use std ; /* should exit with status 6 */ ; const main = { ; 	var a = 42 ; 	var b = 9 ; 	std.exit(a % b) ; } ; \n
use std ;  ; const Bailout : flt64 = 16.0 ; const Maxiter = 1000 ;  ; const mandelbrot = {x, y ; 	var cr, ci, zr, zi ; 	var tmp, zr2, zi2 ; 	var i : int ;  ; 	cr = y - 0.5 ; 	ci = x ; 	zr = 0.0 ; 	zi = 0.0 ;  ; 	i = 0 ;  ; 	while true ; 		i++ ; 		tmp  = zr * zi ; 		zr2 = zr * zr ; 		zi2 = zi * zi ; 		zr = zr2 - zi2 + cr ; 		zi = tmp + tmp + ci ; 		if zi2 + zr2 > Bailout ; 			-> i ; 		;; ; 		if i > Maxiter ; 			-> 0 ; 		;; ; 	;; ; 	-> 0 ; } ;  ; const main = {args : byte[:][:] ; 	var x : flt64, y : flt64, i ;  ; 	for y = -39.0 ;  y < 39.0 ;  y = y + 1.0 ; 		for x = -39.0 ;  x < 39.0 ;  x = x + 1.0 ; 			i = mandelbrot(x/40.0, y/40.0) ; 			if i == 0 ; 				std.put("*") ; 			else ; 				std.put(" ") ; 			;; ; 		;; ; 		std.put("\n") ; 	;; ; 	std.put("\n") ; } ; \n
use std ;  ; const main = { ; 	std.assert('a' == '\u{61}', "unicode char values invalid") ; 	std.assert('Î£' == '\u{03a3}', "unicode char values invalid") ; } ; \n
use std ; /* checks that evaluating a logical and to a bool works. should return 0. */ ; const main = { ; 	std.exit((0 && 1 : int)) ; } ; \n
use std ;  ; type t = union ; 	`U1 ; 	`U2 ; 	`U3 ; 	`U4 ; 	`U5 ; 	`U6 ; 	`U7 ; 	`U8 ; 	`U9 ; 	`U10 ; 	`U11 ; 	`U12 ; 	`U13 ; 	`U14 ; 	`U15 ; 	`U16 ; 	`U17 ; 	`U18 ; 	`U19 ; 	`U20 ; 	`U21 ; 	`U22 ; 	`U23 ; 	`U24 ; 	`U25 ; 	`U26 ; 	`U27 ; 	`U28 ; 	`U29 ; 	`U30 ; 	`U31 ; 	`U32 ; 	`U33 ; 	`U34 ; 	`U35 ; 	`U36 ; 	`U37 ; 	`U38 ; 	`U39 ; 	`U40 ; 	`U41 ; 	`U42 ; 	`U43 ; 	`U44 ; 	`U45 ; 	`U46 ; 	`U47 ; 	`U48 ; 	`U49 ; 	`U50 ; 	`U51 ; 	`U52 ; 	`U53 ; 	`U54 ; 	`U55 ; 	`U56 ; 	`U57 ; 	`U58 ; 	`U59 ; 	`U60 ; 	`U61 ; 	`U62 ; 	`U63 ; 	`U64 ; 	`U65 ; 	`U66 ; 	`U67 ; 	`U68 ; 	`U69 ; 	`U70 ; 	`U71 ; 	`U72 ; 	`U73 ; 	`U74 ; 	`U75 ; 	`U76 ; 	`U77 ; 	`U78 ; 	`U79 ; 	`U80 ; 	`U81 ; 	`U82 ; 	`U83 ; 	`U84 ; 	`U85 ; 	`U86 ; 	`U87 ; 	`U88 ; 	`U89 ; 	`U90 ; 	`U91 ; 	`U92 ; 	`U93 ; 	`U94 ; 	`U95 ; 	`U96 ; 	`U97 ; 	`U98 ; 	`U99 ; 	`U100 ; ;; ;  ; const main = { ; 	std.put("{}\n", `U100) ; } ;  ; \n
use std ;  ; trait name @a = ; 	Name: byte[:] ; ;; ; impl name void = ; 	Name = "zig" ; ;; ; impl name int = ; 	Name = "zag" ; ;; ;  ; const main = { ; 	std.put("{}{}\n", impl(Name, void), impl(Name, int)) ; } ; \n
use std ; /* ; should fail to compile because ; all types matched over should be ; compatible. Strings are not compatible ; with integers. ; */ ; const foo = { ; 	match 123 ; 	|"asdf":	123 ; 	|234567:	888 ; 	;; ; 	std.exit(42) ; } ; \n
use std ; /* checks that evaluating a logical or works. exits with 1. */ ; const main = { ; 	std.exit((0 || 1 : int)) ; } ; \n
use std ;  ;  ; const main = { ; 	type foo = union ; 		`Black ; 		`Blue ; 		`Green ; 		`Red ; 		`Yellow ; 		`White ; 	;; ;  ; 	match `Green ; 	| `Black || `White: std.exit(1) ; 	| `Blue || `Green || `Red: std.put("color\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	match `std.Some 100 ; 	| `std.Some (100 || 200 || 300): std.put("hundreds\n") ; 	| `std.Some _: std.exit(1) ; 	| _: std.exit(1) ; 	;; ;  ; 	match `std.Some (`std.Some 333, 123, 789) ; 	| `std.Some (`std.Some (101||451||789||333), _, _): std.put("good #1\n") ; 	| `std.Some (`std.Some (100||200), 222, 333): std.exit(1) ; 	| `std.Some _: std.exit(1) ; 	| `std.None: std.exit(1) ; 	;; ;  ; 	match 4 ; 	| 1||2||4: std.put("good $2\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	const a = 4 ; 	match 4 ; 	| 1||2||a: std.put("good $3\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	type bar = union ; 		`A int ; 		`B int ; 		`C int ; 		`D (byte[:], int) ; 		`E (byte[:], int) ; 		`F (int, std.option(int)) ; 		`G (int, std.option(int)) ; 	;; ;  ; 	match `A 123 ; 	| `A x || `B x: std.put("good #4 {}\n", x) ; 	| _: std.exit(1) ; 	;; ;  ; 	match `G (223, `std.Some 556) ; 	| `F (x, `std.Some y) || `G (x, `std.Some y): std.put("good #5 x={} y={}\n", x, y) ; 	| _: std.exit(1) ; 	;; ;  ; 	std.put("all good\n") ; } ; \n
use std ; /* checks that we can create arrays without indexed initializers. exits with 2. */ ; const main = { ; 	var a = [1, 3, 2] ; 	std.exit(a[2]) ; } ; \n
