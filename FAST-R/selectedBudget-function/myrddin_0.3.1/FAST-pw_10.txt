use std ;  ; const foo = { ; 	-> (1, 2, (3, 4)) ; } ;  ; const main = { ; 	match foo() ; 	| x: ; 		x.0 = 0 ; 		(x.2).1 = 5 ; 		std.put("a: {}, b: {}, c: {}\n", x.0, x.2.1, foo().1) ; 	;; ; } ; \n
use std ; /* should exit with status 53 */ ; const main = { ; 	var a ; 	var b ; 	var c ;  ; 	a = 42 ; 	b = 11 ; 	c = 0_0 ; 	std.exit(a + b + c) ; } ; \n
use std ; /* should fail because we call f with too many args */ ; const f = {a:int ; 	-> a ; } ;  ; const main = { ; 	std.exit(f(1, 2, 3)) ; } ; \n
use std ; /* tests reading and writing to arrays. should exit with 7 */ ; const main = { ; 	var a : int[3] ; 	a[0] = 3 ; 	a[1] = 4 ; 	a[2] = a[0] + a[1] ; 	std.exit(a[2]) ; } ; \n
use std ; /* tests taking the address of array elements. should exit with 42. */ ; const main = { ; 	var v : int[3] ; 	var p ;  ; 	v[1] = 42 ; 	p = &v[1] ; 	std.exit(p#) ; } ;  ; \n
use std ; /* checks that array lengths work. should exit with 12. */ ; const main = { ; 	var a : int[12] ;  ; 	std.exit(a.len) ; } ; \n
use std ; /* checks that we can create arrays without indexed initializers. exits with 2. */ ; const main = { ; 	var a = [1, 3, 2] ; 	std.exit(a[2]) ; } ; \n
use std ;  ; /* size should be 1 */ ; type alignstruct0 = struct ; 	a : byte ; ;; ;  ; /* size should be 16 */ ; type alignstruct1 = struct ; 	a : byte ; 	b : byte[15] ; ;; ;  ; /* size should be 20 */ ; type alignstruct2 = struct ; 	a : int ; 	b : byte[15] ; 	/* 1 byte padding */ ; ;; ;  ; /* size should be 20 */ ; type alignstruct3 = struct ; 	b : byte[15] ; 	a : int ; ;; ;  ; /* size should be 8 */ ; type alignstruct4 = struct ; 	a : byte ; 	b : int[1] ; ;; ;  ; /* size should be 24 */ ; type alignstruct5 = struct ; 	a : byte ; 	b : byte[:] ; ;; ;  ; /* size should be 8 */ ; type alignstruct6 = struct ; 	a : byte ; 	b : byte ; 	c : byte ; 	d : byte ; 	e : int32 ; ;; ;  ; /* size should be 24 */ ; type alignstruct7 = struct ; 	a : byte ; 	b : int32 ; 	c : byte[:] ; ;; ;  ; const main = { ; 	std.put("size = {}\n", sizeof(alignstruct0)) ; 	std.put("size = {}\n", sizeof(alignstruct1)) ; 	std.put("size = {}\n", sizeof(alignstruct2)) ; 	std.put("size = {}\n", sizeof(alignstruct3)) ; 	std.put("size = {}\n", sizeof(alignstruct4)) ; 	std.put("size = {}\n", sizeof(alignstruct5)) ; 	std.put("size = {}\n", sizeof(alignstruct6)) ; 	std.put("size = {}\n", sizeof(alignstruct7)) ; 	/* size should be 8 */ ; 	std.put("size = {}\n", sizeof((int, byte, byte))) ; 	/* size should be 16 */ ; 	std.put("size = {}\n", sizeof((int, byte, int, byte))) ; 	/* size should be 12 */ ; 	std.put("size = {}\n", sizeof((int, int, byte, byte))) ; } ; \n
use std ;  ; /* checks we can make indexed array literals. exits with 3. */ ; const main = { ; 	var a = [ ; 		.[0] = 1,  ; 		.[2] = 3, ; 		.[1] = 2, ; 	] ; 	std.exit(a[2]) ; } ; \n
use std ;  ; /* test for accidentally packed values */ ; const a = [ ; 	(1, "foo"), ; 	(2, "bar"), ; 	(3, "baz"), ; ] ;  ; const main = { ; 	for x : a[:] ; 		std.put("{}", x) ; 	;; ; 	std.put("\n") ; } ; \n
