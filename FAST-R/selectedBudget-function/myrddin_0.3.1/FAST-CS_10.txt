use std ; /* should exit with status 42 */ ; const main = { ; 	var a ; 	var b ;  ; 	a = 127 ; 	b = 3 ; 	std.exit(a / b) ; } ; \n
type u = union ; 	`Some int ; 	`None ; ;; ;  ; const main = { ; 	var v : u ;  ; 	v = `None ; } ; \n
use std ; /* checks that true complex boolean conditions work. exits with 7. */ ; const main = { ; 	var x = 5, y = 7 ;  ; 	if x == 5 && y == 7 ; 		std.exit(7) ; 	else ; 		std.exit(9) ; 	;; ; } ; \n
use std ;  ; /* size should be 1 */ ; type alignstruct0 = struct ; 	a : byte ; ;; ;  ; /* size should be 16 */ ; type alignstruct1 = struct ; 	a : byte ; 	b : byte[15] ; ;; ;  ; /* size should be 20 */ ; type alignstruct2 = struct ; 	a : int ; 	b : byte[15] ; 	/* 1 byte padding */ ; ;; ;  ; /* size should be 20 */ ; type alignstruct3 = struct ; 	b : byte[15] ; 	a : int ; ;; ;  ; /* size should be 8 */ ; type alignstruct4 = struct ; 	a : byte ; 	b : int[1] ; ;; ;  ; /* size should be 24 */ ; type alignstruct5 = struct ; 	a : byte ; 	b : byte[:] ; ;; ;  ; /* size should be 8 */ ; type alignstruct6 = struct ; 	a : byte ; 	b : byte ; 	c : byte ; 	d : byte ; 	e : int32 ; ;; ;  ; /* size should be 24 */ ; type alignstruct7 = struct ; 	a : byte ; 	b : int32 ; 	c : byte[:] ; ;; ;  ; const main = { ; 	std.put("size = {}\n", sizeof(alignstruct0)) ; 	std.put("size = {}\n", sizeof(alignstruct1)) ; 	std.put("size = {}\n", sizeof(alignstruct2)) ; 	std.put("size = {}\n", sizeof(alignstruct3)) ; 	std.put("size = {}\n", sizeof(alignstruct4)) ; 	std.put("size = {}\n", sizeof(alignstruct5)) ; 	std.put("size = {}\n", sizeof(alignstruct6)) ; 	std.put("size = {}\n", sizeof(alignstruct7)) ; 	/* size should be 8 */ ; 	std.put("size = {}\n", sizeof((int, byte, byte))) ; 	/* size should be 16 */ ; 	std.put("size = {}\n", sizeof((int, byte, int, byte))) ; 	/* size should be 12 */ ; 	std.put("size = {}\n", sizeof((int, int, byte, byte))) ; } ; \n
use std ; /* checks that types do not contain themselves ; inline, because that would lead to an infinite ; sized type. ; */ ;  ; type t = struct ; 	memb : t ; ;; ;  ; var v : t ; \n
use std ;  ; const slpart = array[1:3] ; const slfull = array[:] ; const slinline = [6,7,8][:] ; const array = [1,2,3,4,5] ;  ; const main = { ; 	/* expected output 23 */ ; 	for x : slpart ; 		std.put("{}", x) ; 	;; ; 	/* expected output 12345 */ ; 	for x : slfull ; 		std.put("{}", x) ; 	;; ; 	/* expected output 678 */ ; 	for x : slinline ; 		std.put("{}", x) ; 	;; ; 	std.put("\n") ; } ; \n
use std ;  ; /* checks that we can create struct literals with named initializers. ; 	exits with 42. */ ; type t = struct ; 	a	: int ; 	b	: char ; 	c	: byte[:] ; ;; ;  ; const main = { ; 	var v : t ;  ; 	v = [.a=42, .b='x', .c="foo"] ; 	std.exit(v.a) ; } ;  ; \n
/* test the allocation of slices. should return 123 */ ; use std ;  ; const main = { ; 	var sl : int[:] ;  ; 	sl = std.slalloc(123) ; 	sl[0] = 42 ; 	sl[122] = 1 ; 	std.exit(sl.len) ; } ; \n
use std ; /* checks that sizeof() works. exits with 4. */ ; const main = { ; 	std.exit(sizeof(int)) ; } ; \n
use std ; /* should assign a slice through an out param, returning exiting with 2 */ ; const arr = [1,2,3,4] ; const f = {out ; 	out# = arr[1:3] ; } ;  ; const main = { ; 	var v ;  ; 	f(&v) ; 	std.exit(v[0]) ; } ; \n
