use std ;  ; const main = { ; 	std.put("{},{}\n", a(), b()) ; } ;  ; const a = { ; 	-> 42 ; } ;  ; const b = { ; 	-> (33 : int16) ; } ; \n
use std ;  ; const abs = {d ; 	if d < 0.0 ; 		-> -d ; 	else ; 		-> d ; 	;; ; } ;  ; const Eps = 0.00001 ; const Maxiter = 20 ;  ; const sqrt = {x : flt64 ; 	var val ; 	var iter ; 	var i ;  ;  ; 	val = 1.0 ;  ; 	for i = 0 ;  i < Maxiter ;  i++ ; 		iter = 0.5*(val + x/val) ; 		if abs(val - iter) < Eps ; 			-> val ;  ; 		;; ; 		val = iter ;  ; 	;; ; 	-> val ; } ;  ; const main = { ; 	var r ;  ; 	r = (sqrt(20.0) : int) ; 	std.exit(r) ; } ;  ; \n
use std ;  ; const foo = { ; 	-> (1, 2, (3, 4)) ; } ;  ; const main = { ; 	match foo() ; 	| x: ; 		x.0 = 0 ; 		(x.2).1 = 5 ; 		std.put("a: {}, b: {}, c: {}\n", x.0, x.2.1, foo().1) ; 	;; ; } ; \n
/* checks that our slice grow function works. exits with 42. */ ; use std ;  ; const main = { ; 	var sl ;  ; 	sl = std.slalloc(42) ; 	sl[0] = 12 ; 	std.slgrow(&sl, 123) ; 	sl[122] = 30 ; 	std.exit(sl[0] + sl[122]) ; } ; \n
use std ;  ; type u = union ; 	`Foo int ; 	`Bar char ; 	`Baz byte ; ;; ;  ; type s = struct ; 	x : int ; 	y : char ; 	z : byte ; ;; ;  ; generic expect = {a : @a, b : @a, expected : bool ; 	var actual ;  ; 	if a == b ; 		actual = true ; 	else ; 		actual = false ; 	;; ; 	if actual == expected ; 		std.put("a == b: expected: {}, got, {}: pass\n", expected, actual) ; 	else ; 		std.put("a == b: expected: {}, got, {}: fail\n", expected, actual) ; 	;; ; } ;  ; const main = { ; 	var u1 : u, u2 : u ; 	var s1 : s, s2 : s ;  ; 	/* equal */ ; 	u1 = `Foo 123 ; 	u2 = `Foo 123 ; 	expect(u1, u2, true) ; 	s1 = [.x=123, .y='a', .z=55] ; 	s2 = [.x=123, .y='a', .z=55] ; 	expect(s1, s2, true) ;  ; 	/* varying first values */ ; 	u1 = `Foo 123 ; 	u2 = `Bar 'x' ; 	expect(u1, u2, false) ; 	s1 = [.x=124, .y='a', .z=55] ; 	s2 = [.x=123, .y='a', .z=55] ; 	expect(s1, s2, false) ;  ; 	/* varying later values  */ ; 	u1 = `Foo 123 ; 	u2 = `Foo 124 ; 	expect(u1, u2, false) ; 	s1 = [.x=123, .y='b', .z=55] ; 	s2 = [.x=123, .y='c', .z=55] ; 	expect(s1, s2, false) ; 	u1 = `Bar 'x' ; 	u2 = `Bar 'y' ; 	expect(u1, u2, false) ; 	s1 = [.x=123, .y='b', .z=57] ; 	s2 = [.x=123, .y='b', .z=56] ; 	expect(s1, s2, false) ; } ;  ;  ; \n
use std ;  ;  ; const main = { ; 	type foo = union ; 		`Black ; 		`Blue ; 		`Green ; 		`Red ; 		`Yellow ; 		`White ; 	;; ;  ; 	match `Green ; 	| `Black || `White: std.exit(1) ; 	| `Blue || `Green || `Red: std.put("color\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	match `std.Some 100 ; 	| `std.Some (100 || 200 || 300): std.put("hundreds\n") ; 	| `std.Some _: std.exit(1) ; 	| _: std.exit(1) ; 	;; ;  ; 	match `std.Some (`std.Some 333, 123, 789) ; 	| `std.Some (`std.Some (101||451||789||333), _, _): std.put("good #1\n") ; 	| `std.Some (`std.Some (100||200), 222, 333): std.exit(1) ; 	| `std.Some _: std.exit(1) ; 	| `std.None: std.exit(1) ; 	;; ;  ; 	match 4 ; 	| 1||2||4: std.put("good $2\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	const a = 4 ; 	match 4 ; 	| 1||2||a: std.put("good $3\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	type bar = union ; 		`A int ; 		`B int ; 		`C int ; 		`D (byte[:], int) ; 		`E (byte[:], int) ; 		`F (int, std.option(int)) ; 		`G (int, std.option(int)) ; 	;; ;  ; 	match `A 123 ; 	| `A x || `B x: std.put("good #4 {}\n", x) ; 	| _: std.exit(1) ; 	;; ;  ; 	match `G (223, `std.Some 556) ; 	| `F (x, `std.Some y) || `G (x, `std.Some y): std.put("good #5 x={} y={}\n", x, y) ; 	| _: std.exit(1) ; 	;; ;  ; 	std.put("all good\n") ; } ; \n
use std ; /* checks pattern matching on unions with arguments. ; exits with 42. */ ; type u = union ; 	`Int int ; 	`Str byte[:] ; 	`Nil ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Str "foo" ; 	match v ; 	| `Int 127: std.exit(42) ; 	| `Str s: std.put("{}\n", s) ; 	| `Nil: ; 	| _:	std.die("Impossible match failure\n") ; 	;; ; } ;  ; \n
use std  ;  /* checks if recursive functions work. should return 21. */  ;  const fib = {n  ;  	if n <= 0  ;  		-> 0  ;  	elif n == 1  ;  		-> 1  ;  	else  ;  		-> fib(n - 1) + fib(n - 2)  ;  	;;  ;  }  ;    ;  const main = {  ;  	std.exit(fib(8))  ;  }  ;    ;  \n
use std ;  ; type t = struct ; 	x : union ; 		`Int int ; 		`Str byte[:] ; 	;; ; ;; ;  ; const main = { ; 	var a : t ;  ; 	a = [.x = `Str "asdf"] ; 	match a ; 	| [.x=`Str s]:	std.put("{}\n", s) ; 	| _:	std.die("Impossible match failure\n") ; 	;; ; } ;  ; \n
use std ; /* checks that types do not contain themselves ; inline, because that would lead to an infinite ; sized type. ; */ ;  ; type t = struct ; 	memb : t ; ;; ;  ; var v : t ; \n
