use std ; /* should exit with status 53 */ ; const main = { ; 	var a ; 	var b ; 	var c ;  ; 	a = 42 ; 	b = 11 ; 	c = 0_0 ; 	std.exit(a + b + c) ; } ; \n
use std ;  ; /* size should be 1 */ ; type alignstruct0 = struct ; 	a : byte ; ;; ;  ; /* size should be 16 */ ; type alignstruct1 = struct ; 	a : byte ; 	b : byte[15] ; ;; ;  ; /* size should be 20 */ ; type alignstruct2 = struct ; 	a : int ; 	b : byte[15] ; 	/* 1 byte padding */ ; ;; ;  ; /* size should be 20 */ ; type alignstruct3 = struct ; 	b : byte[15] ; 	a : int ; ;; ;  ; /* size should be 8 */ ; type alignstruct4 = struct ; 	a : byte ; 	b : int[1] ; ;; ;  ; /* size should be 24 */ ; type alignstruct5 = struct ; 	a : byte ; 	b : byte[:] ; ;; ;  ; /* size should be 8 */ ; type alignstruct6 = struct ; 	a : byte ; 	b : byte ; 	c : byte ; 	d : byte ; 	e : int32 ; ;; ;  ; /* size should be 24 */ ; type alignstruct7 = struct ; 	a : byte ; 	b : int32 ; 	c : byte[:] ; ;; ;  ; const main = { ; 	std.put("size = {}\n", sizeof(alignstruct0)) ; 	std.put("size = {}\n", sizeof(alignstruct1)) ; 	std.put("size = {}\n", sizeof(alignstruct2)) ; 	std.put("size = {}\n", sizeof(alignstruct3)) ; 	std.put("size = {}\n", sizeof(alignstruct4)) ; 	std.put("size = {}\n", sizeof(alignstruct5)) ; 	std.put("size = {}\n", sizeof(alignstruct6)) ; 	std.put("size = {}\n", sizeof(alignstruct7)) ; 	/* size should be 8 */ ; 	std.put("size = {}\n", sizeof((int, byte, byte))) ; 	/* size should be 16 */ ; 	std.put("size = {}\n", sizeof((int, byte, int, byte))) ; 	/* size should be 12 */ ; 	std.put("size = {}\n", sizeof((int, int, byte, byte))) ; } ; \n
use std ; /* should fail because we call f with too many args */ ; const f = {a:int ; 	-> a ; } ;  ; const main = { ; 	std.exit(f(1, 2, 3)) ; } ; \n
use std ; /* should fail because we call f with too few args */ ; const f = {a:int, b:int, c:int ; 	-> a + b + c ; } ;  ; const main = { ; 	std.exit(f(1, 2)) ; } ; \n
use std ; /* tests reading and writing to arrays. should exit with 7 */ ; const main = { ; 	var a : int[3] ; 	a[0] = 3 ; 	a[1] = 4 ; 	a[2] = a[0] + a[1] ; 	std.exit(a[2]) ; } ; \n
use std ; /* tests taking the address of array elements. should exit with 42. */ ; const main = { ; 	var v : int[3] ; 	var p ;  ; 	v[1] = 42 ; 	p = &v[1] ; 	std.exit(p#) ; } ;  ; \n
use std ; /* checks that array lengths work. should exit with 12. */ ; const main = { ; 	var a : int[12] ;  ; 	std.exit(a.len) ; } ; \n
use std ; /* checks that we can create arrays without indexed initializers. exits with 2. */ ; const main = { ; 	var a = [1, 3, 2] ; 	std.exit(a[2]) ; } ; \n
use std ;  ; /* checks we can make indexed array literals. exits with 3. */ ; const main = { ; 	var a = [ ; 		.[0] = 1,  ; 		.[2] = 3, ; 		.[1] = 2, ; 	] ; 	std.exit(a[2]) ; } ; \n
use std ;  ; /* test for accidentally packed values */ ; const a = [ ; 	(1, "foo"), ; 	(2, "bar"), ; 	(3, "baz"), ; ] ;  ; const main = { ; 	for x : a[:] ; 		std.put("{}", x) ; 	;; ; 	std.put("\n") ; } ; \n
use std ;  ; const keq = {a, b ;     std.put("{}\n", b[0]) ; } ;  ; const main = {args : byte[:][:] ;     var k : byte[5] ;  ;     k = [1,2,3,4,5] ;     keq(k, k) ; } ; \n
use std ;  ; const main = { ; 	var x ; 	x = "a" + "b" ; } ; \n
use std ;  ; const get42 = { ; 	-> 42.0 ; } ;  ; /* basic sanity check on floating point operations. should return 84. */ ; const main = { ; 	std.exit((42.0 + get42() : int)) ; } ; \n
use std ;  ; type u = union ; 	`Foo int ; 	`Bar char ; 	`Baz byte ; ;; ;  ; type s = struct ; 	x : int ; 	y : char ; 	z : byte ; ;; ;  ; generic expect = {a : @a, b : @a, expected : bool ; 	var actual ;  ; 	if a == b ; 		actual = true ; 	else ; 		actual = false ; 	;; ; 	if actual == expected ; 		std.put("a == b: expected: {}, got, {}: pass\n", expected, actual) ; 	else ; 		std.put("a == b: expected: {}, got, {}: fail\n", expected, actual) ; 	;; ; } ;  ; const main = { ; 	var u1 : u, u2 : u ; 	var s1 : s, s2 : s ;  ; 	/* equal */ ; 	u1 = `Foo 123 ; 	u2 = `Foo 123 ; 	expect(u1, u2, true) ; 	s1 = [.x=123, .y='a', .z=55] ; 	s2 = [.x=123, .y='a', .z=55] ; 	expect(s1, s2, true) ;  ; 	/* varying first values */ ; 	u1 = `Foo 123 ; 	u2 = `Bar 'x' ; 	expect(u1, u2, false) ; 	s1 = [.x=124, .y='a', .z=55] ; 	s2 = [.x=123, .y='a', .z=55] ; 	expect(s1, s2, false) ;  ; 	/* varying later values  */ ; 	u1 = `Foo 123 ; 	u2 = `Foo 124 ; 	expect(u1, u2, false) ; 	s1 = [.x=123, .y='b', .z=55] ; 	s2 = [.x=123, .y='c', .z=55] ; 	expect(s1, s2, false) ; 	u1 = `Bar 'x' ; 	u2 = `Bar 'y' ; 	expect(u1, u2, false) ; 	s1 = [.x=123, .y='b', .z=57] ; 	s2 = [.x=123, .y='b', .z=56] ; 	expect(s1, s2, false) ; } ;  ;  ; \n
use std ;  ; const main = { ; 	std.put("{}\n", (34359738368 : int64)) ; } ; \n
use std ;  ; type t = union ; 	`U1 ; 	`U2 ; 	`U3 ; 	`U4 ; 	`U5 ; 	`U6 ; 	`U7 ; 	`U8 ; 	`U9 ; 	`U10 ; 	`U11 ; 	`U12 ; 	`U13 ; 	`U14 ; 	`U15 ; 	`U16 ; 	`U17 ; 	`U18 ; 	`U19 ; 	`U20 ; 	`U21 ; 	`U22 ; 	`U23 ; 	`U24 ; 	`U25 ; 	`U26 ; 	`U27 ; 	`U28 ; 	`U29 ; 	`U30 ; 	`U31 ; 	`U32 ; 	`U33 ; 	`U34 ; 	`U35 ; 	`U36 ; 	`U37 ; 	`U38 ; 	`U39 ; 	`U40 ; 	`U41 ; 	`U42 ; 	`U43 ; 	`U44 ; 	`U45 ; 	`U46 ; 	`U47 ; 	`U48 ; 	`U49 ; 	`U50 ; 	`U51 ; 	`U52 ; 	`U53 ; 	`U54 ; 	`U55 ; 	`U56 ; 	`U57 ; 	`U58 ; 	`U59 ; 	`U60 ; 	`U61 ; 	`U62 ; 	`U63 ; 	`U64 ; 	`U65 ; 	`U66 ; 	`U67 ; 	`U68 ; 	`U69 ; 	`U70 ; 	`U71 ; 	`U72 ; 	`U73 ; 	`U74 ; 	`U75 ; 	`U76 ; 	`U77 ; 	`U78 ; 	`U79 ; 	`U80 ; 	`U81 ; 	`U82 ; 	`U83 ; 	`U84 ; 	`U85 ; 	`U86 ; 	`U87 ; 	`U88 ; 	`U89 ; 	`U90 ; 	`U91 ; 	`U92 ; 	`U93 ; 	`U94 ; 	`U95 ; 	`U96 ; 	`U97 ; 	`U98 ; 	`U99 ; 	`U100 ; ;; ;  ; const main = { ; 	std.put("{}\n", `U100) ; } ;  ; \n
const main = { ; 	var a : byte[:] = [1, 2, 3][:] ; 	var b = a[:4] ; } ; \n
use std ; /* should exit with status 5 */ ; const main = { ; 	var a = 42 ; 	std.exit(a >> 3) ; } ; \n
use std ; /* checks that simple function calls work. should exit with 42. */ ; const f = { ; 	-> 21 ; } ;  ; const main = { ; 	std.exit(f() + f()) ; } ; \n
use std ; /* checks that calls with large return values (ie, ones that don't fit in a ; * register) works correctly. Should exit with 42. */ ; type pair = struct ; 	a : int ; 	b : int ; ;; ;  ; const f = {s ; 	-> s.a  + s.b ; } ;  ; const main = { ; 	var s : pair ; 	s.a = 12 ; 	s.b = 30 ; 	std.exit(f(s)) ; } ; \n
/* checks that we can read a data file. */ ; use std ;  ; const main = {args : byte[:][:] ; 	var r ;  ; 	r = std.slurp("data/catfile-in") ; 	match r ; 	| `std.Ok dat: 	std.write(1, dat) ; 	| `std.Err msg:	std.put("Failed to read file: {}\n", msg) ; 	;; ; } ;  ; \n
use std ;  ; const main = { ; 	std.assert('a' == '\u{61}', "unicode char values invalid") ; 	std.assert('Σ' == '\u{03a3}', "unicode char values invalid") ; } ; \n
use std ;  ; const main = { ; 	var a, b, c, fn ;  ; 	a = 111 ; 	b = 555 ; 	c = 333 ; 	fn = { ; 		var x ;  ; 		x = 666 ; 		std.put("{}{}{}{}\n", a, b, c, x) ; 	} ; 	fn() ; } ; \n
use std ;  ; const main = { ; 	const fib = {n ; 		if n <= 0 ; 			-> 0 ; 		elif n == 1 ; 			-> 1 ; 		else ; 			-> fib(n - 1) + fib(n - 2) ; 		;; ; 	} ; 	std.exit(fib(8)) ; } ;  ; \n
use std ;  ; trait frobable @a = ; 	frob	: (val : @a -> void) ; ;; ;  ; impl frobable int# = ; 	frob = {val ; 		std.put("intptr,") ; 	} ; ;; ;  ; impl frobable char# = ; 	frob = {val ; 		std.put("charptr\n") ; 	} ; ;; ;  ; generic foo = {x : @a :: frobable @a ; 	frob(x) ; } ;  ; const main = { ; 	var a = (123 : int) ; 	var b = 'c' ; 	foo(&a) ; 	foo(&b) ; } ;  ; \n
use std ; /* checks that false conditions lead to the false branch of an if statement. ; * should exit with 9. */ ; const main = { ; 	var x = 5, y = 7 ;  ; 	if x == 7 && y == 5 ; 		std.exit(7) ; 	else ; 		std.exit(9) ; 	;; ; } ; \n
use std ; /* checks if relatonal operators work. should exit with 9. */ ; const main = { ; 	var x = 3, y = 9 ;  ; 	if x < 5 && y > 7 ; 		std.exit(7) ; 	else ; 		std.exit(9) ; 	;; ; } ; \n
use std ; /* checks that true complex boolean conditions work. exits with 7. */ ; const main = { ; 	var x = 5, y = 7 ;  ; 	if x == 5 && y == 7 ; 		std.exit(7) ; 	else ; 		std.exit(9) ; 	;; ; } ; \n
use std ;  ; const slpart = array[1:3] ; const slfull = array[:] ; const slinline = [6,7,8][:] ; const array = [1,2,3,4,5] ;  ; const main = { ; 	/* expected output 23 */ ; 	for x : slpart ; 		std.put("{}", x) ; 	;; ; 	/* expected output 12345 */ ; 	for x : slfull ; 		std.put("{}", x) ; 	;; ; 	/* expected output 678 */ ; 	for x : slinline ; 		std.put("{}", x) ; 	;; ; 	std.put("\n") ; } ; \n
use std ;  ; const x = `std.Some "thing" ;  ; const main = { ; 	std.put("{}\n", x) ; } ; \n
use std ;  ; type range = struct ; 	lo	: int ; 	hi	: int ; ;; ;  ; /* iterate up to 100 */ ; impl iterable range -> int = ;         __iternext__ = {rng, output ; 		if rng.lo > rng.hi ; 			-> false ; 		else ; 			output# = rng.lo++ ;                         -> true ;                 ;; ;         } ;  ;         __iterfin__ = {it, val ;         } ; ;; ;  ; const main = { ; 	var r : range ; 	var x : int ;  ; 	r = [.lo=6, .hi=11] ; 	for v : r ; 		x = v ;                 std.put("{}", x) ;         ;; ; 	std.put("\n") ; } ; \n
use std ; /* ; should fail to compile with a type error. ; char is incompatible with int. ; */ ; const main = { ; 	var a : int ; 	var b : char ;  ; 	a = b ; } ; \n
use std ; /* should assign to v through pointer p, exiting with 123 */ ; const main = { ; 	var p ; 	var v ;  ; 	v = 0 ; 	p = &v ; 	p# = 123 ; 	std.exit(v) ; } ; \n
use std ;  ; const main = { ;     var a,b ;     ((a, b), _) = ((1, 2), 3) ;     std.assert(a+b == 3, "fail\n") ; } ; \n
use std ; /* should exit with status 42 */ ; const main = { ; 	var a ; 	var b ;  ; 	a = 127 ; 	b = 3 ; 	std.exit(a / b) ; } ; \n
use std ;  ; const main = { ; 	std.put("{},{}\n", a(), b()) ; } ;  ; const a = { ; 	-> 42 ; } ;  ; const b = { ; 	-> (33 : int16) ; } ; \n
use std ;  ; type foo = struct ; ;; ;  ; type bar = struct ;         baz : foo[:] ;         quux : foo[0][:] ; ;; ;  ;  ; const main = { ;         var a : foo ;         var z : foo[0] ;         var b : bar = [.baz = [a, a][:], .quux = [z, z, z][:]] ;         var c : int = 0 ;         for f : b.baz ;                 c += 3 ;         ;; ;  ;         for f : b.quux ;                 c += 5 ;         ;; ;  ;         std.exit(c) ; } ; \n
use std ;  ; trait fooable @a = ; ;; ;  ; impl fooable int = ; ;; ;  ; generic foo = {x : @a::fooable @a ; 	-> x ; } ;  ; const main = { ; 	std.exit(foo(123)) ; } ;  ; \n
/* checks that we can decode and encode characters from a utf8 string. */ ; use std ;  ; const main = {args : byte[:][:] ; 	chartypes() ; } ;  ; const chartypes = { ; 	var s ; 	var foo ; 	var buf : byte[32] ;  ; 	s = "1世界äa\n" ; 	for c : std.bychar(s) ; 		foo = c ; 		if std.encode(buf[:std.charlen(c)], c) == 0 ; 			std.write(1, "couldn't encode\n") ; 		;; ; 		std.write(1, buf[:std.charlen(c)]) ; 	;; ; } ; \n
use std ; /* This test checks that cyclic types will be output ;  * by muse. */ ; pkg = ; 	type list = struct ; 		next	: list# ; 		val	: int ; 	;; ; ;; ;  ; const main = { ; } ; \n
use std ;  ; pkg = ; 	const foo	: (val:int -> int) ; ;; ;  ;  ; const foo = {val ; 	-> val ; } ;  ; const main = { ; 	std.exit(foo(42)) ; } ; \n
use std ;  ; pkg = ; 	trait t @a ;  ; 	impl t int ; ;; ;  ; trait t @a = ; 	frob    : (v : @a -> @a) ; ;; ;  ; impl t int = ; 	frob = {v ; 		-> v*2 ; 	} ; ;; ;  ; /* shut up the linker: we just want to compile this. */ ; const main = { ; } ; \n
use std  ;  /* checks if recursive functions work. should return 21. */  ;  const fib = {n  ;  	if n <= 0  ;  		-> 0  ;  	elif n == 1  ;  		-> 1  ;  	else  ;  		-> fib(n - 1) + fib(n - 2)  ;  	;;  ;  }  ;    ;  const main = {  ;  	std.exit(fib(8))  ;  }  ;    ;  \n
use std ;  ; const main = { ; 	std.put("{}\n", std.abs(-42.0)) ; } ; \n
use std ;  ; pkg =  ;     type msg = union ;         `Tversion   tversion ;     ;; ;     type tversion = struct ;         tag : uint16 ;         version : byte[:] ;     ;; ; ;; ;  ; const main = { ;     var msg=`Tversion [.tag=45, .version="9P2000"] ;     std.put("{}\n", msg) ; } ;  ; \n
use std ;  ; type foo = struct ;         f2 : uint8 ;         f3 : (uint8, flt64) ; ;; ;  ; const main = { ;         var f : foo = [  .f2 = 2, .f3 = (3, 4.4) ] ;         var str = std.fmt("{}", f) ;         for var j = 0 ;  j < str.len ;  ++j ;                 /* Try not to accidentally create any shell characters */ ;                 if str[j] == ('(' : byte) || str[j] == (')' : byte) || str[j] == ('[' : byte) || str[j] == (']' : byte) || str[j] == (' ' : byte) || str[j] == ('=' : byte) ;                         str[j] = ('_' : byte) ;                 ;; ;         ;; ;         std.put("{}\n", str) ; } ; \n
use std ;  ; const main = { ; 	var fn, envfn ; 	var ptr ; 	 ; 	fn = { ; 	} ; 	ptr = (fn : byte#) ; 	ptr = (envfn : byte#) ; 	envfn = { ; 		ptr = ptr ; 	} ; 	std.put("ok\n") ; } ;  ; \n
use std ;  ; type xy = struct ; 	x : int ; 	y : int ; ;; ; const X = 123 ; const Y = 456 ; const z : xy[1] = [ ; 	[.x = X, .y = Y] ; ] ;  ; const main = { ; 	std.put("{},{}\n", z[0].x, z[0].y) ; } ;  ; \n
use std ;  ; const main = { ; 	var i ; 	 ; 	for i = 0 ;   ;  i++ ; 		if i == 10 ; 			break ; 		;; ; 	;; ; 	if i != 10 ; 		std.exit(1) ; 	;; ; 	 ; 	i = 0 ; 	for var j = 0 ;   ;  j++ ; 		if j == 10 ; 			break ; 		;; ; 		i++ ; 	;; ; 	if i != 10 ; 		std.exit(2) ; 	;; ; 	 ; 	i = 0 ; 	for  ;   ;  ; 		i++ ; 		if i == 10 ; 			break ; 		;; ; 	;; ; 	if i != 10 ; 		std.exit(3) ; 	;; ; 	 ; 	i = 0 ; 	for  ;  i < 10 ;  ; 		i++ ; 	;; ; 	if i != 10 ; 		std.exit(4) ; 	;; ; 	 ; 	for i = 0  ;   ;  ; 		if i == 10 ; 			break ; 		;; ; 		i++ ; 	;; ; 	if i != 10 ; 		std.exit(5) ; 	;; ; 	 ; 	i = 0 ; 	for  ;   ;  i++ ; 		if i == 10 ; 			break ; 		;; ; 	;; ; 	if i != 10 ; 		std.exit(6) ; 	;; ; 	std.put("pass\n") ; } ; \n
use std ; /* ; should fail to compile because generic types ; are only allowed in generic declarations. ; */ ; const foo = {v : @a ; 	-> v ; } ; \n
use std ; /* checks that simple generics are specialized correctly. exits with 42. */ ; generic id = {a:@a ; 	-> a ; } ;  ; const main = { ; 	id("adsf") ; 	std.exit(id(42)) ; } ;  ; \n
use std ; /* checks that generics can call non-generics. exits with 42. */ ; const f = { ; 	-> 42 ; } ;  ; const main = { ; 	id("adsf") ; 	std.exit(id(42)) ; } ;  ; generic id = {a:@a ; 	-> f() ; } ;  ; \n
use std ;  ; generic fail = {val : @a ; 	-> `std.Some val ; } ;  ; generic try = {opt : std.option(@b) ; 	match opt ; 	| `std.Some v:	-> v ; 	| `std.None:	std.die("Badness\n") ; 	;; ; } ;  ; const main = { ; 	std.put("val = {}\n", try(fail(123))) ; } ; \n
use std ;  ; trait gimpl @a = ; 	desc	: (x : @a -> byte[:]) ; ;; ;  ; impl gimpl int = ; 	desc = {x ; 		-> "int" ; 	} ; ;; ;  ; impl gimpl byte[:] = ; 	desc = {x ; 		-> "string" ; 	} ; ;; ;  ; impl gimpl @a = ; 	desc = {x ; 		-> "@a" ; 	} ; ;; ;  ; impl gimpl @b[:] = ; 	desc = {x ; 		-> "@a[:]" ; 	} ; ;; ;  ; const main = { ; 	std.put("{} {} {} {}\n", desc(123), desc("foo"), desc('x'), desc([true][:])) ; } ; \n
use std ;  ; type t(@ty) = union ; 	`Some @ty ; 	`None ; ;; ;  ; const make = {v ; 	-> `Some v ; } ;  ; const main = { ; 	var x ;  ; 	x = make(123) ; 	match x ; 	| `Some v:	std.put("val = {}\n", v) ; 	| `None:	std.die("Unreachable\n") ; 	;; ; } ; \n
use std ;  ; type t(@a) = union ; 	`Foo @a ; 	`Bar ; ;; ;  ; const main = { ; 	match `Foo 123 ; 	| `Foo a:	std.exit(0xf) ; 	| `Bar:		std.exit(0x0) ; 	;; ; } ; \n
use std ; /* test that generic types can be recursive, as long as they're not self ;  * including. This just needs to compile and exit with 0. */ ; type list(@t) = struct ; 	val	: @t ; 	next	: list(@t)# ; ;; ;  ; const main = { ; 	var v : list(int) ;  ; 	v.val = 123 ; 	v.next = std.alloc() ; 	v.next.val = 234 ; 	var n = std.alloc() ; 	v.next.next = n ; 	n.val = 345 ; } ; \n
use std ;  ; type t(@a) = union ; 	`Val @a ; 	`None ; ;; ;  ; const f = {-> t(int) ; 	-> `None ; } ;  ; const main = { ; 	match f() ; 	| `None:	std.exit(42) ; 	| _:		std.die("Impossible match failure\n") ;  ; 	;; ; 	std.exit(0) ; } ; \n
use std ;  ; /* checks that parameterized types work. exits with 0. */ ; type option(@a) :: integral,numeric @a = union ; 	`Some @a ; 	`None ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Some 123 ; 	match v ; 	| `None:	std.exit(1) ; 	| `Some 123:	std.exit(0) ; 	| `Some _:	std.die("Impossible match failure\n") ; 	;; ; 	std.exit(60) ; } ; \n
use std ;  ; generic work = {val : @a ; 	-> `std.Some val ; } ;  ; const main = { ; 	work(123) ; 	std.exit(42) ; } ; \n
use std ;  ; generic Foo : @a = 42 :: integral,numeric @a ;  ; const main = { ; 	std.exit(Foo) ; } ;  ; \n
use std ; /* tests that global arrays work as expected, and are zero-initialized by ; * default. should exit with 7 */ ; var a : int[10] ;  ; const main = { ; 	a[0] = 3 ; 	a[1] = 4 ; 	std.exit(a[0] + a[1] + a[2] + a[3]) ; } ; \n
use std ; /* checks that sizeof works on generics. exits with 5. */ ; generic sz = {a:@a ; 	-> sizeof(@a) ; } ;  ; const main = { ; 	std.exit(sz(123) + sz("asdf"[0])) ; } ; \n
use std ;  ; trait comparable @a = ; 	cmp	: (a : @a, b : @a -> std.order) ; ;; ;  ; impl comparable @a :: numeric @a = ; 	cmp = {a, b ; 		-> std.numcmp(a, b) ; 	} ; ;; ;  ; const main = { ; 	std.put("{}", cmp(1, 2)) ; } ; \n
/* checks that this program prints Hello-世界\n */ ; use std ;  ; const main = {args : byte[:][:] ; 	std.write(1, "Hello-世界\n") ; } ;  ; \n
use std ;  ; trait name @a = ; 	Name: byte[:] ; ;; ; impl name void = ; 	Name = "zig" ; ;; ; impl name int = ; 	Name = "zag" ; ;; ;  ; const main = { ; 	std.put("{}{}\n", impl(Name, void), impl(Name, int)) ; } ; \n
use std ;  ; trait favorite @a = ; 	Fav : @a ; ;; ; impl favorite int = ; 	Fav = 12 ; ;; ; impl favorite char = ; 	Fav = 'z' ; ;; ; impl favorite byte[:] = ; 	Fav = "hello" ; ;; ;  ; const main = { ; 	std.put("{},{},{}\n", impl(Fav, int), impl(Fav, char), impl(Fav, byte[:])) ; } ; \n
use std ; use sys ;  ; const main = { ; 	var x : std.size ; 	var y : std.off ; 	var z : sys.fd ; } ; \n
use std ;  ; var i = 0 ; const f = { ; 	-> i++ ; } ;  ; const main = { ; 	f() ; 	std.exit(i) ; } ; \n
use std ;  ; type u = union ; 	`Foo ; 	`Bar int ; ;; ;  ; const f = {v : int -> u ; 	-> `Bar v ; } ;  ; const main = { ; 	var v ;  ; 	v = f(99) ; 	match v ; 	| `Foo:		std.exit(1) ; 	| `Bar x:	std.exit(x) ; 	;; ; 	std.exit(2) ; } ; \n
use std ; /* ; should fail to compile after infering that a is a float, b is a char, and ; the types are incompatible. ; */ ; const main = { ; 	var a ; 	var b ;  ; 	a = 1.0 ; 	b = 'a' ; 	a = b ; } ; \n
use std ;  ; pkg = ;     type qid = struct ;         ty  : uint8 ;         path    : uint64 ;     ;; ;  ;     type stat = struct ;         dev : uint32 ;         qid : qid ;     ;; ; ;; ;  ; const main = { ;     var stat : stat = [.dev=0, .qid=[.ty=0, .path=0]] ;     std.assert(stat.qid.path == 0, "fail\n") ; } ; \n
use std ;  ; const main = { ; 	var v ;  ; 	v = [foo(), 42, 123] ; 	std.exit(v[0]) ; } ;  ; const foo = { ; 	-> 21  ; } ; \n
use std ;  ; /* checks that we can create struct literals with named initializers. ; 	exits with 42. */ ; type t = struct ; 	a	: int ; 	b	: byte ; 	c	: byte[:] ; ;; ;  ; const main = { ; 	var v : t ;  ; 	v = [.a=foo(), .b=42, .c="foo"] ; 	std.exit(v.a) ; } ;  ; const foo = { ; 	-> 21  ; } ; \n
use std ;  ; const main = { ; 	goto foo ; 	std.exit(123) ; :foo ; 	std.exit(bar()) ; } ;  ; const bar = { ; 	goto foo ; 	-> 42 ; :foo ; 	-> 10 ; } ; \n
use std ; /* checks that evaluating a logical and to a bool works. should return 0. */ ; const main = { ; 	std.exit((0 && 1 : int)) ; } ; \n
use std ; /* checks that evaluating a logical or works. exits with 1. */ ; const main = { ; 	std.exit((0 || 1 : int)) ; } ; \n
use std ; /* checks that loops work. */ ; const main = { ; 	var i ; 	var n ;  ; 	n = 0 ; 	for i = 0 ;  i < 5 ;  ++i ; 		std.put("{}", i) ; 	;; ; 	for i = 0 ;  i < 5 ;  ++i ; 		if i > 3 ; 			break ; 		;; ; 		std.put("{}", i) ; 	;; ; 	for i = 0 ;  i < 10 ;  ++i ; 		if i < 6 ; 			continue ; 		;; ; 		std.put("{}", i) ; 	;; ; 	std.put("\n") ; } ; \n
use std ; /* should exit with status 0 */ ; const main = { ; } ; \n
use std ;  ; const Bailout : flt64 = 16.0 ; const Maxiter = 1000 ;  ; const mandelbrot = {x, y ; 	var cr, ci, zr, zi ; 	var tmp, zr2, zi2 ; 	var i : int ;  ; 	cr = y - 0.5 ; 	ci = x ; 	zr = 0.0 ; 	zi = 0.0 ;  ; 	i = 0 ;  ; 	while true ; 		i++ ; 		tmp  = zr * zi ; 		zr2 = zr * zr ; 		zi2 = zi * zi ; 		zr = zr2 - zi2 + cr ; 		zi = tmp + tmp + ci ; 		if zi2 + zr2 > Bailout ; 			-> i ; 		;; ; 		if i > Maxiter ; 			-> 0 ; 		;; ; 	;; ; 	-> 0 ; } ;  ; const main = {args : byte[:][:] ; 	var x : flt64, y : flt64, i ;  ; 	for y = -39.0 ;  y < 39.0 ;  y = y + 1.0 ; 		for x = -39.0 ;  x < 39.0 ;  x = x + 1.0 ; 			i = mandelbrot(x/40.0, y/40.0) ; 			if i == 0 ; 				std.put("*") ; 			else ; 				std.put(" ") ; 			;; ; 		;; ; 		std.put("\n") ; 	;; ; 	std.put("\n") ; } ; \n
use std ; /* ; should fail to compile because ; all types matched over should be ; compatible. Strings are not compatible ; with integers. ; */ ; const foo = { ; 	match 123 ; 	|"asdf":	123 ; 	|234567:	888 ; 	;; ; 	std.exit(42) ; } ; \n
use std ; /* checks pattern matching on unions with arguments. ; exits with 42. */ ; type u = union ; 	`Int int ; 	`Str byte[:] ; 	`Nil ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Str "asdf" ; 	match v ; 	| `Int 127:	std.fatal("wrong match `Int 127\n") ; 	| `Str "foo":	std.fatal("Wrong match `Str \"foo\"\n") ; 	/* make sure we backtrack for the test */ ; 	| `Str "asfd":	std.fatal("Wrong match `Str \"fsda\"\n") ; 	| `Str "asdf":	std.put("Correct `Str \"asdf\"!\n") ; 	| `Nil:		std.fatal("Wrong match `Str \"fsda\"\n") ; 	| _:		std.fatal("Impossible failed match\n") ; 	;; ; } ;  ; \n
use std ; /* checks pattern matching on unions with arguments. ; exits with 42. */ ; type u = union ; 	`Int int ; 	`Chr char ; 	`Nil ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Int 123 ; 	match v ; 	| `Int 127:	std.exit(42) ; 	| `Int 123:	std.exit(69) ; 	| `Chr 'a':	std.exit(4) ; 	| `Nil:		std.exit(6) ; 	| _:		std.die("Impossible failed match\n") ; 	;; ; } ;  ; \n
use std ;  ; const main = { ; 	var v = [2, 40, 10] ;  ; 	match v ; 	| [x, y, 10]:	 ; 		 std.exit(x + y) ; 	| _:	std.die("Wat") ; 	;; ; 	std.exit(0) ; } ; \n
use std ; /* checks that we can bind values in pattern matches. ; exits with 11. */ ; type u = union ; 	`Int int ; 	`Chr char ; 	`Nil ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Int 8 ; 	match v ; 	| `Int 127:	std.exit(42) ; 	| `Int x:	std.exit(x) ; 	| `Chr 'a':	std.exit(4) ; 	| `Nil:		std.exit(6) ; 	| x:		std.die("Impossible match failure\n") ; 	;; ; } ;  ; \n
use std ; /* checks that matching works when comparing against constants, ; instead of just literals. exits with 88. */ ; /* some misc constants */ ; const Ca = 123 ; const Cb = 8 ; const Cc = 42 ;  ; const main = { ; 	var v ;  ; 	v = 8 ; 	match v ; 	| Ca: 	std.exit(123) ; 	| Cb:	std.exit(88) ; 	| Cc:	std.exit(42) ; 	| _:	std.die("Impossible match failure in pattern\n") ; 	;; ; } ; \n
use std ;  ; const main = { ; 	match (gen_a(), gen_b()) ; 	| (`std.Err _, _): std.put("error case 1") ; 	| (_, `std.Err _): std.put("error case 2") ; 	| (`std.Ok L, `std.Ok N): ; 		std.put("l = {} n = {}\n", L, N) ; 	;; ; } ;  ; var gen_a : (-> std.result(byte[:][:], void)) = { ; 	var ret = [][:] ;  ; 	for var j = 0 ;  j < 4 ;  ++j ; 		std.slpush(&ret, std.fmt("{}", j)) ; 	;; ;  ; 	if 1 + 1 > 3 ; 		-> `std.Err void ; 	;; ;  ; 	-> `std.Ok ret ; } ;  ; var gen_b : (-> std.result(int, void)) = { ; 	if 1 + 1 > 3 ; 		-> `std.Err void ; 	;; ;  ; 	-> `std.Ok 5 ; } ; \n
use std ;  ; type u = union ; 	`Foo (bool, v, bool) ; 	`Bar (bool, bool) ; 	`Baz bool ; 	`Quux ; ;; ;  ; type v = union ; 	`A ; 	`B ; ;; ;  ; const main = { ; 	match `Quux ; 	| `Foo (true, `A, true): ; 	| `Foo (true, `A, false): ; 	| `Foo (true, `B, true): ; 	| `Foo (true, `B, false): ; 	| `Foo (false, `A, true): ; 	| `Foo (false, `A, false): ; 	| `Foo (false, `B, true): ; 	| `Foo (false, `B, false): ;  ; 	| `Bar (false, false): ; 	| `Bar (false, true): ; 	| `Bar (true, false): ; 	| `Bar (true, true): ;  ; 	| `Baz false: ; 	| `Baz true: ;  ; 	| `Quux: ; 	;; ; 	std.put("worked\n") ; } ; \n
use std ; /* checks that matching integers works. exits with 84. */ ; const main = { ; 	var v ;  ; 	v = 12 ; 	match 12 ; 	| 1:	std.exit(42) ; 	| 2:	std.exit(81) ; 	| 3:	std.exit(123) ; 	| 4:	std.exit(99) ; 	| 12:	std.exit(84) ; 	| 6:	std.exit(18) ; 	| x:	std.die("Got an unexpected int!\n") ; 	;; ; } ; \n
use std ;  ; type u = union ; 	`A ; 	`B ; ;; ;  ; const main = { ; 	match "asdf" ; 	| `A:	std.put("Got a\n") ; 	| `B:	std.put("Got b\n") ; 	;; ; 	std.exit(42) ; } ; \n
use std ;  ; type a = struct ; 	x	: int ; 	y	: int ; ;; ;  ; type b = struct ; 	u	: a ; 	v	: int ; ;; ;  ; const main = { ; 	var v : b ;  ; 	match ((0, 1), 2) ; 	| ((0, 1), 2):	std.put("a") ; 	| _:		std.put("f") ; 	;; ;  ; 	match ((0, 1), 2) ; 	| (_, 2):	std.put("b") ; 	| _:		std.put("f") ; 	;; ;  ; 	v = [.u=[.x=1, .y=2], .v=3] ; 	match v ; 	| [.u=[.x=1, .y=2], .v=3]:	std.put("c") ; 	| _:				std.put("f") ; 	;; ; 	match v ; 	| [.u=_, .v=3]:	std.put("d") ; 	| _:		std.put("f") ; 	;; ;  ;  ; 	match [[1,2], [3,4]] ; 	| [[1,2], [3,4]]:	std.put("e") ; 	| _:			std.put("f") ; 	;; ; 	match [[1,2], [3,4]] ; 	| [_, [3,4]]:	std.put("f") ; 	| _:		std.put("f") ; 	;; ; } ; \n
use std ;  ; const main = { ; 	var v ;  ; 	v = std.Badchar ; 	match v ; 	| std.Maxcharval:	std.put("matched maxcharval\n") ; 	| std.Badchar: 	std.put("matched badchar\n") ; 	| 'c':	std.put("matched 'c'\n") ; 	| _:	std.die("Impossible match failure in pattern\n") ; 	;; ; } ; \n
use std ;  ;  ; const main = { ; 	type foo = union ; 		`Black ; 		`Blue ; 		`Green ; 		`Red ; 		`Yellow ; 		`White ; 	;; ;  ; 	match `Green ; 	| `Black || `White: std.exit(1) ; 	| `Blue || `Green || `Red: std.put("color\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	match `std.Some 100 ; 	| `std.Some (100 || 200 || 300): std.put("hundreds\n") ; 	| `std.Some _: std.exit(1) ; 	| _: std.exit(1) ; 	;; ;  ; 	match `std.Some (`std.Some 333, 123, 789) ; 	| `std.Some (`std.Some (101||451||789||333), _, _): std.put("good #1\n") ; 	| `std.Some (`std.Some (100||200), 222, 333): std.exit(1) ; 	| `std.Some _: std.exit(1) ; 	| `std.None: std.exit(1) ; 	;; ;  ; 	match 4 ; 	| 1||2||4: std.put("good $2\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	const a = 4 ; 	match 4 ; 	| 1||2||a: std.put("good $3\n") ; 	| _: std.exit(1) ; 	;; ;  ; 	type bar = union ; 		`A int ; 		`B int ; 		`C int ; 		`D (byte[:], int) ; 		`E (byte[:], int) ; 		`F (int, std.option(int)) ; 		`G (int, std.option(int)) ; 	;; ;  ; 	match `A 123 ; 	| `A x || `B x: std.put("good #4 {}\n", x) ; 	| _: std.exit(1) ; 	;; ;  ; 	match `G (223, `std.Some 556) ; 	| `F (x, `std.Some y) || `G (x, `std.Some y): std.put("good #5 x={} y={}\n", x, y) ; 	| _: std.exit(1) ; 	;; ;  ; 	std.put("all good\n") ; } ; \n
use std ;  ; type loop = struct ; 	l	: loop# ; 	val	: int ; ;; ;  ; const main = { ; 	var x : std.option(std.option(int)#) ; 	var y : loop ; 	var ok ;  ; 	ok = false ; 	x = `std.Some &(`std.Some 123) ; 	match x ; 	| `std.Some &(`std.None):	std.put("failed\n") ; 	| `std.Some &(`std.Some 666):	std.put("failed\n") ; 	| `std.Some &(`std.Some 123):	ok = true ; 	| _:	std.put("failed\n") ; 	;; ;  ; 	y.val=666 ; 	match &y ; 	| &[.val=777]:	std.put("failed\n") ; 	| &[.val=123]:	ok = ok && true ; 	| &[.val=999]:	std.put("failed\n") ; 	| _: ; 	;; ;  ; 	if ok ; 		std.put("worked\n") ; 	else ; 		std.put("failed\n") ; 	;; ; } ; \n
use std ;  ; type t = struct ; 	v1 : int ; 	v2 : int ; 	v3 : int ; ;; ;  ; const main = { ; 	var v : t ;  ; 	v.v1 = 2 ; 	v.v2 = 40 ; 	v.v3 = 10 ; 	match v ; 	| [.v2 = x, .v1 = y, .v3 = 10]:	 ; 		 std.exit(x + y) ; 	| _: ; 		std.die("Wat") ; 	;; ; 	std.exit(0) ; } ; \n
use std ;  ; const main = { ; 	var v = (1, 2) ;  ; 	match v ; 	| (1, x):	std.exit(40 + x) ; 	| _:	std.die("Wat") ; 	;; ; 	std.exit(0) ; } ; \n
use std ; /* checks that union matching works, at least on the key. ; exits with 84. */ ; type u = union ; 	`Foo ; 	`Bar ; 	`Baz ; 	`Quux ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Foo ; 	match v ; 	| `Bar:	std.exit(42) ; 	| `Baz:	std.exit(81) ; 	| `Foo:	std.exit(84) ; 	| `Quux:	std.exit(123) ; 	;; ; } ; \n
use std ; /* checks pattern matching on unions with arguments. ; exits with 42. */ ; type u = union ; 	`Int int ; 	`Str byte[:] ; 	`Nil ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Str "foo" ; 	match v ; 	| `Int 127: std.exit(42) ; 	| `Str s: std.put("{}\n", s) ; 	| `Nil: ; 	| _:	std.die("Impossible match failure\n") ; 	;; ; } ;  ; \n
use std ;  ; const main = { ; 	match `std.Some void ; 	| `std.Some void:	std.put("ok\n") ; 	| `std.None:	std.put("nope\n") ; 	;; ; } ; \n
use std ; /* checks that union creation works. exits with 0. */ ; type u = union ; 	`Some int ; 	`None ; ;; ;  ; const main = { ; 	var v ;  ; 	v = `Some 123 ; 	std.exit(0) ; } ; \n
use std ; /* should exit with status 6 */ ; const main = { ; 	var a = 42 ; 	var b = 9 ; 	std.exit(a % b) ; } ; \n
use std ; /* should exit with status 42 */ ; const main = { ; 	var a = 7 ; 	var b = 2 ; 	var c = 3 ; 	std.exit(a * b * c) ; } ; \n
use std ;  ; var a : int8 = 6 ; const f = { -> int8 ; 	-> 3 ; } ; const main = { ; 	std.exit(((a*f() : int))) ; } ; \n
use std ;  ; const main = { ; 	var multi ;  ; 	multi = "abc" "def" \ ; 	"ghi" ; 	 ; 	match multi ; 	| "abcdefghi": ; 	| fail: std.fatal("failed: {}\n", fail) ; 	;; ; } ; \n
use std ;  ; const main = { ; 	var a = 1 ; 	var f = std.fndup({ ; 		{ ; 			std.put("{}\n", a) ; 		}() ; 	}) ; 	f() ; } ; \n
use std ;  ; const main = { ;     match 0 ;     | 0: ;         goto ok ;     | 1: ;         :ok ;         -> void ;     | _: ;     ;; ;     std.exit(1) ; } ; \n
use std ; /* checks that nested functions without environment capture work. should ; * exit with 42. */ ; const main = { ; 	const ret42 = { ; 		-> 42 ; 	} ; 	std.exit(ret42()) ; } ; \n
use std ; /* tests that nested structs work. should exit with 3 */ ; type s1 = struct ; 	x : s2 ; ;; ;  ; type s2 = struct ; 	a : int ; 	b : int ; ;; ;  ; const main = { ; 	var s1 : s1 ; 	var s2 : s2 ;  ; 	s1.x.a = 1 ; 	s1.x.b = 2 ; 	s2 = s1.x ;  ; 	std.exit(s2.a + s2.b) ; } ; \n
use std ;  ; type t = struct ; 	x : union ; 		`Int int ; 		`Str byte[:] ; 	;; ; ;; ;  ; const main = { ; 	var a : t ;  ; 	a = [.x = `Str "asdf"] ; 	match a ; 	| [.x=`Str s]:	std.put("{}\n", s) ; 	| _:	std.die("Impossible match failure\n") ; 	;; ; } ;  ; \n
use std ; /* checks that f is not an infinite type (ie, the type ; doesn't exist within itself). If 'f' typechecked, ; it's type would be: ;  ; f : (std.exit((-> (-> ... ad infinitum ...)))) ; */ ; const f = { ; 	std.exit(f) ; } ; \n
use std ; /* should assign a slice through an out param, returning exiting with 2 */ ; const arr = [1,2,3,4] ; const f = {out ; 	out# = arr[1:3] ; } ;  ; const main = { ; 	var v ;  ; 	f(&v) ; 	std.exit(v[0]) ; } ; \n
use std ; /* should assign through an out pointer parameter, exiting with status 42 */ ; const f = {out ; 	out# = 42 ; } ;  ; const main = { ; 	var v ;  ; 	v = 16 ; 	f(&v) ; 	std.exit(v) ; } ; \n
use std ; /* checks that if multiple if conditions are valid, only the first is ; * selected. should exit with 2. */ ; const main = { ; 	var v ; 	var x ;  ; 	v = 0xff ;  ; 	x = 42 ; 	if v & 0xff00 != 0 ; 		x = 1 ; 	elif v & 0xfff0 != 0 ; 		x = 2 ; 	elif v & 0xffff != 0 ; 		x = 3 ; 	;; ; 	std.exit(x) ; } ; \n
use std ;  ; const main = { ; 	/* should print 1,3,5, skipping 4 */ ; 	for (1,x) : [(1,2),(1,3),(2,4),(1,5)] ; 		std.put("{}", x) ; 	;; ; 	/* should print 1, 2 skipping `None */ ; 	for `std.Some v : [`std.None, `std.Some 1, `std.Some 2] ; 		std.put("{}", v) ; 	;; ; 	std.put("\n") ; } ; \n
use std ; use regex ;  ; impl disposable regex.regex# = ; 	__dispose__ = {r ; 		regex.free(r) ; 	} ; ;; ;  ; const main = { ; 	auto std.try(regex.compile(".*")) ; 	std.exit(42) ; } ; \n
use std ;  ; const main = { ; 	std.put("{}\n", f()) ; } ;  ; const a = [1,2,3][:] ; const f = { ; 	var i = 0 ; 	-> a[i++] ; } ;  ; \n
use std ;  ; const main = { ; 	var a, b, v1, v2 ;  ; 	v1 = 42 ; 	v2 = 42 ; 	a = &v1 ; 	b = &v1 ; 	std.assert(a == b, "pointers should be equal, but weren't\n") ; 	a = &v1 ; 	b = &v2 ; 	std.assert(a != b, "pointers weren't equal, but should be\n") ; 	std.exit(0) ; } ; \n
use std ; /* should preincrement through a pointer, exiting with status 9 */ ; const ppreinc = {p ; 	-> ++p# ; } ;  ; const main = { ; 	var x = 8 ;  ; 	std.exit(ppreinc(&x)) ; } ;  ; \n
use std ;  ; type o(@a) :: integral @a = union ; 	`S @a ; ;; ;  ; type x(@k) = struct ; 	n  : o(x(@k)#) ; ;; ;  ; const main = { ; 	var test : x(int) ; 	std.put("built\n") ; } ; \n
use std ;  ; const f1 = { -> byte[:] ; 	-> [1, 2, 3][:] ; } ;  ; const f2 = { -> byte[3] ; 	-> [1, 2, 3] ; } ;  ;  ; const main = { ; 	if f1().len != 3 ; 		-> void ; 	;; ; 	if f2().len != 3 ; 		-> void ; 	;; ; 	std.put("pass\n") ; } ;  ; \n
use std ; /* checks that sizeof() works. exits with 4. */ ; const main = { ; 	std.exit(sizeof(int)) ; } ; \n
/* test the allocation of slices. should return 123 */ ; use std ;  ; const main = { ; 	var sl : int[:] ;  ; 	sl = std.slalloc(123) ; 	sl[0] = 42 ; 	sl[122] = 1 ; 	std.exit(sl.len) ; } ; \n
/* checks that our slice grow function works. exits with 42. */ ; use std ;  ; const main = { ; 	var sl ;  ; 	sl = std.slalloc(42) ; 	sl[0] = 12 ; 	std.slgrow(&sl, 123) ; 	sl[122] = 30 ; 	std.exit(sl[0] + sl[122]) ; } ; \n
use std ; /* checks that taking slices of arrays works. should exit with 7 */ ; const main = { ; 	var a : int[3] ; 	var s ;  ; 	s = a[:] ; 	s[0] = 3 ; 	s[1] = 4 ; 	s[2] = s[0] + s[1] + s.len ; 	std.exit(s[2]) ; } ; \n
use std ; /* checks that taking incomplete slices calculates the length correctly. ; * should exit with 5. */ ; const main = { ; 	var a : int[8] ; 	var s ;  ; 	s = a[1:6] ; 	std.exit(s.len) ; } ; \n
use std ;  ; const main = { ;         std.put("{}          {}\n", (1 : uint32), [2][:]) /* !!! */ ; } ; \n
use std ;  ; const main = { ; 	std.exit(1 + \ /* ignored crap */ ; 	   	 2) ; } ; \n
use std ;  ; const abs = {d ; 	if d < 0.0 ; 		-> -d ; 	else ; 		-> d ; 	;; ; } ;  ; const Eps = 0.00001 ; const Maxiter = 20 ;  ; const sqrt = {x : flt64 ; 	var val ; 	var iter ; 	var i ;  ;  ; 	val = 1.0 ;  ; 	for i = 0 ;  i < Maxiter ;  i++ ; 		iter = 0.5*(val + x/val) ; 		if abs(val - iter) < Eps ; 			-> val ;  ; 		;; ; 		val = iter ;  ; 	;; ; 	-> val ; } ;  ; const main = { ; 	var r ;  ; 	r = (sqrt(20.0) : int) ; 	std.exit(r) ; } ;  ; \n
use std ; /* checks that string literals are compiled correctly. ; exits with ascii 'f', ie, 102. */ ; const main = { ; 	var str ;  ; 	str = "asdf" ; 	std.exit((str[3] : int)) ; } ; \n
use std ;  ; const main = { ; 	printloc(std.strfind("", "")) ; 	printloc(std.strfind("", "a")) ; 	printloc(std.strfind("ab", "abc")) ; 	printloc(std.strfind("abc", "abc")) ; 	printloc(std.strfind("abcde", "abc")) ; 	printloc(std.strfind("abcde", "xyz")) ; 	printloc(std.strfind("abcde", "bcd")) ; 	printloc(std.strfind("abcde", "cde")) ; 	printloc(std.strfind("abcde", "def")) ; 	printloc(std.strfind("abcde", "abx")) ; } ;  ; const printloc = {l ; 	match l ; 	| `std.Some loc:	std.put("Found {}\n", loc) ; 	| `std.None:	std.put("No match\n") ; 	;; ; } ;  ;  ; 	 ; \n
use std ;  ; const main = { ; 	const strings = [ ; 	    "x", ; 	    "y", ; 	    "z", ; 	    "w" ; 	] ; 	std.put("{}\n", std.strcat("foo ; ", "bar")) ; 	std.put("{}\n", std.strjoin(strings[:], "")) ; 	std.put("{}\n", std.strjoin(strings[:], ":")) ; } ; \n
use std ;  ; const main = { ; 	var i ; 	var sp ;  ; 	sp = std.strsplit("a,b,c,d", ",") ; 	for i = 0 ;  i < sp.len ;  i++ ; 		std.put("\"{}\"\n", sp[i]) ; 	;; ; 	std.slfree(sp) ;  ; 	sp = std.strsplit("a,,b,c,,d", ",") ; 	for i = 0 ;  i < sp.len ;  i++ ; 		std.put("\"{}\"\n", sp[i]) ; 	;; ; 	std.slfree(sp) ;  ; 	sp = std.strsplit("a--b---b--c---c-d--d", "---") ; 	for i = 0 ;  i < sp.len ;  i++ ; 		std.put("\"{}\"\n", sp[i]) ; 	;; ; 	std.slfree(sp) ; } ; \n
use std ;  ; const main = { ; 	std.put("\"{}\"\n", std.strstrip("cccc")) ; 	std.put("\"{}\"\n", std.strfstrip("cccc")) ; 	std.put("\"{}\"\n", std.strrstrip("cccc")) ;  ; 	std.put("--\n") ; 	std.put("\"{}\"\n", std.strstrip("  abc  ")) ; 	std.put("\"{}\"\n", std.strfstrip("  abc  ")) ; 	std.put("\"{}\"\n", std.strrstrip("  abc  ")) ;  ; 	std.put("--\n") ; 	std.put("\"{}\"\n", std.strstrip("  世界  ")) ; 	std.put("\"{}\"\n", std.strfstrip("  世界  ")) ; 	std.put("\"{}\"\n", std.strrstrip("  世界  ")) ;  ; 	std.put("--\n") ; 	std.put("\"{}\"\n", std.strstrip("    ")) ; 	std.put("\"{}\"\n", std.strfstrip("    ")) ; 	std.put("\"{}\"\n", std.strrstrip("    ")) ;  ; 	std.put("--\n") ; 	std.put("\"{}\"\n", std.strstrip("")) ; 	std.put("\"{}\"\n", std.strfstrip("")) ; 	std.put("\"{}\"\n", std.strrstrip("")) ; } ; \n
use std ;  ; const strtab = [ ; 	"foo", ; 	"bar", ; 	"baz", ; 	"quux" ; ] ;  ; const main = { ; 	var i ; 	for i = 0 ;  i < strtab.len ;  i++ ; 		std.put("{}: {}\n", i, strtab[i]) ; 	;; ; 	std.exit(0) ; } ; \n
use std ; /* test reading and writing to struct members. exits with 42. */ ; type pair = struct ; 	a : int ; 	b : int ; ;; ;  ; const main = { ; 	var s : pair ; 	s.a = 12 ; 	s.b = 30 ; 	std.exit(s.a + s.b) ; } ; \n
use std ; /*  ; make sure assigning to a 1-element struct works ;  exit status should be 12 ; */ ; type val = struct ; 	a : int ; ;; ;  ; const main = { ; 	var s : val ; 	s.a = 12 ; 	std.exit(s.a) ; } ; \n
use std ; /* tests a struct containing an array. exit status should be 42. */ ; type t = struct ; 	a : int[42] ; ;; ;  ; const main = { ; 	var v : t ;  ; 	v.a[0] = 11 ; 	v.a[1] = 20 ;  ; 	std.exit(2*v.a[0] + v.a[1]) ; } ; \n
use std ; /* tests block assignment of structs. exits with 42.*/ ; type pair = struct ; 	a : int ; 	b : int ; ;; ;  ; const main = { ; 	var x : pair ; 	var y : pair ; 	x.a = 12 ; 	x.b = 30 ; 	y = x ; 	std.exit(y.a + y.b) ; } ; \n
use std ;  ; /* checks that we can create struct literals with named initializers. ; 	exits with 42. */ ; type t = struct ; 	a	: int ; 	b	: char ; 	c	: byte[:] ; ;; ;  ; const main = { ; 	var v : t ;  ; 	v = [.a=42, .b='x', .c="foo"] ; 	std.exit(v.a) ; } ;  ; \n
use std ; /* tests reading and writing through a struct pointer. exits with 42. */ ; type pair = struct ; 	a : int ; 	b : int ; ;; ;  ; const frob = {s ; 	s.a = 12 ; 	s.b = 30 ; } ;  ; const main = { ; 	var s : pair ; 	frob(&s) ; 	std.exit(s.a + s.b) ; } ; \n
use std ; /* tests returning large structs. should exit with 42. */ ; type pair = struct ; 	a : int ; 	b : int ; ;; ;  ; const f = { ; 	var s ;  ; 	s.a = 12 ; 	s.b = 30 ; 	-> s ; } ;  ; const main = { ; 	var s : pair ;  ; 	s = f() ; 	std.exit(s.a + s.b) ; } ; \n
use std ;  ; const main = { ; 	for i : [1,2,3,4][:2] ; 		std.put("{}", i) ; 	;; ; 	std.put("\n") ; } ; \n
use std ; /* sign extending cast. should exit with status 99 */ ; const main = { ; 	var u : int8 ; 	var v : int32 ; 	 ; 	u = 99 ; 	v = (u : int32) ; 	std.exit((v : int)) ; } ; \n
use std ; /* checks that generic types with traits are compiled correctly. ; without the 'numeric' trait on '@a', the '>' operator would not work ; within max. without the 'tctest' trait on '@a' in intlike_is42, ; comparing to 42 wouldn't work. ;  ; exits with 42. ; */ ;  ; generic max = {a : @a, b : @a :: numeric @a ; 	if a > b ; 		-> a ; 	else ; 		-> b ; 	;; ; } ;  ; generic intlike_is42 = {a : @a :: numeric,integral @a ; 	-> a == 42 ; } ;  ; const main = { ; 	if intlike_is42(123) ; 	    std.exit(16) ; 	else ; 	    std.exit(max(12, 42)) ; 	;; ; } ; \n
use std ;  ; trait frobable @a = ; 	frob	: (val : @a -> @a) ; ;; ;  ; impl frobable int = ; 	frob = {val ; 		-> val * 2 ; 	} ; ;; ;  ; impl frobable int16 = ; 	frob = {val ; 		-> val * 4 ; 	} ; ;; ;  ; impl frobable byte[:] = ; 	frob = {val ; 		-> val[:4] ; 	} ; ;; ;  ; generic foo = {x : @a :: frobable @a ; 	-> frob(x) ; } ;  ; const main = { ; 	var a, b, c ; 	a = foo(123) ; 	b = foo((11 : int16)) ; 	c = frob("meeeeeeh") ; 	std.put("{},{},{}\n", a, b, c) ; } ;  ; \n
use std ; /* should truncate y when casting to x, exiting with status 15 */ ; const main = { ; 	var x : uint8 ; 	var y : int32 ;  ; 	y = 9999 ; 	x = (y : uint8) ; 	std.exit((x % 73 : int)) ; } ; \n
use std ; /* checks that we can create tuples and destructure them. exits with 42. */ ; const main = { ; 	var a, b, c ; 	var v, x ;  ; 	x = 10 ; 	v = ((x, x + 12), x) ; 	((a, b), c) = v ; 	std.exit(a + b + c) ; } ; \n
use std ;  ; const foo = { ; 	-> (1, 2, (3, 4)) ; } ;  ; const main = { ; 	match foo() ; 	| x: ; 		x.0 = 0 ; 		(x.2).1 = 5 ; 		std.put("a: {}, b: {}, c: {}\n", x.0, x.2.1, foo().1) ; 	;; ; } ; \n
use std ; /* checks that types do not contain themselves ; inline, because that would lead to an infinite ; sized type. ; */ ;  ; type t = struct ; 	memb : t ; ;; ;  ; var v : t ; \n
use std ; /* we just want to see if this file compiles */ ; type foo = struct ; 	v : foo# ; ;; ;  ; const main = { ; 	var v : foo ; 	std.exit(42) ; } ; \n
use std ;  ; type u = union ; 	`A ; 	`B ; 	`C int ; ;; ;  ; const a = [`A, `B, `C 123] ;  ; const main = { ; 	for v : a ; 		match v ; 		| `A:	std.put("A ") ; 		| `B:	std.put("B ") ; 		| `C x:	std.put("C {}\n", x) ; 		;; ; 	;; ; 	std.put("\n") ; } ;  ; \n
use std ; /* ; should fail to compile becuse ; we're constructing a union that ; with too many arguments. ; */ ; type u = union ; 	`Foo ; ;; ;  ; const main = { ; 	`Foo 123 ; } ; \n
use std ; type u = union ; 	`Foo int ; ;; ;  ; const main = { ; 	`Foo ; } ; \n
type u = union ; 	`Some int ; 	`None ; ;; ;  ; const main = { ; 	var v : u ;  ; 	v = `None ; } ; \n
use std ;  ; /* ; should fail to compile because 'a' is used ; before it is defined. ; */ ; const main = { ; 	var a : int ; 	std.exit(a) ; } ; \n
use std ;  ; const main = { ; 	var x : void ; 	 ;  ; 	std.put("{}\n", f(x, 1, void, 2)) ; } ;  ; const f = {v1, n1, v2, n2 ; 	-> n1 + n2 ; } ; \n
use std ;  ; const main = { ; 	var x : void ;  ; 	x = f() ; } ;  ; const f = { ; 	std.put("ok\n") ; } ;  ; \n
use std ; /* checks that calling void functions works. should compile, and not die ; when running. the exit value is 12, but it's really a dummy. */ ; const f = { ; 	var a ;  ; 	a = a + 1 ; } ;  ; const main = { ; 	f() ; 	std.exit(12) ; } ; \n
use std ;  ; const bar = { ; 	std.put("pass") ; } ;  ; const foo = { ; 	-> bar() ; } ;  ; const main = { ; 	foo() ; } ; \n
use std ;  ; const main = { ; 	match `std.Some void ; 	| `std.Some x:	std.put("ok\n") ; 	| `std.None:	std.put("fail\n") ; 	;; ; } ; \n
use std ; /* should zero-extend u when casting to v, returning 99 */ ; const main = { ; 	var u : uint8 ; 	var v : uint32 ; 	 ; 	u = 99 ; 	v = (u : uint32) ; 	std.exit((v : int)) ; } ; \n
