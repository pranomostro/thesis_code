/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedList; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.list.AbstractListTest;  /**  * Tests base {@link java.util.LinkedList} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject()} method.  * <p>  * If your {@link LinkedList} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link List} fails.  *  */ public abstract class AbstractLinkedListTest<T> extends AbstractListTest<T> {      public AbstractLinkedListTest(final String testName) {         super(testName);     }      @Override     public abstract LinkedList<T> makeObject();      /**      *  Returns the {@link #collection} field cast to a {@link LinkedList}.      *      *  @return the collection field as a List      */     @Override     public LinkedList<T> getCollection() {         return (LinkedList<T>) super.getCollection();     }      /**      *  Returns the {@link #confirmed} field cast to a {@link LinkedList}.      *      *  @return the confirmed field as a List      */     protected LinkedList<T> getConfirmedLinkedList() {         return (LinkedList<T>) getConfirmed();     }      /**      *  Tests {@link LinkedList#addFirst(Object)}.      */     @SuppressWarnings("unchecked")     public void testLinkedListAddFirst() {         if (!isAddSupported()) {             return;         }         final T o = (T) "hello";          resetEmpty();         getCollection().addFirst(o);         getConfirmedLinkedList().addFirst(o);         verify();          resetFull();         getCollection().addFirst(o);         getConfirmedLinkedList().addFirst(o);         verify();     }      /**      *  Tests {@link LinkedList#addLast(Object)}.      */     @SuppressWarnings("unchecked")     public void testLinkedListAddLast() {         if (!isAddSupported()) {             return;         }         final T o = (T) "hello";          resetEmpty();         getCollection().addLast(o);         getConfirmedLinkedList().addLast(o);         verify();          resetFull();         getCollection().addLast(o);         getConfirmedLinkedList().addLast(o);         verify();     }      /**      *  Tests {@link LinkedList#getFirst()}.      */     public void testLinkedListGetFirst() {         resetEmpty();         try {             getCollection().getFirst();             fail("getFirst() should throw a NoSuchElementException for an " +                     "empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object first = getCollection().getFirst();         final Object confirmedFirst = getConfirmedLinkedList().getFirst();         assertEquals("Result returned by getFirst() was wrong.",                 confirmedFirst, first);         verify();     }      /**      *  Tests {@link LinkedList#getLast()}.      */     public void testLinkedListGetLast() {         resetEmpty();         try {             getCollection().getLast();             fail("getLast() should throw a NoSuchElementException for an " +                     "empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object last = getCollection().getLast();         final Object confirmedLast = getConfirmedLinkedList().getLast();         assertEquals("Result returned by getLast() was wrong.",                 confirmedLast, last);         verify();     }      /**      *  Tests {@link LinkedList#removeFirst()}.      */     public void testLinkedListRemoveFirst() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().removeFirst();             fail("removeFirst() should throw a NoSuchElementException for " +                     "an empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object first = getCollection().removeFirst();         final Object confirmedFirst = getConfirmedLinkedList().removeFirst();         assertEquals("Result returned by removeFirst() was wrong.",                 confirmedFirst, first);         verify();     }      /**      *  Tests {@link LinkedList#removeLast()}.      */     public void testLinkedListRemoveLast() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().removeLast();             fail("removeLast() should throw a NoSuchElementException for " +                     "an empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object last = getCollection().removeLast();         final Object confirmedLast = getConfirmedLinkedList().removeLast();         assertEquals("Result returned by removeLast() was wrong.",                 confirmedLast, last);         verify();     }      /**      *  Returns an empty {@link LinkedList}.      */     @Override     public Collection<T> makeConfirmedCollection() {         return new LinkedList<>();     }      /**      *  Returns a full {@link LinkedList}.      */     @Override     public Collection<T> makeConfirmedFullCollection() {         return new LinkedList<>(Arrays.asList(getFullElements()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.EmptyStackException;  import junit.framework.Test;  /**  * Tests ArrayStack.  *  */ @SuppressWarnings("deprecation") // we test a deprecated class public class ArrayStackTest<E> extends AbstractArrayListTest<E> {      public ArrayStackTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ArrayStackTest.class);     }      @Override     public ArrayStack<E> makeObject() {         return new ArrayStack<>();     }      //-----------------------------------------------------------------------     public void testNewStack() {         final ArrayStack<E> stack = makeObject();         assertTrue("New stack is empty", stack.empty());         assertEquals("New stack has size zero", 0, stack.size());          try {             stack.peek();             fail("peek() should have thrown EmptyStackException");         } catch (final EmptyStackException e) {             // Expected result         }          try {             stack.pop();             fail("pop() should have thrown EmptyStackException");         } catch (final EmptyStackException e) {             // Expected result         }      }      @SuppressWarnings("unchecked")     public void testPushPeekPop() {         final ArrayStack<E> stack = makeObject();          stack.push((E) "First Item");         assertTrue("Stack is not empty", !stack.empty());         assertEquals("Stack size is one", 1, stack.size());         assertEquals("Top item is 'First Item'",                      "First Item", (String) stack.peek());         assertEquals("Stack size is one", 1, stack.size());          stack.push((E) "Second Item");         assertEquals("Stack size is two", 2, stack.size());         assertEquals("Top item is 'Second Item'",                      "Second Item", (String) stack.peek());         assertEquals("Stack size is two", 2, stack.size());          assertEquals("Popped item is 'Second Item'",                      "Second Item", (String) stack.pop());         assertEquals("Top item is 'First Item'",                      "First Item", (String) stack.peek());         assertEquals("Stack size is one", 1, stack.size());          assertEquals("Popped item is 'First Item'",                      "First Item", (String) stack.pop());         assertEquals("Stack size is zero", 0, stack.size());      }      @Override     @SuppressWarnings("unchecked")     public void testSearch() {         final ArrayStack<E> stack = makeObject();          stack.push((E) "First Item");         stack.push((E) "Second Item");         assertEquals("Top item is 'Second Item'",                      1, stack.search("Second Item"));         assertEquals("Next Item is 'First Item'",                      2, stack.search("First Item"));         assertEquals("Cannot find 'Missing Item'",                      -1, stack.search("Missing Item"));      }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ArrayStack.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ArrayStack.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.TreeMap;  import org.apache.commons.collections4.map.AbstractMapTest;  /**  * Tests TreeMap.  *  */ public abstract class AbstractTreeMapTest<K, V> extends AbstractMapTest<K, V> {      public AbstractTreeMapTest(final String testName) {         super(testName);     }      @Override     public boolean isAllowNullKey() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract TreeMap<K, V> makeObject();      public void testNewMap() {         final TreeMap<K, V> map = makeObject();         assertTrue("New map is empty", map.isEmpty());         assertEquals("New map has size zero", 0, map.size());     }      @SuppressWarnings("unchecked")     public void testSearch() {         final TreeMap<K, V> map = makeObject();         map.put((K) "first", (V) "First Item");         map.put((K) "second", (V) "Second Item");         assertEquals("Top item is 'Second Item'",             "First Item", map.get("first"));         assertEquals("Next Item is 'First Item'",             "Second Item", map.get("second"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import org.junit.Test;  import java.util.HashMap; import java.util.Map;  import static org.junit.Assert.*;  /**  * Test the DefaultKeyValue class.  *  * @since 3.0  */ public class DefaultKeyValueTest<K, V> {      private final String key = "name";     private final String value = "duke";      //-----------------------------------------------------------------------     /**      * Make an instance of DefaultKeyValue with the default (null) key and value.      * Subclasses should override this method to return a DefaultKeyValue      * of the type being tested.      */     protected DefaultKeyValue<K, V> makeDefaultKeyValue() {         return new DefaultKeyValue<>(null, null);     }      /**      * Make an instance of DefaultKeyValue with the specified key and value.      * Subclasses should override this method to return a DefaultKeyValue      * of the type being tested.      */     protected DefaultKeyValue<K, V> makeDefaultKeyValue(final K key, final V value) {         return new DefaultKeyValue<>(key, value);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     @Test     public void testAccessorsAndMutators() {         final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();          kv.setKey((K) key);         assertTrue(kv.getKey() == key);          kv.setValue((V) value);         assertTrue(kv.getValue() == value);          // check that null doesn't do anything funny         kv.setKey(null);         assertTrue(kv.getKey() == null);          kv.setValue(null);         assertTrue(kv.getValue() == null);      }      @SuppressWarnings("unchecked")     @Test     public void testSelfReferenceHandling() {         // test that #setKey and #setValue do not permit         //  the KVP to contain itself (and thus cause infinite recursion         //  in #hashCode and #toString)          final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();          try {             kv.setKey((K) kv);             fail("Should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected to happen...              // check that the KVP's state has not changed             assertTrue(kv.getKey() == null && kv.getValue() == null);         }          try {             kv.setValue((V) kv);             fail("Should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected to happen...              // check that the KVP's state has not changed             assertTrue(kv.getKey() == null && kv.getValue() == null);         }     }      /**      * Subclasses should override this method to test their own constructors.      */     @SuppressWarnings("unchecked")     @Test     public void testConstructors() {         // 1. test default constructor         DefaultKeyValue<K, V> kv = new DefaultKeyValue<>();         assertTrue(kv.getKey() == null && kv.getValue() == null);          // 2. test key-value constructor         kv = new DefaultKeyValue<>((K) key, (V) value);         assertTrue(kv.getKey() == key && kv.getValue() == value);          // 3. test copy constructor         final DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<>(kv);         assertTrue(kv2.getKey() == key && kv2.getValue() == value);          // test that the KVPs are independent         kv.setKey(null);         kv.setValue(null);          assertTrue(kv2.getKey() == key && kv2.getValue() == value);          // 4. test Map.Entry constructor         final Map<K, V> map = new HashMap<>();         map.put((K) key, (V) value);         final Map.Entry<K, V> entry = map.entrySet().iterator().next();          kv = new DefaultKeyValue<>(entry);         assertTrue(kv.getKey() == key && kv.getValue() == value);          // test that the KVP is independent of the Map.Entry         entry.setValue(null);         assertTrue(kv.getValue() == value);      }      @SuppressWarnings("unchecked")     @Test     public void testEqualsAndHashCode() {         // 1. test with object data         DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);         DefaultKeyValue<K, V> kv2 = makeDefaultKeyValue((K) key, (V) value);          assertTrue(kv.equals(kv));         assertTrue(kv.equals(kv2));         assertTrue(kv.hashCode() == kv2.hashCode());          // 2. test with nulls         kv = makeDefaultKeyValue(null, null);         kv2 = makeDefaultKeyValue(null, null);          assertTrue(kv.equals(kv));         assertTrue(kv.equals(kv2));         assertTrue(kv.hashCode() == kv2.hashCode());     }      @SuppressWarnings("unchecked")     @Test     public void testToString() {         DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);         assertTrue(kv.toString().equals(kv.getKey() + "=" + kv.getValue()));          // test with nulls         kv = makeDefaultKeyValue(null, null);         assertTrue(kv.toString().equals(kv.getKey() + "=" + kv.getValue()));     }      @SuppressWarnings("unchecked")     @Test     public void testToMapEntry() {         final DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);          final Map<K, V> map = new HashMap<>();         map.put(kv.getKey(), kv.getValue());         final Map.Entry<K, V> entry = map.entrySet().iterator().next();          assertTrue(entry.equals(kv.toMapEntry()));         assertTrue(entry.hashCode() == kv.hashCode());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import java.util.HashMap; import java.util.Map;  import org.junit.Test; import static org.junit.Assert.*;  /**  * Abstract tests that can be extended to test any Map.Entry implementation.  * Subclasses must implement {@link #makeMapEntry(Object, Object)} to return  * a new Map.Entry of the type being tested. Subclasses must also implement  * {@link #testConstructors()} to test the constructors of the Map.Entry  * type being tested.  *  * @since 3.0  */ public abstract class AbstractMapEntryTest<K, V> {      protected final String key = "name";     protected final String value = "duke";      //-----------------------------------------------------------------------     /**      * Make an instance of Map.Entry with the default (null) key and value.      * This implementation simply calls {@link #makeMapEntry(Object, Object)}      * with null for key and value. Subclasses can override this method if desired.      */     public Map.Entry<K, V> makeMapEntry() {         return makeMapEntry(null, null);     }      /**      * Make an instance of Map.Entry with the specified key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     public abstract Map.Entry<K, V> makeMapEntry(K key, V value);      /**      * Makes a Map.Entry of a type that's known to work correctly.      */     public Map.Entry<K, V> makeKnownMapEntry() {         return makeKnownMapEntry(null, null);     }      /**      * Makes a Map.Entry of a type that's known to work correctly.      */     public Map.Entry<K, V> makeKnownMapEntry(final K key, final V value) {         final Map<K, V> map = new HashMap<>(1);         map.put(key, value);         final Map.Entry<K, V> entry = map.entrySet().iterator().next();         return entry;     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     @Test     public void testAccessorsAndMutators() {         Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);          assertTrue(entry.getKey() == key);          entry.setValue((V) value);         assertTrue(entry.getValue() == value);          // check that null doesn't do anything funny         entry = makeMapEntry(null, null);         assertTrue(entry.getKey() == null);          entry.setValue(null);         assertTrue(entry.getValue() == null);     }      /**      * Subclasses should override this method to test the      * desired behavior of the class with respect to      * handling of self-references.      *      */      @SuppressWarnings("unchecked")     @Test     public void testSelfReferenceHandling() {         // test that #setValue does not permit         //  the MapEntry to contain itself (and thus cause infinite recursion         //  in #hashCode and #toString)          final Map.Entry<K, V> entry = makeMapEntry();          try {             entry.setValue((V) entry);             fail("Should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected to happen...              // check that the KVP's state has not changed             assertTrue(entry.getKey() == null && entry.getValue() == null);         }     }      /**      * Subclasses should provide tests for their constructors.      *      */     public abstract void testConstructors();      @SuppressWarnings("unchecked")     @Test     public void testEqualsAndHashCode() {         // 1. test with object data         Map.Entry<K, V> e1 = makeMapEntry((K) key, (V) value);         Map.Entry<K, V> e2 = makeKnownMapEntry((K) key, (V) value);          assertTrue(e1.equals(e1));         assertTrue(e2.equals(e1));         assertTrue(e1.equals(e2));         assertTrue(e1.hashCode() == e2.hashCode());          // 2. test with nulls         e1 = makeMapEntry();         e2 = makeKnownMapEntry();          assertTrue(e1.equals(e1));         assertTrue(e2.equals(e1));         assertTrue(e1.equals(e2));         assertTrue(e1.hashCode() == e2.hashCode());     }      @SuppressWarnings("unchecked")     @Test     public void testToString() {         Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);         assertTrue(entry.toString().equals(entry.getKey() + "=" + entry.getValue()));          // test with nulls         entry = makeMapEntry();         assertTrue(entry.toString().equals(entry.getKey() + "=" + entry.getValue()));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import org.junit.Test;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Arrays; import java.util.HashMap; import java.util.Map;  import static org.junit.Assert.*;  /**  * Unit tests for {@link org.apache.commons.collections4.keyvalue.MultiKey}.  *  */ public class MultiKeyTest {      static class DerivedMultiKey<T> extends MultiKey<T> {          private static final long serialVersionUID = 1928896152249821416L;          DerivedMultiKey(final T key1, final T key2) {             super(key1, key2);         }          public T getFirst() {             return getKey(0);         }          public T getSecond() {             return getKey(1);         }      }      static class SystemHashCodeSimulatingKey implements Serializable {          private static final long serialVersionUID = -1736147315703444603L;         private final String name;         private int hashCode = 1;          SystemHashCodeSimulatingKey(final String name) {             this.name = name;         }          @Override         public boolean equals(final Object obj) {             return obj instanceof SystemHashCodeSimulatingKey                 && name.equals(((SystemHashCodeSimulatingKey) obj).name);         }          @Override         public int hashCode() {             return hashCode;         }          private Object readResolve() {             hashCode=2; // simulate different hashCode after deserialization in another process             return this;         }     }     Integer ONE = Integer.valueOf(1);      Integer TWO = Integer.valueOf(2);     Integer THREE = Integer.valueOf(3);     Integer FOUR = Integer.valueOf(4);     Integer FIVE = Integer.valueOf(5);     //-----------------------------------------------------------------------     @Test     public void testConstructors() throws Exception {         MultiKey<Integer> mk;         mk = new MultiKey<>(ONE, TWO);         assertTrue(Arrays.equals(new Object[] { ONE, TWO }, mk.getKeys()));          mk = new MultiKey<>(ONE, TWO, THREE);         assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE }, mk.getKeys()));          mk = new MultiKey<>(ONE, TWO, THREE, FOUR);         assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR }, mk.getKeys()));          mk = new MultiKey<>(ONE, TWO, THREE, FOUR, FIVE);         assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR, FIVE }, mk.getKeys()));          mk = new MultiKey<>(new Integer[] { THREE, FOUR, ONE, TWO }, false);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));     }      @Test     public void testConstructorsByArray() throws Exception {         MultiKey<Integer> mk;         Integer[] keys = new Integer[] { THREE, FOUR, ONE, TWO };         mk = new MultiKey<>(keys);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));         keys[3] = FIVE;  // no effect         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));          keys = new Integer[] {};         mk = new MultiKey<>(keys);         assertTrue(Arrays.equals(new Object[] {}, mk.getKeys()));          keys = new Integer[] { THREE, FOUR, ONE, TWO };         mk = new MultiKey<>(keys, true);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));         keys[3] = FIVE;  // no effect         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));          keys = new Integer[] { THREE, FOUR, ONE, TWO };         mk = new MultiKey<>(keys, false);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));         // change key - don't do this!         // the hashcode of the MultiKey is now broken         keys[3] = FIVE;         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, FIVE }, mk.getKeys()));     }      @Test     public void testConstructorsByArrayNull() throws Exception {         final Integer[] keys = null;         try {             new MultiKey<>(keys);             fail();         } catch (final NullPointerException ex) {}         try {             new MultiKey<>(keys, true);             fail();         } catch (final NullPointerException ex) {}         try {             new MultiKey<>(keys, false);             fail();         } catch (final NullPointerException ex) {}     }      @Test     public void testEquals() {         final MultiKey<Integer> mk1 = new MultiKey<>(ONE, TWO);         final MultiKey<Integer> mk2 = new MultiKey<>(ONE, TWO);         final MultiKey<Object> mk3 = new MultiKey<>(ONE, "TWO");          assertEquals(mk1, mk1);         assertEquals(mk1, mk2);         assertFalse(mk1.equals(mk3));         assertFalse(mk1.equals(""));         assertFalse(mk1.equals(null));     }      @Test     public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException {         SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey("test");         final MultiKey<?> mk = new MultiKey<Object>(ONE, sysKey);         final Map<MultiKey<?>, Integer> map = new HashMap<>();         map.put(mk, TWO);          // serialize         final ByteArrayOutputStream baos = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(baos);         out.writeObject(sysKey);         out.writeObject(map);         out.close();          // deserialize         final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());         final ObjectInputStream in = new ObjectInputStream(bais);         sysKey = (SystemHashCodeSimulatingKey) in.readObject(); // simulate deserialization in another process         final Map<?, ?> map2 = (Map<?, ?>) in.readObject();         in.close();          assertEquals(2, sysKey.hashCode()); // different hashCode now          final MultiKey<?> mk2 = new MultiKey<Object>(ONE, sysKey);         assertEquals(TWO, map2.get(mk2));     }      @Test     public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException {         final DerivedMultiKey<?> mk = new DerivedMultiKey<>("A", "B");          // serialize         final ByteArrayOutputStream baos = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(baos);         out.writeObject(mk);         out.close();          // deserialize         final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());         final ObjectInputStream in = new ObjectInputStream(bais);         final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>) in.readObject();         in.close();          assertEquals(mk.hashCode(), mk2.hashCode());     }      @Test     public void testGetIndexed() {         final MultiKey<Integer> mk = new MultiKey<>(ONE, TWO);         assertSame(ONE, mk.getKey(0));         assertSame(TWO, mk.getKey(1));         try {             mk.getKey(-1);             fail();         } catch (final IndexOutOfBoundsException ex) {}         try {             mk.getKey(2);             fail();         } catch (final IndexOutOfBoundsException ex) {}     }      @Test     public void testGetKeysArrayConstructorCloned() {         final Integer[] keys = new Integer[] { ONE, TWO };         final MultiKey<Integer> mk = new MultiKey<>(keys, true);         final Object[] array = mk.getKeys();         assertTrue(array != keys);         assertTrue(Arrays.equals(array, keys));         assertSame(ONE, array[0]);         assertSame(TWO, array[1]);         assertEquals(2, array.length);     }      @Test     public void testGetKeysArrayConstructorNonCloned() {         final Integer[] keys = new Integer[] { ONE, TWO };         final MultiKey<Integer> mk = new MultiKey<>(keys, false);         final Object[] array = mk.getKeys();         assertTrue(array != keys);  // still not equal         assertTrue(Arrays.equals(array, keys));         assertSame(ONE, array[0]);         assertSame(TWO, array[1]);         assertEquals(2, array.length);     }      @Test     public void testGetKeysSimpleConstructor() {         final MultiKey<Integer> mk = new MultiKey<>(ONE, TWO);         final Object[] array = mk.getKeys();         assertSame(ONE, array[0]);         assertSame(TWO, array[1]);         assertEquals(2, array.length);     }      @Test     public void testHashCode() {         final MultiKey<Integer> mk1 = new MultiKey<>(ONE, TWO);         final MultiKey<Integer> mk2 = new MultiKey<>(ONE, TWO);         final MultiKey<Object> mk3 = new MultiKey<>(ONE, "TWO");          assertTrue(mk1.hashCode() == mk1.hashCode());         assertTrue(mk1.hashCode() == mk2.hashCode());         assertTrue(mk1.hashCode() != mk3.hashCode());          final int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();         assertEquals(total, mk1.hashCode());     }      @Test     public void testSize() {         assertEquals(2, new MultiKey<>(ONE, TWO).size());         assertEquals(2, new MultiKey<>(null, null).size());         assertEquals(3, new MultiKey<>(ONE, TWO, THREE).size());         assertEquals(3, new MultiKey<>(null, null, null).size());         assertEquals(4, new MultiKey<>(ONE, TWO, THREE, FOUR).size());         assertEquals(4, new MultiKey<>(null, null, null, null).size());         assertEquals(5, new MultiKey<>(ONE, TWO, THREE, FOUR, FIVE).size());         assertEquals(5, new MultiKey<>(null, null, null, null, null).size());          assertEquals(0, new MultiKey<>(new Object[] {}).size());         assertEquals(1, new MultiKey<>(new Integer[] { ONE }).size());         assertEquals(2, new MultiKey<>(new Integer[] { ONE, TWO }).size());         assertEquals(7, new MultiKey<>(new Integer[] { ONE, TWO, ONE, TWO, ONE, TWO, ONE }).size());     }      @Test     public void testTwoArgCtor() {         final MultiKeyTest key1 = new MultiKeyTest();         final MultiKeyTest key2 = new MultiKeyTest();         final MultiKeyTest[] keys = new MultiKey<>(key1, key2).getKeys();         assertNotNull(keys);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import java.util.Map;  import org.apache.commons.collections4.KeyValue; import org.junit.Test;  import static org.junit.Assert.*;  /**  * Test the DefaultMapEntry class.  *  * @since 3.0  */ public class DefaultMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {      //-----------------------------------------------------------------------     /**      * Make an instance of Map.Entry with the default (null) key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry() {         return new DefaultMapEntry<>(null, null);     }      /**      * Make an instance of Map.Entry with the specified key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry(final K key, final V value) {         return new DefaultMapEntry<>(key, value);     }      //-----------------------------------------------------------------------     /**      * Subclasses should override this method.      *      */     @Override     @SuppressWarnings("unchecked")     @Test     public void testConstructors() {         // 1. test key-value constructor         final Map.Entry<K, V> entry = new DefaultMapEntry<>((K) key, (V) value);         assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // 2. test pair constructor         final KeyValue<K, V> pair = new DefaultKeyValue<>((K) key, (V) value);         assertSame(key, pair.getKey());         assertSame(value, pair.getValue());          // 3. test copy constructor         final Map.Entry<K, V> entry2 = new DefaultMapEntry<>(entry);         assertSame(key, entry2.getKey());         assertSame(value, entry2.getValue());          // test that the objects are independent         entry.setValue(null);         assertSame(value, entry2.getValue());     }      @Override     @SuppressWarnings("unchecked")     public void testSelfReferenceHandling() {         final Map.Entry<K, V> entry = makeMapEntry();          try {             entry.setValue((V) entry);             assertSame(entry, entry.getValue());          } catch (final Exception e) {             fail("This Map.Entry implementation supports value self-reference.");         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import java.util.Map;  import org.apache.commons.collections4.KeyValue; import org.apache.commons.collections4.Unmodifiable; import org.junit.Test;  import static org.junit.Assert.*;  /**  * Test the UnmodifiableMapEntry class.  *  * @since 3.0  */ public class UnmodifiableMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {      //-----------------------------------------------------------------------     /**      * Make an instance of Map.Entry with the default (null) key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry() {         return new UnmodifiableMapEntry<>(null, null);     }      /**      * Make an instance of Map.Entry with the specified key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry(final K key, final V value) {         return new UnmodifiableMapEntry<>(key, value);     }      //-----------------------------------------------------------------------     /**      * Subclasses should override this method.      *      */     @Override     @SuppressWarnings("unchecked")     @Test     public void testConstructors() {         // 1. test key-value constructor         Map.Entry<K, V> entry = new UnmodifiableMapEntry<>((K) key, (V) value);         assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // 2. test pair constructor         final KeyValue<K, V> pair = new DefaultKeyValue<>((K) key, (V) value);         entry = new UnmodifiableMapEntry<>(pair);         assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // 3. test copy constructor         final Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<>(entry);         assertSame(key, entry2.getKey());         assertSame(value, entry2.getValue());          assertTrue(entry instanceof Unmodifiable);     }      @Override     @SuppressWarnings("unchecked")     public void testAccessorsAndMutators() {         Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);          assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // check that null doesn't do anything funny         entry = makeMapEntry(null, null);         assertSame(null, entry.getKey());         assertSame(null, entry.getValue());     }      @Override     @Test     public void testSelfReferenceHandling() {         // block     }      @Test     public void testUnmodifiable() {         final Map.Entry<K, V> entry = makeMapEntry();         try {             entry.setValue(null);             fail();         } catch (final UnsupportedOperationException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import org.junit.Test;  import java.util.HashMap; import java.util.Map; import static org.junit.Assert.*;  /**  * Test the TiedMapEntry class.  *  * @since 3.0  */ public class TiedMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {      //-----------------------------------------------------------------------     /**      * Gets the instance to test      */     @Override     public Map.Entry<K, V> makeMapEntry(final K key, final V value) {         final Map<K, V> map = new HashMap<>();         map.put(key, value);         return new TiedMapEntry<>(map, key);     }      //-----------------------------------------------------------------------     /**      * Tests the constructors.      */     @Override     @Test     public void testConstructors() {         // ignore     }      /**      * Tests the constructors.      */     @SuppressWarnings("unchecked")     @Test     public void testSetValue() {         final Map<K, V> map = new HashMap<>();         map.put((K) "A", (V) "a");         map.put((K) "B", (V) "b");         map.put((K) "C", (V) "c");         Map.Entry<K, V> entry = new TiedMapEntry<>(map, (K) "A");         assertSame("A", entry.getKey());         assertSame("a", entry.getValue());         assertSame("a", entry.setValue((V) "x"));         assertSame("A", entry.getKey());         assertSame("x", entry.getValue());          entry = new TiedMapEntry<>(map, (K) "B");         assertSame("B", entry.getKey());         assertSame("b", entry.getValue());         assertSame("b", entry.setValue((V) "y"));         assertSame("B", entry.getKey());         assertSame("y", entry.getValue());          entry = new TiedMapEntry<>(map, (K) "C");         assertSame("C", entry.getKey());         assertSame("c", entry.getValue());         assertSame("c", entry.setValue((V) "z"));         assertSame("C", entry.getKey());         assertSame("z", entry.getValue());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Enumeration; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.concurrent.atomic.AtomicInteger;  import org.junit.Before; import org.junit.Test;  /**  * Tests for FluentIterable.  *  * @since 4.1  */ public class FluentIterableTest {      /**      * Iterable of {@link Integer}s      */     private Iterable<Integer> iterableA = null;      /**      * Iterable of {@link Long}s      */     private Iterable<Long> iterableB = null;      /**      * Collection of even {@link Integer}s      */     private Iterable<Integer> iterableEven = null;      /**      * Collection of odd {@link Integer}s      */     private Iterable<Integer> iterableOdd = null;      /**      * An empty Iterable.      */     private Iterable<Integer> emptyIterable = null;      @Before     public void setUp() {         final Collection<Integer> collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         iterableA = collectionA;          final Collection<Long> collectionB = new LinkedList<>();         collectionB.add(5L);         collectionB.add(4L);         collectionB.add(4L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         iterableB = collectionB;          iterableEven = Arrays.asList(2, 4, 6, 8, 10, 12);         iterableOdd = Arrays.asList(1, 3, 5, 7, 9, 11);          emptyIterable = Collections.emptyList();     }      private static Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;      // -----------------------------------------------------------------------     @Test     public void factoryMethodOf() {         FluentIterable<Integer> iterable = FluentIterable.of(1, 2, 3, 4, 5);         List<Integer> result = iterable.toList();         assertEquals(Arrays.asList(1, 2, 3, 4, 5), result);          iterable = FluentIterable.of(1);         assertEquals(1, iterable.size());         assertFalse(iterable.isEmpty());         assertEquals(Arrays.asList(1), iterable.toList());          result = FluentIterable.of(new Integer[0]).toList();         assertTrue(result.isEmpty());          final Iterable<Integer> it = null;         try {             FluentIterable.of(it).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void appendElements() {         final FluentIterable<Integer> it = FluentIterable.of(iterableA).append(10, 20, 30);         assertEquals(IterableUtils.size(iterableA) + 3, IterableUtils.size(it));         assertTrue(IterableUtils.contains(it, 1));         assertTrue(IterableUtils.contains(it, 10));         assertTrue(IterableUtils.contains(it, 20));         assertTrue(IterableUtils.contains(it, 30));         assertFalse(IterableUtils.contains(it, 40));          final FluentIterable<Integer> empty = FluentIterable.of(emptyIterable).append();         assertTrue(IterableUtils.isEmpty(empty));     }      @Test     public void appendIterable() {         final List<Integer> listB = Arrays.asList(10, 20, 30);         final FluentIterable<Integer> it = FluentIterable.of(iterableA).append(listB);         assertEquals(IterableUtils.size(iterableA) + listB.size(), IterableUtils.size(it));         assertTrue(IterableUtils.contains(it, 1));         assertTrue(IterableUtils.contains(it, 10));         assertTrue(IterableUtils.contains(it, 20));         assertTrue(IterableUtils.contains(it, 30));         assertFalse(IterableUtils.contains(it, 40));     }      @Test     public void collate() {         final List<Integer> result = FluentIterable.of(iterableOdd).collate(iterableEven).toList();         final List<Integer> combinedList = new ArrayList<>();         CollectionUtils.addAll(combinedList, iterableOdd);         CollectionUtils.addAll(combinedList, iterableEven);         Collections.sort(combinedList);         assertEquals(combinedList, result);          try {             FluentIterable.of(iterableOdd).collate(null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void collateWithComparator() {         List<Integer> result =                 FluentIterable                     .of(iterableOdd)                     .collate(iterableEven, ComparatorUtils.<Integer>naturalComparator())                     .toList();          final List<Integer> combinedList = new ArrayList<>();         CollectionUtils.addAll(combinedList, iterableOdd);         CollectionUtils.addAll(combinedList, iterableEven);         Collections.sort(combinedList);         assertEquals(combinedList, result);          // null comparator is equivalent to natural ordering         result = FluentIterable.of(iterableOdd).collate(iterableEven, null).toList();         assertEquals(combinedList, result);     }      @Test     public void filter() {         final Predicate<Integer> smallerThan3 = object -> object.intValue() < 3;         List<Integer> result = FluentIterable.of(iterableA).filter(smallerThan3).toList();         assertEquals(3, result.size());         assertEquals(Arrays.asList(1, 2, 2), result);          // empty iterable         result = FluentIterable.of(emptyIterable).filter(smallerThan3).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).filter(null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void forEach() {         final AtomicInteger sum = new AtomicInteger(0);         final Closure<Integer> closure = input -> sum.addAndGet(input);          FluentIterable.of(iterableA).forEach(closure);         int expectedSum = 0;         for (final Integer i : iterableA) {             expectedSum += i;         }         assertEquals(expectedSum, sum.get());          try {             FluentIterable.of(iterableA).forEach((Closure<Integer>) null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void limit() {         List<Integer> result = FluentIterable.of(iterableA).limit(3).toList();         assertEquals(3, result.size());         assertEquals(Arrays.asList(1, 2, 2), result);          // limit larger than input         result = FluentIterable.of(iterableA).limit(100).toList();         final List<Integer> expected = IterableUtils.toList(iterableA);         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          // limit is 0         result = FluentIterable.of(iterableA).limit(0).toList();         assertEquals(0, result.size());          // empty iterable         result = FluentIterable.of(emptyIterable).limit(3).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).limit(-2).toList();             fail("expecting IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected         }     }      @Test     public void reverse() {         List<Integer> result = FluentIterable.of(iterableA).reverse().toList();         final List<Integer> expected = IterableUtils.toList(iterableA);         Collections.reverse(expected);         assertEquals(expected, result);          // empty iterable         result = FluentIterable.of(emptyIterable).reverse().toList();         assertEquals(0, result.size());     }      @Test     public void skip() {         List<Integer> result = FluentIterable.of(iterableA).skip(4).toList();         assertEquals(6, result.size());         assertEquals(Arrays.asList(3, 3, 4, 4, 4, 4), result);          // skip larger than input         result = FluentIterable.of(iterableA).skip(100).toList();         assertEquals(0, result.size());          // skip 0 elements         result = FluentIterable.of(iterableA).skip(0).toList();         final List<Integer> expected = IterableUtils.toList(iterableA);         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          // empty iterable         result = FluentIterable.of(emptyIterable).skip(3).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).skip(-4).toList();             fail("expecting IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected         }     }      @Test     public void transform() {         final Transformer<Integer, Integer> squared = object -> object * object;         List<Integer> result = FluentIterable.of(iterableA).transform(squared).toList();         assertEquals(10, result.size());         assertEquals(Arrays.asList(1, 4, 4, 9, 9, 9, 16, 16, 16, 16), result);          // empty iterable         result = FluentIterable.of(emptyIterable).transform(squared).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).transform(null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void unique() {         List<Integer> result = FluentIterable.of(iterableA).unique().toList();         assertEquals(4, result.size());         assertEquals(Arrays.asList(1, 2, 3, 4), result);          // empty iterable         result = FluentIterable.of(emptyIterable).unique().toList();         assertEquals(0, result.size());     }      @Test     public void unmodifiable() {         final FluentIterable<Integer> iterable1 = FluentIterable.of(iterableA).unmodifiable();         final Iterator<Integer> it = iterable1.iterator();         assertEquals(1, it.next().intValue());         try {             it.remove();             fail("expecting UnsupportedOperationException");         } catch (final UnsupportedOperationException ise) {             // expected         }          // calling unmodifiable on an already unmodifiable iterable shall return the same instance         final FluentIterable<Integer> iterable2 = iterable1.unmodifiable();         assertSame(iterable1, iterable2);     }      @SuppressWarnings("unchecked")     @Test     public void zip() {         List<Integer> result = FluentIterable.of(iterableOdd).zip(iterableEven).toList();         List<Integer> combinedList = new ArrayList<>();         CollectionUtils.addAll(combinedList, iterableOdd);         CollectionUtils.addAll(combinedList, iterableEven);         Collections.sort(combinedList);         assertEquals(combinedList, result);          try {             FluentIterable.of(iterableOdd).zip((Iterable<Integer>) null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          result = FluentIterable                     .of(Arrays.asList(1, 4, 7))                     .zip(Arrays.asList(2, 5, 8), Arrays.asList(3, 6, 9))                     .toList();         combinedList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);         assertEquals(combinedList, result);     }      @Test     public void asEnumeration() {         Enumeration<Long> enumeration = FluentIterable.of(iterableB).asEnumeration();         final List<Long> result = EnumerationUtils.toList(enumeration);         assertEquals(iterableB, result);          enumeration = FluentIterable.<Long>empty().asEnumeration();         assertFalse(enumeration.hasMoreElements());     }      @Test     public void allMatch() {         assertTrue(FluentIterable.of(iterableEven).allMatch(EVEN));         assertFalse(FluentIterable.of(iterableOdd).allMatch(EVEN));         assertFalse(FluentIterable.of(iterableA).allMatch(EVEN));          try {             FluentIterable.of(iterableEven).allMatch(null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void anyMatch() {         assertTrue(FluentIterable.of(iterableEven).anyMatch(EVEN));         assertFalse(FluentIterable.of(iterableOdd).anyMatch(EVEN));         assertTrue(FluentIterable.of(iterableA).anyMatch(EVEN));          try {             FluentIterable.of(iterableEven).anyMatch(null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void isEmpty() {         assertTrue(FluentIterable.of(emptyIterable).isEmpty());         assertFalse(FluentIterable.of(iterableOdd).isEmpty());     }      @Test     public void size() {         assertEquals(0, FluentIterable.of(emptyIterable).size());         assertEquals(IterableUtils.toList(iterableOdd).size(), FluentIterable.of(iterableOdd).size());     }      @Test     public void eval() {         final List<Integer> listNumbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));         final FluentIterable<Integer> iterable = FluentIterable.of(listNumbers).filter(EVEN);         final FluentIterable<Integer> materialized = iterable.eval();          listNumbers.addAll(Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20));         assertEquals(5, materialized.size());         assertEquals(10, iterable.size());          assertEquals(Arrays.asList(2, 4, 6, 8, 10), materialized.toList());         assertEquals(Arrays.asList(2, 4, 6, 8, 10, 12, 14, 16, 18, 20), iterable.toList());     }      @Test     public void contains() {         assertTrue(FluentIterable.of(iterableEven).contains(2));         assertFalse(FluentIterable.of(iterableEven).contains(1));         assertFalse(FluentIterable.of(iterableEven).contains(null));         assertTrue(FluentIterable.of(iterableEven).append((Integer) null).contains(null));     }      @Test     public void copyInto() {         List<Integer> result = new ArrayList<>();         FluentIterable.of(iterableA).copyInto(result);          List<Integer> expected = IterableUtils.toList(iterableA);         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          result = new ArrayList<>();         result.add(10);         result.add(9);         result.add(8);         FluentIterable.of(iterableA).copyInto(result);          expected = new ArrayList<>(Arrays.asList(10, 9, 8));         expected.addAll(IterableUtils.toList(iterableA));         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          try {             FluentIterable.of(iterableA).copyInto(null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void iterator() {         Iterator<Integer> iterator = FluentIterable.of(iterableA).iterator();         assertTrue(iterator.hasNext());          iterator = FluentIterable.<Integer>empty().iterator();         assertFalse(iterator.hasNext());     }      @Test     public void get() {         assertEquals(2, FluentIterable.of(iterableEven).get(0).intValue());          try {             FluentIterable.of(iterableEven).get(-1);             fail("expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ioe) {             // expected         }          try {             FluentIterable.of(iterableEven).get(IterableUtils.size(iterableEven));             fail("expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ioe) {             // expected         }     }      @SuppressWarnings({ "rawtypes", "unchecked" })     @Test     public void toArray() {         final Long[] arr = new Long[] {1L, 2L, 3L, 4L, 5L};         final Long[] result = FluentIterable.of(arr).toArray(Long.class);         assertNotNull(result);         assertArrayEquals(arr, result);          try {             FluentIterable.of(arr).toArray((Class) String.class);         } catch (final ArrayStoreException ase) {             // expected         }     }      @Test     public void testToString() {         String result = FluentIterable.of(iterableA).toString();         assertEquals(iterableA.toString(), result);          result = FluentIterable.empty().toString();         assertEquals("[]", result);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import static org.easymock.EasyMock.*;  import java.util.Iterator;  import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.w3c.dom.Text;  /**  * Tests the NodeListIterator.  */ public class NodeListIteratorTest extends AbstractIteratorTest<Node> {      // Node array to be filled with mocked Node instances     private Node[] nodes;      // NodeListIterator supports two constructors. This flag allows to     // control, which constructor to use in makeObject() and makeEmptyIterator     private boolean createIteratorWithStandardConstr = true;      /**      * Constructor      * @param testName      */     public NodeListIteratorTest(final String testName) {         super(testName);     }      @Override     protected void setUp() throws Exception {         super.setUp();          // Default: use standard constr.         createIteratorWithStandardConstr = true;           // create mocked Node Instances and fill Node[] to be used by test cases         final Node node1 = createMock(Element.class);         final Node node2 = createMock(Element.class);         final Node node3 = createMock(Text.class);         final Node node4 = createMock(Element.class);         nodes = new Node[] {node1, node2, node3, node4};          replay(node1);         replay(node2);         replay(node3);         replay(node4);     }      @Override     public Iterator<Node> makeEmptyIterator() {         final NodeList emptyNodeList = new NodeList() {             @Override             public Node item(final int index) {                 throw new IndexOutOfBoundsException();             }             @Override             public int getLength() {                 return 0;             }         };          if (createIteratorWithStandardConstr) {             return new NodeListIterator(emptyNodeList);         }         final Node parentNode = createMock(Node.class);         expect(parentNode.getChildNodes()).andStubReturn(emptyNodeList);         replay(parentNode);          return new NodeListIterator(parentNode);     }      @Override     public Iterator<Node> makeObject() {         final NodeList nodeList = new NodeList() {             @Override             public Node item(final int index) {                 return nodes[index];             }             @Override             public int getLength() {                 return nodes.length;             }         };          return new NodeListIterator(nodeList);     }      @Override     public boolean supportsRemove() {         return false;     }      //-----------------------------------------------------------------------     public void testNullConstructor(){         try{             new NodeListIterator((Node) null);             fail("NullPointerException expected!");         }catch(final NullPointerException e){             // expected.         }     }      /**      * tests the convenience Constructor with parameter type org.w3c.Node      */     public void testEmptyIteratorWithNodeConstructor(){         createIteratorWithStandardConstr = false;         testEmptyIterator();     }      /**      * tests the convenience Constructor with parameter type org.w3c.Node      */     public void testFullIteratorWithNodeConstructor(){         createIteratorWithStandardConstr = false;         testFullIterator();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.Predicate;  /**  * Tests the IteratorChain class.  *  */ public class IteratorChainTest extends AbstractIteratorTest<String> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<String> list1 = null;     protected List<String> list2 = null;     protected List<String> list3 = null;      public IteratorChainTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         list1 = new ArrayList<>();         list1.add("One");         list1.add("Two");         list1.add("Three");         list2 = new ArrayList<>();         list2.add("Four");         list3 = new ArrayList<>();         list3.add("Five");         list3.add("Six");     }      @Override     public IteratorChain<String> makeEmptyIterator() {         final ArrayList<String> list = new ArrayList<>();         return new IteratorChain<>(list.iterator());     }      @Override     public IteratorChain<String> makeObject() {         final IteratorChain<String> chain = new IteratorChain<>();          chain.addIterator(list1.iterator());         chain.addIterator(list2.iterator());         chain.addIterator(list3.iterator());         return chain;     }      public void testIterator() {         final Iterator<String> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testRemoveFromFilteredIterator() {          final Predicate<Integer> myPredicate = i -> i.compareTo(Integer.valueOf(4)) < 0;          final List<Integer> list1 = new ArrayList<>();         final List<Integer> list2 = new ArrayList<>();          list1.add(Integer.valueOf(1));         list1.add(Integer.valueOf(2));         list2.add(Integer.valueOf(3));         list2.add(Integer.valueOf(4)); // will be ignored by the predicate          final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);         final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);          final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);         while (it.hasNext()) {             it.next();             it.remove();         }         assertEquals(0, list1.size());         assertEquals(1, list2.size());     }      @Override     public void testRemove() {         final Iterator<String> iter = makeObject();          try {             iter.remove();             fail("Calling remove before the first call to next() should throw an exception");         } catch (final IllegalStateException e) {          }          for (final String testValue : testArray) {             final String iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);              if (!iterValue.equals("Four")) {                 iter.remove();             }         }          assertTrue("List is empty", list1.size() == 0);         assertTrue("List is empty", list2.size() == 1);         assertTrue("List is empty", list3.size() == 0);     }      public void testFirstIteratorIsEmptyBug() {         final List<String> empty = new ArrayList<>();         final List<String> notEmpty = new ArrayList<>();         notEmpty.add("A");         notEmpty.add("B");         notEmpty.add("C");         final IteratorChain<String> chain = new IteratorChain<>();         chain.addIterator(empty.iterator());         chain.addIterator(notEmpty.iterator());         assertTrue("should have next", chain.hasNext());         assertEquals("A", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("B", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("C", chain.next());         assertTrue("should not have next", !chain.hasNext());     }      public void testEmptyChain() {         final IteratorChain<Object> chain = new IteratorChain<>();         assertEquals(false, chain.hasNext());         try {             chain.next();             fail();         } catch (final NoSuchElementException ex) {}         try {             chain.remove();             fail();         } catch (final IllegalStateException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  /**  * Tests the ObjectArrayIterator.  *  */ public class ObjectArrayIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };      public ObjectArrayIteratorTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayIterator<E> makeEmptyIterator() {         return new ObjectArrayIterator<>((E[]) new Object[0]);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayIterator<E> makeObject() {         return new ObjectArrayIterator<>((E[]) testArray);     }      @SuppressWarnings("unchecked")     public ObjectArrayIterator<E> makeArrayIterator() {         return new ObjectArrayIterator<>();     }      public ObjectArrayIterator<E> makeArrayIterator(final E[] array) {         return new ObjectArrayIterator<>(array);     }      public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int index) {         return new ObjectArrayIterator<>(array, index);     }      public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int start, final int end) {         return new ObjectArrayIterator<>(array, start, end);     }      @Override     public boolean supportsRemove() {         return false;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final String testValue : testArray) {             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testNullArray() {         try {             makeArrayIterator(null);              fail("Constructor should throw a NullPointerException when constructed with a null array");         } catch (final NullPointerException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testReset() {         final ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);         it.next();         it.reset();         assertEquals("One", it.next());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableIterator;  /**  * Tests the SingletonIterator to ensure that the next() method will actually  * perform the iteration rather than the hasNext() method.  *  */ public class SingletonIteratorTest<E> extends AbstractIteratorTest<E> {      private static final Object testValue = "foo";      public SingletonIteratorTest(final String testName) {         super(testName);     }      /**      * Returns a SingletonIterator from which      * the element has already been removed.      */     @Override     public SingletonIterator<E> makeEmptyIterator() {         final SingletonIterator<E> iter = makeObject();         iter.next();         iter.remove();         iter.reset();         return iter;     }      @Override     @SuppressWarnings("unchecked")     public SingletonIterator<E> makeObject() {         return new SingletonIterator<>((E) testValue);     }      @Override     public boolean supportsRemove() {         return true;     }      @Override     public boolean supportsEmptyIterator() {         return true;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         assertTrue("Iterator has a first item", iter.hasNext());          final E iterValue = iter.next();         assertEquals("Iteration value is correct", testValue, iterValue);          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      @SuppressWarnings("unchecked")     public void testSingletonIteratorRemove() {         final ResettableIterator<E> iter = new SingletonIterator<>((E) "xyzzy");         assertTrue(iter.hasNext());         assertEquals("xyzzy", iter.next());         iter.remove();         iter.reset();         assertTrue(! iter.hasNext());     }      public void testReset() {         final ResettableIterator<E> it = makeObject();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();         it.reset();          assertEquals(true, it.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * Tests the LoopingIterator class.  *  */ public class LoopingIteratorTest {      /**      * Tests constructor exception.      */     @Test     public void testConstructorEx() throws Exception {         try {             new LoopingIterator<>(null);             fail();         } catch (final NullPointerException ex) {         }     }      /**      * Tests whether an empty looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping0() throws Exception {         final List<Object> list = new ArrayList<>();         final LoopingIterator<Object> loop = new LoopingIterator<>(list);         assertTrue("hasNext should return false", !loop.hasNext());          try {             loop.next();             fail("NoSuchElementException was not thrown during next() call.");         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests whether a populated looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping1() throws Exception {         final List<String> list = Arrays.asList("a");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());      }      /**      * Tests whether a populated looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping2() throws Exception {         final List<String> list = Arrays.asList("a", "b");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("b", loop.next());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());      }      /**      * Tests whether a populated looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping3() throws Exception {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("b", loop.next());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("c", loop.next());          assertTrue("4th hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());      }      /**      * Tests the remove() method on a LoopingIterator wrapped ArrayList.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testRemoving1() throws Exception {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingIterator<String> loop = new LoopingIterator<>(list);         assertEquals("list should have 3 elements.", 3, list.size());          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());         loop.remove();  // removes a         assertEquals("list should have 2 elements.", 2, list.size());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("b", loop.next());         loop.remove();  // removes b         assertEquals("list should have 1 elements.", 1, list.size());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("c", loop.next());         loop.remove();  // removes c         assertEquals("list should have 0 elements.", 0, list.size());          assertFalse("4th hasNext should return false", loop.hasNext());         try {             loop.next();             fail("Expected NoSuchElementException to be thrown.");         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests the reset() method on a LoopingIterator wrapped ArrayList.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testReset() throws Exception {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertEquals("a", loop.next());         assertEquals("b", loop.next());         loop.reset();         assertEquals("a", loop.next());         loop.reset();         assertEquals("a", loop.next());         assertEquals("b", loop.next());         assertEquals("c", loop.next());         loop.reset();         assertEquals("a", loop.next());         assertEquals("b", loop.next());         assertEquals("c", loop.next());     }      /**      * Tests the size() method on a LoopingIterator wrapped ArrayList.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testSize() throws Exception {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertEquals(3, loop.size());         loop.next();         loop.next();         assertEquals(3, loop.size());         loop.reset();         assertEquals(3, loop.size());         loop.next();         loop.remove();         assertEquals(2, loop.size());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Tests for IteratorIterable.  *  */ public class IteratorIterableTest extends BulkTest {      public static Test suite() {         return BulkTest.makeSuite(IteratorIterableTest.class);     }      public IteratorIterableTest(final String name) {         super(name);     }      private Iterator<Integer> createIterator() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iter = list.iterator();         return iter;     }      @SuppressWarnings("unused")     public void testIterator() {         final Iterator<Integer> iter = createIterator();         final Iterable<Number> iterable = new IteratorIterable<>(iter);          // first use         verifyIteration(iterable);          // second use         for (final Number actual : iterable) {             fail("should not be able to iterate twice");         }     }      public void testMultipleUserIterator() {         final Iterator<Integer> iter = createIterator();          final Iterable<Number> iterable = new IteratorIterable<>(iter, true);          // first use         verifyIteration(iterable);          // second use         verifyIteration(iterable);     }      private void verifyIteration(final Iterable<Number> iterable) {         int expected = 0;         for (final Number actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         assertTrue(expected > 0);     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.MapIterator;  /**  * Abstract class for testing the MapIterator interface.  * <p>  * This class provides a framework for testing an implementation of MapIterator.  * Concrete subclasses must provide the list iterator to be tested.  * They must also specify certain details of how the list iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractMapIteratorTest<K, V> extends AbstractIteratorTest<K> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractMapIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implement this method to return a map iterator over an empty map.      *      * @return an empty iterator      */     @Override     public abstract MapIterator<K, V> makeEmptyIterator();      /**      * Implement this method to return a map iterator over a map with elements.      *      * @return a full iterator      */     @Override     public abstract MapIterator<K, V> makeObject();      /**      * Implement this method to return the map which contains the same data as the      * iterator.      *      * @return a full map which can be updated      */     public abstract Map<K, V> getMap();      /**      * Implement this method to return the confirmed map which contains the same      * data as the iterator.      *      * @return a full map which can be updated      */     public abstract Map<K, V> getConfirmedMap();      /**      * Whether or not we are testing an iterator that supports setValue().      * Default is true.      *      * @return true if Iterator supports set      */     public boolean supportsSetValue() {         return true;     }      /**      * Whether the get operation on the map structurally modifies the map,      * such as with LRUMap. Default is false.      *      * @return true if the get method structurally modifies the map      */     public boolean isGetStructuralModify() {         return false;     }      /**      * The values to be used in the add and set tests.      * Default is two strings.      */     @SuppressWarnings("unchecked")     public V[] addSetValues() {         return (V[]) new Object[] { "A", "B" };     }      //-----------------------------------------------------------------------     /**      * Test that the empty list iterator contract is correct.      */     public void testEmptyMapIterator() {         if (!supportsEmptyIterator()) {             return;         }          final MapIterator<K, V> it = makeEmptyIterator();         assertEquals(false, it.hasNext());          // next() should throw a NoSuchElementException         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {}          // getKey() should throw an IllegalStateException         try {             it.getKey();             fail();         } catch (final IllegalStateException ex) {}          // getValue() should throw an IllegalStateException         try {             it.getValue();             fail();         } catch (final IllegalStateException ex) {}          if (!supportsSetValue()) {             // setValue() should throw an UnsupportedOperationException/IllegalStateException             try {                 it.setValue(addSetValues()[0]);                 fail();             } catch (final UnsupportedOperationException ex) {             } catch (final IllegalStateException ex) {}         } else {             // setValue() should throw an IllegalStateException             try {                 it.setValue(addSetValues()[0]);                 fail();             } catch (final IllegalStateException ex) {}         }     }      //-----------------------------------------------------------------------     /**      * Test that the full list iterator contract is correct.      */     public void testFullMapIterator() {         if (!supportsFullIterator()) {             return;         }          final MapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();         assertEquals(true, it.hasNext());          assertEquals(true, it.hasNext());         final Set<K> set = new HashSet<>();         while (it.hasNext()) {             // getKey             final K key = it.next();             assertSame("it.next() should equals getKey()", key, it.getKey());             assertTrue("Key must be in map",  map.containsKey(key));             assertTrue("Key must be unique", set.add(key));              // getValue             final V value = it.getValue();             if (!isGetStructuralModify()) {                 assertSame("Value must be mapped to key", map.get(key), value);             }             assertTrue("Value must be in map",  map.containsValue(value));              verify();         }     }      //-----------------------------------------------------------------------     public void testMapIteratorSet() {         if (!supportsFullIterator()) {             return;         }          final V newValue = addSetValues()[0];         final V newValue2 = addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1];         final MapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();         final Map<K, V> confirmed = getConfirmedMap();         assertEquals(true, it.hasNext());         final K key = it.next();         final V value = it.getValue();          if (!supportsSetValue()) {             try {                 it.setValue(newValue);                 fail();             } catch (final UnsupportedOperationException ex) {}             return;         }         final V old = it.setValue(newValue);         confirmed.put(key, newValue);         assertSame("Key must not change after setValue", key, it.getKey());         assertSame("Value must be changed after setValue", newValue, it.getValue());         assertSame("setValue must return old value", value, old);         assertEquals("Map must contain key", true, map.containsKey(key));         // test against confirmed, as map may contain value twice         assertEquals("Map must not contain old value",             confirmed.containsValue(old), map.containsValue(old));         assertEquals("Map must contain new value", true, map.containsValue(newValue));         verify();          it.setValue(newValue);  // same value - should be OK         confirmed.put(key, newValue);         assertSame("Key must not change after setValue", key, it.getKey());         assertSame("Value must be changed after setValue", newValue, it.getValue());         verify();          it.setValue(newValue2);  // new value         confirmed.put(key, newValue2);         assertSame("Key must not change after setValue", key, it.getKey());         assertSame("Value must be changed after setValue", newValue2, it.getValue());         verify();     }      //-----------------------------------------------------------------------     @Override     public void testRemove() { // override         final MapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();         final Map<K, V> confirmed = getConfirmedMap();         assertEquals(true, it.hasNext());         final K key = it.next();          if (!supportsRemove()) {             try {                 it.remove();                 fail();             } catch (final UnsupportedOperationException ex) {             }             return;         }          it.remove();         confirmed.remove(key);         assertEquals(false, map.containsKey(key));         verify();          try {             it.remove();  // second remove fails         } catch (final IllegalStateException ex) {         }         verify();     }      //-----------------------------------------------------------------------     public void testMapIteratorSetRemoveSet() {         if (!supportsSetValue() || !supportsRemove()) {             return;         }         final V newValue = addSetValues()[0];         final MapIterator<K, V> it = makeObject();         final Map<K, V> confirmed = getConfirmedMap();          assertEquals(true, it.hasNext());         final K key = it.next();          it.setValue(newValue);         it.remove();         confirmed.remove(key);         verify();          try {             it.setValue(newValue);             fail();         } catch (final IllegalStateException ex) {}         verify();     }      //-----------------------------------------------------------------------     public void testMapIteratorRemoveGetKey() {         if (!supportsRemove()) {             return;         }         final MapIterator<K, V> it = makeObject();         final Map<K, V> confirmed = getConfirmedMap();          assertEquals(true, it.hasNext());         final K key = it.next();          it.remove();         confirmed.remove(key);         verify();          try {             it.getKey();             fail();         } catch (final IllegalStateException ex) {}         verify();     }      //-----------------------------------------------------------------------     public void testMapIteratorRemoveGetValue() {         if (!supportsRemove()) {             return;         }         final MapIterator<K, V> it = makeObject();         final Map<K, V> confirmed = getConfirmedMap();          assertEquals(true, it.hasNext());         final K key = it.next();          it.remove();         confirmed.remove(key);         verify();          try {             it.getValue();             fail();         } catch (final IllegalStateException ex) {}         verify();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableIterator;  /**  * Tests the SingletonIterator to ensure that the next() method will actually  * perform the iteration rather than the hasNext() method.  *  */ public class SingletonIterator2Test<E> extends AbstractIteratorTest<E> {      private static final Object testValue = "foo";      public SingletonIterator2Test(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public SingletonIterator<E> makeEmptyIterator() {         final SingletonIterator<E> iter = new SingletonIterator<>((E) testValue);         iter.next();         iter.remove();         iter.reset();         return iter;     }      @Override     @SuppressWarnings("unchecked")     public SingletonIterator<E> makeObject() {         return new SingletonIterator<>((E) testValue, false);     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsEmptyIterator() {         return false;     }      //-----------------------------------------------------------------------     public void testIterator() {         final Iterator<E> iter = makeObject();         assertTrue("Iterator has a first item", iter.hasNext());          final E iterValue = iter.next();         assertEquals("Iteration value is correct", testValue, iterValue);          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testReset() {         final ResettableIterator<E> it = makeObject();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();         it.reset();          assertEquals(true, it.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  /**  * Test the ArrayListIterator class with primitives.  *  */ public class ArrayListIterator2Test<E> extends ArrayIterator2Test<E> {      public ArrayListIterator2Test(final String testName) {         super(testName);     }      @Override     public ArrayListIterator<E> makeEmptyIterator() {         return new ArrayListIterator<>(new int[0]);     }      @Override     public ArrayListIterator<E> makeObject() {         return new ArrayListIterator<>(testArray);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array) {         return new ArrayListIterator<>(array);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array, final int index) {         return new ArrayListIterator<>(array, index);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array, final int start, final int end) {         return new ArrayListIterator<>(array, start, end);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test; import static org.junit.Assert.*;  /**  * Tests the LoopingListIterator class.  *  */ public class LoopingListIteratorTest {      /**      * Tests constructor exception.      */     @Test     public void testConstructorEx() throws Exception {         try {             new LoopingListIterator<>(null);             fail();         } catch (final NullPointerException ex) {         }     }      /**      * Tests whether an empty looping list iterator works.      */     @Test     public void testLooping0() throws Exception {         final List<Object> list = new ArrayList<>();         final LoopingListIterator<Object> loop = new LoopingListIterator<>(list);         assertFalse(loop.hasNext());         assertFalse(loop.hasPrevious());          try {             loop.next();             fail();         } catch (final NoSuchElementException ex) {         }          try {             loop.previous();             fail();         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests whether a looping list iterator works on a list with only      * one element.      */     @Test     public void testLooping1() throws Exception {         final List<String> list = Arrays.asList("a");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a>          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // <a>          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // <a>          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // <a>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>     }      /**      * Tests whether a looping list iterator works on a list with two      * elements.      */     @Test     public void testLooping2() throws Exception {         final List<String> list = Arrays.asList("a", "b");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // a <b>          assertTrue(loop.hasNext());         assertEquals("b", loop.next());     // <a> b          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // a <b>          // Reset the iterator and try using previous.         loop.reset();                       // <a> b          assertTrue(loop.hasPrevious());         assertEquals("b", loop.previous()); // a <b>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a> b          assertTrue(loop.hasPrevious());         assertEquals("b", loop.previous()); // a <b>     }      /**      * Tests jogging back and forth between two elements, but not over      * the begin/end boundary of the list.      */     @Test     public void testJoggingNotOverBoundary() {         final List<String> list = Arrays.asList("a", "b");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b          // Try jogging back and forth between the elements, but not         // over the begin/end boundary.         loop.reset();         assertEquals("a", loop.next());     // a <b>         assertEquals("a", loop.previous()); // <a> b         assertEquals("a", loop.next());     // a <b>          assertEquals("b", loop.next());     // <a> b         assertEquals("b", loop.previous()); // a <b>         assertEquals("b", loop.next());     // <a> b     }      /**      * Tests jogging back and forth between two elements over the      * begin/end boundary of the list.      */     @Test     public void testJoggingOverBoundary() {         final List<String> list = Arrays.asList("a", "b");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b          // Try jogging back and forth between the elements, but not         // over the begin/end boundary.         assertEquals("b", loop.previous()); // a <b>         assertEquals("b", loop.next());     // <a> b         assertEquals("b", loop.previous()); // a <b>          assertEquals("a", loop.previous()); // <a> b         assertEquals("a", loop.next());     // a <b>         assertEquals("a", loop.previous()); // <a> b     }      /**      * Tests removing an element from a wrapped ArrayList.      */     @Test     public void testRemovingElementsAndIteratingForward() {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertTrue(loop.hasNext());         assertEquals("a", loop.next()); // a <b> c         loop.remove();                  // <b> c         assertEquals(2, list.size());          assertTrue(loop.hasNext());         assertEquals("b", loop.next()); // b <c>         loop.remove();                  // <c>         assertEquals(1, list.size());          assertTrue(loop.hasNext());         assertEquals("c", loop.next()); // <c>         loop.remove();                  // ---         assertEquals(0, list.size());          assertFalse(loop.hasNext());         try {             loop.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests removing an element from a wrapped ArrayList.      */     @Test     public void testRemovingElementsAndIteratingBackwards() {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertTrue(loop.hasPrevious());         assertEquals("c", loop.previous()); // a b <c>         loop.remove();                      // <a> b         assertEquals(2, list.size());          assertTrue(loop.hasPrevious());         assertEquals("b", loop.previous()); // a <b>         loop.remove();                      // <a>         assertEquals(1, list.size());          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>         loop.remove();                      // ---         assertEquals(0, list.size());          assertFalse(loop.hasPrevious());         try {             loop.previous();             fail();         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests the reset method.      */     @Test     public void testReset() {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertEquals("a", loop.next()); // a <b> c         assertEquals("b", loop.next()); // a b <c>         loop.reset();                   // <a> b c         assertEquals("a", loop.next()); // a <b> c         loop.reset();                   // <a> b c         assertEquals("a", loop.next()); // a <b> c         assertEquals("b", loop.next()); // a b <c>         assertEquals("c", loop.next()); // <a> b c         loop.reset();                   // <a> b c          assertEquals("c", loop.previous()); // a b <c>         assertEquals("b", loop.previous()); // a <b> c         loop.reset();                       // <a> b c         assertEquals("c", loop.previous()); // a b <c>         loop.reset();                       // <a> b c         assertEquals("c", loop.previous()); // a b <c>         assertEquals("b", loop.previous()); // a <b> c         assertEquals("a", loop.previous()); // <a> b c     }      /**      * Tests the add method.      */     @Test     public void testAdd() {         List<String> list = new ArrayList<>(Arrays.asList("b", "e", "f"));         LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <b> e f          loop.add("a");                      // <a> b e f         assertEquals("b", loop.next());     // a <b> e f         loop.reset();                       // <a> b e f         assertEquals("a", loop.next());     // a <b> e f         assertEquals("b", loop.next());     // a b <e> f          loop.add("c");                      // a b c <e> f         assertEquals("e", loop.next());     // a b c e <f>         assertEquals("e", loop.previous()); // a b c <e> f         assertEquals("c", loop.previous()); // a b <c> e f         assertEquals("c", loop.next());     // a b c <e> f          loop.add("d");                      // a b c d <e> f         loop.reset();                       // <a> b c d e f         assertEquals("a", loop.next());     // a <b> c d e f         assertEquals("b", loop.next());     // a b <c> d e f         assertEquals("c", loop.next());     // a b c <d> e f         assertEquals("d", loop.next());     // a b c d <e> f         assertEquals("e", loop.next());     // a b c d e <f>         assertEquals("f", loop.next());     // <a> b c d e f         assertEquals("a", loop.next());     // a <b> c d e f          list = new ArrayList<>(Arrays.asList("b", "e", "f"));         loop = new LoopingListIterator<>(list); // <b> e f          loop.add("a");                      // a <b> e f         assertEquals("a", loop.previous()); // a b e <f>         loop.reset();                       // <a> b e f         assertEquals("f", loop.previous()); // a b e <f>         assertEquals("e", loop.previous()); // a b <e> f          loop.add("d");                      // a b d <e> f         assertEquals("d", loop.previous()); // a b <d> e f          loop.add("c");                      // a b c <d> e f         assertEquals("c", loop.previous()); // a b <c> d e f          loop.reset();         assertEquals("a", loop.next());     // a <b> c d e f         assertEquals("b", loop.next());     // a b <c> d e f         assertEquals("c", loop.next());     // a b c <d> e f         assertEquals("d", loop.next());     // a b c d <e> f         assertEquals("e", loop.next());     // a b c d e <f>         assertEquals("f", loop.next());     // <a> b c d e f         assertEquals("a", loop.next());     // a <b> c d e f     }      /**      * Tests nextIndex and previousIndex.      */     @Test     public void testNextAndPreviousIndex() {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertEquals(0, loop.nextIndex());         assertEquals(2, loop.previousIndex());          assertEquals("a", loop.next());        // a <b> c         assertEquals(1, loop.nextIndex());         assertEquals(0, loop.previousIndex());          assertEquals("a", loop.previous());    // <a> b c         assertEquals(0, loop.nextIndex());         assertEquals(2, loop.previousIndex());          assertEquals("c", loop.previous());    // a b <c>         assertEquals(2, loop.nextIndex());         assertEquals(1, loop.previousIndex());          assertEquals("b", loop.previous());    // a <b> c         assertEquals(1, loop.nextIndex());         assertEquals(0, loop.previousIndex());          assertEquals("a", loop.previous());    // <a> b c         assertEquals(0, loop.nextIndex());         assertEquals(2, loop.previousIndex());     }      /**      * Tests using the set method to change elements.      */     @Test     public void testSet() {         final List<String> list = Arrays.asList("q", "r", "z");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <q> r z          assertEquals("z", loop.previous()); // q r <z>         loop.set("c");                      // q r <c>          loop.reset();                       // <q> r c         assertEquals("q", loop.next());     // q <r> c         loop.set("a");                      // a <r> c          assertEquals("r", loop.next());     // a r <c>         loop.set("b");                      // a b <c>          loop.reset();                       // <a> b c         assertEquals("a", loop.next());     // a <b> c         assertEquals("b", loop.next());     // a b <c>         assertEquals("c", loop.next());     // <a> b c     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Arrays; import java.util.ListIterator; import java.util.NoSuchElementException;  /**  * Test the ArrayListIterator class.  *  */ public class ArrayListIteratorTest<E> extends ArrayIteratorTest<E> {      public ArrayListIteratorTest(final String testName) {         super(testName);     }      @Override     public ArrayListIterator<E> makeEmptyIterator() {         return new ArrayListIterator<>(new Object[0]);     }      @Override     public ArrayListIterator<E> makeObject() {         return new ArrayListIterator<>(testArray);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array) {         return new ArrayListIterator<>(array);     }      @Override     public boolean supportsRemove() {         return false;     }      /**      * Test the basic ListIterator functionality - going backwards using      * {@code previous()}.      */     public void testListIterator() {         final ListIterator<E> iter = makeObject();          // TestArrayIterator#testIterator() has already tested the iterator forward,         //  now we need to test it in reverse          // fast-forward the iterator to the end...         while (iter.hasNext()) {             iter.next();         }          for (int x = testArray.length - 1; x >= 0; x--) {             final Object testValue = testArray[x];             final Object iterValue = iter.previous();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasPrevious());          try {             iter.previous();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }      }      /**      * Tests the {@link java.util.ListIterator#set} operation.      */     @SuppressWarnings("unchecked")     public void testListIteratorSet() {         final String[] testData = new String[] { "a", "b", "c" };          final String[] result = new String[] { "0", "1", "2" };          ListIterator<E> iter = makeArrayListIterator(testData);         int x = 0;          while (iter.hasNext()) {             iter.next();             iter.set((E) Integer.toString(x));             x++;         }          assertTrue("The two arrays should have the same value, i.e. {0,1,2}", Arrays.equals(testData, result));          // a call to set() before a call to next() or previous() should throw an IllegalStateException         iter = makeArrayListIterator(testArray);          try {             iter.set((E) "should fail");             fail("ListIterator#set should fail if next() or previous() have not yet been called.");         } catch (final IllegalStateException e) {             // expected         } catch (final Throwable t) { // should never happen             fail(t.toString());         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.AbstractObjectTest;  /**  * Abstract class for testing the Iterator interface.  * <p>  * This class provides a framework for testing an implementation of Iterator.  * Concrete subclasses must provide the iterator to be tested.  * They must also specify certain details of how the iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractIteratorTest<E> extends AbstractObjectTest {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implement this method to return an iterator over an empty collection.      *      * @return an empty iterator      */     public abstract Iterator<E> makeEmptyIterator();      /**      * Implements the abstract superclass method to return the full iterator.      *      * @return a full iterator      */     @Override     public abstract Iterator<E> makeObject();      /**      * Whether or not we are testing an iterator that can be empty.      * Default is true.      *      * @return true if Iterator can be empty      */     public boolean supportsEmptyIterator() {         return true;     }      /**      * Whether or not we are testing an iterator that can contain elements.      * Default is true.      *      * @return true if Iterator can be full      */     public boolean supportsFullIterator() {         return true;     }      /**      * Whether or not we are testing an iterator that supports remove().      * Default is true.      *      * @return true if Iterator supports remove      */     public boolean supportsRemove() {         return true;     }      /**      * Allows subclasses to add complex cross verification      */     public void verify() {         // do nothing     }      //-----------------------------------------------------------------------     /**      * Test the empty iterator.      */     public void testEmptyIterator() {         if (!supportsEmptyIterator()) {             return;         }          final Iterator<E> it = makeEmptyIterator();          // hasNext() should return false         assertEquals("hasNext() should return false for empty iterators", false, it.hasNext());          // next() should throw a NoSuchElementException         try {             it.next();             fail("NoSuchElementException must be thrown when Iterator is exhausted");         } catch (final NoSuchElementException e) {         }         verify();          assertNotNull(it.toString());     }      /**      * Test normal iteration behavior.      */     public void testFullIterator() {         if (!supportsFullIterator()) {             return;         }          final Iterator<E> it = makeObject();          // hasNext() must be true (ensure makeFullIterator is correct!)         assertEquals("hasNext() should return true for at least one element", true, it.hasNext());          // next() must not throw exception (ensure makeFullIterator is correct!)         try {             it.next();         } catch (final NoSuchElementException e) {             fail("Full iterators must have at least one element");         }          // iterate through         while (it.hasNext()) {             it.next();             verify();         }          // next() must throw NoSuchElementException now         try {             it.next();             fail("NoSuchElementException must be thrown when Iterator is exhausted");         } catch (final NoSuchElementException e) {         }          assertNotNull(it.toString());     }      /**      * Test remove behavior.      */     public void testRemove() {         final Iterator<E> it = makeObject();          if (!supportsRemove()) {             // check for UnsupportedOperationException if not supported             try {                 it.remove();             } catch (final UnsupportedOperationException ex) {}             return;         }          // should throw IllegalStateException before next() called         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {}         verify();          // remove after next should be fine         it.next();         it.remove();          // should throw IllegalStateException for second remove()         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List;  import org.apache.commons.collections4.comparators.ComparableComparator;  /**  * Unit test suite for {@link CollatingIterator}.  *  */ @SuppressWarnings("boxing") public class CollatingIteratorTest extends AbstractIteratorTest<Integer> {      //------------------------------------------------------------ Conventional      public CollatingIteratorTest(final String testName) {         super(testName);     }      //--------------------------------------------------------------- Lifecycle      private Comparator<Integer> comparator = null;     private ArrayList<Integer> evens = null;     private ArrayList<Integer> odds = null;     private ArrayList<Integer> fib = null;      @Override     public void setUp() throws Exception {         super.setUp();         comparator = new ComparableComparator<>();         evens = new ArrayList<>();         odds = new ArrayList<>();         for (int i = 0; i < 20; i++) {             if (0 == i % 2) {                 evens.add(i);             } else {                 odds.add(i);             }         }         fib = new ArrayList<>();         fib.add(1);         fib.add(1);         fib.add(2);         fib.add(3);         fib.add(5);         fib.add(8);         fib.add(13);         fib.add(21);     }      //---------------------------------------------------- TestIterator Methods      @Override     public CollatingIterator<Integer> makeEmptyIterator() {         return new CollatingIterator<>(comparator);     }      @Override     public CollatingIterator<Integer> makeObject() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         iter.addIterator(odds.iterator());         iter.addIterator(fib.iterator());         return iter;     }      //------------------------------------------------------------------- Tests      public void testGetSetComparator() {         final CollatingIterator<Integer> iter = new CollatingIterator<>();         assertNull(iter.getComparator());         iter.setComparator(comparator);         assertSame(comparator, iter.getComparator());         iter.setComparator(null);         assertNull(iter.getComparator());     }      public void testIterateEven() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertEquals(0, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenOdd() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator, evens.iterator(), odds.iterator());         for (int i = 0; i < 20; i++) {             assertTrue(iter.hasNext());             assertEquals(Integer.valueOf(i), iter.next());             assertEquals(i % 2, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateOddEven() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator, odds.iterator(), evens.iterator());         for (int i = 0; i < 20; i++) {             assertTrue(iter.hasNext());             assertEquals(Integer.valueOf(i), iter.next());             assertEquals(i % 2 == 0 ? 1 : 0, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenEven() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         iter.addIterator(evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertEquals(0, iter.getIteratorIndex());             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertEquals(1, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateFibEvenOdd() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(fib.iterator());         iter.addIterator(evens.iterator());         iter.addIterator(odds.iterator());          assertEquals(Integer.valueOf(0), iter.next());  // even   0         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(1), iter.next());  // odd    1         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(2), iter.next());  // fib    2         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(2), iter.next());  // even   2         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(3), iter.next());  // fib    3         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(3), iter.next());  // odd    3         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(4), iter.next());  // even   4         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(5), iter.next());  // fib    5         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(5), iter.next());  // odd    5         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(6), iter.next());  // even   6         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(7), iter.next());  // odd    7         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(8), iter.next());  // fib    8         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(8), iter.next());  // even   8         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(9), iter.next());  // odd    9         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(10), iter.next()); // even  10         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(11), iter.next()); // odd   11         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(12), iter.next()); // even  12         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(13), iter.next()); // fib   13         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(13), iter.next()); // odd   13         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(14), iter.next()); // even  14         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(15), iter.next()); // odd   15         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(16), iter.next()); // even  16         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(17), iter.next()); // odd   17         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(18), iter.next()); // even  18         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(19), iter.next()); // odd   19         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(21), iter.next()); // fib   21         assertEquals(0, iter.getIteratorIndex());          assertTrue(!iter.hasNext());     }      public void testRemoveFromSingle() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         int expectedSize = evens.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size());     }      public void testRemoveFromDouble() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         iter.addIterator(odds.iterator());         int expectedSize = evens.size() + odds.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size() + odds.size());     }      public void testNullComparator() {         final List<Integer> l1 = Arrays.asList(1, 3, 5);         final List<Integer> l2 = Arrays.asList(2, 4, 6);          final CollatingIterator<Integer> collatingIterator1 = new CollatingIterator<>(null, l1.iterator(), l2.iterator());         try {             collatingIterator1.next();         } catch (final NullPointerException e) {             assertTrue(e.getMessage().startsWith("You must invoke setComparator"));         }          int i = 0;         final CollatingIterator<Integer> collatingIterator2 = new CollatingIterator<>(null, l1.iterator(), l2.iterator());         collatingIterator2.setComparator(new ComparableComparator<Integer>());         for ( ; collatingIterator2.hasNext(); i++ ) {             final Integer n = collatingIterator2.next();             assertEquals("wrong order", (int) n, i + 1);         }         assertEquals("wrong size", i, l1.size() + l2.size());     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.ListIterator;  import org.apache.commons.collections4.Unmodifiable;  /**  * Tests the UnmodifiableListIterator.  *  */ public class UnmodifiableListIteratorTest<E> extends AbstractListIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };     protected List<E> testList;      public UnmodifiableListIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public ListIterator<E> makeEmptyIterator() {         return UnmodifiableListIterator.umodifiableListIterator(Collections.<E>emptyList().listIterator());     }      @Override     public ListIterator<E> makeObject() {         return UnmodifiableListIterator.umodifiableListIterator(testList.listIterator());     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsAdd() {         return false;     }      @Override     public boolean supportsSet() {         return false;     }      //-----------------------------------------------------------------------     public void testListIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         ListIterator<E> it = makeObject();         assertSame(it, UnmodifiableListIterator.umodifiableListIterator(it));          it = testList.listIterator();         assertTrue(it != UnmodifiableListIterator.umodifiableListIterator(it));          try {             UnmodifiableListIterator.umodifiableListIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.ListIterator; import java.util.Random;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.PredicateUtils; import org.apache.commons.collections4.list.GrowthList; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * Tests the FilterListIterator class.  *  */ @SuppressWarnings("boxing") public class FilterListIteratorTest {      private ArrayList<Integer> list = null;     private ArrayList<Integer> odds = null;     private ArrayList<Integer> evens = null;     private ArrayList<Integer> threes = null;     private ArrayList<Integer> fours = null;     private ArrayList<Integer> sixes = null;     private Predicate<Integer> truePred = null;     private Predicate<Integer> falsePred = null;     private Predicate<Integer> evenPred = null;     private Predicate<Integer> oddPred = null;     private Predicate<Integer> threePred = null;     private Predicate<Integer> fourPred = null;     private final Random random = new Random();      @Before     public void setUp() {         list = new ArrayList<>();         odds = new ArrayList<>();         evens = new ArrayList<>();         threes = new ArrayList<>();         fours = new ArrayList<>();         sixes = new ArrayList<>();         for (int i = 0; i < 20; i++) {             list.add(Integer.valueOf(i));             if (i % 2 == 0) {                 evens.add(Integer.valueOf(i));             }             if (i % 2 != 0) {                 odds.add(Integer.valueOf(i));             }             if (i % 3 == 0) {                 threes.add(Integer.valueOf(i));             }             if (i % 4 == 0) {                 fours.add(Integer.valueOf(i));             }             if (i % 6 == 0) {                 sixes.add(Integer.valueOf(i));             }         }          truePred = x -> true;          falsePred = x -> true;          evenPred = x -> x % 2 == 0;          oddPred = x -> x % 2 != 0;          threePred = x -> x % 3 == 0;          fourPred = x -> x % 4 == 0;      }      @After     public void tearDown() throws Exception {         list = null;         odds = null;         evens = null;         threes = null;         fours = null;         sixes = null;         truePred = null;         falsePred = null;         evenPred = null;         oddPred = null;         threePred = null;         fourPred = null;     }      @Test     public void testWalkLists() {         // this just confirms that our walkLists method works OK         walkLists(list, list.listIterator());     }      @Test     public void testManual() {         // do this one "by hand" as a sanity check         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);          assertEquals(Integer.valueOf(0), filtered.next());         assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());         assertEquals(Integer.valueOf(9), filtered.next());         assertEquals(Integer.valueOf(12), filtered.next());         assertEquals(Integer.valueOf(15), filtered.next());         assertEquals(Integer.valueOf(18), filtered.next());          assertEquals(Integer.valueOf(18), filtered.previous());         assertEquals(Integer.valueOf(15), filtered.previous());         assertEquals(Integer.valueOf(12), filtered.previous());         assertEquals(Integer.valueOf(9), filtered.previous());         assertEquals(Integer.valueOf(6), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.previous());         assertEquals(Integer.valueOf(0), filtered.previous());          assertTrue(!filtered.hasPrevious());          assertEquals(Integer.valueOf(0), filtered.next());         assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());         assertEquals(Integer.valueOf(9), filtered.next());         assertEquals(Integer.valueOf(12), filtered.next());         assertEquals(Integer.valueOf(15), filtered.next());         assertEquals(Integer.valueOf(18), filtered.next());          assertTrue(!filtered.hasNext());          assertEquals(Integer.valueOf(18), filtered.previous());         assertEquals(Integer.valueOf(15), filtered.previous());         assertEquals(Integer.valueOf(12), filtered.previous());         assertEquals(Integer.valueOf(9), filtered.previous());         assertEquals(Integer.valueOf(6), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.previous());         assertEquals(Integer.valueOf(0), filtered.previous());          assertEquals(Integer.valueOf(0), filtered.next());         assertEquals(Integer.valueOf(0), filtered.previous());         assertEquals(Integer.valueOf(0), filtered.next());          assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());         assertEquals(Integer.valueOf(6), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());          assertEquals(Integer.valueOf(9), filtered.next());         assertEquals(Integer.valueOf(12), filtered.next());         assertEquals(Integer.valueOf(15), filtered.next());         assertEquals(Integer.valueOf(15), filtered.previous());         assertEquals(Integer.valueOf(12), filtered.previous());         assertEquals(Integer.valueOf(9), filtered.previous());     }      @Test     public void testTruePredicate() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);         walkLists(list, filtered);     }      @Test     public void testFalsePredicate() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), falsePred);         walkLists(new ArrayList<Integer>(), filtered);     }      @Test     public void testEvens() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), evenPred);         walkLists(evens, filtered);     }      @Test     public void testOdds() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), oddPred);         walkLists(odds, filtered);     }      @Test     public void testThrees() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);         walkLists(threes, filtered);     }      @Test     public void testFours() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);         walkLists(fours, filtered);     }      @Test     public void testNestedSixes() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(                                         new FilterListIterator<>(list.listIterator(), threePred),                                         evenPred                                       );         walkLists(sixes, filtered);     }      @Test     public void testNestedSixes2() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(                                         new FilterListIterator<>(list.listIterator(), evenPred),                                         threePred                                       );         walkLists(sixes, filtered);     }      @Test     public void testNestedSixes3() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(                                         new FilterListIterator<>(list.listIterator(), threePred),                                         evenPred                                       );         walkLists(sixes, new FilterListIterator<>(filtered, truePred));     }      @Test     public void testNextChangesPrevious() {         {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);             nextNextPrevious(threes.listIterator(), filtered);         }          {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);             nextNextPrevious(list.listIterator(), filtered);         }     }      @Test     public void testPreviousChangesNext() {         {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);             final ListIterator<Integer> expected = threes.listIterator();             walkForward(expected, filtered);             previousPreviousNext(expected, filtered);         }         {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);             final ListIterator<Integer> expected = list.listIterator();             walkForward(expected, filtered);             previousPreviousNext(expected, filtered);         }     }      @Test     public void testFailingHasNextBug() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);         final ListIterator<Integer> expected = fours.listIterator();         while (expected.hasNext()) {             expected.next();             filtered.next();         }         assertTrue(filtered.hasPrevious());         assertTrue(!filtered.hasNext());         assertEquals(expected.previous(), filtered.previous());     }      /**      * Test for {@link "https://issues.apache.org/jira/browse/COLLECTIONS-360 COLLECTIONS-360"}      */     @Test     public void testCollections360() throws Throwable {         final Collection<Predicate<Object>> var7 = new GrowthList<>();         final Predicate<Object> var9 = PredicateUtils.anyPredicate(var7);         final FilterListIterator<Object> var13 = new FilterListIterator<>(var9);         Assert.assertFalse(var13.hasNext());         final FilterListIterator<Object> var14 = new FilterListIterator<>(var9);         Assert.assertFalse(var14.hasPrevious());     }      // Utilities      private void walkForward(final ListIterator<?> expected, final ListIterator<?> testing) {         while (expected.hasNext()) {             assertEquals(expected.nextIndex(), testing.nextIndex());             assertEquals(expected.previousIndex(), testing.previousIndex());             assertTrue(testing.hasNext());             assertEquals(expected.next(), testing.next());         }     }      private void walkBackward(final ListIterator<?> expected, final ListIterator<?> testing) {         while (expected.hasPrevious()) {             assertEquals(expected.nextIndex(), testing.nextIndex());             assertEquals(expected.previousIndex(), testing.previousIndex());             assertTrue(testing.hasPrevious());             assertEquals(expected.previous(), testing.previous());         }     }      private void nextNextPrevious(final ListIterator<?> expected, final ListIterator<?> testing) {         // calls to next() should change the value returned by previous()         // even after previous() has been set by a call to hasPrevious()         assertEquals(expected.next(), testing.next());         assertEquals(expected.hasPrevious(), testing.hasPrevious());         final Object expecteda = expected.next();         final Object testinga = testing.next();         assertEquals(expecteda, testinga);         final Object expectedb = expected.previous();         final Object testingb = testing.previous();         assertEquals(expecteda, expectedb);         assertEquals(testinga, testingb);     }      private void previousPreviousNext(final ListIterator<?> expected, final ListIterator<?> testing) {         // calls to previous() should change the value returned by next()         // even after next() has been set by a call to hasNext()         assertEquals(expected.previous(), testing.previous());         assertEquals(expected.hasNext(), testing.hasNext());         final Object expecteda = expected.previous();         final Object testinga = testing.previous();         assertEquals(expecteda, testinga);         final Object expectedb = expected.next();         final Object testingb = testing.next();         assertEquals(expecteda, testingb);         assertEquals(expecteda, expectedb);         assertEquals(testinga, testingb);     }      private <E> void walkLists(final List<E> list, final ListIterator<E> testing) {         final ListIterator<E> expected = list.listIterator();          // walk all the way forward         walkForward(expected, testing);          // walk all the way back         walkBackward(expected, testing);          // forward,back,forward         while (expected.hasNext()) {             assertEquals(expected.nextIndex(), testing.nextIndex());             assertEquals(expected.previousIndex(), testing.previousIndex());             assertTrue(testing.hasNext());             assertEquals(expected.next(), testing.next());             assertTrue(testing.hasPrevious());             assertEquals(expected.previous(), testing.previous());             assertTrue(testing.hasNext());             assertEquals(expected.next(), testing.next());         }          // walk all the way back         walkBackward(expected, testing);          for (int i = 0; i < list.size(); i++) {             // walk forward i             for (int j = 0; j < i; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasNext());                 assertEquals(expected.next(), testing.next());             }             // walk back i/2             for (int j = 0; j < i / 2; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasPrevious());                 assertEquals(expected.previous(), testing.previous());             }             // walk forward i/2             for (int j = 0; j < i / 2; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasNext());                 assertEquals(expected.next(), testing.next());             }             // walk back i             for (int j = 0; j < i; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasPrevious());                 assertEquals(expected.previous(), testing.previous());             }         }          // random walk         final StringBuilder walkdescr = new StringBuilder(500);         for (int i = 0; i < 500; i++) {             if (random.nextBoolean()) {                 // step forward                 walkdescr.append("+");                 if (expected.hasNext()) {                     assertEquals(walkdescr.toString(), expected.next(), testing.next());                 }             } else {                 // step backward                 walkdescr.append("-");                 if (expected.hasPrevious()) {                     assertEquals(walkdescr.toString(), expected.previous(), testing.previous());                 }             }             assertEquals(walkdescr.toString(), expected.nextIndex(), testing.nextIndex());             assertEquals(walkdescr.toString(), expected.previousIndex(), testing.previousIndex());         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  /**  * Tests the ArrayIterator to ensure that the next() method will actually  * perform the iteration rather than the hasNext() method.  * The code of this test was supplied by Mauricio S. Moura.  *  */ public class ArrayIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };      public ArrayIteratorTest(final String testName) {         super(testName);     }      @Override     public ArrayIterator<E> makeEmptyIterator() {         return new ArrayIterator<>(new Object[0]);     }      @Override     public ArrayIterator<E> makeObject() {         return new ArrayIterator<>(testArray);     }      @Override     public boolean supportsRemove() {         return false;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final String testValue : testArray) {             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testNullArray() {         try {             new ArrayIterator<>(null);             fail("Constructor should throw a NullPointerException when constructed with a null array");         } catch (final NullPointerException e) {             // expected         }     }      public void testReset() {         final ArrayIterator<E> it = makeObject();         it.next();         it.reset();         assertEquals("One", it.next());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List;  import org.apache.commons.collections4.Unmodifiable;  /**  * Tests the UnmodifiableIterator.  *  */ public class UnmodifiableIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };     protected List<E> testList;      public UnmodifiableIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public Iterator<E> makeEmptyIterator() {         return UnmodifiableIterator.unmodifiableIterator(Collections.<E>emptyList().iterator());     }      @Override     public Iterator<E> makeObject() {         return UnmodifiableIterator.unmodifiableIterator(testList.iterator());     }      @Override     public boolean supportsRemove() {         return false;     }      //-----------------------------------------------------------------------     public void testIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         Iterator<E> it = makeObject();         assertSame(it, UnmodifiableIterator.unmodifiableIterator(it));          it = testList.iterator();         assertTrue(it != UnmodifiableIterator.unmodifiableIterator(it));          try {             UnmodifiableIterator.unmodifiableIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  /**  * A unit test to test the basic functions of {@link SkippingIterator}.  *  */ public class SkippingIteratorTest<E> extends AbstractIteratorTest<E> {      /** Test array of size 7 */     private final String[] testArray = {         "a", "b", "c", "d", "e", "f", "g"     };      private List<E> testList;      public SkippingIteratorTest(final String testName) {         super(testName);     }      @SuppressWarnings("unchecked")     @Override     public void setUp()         throws Exception {         super.setUp();         testList = Arrays.asList((E[]) testArray);     }      @Override     public Iterator<E> makeEmptyIterator() {         return new SkippingIterator<>(Collections.<E>emptyList().iterator(), 0);     }      @Override     public Iterator<E> makeObject() {         return new SkippingIterator<>(new ArrayList<>(testList).iterator(), 1);     }      // ---------------- Tests ---------------------      /**      * Test a decorated iterator bounded such that the first element returned is      * at an index greater its first element, and the last element returned is      * at an index less than its last element.      */     @Test     public void testSkipping() {         final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 2);          assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test a decorated iterator bounded such that the {@code offset} is      * zero, in that the SkippingIterator should return all the same elements      * as its decorated iterator.      */     @Test     public void testSameAsDecorated() {         final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 0);          assertTrue(iter.hasNext());         assertEquals("a", iter.next());         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the {@code offset} passed to the constructor is      * greater than the decorated iterator's size. The SkippingIterator should      * behave as if there are no more elements to return.      */     @Test     public void testOffsetGreaterThanSize() {         final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 10);         assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if a negative {@code offset} is passed to the      * constructor. {@link IllegalArgumentException} is expected.      */     @Test     public void testNegativeOffset() {         try {             new SkippingIterator<>(testList.iterator(), -1);             fail("Expected IllegalArgumentException.");         } catch (final IllegalArgumentException iae) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called without      * {@code next()} being called first.      */     @Test     public void testRemoveWithoutCallingNext() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 1);          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called twice without calling      * {@code next()} in between.      */     @Test     public void testRemoveCalledTwice() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 1);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         iter.remove();          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test removing the first element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveFirst() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 4);          assertTrue(iter.hasNext());         assertEquals("e", iter.next());          iter.remove();         assertFalse(testListCopy.contains("e"));          assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing an element in the middle of the iterator. Verify that the      * element is removed from the underlying collection.      */     @Test     public void testRemoveMiddle() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 3);          assertTrue(iter.hasNext());         assertEquals("d", iter.next());          iter.remove();         assertFalse(testListCopy.contains("d"));          assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing the last element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveLast() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 5);          assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }          iter.remove();         assertFalse(testListCopy.contains("g"));          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the decorated iterator does not support the      * {@code remove()} method and throws an {@link UnsupportedOperationException}.      */     @Test     public void testRemoveUnsupported() {         final Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {             @Override             public void remove() {                 throw new UnsupportedOperationException();             }         };          final Iterator<E> iter = new SkippingIterator<>(mockIterator, 1);         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         try {             iter.remove();             fail("Expected UnsupportedOperationException.");         } catch (final UnsupportedOperationException usoe) { /* Success case */         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList;  import org.apache.commons.collections4.IteratorUtils;  /**  * Unit test suite for {@link ZippingIterator}.  *  */ @SuppressWarnings("boxing") public class ZippingIteratorTest extends AbstractIteratorTest<Integer> {      //------------------------------------------------------------ Conventional      public ZippingIteratorTest(final String testName) {         super(testName);     }      //--------------------------------------------------------------- Lifecycle      private ArrayList<Integer> evens = null;     private ArrayList<Integer> odds = null;     private ArrayList<Integer> fib = null;      @Override     public void setUp() throws Exception {         super.setUp();         evens = new ArrayList<>();         odds = new ArrayList<>();         for (int i = 0; i < 20; i++) {             if (0 == i % 2) {                 evens.add(i);             } else {                 odds.add(i);             }         }         fib = new ArrayList<>();         fib.add(1);         fib.add(1);         fib.add(2);         fib.add(3);         fib.add(5);         fib.add(8);         fib.add(13);         fib.add(21);     }      //---------------------------------------------------- TestIterator Methods      @Override     @SuppressWarnings("unchecked")     public ZippingIterator<Integer> makeEmptyIterator() {         return new ZippingIterator<>(IteratorUtils.<Integer>emptyIterator());     }      @Override     public ZippingIterator<Integer> makeObject() {         return new ZippingIterator<>(evens.iterator(), odds.iterator(), fib.iterator());     }      //------------------------------------------------------------------- Tests      public void testIterateEven() {         @SuppressWarnings("unchecked")         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenOdd() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), odds.iterator());         for (int i = 0; i < 20; i++) {             assertTrue(iter.hasNext());             assertEquals(Integer.valueOf(i), iter.next());         }         assertTrue(!iter.hasNext());     }      public void testIterateOddEven() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(odds.iterator(), evens.iterator());         for (int i = 0, j = 0; i < 20; i++) {             assertTrue(iter.hasNext());             final int val = iter.next();             if (i % 2 == 0) {                 assertEquals(odds.get(j).intValue(), val);             } else {                 assertEquals(evens.get(j).intValue(), val);                 j++;             }         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenEven() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertTrue(iter.hasNext());             assertEquals(even, iter.next());         }         assertTrue(!iter.hasNext());     }      public void testIterateFibEvenOdd() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(fib.iterator(), evens.iterator(), odds.iterator());          assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(Integer.valueOf(0), iter.next());  // even   0         assertEquals(Integer.valueOf(1), iter.next());  // odd    1         assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(Integer.valueOf(2), iter.next());  // even   2         assertEquals(Integer.valueOf(3), iter.next());  // odd    3         assertEquals(Integer.valueOf(2), iter.next());  // fib    2         assertEquals(Integer.valueOf(4), iter.next());  // even   4         assertEquals(Integer.valueOf(5), iter.next());  // odd    5         assertEquals(Integer.valueOf(3), iter.next());  // fib    3         assertEquals(Integer.valueOf(6), iter.next());  // even   6         assertEquals(Integer.valueOf(7), iter.next());  // odd    7         assertEquals(Integer.valueOf(5), iter.next());  // fib    5         assertEquals(Integer.valueOf(8), iter.next());  // even   8         assertEquals(Integer.valueOf(9), iter.next());  // odd    9         assertEquals(Integer.valueOf(8), iter.next());  // fib    8         assertEquals(Integer.valueOf(10), iter.next()); // even  10         assertEquals(Integer.valueOf(11), iter.next()); // odd   11         assertEquals(Integer.valueOf(13), iter.next()); // fib   13         assertEquals(Integer.valueOf(12), iter.next()); // even  12         assertEquals(Integer.valueOf(13), iter.next()); // odd   13         assertEquals(Integer.valueOf(21), iter.next()); // fib   21         assertEquals(Integer.valueOf(14), iter.next()); // even  14         assertEquals(Integer.valueOf(15), iter.next()); // odd   15         assertEquals(Integer.valueOf(16), iter.next()); // even  16         assertEquals(Integer.valueOf(17), iter.next()); // odd   17         assertEquals(Integer.valueOf(18), iter.next()); // even  18         assertEquals(Integer.valueOf(19), iter.next()); // odd   19          assertTrue(!iter.hasNext());     }      public void testRemoveFromSingle() {         @SuppressWarnings("unchecked")         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator());         int expectedSize = evens.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size());     }      public void testRemoveFromDouble() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), odds.iterator());         int expectedSize = evens.size() + odds.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size() + odds.size());     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the ListIteratorWrapper to insure that it simulates  * a ListIterator correctly.  *  */ public class ListIteratorWrapperTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<E> list1 = null;      public ListIteratorWrapperTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public void setUp() {         list1 = new ArrayList<>();         list1.add((E) "One");         list1.add((E) "Two");         list1.add((E) "Three");         list1.add((E) "Four");         list1.add((E) "Five");         list1.add((E) "Six");     }      @Override     public ResettableListIterator<E> makeEmptyIterator() {         final ArrayList<E> list = new ArrayList<>();         return new ListIteratorWrapper<>(list.iterator());     }      @Override     public ResettableListIterator<E> makeObject() {         return new ListIteratorWrapper<>(list1.iterator());     }      public void testIterator() {         final ListIterator<E> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it backwards         for (int i = testArray.length - 1; i > -1; --i) {             final Object testValue = testArray[i];             final E iterValue = iter.previous();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          try {             iter.previous();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it forwards again         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }      }      @Override     public void testRemove() {         final ListIterator<E> iter = makeObject();          //initial state:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be initially positioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //establish size:         int sz = list1.size();          //verify initial next() call:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //verify remove():         iter.remove();         assertEquals(--sz, list1.size());         //like we never started iterating:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be repositioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //two consecutive next() calls:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());          //call previous():         assertEquals(list1.get(1), iter.previous());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //dig into cache         assertEquals(list1.get(0), iter.previous());         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper does not support the remove() method while dug into the cache via previous()");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //dig out of cache, first next() maintains current position:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());         //continue traversing underlying iterator with this next() call, and we're out of the hole, so to speak:         assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());          //verify remove() works again:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());      }      public void testReset() {         final ResettableListIterator<E> iter = makeObject();         final E first = iter.next();         final E second = iter.next();          iter.reset();          // after reset, there shouldn't be any previous elements         assertFalse("No previous elements after reset()", iter.hasPrevious());          // after reset, the results should be the same as before         assertEquals("First element should be the same", first, iter.next());         assertEquals("Second element should be the same", second, iter.next());          // after passing the point, where we resetted, continuation should work as expected         for (int i = 2; i < testArray.length; i++) {             final Object testValue = testArray[i];             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Arrays; import java.util.Iterator; import java.util.NoSuchElementException;  import org.junit.Test; import static org.junit.Assert.*;  /**  * Tests the IteratorEnumeration.  *  */ public class IteratorEnumerationTest {      @Test     public void testEnumeration() {         final Iterator<String> iterator = Arrays.asList("a", "b", "c").iterator();         final IteratorEnumeration<String> enumeration = new IteratorEnumeration<>(iterator);          assertEquals(iterator, enumeration.getIterator());          assertTrue(enumeration.hasMoreElements());         assertEquals("a", enumeration.nextElement());         assertEquals("b", enumeration.nextElement());         assertEquals("c", enumeration.nextElement());         assertFalse(enumeration.hasMoreElements());          try {             enumeration.nextElement();             fail("NoSuchElementException expected");         } catch (final NoSuchElementException e) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  /**  * Tests the ObjectArrayListIterator class.  *  */ public class ObjectArrayListIterator2Test<E> extends AbstractListIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };      public ObjectArrayListIterator2Test(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeEmptyIterator() {         return new ObjectArrayListIterator<>((E[]) new Object[0]);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeObject() {         return new ObjectArrayListIterator<>((E[]) testArray);     }      public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {         return new ObjectArrayListIterator<>(array);     }      @Override     public boolean supportsAdd() {         return false;     }      @Override     public boolean supportsRemove() {         return false;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the SingletonListIterator.  *  */ public class SingletonListIteratorTest<E> extends AbstractListIteratorTest<E> {      private static final Object testValue = "foo";      public SingletonListIteratorTest(final String testName) {         super(testName);     }      /**      * Returns a SingletonListIterator from which      * the element has already been removed.      */     @Override     public SingletonListIterator<E> makeEmptyIterator() {         final SingletonListIterator<E> iter = makeObject();         iter.next();         iter.remove();         iter.reset();         return iter;     }      @Override     @SuppressWarnings("unchecked")     public SingletonListIterator<E> makeObject() {         return new SingletonListIterator<>((E) testValue);     }      @Override     public boolean supportsAdd() {         return false;     }      @Override     public boolean supportsRemove() {         return true;     }      @Override     public boolean supportsEmptyIterator() {         return true;     }      public void testIterator() {         final ListIterator<E> iter = makeObject();         assertTrue( "Iterator should have next item", iter.hasNext() );         assertTrue( "Iterator should have no previous item", !iter.hasPrevious() );         assertEquals( "Iteration next index", 0, iter.nextIndex() );         assertEquals( "Iteration previous index", -1, iter.previousIndex() );          Object iterValue = iter.next();         assertEquals( "Iteration value is correct", testValue, iterValue );          assertTrue( "Iterator should have no next item", !iter.hasNext() );         assertTrue( "Iterator should have previous item", iter.hasPrevious() );         assertEquals( "Iteration next index", 1, iter.nextIndex() );         assertEquals( "Iteration previous index", 0, iter.previousIndex() );          iterValue = iter.previous();         assertEquals( "Iteration value is correct", testValue, iterValue );          assertTrue( "Iterator should have next item", iter.hasNext() );         assertTrue( "Iterator should have no previous item", !iter.hasPrevious() );         assertEquals( "Iteration next index", 0, iter.nextIndex() );         assertEquals( "Iteration previous index", -1, iter.previousIndex() );          iterValue = iter.next();         assertEquals( "Iteration value is correct", testValue, iterValue );          assertTrue( "Iterator should have no next item", !iter.hasNext() );         assertTrue( "Iterator should have previous item", iter.hasPrevious() );         assertEquals( "Iteration next index", 1, iter.nextIndex() );         assertEquals( "Iteration previous index", 0, iter.previousIndex() );          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }         iter.previous();         try {             iter.previous();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testReset() {         final ResettableListIterator<E> it = makeObject();          assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());          it.reset();          assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());          it.reset();         it.reset();          assertEquals(true, it.hasNext());     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  /**  * Tests the UniqueFilterIterator class.  *  */ public class UniqueFilterIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<E> list1 = null;      public UniqueFilterIteratorTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public void setUp() {         list1 = new ArrayList<>();         list1.add((E) "One");         list1.add((E) "Two");         list1.add((E) "Three");         list1.add((E) "Two");         list1.add((E) "One");         list1.add((E) "Four");         list1.add((E) "Five");         list1.add((E) "Five");         list1.add((E) "Six");         list1.add((E) "Five");     }      @Override     public UniqueFilterIterator<E> makeEmptyIterator() {         final ArrayList<E> list = new ArrayList<>();         return new UniqueFilterIterator<>(list.iterator());     }      @Override     public UniqueFilterIterator<E> makeObject() {         final Iterator<E> i = list1.iterator();         return new UniqueFilterIterator<>(i);     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final String testValue : testArray) {             final E iterValue = iter.next();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          assertTrue("Iterator should now be empty", ! iter.hasNext() );          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  /**  * A unit test to test the basic functions of {@link BoundedIterator}.  *  */ public class BoundedIteratorTest<E> extends AbstractIteratorTest<E> {      /** Test array of size 7 */     private final String[] testArray = {         "a", "b", "c", "d", "e", "f", "g"     };      private List<E> testList;      public BoundedIteratorTest(final String testName) {         super(testName);     }      @SuppressWarnings("unchecked")     @Override     public void setUp()         throws Exception {         super.setUp();         testList = Arrays.asList((E[]) testArray);     }      @Override     public Iterator<E> makeEmptyIterator() {         return new BoundedIterator<>(Collections.<E>emptyList().iterator(), 0, 10);     }      @Override     public Iterator<E> makeObject() {         return new BoundedIterator<>(new ArrayList<>(testList).iterator(), 1, testList.size() - 1);     }      // ---------------- Tests ---------------------      /**      * Test a decorated iterator bounded such that the first element returned is      * at an index greater its first element, and the last element returned is      * at an index less than its last element.      */     @Test     public void testBounded() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 2, 4);          assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test a decorated iterator bounded such that the {@code offset} is      * zero and the {@code max} is its size, in that the BoundedIterator      * should return all the same elements as its decorated iterator.      */     @Test     public void testSameAsDecorated() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 0,                                                   testList.size());          assertTrue(iter.hasNext());         assertEquals("a", iter.next());         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test a decorated iterator bounded to a {@code max} of 0. The      * BoundedIterator should behave as if there are no more elements to return,      * since it is technically an empty iterator.      */     @Test     public void testEmptyBounded() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 3, 0);         assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if a negative {@code offset} is passed to the      * constructor. {@link IllegalArgumentException} is expected.      */     @Test     public void testNegativeOffset() {         try {             new BoundedIterator<>(testList.iterator(), -1, 4);             fail("Expected IllegalArgumentException.");         } catch (final IllegalArgumentException iae) { /* Success case */         }     }      /**      * Test the case if a negative {@code max} is passed to the      * constructor. {@link IllegalArgumentException} is expected.      */     @Test     public void testNegativeMax() {         try {             new BoundedIterator<>(testList.iterator(), 3, -1);             fail("Expected IllegalArgumentException.");         } catch (final IllegalArgumentException iae) { /* Success case */         }     }      /**      * Test the case if the {@code offset} passed to the constructor is      * greater than the decorated iterator's size. The BoundedIterator should      * behave as if there are no more elements to return.      */     @Test     public void testOffsetGreaterThanSize() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 10, 4);         assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the {@code max} passed to the constructor is      * greater than the size of the decorated iterator. The last element      * returned should be the same as the last element of the decorated      * iterator.      */     @Test     public void testMaxGreaterThanSize() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 1, 10);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called without      * {@code next()} being called first.      */     @Test     public void testRemoveWithoutCallingNext() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called twice without calling      * {@code next()} in between.      */     @Test     public void testRemoveCalledTwice() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         iter.remove();          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test removing the first element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveFirst() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());          iter.remove();         assertFalse(testListCopy.contains("b"));          assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing an element in the middle of the iterator. Verify that the      * element is removed from the underlying collection.      */     @Test     public void testRemoveMiddle() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());          iter.remove();         assertFalse(testListCopy.contains("d"));          assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing the last element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveLast() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }          iter.remove();         assertFalse(testListCopy.contains("f"));          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the decorated iterator does not support the      * {@code remove()} method and throws an {@link UnsupportedOperationException}.      */     @Test     public void testRemoveUnsupported() {         final Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {             @Override             public void remove() {                 throw new UnsupportedOperationException();             }         };          final Iterator<E> iter = new BoundedIterator<>(mockIterator, 1, 5);         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         try {             iter.remove();             fail("Expected UnsupportedOperationException.");         } catch (final UnsupportedOperationException usoe) { /* Success case */         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import static org.apache.commons.collections4.functors.TruePredicate.truePredicate;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.NotNullPredicate;  /**  * Test the filter iterator.  *  */ public class FilterIteratorTest<E> extends AbstractIteratorTest<E> {      /** Creates new TestFilterIterator */     public FilterIteratorTest(final String name) {         super(name);     }      private String[] array;     private List<E> list;     private FilterIterator<E> iterator;      /**      * Set up instance variables required by this test case.      */     @Override     public void setUp() {         array = new String[] { "a", "b", "c" };         initIterator();     }      /**      * Tear down instance variables required by this test case.      */     @Override     public void tearDown() throws Exception {         iterator = null;     }      /**      * Returns an full iterator wrapped in a      * FilterIterator that blocks all the elements      *      * @return "empty" FilterIterator      */     @Override     public FilterIterator<E> makeEmptyIterator() {         return makeBlockAllFilter(new ArrayIterator<E>(array));     }      /**      * Returns an array with elements wrapped in a pass-through      * FilterIterator      *      * @return a filtered iterator      */     @Override     @SuppressWarnings("unchecked")     public FilterIterator<E> makeObject() {         list = new ArrayList<>(Arrays.asList((E[]) array));         return makePassThroughFilter(list.iterator());     }      public void testRepeatedHasNext() {         for (int i = 0; i <= array.length; i++) {             assertTrue(iterator.hasNext());         }     }      @SuppressWarnings("unused")     public void testRepeatedNext() {         for (final String element : array) {             iterator.next();         }         verifyNoMoreElements();     }      public void testReturnValues() {         verifyElementsInPredicate(new String[0]);         verifyElementsInPredicate(new String[] { "a" });         verifyElementsInPredicate(new String[] { "b" });         verifyElementsInPredicate(new String[] { "c" });         verifyElementsInPredicate(new String[] { "a", "b" });         verifyElementsInPredicate(new String[] { "a", "c" });         verifyElementsInPredicate(new String[] { "b", "c" });         verifyElementsInPredicate(new String[] { "a", "b", "c" });     }      /**      * Test that when the iterator is changed, the hasNext method returns the      * correct response for the new iterator.      */     @SuppressWarnings("unchecked")     public void testSetIterator() {         final Iterator<E> iter1 = Collections.singleton((E) new Object()).iterator();         final Iterator<E> iter2 = Collections.<E>emptyList().iterator();          final FilterIterator<E> filterIterator = new FilterIterator<>(iter1);         filterIterator.setPredicate(truePredicate());         // this iterator has elements         assertEquals(true, filterIterator.hasNext());          // this iterator has no elements         filterIterator.setIterator(iter2);         assertEquals(false, filterIterator.hasNext());     }      /**      * Test that when the predicate is changed, the hasNext method returns the      * correct response for the new predicate.      */     public void testSetPredicate() {         final Iterator<E> iter = Collections.singleton((E) null).iterator();          final FilterIterator<E> filterIterator = new FilterIterator<>(iter);         filterIterator.setPredicate(truePredicate());         // this predicate matches         assertEquals(true, filterIterator.hasNext());          // this predicate doesn't match         filterIterator.setPredicate(NotNullPredicate.notNullPredicate());         assertEquals(false, filterIterator.hasNext());     }      private void verifyNoMoreElements() {         assertTrue(!iterator.hasNext());         try {             iterator.next();             fail("NoSuchElementException expected");         } catch (final NoSuchElementException e) {             // success         }     }      private void verifyElementsInPredicate(final String[] elements) {         final Predicate<E> pred = x -> {             for (final String element : elements) {                 if (element.equals(x)) {                     return true;                 }             }             return false;         };         initIterator();         iterator.setPredicate(pred);         for (int i = 0; i < elements.length; i++) {             final String s = (String) iterator.next();             assertEquals(elements[i], s);             assertTrue(i == elements.length - 1 ? !iterator.hasNext() : iterator.hasNext());         }         verifyNoMoreElements();          // test removal         initIterator();         iterator.setPredicate(pred);         if (iterator.hasNext()) {             final Object last = iterator.next();             iterator.remove();             assertTrue("Base of FilterIterator still contains removed element.", !list.contains(last));         }     }      private void initIterator() {         iterator = makeObject();     }      /**      * Returns a FilterIterator that does not filter      * any of its elements      *      * @param i      the Iterator to "filter"      * @return "filtered" iterator      */     protected FilterIterator<E> makePassThroughFilter(final Iterator<E> i) {         final Predicate<E> pred = x -> true;         return new FilterIterator<>(i, pred);     }      /**      * Returns a FilterIterator that blocks      * all of its elements      *      * @param i      the Iterator to "filter"      * @return "filtered" iterator      */     protected FilterIterator<E> makeBlockAllFilter(final Iterator<E> i) {         final Predicate<E> pred = x -> false;         return new FilterIterator<>(i, pred);     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.Transformer;  /**  * Testcase.  *  */ public class ObjectGraphIteratorTest extends AbstractIteratorTest<Object> {      protected String[] testArray = { "One", "Two", "Three", "Four", "Five", "Six" };      protected List<String> list1 = null;     protected List<String> list2 = null;     protected List<String> list3 = null;     protected List<Iterator<String>> iteratorList = null;      public ObjectGraphIteratorTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         list1 = new ArrayList<>();         list1.add("One");         list1.add("Two");         list1.add("Three");         list2 = new ArrayList<>();         list2.add("Four");         list3 = new ArrayList<>();         list3.add("Five");         list3.add("Six");         iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());     }      //-----------------------------------------------------------------------     @Override     public ObjectGraphIterator<Object> makeEmptyIterator() {         final ArrayList<Object> list = new ArrayList<>();         return new ObjectGraphIterator<>(list.iterator());     }      @Override     public ObjectGraphIterator<Object> makeObject() {         return new ObjectGraphIterator<>(iteratorList.iterator());     }      //-----------------------------------------------------------------------     public void testIteratorConstructor_null1() {         final Iterator<Object> it = new ObjectGraphIterator<>(null);          assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      public void testIteratorConstructor_null_next() {         final Iterator<Object> it = new ObjectGraphIterator<>(null);         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructor_null_remove() {         final Iterator<Object> it = new ObjectGraphIterator<>(null);         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      //-----------------------------------------------------------------------     public void testIteratorConstructorIteration_Empty() {         final List<Iterator<Object>> iteratorList = new ArrayList<>();         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      public void testIteratorConstructorIteration_Simple() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructorIteration_SimpleNoHasNext() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(testArray[i], it.next());         }         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructorIteration_WithEmptyIterators() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list1.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list2.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list3.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructorRemove() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(testArray[i], it.next());             it.remove();         }         assertEquals(false, it.hasNext());         assertEquals(0, list1.size());         assertEquals(0, list2.size());         assertEquals(0, list3.size());     }      //-----------------------------------------------------------------------     public void testIteration_IteratorOfIterators() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());     }      public void testIteration_IteratorOfIteratorsWithEmptyIterators() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list1.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list2.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list3.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());     }      //-----------------------------------------------------------------------     public void testIteration_RootNull() {         final Iterator<Object> it = new ObjectGraphIterator<>(null, null);          assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      public void testIteration_RootNoTransformer() {         final Forest forest = new Forest();         final Iterator<Object> it = new ObjectGraphIterator<>(forest, null);          assertEquals(true, it.hasNext());         assertSame(forest, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteration_Transformed1() {         final Forest forest = new Forest();         final Leaf l1 = forest.addTree().addBranch().addLeaf();         final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());          assertEquals(true, it.hasNext());         assertSame(l1, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteration_Transformed2() {         final Forest forest = new Forest();         forest.addTree();         forest.addTree();         forest.addTree();         final Branch b1 = forest.getTree(0).addBranch();         final Branch b2 = forest.getTree(0).addBranch();         final Branch b3 = forest.getTree(2).addBranch();         /* Branch b4 = */ forest.getTree(2).addBranch();         final Branch b5 = forest.getTree(2).addBranch();         final Leaf l1 = b1.addLeaf();         final Leaf l2 = b1.addLeaf();         final Leaf l3 = b2.addLeaf();         final Leaf l4 = b3.addLeaf();         final Leaf l5 = b5.addLeaf();          final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());          assertEquals(true, it.hasNext());         assertSame(l1, it.next());         assertEquals(true, it.hasNext());         assertSame(l2, it.next());         assertEquals(true, it.hasNext());         assertSame(l3, it.next());         assertEquals(true, it.hasNext());         assertSame(l4, it.next());         assertEquals(true, it.hasNext());         assertSame(l5, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteration_Transformed3() {         final Forest forest = new Forest();         forest.addTree();         forest.addTree();         forest.addTree();         final Branch b1 = forest.getTree(1).addBranch();         final Branch b2 = forest.getTree(1).addBranch();         final Branch b3 = forest.getTree(2).addBranch();         final Branch b4 = forest.getTree(2).addBranch();         /* Branch b5 = */ forest.getTree(2).addBranch();         final Leaf l1 = b1.addLeaf();         final Leaf l2 = b1.addLeaf();         final Leaf l3 = b2.addLeaf();         final Leaf l4 = b3.addLeaf();         final Leaf l5 = b4.addLeaf();          final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());          assertEquals(true, it.hasNext());         assertSame(l1, it.next());         assertEquals(true, it.hasNext());         assertSame(l2, it.next());         assertEquals(true, it.hasNext());         assertSame(l3, it.next());         assertEquals(true, it.hasNext());         assertSame(l4, it.next());         assertEquals(true, it.hasNext());         assertSame(l5, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      //-----------------------------------------------------------------------     static class LeafFinder implements Transformer<Object, Object> {         @Override         public Object transform(final Object input) {             if (input instanceof Forest) {                 return ((Forest) input).treeIterator();             }             if (input instanceof Tree) {                 return ((Tree) input).branchIterator();             }             if (input instanceof Branch) {                 return ((Branch) input).leafIterator();             }             if (input instanceof Leaf) {                 return input;             }             throw new ClassCastException();         }     }      //-----------------------------------------------------------------------     static class Forest {         List<Tree> trees = new ArrayList<>();          Tree addTree() {             trees.add(new Tree());             return getTree(trees.size() - 1);         }          Tree getTree(final int index) {             return trees.get(index);         }          Iterator<Tree> treeIterator() {             return trees.iterator();         }     }      static class Tree {         List<Branch> branches = new ArrayList<>();          Branch addBranch() {             branches.add(new Branch());             return getBranch(branches.size() - 1);         }          Branch getBranch(final int index) {             return branches.get(index);         }          Iterator<Branch> branchIterator() {             return branches.iterator();         }     }      static class Branch {         List<Leaf> leaves = new ArrayList<>();          Leaf addLeaf() {             leaves.add(new Leaf());             return getLeaf(leaves.size() - 1);         }          Leaf getLeaf(final int index) {             return leaves.get(index);         }          Iterator<Leaf> leafIterator() {             return leaves.iterator();         }     }      static class Leaf {         String colour;          String getColour() {             return colour;         }          void setColour(final String colour) {             this.colour = colour;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  /**  * Tests the ArrayIterator with primitive type arrays.  *  */ public class ArrayIterator2Test<E> extends AbstractIteratorTest<E> {      protected int[] testArray = { 2, 4, 6, 8 };      public ArrayIterator2Test(final String testName) {         super(testName);     }      @Override     public ArrayIterator<E> makeEmptyIterator() {         return new ArrayIterator<>(new int[0]);     }      @Override     public ArrayIterator<E> makeObject() {         return new ArrayIterator<>(testArray);     }      public ArrayIterator<E> makeArrayIterator(final Object array) {         return new ArrayIterator<>(array);     }      public ArrayIterator<E> makeArrayIterator(final Object array, final int index) {         return new ArrayIterator<>(array, index);     }      public ArrayIterator<E> makeArrayIterator(final Object array, final int start, final int end) {         return new ArrayIterator<>(array, start, end);     }      @Override     public boolean supportsRemove() {         return false;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final int element : testArray) {             final Integer testValue = Integer.valueOf(element);             final Number iterValue = (Number) iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testIndexedArray() {         Iterator<E> iter = makeArrayIterator(testArray, 2);         int count = 0;         while (iter.hasNext()) {             ++count;             iter.next();         }          assertEquals("the count should be right using ArrayIterator(Object,2) ", count, testArray.length - 2);          iter = makeArrayIterator(testArray, 1, testArray.length - 1);         count = 0;         while (iter.hasNext()) {             ++count;             iter.next();         }          assertEquals(             "the count should be right using ArrayIterator(Object,1," + (testArray.length - 1) + ") ",             count,             testArray.length - 2);          try {             iter = makeArrayIterator(testArray, -1);             fail("new ArrayIterator(Object,-1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, testArray.length + 1);             fail("new ArrayIterator(Object,length+1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, 0, -1);             fail("new ArrayIterator(Object,0,-1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, 0, testArray.length + 1);             fail("new ArrayIterator(Object,0,length+1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, 1, 1);             // expected not to fail         } catch (final IllegalArgumentException iae) {             // MODIFIED: an iterator over a zero-length section of array             //  should be perfectly legal behavior             fail("new ArrayIterator(Object,1,1) should NOT throw an IllegalArgumentException");         }          try {             iter = makeArrayIterator(testArray, testArray.length - 1, testArray.length - 2);             fail("new ArrayIterator(Object,length-2,length-1) should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Set;  /**  * Test class for PermutationIterator.  *  * @since 4.0  */ public class PermutationIteratorTest extends AbstractIteratorTest<List<Character>> {      @SuppressWarnings("boxing") // OK in test code     protected Character[] testArray = { 'A', 'B', 'C' };     protected List<Character> testList;      public PermutationIteratorTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         testList = new ArrayList<>();         testList.addAll(Arrays.asList(testArray));     }      //-----------------------------------------------------------------------      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsEmptyIterator() {         return false;     }      @Override     public PermutationIterator<Character> makeEmptyIterator() {         return new PermutationIterator<>(new ArrayList<Character>());     }      @Override     public PermutationIterator<Character> makeObject() {         return new PermutationIterator<>(testList);     }      //-----------------------------------------------------------------------      @SuppressWarnings("boxing") // OK in test code     public void testPermutationResultSize() {         int factorial = 1;         for (int i = 0; i < 8; i++, factorial*=i) {             final List<Integer> list = new ArrayList<>();             for (int j = 0; j < i; j++) {                 list.add(j);             }             final Iterator<List<Integer>> it = new PermutationIterator<>(list);             int count = 0;             while (it.hasNext()) {                 it.next();                 count++;             }             assertEquals(factorial, count);         }     }      /**      * test checking that all the permutations are returned      */     @SuppressWarnings("boxing") // OK in test code     public void testPermutationExhaustivity() {         final List<Character> perm1 = new ArrayList<>();         final List<Character> perm2 = new ArrayList<>();         final List<Character> perm3 = new ArrayList<>();         final List<Character> perm4 = new ArrayList<>();         final List<Character> perm5 = new ArrayList<>();         final List<Character> perm6 = new ArrayList<>();          perm1.add('A');         perm2.add('A');         perm3.add('B');         perm4.add('B');         perm5.add('C');         perm6.add('C');          perm1.add('B');         perm2.add('C');         perm3.add('A');         perm4.add('C');         perm5.add('A');         perm6.add('B');          perm1.add('C');         perm2.add('B');         perm3.add('C');         perm4.add('A');         perm5.add('B');         perm6.add('A');          final List<List<Character>> results = new ArrayList<>();          final PermutationIterator<Character> it = makeObject();         while (it.hasNext()) {             final List<Character> next = it.next();             results.add(next);         }         //3! permutation for 3 elements         assertEquals(6, results.size());         assertTrue(results.contains(perm1));         assertTrue(results.contains(perm2));         assertTrue(results.contains(perm3));         assertTrue(results.contains(perm4));         assertTrue(results.contains(perm5));         assertTrue(results.contains(perm6));     }      /**      * test checking that all the permutations are returned only once.      */     public void testPermutationUnicity() {         final List<List<Character>> resultsList = new ArrayList<>();         final Set<List<Character>> resultsSet = new HashSet<>();          final PermutationIterator<Character> it = makeObject();         while (it.hasNext()) {             final List<Character> permutation = it.next();             resultsList.add(permutation);             resultsSet.add(permutation);         }         //3! permutation for 3 elements         assertEquals(6, resultsList.size());         assertEquals(6, resultsSet.size());     }      public void testPermutationException() {         final List<List<Character>> resultsList = new ArrayList<>();          final PermutationIterator<Character> it = makeObject();         while (it.hasNext()) {             final List<Character> permutation = it.next();             resultsList.add(permutation);         }         //asking for another permutation should throw an exception         try {             it.next();             fail();         } catch (final NoSuchElementException e) {             // expected         }     }      public void testPermutatorHasMore() {         final PermutationIterator<Character> it = makeObject();         for (int i = 0; i < 6; i++) {             assertTrue(it.hasNext());             it.next();         }         assertFalse(it.hasNext());     }      public void testEmptyCollection() {         final PermutationIterator<Character> it = makeEmptyIterator();         // there is one permutation for an empty set: 0! = 1         assertTrue(it.hasNext());          final List<Character> nextPermutation = it.next();         assertEquals(0, nextPermutation.size());          assertFalse(it.hasNext());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List;  import org.junit.Test;  /**  * Tests the PushbackIterator.  *  */ public class PushbackIteratorTest<E> extends AbstractIteratorTest<E> {      private final String[] testArray = { "a", "b", "c" };      private List<E> testList;      public PushbackIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public Iterator<E> makeEmptyIterator() {         return PushbackIterator.pushbackIterator(Collections.<E>emptyList().iterator());     }      @Override     public PushbackIterator<E> makeObject() {         return PushbackIterator.pushbackIterator(testList.iterator());     }      @Override     public boolean supportsRemove() {         return false;     }      // -----------------------------------------------------------------------      @Test     public void testNormalIteration() {         final PushbackIterator<E> iter = makeObject();         assertEquals("a", iter.next());         assertEquals("b", iter.next());         assertEquals("c", iter.next());         assertFalse(iter.hasNext());     }      @Test     @SuppressWarnings("unchecked")     public void testImmediatePushback() {         final PushbackIterator<E> iter = makeObject();         iter.pushback((E) "x");         assertEquals("x", iter.next());         assertEquals("a", iter.next());         validate(iter, "b", "c");     }      @Test     @SuppressWarnings("unchecked")     public void testDelayedPushback() {         final PushbackIterator<E> iter = makeObject();         assertEquals("a", iter.next());         iter.pushback((E) "x");         assertEquals("x", iter.next());         assertEquals("b", iter.next());         validate(iter, "c");     }      @Test     @SuppressWarnings("unchecked")     public void testMultiplePushback() {         final PushbackIterator<E> iter = makeObject();         assertEquals("a", iter.next());         iter.pushback((E) "x");         iter.pushback((E) "y");         assertEquals("y", iter.next());         assertEquals("x", iter.next());         assertEquals("b", iter.next());         validate(iter, "c");     }      private void validate(final Iterator<E> iter, final Object... items) {         for (final Object x : items) {             assertTrue(iter.hasNext());             assertEquals(x, iter.next());         }         assertFalse(iter.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Arrays; import java.util.ListIterator; import java.util.NoSuchElementException;  /**  * Tests the ObjectArrayListIterator class.  *  */ public class ObjectArrayListIteratorTest<E> extends ObjectArrayIteratorTest<E> {      public ObjectArrayListIteratorTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeEmptyIterator() {         return new ObjectArrayListIterator<>((E[]) new Object[0]);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeObject() {         return new ObjectArrayListIterator<>((E[]) testArray);     }      public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {         return new ObjectArrayListIterator<>(array);     }      /**      * Test the basic ListIterator functionality - going backwards using      * {@code previous()}.      */     public void testListIterator() {         final ListIterator<E> iter = makeObject();          // TestArrayIterator#testIterator() has already tested the iterator forward,         //  now we need to test it in reverse          // fast-forward the iterator to the end...         while (iter.hasNext()) {             iter.next();         }          for (int x = testArray.length - 1; x >= 0; x--) {             final Object testValue = testArray[x];             final Object iterValue = iter.previous();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasPrevious());          try {             iter.previous();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }      }      /**      * Tests the {@link java.util.ListIterator#set} operation.      */     @SuppressWarnings("unchecked")     public void testListIteratorSet() {         final String[] testData = new String[] { "a", "b", "c" };          final String[] result = new String[] { "0", "1", "2" };          ListIterator<E> iter = makeArrayListIterator((E[]) testData);         int x = 0;          while (iter.hasNext()) {             iter.next();             iter.set((E) Integer.toString(x));             x++;         }          assertTrue("The two arrays should have the same value, i.e. {0,1,2}", Arrays.equals(testData, result));          // a call to set() before a call to next() or previous() should throw an IllegalStateException         iter = makeArrayListIterator((E[]) testArray);          try {             iter.set((E) "should fail");             fail("ListIterator#set should fail if next() or previous() have not yet been called.");         } catch (final IllegalStateException e) {             // expected         } catch (final Throwable t) { // should never happen             fail(t.toString());         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.OrderedMapIterator;  /**  * Abstract class for testing the OrderedMapIterator interface.  * <p>  * This class provides a framework for testing an implementation of MapIterator.  * Concrete subclasses must provide the list iterator to be tested.  * They must also specify certain details of how the list iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractOrderedMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractOrderedMapIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public abstract OrderedMapIterator<K, V> makeEmptyIterator();      @Override     public abstract OrderedMapIterator<K, V> makeObject();      //-----------------------------------------------------------------------     /**      * Test that the empty list iterator contract is correct.      */     @Override     public void testEmptyMapIterator() {         if (!supportsEmptyIterator()) {             return;         }          super.testEmptyMapIterator();          final OrderedMapIterator<K, V> it = makeEmptyIterator();         assertEquals(false, it.hasPrevious());         try {             it.previous();             fail();         } catch (final NoSuchElementException ex) {}     }      //-----------------------------------------------------------------------     /**      * Test that the full list iterator contract is correct.      */     @Override     public void testFullMapIterator() {         if (!supportsFullIterator()) {             return;         }          super.testFullMapIterator();          final OrderedMapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();          assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         final Set<K> set = new HashSet<>();         while (it.hasNext()) {             // getKey             final K key = it.next();             assertSame("it.next() should equals getKey()", key, it.getKey());             assertTrue("Key must be in map",  map.containsKey(key));             assertTrue("Key must be unique", set.add(key));              // getValue             final V value = it.getValue();             if (!isGetStructuralModify()) {                 assertSame("Value must be mapped to key", map.get(key), value);             }             assertTrue("Value must be in map",  map.containsValue(value));              assertEquals(true, it.hasPrevious());              verify();         }         while (it.hasPrevious()) {             // getKey             final Object key = it.previous();             assertSame("it.previous() should equals getKey()", key, it.getKey());             assertTrue("Key must be in map",  map.containsKey(key));             assertTrue("Key must be unique", set.remove(key));              // getValue             final Object value = it.getValue();             if (!isGetStructuralModify()) {                 assertSame("Value must be mapped to key", map.get(key), value);             }             assertTrue("Value must be in map",  map.containsValue(value));              assertEquals(true, it.hasNext());              verify();         }     }      //-----------------------------------------------------------------------     /**      * Test that the iterator order matches the keySet order.      */     public void testMapIteratorOrder() {         if (!supportsFullIterator()) {             return;         }          final OrderedMapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();          assertEquals("keySet() not consistent", new ArrayList<>(map.keySet()), new ArrayList<>(map.keySet()));          final Iterator<K> it2 = map.keySet().iterator();         assertEquals(true, it.hasNext());         assertEquals(true, it2.hasNext());         final List<K> list = new ArrayList<>();         while (it.hasNext()) {             final K key = it.next();             assertEquals(it2.next(), key);             list.add(key);         }         assertEquals(map.size(), list.size());         while (it.hasPrevious()) {             final K key = it.previous();             assertEquals(list.get(list.size() - 1), key);             list.remove(list.size() - 1);         }         assertEquals(0, list.size());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the ReverseListIterator.  *  */ public class ReverseListIteratorTest<E> extends AbstractListIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three", "Four" };      public ReverseListIteratorTest(final String testName) {         super(testName);     }      @Override     public ListIterator<E> makeEmptyIterator() {         return new ReverseListIterator<>(new ArrayList<E>());     }      @Override     @SuppressWarnings("unchecked")     public ReverseListIterator<E> makeObject() {         final List<E> list = new ArrayList<>(Arrays.asList((E[]) testArray));         return new ReverseListIterator<>(list);     }      // overrides     //-----------------------------------------------------------------------     @Override     public void testEmptyListIteratorIsIndeedEmpty() {         final ListIterator<E> it = makeEmptyIterator();          assertEquals(false, it.hasNext());         assertEquals(-1, it.nextIndex());  // reversed index         assertEquals(false, it.hasPrevious());         assertEquals(0, it.previousIndex());  // reversed index          // next() should throw a NoSuchElementException         try {             it.next();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }          // previous() should throw a NoSuchElementException         try {             it.previous();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }     }      @Override     public void testWalkForwardAndBack() {         final ArrayList<E> list = new ArrayList<>();         final ListIterator<E> it = makeObject();         while (it.hasNext()) {             list.add(it.next());         }          // check state at end         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());          // this had to be commented out, as there is a bug in the JDK before JDK1.5         // where calling previous at the start of an iterator would push the cursor         // back to an invalid negative value //        try { //            it.next(); //            fail("NoSuchElementException must be thrown from next at end of ListIterator"); //        } catch (NoSuchElementException e) { //        }          // loop back through comparing         for (int i = list.size() - 1; i >= 0; i--) {             assertEquals("" + i, list.size() - i - 2, it.nextIndex());  // reversed index             assertEquals(list.size() - i - 1, it.previousIndex());  // reversed index              final Object obj = list.get(i);             assertEquals(obj, it.previous());         }          // check state at start         assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         try {             it.previous();             fail("NoSuchElementException must be thrown from previous at start of ListIterator");         } catch (final NoSuchElementException e) {         }     }      //-----------------------------------------------------------------------     public void testReverse() {         final ListIterator<E> it = makeObject();         assertEquals(true, it.hasNext());         assertEquals(3, it.nextIndex());         assertEquals(false, it.hasPrevious());         assertEquals(4, it.previousIndex());         assertEquals("Four", it.next());         assertEquals(2, it.nextIndex());         assertEquals(true, it.hasNext());         assertEquals(3, it.previousIndex());         assertEquals(true, it.hasPrevious());         assertEquals("Three", it.next());         assertEquals(true, it.hasNext());         assertEquals(1, it.nextIndex());         assertEquals(true, it.hasPrevious());         assertEquals(2, it.previousIndex());         assertEquals("Two", it.next());         assertEquals(true, it.hasNext());         assertEquals(0, it.nextIndex());         assertEquals(true, it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals("One", it.next());         assertEquals(false, it.hasNext());         assertEquals(-1, it.nextIndex());         assertEquals(true, it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals("One", it.previous());         assertEquals("Two", it.previous());         assertEquals("Three", it.previous());         assertEquals("Four", it.previous());     }      public void testReset() {         final ResettableListIterator<E> it = makeObject();         assertEquals("Four", it.next());         it.reset();         assertEquals("Four", it.next());         it.next();         it.next();         it.reset();         assertEquals("Four", it.next());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.bidimap.DualHashBidiMap;  /**  * Tests the UnmodifiableMapIterator.  *  */ public class UnmodifiableMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {      public UnmodifiableMapIteratorTest(final String testName) {         super(testName);     }      @Override     public MapIterator<K, V> makeEmptyIterator() {         return UnmodifiableMapIterator.unmodifiableMapIterator(new DualHashBidiMap<K, V>().mapIterator());     }      @Override     public MapIterator<K, V> makeObject() {         return UnmodifiableMapIterator.unmodifiableMapIterator(getMap().mapIterator());     }      @Override     @SuppressWarnings("unchecked")     public IterableMap<K, V> getMap() {         final IterableMap<K, V> testMap = new DualHashBidiMap<>();         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     @SuppressWarnings("unchecked")     public Map<K, V> getConfirmedMap() {         final Map<K, V> testMap = new HashMap<>();         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsSetValue() {         return false;     }      //-----------------------------------------------------------------------     public void testMapIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         MapIterator<K, V> it = makeObject();         assertSame(it, UnmodifiableMapIterator.unmodifiableMapIterator(it));          it = getMap().mapIterator();         assertTrue(it != UnmodifiableMapIterator.unmodifiableMapIterator(it));          try {             UnmodifiableMapIterator.unmodifiableMapIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.ListIterator; import java.util.NoSuchElementException;  /**  * Abstract class for testing the ListIterator interface.  * <p>  * This class provides a framework for testing an implementation of ListIterator.  * Concrete subclasses must provide the list iterator to be tested.  * They must also specify certain details of how the list iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractListIteratorTest<E> extends AbstractIteratorTest<E> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractListIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implements the abstract superclass method to return the list iterator.      *      * @return an empty iterator      */     @Override     public abstract ListIterator<E> makeEmptyIterator();      /**      * Implements the abstract superclass method to return the list iterator.      *      * @return a full iterator      */     @Override     public abstract ListIterator<E> makeObject();      /**      * Whether or not we are testing an iterator that supports add().      * Default is true.      *      * @return true if Iterator supports add      */     public boolean supportsAdd() {         return true;     }      /**      * Whether or not we are testing an iterator that supports set().      * Default is true.      *      * @return true if Iterator supports set      */     public boolean supportsSet() {         return true;     }      /**      * The value to be used in the add and set tests.      * Default is null.      */     public E addSetValue() {         return null;     }      //-----------------------------------------------------------------------     /**      * Test that the empty list iterator contract is correct.      */     public void testEmptyListIteratorIsIndeedEmpty() {         if (!supportsEmptyIterator()) {             return;         }          final ListIterator<E> it = makeEmptyIterator();          assertEquals(false, it.hasNext());         assertEquals(0, it.nextIndex());         assertEquals(false, it.hasPrevious());         assertEquals(-1, it.previousIndex());          // next() should throw a NoSuchElementException         try {             it.next();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }          // previous() should throw a NoSuchElementException         try {             it.previous();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }     }      /**      * Test navigation through the iterator.      */     public void testWalkForwardAndBack() {         final ArrayList<E> list = new ArrayList<>();         final ListIterator<E> it = makeObject();         while (it.hasNext()) {             list.add(it.next());         }          // check state at end         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());         try {             it.next();             fail("NoSuchElementException must be thrown from next at end of ListIterator");         } catch (final NoSuchElementException e) {         }          // loop back through comparing         for (int i = list.size() - 1; i >= 0; i--) {             assertEquals(i + 1, it.nextIndex());             assertEquals(i, it.previousIndex());              final Object obj = list.get(i);             assertEquals(obj, it.previous());         }          // check state at start         assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         try {             it.previous();             fail("NoSuchElementException must be thrown from previous at start of ListIterator");         } catch (final NoSuchElementException e) {         }     }      /**      * Test add behavior.      */     public void testAdd() {         ListIterator<E> it = makeObject();          final E addValue = addSetValue();         if (!supportsAdd()) {             // check for UnsupportedOperationException if not supported             try {                 it.add(addValue);                 fail("UnsupportedOperationException must be thrown from add of " + it.getClass().getSimpleName());             } catch (final UnsupportedOperationException ex) {}             return;         }          // add at start should be OK, added should be previous         it = makeObject();         it.add(addValue);         assertEquals(addValue, it.previous());          // add at start should be OK, added should not be next         it = makeObject();         it.add(addValue);         assertTrue(addValue != it.next());          // add in middle and at end should be OK         it = makeObject();         while (it.hasNext()) {             it.next();             it.add(addValue);             // check add OK             assertEquals(addValue, it.previous());             it.next();         }     }      /**      * Test set behavior.      */     public void testSet() {         final ListIterator<E> it = makeObject();          if (!supportsSet()) {             // check for UnsupportedOperationException if not supported             try {                 it.set(addSetValue());                 fail("UnsupportedOperationException must be thrown from set in " + it.getClass().getSimpleName());             } catch (final UnsupportedOperationException ex) {}             return;         }          // should throw IllegalStateException before next() called         try {             it.set(addSetValue());             fail();         } catch (final IllegalStateException ex) {}          // set after next should be fine         it.next();         it.set(addSetValue());          // repeated set calls should be fine         it.set(addSetValue());      }      public void testRemoveThenSet() {         final ListIterator<E> it = makeObject();         if (supportsRemove() && supportsSet()) {             it.next();             it.remove();             try {                 it.set(addSetValue());                 fail("IllegalStateException must be thrown from set after remove");             } catch (final IllegalStateException e) {             }         }     }      public void testAddThenSet() {         final ListIterator<E> it = makeObject();         // add then set         if (supportsAdd() && supportsSet()) {             it.next();             it.add(addSetValue());             try {                 it.set(addSetValue());                 fail("IllegalStateException must be thrown from set after add");             } catch (final IllegalStateException e) {             }         }     }      /**      * Test remove after add behavior.      */     public void testAddThenRemove() {         final ListIterator<E> it = makeObject();          // add then remove         if (supportsAdd() && supportsRemove()) {             it.next();             it.add(addSetValue());             try {                 it.remove();                 fail("IllegalStateException must be thrown from remove after add");             } catch (final IllegalStateException e) {             }         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the ListIteratorWrapper to insure that it behaves as expected when wrapping a ListIterator.  *  */ public class ListIteratorWrapper2Test<E> extends AbstractIteratorTest<E> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<E> list1 = null;      public ListIteratorWrapper2Test(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public void setUp() {         list1 = new ArrayList<>();         list1.add((E) "One");         list1.add((E) "Two");         list1.add((E) "Three");         list1.add((E) "Four");         list1.add((E) "Five");         list1.add((E) "Six");     }      @Override     public ResettableListIterator<E> makeEmptyIterator() {         final ArrayList<E> list = new ArrayList<>();         return new ListIteratorWrapper<>(list.listIterator());     }      @Override     public ResettableListIterator<E> makeObject() {         return new ListIteratorWrapper<>(list1.listIterator());     }      public void testIterator() {         final ListIterator<E> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it backwards         for (int i = testArray.length - 1; i > -1; --i) {             final Object testValue = testArray[i];             final E iterValue = iter.previous();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          try {             iter.previous();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it forwards again         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }      }      @Override     public void testRemove() {         final ListIterator<E> iter = makeObject();          //initial state:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be initially positioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //establish size:         int sz = list1.size();          //verify initial next() call:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //verify remove():         iter.remove();         assertEquals(--sz, list1.size());         //like we never started iterating:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be repositioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //two consecutive next() calls:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());          //call previous():         assertEquals(list1.get(1), iter.previous());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //this would dig into cache on a plain Iterator, but forwards directly to wrapped ListIterator:         assertEquals(list1.get(0), iter.previous());         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //here's the proof; remove() still works:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //further testing would be fairly meaningless:     }      public void testReset() {         final ResettableListIterator<E> iter = makeObject();         final E first = iter.next();         final E second = iter.next();          iter.reset();          // after reset, there shouldn't be any previous elements         assertFalse("No previous elements after reset()", iter.hasPrevious());          // after reset, the results should be the same as before         assertEquals("First element should be the same", first, iter.next());         assertEquals("Second element should be the same", second, iter.next());          // after passing the point, where we resetted, continuation should work as expected         for (int i = 2; i < testArray.length; i++) {             final Object testValue = testArray[i];             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  /**  * Tests the PeekingIterator.  */ public class PeekingIteratorTest<E> extends AbstractIteratorTest<E> {      private final String[] testArray = { "a", "b", "c" };      private List<E> testList;      public PeekingIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public Iterator<E> makeEmptyIterator() {         return PeekingIterator.peekingIterator(Collections.<E>emptyList().iterator());     }      @Override     public PeekingIterator<E> makeObject() {         return PeekingIterator.peekingIterator(testList.iterator());     }      @Override     public boolean supportsRemove() {         return true;     }      //-----------------------------------------------------------------------      @Test     public void testEmpty() {         final Iterator<E> it = makeEmptyIterator();         assertFalse(it.hasNext());     }      @Test     @SuppressWarnings("unchecked")     public void testSinglePeek() {         final PeekingIterator<E> it = makeObject();         assertEquals("a", it.peek());         assertEquals("a", it.element());         validate(it, (E[]) testArray);     }      @Test     public void testMultiplePeek() {         final PeekingIterator<E> it = makeObject();         assertEquals("a", it.peek());         assertEquals("a", it.peek());         assertEquals("a", it.next());         assertTrue(it.hasNext());         assertEquals("b", it.peek());         assertEquals("b", it.peek());         assertEquals("b", it.next());         assertTrue(it.hasNext());         assertEquals("c", it.peek());         assertEquals("c", it.peek());         assertEquals("c", it.next());         assertFalse(it.hasNext());     }      @Test     public void testIteratorExhausted() {         final PeekingIterator<E> it = makeObject();         it.next();         it.next();         it.next();         assertFalse(it.hasNext());         assertNull(it.peek());          try {             it.element();             fail();         } catch (final NoSuchElementException e) {             // expected         }     }      @Test     public void testIllegalRemove() {         final PeekingIterator<E> it = makeObject();         it.next();         it.remove(); // supported          assertTrue(it.hasNext());         assertEquals("b", it.peek());          try {             it.remove();             fail();         } catch (final IllegalStateException e) {             // expected         }     }      private void validate(final Iterator<E> iter, final E... items) {         for (final E x : items) {             assertTrue(iter.hasNext());             assertEquals(x, iter.next());         }         assertFalse(iter.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.HashMap; import java.util.Map; import java.util.TreeMap;  import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.OrderedMapIterator; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.map.ListOrderedMap;  /**  * Tests the UnmodifiableOrderedMapIterator.  *  */ public class UnmodifiableOrderedMapIteratorTest<K, V> extends AbstractOrderedMapIteratorTest<K, V> {      public UnmodifiableOrderedMapIteratorTest(final String testName) {         super(testName);     }      @Override     public OrderedMapIterator<K, V> makeEmptyIterator() {         return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(                 ListOrderedMap.listOrderedMap(new HashMap<K, V>()).mapIterator());     }      @Override     public OrderedMapIterator<K, V> makeObject() {         return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(getMap().mapIterator());     }      @Override     @SuppressWarnings("unchecked")     public OrderedMap<K, V> getMap() {         final OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     @SuppressWarnings("unchecked")     public Map<K, V> getConfirmedMap() {         final Map<K, V> testMap = new TreeMap<>();         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsSetValue() {         return false;     }      //-----------------------------------------------------------------------     public void testOrderedMapIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         OrderedMapIterator<K, V> it = makeObject();         assertSame(it, UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));          it = getMap().mapIterator();         assertTrue(it != UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));          try {             UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.Predicate;  /**  * Tests the LazyIteratorChain class.  *  */ public class LazyIteratorChainTest extends AbstractIteratorTest<String> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<String> list1 = null;     protected List<String> list2 = null;     protected List<String> list3 = null;      public LazyIteratorChainTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         list1 = new ArrayList<>();         list1.add("One");         list1.add("Two");         list1.add("Three");         list2 = new ArrayList<>();         list2.add("Four");         list3 = new ArrayList<>();         list3.add("Five");         list3.add("Six");     }      @Override     public LazyIteratorChain<String> makeEmptyIterator() {         return new LazyIteratorChain<String>() {             @Override             protected Iterator<String> nextIterator(final int count) {                 return null;             }         };     }      @Override     public LazyIteratorChain<String> makeObject() {         final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {             @Override             protected Iterator<String> nextIterator(final int count) {                 switch (count) {                 case 1:                     return list1.iterator();                 case 2:                     return list2.iterator();                 case 3:                     return list3.iterator();                 }                 return null;             }         };          return chain;     }      public void testIterator() {         final Iterator<String> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testRemoveFromFilteredIterator() {          final Predicate<Integer> myPredicate = i -> i.compareTo(Integer.valueOf(4)) < 0;          final List<Integer> list1 = new ArrayList<>();         final List<Integer> list2 = new ArrayList<>();          list1.add(Integer.valueOf(1));         list1.add(Integer.valueOf(2));         list2.add(Integer.valueOf(3));         list2.add(Integer.valueOf(4)); // will be ignored by the predicate          final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);         final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);          final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);         while (it.hasNext()) {             it.next();             it.remove();         }         assertEquals(0, list1.size());         assertEquals(1, list2.size());     }      @Override     public void testRemove() {         final Iterator<String> iter = makeObject();          try {             iter.remove();             fail("Calling remove before the first call to next() should throw an exception");         } catch (final IllegalStateException e) {          }          for (final String testValue : testArray) {             final String iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);              if (!iterValue.equals("Four")) {                 iter.remove();             }         }          assertTrue("List is empty", list1.size() == 0);         assertTrue("List is empty", list2.size() == 1);         assertTrue("List is empty", list3.size() == 0);     }      public void testFirstIteratorIsEmptyBug() {         final List<String> empty = new ArrayList<>();         final List<String> notEmpty = new ArrayList<>();         notEmpty.add("A");         notEmpty.add("B");         notEmpty.add("C");         final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {             @Override             protected Iterator<String> nextIterator(final int count) {                 switch (count) {                 case 1:                     return empty.iterator();                 case 2:                     return notEmpty.iterator();                 }                 return null;             }         };         assertTrue("should have next", chain.hasNext());         assertEquals("A", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("B", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("C", chain.next());         assertTrue("should not have next", !chain.hasNext());     }      public void testEmptyChain() {         final LazyIteratorChain<String> chain = makeEmptyIterator();         assertEquals(false, chain.hasNext());         try {             chain.next();             fail();         } catch (final NoSuchElementException ex) {}         try {             chain.remove();             fail();         } catch (final IllegalStateException ex) {}     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.io.Serializable;  /**  * Abstract test class for {@link java.lang.Object} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject()} method.  * <p>  * If your {@link Object} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link Object} fails.  */ public abstract class AbstractObjectTest extends BulkTest {      /** Current major release for Collections */     public static final int COLLECTIONS_MAJOR_VERSION = 4;      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractObjectTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implement this method to return the object to test.      *      * @return the object to test      */     public abstract Object makeObject();      /**      * Override this method if a subclass is testing an object      * that cannot serialize an "empty" Collection.      * (e.g. Comparators have no contents)      *      * @return true      */     public boolean supportsEmptyCollections() {         return true;     }      /**      * Override this method if a subclass is testing an object      * that cannot serialize a "full" Collection.      * (e.g. Comparators have no contents)      *      * @return true      */     public boolean supportsFullCollections() {         return true;     }      /**      * Is serialization testing supported.      * Default is true.      */     public boolean isTestSerialization() {         return true;     }      /**      * Returns true to indicate that the collection supports equals() comparisons.      * This implementation returns true;      */     public boolean isEqualsCheckable() {         return true;     }      //-----------------------------------------------------------------------     public void testObjectEqualsSelf() {         final Object obj = makeObject();         assertEquals("A Object should equal itself", obj, obj);     }      public void testEqualsNull() {         final Object obj = makeObject();         assertEquals(false, obj.equals(null)); // make sure this doesn't throw NPE either     }      public void testObjectHashCodeEqualsSelfHashCode() {         final Object obj = makeObject();         assertEquals("hashCode should be repeatable", obj.hashCode(), obj.hashCode());     }      public void testObjectHashCodeEqualsContract() {         final Object obj1 = makeObject();         if (obj1.equals(obj1)) {             assertEquals(                 "[1] When two objects are equal, their hashCodes should be also.",                 obj1.hashCode(), obj1.hashCode());         }         final Object obj2 = makeObject();         if (obj1.equals(obj2)) {             assertEquals(                 "[2] When two objects are equal, their hashCodes should be also.",                 obj1.hashCode(), obj2.hashCode());             assertTrue(                 "When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true",                 obj2.equals(obj1));         }     }      protected Object serializeDeserialize(final Object obj) throws Exception {         final ByteArrayOutputStream buffer = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(buffer);         out.writeObject(obj);         out.close();          final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));         final Object dest = in.readObject();         in.close();          return dest;     }      public void testSerializeDeserializeThenCompare() throws Exception {         final Object obj = makeObject();         if (obj instanceof Serializable && isTestSerialization()) {             final Object dest = serializeDeserialize(obj);             if (isEqualsCheckable()) {                 assertEquals("obj != deserialize(serialize(obj))", obj, dest);             }         }     }      /**      * Sanity check method, makes sure that any Serializable      * class can be serialized and de-serialized in memory,      * using the handy makeObject() method      *      * @throws IOException      * @throws ClassNotFoundException      */     public void testSimpleSerialization() throws Exception {         final Object o = makeObject();         if (o instanceof Serializable && isTestSerialization()) {             final byte[] objekt = writeExternalFormToBytes((Serializable) o);             readExternalFormFromBytes(objekt);         }     }      /**      * Tests serialization by comparing against a previously stored version in SCM.      * If the test object is serializable, confirm that a canonical form exists.      */     public void testCanonicalEmptyCollectionExists() {         if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {             final Object object = makeObject();             if (object instanceof Serializable) {                 final String name = getCanonicalEmptyCollectionName(object);                 assertTrue(                     "Canonical empty collection (" + name + ") is not in SCM",                     new File(name).exists());             }         }     }      /**      * Tests serialization by comparing against a previously stored version in SCM.      * If the test object is serializable, confirm that a canonical form exists.      */     public void testCanonicalFullCollectionExists() {         if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {             final Object object = makeObject();             if (object instanceof Serializable) {                 final String name = getCanonicalFullCollectionName(object);                 assertTrue(                     "Canonical full collection (" + name + ") is not in SCM",                     new File(name).exists());             }         }     }      // protected implementation     //-----------------------------------------------------------------------     /**      * Get the version of Collections that this object tries to      * maintain serialization compatibility with. Defaults to 4, due to      * the package change to collections4 introduced in version 4.      *      * This constant makes it possible for TestMap (and other subclasses,      * if necessary) to automatically check SCM for a versionX copy of a      * Serialized object, so we can make sure that compatibility is maintained.      * See, for example, TestMap.getCanonicalFullMapName(Map map).      * Subclasses can override this variable, indicating compatibility      * with earlier Collections versions.      *      * @return The version, or {@code null} if this object shouldn't be      * tested for compatibility with previous versions.      */     public String getCompatibilityVersion() {         return "4";     }      protected String getCanonicalEmptyCollectionName(final Object object) {         final StringBuilder retval = new StringBuilder();         retval.append(TEST_DATA_PATH);         String colName = object.getClass().getName();         colName = colName.substring(colName.lastIndexOf(".") + 1, colName.length());         retval.append(colName);         retval.append(".emptyCollection.version");         retval.append(getCompatibilityVersion());         retval.append(".obj");         return retval.toString();     }      protected String getCanonicalFullCollectionName(final Object object) {         final StringBuilder retval = new StringBuilder();         retval.append(TEST_DATA_PATH);         String colName = object.getClass().getName();         colName = colName.substring(colName.lastIndexOf(".") + 1, colName.length());         retval.append(colName);         retval.append(".fullCollection.version");         retval.append(getCompatibilityVersion());         retval.append(".obj");         return retval.toString();     }      /**      * Writes a Serializable or Externalizable object as      * a file at the given path.  NOT USEFUL as part      * of a unit test; this is just a utility method      * for creating disk-based objects in SCM that can become      * the basis for compatibility tests using      * readExternalFormFromDisk(String path)      *      * @param o Object to serialize      * @param path path to write the serialized Object      * @throws IOException      */     protected void writeExternalFormToDisk(final Serializable o, final String path) throws IOException {         try (FileOutputStream fileStream = new FileOutputStream(path)) {             writeExternalFormToStream(o, fileStream);         }     }      /**      * Converts a Serializable or Externalizable object to      * bytes.  Useful for in-memory tests of serialization      *      * @param o Object to convert to bytes      * @return serialized form of the Object      * @throws IOException      */     protected byte[] writeExternalFormToBytes(final Serializable o) throws IOException {         final ByteArrayOutputStream byteStream = new ByteArrayOutputStream();         writeExternalFormToStream(o, byteStream);         return byteStream.toByteArray();     }      /**      * Reads a Serialized or Externalized Object from disk.      * Useful for creating compatibility tests between      * different SCM versions of the same class      *      * @param path path to the serialized Object      * @return the Object at the given path      * @throws IOException      * @throws ClassNotFoundException      */     protected Object readExternalFormFromDisk(final String path) throws IOException, ClassNotFoundException {         try (FileInputStream stream = new FileInputStream(path)) {             return readExternalFormFromStream(stream);         }     }      /**      * Read a Serialized or Externalized Object from bytes.      * Useful for verifying serialization in memory.      *      * @param b byte array containing a serialized Object      * @return Object contained in the bytes      * @throws IOException      * @throws ClassNotFoundException      */     protected Object readExternalFormFromBytes(final byte[] b) throws IOException, ClassNotFoundException {         final ByteArrayInputStream stream = new ByteArrayInputStream(b);         return readExternalFormFromStream(stream);     }      protected boolean skipSerializedCanonicalTests() {         return Boolean.getBoolean("org.apache.commons.collections:with-clover");     }      // private implementation     //-----------------------------------------------------------------------     private Object readExternalFormFromStream(final InputStream stream) throws IOException, ClassNotFoundException {         final ObjectInputStream oStream = new ObjectInputStream(stream);         return oStream.readObject();     }      private void writeExternalFormToStream(final Serializable o, final OutputStream stream) throws IOException {         final ObjectOutputStream oStream = new ObjectOutputStream(stream);         oStream.writeObject(o);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import org.junit.Assert; import org.junit.Test;  public class SortedPropertiesFactoryTest extends AbstractPropertiesFactoryTest<SortedProperties> {      public SortedPropertiesFactoryTest(final String fileExtension) {         super(SortedPropertiesFactory.INSTANCE, fileExtension);     }      @Override     @Test     public void testInstance() {         Assert.assertNotNull(SortedPropertiesFactory.INSTANCE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.util.Properties;  import org.junit.Assert; import org.junit.Test;  public class PropertiesFactoryTest extends AbstractPropertiesFactoryTest<Properties> {      public PropertiesFactoryTest(final String fileExtension) {         super(PropertiesFactory.INSTANCE, fileExtension);     }      @Override     @Test     public void testInstance() {         Assert.assertNotNull(PropertiesFactory.INSTANCE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.PrintStream; import java.io.PrintWriter; import java.nio.charset.StandardCharsets; import java.util.HashMap; import java.util.Properties;  import org.apache.commons.io.input.NullReader; import org.apache.commons.lang3.ArrayUtils; import org.junit.Assert; import org.junit.Test;  public class EmptyPropertiesTest {      @Test     public void testClear() {         PropertiesFactory.EMPTY_PROPERTIES.clear();         Assert.assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());     }      @Test     public void testClone() {         // TODO Better test?         PropertiesFactory.EMPTY_PROPERTIES.clone();         Assert.assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());     }      @Test(expected = UnsupportedOperationException.class)     public void testCompute() {         PropertiesFactory.EMPTY_PROPERTIES.compute("key", (k, v) -> "foo");     }      @Test(expected = UnsupportedOperationException.class)     public void testComputeIfAbsent() {         PropertiesFactory.EMPTY_PROPERTIES.computeIfAbsent("key", k -> "foo");     }      @Test(expected = UnsupportedOperationException.class)     public void testComputeIfPresent() {         PropertiesFactory.EMPTY_PROPERTIES.computeIfPresent("key", (k, v) -> "foo");     }      @Test     public void testContains() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.contains("foo"));     }      @Test     public void testContainsKey() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.containsKey("foo"));     }      @Test     public void testContainsValue() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.containsValue("foo"));     }      @Test     public void testElements() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.elements().hasMoreElements());     }      @Test     public void testEntrySet() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.entrySet().isEmpty());     }      @Test     public void testEquals() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.equals(PropertiesFactory.EMPTY_PROPERTIES));         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.equals(new Properties()));         Assert.assertTrue(new Properties().equals(PropertiesFactory.EMPTY_PROPERTIES));         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.equals(null));         final Properties p = new Properties();         p.put("Key", "Value");         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.equals(p));         Assert.assertFalse(p.equals(PropertiesFactory.EMPTY_PROPERTIES));     }      public void testForEach() {         PropertiesFactory.EMPTY_PROPERTIES.forEach((k, v) -> Assert.fail());     }      @Test     public void testGet() {         Assert.assertNull(PropertiesFactory.EMPTY_PROPERTIES.get("foo"));     }      @Test     public void testGetOrDefault() {         Assert.assertEquals("bar", PropertiesFactory.EMPTY_PROPERTIES.getOrDefault("foo", "bar"));     }      @Test     public void testGetProperty() {         Assert.assertNull(PropertiesFactory.EMPTY_PROPERTIES.getProperty("foo"));     }      @Test     public void testGetPropertyDefault() {         Assert.assertEquals("bar", PropertiesFactory.EMPTY_PROPERTIES.getProperty("foo", "bar"));     }      @Test     public void testHashCode() {         Assert.assertEquals(PropertiesFactory.EMPTY_PROPERTIES.hashCode(),             PropertiesFactory.EMPTY_PROPERTIES.hashCode());         // Should be equals?         // Assert.assertEquals(PropertiesFactory.EMPTY_PROPERTIES.hashCode(), new Properties().hashCode());     }      @Test     public void testIsEmpty() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.isEmpty());     }      @Test     public void testKeys() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.keys().hasMoreElements());     }      @Test     public void testKeySet() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.keySet().isEmpty());     }      @Test     public void testListToPrintStream() {         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.list(new PrintStream(actual));         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().list(new PrintStream(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().list(new PrintStream(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testListToPrintWriter() {         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.list(new PrintWriter(actual));         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().list(new PrintWriter(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().list(new PrintWriter(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test(expected = UnsupportedOperationException.class)     public void testLoadFromXML() throws IOException {         PropertiesFactory.EMPTY_PROPERTIES.loadFromXML(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY));     }      @Test(expected = UnsupportedOperationException.class)     public void testLoadInputStream() throws IOException {         PropertiesFactory.EMPTY_PROPERTIES.load(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY));     }      @Test(expected = UnsupportedOperationException.class)     public void testLoadReader() throws IOException {         try (NullReader reader = new NullReader(0)) {             PropertiesFactory.EMPTY_PROPERTIES.load(reader);         }     }      @Test(expected = UnsupportedOperationException.class)     public void testMerge() {         PropertiesFactory.EMPTY_PROPERTIES.merge("key", "value", (k, v) -> "foo");     }      @Test     public void testPropertyName() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.propertyNames().hasMoreElements());     }      @Test(expected = UnsupportedOperationException.class)     public void testPut() {         PropertiesFactory.EMPTY_PROPERTIES.put("Key", "Value");     }      @Test(expected = UnsupportedOperationException.class)     public void testPutAll() {         PropertiesFactory.EMPTY_PROPERTIES.putAll(new HashMap<>());     }      @Test(expected = UnsupportedOperationException.class)     public void testPutIfAbsent() {         PropertiesFactory.EMPTY_PROPERTIES.putIfAbsent("Key", "Value");     }      @Test     public void testRehash() {         // Can't really test without extending and casting to a currently private class         // PropertiesFactory.EMPTY_PROPERTIES.rehash();     }      @Test(expected = UnsupportedOperationException.class)     public void testRemove() {         PropertiesFactory.EMPTY_PROPERTIES.remove("key", "value");     }      @Test(expected = UnsupportedOperationException.class)     public void testRemoveKey() {         PropertiesFactory.EMPTY_PROPERTIES.remove("key");     }      @Test(expected = UnsupportedOperationException.class)     public void testReplace() {         PropertiesFactory.EMPTY_PROPERTIES.replace("key", "value1");     }      @Test(expected = UnsupportedOperationException.class)     public void testReplaceAll() {         PropertiesFactory.EMPTY_PROPERTIES.replaceAll((k, v) -> "value1");     }      @Test(expected = UnsupportedOperationException.class)     public void testReplaceOldValue() {         PropertiesFactory.EMPTY_PROPERTIES.replace("key", "value1", "value2");     }      @Test     public void testSave() throws IOException {         final String comments = "Hello world!";         // actual         try (ByteArrayOutputStream actual = new ByteArrayOutputStream()) {             try (PrintStream out = new PrintStream(actual)) {                 PropertiesFactory.EMPTY_PROPERTIES.save(out, comments);             }             // expected             try (ByteArrayOutputStream expected = new ByteArrayOutputStream()) {                 try (PrintStream out = new PrintStream(expected)) {                     PropertiesFactory.INSTANCE.createProperties().save(out, comments);                 }                 Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());                 expected.reset();                 try (PrintStream out = new PrintStream(expected)) {                     new Properties().save(out, comments);                 }                 Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());             }         }     }      @Test(expected = UnsupportedOperationException.class)     public void testSetProperty() {         PropertiesFactory.EMPTY_PROPERTIES.setProperty("Key", "Value");     }      @Test     public void testSize() {         Assert.assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());     }      @Test     public void testStoreToOutputStream() throws IOException {         final String comments = "Hello world!";         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.store(new PrintStream(actual), comments);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().store(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().store(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStoreToPrintWriter() throws IOException {         final String comments = "Hello world!";         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.store(new PrintWriter(actual), comments);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().store(new PrintWriter(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().store(new PrintWriter(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStoreToXMLOutputStream() throws IOException {         final String comments = "Hello world!";         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.storeToXML(new PrintStream(actual), comments);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().storeToXML(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().storeToXML(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStoreToXMLOutputStreamWithEncoding() throws IOException {         final String comments = "Hello world!";         final String encoding = StandardCharsets.UTF_8.name();         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.storeToXML(new PrintStream(actual), comments, encoding);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().storeToXML(new PrintStream(expected), comments, encoding);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().storeToXML(new PrintStream(expected), comments, encoding);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStringPropertyName() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.stringPropertyNames().isEmpty());     }      @Test     public void testToString() {         Assert.assertEquals(new Properties().toString(), PropertiesFactory.EMPTY_PROPERTIES.toString());     }      @Test     public void testValues() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.values().isEmpty());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.util.Enumeration;  import org.junit.Assert; import org.junit.Test;  public class SortedPropertiesTest {      @Test     public void testKeys() {         final SortedProperties sortedProperties = new SortedProperties();         for (char ch = 'Z'; ch >= 'A'; ch--) {             sortedProperties.put(String.valueOf(ch), "Value" + ch);         }         final Enumeration<Object> keys = sortedProperties.keys();         for (char ch = 'A'; ch <= 'Z'; ch++) {             Assert.assertEquals(String.valueOf(ch), keys.nextElement());         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.io.BufferedReader; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; import java.util.Properties;  import org.apache.commons.collections4.BulkTest; import org.junit.Assert; import org.junit.Assume; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  @RunWith(Parameterized.class) public abstract class AbstractPropertiesFactoryTest<T extends Properties> {      @Parameters(name = "{0}")     public static Object[][] getParameters() {         return new Object[][] { { ".properties" }, { ".xml" } };      }      private final AbstractPropertiesFactory<T> factory;     private final String pathString;     private final String fileExtension;      protected AbstractPropertiesFactoryTest(final AbstractPropertiesFactory<T> factory, final String fileExtension) {         this.factory = factory;         this.fileExtension = fileExtension;         this.pathString = BulkTest.TEST_PROPERTIES_PATH + "test" + fileExtension;     }      private void assertContents(final T properties) {         Assert.assertEquals("value1", properties.getProperty("key1"));         Assert.assertEquals("value2", properties.getProperty("key2"));         Assert.assertEquals("value3", properties.getProperty("key3"));         Assert.assertEquals("value4", properties.getProperty("key4"));         Assert.assertEquals("value5", properties.getProperty("key5"));         Assert.assertEquals("value6", properties.getProperty("key6"));         Assert.assertEquals("value7", properties.getProperty("key7"));         Assert.assertEquals("value8", properties.getProperty("key8"));         Assert.assertEquals("value9", properties.getProperty("key9"));         Assert.assertEquals("value10", properties.getProperty("key10"));         Assert.assertEquals("value11", properties.getProperty("key11"));     }      private boolean isXmlTest() {         return ".xml".equals(fileExtension);     }      @Test     public void testInstance() {         Assert.assertNotNull(PropertiesFactory.INSTANCE);     }      @Test     public void testLoadClassLoaderMissingResource() throws Exception {         Assert.assertNull(factory.load(ClassLoader.getSystemClassLoader(), "missing/test" + fileExtension));     }      @Test     public void testLoadClassLoaderResource() throws Exception {         assertContents(factory.load(ClassLoader.getSystemClassLoader(), "org/apache/commons/collections4/properties/test" + fileExtension));     }      @Test     public void testLoadFile() throws Exception {         assertContents(factory.load(Paths.get(pathString).toFile()));     }      @Test     public void testLoadFileName() throws Exception {         assertContents(factory.load(pathString));     }      @Test     public void testLoadInputStream() throws Exception {         // Can't tell what we are reading         Assume.assumeFalse(isXmlTest());         //         try (FileInputStream inputStream = new FileInputStream(pathString)) {             assertContents(factory.load(inputStream));         }     }      @Test     public void testLoadPath() throws Exception {         assertContents(factory.load(Paths.get(pathString)));     }      @Test     public void testLoadReader() throws Exception {         // Can't tell what we are reading         Assume.assumeFalse(isXmlTest());         //         try (BufferedReader inputStream = Files.newBufferedReader(Paths.get(pathString))) {             assertContents(factory.load(inputStream));         }     }      @Test     public void testLoadUri() throws Exception {         assertContents(factory.load(Paths.get(pathString).toUri()));     }      @Test     public void testLoadUrl() throws Exception {         assertContents(factory.load(Paths.get(pathString).toUri().toURL()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import static org.junit.Assert.assertFalse; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Enumeration; import java.util.Hashtable; import java.util.Iterator; import java.util.List; import java.util.StringTokenizer; import java.util.Vector;  import org.junit.Test;  /**  * Tests EnumerationUtils.  *  */ public class EnumerationUtilsTest {      public static final String TO_LIST_FIXTURE = "this is a test";      @Test     public void getFromEnumeration() throws Exception {         // Enumeration, entry exists         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         Enumeration<String> en = vector.elements();         assertEquals("zero", EnumerationUtils.get(en, 0));         en = vector.elements();         assertEquals("one", EnumerationUtils.get(en, 1));          // Enumerator, non-existent entry         try {             EnumerationUtils.get(en, 3);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertTrue(!en.hasMoreElements());     }      @Test     public void testAsIterableFor() {         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         final Enumeration<String> en = vector.elements();         final Iterator<String> iterator = EnumerationUtils.asIterable(en).iterator();         assertTrue(iterator.hasNext());         assertEquals("zero", iterator.next());         assertTrue(iterator.hasNext());         assertEquals("one", iterator.next());         assertFalse(iterator.hasNext());     }      @Test     public void testAsIterableForNull() {         try {             EnumerationUtils.asIterable((Enumeration) null).iterator().next();             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testToListWithHashtable() {         final Hashtable<String, Integer> expected = new Hashtable<>();         expected.put("one", Integer.valueOf(1));         expected.put("two", Integer.valueOf(2));         expected.put("three", Integer.valueOf(3));         // validate elements.         final List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());         assertEquals(expected.size(), actualEltList.size());         assertTrue(actualEltList.contains(Integer.valueOf(1)));         assertTrue(actualEltList.contains(Integer.valueOf(2)));         assertTrue(actualEltList.contains(Integer.valueOf(3)));         final List<Integer> expectedEltList = new ArrayList<>();         expectedEltList.add(Integer.valueOf(1));         expectedEltList.add(Integer.valueOf(2));         expectedEltList.add(Integer.valueOf(3));         assertTrue(actualEltList.containsAll(expectedEltList));          // validate keys.         final List<String> actualKeyList = EnumerationUtils.toList(expected.keys());         assertEquals(expected.size(), actualEltList.size());         assertTrue(actualKeyList.contains("one"));         assertTrue(actualKeyList.contains("two"));         assertTrue(actualKeyList.contains("three"));         final List<String> expectedKeyList = new ArrayList<>();         expectedKeyList.add("one");         expectedKeyList.add("two");         expectedKeyList.add("three");         assertTrue(actualKeyList.containsAll(expectedKeyList));     }      @Test     public void testToListWithStringTokenizer() {         final List<String> expectedList1 = new ArrayList<>();         final StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);         while (st.hasMoreTokens()) {             expectedList1.add(st.nextToken());         }         final List<String> expectedList2 = new ArrayList<>();         expectedList2.add("this");         expectedList2.add("is");         expectedList2.add("a");         expectedList2.add("test");         final List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));         assertEquals(expectedList1, expectedList2);         assertEquals(expectedList1, actualList);         assertEquals(expectedList2, actualList);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.trie;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Trie; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.map.AbstractSortedMapTest;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the  * {@link UnmodifiableTrie} implementation.  *  * @since 4.0  */ public class UnmodifiableTrieTest<V> extends AbstractSortedMapTest<String, V> {      public UnmodifiableTrieTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableTrieTest.class);     }      //-------------------------------------------------------------------      @Override     public Trie<String, V> makeObject() {         return UnmodifiableTrie.unmodifiableTrie(new PatriciaTrie<V>());     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public Trie<String, V> makeFullMap() {         final Trie<String, V> m = new PatriciaTrie<>();         addSampleMappings(m);         return UnmodifiableTrie.unmodifiableTrie(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Trie<String, V> trie = makeFullMap();         assertSame(trie, UnmodifiableTrie.unmodifiableTrie(trie));          try {             UnmodifiableTrie.unmodifiableTrie(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return null;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableTrie.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableTrie.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.trie;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.map.AbstractOrderedMapTest;  /**  * JUnit test of the OrderedMap interface of a PatriciaTrie.  *  * @since 4.0  */ public class PatriciaTrie2Test<V> extends AbstractOrderedMapTest<String, V> {      public PatriciaTrie2Test(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PatriciaTrie2Test.class);     }      @Override     public OrderedMap<String, V> makeObject() {         return new PatriciaTrie<>();     }      @Override     public boolean isAllowNullKey() {         return false;     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.trie;  import java.util.ArrayList; import java.util.Arrays; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set; import java.util.SortedMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Trie; import org.apache.commons.collections4.map.AbstractSortedMapTest; import org.junit.Assert;  /**  * JUnit tests for the PatriciaTrie.  *  * @since 4.0  */ public class PatriciaTrieTest<V> extends AbstractSortedMapTest<String, V> {      public PatriciaTrieTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PatriciaTrieTest.class);     }      @Override     public SortedMap<String, V> makeObject() {         return new PatriciaTrie<>();     }      @Override     public boolean isAllowNullKey() {         return false;     }      //-----------------------------------------------------------------------      public void testPrefixMap() {         final PatriciaTrie<String> trie = new PatriciaTrie<>();          final String[] keys = new String[]{             "",             "Albert", "Xavier", "XyZ", "Anna", "Alien", "Alberto",             "Alberts", "Allie", "Alliese", "Alabama", "Banane",             "Blabla", "Amber", "Ammun", "Akka", "Akko", "Albertoo",             "Amma"         };          for (final String key : keys) {             trie.put(key, key);         }          SortedMap<String, String> map;         Iterator<String> iterator;         Iterator<Map.Entry<String, String>> entryIterator;         Map.Entry<String, String> entry;          map = trie.prefixMap("Al");         Assert.assertEquals(8, map.size());         Assert.assertEquals("Alabama", map.firstKey());         Assert.assertEquals("Alliese", map.lastKey());         Assert.assertEquals("Albertoo", map.get("Albertoo"));         Assert.assertNotNull(trie.get("Xavier"));         Assert.assertNull(map.get("Xavier"));         Assert.assertNull(trie.get("Alice"));         Assert.assertNull(map.get("Alice"));         iterator = map.values().iterator();         Assert.assertEquals("Alabama", iterator.next());         Assert.assertEquals("Albert", iterator.next());         Assert.assertEquals("Alberto", iterator.next());         Assert.assertEquals("Albertoo", iterator.next());         Assert.assertEquals("Alberts", iterator.next());         Assert.assertEquals("Alien", iterator.next());         Assert.assertEquals("Allie", iterator.next());         Assert.assertEquals("Alliese", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Albert");         iterator = map.keySet().iterator();         Assert.assertEquals("Albert", iterator.next());         Assert.assertEquals("Alberto", iterator.next());         Assert.assertEquals("Albertoo", iterator.next());         Assert.assertEquals("Alberts", iterator.next());         Assert.assertFalse(iterator.hasNext());         Assert.assertEquals(4, map.size());         Assert.assertEquals("Albert", map.firstKey());         Assert.assertEquals("Alberts", map.lastKey());         Assert.assertNull(trie.get("Albertz"));         map.put("Albertz", "Albertz");         Assert.assertEquals("Albertz", trie.get("Albertz"));         Assert.assertEquals(5, map.size());         Assert.assertEquals("Albertz", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Albert", iterator.next());         Assert.assertEquals("Alberto", iterator.next());         Assert.assertEquals("Albertoo", iterator.next());         Assert.assertEquals("Alberts", iterator.next());         Assert.assertEquals("Albertz", iterator.next());         Assert.assertFalse(iterator.hasNext());         Assert.assertEquals("Albertz", map.remove("Albertz"));          map = trie.prefixMap("Alberto");         Assert.assertEquals(2, map.size());         Assert.assertEquals("Alberto", map.firstKey());         Assert.assertEquals("Albertoo", map.lastKey());         entryIterator = map.entrySet().iterator();         entry = entryIterator.next();         Assert.assertEquals("Alberto", entry.getKey());         Assert.assertEquals("Alberto", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoo", entry.getKey());         Assert.assertEquals("Albertoo", entry.getValue());         Assert.assertFalse(entryIterator.hasNext());         trie.put("Albertoad", "Albertoad");         Assert.assertEquals(3, map.size());         Assert.assertEquals("Alberto", map.firstKey());         Assert.assertEquals("Albertoo", map.lastKey());         entryIterator = map.entrySet().iterator();         entry = entryIterator.next();         Assert.assertEquals("Alberto", entry.getKey());         Assert.assertEquals("Alberto", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoad", entry.getKey());         Assert.assertEquals("Albertoad", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoo", entry.getKey());         Assert.assertEquals("Albertoo", entry.getValue());         Assert.assertFalse(entryIterator.hasNext());         Assert.assertEquals("Albertoo", trie.remove("Albertoo"));         Assert.assertEquals("Alberto", map.firstKey());         Assert.assertEquals("Albertoad", map.lastKey());         Assert.assertEquals(2, map.size());         entryIterator = map.entrySet().iterator();         entry = entryIterator.next();         Assert.assertEquals("Alberto", entry.getKey());         Assert.assertEquals("Alberto", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoad", entry.getKey());         Assert.assertEquals("Albertoad", entry.getValue());         Assert.assertFalse(entryIterator.hasNext());         Assert.assertEquals("Albertoad", trie.remove("Albertoad"));         trie.put("Albertoo", "Albertoo");          map = trie.prefixMap("X");         Assert.assertEquals(2, map.size());         Assert.assertFalse(map.containsKey("Albert"));         Assert.assertTrue(map.containsKey("Xavier"));         Assert.assertFalse(map.containsKey("Xalan"));         iterator = map.values().iterator();         Assert.assertEquals("Xavier", iterator.next());         Assert.assertEquals("XyZ", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("An");         Assert.assertEquals(1, map.size());         Assert.assertEquals("Anna", map.firstKey());         Assert.assertEquals("Anna", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Anna", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Ban");         Assert.assertEquals(1, map.size());         Assert.assertEquals("Banane", map.firstKey());         Assert.assertEquals("Banane", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Banane", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Am");         Assert.assertFalse(map.isEmpty());         Assert.assertEquals(3, map.size());         Assert.assertEquals("Amber", trie.remove("Amber"));         iterator = map.keySet().iterator();         Assert.assertEquals("Amma", iterator.next());         Assert.assertEquals("Ammun", iterator.next());         Assert.assertFalse(iterator.hasNext());         iterator = map.keySet().iterator();         map.put("Amber", "Amber");         Assert.assertEquals(3, map.size());         try {             iterator.next();             Assert.fail("CME expected");         } catch(final ConcurrentModificationException expected) {}         Assert.assertEquals("Amber", map.firstKey());         Assert.assertEquals("Ammun", map.lastKey());          map = trie.prefixMap("Ak\0");         Assert.assertTrue(map.isEmpty());          map = trie.prefixMap("Ak");         Assert.assertEquals(2, map.size());         Assert.assertEquals("Akka", map.firstKey());         Assert.assertEquals("Akko", map.lastKey());         map.put("Ak", "Ak");         Assert.assertEquals("Ak", map.firstKey());         Assert.assertEquals("Akko", map.lastKey());         Assert.assertEquals(3, map.size());         trie.put("Al", "Al");         Assert.assertEquals(3, map.size());         Assert.assertEquals("Ak", map.remove("Ak"));         Assert.assertEquals("Akka", map.firstKey());         Assert.assertEquals("Akko", map.lastKey());         Assert.assertEquals(2, map.size());         iterator = map.keySet().iterator();         Assert.assertEquals("Akka", iterator.next());         Assert.assertEquals("Akko", iterator.next());         Assert.assertFalse(iterator.hasNext());         Assert.assertEquals("Al", trie.remove("Al"));          map = trie.prefixMap("Akka");         Assert.assertEquals(1, map.size());         Assert.assertEquals("Akka", map.firstKey());         Assert.assertEquals("Akka", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Akka", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Ab");         Assert.assertTrue(map.isEmpty());         Assert.assertEquals(0, map.size());         try {             final Object o = map.firstKey();             Assert.fail("got a first key: " + o);         } catch(final NoSuchElementException nsee) {}         try {             final Object o = map.lastKey();             Assert.fail("got a last key: " + o);         } catch(final NoSuchElementException nsee) {}         iterator = map.values().iterator();         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Albertooo");         Assert.assertTrue(map.isEmpty());         Assert.assertEquals(0, map.size());         try {             final Object o = map.firstKey();             Assert.fail("got a first key: " + o);         } catch(final NoSuchElementException nsee) {}         try {             final Object o = map.lastKey();             Assert.fail("got a last key: " + o);         } catch(final NoSuchElementException nsee) {}         iterator = map.values().iterator();         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("");         Assert.assertSame(trie, map); // stricter than necessary, but a good check          map = trie.prefixMap("\0");         Assert.assertTrue(map.isEmpty());         Assert.assertEquals(0, map.size());         try {             final Object o = map.firstKey();             Assert.fail("got a first key: " + o);         } catch(final NoSuchElementException nsee) {}         try {             final Object o = map.lastKey();             Assert.fail("got a last key: " + o);         } catch(final NoSuchElementException nsee) {}         iterator = map.values().iterator();         Assert.assertFalse(iterator.hasNext());     }      public void testPrefixMapRemoval() {         final PatriciaTrie<String> trie = new PatriciaTrie<>();          final String[] keys = new String[]{             "Albert", "Xavier", "XyZ", "Anna", "Alien", "Alberto",             "Alberts", "Allie", "Alliese", "Alabama", "Banane",             "Blabla", "Amber", "Ammun", "Akka", "Akko", "Albertoo",             "Amma"         };          for (final String key : keys) {             trie.put(key, key);         }          SortedMap<String, String> map = trie.prefixMap("Al");         Assert.assertEquals(8, map.size());         Iterator<String> iter = map.keySet().iterator();         Assert.assertEquals("Alabama", iter.next());         Assert.assertEquals("Albert", iter.next());         Assert.assertEquals("Alberto", iter.next());         Assert.assertEquals("Albertoo", iter.next());         Assert.assertEquals("Alberts", iter.next());         Assert.assertEquals("Alien", iter.next());         iter.remove();         Assert.assertEquals(7, map.size());         Assert.assertEquals("Allie", iter.next());         Assert.assertEquals("Alliese", iter.next());         Assert.assertFalse(iter.hasNext());          map = trie.prefixMap("Ak");         Assert.assertEquals(2, map.size());         iter = map.keySet().iterator();         Assert.assertEquals("Akka", iter.next());         iter.remove();         Assert.assertEquals(1, map.size());         Assert.assertEquals("Akko", iter.next());         if (iter.hasNext()) {             Assert.fail("shouldn't have next (but was: " + iter.next() + ")");         }         Assert.assertFalse(iter.hasNext());     }      public void testPrefixMapSizes() {         // COLLECTIONS-525         final PatriciaTrie<String> aTree = new PatriciaTrie<>();         aTree.put("", "");         aTree.put("", "");         assertTrue(aTree.prefixMap("").containsKey(""));         assertEquals("", aTree.prefixMap("").get(""));         assertFalse(aTree.prefixMap("").isEmpty());         assertEquals(1, aTree.prefixMap("").size());         assertEquals(1, aTree.prefixMap("").keySet().size());         assertEquals(1, aTree.prefixMap("").entrySet().size());         assertEquals(1, aTree.prefixMap("").values().size());          aTree.clear();         aTree.put("", "");         aTree.put("", "");         assertEquals(2, aTree.prefixMap("").keySet().size());         assertEquals(2, aTree.prefixMap("").values().size());     }      public void testPrefixMapSizes2() {         final char u8000 = Character.toChars(32768)[0]; // U+8000 (1000000000000000)         final char char_b = 'b'; // 1100010          final PatriciaTrie<String> trie = new PatriciaTrie<>();         final String prefixString = "" + char_b;         final String longerString = prefixString + u8000;          assertEquals(1, prefixString.length());         assertEquals(2, longerString.length());          assertTrue(longerString.startsWith(prefixString));          trie.put(prefixString, "prefixString");         trie.put(longerString, "longerString");          assertEquals(2, trie.prefixMap(prefixString).size());         assertTrue(trie.prefixMap(prefixString).containsKey(longerString));     }      public void testPrefixMapClear() {         final Trie<String, Integer> trie = new PatriciaTrie<>();         trie.put("Anna", 1);         trie.put("Anael", 2);         trie.put("Analu", 3);         trie.put("Andreas", 4);         trie.put("Andrea", 5);         trie.put("Andres", 6);         trie.put("Anatole", 7);         final SortedMap<String, Integer> prefixMap = trie.prefixMap("And");         assertEquals(new HashSet<>(Arrays.asList("Andrea", "Andreas", "Andres")), prefixMap.keySet());         assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));          prefixMap.clear();         assertTrue(prefixMap.isEmpty());         assertTrue(prefixMap.keySet().isEmpty());         assertTrue(prefixMap.values().isEmpty());         assertEquals(new HashSet<>(Arrays.asList("Anael", "Analu", "Anatole", "Anna")), trie.keySet());         assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));     }      public void testPrefixMapClearNothing() {         final Trie<String, Integer> trie = new PatriciaTrie<>();         final SortedMap<String, Integer> prefixMap = trie.prefixMap("And");         assertEquals(new HashSet<String>(), prefixMap.keySet());         assertEquals(new ArrayList<Integer>(0), new ArrayList<>(prefixMap.values()));          prefixMap.clear();         assertTrue(prefixMap.isEmpty());         assertTrue(prefixMap.keySet().isEmpty());         assertTrue(prefixMap.values().isEmpty());         assertEquals(new HashSet<String>(), trie.keySet());         assertEquals(new ArrayList<Integer>(0), new ArrayList<>(trie.values()));     }      public void testPrefixMapClearUsingRemove() {         final Trie<String, Integer> trie = new PatriciaTrie<>();         trie.put("Anna", 1);         trie.put("Anael", 2);         trie.put("Analu", 3);         trie.put("Andreas", 4);         trie.put("Andrea", 5);         trie.put("Andres", 6);         trie.put("Anatole", 7);         final SortedMap<String, Integer> prefixMap = trie.prefixMap("And");         assertEquals(new HashSet<>(Arrays.asList("Andrea", "Andreas", "Andres")), prefixMap.keySet());         assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));          final Set<String> keys = new HashSet<>(prefixMap.keySet());         for (final String key : keys) {             prefixMap.remove(key);         }         assertTrue(prefixMap.keySet().isEmpty());         assertTrue(prefixMap.values().isEmpty());         assertEquals(new HashSet<>(Arrays.asList("Anael", "Analu", "Anatole", "Anna")), trie.keySet());         assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PatriciaTrie.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PatriciaTrie.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link PredicatedSet} implementation.  *  * @since 3.0  */ public class PredicatedSetTest<E> extends AbstractSetTest<E> {      public PredicatedSetTest(final String testName) {         super(testName);     }   //-------------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected PredicatedSet<E> decorateSet(final Set<E> set, final Predicate<? super E> predicate) {         return PredicatedSet.predicatedSet(set, predicate);     }      @Override     public PredicatedSet<E> makeObject() {         return decorateSet(new HashSet<E>(), truePredicate);     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] {"1", "3", "5", "7", "2", "4", "6"};     }  //--------------------------------------------------------------------      protected Predicate<E> testPredicate =         o -> o instanceof String;      protected PredicatedSet<E> makeTestSet() {         return decorateSet(new HashSet<E>(), testPredicate);     }      public void testGetSet() {         final PredicatedSet<E> set = makeTestSet();         assertTrue("returned set should not be null", set.decorated() != null);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final Set<E> set = makeTestSet();         final Integer i = Integer.valueOf(3);         try {             set.add((E) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !set.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final Set<E> set = makeTestSet();         final Set<E> elements = new HashSet<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) Integer.valueOf(3));         elements.add((E) "four");         try {             set.addAll(elements);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Set shouldn't contain illegal element", !set.contains("one"));         assertTrue("Set shouldn't contain illegal element", !set.contains("two"));         assertTrue("Set shouldn't contain illegal element", !set.contains(Integer.valueOf(3)));         assertTrue("Set shouldn't contain illegal element", !set.contains("four"));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.NavigableSet; import java.util.Set; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractNavigableSetTest} for exercising the  * {@link UnmodifiableNavigableSet} implementation.  *  * @since 4.1  */ public class UnmodifiableNavigableSetTest<E> extends AbstractNavigableSetTest<E> {     protected UnmodifiableNavigableSet<E> set = null;     protected ArrayList<E> array = null;      public UnmodifiableNavigableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableNavigableSetTest.class);     }      //-------------------------------------------------------------------     @Override     public NavigableSet<E> makeObject() {         return UnmodifiableNavigableSet.unmodifiableNavigableSet(new TreeSet<E>());     }      @Override     public UnmodifiableNavigableSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return (UnmodifiableNavigableSet<E>) UnmodifiableNavigableSet.unmodifiableNavigableSet(set);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //--------------------------------------------------------------------     @SuppressWarnings("unchecked")     protected void setupSet() {         set = makeFullCollection();         array = new ArrayList<>();         array.add((E) Integer.valueOf(1));     }      /**      * Verify that base set and subsets are not modifiable      */     @SuppressWarnings("unchecked")     public void testUnmodifiable() {         setupSet();         verifyUnmodifiable(set);         verifyUnmodifiable(set.descendingSet());         verifyUnmodifiable(set.headSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.headSet((E) Integer.valueOf(1), true));         verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1), false));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), (E) Integer.valueOf(3)));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), false, (E) Integer.valueOf(3), false));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), true, (E) Integer.valueOf(3), true));     }      public void testDecorateFactory() {         final NavigableSet<E> set = makeFullCollection();         assertSame(set, UnmodifiableNavigableSet.unmodifiableNavigableSet(set));          try {             UnmodifiableNavigableSet.unmodifiableNavigableSet(null);             fail();         } catch (final NullPointerException ex) {}     }      /**      * Verifies that a set is not modifiable      */     @SuppressWarnings("unchecked")     public void verifyUnmodifiable(final Set<E> set) {         try {             set.add((E) "value");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.addAll(new TreeSet<E>());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.clear();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.remove("x");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.removeAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.retainAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      public void testComparator() {         setupSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableNavigableSet.emptyCollection.version4.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableNavigableSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.IteratorUtils;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link ListOrderedSet} implementation.  *  * @since 3.0  */ public class ListOrderedSetTest<E>     extends AbstractSetTest<E> {      private static final Integer ZERO = Integer.valueOf(0);      private static final Integer ONE = Integer.valueOf(1);      private static final Integer TWO = Integer.valueOf(2);      private static final Integer THREE = Integer.valueOf(3);      public ListOrderedSetTest(final String testName) {         super(testName);     }      @Override     public ListOrderedSet<E> makeObject() {         return ListOrderedSet.listOrderedSet(new HashSet<E>());     }      @SuppressWarnings("unchecked")     protected ListOrderedSet<E> setupSet() {         final ListOrderedSet<E> set = makeObject();          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }         return set;     }      @SuppressWarnings("unchecked")     public void testOrdering() {         final ListOrderedSet<E> set = setupSet();         Iterator<E> it = set.iterator();          for (int i = 0; i < 10; i++) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i += 2) {             assertTrue("Must be able to remove int",                        set.remove(Integer.toString(i)));         }          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong after remove ",                          Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }          assertEquals("Size of set is wrong!", 10, set.size());          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }         for (int i = 0; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }     }      @SuppressWarnings("unchecked")     public void testListAddRemove() {         final ListOrderedSet<E> set = makeObject();         final List<E> view = set.asList();         set.add((E) ZERO);         set.add((E) ONE);         set.add((E) TWO);          assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));         assertEquals(3, view.size());         assertSame(ZERO, view.get(0));         assertSame(ONE, view.get(1));         assertSame(TWO, view.get(2));          assertEquals(0, set.indexOf(ZERO));         assertEquals(1, set.indexOf(ONE));         assertEquals(2, set.indexOf(TWO));          set.remove(1);         assertEquals(2, set.size());         assertSame(ZERO, set.get(0));         assertSame(TWO, set.get(1));         assertEquals(2, view.size());         assertSame(ZERO, view.get(0));         assertSame(TWO, view.get(1));     }      @SuppressWarnings("unchecked")     public void testListAddIndexed() {         final ListOrderedSet<E> set = makeObject();         set.add((E) ZERO);         set.add((E) TWO);          set.add(1, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          set.add(0, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          final List<E> list = new ArrayList<>();         list.add((E) ZERO);         list.add((E) TWO);          set.addAll(0, list);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          list.add(0, (E) THREE); // list = [3,0,2]         set.remove(TWO); //  set = [0,1]         set.addAll(1, list);         assertEquals(4, set.size());         assertSame(ZERO, set.get(0));         assertSame(THREE, set.get(1));         assertSame(TWO, set.get(2));         assertSame(ONE, set.get(3));     }      @SuppressWarnings("unchecked")     public void testListAddReplacing() {         final ListOrderedSet<E> set = makeObject();         final A a = new A();         final B b = new B();         set.add((E) a);         assertEquals(1, set.size());         set.add((E) b); // will match but not replace A as equal         assertEquals(1, set.size());         assertSame(a, set.decorated().iterator().next());         assertSame(a, set.iterator().next());         assertSame(a, set.get(0));         assertSame(a, set.asList().get(0));     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         final List<E> list = new ArrayList<>(10);         final Set<E> set = new HashSet<>(10);         final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(set, list);         for (int i = 0; i < 10; ++i) {             orderedSet.add((E) Integer.valueOf(10 - i - 1));         }          final Collection<E> retained = new ArrayList<>(5);         for (int i = 0; i < 5; ++i) {             retained.add((E) Integer.valueOf(i * 2));         }          assertTrue(orderedSet.retainAll(retained));         assertEquals(5, orderedSet.size());         // insertion order preserved?         assertEquals(Integer.valueOf(8), orderedSet.get(0));         assertEquals(Integer.valueOf(6), orderedSet.get(1));         assertEquals(Integer.valueOf(4), orderedSet.get(2));         assertEquals(Integer.valueOf(2), orderedSet.get(3));         assertEquals(Integer.valueOf(0), orderedSet.get(4));     }      @SuppressWarnings("unchecked")     public void testDuplicates() {         final List<E> list = new ArrayList<>(10);         list.add((E) Integer.valueOf(1));         list.add((E) Integer.valueOf(2));         list.add((E) Integer.valueOf(3));         list.add((E) Integer.valueOf(1));          final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(list);          assertEquals(3, orderedSet.size());         assertEquals(3, IteratorUtils.toArray(orderedSet.iterator()).length);          // insertion order preserved?         assertEquals(Integer.valueOf(1), orderedSet.get(0));         assertEquals(Integer.valueOf(2), orderedSet.get(1));         assertEquals(Integer.valueOf(3), orderedSet.get(2));     }      static class A {          @Override         public boolean equals(final Object obj) {             return obj instanceof A || obj instanceof B;         }          @Override         public int hashCode() {             return 1;         }     }      static class B {          @Override         public boolean equals(final Object obj) {             return obj instanceof A || obj instanceof B;         }          @Override         public int hashCode() {             return 1;         }     }      public void testDecorator() {         try {             ListOrderedSet.listOrderedSet((List<E>) null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet((Set<E>) null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet(null, null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet(new HashSet<E>(), null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet(null, new ArrayList<E>());             fail();         } catch (final NullPointerException ex) {         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ListOrderedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ListOrderedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Iterator; import java.util.SortedSet; import java.util.TreeSet;  import org.apache.commons.collections4.BulkTest;  /**  * Abstract test class for {@link SortedSet} methods and contracts.  * <p>  * To use, subclass and override the {@link #makeObject()}  * method.  You may have to override other protected methods if your  * set is not modifiable, or if your set restricts what kinds of  * elements may be added; see {@link AbstractSetTest} for more details.  *  * @since 3.0  */ public abstract class AbstractSortedSetTest<E> extends AbstractSetTest<E> {      /**      * JUnit constructor.      *      * @param name  name for test      */     public AbstractSortedSetTest(final String name) {         super(name);     }      //-----------------------------------------------------------------------     /**      * Verification extension, will check the order of elements,      * the sets should already be verified equal.      */     @Override     public void verify() {         super.verify();          // Check that iterator returns elements in order and first() and last()         // are consistent         final Iterator<E> colliter = getCollection().iterator();         final Iterator<E> confiter = getConfirmed().iterator();         E first = null;         E last = null;         while (colliter.hasNext()) {             if (first == null) {                 first = colliter.next();                 last = first;             } else {                 last = colliter.next();             }             assertEquals("Element appears to be out of order.", last, confiter.next());         }         if (getCollection().size() > 0) {             assertEquals("Incorrect element returned by first().", first,                 getCollection().first());             assertEquals("Incorrect element returned by last().", last,                 getCollection().last());         }     }      //-----------------------------------------------------------------------     /**      * Overridden because SortedSets don't allow null elements (normally).      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedSet<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedSet<E> makeFullCollection() {         return (SortedSet<E>) super.makeFullCollection();     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link TreeSet} for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public SortedSet<E> makeConfirmedCollection() {         return new TreeSet<>();     }      //-----------------------------------------------------------------------      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (E[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (E[]) elements;     }      //-----------------------------------------------------------------------     /**      * Bulk test {@link SortedSet#subSet(Object, Object)}.  This method runs through all of      * the tests in {@link AbstractSortedSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing a subset.      */     public BulkTest bulkTestSortedSetSubSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestSortedSetSubSet(lobound, hibound);      }      /**      * Bulk test {@link SortedSet#headSet(Object)}.  This method runs through all of      * the tests in {@link AbstractSortedSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing a headset.      */     public BulkTest bulkTestSortedSetHeadSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestSortedSetSubSet(hibound, true);     }      /**      * Bulk test {@link SortedSet#tailSet(Object)}.  This method runs through all of      * the tests in {@link AbstractSortedSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing a tailset.      */     public BulkTest bulkTestSortedSetTailSet() {         final int length = getFullElements().length;         final int lobound = length / 3;         return new TestSortedSetSubSet(lobound, false);     }      public class TestSortedSetSubSet extends AbstractSortedSetTest<E> {          private int m_Type;         private int m_LowBound;         private int m_HighBound;         private E[] m_FullElements;         private E[] m_OtherElements;          @SuppressWarnings("unchecked")         public TestSortedSetSubSet(final int bound, final boolean head) {             super("TestSortedSetSubSet");             if (head) {                 //System.out.println("HEADSET");                 m_Type = TYPE_HEADSET;                 m_HighBound = bound;                 m_FullElements = (E[]) new Object[bound];                 System.arraycopy(AbstractSortedSetTest.this.getFullElements(), 0, m_FullElements, 0, bound);                 m_OtherElements = (E[]) new Object[bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractSortedSetTest.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);                 //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));                 //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));             } else {                 //System.out.println("TAILSET");                 m_Type = TYPE_TAILSET;                 m_LowBound = bound;                 final Object[] allelements = AbstractSortedSetTest.this.getFullElements();                 //System.out.println("bound = "+bound +"::length="+allelements.length);                 m_FullElements = (E[]) new Object[allelements.length - bound];                 System.arraycopy(allelements, bound, m_FullElements, 0, allelements.length - bound);                 m_OtherElements = (E[]) new Object[allelements.length - bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractSortedSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);                 //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));                 //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));                 //resetFull();                 //System.out.println(collection);                 //System.out.println(confirmed);              }          } //type          @SuppressWarnings("unchecked")         public TestSortedSetSubSet(final int lobound, final int hibound) {             super("TestSortedSetSubSet");             //System.out.println("SUBSET");             m_Type = TYPE_SUBSET;             m_LowBound = lobound;             m_HighBound = hibound;             final int length = hibound - lobound;             //System.out.println("Low=" + lobound + "::High=" + hibound + "::Length=" + length);             m_FullElements = (E[]) new Object[length];             System.arraycopy(AbstractSortedSetTest.this.getFullElements(), lobound, m_FullElements, 0, length);             m_OtherElements = (E[]) new Object[length - 1];             System.arraycopy(//src src_pos dst dst_pos length                 AbstractSortedSetTest.this.getOtherElements(), lobound, m_OtherElements, 0, length - 1);              //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));             //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));          }          @Override         public boolean isNullSupported() {             return AbstractSortedSetTest.this.isNullSupported();         }         @Override         public boolean isAddSupported() {             return AbstractSortedSetTest.this.isAddSupported();         }         @Override         public boolean isRemoveSupported() {             return AbstractSortedSetTest.this.isRemoveSupported();         }         @Override         public boolean isFailFastSupported() {             return AbstractSortedSetTest.this.isFailFastSupported();         }          @Override         public E[] getFullElements() {             return m_FullElements;         }         @Override         public E[] getOtherElements() {             return m_OtherElements;         }          private SortedSet<E> getSubSet(final SortedSet<E> set) {             final E[] elements = AbstractSortedSetTest.this.getFullElements();             switch (m_Type) {             case TYPE_SUBSET :                 return set.subSet(elements[m_LowBound], elements[m_HighBound]);             case TYPE_HEADSET :                 return set.headSet(elements[m_HighBound]);             case TYPE_TAILSET :                 return set.tailSet(elements[m_LowBound]);             default :                 return null;             }         }          @Override         public SortedSet<E> makeObject() {             return getSubSet(AbstractSortedSetTest.this.makeObject());         }          @Override         public SortedSet<E> makeFullCollection() {             return getSubSet(AbstractSortedSetTest.this.makeFullCollection());         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public BulkTest bulkTestSortedSetSubSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetHeadSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetTailSet() {             return null;  // prevent infinite recursion         }          static final int TYPE_SUBSET = 0;         static final int TYPE_TAILSET = 1;         static final int TYPE_HEADSET = 2;      }      /**      * {@inheritDoc}      */     @Override     public SortedSet<E> getCollection() {         return (SortedSet<E>) super.getCollection();     }      /**      * {@inheritDoc}      */     @Override     public SortedSet<E> getConfirmed() {         return (SortedSet<E>) super.getConfirmed();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Set;  import org.apache.commons.collections4.map.HashedMap;  /**  * JUnit test.  *  * @since 3.1  */ public class MapBackedSetTest<E> extends AbstractSetTest<E> {      public MapBackedSetTest(final String testName) {         super(testName);     }      @Override     public Set<E> makeObject() {         return MapBackedSet.mapBackedSet(new HashedMap<E, Object>());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/MapBackedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/MapBackedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Collection; import java.util.List; import java.util.Set;  /**  * This class is used in CompositeSetTest. When testing serialization,  * the class has to be separate of CompositeSetTest, else the test  * class also has to be serialized.  */ class EmptySetMutator<E> implements CompositeSet.SetMutator<E> {      /** Serialization version */     private static final long serialVersionUID = 5321193666420238910L;      private final Set<E> contained;      EmptySetMutator(final Set<E> set) {         this.contained = set;     }      @Override     public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing, final Set<E> added, final Collection<E> intersects) {         throw new IllegalArgumentException();     }      @Override     public boolean add(final CompositeSet<E> composite, final List<Set<E>> collections, final E obj) {         return contained.add(obj);     }      @Override     public boolean addAll(final CompositeSet<E> composite, final List<Set<E>> collections, final Collection<? extends E> coll) {         return contained.addAll(coll);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Iterator; import java.util.Set;  import org.apache.commons.collections4.map.LinkedMap;  /**  * JUnit test.  *  * @since 3.1  */ public class MapBackedSet2Test<E> extends AbstractSetTest<E> {      public MapBackedSet2Test(final String testName) {         super(testName);     }      @Override     public Set<E> makeObject() {         return MapBackedSet.mapBackedSet(new LinkedMap<E, Object>());     }      @SuppressWarnings("unchecked")     protected Set<E> setupSet() {         final Set<E> set = makeObject();          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }         return set;     }      @SuppressWarnings("unchecked")     public void testOrdering() {         final Set<E> set = setupSet();         Iterator<E> it = set.iterator();          for (int i = 0; i < 10; i++) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i += 2) {             assertTrue("Must be able to remove int", set.remove(Integer.toString(i)));         }          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong after remove ", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }          assertEquals("Size of set is wrong!", 10, set.size());          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }         for (int i = 0; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }     }      @Override     public void testCanonicalEmptyCollectionExists() {     }      @Override     public void testCanonicalFullCollectionExists() {     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.set.CompositeSet.SetMutator;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link CompositeSet} implementation.  *  * @since 3.0  */ public class CompositeSetTest<E> extends AbstractSetTest<E> {     public CompositeSetTest(final String name) {         super(name);     }      @Override     public CompositeSet<E> makeObject() {         final HashSet<E> contained = new HashSet<>();         final CompositeSet<E> set = new CompositeSet<>(contained);         set.setMutator( new EmptySetMutator<>(contained) );         return set;     }      @SuppressWarnings("unchecked")     public Set<E> buildOne() {         final HashSet<E> set = new HashSet<>();         set.add((E) "1");         set.add((E) "2");         return set;     }      @SuppressWarnings("unchecked")     public Set<E> buildTwo() {         final HashSet<E> set = new HashSet<>();         set.add((E) "3");         set.add((E) "4");         return set;     }      @SuppressWarnings("unchecked")     public void testContains() {         final CompositeSet<E> set = new CompositeSet<>(new Set[]{ buildOne(), buildTwo() });         assertTrue(set.contains("1"));     }      @SuppressWarnings("unchecked")     public void testContainsAll() {         final CompositeSet<E> set = new CompositeSet<>(new Set[]{ buildOne(), buildTwo() });         assertFalse(set.containsAll(null));     }      @SuppressWarnings("unchecked")     public void testRemoveAll() {         final CompositeSet<E> set = new CompositeSet<>(new Set[]{ buildOne(), buildTwo() });         assertFalse(set.removeAll(null));     }      @SuppressWarnings("unchecked")     public void testRemoveUnderlying() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>(new Set[] { one, two });         one.remove("1");         assertFalse(set.contains("1"));          two.remove("3");         assertFalse(set.contains("3"));     }      @SuppressWarnings("unchecked")     public void testRemoveComposited() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>(new Set[] { one, two });         set.remove("1");         assertFalse(one.contains("1"));          set.remove("3");         assertFalse(one.contains("3"));     }      @SuppressWarnings("unchecked")     public void testFailedCollisionResolution() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>(new Set[] { one, two });         set.setMutator(new SetMutator<E>() {             private static final long serialVersionUID = 1L;              @Override             public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing,                 final Set<E> added, final Collection<E> intersects) {                 //noop             }              @Override             public boolean add(final CompositeSet<E> composite,                     final List<Set<E>> collections, final E obj) {                 throw new UnsupportedOperationException();             }              @Override             public boolean addAll(final CompositeSet<E> composite,                     final List<Set<E>> collections, final Collection<? extends E> coll) {                 throw new UnsupportedOperationException();             }         });          final HashSet<E> three = new HashSet<>();         three.add((E) "1");         try {             set.addComposited(three);             fail("IllegalArgumentException should have been thrown");         } catch (final IllegalArgumentException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testAddComposited() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>();         set.addComposited(one, two);         set.addComposited((Set<E>) null);         set.addComposited((Set<E>[]) null);         set.addComposited(null, null);         set.addComposited(null, null, null);         final CompositeSet<E> set2 = new CompositeSet<>(buildOne());         set2.addComposited(buildTwo());         assertTrue(set.equals(set2));         final HashSet<E> set3 = new HashSet<>();         set3.add((E) "1");         set3.add((E) "2");         set3.add((E) "3");         final HashSet<E> set4 = new HashSet<>();         set4.add((E) "4");         final CompositeSet<E> set5 = new CompositeSet<>(set3);         set5.addComposited(set4);         assertTrue(set.equals(set5));         try {             set.addComposited(set3);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testAddCompositedCollision() {         final HashSet<E> set1 = new HashSet<>();         set1.add((E) "1");         set1.add((E) "2");         set1.add((E) "3");         final HashSet<E> set2 = new HashSet<>();         set2.add((E) "4");         final CompositeSet<E> set3 = new CompositeSet<>(set1);         try {             set3.addComposited(set1, buildOne());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException ex) {             // expected         }         try {             set3.addComposited(set1, buildOne(), buildTwo());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException ex) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Comparator; import java.util.NavigableSet; import java.util.Set; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractNavigableSetTest} for exercising the  * {@link PredicatedNavigableSet} implementation.  *  * @since 4.1  */ public class PredicatedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {      public PredicatedNavigableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedNavigableSetTest.class);     }      //-------------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      @Override     public NavigableSet<E> makeObject() {         return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<E>(), truePredicate);     }      @Override     public NavigableSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return PredicatedNavigableSet.predicatedNavigableSet(set, truePredicate);     }  //--------------------------------------------------------------------     protected Predicate<E> testPredicate =         o -> o instanceof String && ((String) o).startsWith("A");      protected PredicatedNavigableSet<E> makeTestSet() {         return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<E>(), testPredicate);     }      public void testGetSet() {         final PredicatedNavigableSet<E> set = makeTestSet();         assertTrue("returned set should not be null", set.decorated() != null);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final NavigableSet<E> set = makeTestSet();         final String testString = "B";         try {             set.add((E) testString);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !set.contains(testString));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final NavigableSet<E> set = makeTestSet();         final Set<E> elements = new TreeSet<>();         elements.add((E) "Aone");         elements.add((E) "Atwo");         elements.add((E) "Bthree");         elements.add((E) "Afour");         try {             set.addAll(elements);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Set shouldn't contain illegal element", !set.contains("Aone"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Atwo"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Bthree"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Afour"));     }      public void testComparator() {         final NavigableSet<E> set = makeTestSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedNavigableSet.emptyCollection.version4.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedNavigableSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collections; import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSetTest} for exercising the {@link TransformedSet}  * implementation.  *  * @since 3.0  */ public class TransformedSetTest<E> extends AbstractSetTest<E> {      public TransformedSetTest(final String testName) {         super(testName);     }      @Override     public Set<E> makeConfirmedCollection() {         return new HashSet<>();     }      @Override     public Set<E> makeConfirmedFullCollection() {         return new HashSet<>(Arrays.asList(getFullElements()));     }      @Override     @SuppressWarnings("unchecked")     public Set<E> makeObject() {         return TransformedSet.transformingSet(new HashSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public Set<E> makeFullCollection() {         final Set<E> list = new HashSet<>(Arrays.asList(getFullElements()));         return TransformedSet.transformingSet(list,                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedSet() {         final Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, set.size());         final E[] els = (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < els.length; i++) {             set.add(els[i]);             assertEquals(i + 1, set.size());             assertEquals(true, set.contains(Integer.valueOf((String) els[i])));             assertEquals(false, set.contains(els[i]));         }          assertEquals(false, set.remove(els[0]));         assertEquals(true, set.remove(Integer.valueOf((String) els[0])));      }      public void testTransformedSet_decorateTransform() {         final Set<Object> originalSet = new HashSet<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalSet, els);         final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, set.size());         for (final Object el : els) {             assertEquals(true, set.contains(Integer.valueOf((String) el)));             assertEquals(false, set.contains(el));         }          assertEquals(false, set.remove(els[0]));         assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collections; import java.util.TreeSet; import java.util.Set; import java.util.SortedSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSortedSetTest} for exercising the {@link TransformedSortedSet}  * implementation.  *  * @since 3.0  */ public class TransformedSortedSetTest<E> extends AbstractSortedSetTest<E> {      public TransformedSortedSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedSortedSetTest.class);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public SortedSet<E> makeObject() {         return TransformedSortedSet.transformingSortedSet(new TreeSet<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public SortedSet<E> makeFullCollection() {         final SortedSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testTransformedSet() {         final SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, set.size());         final E[] els = (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < els.length; i++) {             set.add(els[i]);             assertEquals(i + 1, set.size());             assertEquals(true, set.contains(Integer.valueOf((String) els[i])));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      public void testTransformedSet_decorateTransform() {         final Set<Object> originalSet = new TreeSet<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalSet, els);         final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, set.size());         for (final Object el : els) {             assertEquals(true, set.contains(Integer.valueOf((String) el)));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSortedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSortedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractSortedSetTest} for exercising the  * {@link UnmodifiableSortedSet} implementation.  *  * @since 3.0  */ public class UnmodifiableSortedSetTest<E> extends AbstractSortedSetTest<E> {     protected UnmodifiableSortedSet<E> set = null;     protected ArrayList<E> array = null;      public UnmodifiableSortedSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSortedSetTest.class);     }      //-------------------------------------------------------------------     @Override     public SortedSet<E> makeObject() {         return UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<E>());     }      @Override     public UnmodifiableSortedSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.unmodifiableSortedSet(set);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //--------------------------------------------------------------------     @SuppressWarnings("unchecked")     protected void setupSet() {         set = makeFullCollection();         array = new ArrayList<>();         array.add((E) Integer.valueOf(1));     }      /**      * Verify that base set and subsets are not modifiable      */     @SuppressWarnings("unchecked")     public void testUnmodifiable() {         setupSet();         verifyUnmodifiable(set);         verifyUnmodifiable(set.headSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), (E) Integer.valueOf(3)));     }      public void testDecorateFactory() {         final SortedSet<E> set = makeFullCollection();         assertSame(set, UnmodifiableSortedSet.unmodifiableSortedSet(set));          try {             UnmodifiableSortedSet.unmodifiableSortedSet(null);             fail();         } catch (final NullPointerException ex) {}     }      /**      * Verifies that a set is not modifiable      */     @SuppressWarnings("unchecked")     public void verifyUnmodifiable(final Set<E> set) {         try {             set.add((E) "value");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.addAll(new TreeSet<E>());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.clear();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.remove("x");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.removeAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.retainAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      public void testComparator() {         setupSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSortedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSortedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Comparator; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractSortedSetTest} for exercising the  * {@link PredicatedSortedSet} implementation.  *  * @since 3.0  */ public class PredicatedSortedSetTest<E> extends AbstractSortedSetTest<E> {      public PredicatedSortedSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedSortedSetTest.class);     }      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      @Override     public SortedSet<E> makeObject() {         return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), truePredicate);     }      @Override     public SortedSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return PredicatedSortedSet.predicatedSortedSet(set, truePredicate);     }      protected Predicate<E> testPredicate =         o -> o instanceof String && ((String) o).startsWith("A");      protected PredicatedSortedSet<E> makeTestSet() {         return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), testPredicate);     }      public void testGetSet() {         final PredicatedSortedSet<E> set = makeTestSet();         assertTrue("returned set should not be null", set.decorated() != null);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final SortedSet<E> set = makeTestSet();         final String testString = "B";         try {             set.add((E) testString);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !set.contains(testString));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final SortedSet<E> set = makeTestSet();         final Set<E> elements = new TreeSet<>();         elements.add((E) "Aone");         elements.add((E) "Atwo");         elements.add((E) "Bthree");         elements.add((E) "Afour");         try {             set.addAll(elements);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Set shouldn't contain illegal element", !set.contains("Aone"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Atwo"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Bthree"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Afour"));     }      public void testComparator() {         final SortedSet<E> set = makeTestSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSortedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSortedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Iterator; import java.util.NavigableSet; import java.util.TreeSet;  import org.apache.commons.collections4.BulkTest;  /**  * Abstract test class for {@link NavigableSet} methods and contracts.  * <p>  * To use, subclass and override the {@link #makeObject()}  * method.  You may have to override other protected methods if your  * set is not modifiable, or if your set restricts what kinds of  * elements may be added; see {@link AbstractSetTest} for more details.  *  * @since 4.1  */ public abstract class AbstractNavigableSetTest<E> extends AbstractSortedSetTest<E> {      /**      * JUnit constructor.      *      * @param name  name for test      */     public AbstractNavigableSetTest(final String name) {         super(name);     }      //-----------------------------------------------------------------------     /**      * {@inheritDoc}      */     @Override     public abstract NavigableSet<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public NavigableSet<E> makeFullCollection() {         return (NavigableSet<E>) super.makeFullCollection();     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link TreeSet} for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public NavigableSet<E> makeConfirmedCollection() {         return new TreeSet<>();     }      //-----------------------------------------------------------------------      /**      * Verification extension, will check the order of elements,      * the sets should already be verified equal.      */     @Override     public void verify() {         super.verify();          // Check that descending iterator returns elements in order and higher(), lower(),         // floor() and ceiling() are consistent         final Iterator<E> colliter = getCollection().descendingIterator();         final Iterator<E> confiter = getConfirmed().descendingIterator();         while (colliter.hasNext()) {             final E element = colliter.next();             final E confelement = confiter.next();             assertEquals("Element appears to be out of order.", confelement, element);              assertEquals("Incorrect element returned by higher().", getConfirmed().higher(element),                                                                     getCollection().higher(element));              assertEquals("Incorrect element returned by lower().", getConfirmed().lower(element),                                                                    getCollection().lower(element));              assertEquals("Incorrect element returned by floor().", getConfirmed().floor(element),                                                                    getCollection().floor(element));              assertEquals("Incorrect element returned by ceiling().", getConfirmed().ceiling(element),                                                                      getCollection().ceiling(element));         }     }      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (E[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (E[]) elements;     }      //-----------------------------------------------------------------------     /**      * Bulk test {@link NavigableSet#subSet(Object, boolean, Object, boolean)}.      * This method runs through all of the tests in {@link AbstractNavigableSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractNavigableSetTest} instance for testing a subset.      */     public BulkTest bulkTestNavigableSetSubSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestNavigableSetSubSet(lobound, hibound, false);     }      /**      * Bulk test {@link NavigableSet#headSet(Object, boolean)}.      * This method runs through all of the tests in {@link AbstractNavigableSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractNavigableSetTest} instance for testing a headset.      */     public BulkTest bulkTestNavigableSetHeadSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestNavigableSetSubSet(hibound, true, true);     }      /**      * Bulk test {@link NavigableSet#tailSet(Object, boolean)}.      * This method runs through all of the tests in {@link AbstractNavigableSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractNavigableSetTest} instance for testing a tailset.      */     public BulkTest bulkTestNavigableSetTailSet() {         final int length = getFullElements().length;         final int lobound = length / 3;         return new TestNavigableSetSubSet(lobound, false, false);     }      public class TestNavigableSetSubSet extends AbstractNavigableSetTest<E> {          private int m_Type;         private int m_LowBound;         private int m_HighBound;         private E[] m_FullElements;         private E[] m_OtherElements;         private boolean m_Inclusive;          @SuppressWarnings("unchecked")         public TestNavigableSetSubSet(final int bound, final boolean head, final boolean inclusive) {             super("TestNavigableSetSubSet");             if (head) {                 m_Type = TYPE_HEADSET;                 m_Inclusive = inclusive;                 m_HighBound = bound;                  final int realBound = inclusive ? bound + 1 : bound;                 m_FullElements = (E[]) new Object[realBound];                 System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), 0, m_FullElements, 0, realBound);                 m_OtherElements = (E[]) new Object[bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractNavigableSetTest.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);             } else {                 m_Type = TYPE_TAILSET;                 m_Inclusive = inclusive;                 m_LowBound = bound;                 final Object[] allelements = AbstractNavigableSetTest.this.getFullElements();                 final int realBound = inclusive ? bound : bound + 1;                 m_FullElements = (E[]) new Object[allelements.length - realBound];                 System.arraycopy(allelements, realBound, m_FullElements, 0, allelements.length - realBound);                 m_OtherElements = (E[]) new Object[allelements.length - bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractNavigableSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);             }          } //type          @SuppressWarnings("unchecked")         public TestNavigableSetSubSet(final int lobound, final int hibound, final boolean inclusive) {             super("TestNavigableSetSubSet");             m_Type = TYPE_SUBSET;             m_LowBound = lobound;             m_HighBound = hibound;             m_Inclusive = inclusive;              final int fullLoBound = inclusive ? lobound : lobound + 1;             final int length = hibound - lobound + 1 - (inclusive ? 0 : 2);             m_FullElements = (E[]) new Object[length];             System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, m_FullElements, 0, length);             final int otherLength = hibound - lobound;             m_OtherElements = (E[]) new Object[otherLength - 1];             System.arraycopy(//src src_pos dst dst_pos length                 AbstractNavigableSetTest.this.getOtherElements(), lobound, m_OtherElements, 0, otherLength - 1);         }          @Override         public boolean isNullSupported() {             return AbstractNavigableSetTest.this.isNullSupported();         }         @Override         public boolean isAddSupported() {             return AbstractNavigableSetTest.this.isAddSupported();         }         @Override         public boolean isRemoveSupported() {             return AbstractNavigableSetTest.this.isRemoveSupported();         }         @Override         public boolean isFailFastSupported() {             return AbstractNavigableSetTest.this.isFailFastSupported();         }          @Override         public E[] getFullElements() {             return m_FullElements;         }         @Override         public E[] getOtherElements() {             return m_OtherElements;         }          private NavigableSet<E> getSubSet(final NavigableSet<E> set) {             final E[] elements = AbstractNavigableSetTest.this.getFullElements();             switch (m_Type) {             case TYPE_SUBSET :                 return set.subSet(elements[m_LowBound], m_Inclusive, elements[m_HighBound], m_Inclusive);             case TYPE_HEADSET :                 return set.headSet(elements[m_HighBound], m_Inclusive);             case TYPE_TAILSET :                 return set.tailSet(elements[m_LowBound], m_Inclusive);             default :                 return null;             }         }          @Override         public NavigableSet<E> makeObject() {             return getSubSet(AbstractNavigableSetTest.this.makeObject());         }          @Override         public NavigableSet<E> makeFullCollection() {             return getSubSet(AbstractNavigableSetTest.this.makeFullCollection());         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public BulkTest bulkTestSortedSetSubSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetHeadSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetTailSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestNavigableSetSubSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestNavigableSetHeadSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestNavigableSetTailSet() {             return null;  // prevent infinite recursion         }          static final int TYPE_SUBSET = 0;         static final int TYPE_TAILSET = 1;         static final int TYPE_HEADSET = 2;      }      /**      * {@inheritDoc}      */     @Override     public NavigableSet<E> getCollection() {         return (NavigableSet<E>) super.getCollection();     }      /**      * {@inheritDoc}      */     @Override     public NavigableSet<E> getConfirmed() {         return (NavigableSet<E>) super.getConfirmed();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.HashSet; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link UnmodifiableSet} implementation.  *  * @since 3.0  */ public class UnmodifiableSetTest<E> extends AbstractSetTest<E> {      public UnmodifiableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSetTest.class);     }      //-------------------------------------------------------------------     @Override     public Set<E> makeObject() {         return UnmodifiableSet.unmodifiableSet(new HashSet<E>());     }      @Override     public Set<E> makeFullCollection() {         final HashSet<E> set = new HashSet<>(Arrays.asList(getFullElements()));         return UnmodifiableSet.unmodifiableSet(set);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Set<E> set = makeFullCollection();         assertSame(set, UnmodifiableSet.unmodifiableSet(set));          try {             UnmodifiableSet.unmodifiableSet(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Abstract test class for {@link Set} methods and contracts.  * <p>  * Since {@link Set} doesn't stipulate much new behavior that isn't already  * found in {@link Collection}, this class basically just adds tests for  * {@link Set#equals} and {@link Set#hashCode()} along with an updated  * {@link #verify()} that ensures elements do not appear more than once in the  * set.  * <p>  * To use, subclass and override the {@link #makeObject()}  * method.  You may have to override other protected methods if your  * set is not modifiable, or if your set restricts what kinds of  * elements may be added; see {@link AbstractCollectionTest} for more details.  *  * @since 3.0  */ public abstract class AbstractSetTest<E> extends AbstractCollectionTest<E> {      /**      * JUnit constructor.      *      * @param name  name for test      */     public AbstractSetTest(final String name) {         super(name);     }      //-----------------------------------------------------------------------     /**      * Provides additional verifications for sets.      */     @Override     public void verify() {         super.verify();          assertEquals("Sets should be equal", getConfirmed(), getCollection());         assertEquals("Sets should have equal hashCodes",                      getConfirmed().hashCode(), getCollection().hashCode());         final Collection<E> set = makeConfirmedCollection();         for (final E element : getCollection()) {             assertTrue("Set.iterator should only return unique elements", set.add(element));         }     }      //-----------------------------------------------------------------------     /**      * Set equals method is defined.      */     @Override     public boolean isEqualsCheckable() {         return true;     }      /**      * Returns an empty Set for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public Collection<E> makeConfirmedCollection() {         return new HashSet<>();     }      /**      * Returns a full Set for use in modification testing.      *      * @return a confirmed full collection      */     @Override     public Collection<E> makeConfirmedFullCollection() {         final Collection<E> set = makeConfirmedCollection();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      /**      * Makes an empty set.  The returned set should have no elements.      *      * @return an empty set      */     @Override     public abstract Set<E> makeObject();      /**      * Makes a full set by first creating an empty set and then adding      * all the elements returned by {@link #getFullElements()}.      *      * Override if your set does not support the add operation.      *      * @return a full set      */     @Override     public Set<E> makeFullCollection() {         final Set<E> set = makeObject();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      //-----------------------------------------------------------------------     /**      * Return the {@link AbstractCollectionTest#collection} fixture, but cast as a Set.      */     @Override     public Set<E> getCollection() {         return (Set<E>) super.getCollection();     }      /**      * Return the {@link AbstractCollectionTest#confirmed} fixture, but cast as a Set.      */     @Override     public Set<E> getConfirmed() {         return (Set<E>) super.getConfirmed();     }      //-----------------------------------------------------------------------     /**      * Tests {@link Set#equals(Object)}.      */     @SuppressWarnings("unchecked")     public void testSetEquals() {         resetEmpty();         assertEquals("Empty sets should be equal", getCollection(), getConfirmed());         verify();          final Collection<E> set2 = makeConfirmedCollection();         set2.add((E) "foo");         assertTrue("Empty set shouldn't equal nonempty set", !getCollection().equals(set2));          resetFull();         assertEquals("Full sets should be equal", getCollection(), getConfirmed());         verify();          set2.clear();         set2.addAll(Arrays.asList(getOtherElements()));         assertTrue("Sets with different contents shouldn't be equal", !getCollection().equals(set2));     }      /**      * Tests {@link Set#hashCode()}.      */     public void testSetHashCode() {         resetEmpty();         assertEquals("Empty sets have equal hashCodes",                 getCollection().hashCode(), getConfirmed().hashCode());          resetFull();         assertEquals("Equal sets have equal hashCodes",                 getCollection().hashCode(), getConfirmed().hashCode());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Iterator; import java.util.List;  /**  * Extension of {@link AbstractSetTest} for exercising the {@link ListOrderedSet}  * implementation.  *  * @since 3.1  */ public class ListOrderedSet2Test<E> extends AbstractSetTest<E> {      private static final Integer ZERO = Integer.valueOf(0);     private static final Integer ONE = Integer.valueOf(1);     private static final Integer TWO = Integer.valueOf(2);     private static final Integer THREE = Integer.valueOf(3);      public ListOrderedSet2Test(final String testName) {         super(testName);     }      @Override     public ListOrderedSet<E> makeObject() {         return new ListOrderedSet<>();     }      @SuppressWarnings("unchecked")     protected ListOrderedSet<E> setupSet() {         final ListOrderedSet<E> set = makeObject();          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }         return set;     }      @SuppressWarnings("unchecked")     public void testOrdering() {         final ListOrderedSet<E> set = setupSet();         Iterator<E> it = set.iterator();          for (int i = 0; i < 10; i++) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i += 2) {             assertTrue("Must be able to remove int", set.remove(Integer.toString(i)));         }          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong after remove ", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }          assertEquals("Size of set is wrong!", 10, set.size());          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }         for (int i = 0; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }     }      @SuppressWarnings("unchecked")     public void testListAddRemove() {         final ListOrderedSet<E> set = makeObject();         final List<E> view = set.asList();         set.add((E) ZERO);         set.add((E) ONE);         set.add((E) TWO);          assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));         assertEquals(3, view.size());         assertSame(ZERO, view.get(0));         assertSame(ONE, view.get(1));         assertSame(TWO, view.get(2));          assertEquals(0, set.indexOf(ZERO));         assertEquals(1, set.indexOf(ONE));         assertEquals(2, set.indexOf(TWO));          set.remove(1);         assertEquals(2, set.size());         assertSame(ZERO, set.get(0));         assertSame(TWO, set.get(1));         assertEquals(2, view.size());         assertSame(ZERO, view.get(0));         assertSame(TWO, view.get(1));     }      @SuppressWarnings("unchecked")     public void testListAddIndexed() {         final ListOrderedSet<E> set = makeObject();         set.add((E) ZERO);         set.add((E) TWO);          set.add(1, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          set.add(0, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          final List<E> list = new ArrayList<>();         list.add((E) ZERO);         list.add((E) TWO);          set.addAll(0, list);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          list.add(0, (E) THREE); // list = [3,0,2]         set.remove(TWO);    //  set = [0,1]         set.addAll(1, list);         assertEquals(4, set.size());         assertSame(ZERO, set.get(0));         assertSame(THREE, set.get(1));         assertSame(TWO, set.get(2));         assertSame(ONE, set.get(3));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) collection, "D:/dev/collections/data/test/ListOrderedSet.emptyCollection.version3.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) collection, "D:/dev/collections/data/test/ListOrderedSet.fullCollection.version3.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collections; import java.util.NavigableSet; import java.util.TreeSet; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractNavigableSetTest} for exercising the  * {@link TransformedNavigableSet} implementation.  *  * @since 4.1  */ public class TransformedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {      public TransformedNavigableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedNavigableSetTest.class);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public NavigableSet<E> makeObject() {         return TransformedNavigableSet.transformingNavigableSet(new TreeSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public NavigableSet<E> makeFullCollection() {         final NavigableSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return TransformedNavigableSet.transformingNavigableSet(set,                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testTransformedSet() {         final NavigableSet<E> set = TransformedNavigableSet.transformingNavigableSet(new TreeSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, set.size());         final E[] els = (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < els.length; i++) {             set.add(els[i]);             assertEquals(i + 1, set.size());             assertEquals(true, set.contains(Integer.valueOf((String) els[i])));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      public void testTransformedSet_decorateTransform() {         final Set<Object> originalSet = new TreeSet<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalSet, els);         final Set<?> set = TransformedSet.transformedSet(originalSet,                 TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, set.size());         for (final Object el : els) {             assertEquals(true, set.contains(Integer.valueOf((String) el)));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedNavigableSet.emptyCollection.version4.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedNavigableSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Closure; import org.junit.Assert; import org.junit.Test;  public abstract class AbstractClosureTest {      @Test     public void closureSanityTests() throws Exception {         final Closure<?> closure = generateClosure();         Assert.assertNotNull(closure);     }      /**      * @return a closure for general sanity tests.      */     protected abstract <T> Closure<T> generateClosure(); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import static org.apache.commons.collections4.functors.ComparatorPredicate.*;  import java.util.Comparator;  import org.apache.commons.collections4.Predicate; import org.junit.Test;   public class ComparatorPredicateTest extends AbstractPredicateTest {     private class TestComparator<T extends Comparable<T>> implements Comparator<T> {         @Override         public int compare(final T first, final T second) {             return first.compareTo(second);         }     }      @Test     public void compareEquals() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());         assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));         assertPredicateTrue(p, Integer.valueOf(value.intValue()));         assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareGreater() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);         assertPredicateTrue(p, Integer.valueOf(value.intValue() - 1));         assertPredicateFalse(p, Integer.valueOf(value.intValue()));         assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareLess() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);         assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));         assertPredicateFalse(p, Integer.valueOf(value.intValue()));         assertPredicateTrue(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareGreaterOrEqual() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);         assertPredicateTrue(p, Integer.valueOf(value.intValue() - 1));         assertPredicateTrue(p, Integer.valueOf(value.intValue()));         assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareLessOrEqual() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);         assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));         assertPredicateTrue(p, Integer.valueOf(value.intValue()));         assertPredicateTrue(p, Integer.valueOf(value.intValue() + 1));     }      @Override     protected Predicate<?> generatePredicate() {         return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List;  import org.apache.commons.collections4.Predicate; import org.junit.Assert; import org.junit.Test;  /**  * Base class for tests of composite predicates.  *  * @since 3.0  */ public abstract class AbstractCompositePredicateTest<T> extends AbstractMockPredicateTest<T> {      /**      * Creates a new {@code TestCompositePredicate}.      *      * @param testValue the value which the mock predicates should expect to see (may be null).      */     protected AbstractCompositePredicateTest(final T testValue) {         super(testValue);     }      /**      * Creates an instance of the predicate to test.      *      * @param predicates the arguments to {@code getInstance}.      *      * @return a predicate to test.      */     protected abstract Predicate<T> getPredicateInstance(Predicate<? super T>... predicates);      /**      * Creates an instance of the predicate to test.      *      * @param predicates the argument to {@code getInstance}.      *      * @return a predicate to test.      */     protected abstract Predicate<T> getPredicateInstance(Collection<Predicate<T>> predicates);      /**      * Creates an instance of the predicate to test.      *      * @param mockReturnValues the return values for the mock predicates, or null if that mock is not expected      *                         to be called      *      * @return a predicate to test.      */     protected final Predicate<T> getPredicateInstance(final Boolean... mockReturnValues) {         final List<Predicate<T>> predicates = new ArrayList<>();         for (final Boolean returnValue : mockReturnValues) {             predicates.add(createMockPredicate(returnValue));         }         return getPredicateInstance(predicates);     }      /**      * Tests whether {@code getInstance} with a one element array returns the first element in the array.      */     @SuppressWarnings("unchecked")     public void singleElementArrayToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(predicate);         Assert.assertSame("expected argument to be returned by getInstance()", predicate, allPredicate);     }      /**      * Tests that passing a singleton collection to {@code getInstance} returns the single element in the      * collection.      */     public void singletonCollectionToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(                 Collections.<Predicate<T>>singleton(predicate));         Assert.assertSame("expected argument to be returned by getInstance()", predicate, allPredicate);     }      /**      * Tests {@code getInstance} with a null predicate array.      */     @Test(expected = NullPointerException.class)     public final void nullArrayToGetInstance() {         getPredicateInstance((Predicate<T>[]) null);     }      /**      * Tests {@code getInstance} with a single null element in the predicate array.      */     @SuppressWarnings({"unchecked"})     @Test(expected = NullPointerException.class)     public final void nullElementInArrayToGetInstance() {         getPredicateInstance(new Predicate[] { null });     }      /**      * Tests {@code getInstance} with two null elements in the predicate array.      */     @SuppressWarnings({"unchecked"})     @Test(expected = NullPointerException.class)     public final void nullElementsInArrayToGetInstance() {         getPredicateInstance(new Predicate[] { null, null });     }       /**      * Tests {@code getInstance} with a null predicate collection      */     @Test(expected = NullPointerException.class)     public final void nullCollectionToGetInstance() {         getPredicateInstance((Collection<Predicate<T>>) null);     }      /**      * Tests {@code getInstance} with a predicate collection that contains null elements      */     @Test(expected = NullPointerException.class)     public final void nullElementsInCollectionToGetInstance() {         final Collection<Predicate<T>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         getPredicateInstance(coll);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Predicate;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import org.junit.Test;  import java.util.Collections;  /**  * Base class for tests of AnyPredicate, AllPredicate, and OnePredicate.  *  * @since 3.0  */ public abstract class AbstractAnyAllOnePredicateTest<T> extends AbstractCompositePredicateTest<T> {      /**      * Creates a new {@code TestCompositePredicate}.      *      * @param testValue the value which the mock predicates should expect to see (may be null).      */     protected AbstractAnyAllOnePredicateTest(final T testValue) {         super(testValue);     }      /**      * Tests whether {@code getInstance} with a one element array returns the first element in the array.      */     @Override     @SuppressWarnings("unchecked")     @Test     public final void singleElementArrayToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(predicate);         assertSame("expected argument to be returned by getInstance()", predicate, allPredicate);     }      /**      * Tests that passing a singleton collection to {@code getInstance} returns the single element in the      * collection.      */     @Override     @Test     public final void singletonCollectionToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(                 Collections.<Predicate<T>>singleton(predicate));         assertSame("expected singleton collection member to be returned by getInstance()",                 predicate, allPredicate);     }      /**      * Tests creating composite predicate instances with single predicates and verifies that the composite returns      * the same value as the single predicate does.      */     @SuppressWarnings("boxing")     public final void singleValues() {         assertTrue(getPredicateInstance(true).evaluate(null));         assertFalse(getPredicateInstance(false).evaluate(null));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate; import static org.junit.Assert.assertSame;  import org.apache.commons.collections4.Predicate; import org.junit.Test;  public class NullPredicateTest extends AbstractPredicateTest {     @Test     public void testNullPredicate() {         assertSame(NullPredicate.nullPredicate(), NullPredicate.nullPredicate());         assertPredicateTrue(nullPredicate(), null);     }      @Test     public void ensurePredicateCanBeTypedWithoutWarning() throws Exception {         final Predicate<String> predicate = NullPredicate.nullPredicate();         assertPredicateFalse(predicate, cString);     }      @Override     protected Predicate<?> generatePredicate() {         return nullPredicate();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import java.util.ArrayList; import java.util.List;  import static org.easymock.EasyMock.verify; import static org.easymock.EasyMock.replay; import org.junit.Before; import org.junit.After; import org.apache.commons.collections4.Predicate; import org.easymock.EasyMock;  /**  * Base class for tests of predicates which delegate to other predicates when evaluating an object.  This class  * provides methods to create and verify mock predicates to which to delegate.  *  * @since 3.0  */ public abstract class AbstractMockPredicateTest<T> {     /**      * Mock predicates created by a single test case which need to be verified after the test completes.      */     private List<Predicate<? super T>> mockPredicatesToVerify;      /**      * The value to pass to mocks.      */     private final T testValue;      /**      * Creates a new {@code PredicateTestBase}.      *      * @param testValue the value to pass to mock predicates.      */     protected AbstractMockPredicateTest(final T testValue) {         this.testValue = testValue;     }      /**      * Creates the list of predicates to verify.      */     @Before     public final void createVerifyList() {         mockPredicatesToVerify = new ArrayList<>();     }      /**      * Verifies all the mock predicates created for the test.      */     @After     public final void verifyPredicates() {         for (final Predicate<? super T> predicate : mockPredicatesToVerify) {             verify(predicate);         }     }      /**      * Gets the value which will be passed to the mock predicates.      *      * @return the test value.      */     protected final T getTestValue() {         return testValue;     }      /**      * Creates a single mock predicate.      *      * @param returnValue the return value for the mock predicate, or null if the mock is not expected to be called.      *      * @return a single mock predicate.      */     @SuppressWarnings({"boxing"})     protected final Predicate<T> createMockPredicate(final Boolean returnValue) {         final Predicate<T> mockPredicate = EasyMock.createMock(Predicate.class);         if (returnValue != null) {             EasyMock.expect(mockPredicate.evaluate(testValue)).andReturn(returnValue);         }         replay(mockPredicate);         mockPredicatesToVerify.add(mockPredicate);          return mockPredicate;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate; import static org.junit.Assert.assertSame;  import org.apache.commons.collections4.Predicate; import org.junit.Test;   public class EqualPredicateTest extends AbstractPredicateTest {     private static final EqualsTestObject FALSE_OBJECT = new EqualsTestObject(false);     private static final EqualsTestObject TRUE_OBJECT = new EqualsTestObject(true);      @Override     protected Predicate<Object> generatePredicate() {         return equalPredicate(null);     }      @Test     public void testNullArgumentEqualsNullPredicate() throws Exception {         assertSame(nullPredicate(), equalPredicate(null));     }      @Test     public void objectFactoryUsesEqualsForTest() throws Exception {         final Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);         assertPredicateFalse(predicate, FALSE_OBJECT);         assertPredicateTrue(equalPredicate(TRUE_OBJECT), TRUE_OBJECT);     }      @SuppressWarnings("boxing")     @Test     public void testPredicateTypeCanBeSuperClassOfObject() throws Exception {         final Predicate<Number> predicate = equalPredicate((Number) 4);         assertPredicateTrue(predicate, 4);     }      public static class EqualsTestObject {         private final boolean b;          public EqualsTestObject(final boolean b) {             this.b = b;         }          @Override         public boolean equals(final Object obj) {             return b;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import java.io.IOException;  import org.apache.commons.collections4.Closure; import org.apache.commons.collections4.FunctorException; import org.junit.Assert; import org.junit.Test;  public class CatchAndRethrowClosureTest extends AbstractClosureTest {      private static <T> Closure<T> generateIOExceptionClosure() {         return new CatchAndRethrowClosure<T>() {              @Override             protected void executeAndThrow(final T input) throws IOException  {                 throw new IOException();             }         };     }      private static <T> Closure<T> generateNullPointerExceptionClosure() {         return new CatchAndRethrowClosure<T>() {              @Override             protected void executeAndThrow(final T input) {                 throw new NullPointerException();             }         };     }      private static <T> Closure<T> generateNoExceptionClosure() {         return new CatchAndRethrowClosure<T>() {              @Override             protected void executeAndThrow(final T input) {             }         };     }      @Override     protected <T> Closure<T> generateClosure() {         return generateNoExceptionClosure();     }      @Test     public void testThrowingClosure() {         Closure<Integer> closure = generateNoExceptionClosure();         try {             closure.execute(Integer.valueOf(0));         } catch (final FunctorException ex) {             Assert.fail();         } catch (final RuntimeException ex) {             Assert.fail();         }          closure = generateIOExceptionClosure();         try {             closure.execute(Integer.valueOf(0));             Assert.fail();         } catch (final FunctorException ex) {             Assert.assertTrue(ex.getCause() instanceof IOException);         } catch (final RuntimeException ex) {             Assert.fail();         }          closure = generateNullPointerExceptionClosure();         try {             closure.execute(Integer.valueOf(0));             Assert.fail();         } catch (final FunctorException ex) {             Assert.fail();         } catch (final RuntimeException ex) {             Assert.assertTrue(ex instanceof NullPointerException);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Predicate;  import static org.apache.commons.collections4.functors.AllPredicate.allPredicate; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import org.junit.Test;  import java.util.Collection; import java.util.Collections;  /**  * Tests the org.apache.commons.collections.functors.AllPredicate class.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class AllPredicateTest extends AbstractAnyAllOnePredicateTest<Integer> {      /**      * Creates a new {@code TestAllPredicate}.      */     public AllPredicateTest() {         super(42);     }      /**      * {@inheritDoc}      */     @Override     protected final Predicate<Integer> getPredicateInstance(final Predicate<? super Integer>... predicates) {         return AllPredicate.allPredicate(predicates);     }      /**      * {@inheritDoc}      */     @Override     protected final Predicate<Integer> getPredicateInstance(final Collection<Predicate<Integer>> predicates) {         return AllPredicate.allPredicate(predicates);     }      /**      * Verifies that providing an empty predicate array evaluates to true.      */     @SuppressWarnings({"unchecked"})     @Test     public void emptyArrayToGetInstance() {         assertTrue("empty array not true", getPredicateInstance(new Predicate[] {}).evaluate(null));     }      /**      * Verifies that providing an empty predicate collection evaluates to true.      */     @Test     public void emptyCollectionToGetInstance() {         final Predicate<Integer> allPredicate = getPredicateInstance(                 Collections.<Predicate<Integer>>emptyList());         assertTrue("empty collection not true", allPredicate.evaluate(getTestValue()));     }      /**      * Tests whether a single true predicate evaluates to true.      */     @SuppressWarnings("unchecked")     @Test     public void oneTruePredicate() {         // use the constructor directly, as getInstance() returns the original predicate when passed         // an array of size one.         final Predicate<Integer> predicate = createMockPredicate(true);          assertTrue("single true predicate evaluated to false",                 allPredicate(predicate).evaluate(getTestValue()));     }      /**      * Tests whether a single false predicate evaluates to true.      */     @SuppressWarnings("unchecked")     @Test     public void oneFalsePredicate() {         // use the constructor directly, as getInstance() returns the original predicate when passed         // an array of size one.         final Predicate<Integer> predicate = createMockPredicate(false);         assertFalse("single false predicate evaluated to true",                 allPredicate(predicate).evaluate(getTestValue()));     }      /**      * Tests whether multiple true predicates evaluates to true.      */     @Test     public void allTrue() {         assertTrue("multiple true predicates evaluated to false",                 getPredicateInstance(true, true).evaluate(getTestValue()));         assertTrue("multiple true predicates evaluated to false",                 getPredicateInstance(true, true, true).evaluate(getTestValue()));     }      /**      * Tests whether combining some true and one false evaluates to false.  Also verifies that only the first      * false predicate is actually evaluated      */     @Test     public void trueAndFalseCombined() {         assertFalse("false predicate evaluated to true",                 getPredicateInstance(false, null).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(false, null, null).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(true, false, null).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(true, true, false).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(true, true, false, null).evaluate(getTestValue()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Predicate; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public abstract class AbstractPredicateTest {     protected Object cObject;     protected String cString;     protected Integer cInteger;      @Before     public void initializeTestObjects() throws Exception {         cObject = new Object();         cString = "Hello";         cInteger = Integer.valueOf(6);     }      @Test     public void predicateSanityTests() throws Exception {         final Predicate<?> predicate = generatePredicate();         Assert.assertNotNull(predicate);     }      /**      * @return a predicate for general sanity tests.      */     protected abstract Predicate<?> generatePredicate();      protected <T> void assertPredicateFalse(final Predicate<T> predicate, final T testObject) {         Assert.assertFalse(predicate.evaluate(testObject));     }      protected <T> void assertPredicateTrue(final Predicate<T> predicate, final T testObject) {         Assert.assertTrue(predicate.evaluate(testObject));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.apache.commons.collections4.functors.TruePredicate.INSTANCE; import static org.easymock.EasyMock.createMock; import static org.easymock.EasyMock.expect; import static org.easymock.EasyMock.replay; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.ListIterator; import java.util.Map; import java.util.NoSuchElementException; import java.util.Vector; import java.util.Dictionary; import java.util.Enumeration; import java.util.Set; import java.util.LinkedHashSet;  import org.apache.commons.collections4.iterators.*; import org.apache.commons.collections4.map.EntrySetToMapIteratorAdapter; import org.junit.Before; import org.junit.Test; import org.w3c.dom.Node; import org.w3c.dom.NodeList;  /**  * Tests for IteratorUtils.  */ public class IteratorUtilsTest {      /**      * Collection of {@link Integer}s      */     private List<Integer> collectionA = null;      /**      * Collection of even {@link Integer}s      */     private List<Integer> collectionEven = null;      /**      * Collection of odd {@link Integer}s      */     private List<Integer> collectionOdd = null;      private final Collection<Integer> emptyCollection = new ArrayList<>(1);      private Iterable<Integer> iterableA = null;      /**      * Creates a NodeList containing the specified nodes.      */     private NodeList createNodeList(final Node[] nodes) {         return new NodeList() {             @Override             public int getLength() {                 return nodes.length;             }              @Override             public Node item(final int index) {                 return nodes[index];             }         };     }      /**      * creates an array of four Node instances, mocked by EasyMock.      */     private Node[] createNodes() {         final Node node1 = createMock(Node.class);         final Node node2 = createMock(Node.class);         final Node node3 = createMock(Node.class);         final Node node4 = createMock(Node.class);         replay(node1);         replay(node2);         replay(node3);         replay(node4);          return new Node[] { node1, node2, node3, node4 };     }      /**      * Gets an immutable Iterator operating on the elements ["a", "b", "c", "d"].      */     private Iterator<String> getImmutableIterator() {         final List<String> list = new ArrayList<>();         list.add("a");         list.add("b");         list.add("c");         list.add("d");         return IteratorUtils.unmodifiableIterator(list.iterator());     }      /**      * Gets an immutable ListIterator operating on the elements ["a", "b", "c", "d"].      */     private ListIterator<String> getImmutableListIterator() {         final List<String> list = new ArrayList<>();         list.add("a");         list.add("b");         list.add("c");         list.add("d");         return IteratorUtils.unmodifiableListIterator(list.listIterator());     }      @Before     public void setUp() {         collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);          iterableA = collectionA;          collectionEven = Arrays.asList(2, 4, 6, 8, 10, 12);         collectionOdd = Arrays.asList(1, 3, 5, 7, 9, 11);     }      @Test     public void testArrayIterator() {         final Object[] objArray = { "a", "b", "c" };         ResettableIterator<Object> iterator = IteratorUtils.arrayIterator(objArray);         assertEquals("a", iterator.next());         assertEquals("b", iterator.next());         iterator.reset();         assertEquals("a", iterator.next());          try {             iterator = IteratorUtils.arrayIterator(Integer.valueOf(0));             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator((Object[]) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(objArray, 1);         assertEquals("b", iterator.next());          try {             iterator = IteratorUtils.arrayIterator(objArray, -1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(objArray, 3);         assertFalse(iterator.hasNext());         iterator.reset();          try {             iterator = IteratorUtils.arrayIterator(objArray, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(objArray, 2, 3);         assertEquals("c", iterator.next());          try {             iterator = IteratorUtils.arrayIterator(objArray, 2, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(objArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(objArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          final int[] intArray = { 0, 1, 2 };         iterator = IteratorUtils.arrayIterator(intArray);         assertEquals(0, iterator.next());         assertEquals(1, iterator.next());         iterator.reset();         assertEquals(0, iterator.next());          iterator = IteratorUtils.arrayIterator(intArray, 1);         assertEquals(1, iterator.next());          try {             iterator = IteratorUtils.arrayIterator(intArray, -1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(intArray, 3);         assertFalse(iterator.hasNext());         iterator.reset();          try {             iterator = IteratorUtils.arrayIterator(intArray, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(intArray, 2, 3);         assertEquals(2, iterator.next());          try {             iterator = IteratorUtils.arrayIterator(intArray, 2, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(intArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(intArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }     }      @Test     public void testArrayListIterator() {         final Object[] objArray = { "a", "b", "c", "d" };         ResettableListIterator<Object> iterator = IteratorUtils.arrayListIterator(objArray);         assertFalse(iterator.hasPrevious());         assertEquals(-1, iterator.previousIndex());         assertEquals(0, iterator.nextIndex());         assertEquals("a", iterator.next());         assertEquals("a", iterator.previous());         assertEquals("a", iterator.next());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());         assertEquals("b", iterator.next());         assertEquals("c", iterator.next());         assertEquals("d", iterator.next());         assertEquals(4, iterator.nextIndex()); // size of list         assertEquals(3, iterator.previousIndex());          try {             iterator = IteratorUtils.arrayListIterator(Integer.valueOf(0));             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator((Object[]) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(objArray, 1);         assertEquals(-1, iterator.previousIndex());         assertFalse(iterator.hasPrevious());         assertEquals(0, iterator.nextIndex());         assertEquals("b", iterator.next());         assertEquals(0, iterator.previousIndex());          try {             iterator = IteratorUtils.arrayListIterator(objArray, -1);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(objArray, 3);         assertTrue(iterator.hasNext());         try {             iterator.previous();             fail("Expecting NoSuchElementException.");         } catch (final NoSuchElementException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(objArray, 5);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(objArray, 2, 3);         assertEquals("c", iterator.next());          try {             iterator = IteratorUtils.arrayListIterator(objArray, 2, 5);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(objArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(objArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          final int[] intArray = { 0, 1, 2 };         iterator = IteratorUtils.arrayListIterator(intArray);         assertEquals(iterator.previousIndex(), -1);         assertFalse(iterator.hasPrevious());         assertEquals(0, iterator.nextIndex());         assertEquals(0, iterator.next());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());         assertEquals(1, iterator.next());         assertEquals(1, iterator.previousIndex());         assertEquals(2, iterator.nextIndex());         assertEquals(1, iterator.previous());         assertEquals(1, iterator.next());          iterator = IteratorUtils.arrayListIterator(intArray, 1);         assertEquals(-1, iterator.previousIndex());         assertFalse(iterator.hasPrevious());         assertEquals(0, iterator.nextIndex());         assertEquals(1, iterator.next());         assertEquals(1, iterator.previous());         assertEquals(1, iterator.next());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());         assertEquals(2, iterator.next());         assertEquals(1, iterator.previousIndex());         assertEquals(2, iterator.nextIndex());         assertEquals(2, iterator.previous());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());          try {             iterator = IteratorUtils.arrayListIterator(intArray, -1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(intArray, 3);         assertFalse(iterator.hasNext());          try {             iterator = IteratorUtils.arrayListIterator(intArray, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(intArray, 2, 3);         assertFalse(iterator.hasPrevious());         assertEquals(-1, iterator.previousIndex());         assertEquals(2, iterator.next());         assertTrue(iterator.hasPrevious());         assertFalse(iterator.hasNext());          try {             iterator = IteratorUtils.arrayListIterator(intArray, 2, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(intArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(intArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }     }      @Test(expected = NullPointerException.class)     public void testAsEnumerationNull() {         IteratorUtils.asEnumeration(null);     }      @Test     public void testAsIterable() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iterator = list.iterator();          final Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);         int expected = 0;         for (final Integer actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         // insure iteration occurred         assertTrue(expected > 0);          // single use iterator         assertFalse("should not be able to iterate twice", IteratorUtils.asIterable(iterator).iterator().hasNext());     }      @Test     public void testAsIterableNull() {         try {             IteratorUtils.asIterable(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test(expected = NullPointerException.class)     public void testAsIterator() {         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         final Enumeration<String> en = vector.elements();         assertTrue("create instance fail", IteratorUtils.asIterator(en) instanceof Iterator);         IteratorUtils.asIterator(null);     }      @Test     public void testAsIteratorNull() {         final Collection coll = new ArrayList();         coll.add("test");         final Vector<String> vector = new Vector<>();         vector.addElement("test");         vector.addElement("one");         final Enumeration<String> en = vector.elements();         assertTrue("create instance fail", IteratorUtils.asIterator(en, coll) instanceof Iterator);         try {             IteratorUtils.asIterator(null, coll);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.asIterator(en, null);         } catch (final NullPointerException npe) {             //         }     }      @Test     public void testAsMultipleIterable() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iterator = list.iterator();          final Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);         int expected = 0;         for (final Integer actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         // insure iteration occurred         assertTrue(expected > 0);          // multiple use iterator         expected = 0;         for (final Integer actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         // insure iteration occurred         assertTrue(expected > 0);     }      @Test     public void testAsMultipleIterableNull() {         try {             IteratorUtils.asMultipleUseIterable(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testChainedIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.chainedIterator(ie) instanceof Iterator);         final Collection<Iterator<?>> coll = new ArrayList();         assertTrue("create instance fail", IteratorUtils.chainedIterator(coll) instanceof Iterator);      }      /**      * Tests methods collatedIterator(...)      */     @Test     public void testCollatedIterator() {         try {             IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             IteratorUtils.collatedIterator(null, null, collectionEven.iterator());             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          // natural ordering         Iterator<Integer> it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(),                 collectionEven.iterator());          List<Integer> result = IteratorUtils.toList(it);         assertEquals(12, result.size());          final List<Integer> combinedList = new ArrayList<>(collectionOdd);         combinedList.addAll(collectionEven);         Collections.sort(combinedList);          assertEquals(combinedList, result);          it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());         result = IteratorUtils.toList(it);         assertEquals(collectionOdd, result);          final Comparator<Integer> reverseComparator = ComparatorUtils                 .reversedComparator(ComparatorUtils.<Integer>naturalComparator());          Collections.reverse(collectionOdd);         Collections.reverse(collectionEven);         Collections.reverse(combinedList);          it = IteratorUtils.collatedIterator(reverseComparator, collectionOdd.iterator(), collectionEven.iterator());         result = IteratorUtils.toList(it);         assertEquals(combinedList, result);     }      @Test(expected = NullPointerException.class)     public void testCollatedIteratorCollectionNull() {         final Collection<Iterator<?>> coll = new ArrayList<>();         coll.add(collectionOdd.iterator());         // natural ordering         final Iterator<?> it = IteratorUtils.collatedIterator(null, coll);         final List<?> result = IteratorUtils.toList(it);         assertEquals(6, result.size());         IteratorUtils.collatedIterator(null, (Collection<Iterator<?>>) null);     }      @Test(expected = NullPointerException.class)     public void testCollatedIteratorNull() {         final ArrayList arrayList = new ArrayList();         // natural ordering         Iterator<Integer> it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionOdd.iterator(),                 collectionOdd.iterator());          List<Integer> result = IteratorUtils.toList(it);         assertEquals(18, result.size());          it = IteratorUtils.collatedIterator(null, collectionOdd.iterator());         result = IteratorUtils.toList(it);         assertEquals(collectionOdd, result);          final Comparator<Integer> reverseComparator = ComparatorUtils                 .reversedComparator(ComparatorUtils.<Integer>naturalComparator());          Collections.reverse(collectionOdd);          it = IteratorUtils.collatedIterator(reverseComparator, collectionOdd.iterator());         result = IteratorUtils.toList(it);         assertEquals(collectionOdd, result);         IteratorUtils.collatedIterator(null, arrayList.iterator(), arrayList.listIterator(), null);     }      // -----------------------------------------------------------------------     /**      * Test empty iterator      */     @Test     public void testEmptyIterator() {         assertSame(EmptyIterator.INSTANCE, IteratorUtils.EMPTY_ITERATOR);         assertSame(EmptyIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_ITERATOR);         assertTrue(IteratorUtils.EMPTY_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof OrderedIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof MapIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR.hasNext());         IteratorUtils.EMPTY_ITERATOR.reset();         assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.EMPTY_ITERATOR);         assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.emptyIterator());         try {             IteratorUtils.EMPTY_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty list iterator      */     @Test     public void testEmptyListIterator() {         assertSame(EmptyListIterator.INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);         assertSame(EmptyListIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ListIterator);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableIterator);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableListIterator);         assertFalse(IteratorUtils.EMPTY_LIST_ITERATOR instanceof MapIterator);         assertFalse(IteratorUtils.EMPTY_LIST_ITERATOR.hasNext());         assertEquals(0, IteratorUtils.EMPTY_LIST_ITERATOR.nextIndex());         assertEquals(-1, IteratorUtils.EMPTY_LIST_ITERATOR.previousIndex());         IteratorUtils.EMPTY_LIST_ITERATOR.reset();         assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.EMPTY_LIST_ITERATOR);         assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.emptyListIterator());         try {             IteratorUtils.EMPTY_LIST_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_LIST_ITERATOR.previous();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_LIST_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.emptyListIterator().set(null);             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.emptyListIterator().add(null);             fail();         } catch (final UnsupportedOperationException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty map iterator      */     @Test     @SuppressWarnings("unchecked")     public void testEmptyMapIterator() {         assertSame(EmptyMapIterator.INSTANCE, IteratorUtils.EMPTY_MAP_ITERATOR);         assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof MapIterator);         assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedMapIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR.hasNext());         ((ResettableIterator<Object>) IteratorUtils.EMPTY_MAP_ITERATOR).reset();         assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.EMPTY_MAP_ITERATOR);         assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.emptyMapIterator());         try {             IteratorUtils.EMPTY_MAP_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.getKey();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.getValue();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.setValue(null);             fail();         } catch (final IllegalStateException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty map iterator      */     @Test     @SuppressWarnings("unchecked")     public void testEmptyOrderedIterator() {         assertSame(EmptyOrderedIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_ITERATOR);         assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof OrderedIterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof MapIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR.hasNext());         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR.hasPrevious());         ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_ITERATOR).reset();         assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.EMPTY_ORDERED_ITERATOR);         assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.emptyOrderedIterator());         try {             IteratorUtils.EMPTY_ORDERED_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_ITERATOR.previous();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty map iterator      */     @Test     @SuppressWarnings("unchecked")     public void testEmptyOrderedMapIterator() {         assertSame(EmptyOrderedMapIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof MapIterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof OrderedMapIterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasNext());         assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasPrevious());         ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR).reset();         assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);         assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.emptyOrderedMapIterator());         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.previous();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getKey();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getValue();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.setValue(null);             fail();         } catch (final IllegalStateException ex) {         }     }      @Test     public void testFilteredIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         try {             IteratorUtils.filteredIterator(ie, null);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.filteredIterator(null, null);         } catch (final NullPointerException npe) {             //         }     }      @Test     public void testFilteredListIterator() {         final List arrayList = new ArrayList();         arrayList.add("test");         final Predicate predicate = INSTANCE;         assertTrue("create instance fail",                 IteratorUtils.filteredListIterator(arrayList.listIterator(), predicate) instanceof ListIterator);         try {             IteratorUtils.filteredListIterator(null, predicate);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.filteredListIterator(arrayList.listIterator(), null);         } catch (final NullPointerException npe) {             //         }     }      @Test     public void testFind() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         Integer test = IteratorUtils.find(iterableA.iterator(), testPredicate);         assertEquals(4, (int) test);         testPredicate = equalPredicate((Number) 45);         test = IteratorUtils.find(iterableA.iterator(), testPredicate);         assertNull(test);         assertNull(IteratorUtils.find(null, testPredicate));         try {             assertNull(IteratorUtils.find(iterableA.iterator(), null));             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void testFirstFromIterator() throws Exception {         // Iterator, entry exists         final Iterator<Integer> iterator = iterableA.iterator();         assertEquals(1, (int) IteratorUtils.first(iterator));     }      // -----------------------------------------------------------------------     @Test     public void testForEach() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         IteratorUtils.forEach(col.iterator(), testClosure);         assertTrue(listA.isEmpty() && listB.isEmpty());         try {             IteratorUtils.forEach(col.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IteratorUtils.forEach(null, testClosure);          // null should be OK         col.add(null);         IteratorUtils.forEach(col.iterator(), testClosure);     }      @Test     public void testForEachButLast() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         List<Integer> last = IteratorUtils.forEachButLast(col.iterator(), testClosure);         assertTrue(listA.isEmpty() && !listB.isEmpty());         assertSame(listB, last);          try {             IteratorUtils.forEachButLast(col.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IteratorUtils.forEachButLast(null, testClosure);          // null should be OK         col.add(null);         col.add(null);         last = IteratorUtils.forEachButLast(col.iterator(), testClosure);         assertNull(last);     }      @Test     public void testGetAtIndexFromIterator() throws Exception {         // Iterator, entry exists         Iterator<Integer> iterator = iterableA.iterator();         assertEquals(1, (int) IteratorUtils.get(iterator, 0));         iterator = iterableA.iterator();         assertEquals(2, (int) IteratorUtils.get(iterator, 1));          // Iterator, non-existent entry         try {             IteratorUtils.get(iterator, 10);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertFalse(iterator.hasNext());     }      @Test     public void testGetIterator() {         final Object[] objArray = { "a", "b", "c" };         final Map<String, String> inMap = new HashMap<>();         final Node[] nodes = createNodes();         final NodeList nodeList = createNodeList(nodes);          assertTrue("returns empty iterator when null passed", IteratorUtils.getIterator(null) instanceof EmptyIterator);         assertTrue("returns Iterator when Iterator directly ",                 IteratorUtils.getIterator(iterableA.iterator()) instanceof Iterator);         assertTrue("returns Iterator when iterable passed", IteratorUtils.getIterator(iterableA) instanceof Iterator);         assertTrue("returns ObjectArrayIterator when Object array passed",                 IteratorUtils.getIterator(objArray) instanceof ObjectArrayIterator);         assertTrue("returns Iterator when Map passed", IteratorUtils.getIterator(inMap) instanceof Iterator);         assertTrue("returns NodeListIterator when nodeList passed",                 IteratorUtils.getIterator(nodeList) instanceof NodeListIterator);         assertTrue("returns EnumerationIterator when Enumeration passed",                 IteratorUtils.getIterator(new Vector().elements()) instanceof EnumerationIterator);         final Node node1 = createMock(Node.class);         assertTrue("returns NodeListIterator when nodeList passed",                 IteratorUtils.getIterator(node1) instanceof NodeListIterator);         final Dictionary dic = createMock(Dictionary.class);         assertTrue("returns EnumerationIterator when Dictionary passed",                 IteratorUtils.getIterator(dic) instanceof EnumerationIterator);         final int[] arr = new int[8];         assertTrue("returns ArrayIterator when array passed", IteratorUtils.getIterator(arr) instanceof ArrayIterator);     }      @Test     public void testIndexOf() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         int index = IteratorUtils.indexOf(iterableA.iterator(), testPredicate);         assertEquals(6, index);         testPredicate = equalPredicate((Number) 45);         index = IteratorUtils.indexOf(iterableA.iterator(), testPredicate);         assertEquals(-1, index);         assertEquals(-1, IteratorUtils.indexOf(null, testPredicate));         try {             IteratorUtils.indexOf(iterableA.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test(expected = NullPointerException.class)     public void testLoopingIterator() {         final ArrayList arrayList = new ArrayList();         arrayList.add("test");         final Collection coll = new ArrayList();         coll.add("test");         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.loopingIterator(coll) instanceof ResettableIterator);         IteratorUtils.loopingIterator(null);     }      @Test(expected = NullPointerException.class)     public void testLoopingListIterator() {         final ArrayList arrayList = new ArrayList();         arrayList.add("test");         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.loopingListIterator(arrayList) instanceof ResettableIterator);         IteratorUtils.loopingListIterator(null);     }      /**      * Tests method nodeListIterator(Node)      */     @Test     public void testNodeIterator() {         final Node[] nodes = createNodes();         final NodeList nodeList = createNodeList(nodes);         final Node parentNode = createMock(Node.class);         expect(parentNode.getChildNodes()).andStubReturn(nodeList);         replay(parentNode);          final Iterator<Node> iterator = IteratorUtils.nodeListIterator(parentNode);         int expectedNodeIndex = 0;         for (final Node actual : IteratorUtils.asIterable(iterator)) {             assertEquals(nodes[expectedNodeIndex], actual);             ++expectedNodeIndex;         }          // insure iteration occurred         assertTrue(expectedNodeIndex > 0);          // single use iterator         assertFalse("should not be able to iterate twice", IteratorUtils.asIterable(iterator).iterator().hasNext());          try {             IteratorUtils.nodeListIterator((Node) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      /**      * Tests method nodeListIterator(NodeList)      */     @Test     public void testNodeListIterator() {         final Node[] nodes = createNodes();         final NodeList nodeList = createNodeList(nodes);          final Iterator<Node> iterator = IteratorUtils.nodeListIterator(nodeList);         int expectedNodeIndex = 0;         for (final Node actual : IteratorUtils.asIterable(iterator)) {             assertEquals(nodes[expectedNodeIndex], actual);             ++expectedNodeIndex;         }          // insure iteration occurred         assertTrue(expectedNodeIndex > 0);          // single use iterator         assertFalse("should not be able to iterate twice", IteratorUtils.asIterable(iterator).iterator().hasNext());          try {             IteratorUtils.nodeListIterator((NodeList) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testObjectGraphIterator() {         assertTrue("create instance fail", IteratorUtils.objectGraphIterator(null, null) instanceof Iterator);     }      @Test(expected = NullPointerException.class)     public void testPeekingIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.peekingIterator(ie) instanceof Iterator);         IteratorUtils.peekingIterator(null);      }      @Test(expected = NullPointerException.class)     public void testPushBackIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.pushbackIterator(ie) instanceof Iterator);         IteratorUtils.pushbackIterator(null);     }      @Test     public void testSingletonIterator() {         assertTrue("create instance fail", IteratorUtils.singletonIterator(new Object()) instanceof ResettableIterator);     }      @Test     public void testSingletonListIterator() {         assertTrue("create instance fail", IteratorUtils.singletonListIterator(new Object()) instanceof Iterator);     }      @Test     public void testToArray() {         final List<Object> list = new ArrayList<>();         list.add(Integer.valueOf(1));         list.add("Two");         list.add(null);         final Object[] result = IteratorUtils.toArray(list.iterator());         assertEquals(list, Arrays.asList(result));          try {             IteratorUtils.toArray(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testToArray2() {         final List<String> list = new ArrayList<>();         list.add("One");         list.add("Two");         list.add(null);         final String[] result = IteratorUtils.toArray(list.iterator(), String.class);         assertEquals(list, Arrays.asList(result));          try {             IteratorUtils.toArray(list.iterator(), null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }          try {             IteratorUtils.toArray(null, String.class);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testToList() {         final List<Object> list = new ArrayList<>();         list.add(Integer.valueOf(1));         list.add("Two");         list.add(null);         final List<Object> result = IteratorUtils.toList(list.iterator());         assertEquals(list, result);         // add         try {             IteratorUtils.toList(null, 10);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }          try {             IteratorUtils.toList(list.iterator(), -1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // success         }      }      @Test     public void testToListIterator() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iterator = list.iterator();          final ListIterator<Integer> liItr = IteratorUtils.toListIterator(iterator);         int expected = 0;         while (liItr.hasNext()) {             assertEquals(expected, liItr.next().intValue());             ++expected;         }     }      @Test     public void testToListIteratorNull() {         try {             IteratorUtils.toListIterator(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testTransformedIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         try {             IteratorUtils.transformedIterator(ie, null);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.transformedIterator(null, null);         } catch (final NullPointerException npe) {             //         }     }      /**      * Test remove() for an immutable Iterator.      */     @Test     public void testUnmodifiableIteratorImmutability() {         final Iterator<String> iterator = getImmutableIterator();          try {             iterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          iterator.next();          try {             iterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }      }      // -----------------------------------------------------------------------     /**      * Test next() and hasNext() for an immutable Iterator.      */     @Test     public void testUnmodifiableIteratorIteration() {         final Iterator<String> iterator = getImmutableIterator();          assertTrue(iterator.hasNext());          assertEquals("a", iterator.next());          assertTrue(iterator.hasNext());          assertEquals("b", iterator.next());          assertTrue(iterator.hasNext());          assertEquals("c", iterator.next());          assertTrue(iterator.hasNext());          assertEquals("d", iterator.next());          assertFalse(iterator.hasNext());     }      /**      * Test remove() for an immutable ListIterator.      */     @Test     public void testUnmodifiableListIteratorImmutability() {         final ListIterator<String> listIterator = getImmutableListIterator();          try {             listIterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.set("a");             // We shouldn't get to here.             fail("set(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.add("a");             // We shouldn't get to here.             fail("add(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          listIterator.next();          try {             listIterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.set("a");             // We shouldn't get to here.             fail("set(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.add("a");             // We shouldn't get to here.             fail("add(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }     }      /**      * Test next(), hasNext(), previous() and hasPrevious() for an immutable ListIterator.      */     @Test     public void testUnmodifiableListIteratorIteration() {         final ListIterator<String> listIterator = getImmutableListIterator();          assertFalse(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("a", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("b", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("c", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("d", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertFalse(listIterator.hasNext());          assertEquals("d", listIterator.previous());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("c", listIterator.previous());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("b", listIterator.previous());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("a", listIterator.previous());          assertFalse(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());     }      @Test(expected = NullPointerException.class)     public void testUnmodifiableMapIterator() {         final Set<?> set = new LinkedHashSet<>();         final MapIterator ie = new EntrySetToMapIteratorAdapter(set);         assertTrue("create instance fail", IteratorUtils.unmodifiableMapIterator(ie) instanceof MapIterator);         IteratorUtils.unmodifiableMapIterator(null);      }      @Test     public void testZippingIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.zippingIterator(ie, ie, ie) instanceof ZippingIterator);         assertTrue("create instance fail", IteratorUtils.zippingIterator(ie, ie) instanceof ZippingIterator);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Arrays; import java.util.List;  import junit.framework.TestCase; import junit.framework.TestSuite;  /**  * A {@link TestCase} that can define both simple and bulk test methods.  * <p>  * A <I>simple test method</I> is the type of test traditionally  * supplied by by {@link TestCase}.  To define a simple test, create a public  * no-argument method whose name starts with "test".  You can specify the  * the name of simple test in the constructor of {@code BulkTest};  * a subsequent call to {@link TestCase#run} will run that simple test.  * <p>  * A <I>bulk test method</I>, on the other hand, returns a new instance  * of {@code BulkTest}, which can itself define new simple and bulk  * test methods.  By using the {@link #makeSuite} method, you can  * automatically create a hierarchical suite of tests and child bulk tests.  * <p>  * For instance, consider the following two classes:  *  * <Pre>  *  public class SetTest extends BulkTest {  *  *      private Set set;  *  *      public SetTest(Set set) {  *          this.set = set;  *      }  *  *      public void testContains() {  *          boolean r = set.contains(set.iterator().next()));  *          assertTrue("Set should contain first element, r);  *      }  *  *      public void testClear() {  *          set.clear();  *          assertTrue("Set should be empty after clear", set.isEmpty());  *      }  *  }  *  *  *  public class HashMapTest extends BulkTest {  *  *      private Map makeFullMap() {  *          HashMap result = new HashMap();  *          result.put("1", "One");  *          result.put("2", "Two");  *          return result;  *      }  *  *      public void testClear() {  *          Map map = makeFullMap();  *          map.clear();  *          assertTrue("Map empty after clear", map.isEmpty());  *      }  *  *      public BulkTest bulkTestKeySet() {  *          return new SetTest(makeFullMap().keySet());  *      }  *  *      public BulkTest bulkTestEntrySet() {  *          return new SetTest(makeFullMap().entrySet());  *      }  *  }  *  </Pre>  *  *  In the above examples, {@code SetTest} defines two  *  simple test methods and no bulk test methods; {@code HashMapTest}  *  defines one simple test method and two bulk test methods.  When  *  {@code makeSuite(HashMapTest.class).run} is executed,  *  <I>five</I> simple test methods will be run, in this order:<P>  *  *  <Ol>  *  <Li>HashMapTest.testClear()  *  <Li>HashMapTest.bulkTestKeySet().testContains();  *  <Li>HashMapTest.bulkTestKeySet().testClear();  *  <Li>HashMapTest.bulkTestEntrySet().testContains();  *  <Li>HashMapTest.bulkTestEntrySet().testClear();  *  </Ol>  *  *  In the graphical junit test runners, the tests would be displayed in  *  the following tree:<P>  *  *  <UL>  *  <LI>HashMapTest</LI>  *      <UL>  *      <LI>testClear  *      <LI>bulkTestKeySet  *          <UL>  *          <LI>testContains  *          <LI>testClear  *          </UL>  *      <LI>bulkTestEntrySet  *          <UL>  *          <LI>testContains  *          <LI>testClear  *          </UL>  *      </UL>  *  </UL>  *  *  A subclass can override a superclass's bulk test by  *  returning {@code null} from the bulk test method.  If you only  *  want to override specific simple tests within a bulk test, use the  *  {@link #ignoredTests} method.<P>  *  *  Note that if you want to use the bulk test methods, you <I>must</I>  *  define your {@code suite()} method to use {@link #makeSuite}.  *  The ordinary {@link TestSuite} constructor doesn't know how to  *  interpret bulk test methods.  *  */ public class BulkTest extends TestCase implements Cloneable {      // Note:  BulkTest is Cloneable to make it easier to construct     // BulkTest instances for simple test methods that are defined in     // anonymous inner classes.  Basically we don't have to worry about     // finding weird constructors.  (And even if we found them, technically     // it'd be illegal for anyone but the outer class to invoke them).     // Given one BulkTest instance, we can just clone it and reset the     // method name for every simple test it defines.      /** Path to test data resources */     protected static final String TEST_DATA_PATH = "src/test/resources/org/apache/commons/collections4/data/test/";      /** Path to test properties resources */     public static final String TEST_PROPERTIES_PATH = "src/test/resources/org/apache/commons/collections4/properties/";      /**      *  The full name of this bulk test instance.  This is the full name      *  that is compared to {@link #ignoredTests} to see if this      *  test should be ignored.  It's also displayed in the text runner      *  to ease debugging.      */     String verboseName;      /**      *  Constructs a new {@code BulkTest} instance that will run the      *  specified simple test.      *      *  @param name  the name of the simple test method to run      */     public BulkTest(final String name) {         super(name);         this.verboseName = getClass().getName();     }      /**      *  Creates a clone of this {@code BulkTest}.<P>      *      *  @return  a clone of this {@code BulkTest}      */     @Override     public Object clone() {         try {             return super.clone();         } catch (final CloneNotSupportedException e) {             throw new Error(); // should never happen         }     }      /**      *  Returns an array of test names to ignore.<P>      *      *  If a test that's defined by this {@code BulkTest} or      *  by one of its bulk test methods has a name that's in the returned      *  array, then that simple test will not be executed.<P>      *      *  A test's name is formed by taking the class name of the      *  root {@code BulkTest}, eliminating the package name, then      *  appending the names of any bulk test methods that were invoked      *  to get to the simple test, and then appending the simple test      *  method name.  The method names are delimited by periods:      *      *  <pre>      *  HashMapTest.bulkTestEntrySet.testClear      *  </pre>      *      *  is the name of one of the simple tests defined in the sample classes      *  described above.  If the sample {@code HashMapTest} class      *  included this method:      *      *  <pre>      *  public String[] ignoredTests() {      *      return new String[] { "HashMapTest.bulkTestEntrySet.testClear" };      *  }      *  </pre>      *      *  then the entry set's clear method wouldn't be tested, but the key      *  set's clear method would.      *      *  @return an array of the names of tests to ignore, or null if      *   no tests should be ignored      */     public String[] ignoredTests() {         return null;     }      /**      *  Returns the display name of this {@code BulkTest}.      *      *  @return the display name of this {@code BulkTest}      */     @Override     public String toString() {         return getName() + "(" + verboseName + ") ";     }      /**      *  Returns a {@link TestSuite} for testing all of the simple tests      *  <I>and</I> all the bulk tests defined by the given class.<P>      *      *  The class is examined for simple and bulk test methods; any child      *  bulk tests are also examined recursively; and the results are stored      *  in a hierarchical {@link TestSuite}.<P>      *      *  The given class must be a subclass of {@code BulkTest} and must      *  not be abstract.<P>      *      *  @param c  the class to examine for simple and bulk tests      *  @return  a {@link TestSuite} containing all the simple and bulk tests      *    defined by that class      */     public static TestSuite makeSuite(final Class<? extends BulkTest> c) {         if (Modifier.isAbstract(c.getModifiers())) {             throw new IllegalArgumentException("Class must not be abstract.");         }         if (!BulkTest.class.isAssignableFrom(c)) {             throw new IllegalArgumentException("Class must extend BulkTest.");         }         return new BulkTestSuiteMaker(c).make();     }  }  // It was easier to use a separate class to do all the reflection stuff // for making the TestSuite instances.  Having permanent state around makes // it easier to handle the recursion. class BulkTestSuiteMaker {      /** The class that defines simple and bulk tests methods. */     private final Class<? extends BulkTest> startingClass;      /** List of ignored simple test names. */     private List<String> ignored;      /** The TestSuite we're currently populating.  Can change over time. */     private TestSuite result;      /**      * The prefix for simple test methods.  Used to check if a test is in      * the ignored list.      */     private String prefix;      /**      * Constructor.      *      * @param startingClass  the starting class      */     BulkTestSuiteMaker(final Class<? extends BulkTest> startingClass) {         this.startingClass = startingClass;     }      /**      * Makes a hierarchical TestSuite based on the starting class.      *      * @return the hierarchical TestSuite for startingClass      */     public TestSuite make() {         this.result = new TestSuite();         this.prefix = getBaseName(startingClass);         result.setName(prefix);          final BulkTest bulk = makeFirstTestCase(startingClass);         ignored = new ArrayList<>();         final String[] s = bulk.ignoredTests();         if (s != null) {             ignored.addAll(Arrays.asList(s));         }         make(bulk);         return result;     }      /**      * Appends all the simple tests and bulk tests defined by the given      * instance's class to the current TestSuite.      *      * @param bulk  An instance of the class that defines simple and bulk      *    tests for us to append      */     void make(final BulkTest bulk) {         final Class<? extends BulkTest> c = bulk.getClass();         final Method[] all = c.getMethods();         for (final Method element : all) {             if (isTest(element)) {                 addTest(bulk, element);             }             if (isBulk(element)) {                 addBulk(bulk, element);             }         }     }      /**      * Adds the simple test defined by the given method to the TestSuite.      *      * @param bulk  The instance of the class that defined the method      *   (I know it's weird.  But the point is, we can clone the instance      *   and not have to worry about constructors.)      * @param m  The simple test method      */     void addTest(final BulkTest bulk, final Method m) {         final BulkTest bulk2 = (BulkTest) bulk.clone();         bulk2.setName(m.getName());         bulk2.verboseName = prefix + "." + m.getName();         if (ignored.contains(bulk2.verboseName)) {             return;         }         result.addTest(bulk2);     }      /**      * Adds a whole new suite of tests that are defined by the result of      * the given bulk test method.  In other words, the given bulk test      * method is invoked, and the resulting BulkTest instance is examined      * for yet more simple and bulk tests.      *      * @param bulk  The instance of the class that defined the method      * @param m  The bulk test method      */     void addBulk(final BulkTest bulk, final Method m) {         final String verboseName = prefix + "." + m.getName();         if (ignored.contains(verboseName)) {             return;         }          BulkTest bulk2;         try {             bulk2 = (BulkTest) m.invoke(bulk, (Object[]) null);             if (bulk2 == null) {                 return;             }         } catch (final InvocationTargetException ex) {             ex.getTargetException().printStackTrace();             throw new Error(); // FIXME;         } catch (final IllegalAccessException ex) {             ex.printStackTrace();             throw new Error(); // FIXME;         }          // Save current state on the stack.         final String oldPrefix = prefix;         final TestSuite oldResult = result;          prefix = prefix + "." + m.getName();         result = new TestSuite();         result.setName(m.getName());          make(bulk2);          oldResult.addTest(result);          // Restore the old state         prefix = oldPrefix;         result = oldResult;     }      /**      * Returns the base name of the given class.      *      * @param c  the class      * @return the name of that class, minus any package names      */     private static String getBaseName(final Class<?> c) {         String name = c.getName();         final int p = name.lastIndexOf('.');         if (p > 0) {             name = name.substring(p + 1);         }         return name;     }       // These three methods are used to create a valid BulkTest instance     // from a class.      private static <T> Constructor<T> getTestCaseConstructor(final Class<T> c) {         try {             return c.getConstructor(String.class);         } catch (final NoSuchMethodException e) {             throw new IllegalArgumentException(c + " must provide a (String) constructor");         }     }      private static <T extends BulkTest> BulkTest makeTestCase(final Class<T> c, final Method m) {         final Constructor<T> con = getTestCaseConstructor(c);         try {             return con.newInstance(m.getName());         } catch (final InvocationTargetException e) {             e.printStackTrace();             throw new RuntimeException(); // FIXME;         } catch (final IllegalAccessException e) {             throw new Error(); // should never occur         } catch (final InstantiationException e) {             throw new RuntimeException(); // FIXME;         }     }      private static <T extends BulkTest> BulkTest makeFirstTestCase(final Class<T> c) {         final Method[] all = c.getMethods();         for (final Method element : all) {             if (isTest(element)) {                 return makeTestCase(c, element);             }         }         throw new IllegalArgumentException(c.getName() + " must provide at least one test method.");     }      /**      * Returns true if the given method is a simple test method.      */     private static boolean isTest(final Method m) {         if (!m.getName().startsWith("test")) {             return false;         }         if (m.getReturnType() != Void.TYPE) {             return false;         }         if (m.getParameterTypes().length != 0) {             return false;         }         final int mods = m.getModifiers();         if (Modifier.isStatic(mods)) {             return false;         }         if (Modifier.isAbstract(mods)) {             return false;         }         return true;     }      /**      * Returns true if the given method is a bulk test method.      */     private static boolean isBulk(final Method m) {         if (!m.getName().startsWith("bulkTest")) {             return false;         }         if (m.getReturnType() != BulkTest.class) {             return false;         }         if (m.getParameterTypes().length != 0) {             return false;         }         final int mods = m.getModifiers();         if (Modifier.isStatic(mods)) {             return false;         }         if (Modifier.isAbstract(mods)) {             return false;         }         return true;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Set;  import org.apache.commons.collections4.map.Flat3Map;  /**  * {@code MapPerformanceTest} is designed to perform basic Map performance tests.  *  */ public class MapPerformance {      /** The total number of runs for each test */     private static final int RUNS = 20000000;      /**      * Main method      */     public static void main(final String[] args) {         testAll();     }      private static void testAll() {         final Map<String, String> dummyMap = new DummyMap<>();         final Map<String, String> hashMap = new HashMap<>(); //        hashMap.put("Alpha", "A"); //        hashMap.put("Beta", "B"); //        hashMap.put("Gamma", "C"); //        hashMap.put("Delta", "D");         final Map<String, String> flatMap = new Flat3Map<>(hashMap);         System.out.println(flatMap); //        Map<String, String> unmodHashMap = Collections.unmodifiableMap(new HashMap<String, String>(hashMap)); //        Map fastHashMap = new FastHashMap(hashMap); //        Map<String, String> treeMap = new TreeMap<String, String>(hashMap); //        Map linkedMap = new LinkedHashMap(hashMap); //        Map syncMap = Collections.unmodifiableMap(new HashMap(hashMap)); //        Map bucketMap = new StaticBucketMap(); //        bucketMap.putAll(hashMap); //        Map doubleMap = new DoubleOrderedMap(hashMap);          // dummy is required as the VM seems to hotspot the first call to the         // test method with the given type         test(dummyMap,      "         Dummy ");         test(dummyMap,      "         Dummy ");         test(dummyMap,      "         Dummy ");         test(flatMap,       "         Flat3 ");         test(hashMap,       "       HashMap ");          test(flatMap,       "         Flat3 ");         test(flatMap,       "         Flat3 ");         test(flatMap,       "         Flat3 ");          test(hashMap,       "       HashMap ");         test(hashMap,       "       HashMap ");         test(hashMap,       "       HashMap ");  //        test(treeMap,       "       TreeMap "); //        test(treeMap,       "       TreeMap "); //        test(treeMap,       "       TreeMap ");  //        test(unmodHashMap,  "Unmod(HashMap) "); //        test(unmodHashMap,  "Unmod(HashMap) "); //        test(unmodHashMap,  "Unmod(HashMap) "); // //        test(syncMap,       " Sync(HashMap) "); //        test(syncMap,       " Sync(HashMap) "); //        test(syncMap,       " Sync(HashMap) "); // //        test(fastHashMap,   "   FastHashMap "); //        test(fastHashMap,   "   FastHashMap "); //        test(fastHashMap,   "   FastHashMap "); // //        test(seqMap,        "    SeqHashMap "); //        test(seqMap,        "    SeqHashMap "); //        test(seqMap,        "    SeqHashMap "); // //        test(linkedMap,     " LinkedHashMap "); //        test(linkedMap,     " LinkedHashMap "); //        test(linkedMap,     " LinkedHashMap "); // //        test(bucketMap,     "     BucketMap "); //        test(bucketMap,     "     BucketMap "); //        test(bucketMap,     "     BucketMap "); // //        test(doubleMap,     "     DoubleMap "); //        test(doubleMap,     "     DoubleMap "); //        test(doubleMap,     "     DoubleMap ");     }      private static void test(final Map<String, String> map, final String name) {         long start = 0, end = 0; //        int total = 0;         start = System.currentTimeMillis();         for (int i = RUNS; i > 0; i--) { //            if (map.get("Alpha") != null) total++; //            if (map.get("Beta") != null) total++; //            if (map.get("Gamma") != null) total++;             map.put("Alpha", "A");             map.put("Beta", "B");             map.put("Beta", "C");             map.put("Gamma", "D"); //            map.remove("Gamma"); //            map.remove("Beta"); //            map.remove("Alpha");             map.put("Delta", "E");             map.clear();         }         end = System.currentTimeMillis();         System.out.println(name + (end - start));     }      // ----------------------------------------------------------------------      private static class DummyMap<K, V> implements Map<K, V> {         @Override         public void clear() {         }         @Override         public boolean containsKey(final Object key) {             return false;         }         @Override         public boolean containsValue(final Object value) {             return false;         }         @Override         public Set<Map.Entry<K, V>> entrySet() {             return null;         }         @Override         public V get(final Object key) {             return null;         }         @Override         public boolean isEmpty() {             return false;         }         @Override         public Set<K> keySet() {             return null;         }         @Override         public V put(final K key, final V value) {             return null;         }         @Override         public void putAll(final Map<? extends K, ? extends V> t) {         }         @Override         public V remove(final Object key) {             return null;         }         @Override         public int size() {             return 0;         }         @Override         public Collection<V> values() {             return null;         }     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;  /**  * Extension of {@link AbstractListTest} for exercising the {@link GrowthList}.  *  * @since 3.2  */ public class GrowthListTest<E> extends AbstractListTest<E> {      public GrowthListTest(final String testName) {         super(testName);     }      @Override     public List<E> makeObject() {         return new GrowthList<>();     }      @Override     public List<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return GrowthList.growthList(list);     }      //-----------------------------------------------------------------------     public void testGrowthList() {         final Integer zero = Integer.valueOf(0);         final Integer one = Integer.valueOf(1);         final Integer two = Integer.valueOf(2);         final GrowthList<Integer> grower = new GrowthList(1);         assertEquals(0, grower.size());         grower.add(0, zero);         assertEquals(1, grower.size());         grower.add(1, one);         assertEquals(2, grower.size());         grower.add(2, two);         assertEquals(3, grower.size());     }      //-----------------------------------------------------------------------     public void testGrowthAdd() {         final Integer one = Integer.valueOf(1);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.add(1, one);         assertEquals(2, grower.size());         assertEquals(null, grower.get(0));         assertEquals(one, grower.get(1));     }      public void testGrowthAddAll() {         final Integer one = Integer.valueOf(1);         final Integer two = Integer.valueOf(2);         final Collection<Integer> coll = new ArrayList<>();         coll.add(one);         coll.add(two);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.addAll(1, coll);         assertEquals(3, grower.size());         assertEquals(null, grower.get(0));         assertEquals(one, grower.get(1));         assertEquals(two, grower.get(2));     }      public void testGrowthSet1() {         final Integer one = Integer.valueOf(1);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.set(1, one);         assertEquals(2, grower.size());         assertEquals(null, grower.get(0));         assertEquals(one, grower.get(1));     }      public void testGrowthSet2() {         final Integer one = Integer.valueOf(1);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.set(0, one);         assertEquals(1, grower.size());         assertEquals(one, grower.get(0));     }      //-----------------------------------------------------------------------     /**      * Override.      */     @Override     public void testListAddByIndexBoundsChecking() {         List<E> list;         final E element = getOtherElements()[0];         try {             list = makeObject();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      * Override.      */     @Override     public void testListAddByIndexBoundsChecking2() {         List<E> list;         final E element = getOtherElements()[0];         try {             list = makeFullCollection();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      * Override.      */     @Override     public void testListSetByIndexBoundsChecking() {         final List<E> list = makeObject();         final E element = getOtherElements()[0];         try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      * Override.      */     @Override     public void testListSetByIndexBoundsChecking2() {         final List<E> list = makeFullCollection();         final E element = getOtherElements()[0];         try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/GrowthList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/GrowthList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.Arrays;  /**  * Test case for {@link AbstractLinkedList}.  *  */ public abstract class AbstractLinkedListTest<E> extends AbstractListTest<E> {      public AbstractLinkedListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testRemoveFirst() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         if (!isRemoveSupported()) {             try {                 list.removeFirst();             } catch (final UnsupportedOperationException ex) {}         }          list.addAll(Arrays.asList((E[]) new String[] { "value1", "value2" }));         assertEquals("value1", list.removeFirst());         checkNodes();         list.addLast((E) "value3");         checkNodes();         assertEquals("value2", list.removeFirst());         assertEquals("value3", list.removeFirst());         checkNodes();         list.addLast((E) "value4");         checkNodes();         assertEquals("value4", list.removeFirst());         checkNodes();     }      @SuppressWarnings("unchecked")     public void testRemoveLast() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         if (!isRemoveSupported()) {             try {                 list.removeLast();             } catch (final UnsupportedOperationException ex) {}         }          list.addAll(Arrays.asList((E[]) new String[] { "value1", "value2" }));         assertEquals("value2", list.removeLast());         list.addFirst((E) "value3");         checkNodes();         assertEquals("value1", list.removeLast());         assertEquals("value3", list.removeLast());         list.addFirst((E) "value4");         checkNodes();         assertEquals("value4", list.removeFirst());     }      @SuppressWarnings("unchecked")     public void testAddNodeAfter() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         if (!isAddSupported()) {             try {                 list.addFirst(null);             } catch (final UnsupportedOperationException ex) {}         }          list.addFirst((E) "value1");         list.addNodeAfter(list.getNode(0, false), (E) "value2");         assertEquals("value1", list.getFirst());         assertEquals("value2", list.getLast());         list.removeFirst();         checkNodes();         list.addNodeAfter(list.getNode(0, false), (E) "value3");         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value3", list.getLast());         list.addNodeAfter(list.getNode(0, false), (E) "value4");         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value3", list.getLast());         assertEquals("value4", list.get(1));         list.addNodeAfter(list.getNode(2, false), (E) "value5");         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value4", list.get(1));         assertEquals("value3", list.get(2));         assertEquals("value5", list.getLast());     }      @SuppressWarnings("unchecked")     public void testRemoveNode() {         resetEmpty();         if (!isAddSupported() || !isRemoveSupported()) {             return;         }         final AbstractLinkedList<E> list = getCollection();          list.addAll(Arrays.asList((E[]) new String[] { "value1", "value2" }));         list.removeNode(list.getNode(0, false));         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value2", list.getLast());         list.addFirst((E) "value1");         list.addFirst((E) "value0");         checkNodes();         list.removeNode(list.getNode(1, false));         assertEquals("value0", list.getFirst());         assertEquals("value2", list.getLast());         checkNodes();         list.removeNode(list.getNode(1, false));         assertEquals("value0", list.getFirst());         assertEquals("value0", list.getLast());         checkNodes();     }      @SuppressWarnings("unchecked")     public void testGetNode() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         // get marker         assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);         try {             list.getNode(0, false);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }         list.addAll( Arrays.asList((E[]) new String[]{"value1", "value2"}));         checkNodes();         list.addFirst((E) "value0");         checkNodes();         list.removeNode(list.getNode(1, false));         checkNodes();         try {             list.getNode(2, false);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }         try {             list.getNode(-1, false);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }         try {             list.getNode(3, true);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }     }      protected void checkNodes() {         final AbstractLinkedList<E> list = getCollection();         for (int i = 0; i < list.size; i++) {             assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));             if (i < list.size - 1) {                 assertEquals(list.getNode(i + 1, false).previous,                     list.getNode(i, false));             }         }     }      /**      * {@inheritDoc}      */     @Override     public AbstractLinkedList<E> getCollection() {         return (AbstractLinkedList<E>) super.getCollection();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.Transformer;  import java.time.LocalDateTime; import java.util.ArrayList; import java.util.Arrays; import java.util.List;  public class LazyListTest extends AbstractObjectTest {      public LazyListTest(final String testName) {         super(testName);     }      @Override     public Object makeObject() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         return new LazyList<>(new ArrayList<>(), dateFactory);     }      @Override     public void testSimpleSerialization() {         // Factory and Transformer are not serializable     }      @Override     public void testSerializeDeserializeThenCompare() {         // Factory and Transformer are not serializable     }      @Override     public void testCanonicalEmptyCollectionExists() {         // Factory and Transformer are not serializable     }      @Override     public void testCanonicalFullCollectionExists() {         // Factory and Transformer are not serializable     }      public void testElementCreationWithFactory() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          assertTrue(list.isEmpty());          final LocalDateTime firstElement = list.get(0);         assertNotNull(firstElement);         assertFalse(list.isEmpty());     }      public void testElementCreationWithTransformer() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          assertTrue(list.isEmpty());          final LocalDateTime firstElement = list.get(0);         assertNotNull(firstElement);         assertFalse(list.isEmpty());     }      public void testCreateNullGapsWithFactory() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);     }      public void testCreateNullGapsWithTransformer() {         final List<Integer> hours = Arrays.asList(7, 5, 8, 2);         final Transformer<Integer, LocalDateTime> dateFactory = input -> LocalDateTime.now().withHour(hours.get(input));         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);     }      public void testGetWithNull() {         final List<Integer> hours = Arrays.asList(7, 5, 8, 2);         final Transformer<Integer, LocalDateTime> transformer = input -> LocalDateTime.now().withHour(hours.get(input));         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), transformer);         LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);         list.remove(3);         list.add(3, null);         fourthElement = list.get(3);         assertNotNull(fourthElement);     }      public void testSubListWitheFactory() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);         final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);         testSubList(list);     }      public void testSubListWithTransformer() {         final List<Integer> hours = Arrays.asList(7, 5, 8, 2);         final Transformer<Integer, LocalDateTime> transformer = input -> LocalDateTime.now().withHour(hours.get(input));         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), transformer);         final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);         testSubList(list);     }      private void testSubList(final List<LocalDateTime> list) {         List<LocalDateTime> subList = list.subList(1, 3);         assertFalse(subList.isEmpty());         assertNotNull(subList);         assertEquals(2, subList.size());          subList = list.subList(0, 1);         assertFalse(subList.isEmpty());         assertEquals(1, subList.size());          subList = list.subList(1, 1);         assertTrue(subList.isEmpty());          subList = list.subList(0, list.size());         assertFalse(subList.isEmpty());         assertEquals(list.size(), subList.size());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.List;  /**  * Extension of {@link AbstractListTest} for exercising the  * {@link UnmodifiableList} implementation.  *  * @since 3.0  */ public class UnmodifiableListTest<E> extends AbstractListTest<E> {      public UnmodifiableListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public UnmodifiableList<E> makeObject() {         return new UnmodifiableList<>(new ArrayList<E>());     }      @Override     public UnmodifiableList<E> makeFullCollection() {         final ArrayList<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return new UnmodifiableList<>(list);     }      @Override     public boolean isSetSupported() {         return false;     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------     protected UnmodifiableList<E> list;     protected ArrayList<E> array;      @SuppressWarnings("unchecked")     protected void setupList() {         list = makeFullCollection();         array = new ArrayList<>();         array.add((E) Integer.valueOf(1));     }      /**      * Verify that base list and sublists are not modifiable      */     public void testUnmodifiable() {         setupList();         verifyUnmodifiable(list);         verifyUnmodifiable(list.subList(0, 2));     }      public void testDecorateFactory() {         final List<E> list = makeObject();         assertSame(list, UnmodifiableList.unmodifiableList(list));          try {             UnmodifiableList.unmodifiableList(null);             fail();         } catch (final NullPointerException ex) {}     }      @SuppressWarnings("unchecked")     protected void verifyUnmodifiable(final List<E> list) {         try {             list.add(0, (E) Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.add((E) Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.addAll(0, array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.addAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.clear();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.remove(0);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.remove(Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.removeAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.retainAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.set(0, (E) Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      /**      * Verify that iterator is not modifiable      */     public void testUnmodifiableIterator() {         setupList();         final Iterator<E> iterator = list.iterator();         try {             iterator.next();             iterator.remove();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests  *  * @since 3.1  */ public class TreeListTest<E> extends AbstractListTest<E> {      public TreeListTest(final String name) {         super(name);     }  //    public static void main(String[] args) { //        junit.textui.TestRunner.run(suite()); //        System.out.println("         add; toArray; iterator; insert; get; indexOf; remove"); //        System.out.print("   TreeList = "); //        benchmark(new TreeList()); //        System.out.print("\n  ArrayList = "); //        benchmark(new java.util.ArrayList()); //        System.out.print("\n LinkedList = "); //        benchmark(new java.util.LinkedList()); //        System.out.print("\n NodeCachingLinkedList = "); //        benchmark(new NodeCachingLinkedList()); //    }      public static Test suite() {         return BulkTest.makeSuite(TreeListTest.class);     }      public static void benchmark(final List<? super Integer> l) {         long start = System.currentTimeMillis();         for (int i = 0; i < 100000; i++) {             l.add(Integer.valueOf(i));         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 200; i++) {             l.toArray();         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 100; i++) {             final java.util.Iterator<? super Integer> it = l.iterator();             while (it.hasNext()) {                 it.next();             }         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 10000; i++) {             final int j = (int) (Math.random() * 100000);             l.add(j, Integer.valueOf(-j));         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 50000; i++) {             final int j = (int) (Math.random() * 110000);             l.get(j);         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 200; i++) {             final int j = (int) (Math.random() * 100000);             l.indexOf(Integer.valueOf(j));         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 10000; i++) {             final int j = (int) (Math.random() * 100000);             l.remove(j);         }         System.out.print(System.currentTimeMillis() - start + ";");     }      //-----------------------------------------------------------------------     @Override     public TreeList<E> makeObject() {         return new TreeList<>();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testAddMultiple() {         final List<E> l = makeObject();         l.add((E) "hugo");         l.add((E) "erna");         l.add((E) "daniel");         l.add((E) "andres");         l.add((E) "harald");         l.add(0, null);         assertEquals(null, l.get(0));         assertEquals("hugo", l.get(1));         assertEquals("erna", l.get(2));         assertEquals("daniel", l.get(3));         assertEquals("andres", l.get(4));         assertEquals("harald", l.get(5));     }      @SuppressWarnings("unchecked")     public void testRemove() {         final List<E> l = makeObject();         l.add((E) "hugo");         l.add((E) "erna");         l.add((E) "daniel");         l.add((E) "andres");         l.add((E) "harald");         l.add(0, null);         int i = 0;         assertEquals(null, l.get(i++));         assertEquals("hugo", l.get(i++));         assertEquals("erna", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("andres", l.get(i++));         assertEquals("harald", l.get(i++));          l.remove(0);         i = 0;         assertEquals("hugo", l.get(i++));         assertEquals("erna", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("andres", l.get(i++));         assertEquals("harald", l.get(i++));          i = 0;         l.remove(1);         assertEquals("hugo", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("andres", l.get(i++));         assertEquals("harald", l.get(i++));          i = 0;         l.remove(2);         assertEquals("hugo", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("harald", l.get(i++));     }      @SuppressWarnings("unchecked")     public void testInsertBefore() {         final List<E> l = makeObject();         l.add((E) "erna");         l.add(0, (E) "hugo");         assertEquals("hugo", l.get(0));         assertEquals("erna", l.get(1));     }      @SuppressWarnings("unchecked")     public void testIndexOf() {         final List<E> l = makeObject();         l.add((E) "0");         l.add((E) "1");         l.add((E) "2");         l.add((E) "3");         l.add((E) "4");         l.add((E) "5");         l.add((E) "6");         assertEquals(0, l.indexOf("0"));         assertEquals(1, l.indexOf("1"));         assertEquals(2, l.indexOf("2"));         assertEquals(3, l.indexOf("3"));         assertEquals(4, l.indexOf("4"));         assertEquals(5, l.indexOf("5"));         assertEquals(6, l.indexOf("6"));          l.set(1, (E) "0");         assertEquals(0, l.indexOf("0"));          l.set(3, (E) "3");         assertEquals(3, l.indexOf("3"));         l.set(2, (E) "3");         assertEquals(2, l.indexOf("3"));         l.set(1, (E) "3");         assertEquals(1, l.indexOf("3"));         l.set(0, (E) "3");         assertEquals(0, l.indexOf("3"));     }  //    public void testCheck() { //        List l = makeEmptyList(); //        l.add("A1"); //        l.add("A2"); //        l.add("A3"); //        l.add("A4"); //        l.add("A5"); //        l.add("A6"); //    }      public void testBug35258() {         final Object objectToRemove = Integer.valueOf(3);          final List<Integer> treelist = new TreeList<>();         treelist.add(Integer.valueOf(0));         treelist.add(Integer.valueOf(1));         treelist.add(Integer.valueOf(2));         treelist.add(Integer.valueOf(3));         treelist.add(Integer.valueOf(4));          // this cause inconsistence of ListIterator()         treelist.remove(objectToRemove);          final ListIterator<Integer> li = treelist.listIterator();         assertEquals(Integer.valueOf(0), li.next());         assertEquals(Integer.valueOf(0), li.previous());         assertEquals(Integer.valueOf(0), li.next());         assertEquals(Integer.valueOf(1), li.next());         // this caused error in bug 35258         assertEquals(Integer.valueOf(1), li.previous());         assertEquals(Integer.valueOf(1), li.next());         assertEquals(Integer.valueOf(2), li.next());         assertEquals(Integer.valueOf(2), li.previous());         assertEquals(Integer.valueOf(2), li.next());         assertEquals(Integer.valueOf(4), li.next());         assertEquals(Integer.valueOf(4), li.previous());         assertEquals(Integer.valueOf(4), li.next());         assertEquals(false, li.hasNext());     }      public void testBugCollections447() {         final List<String> treeList = new TreeList<>();         treeList.add("A");         treeList.add("B");         treeList.add("C");         treeList.add("D");          final ListIterator<String> li = treeList.listIterator();         assertEquals("A", li.next());         assertEquals("B", li.next());          assertEquals("B", li.previous());          li.remove(); // Deletes "B"          // previous() after remove() should move to         // the element before the one just removed         assertEquals("A", li.previous());     }      @SuppressWarnings("boxing") // OK in test code     public void testIterationOrder() {         // COLLECTIONS-433:         // ensure that the iteration order of elements is correct         // when initializing the TreeList with another collection          for (int size = 1; size < 1000; size++) {             final List<Integer> other = new ArrayList<>(size);             for (int i = 0; i < size; i++) {                 other.add(i);             }             final TreeList<Integer> l = new TreeList<>(other);             final ListIterator<Integer> it = l.listIterator();             int i = 0;             while (it.hasNext()) {                 final Integer val = it.next();                 assertEquals(i++, val.intValue());             }              while (it.hasPrevious()) {                 final Integer val = it.previous();                 assertEquals(--i, val.intValue());             }         }     }      @SuppressWarnings("boxing") // OK in test code     public void testIterationOrderAfterAddAll() {         // COLLECTIONS-433:         // ensure that the iteration order of elements is correct         // when calling addAll on the TreeList          // to simulate different cases in addAll, do different runs where         // the number of elements already in the list and being added by addAll differ          final int size = 1000;         for (int i = 0; i < 100; i++) {             final List<Integer> other = new ArrayList<>(size);             for (int j = i; j < size; j++) {                 other.add(j);             }             final TreeList<Integer> l = new TreeList<>();             for (int j = 0; j < i; j++) {                 l.add(j);             }              l.addAll(other);              final ListIterator<Integer> it = l.listIterator();             int cnt = 0;             while (it.hasNext()) {                 final Integer val = it.next();                 assertEquals(cnt++, val.intValue());             }              while (it.hasPrevious()) {                 final Integer val = it.previous();                 assertEquals(--cnt, val.intValue());             }         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.ListIterator;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractListTest} for exercising the {@link TransformedList}  * implementation.  *  * @since 3.0  */ public class TransformedListTest<E> extends AbstractListTest<E> {      public TransformedListTest(final String testName) {         super(testName);     }      @Override     public List<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public List<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     @SuppressWarnings("unchecked")     public List<E> makeObject() {         return TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public List<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return TransformedList.transformingList(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedList() {         final List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, list.size());         final E[] els = (E[]) new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (int i = 0; i < els.length; i++) {             list.add(els[i]);             assertEquals(i + 1, list.size());             assertEquals(true, list.contains(Integer.valueOf((String) els[i])));             assertEquals(false, list.contains(els[i]));         }          assertEquals(false, list.remove(els[0]));         assertEquals(true, list.remove(Integer.valueOf((String) els[0])));          list.clear();         for (int i = 0; i < els.length; i++) {             list.add(0, els[i]);             assertEquals(i + 1, list.size());             assertEquals(Integer.valueOf((String) els[i]), list.get(0));         }          list.set(0, (E) "22");         assertEquals(Integer.valueOf(22), list.get(0));          final ListIterator<E> it = list.listIterator();         it.next();         it.set((E) "33");         assertEquals(Integer.valueOf(33), list.get(0));         it.add((E) "44");         assertEquals(Integer.valueOf(44), list.get(1));          final List<E> adds = new ArrayList<>();         adds.add((E) "1");         adds.add((E) "2");         list.clear();         list.addAll(adds);         assertEquals(Integer.valueOf(1), list.get(0));         assertEquals(Integer.valueOf(2), list.get(1));          adds.clear();         adds.add((E) "3");         list.addAll(1, adds);         assertEquals(Integer.valueOf(1), list.get(0));         assertEquals(Integer.valueOf(3), list.get(1));         assertEquals(Integer.valueOf(2), list.get(2));     }      public void testTransformedList_decorateTransform() {         final List<Object> originalList = new ArrayList<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (final Object el : els) {             originalList.add(el);         }         final List<?> list = TransformedList.transformedList(originalList, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, list.size());         for (final Object el : els) {             assertEquals(true, list.contains(Integer.valueOf((String) el)));             assertEquals(false, list.contains(el));         }          assertEquals(false, list.remove(els[0]));         assertEquals(true, list.remove(Integer.valueOf((String) els[0])));     }      public void testSubList() {         final List<E> list = makeObject();         List<E> subList = list.subList(0, 0);         assertNotNull(subList);         list.add((E) "zero");         //subList without any element of list         subList = list.subList(0, 0);         assertNotNull(subList);         assertEquals(0, subList.size());          //subList with one element oif list         subList = list.subList(0, 1);         assertEquals(1, subList.size());          final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) "three");         list.addAll(1, elements);         //subList with all elements of list         subList = list.subList(0, list.size());         assertEquals(list.size(), subList.size());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.Arrays; import java.util.LinkedList;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Test class for NodeCachingLinkedList, a performance optimised LinkedList.  *  */ public class NodeCachingLinkedListTest<E> extends AbstractLinkedListTest<E> {      public NodeCachingLinkedListTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(NodeCachingLinkedListTest.class);     }      //-----------------------------------------------------------------------     @Override     public NodeCachingLinkedList<E> makeObject() {         return new NodeCachingLinkedList<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testShrinkCache() {         if (!isRemoveSupported() || !isAddSupported()) {             return;         }         resetEmpty();         final NodeCachingLinkedList<E> list = getCollection();          list.addAll(Arrays.asList((E[]) new String[] { "1", "2", "3", "4" }));         list.removeAllNodes(); // Will dump all 4 elements into cache         list.setMaximumCacheSize(2); // shrink cache         list.addAll(Arrays.asList((E[]) new String[] { "1", "2", "3", "4" }));         checkNodes();         list.removeNode(list.getNode(0, false)); // no room in cache         list.removeNode(list.getNode(0, false));         list.removeNode(list.getNode(0, false));         checkNodes();         list.addAll(Arrays.asList((E[]) new String[] { "1", "2", "3", "4" }));         checkNodes();     }      //-----------------------------------------------------------------------     public static void compareSpeed() {         final NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<>();         final LinkedList<Object> ll = new LinkedList<>();          final Object o1 = new Object();         final Object o2 = new Object();          final int loopCount = 4000000;          long startTime, endTime;          System.out.println("Testing relative execution time of commonly-used methods...");          startTime = System.currentTimeMillis();         for (int x = loopCount; x > 0; x--) {             // unrolled a few times to minimize effect of loop             ll.addFirst(o1);             ll.addLast(o2);             ll.removeFirst();             ll.removeLast();             ll.add(o1);             ll.remove(0);             //             ll.addFirst(o1);             ll.addLast(o2);             ll.removeFirst();             ll.removeLast();             ll.add(o1);             ll.remove(0);             //             ll.addFirst(o1);             ll.addLast(o2);             ll.removeFirst();             ll.removeLast();             ll.add(o1);             ll.remove(0);         }         endTime = System.currentTimeMillis();         System.out.println("Time with LinkedList: " + (endTime - startTime) + " ms");          startTime = System.currentTimeMillis();         for (int x = loopCount; x > 0; x--) {             ncll.addFirst(o1);             ncll.addLast(o2);             ncll.removeFirst();             ncll.removeLast();             ncll.add(o1);             ncll.remove(0);             //             ncll.addFirst(o1);             ncll.addLast(o2);             ncll.removeFirst();             ncll.removeLast();             ncll.add(o1);             ncll.remove(0);             //             ncll.addFirst(o1);             ncll.addLast(o2);             ncll.removeFirst();             ncll.removeLast();             ncll.add(o1);             ncll.remove(0);         }         endTime = System.currentTimeMillis();         System.out.println("Time with NodeCachingLinkedList: " + (endTime - startTime) + " ms");      }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), //           "src/test/resources/data/test/NodeCachingLinkedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), //            "src/test/resources/data/test/NodeCachingLinkedList.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public NodeCachingLinkedList<E> getCollection() {         return (NodeCachingLinkedList<E>) super.getCollection();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.Set;  /**  * JUnit tests.  *  * @since 3.0  */ public class SetUniqueListTest<E> extends AbstractListTest<E> {      class SetUniqueList307 extends SetUniqueList<E> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = 1415013031022962158L;          SetUniqueList307(final List<E> list, final Set<E> set) {             super(list, set);         }     }      boolean extraVerify = true;      public SetUniqueListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         // override to avoid duplicate "One"         return (E[]) new Object[] {             "",             "One",             Integer.valueOf(2),             "Three",             Integer.valueOf(4),             new Double(5),             new Float(6),             "Seven",             "Eight",             "Nine",             Integer.valueOf(10),             new Short((short) 11),             new Long(12),             "Thirteen",             "14",             "15",             new Byte((byte) 16)         };     }      //-----------------------------------------------------------------------     @Override     public List<E> makeObject() {         return new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());     }      @SuppressWarnings("unchecked")     public void testAdd() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          // Duplicate element         final E obj = (E) Integer.valueOf(1);         lset.add(obj);         lset.add(obj);         assertEquals("Duplicate element was added.", 1, lset.size());          // Unique element         lset.add((E) Integer.valueOf(2));         assertEquals("Unique element was not added.", 2, lset.size());     }      @SuppressWarnings("unchecked")     public void testAddAll() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          lset.addAll(             Arrays.asList((E[]) new Integer[] { Integer.valueOf(1), Integer.valueOf(1)}));          assertEquals("Duplicate element was added.", 1, lset.size());     }      @Override     public void testCollectionAddAll() {         // override for set behavior         resetEmpty();         E[] elements = getFullElements();         boolean r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Empty collection should change after addAll", r);         for (final E element : elements) {             assertTrue("Collection should contain added element",                     getCollection().contains(element));         }          resetFull();         final int size = getCollection().size();         elements = getOtherElements();         r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Full collection should change after addAll", r);         for (int i = 0; i < elements.length; i++) {             assertTrue("Full collection should contain added element " + i,                     getCollection().contains(elements[i]));         }         assertEquals("Size should increase after addAll",                 size + elements.length, getCollection().size());     }      @Override     public void testCollectionIteratorRemove() {         try {             extraVerify = false;             super.testCollectionIteratorRemove();         } finally {             extraVerify = true;         }     }     public void testCollections304() {         final List<String> list = new LinkedList<>();         final SetUniqueList<String> decoratedList = SetUniqueList.setUniqueList(list);         final String s1 = "Apple";         final String s2 = "Lemon";         final String s3 = "Orange";         final String s4 = "Strawberry";          decoratedList.add(s1);         decoratedList.add(s2);         decoratedList.add(s3);         assertEquals(3, decoratedList.size());          decoratedList.set(1, s4);         assertEquals(3, decoratedList.size());          decoratedList.add(1, s4);         assertEquals(3, decoratedList.size());          decoratedList.add(1, s2);         assertEquals(4, decoratedList.size());     }      @SuppressWarnings("unchecked")     public void testCollections307() {         List<E> list = new ArrayList<>();         List<E> uniqueList = SetUniqueList.setUniqueList(list);          final String hello = "Hello";         final String world = "World";         uniqueList.add((E) hello);         uniqueList.add((E) world);          List<E> subList = list.subList(0, 0);         List<E> subUniqueList = uniqueList.subList(0, 0);          assertFalse(subList.contains(world)); // passes         assertFalse(subUniqueList.contains(world)); // fails          List<E> worldList = new ArrayList<>();         worldList.add((E) world);         assertFalse(subList.contains("World")); // passes         assertFalse(subUniqueList.contains("World")); // fails          // repeat the test with a different class than HashSet;         // which means subclassing SetUniqueList below         list = new ArrayList<>();         uniqueList = new SetUniqueList307(list, new java.util.TreeSet<E>());          uniqueList.add((E) hello);         uniqueList.add((E) world);          subList = list.subList(0, 0);         subUniqueList = uniqueList.subList(0, 0);          assertFalse(subList.contains(world)); // passes         assertFalse(subUniqueList.contains(world)); // fails          worldList = new ArrayList<>();         worldList.add((E) world);         assertFalse(subList.contains("World")); // passes         assertFalse(subUniqueList.contains("World")); // fails     }      public void testCollections701() {         final SetUniqueList<Object> uniqueList = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());         final Integer obj1 = Integer.valueOf(1);         final Integer obj2 = Integer.valueOf(2);         uniqueList.add(obj1);         uniqueList.add(obj2);         assertEquals(2, uniqueList.size());         uniqueList.add(uniqueList);         assertEquals(3, uniqueList.size());         final List<Object> list = new LinkedList<>();         final SetUniqueList<Object> decoratedList = SetUniqueList.setUniqueList(list);         final String s1 = "Apple";         final String s2 = "Lemon";         final String s3 = "Orange";         final String s4 = "Strawberry";         decoratedList.add(s1);         decoratedList.add(s2);         decoratedList.add(s3);         assertEquals(3, decoratedList.size());         decoratedList.set(1, s4);         assertEquals(3, decoratedList.size());         decoratedList.add(decoratedList);         assertEquals(4, decoratedList.size());     }      //-----------------------------------------------------------------------     public void testFactory() {         final Integer[] array = new Integer[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(1) };         final ArrayList<Integer> list = new ArrayList<>(Arrays.asList(array));         final SetUniqueList<Integer> lset = SetUniqueList.setUniqueList(list);          assertEquals("Duplicate element was added.", 2, lset.size());         assertEquals(Integer.valueOf(1), lset.get(0));         assertEquals(Integer.valueOf(2), lset.get(1));         assertEquals(Integer.valueOf(1), list.get(0));         assertEquals(Integer.valueOf(2), list.get(1));     }      public void testIntCollectionAddAll() {         // make a SetUniqueList with one element         final List<Integer> list = new SetUniqueList<>(new ArrayList<Integer>(), new HashSet<Integer>());         final Integer existingElement = Integer.valueOf(1);         list.add(existingElement);          // add two new unique elements at index 0         final Integer firstNewElement = Integer.valueOf(2);         final Integer secondNewElement = Integer.valueOf(3);         Collection<Integer> collection = Arrays.asList(firstNewElement, secondNewElement);         list.addAll(0, collection);         assertEquals("Unique elements should be added.", 3, list.size());         assertEquals("First new element should be at index 0", firstNewElement, list.get(0));         assertEquals("Second new element should be at index 1", secondNewElement, list.get(1));         assertEquals("Existing element should shift to index 2", existingElement, list.get(2));          // add a duplicate element and a unique element at index 0         final Integer thirdNewElement = Integer.valueOf(4);         collection = Arrays.asList(existingElement, thirdNewElement);         list.addAll(0, collection);         assertEquals("Duplicate element should not be added, unique element should be added.",             4, list.size());         assertEquals("Third new element should be at index 0", thirdNewElement, list.get(0));     }      @SuppressWarnings("unchecked")     public void testListIterator() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          final E obj1 = (E) Integer.valueOf(1);         final E obj2 = (E) Integer.valueOf(2);         lset.add(obj1);         lset.add(obj2);          // Attempts to add a duplicate object         for (final ListIterator<E> it = lset.listIterator(); it.hasNext();) {             it.next();              if (!it.hasNext()) {                 it.add(obj1);                 break;             }         }          assertEquals("Duplicate element was added", 2, lset.size());     }      @Override     public void testListIteratorAdd() {         // override to cope with Set behavior         resetEmpty();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          final E[] elements = getOtherElements();  // changed here         ListIterator<E> iter1 = list1.listIterator();         ListIterator<E> iter2 = list2.listIterator();          for (final E element : elements) {             iter1.add(element);             iter2.add(element);             super.verify();  // changed here         }          resetFull();         iter1 = getCollection().listIterator();         iter2 = getConfirmed().listIterator();         for (final E element : elements) {             iter1.next();             iter2.next();             iter1.add(element);             iter2.add(element);             super.verify();  // changed here         }     }      //-----------------------------------------------------------------------     @Override     public void testListIteratorSet() {         // override to block         resetFull();         final ListIterator<E> it = getCollection().listIterator();         it.next();         try {             it.set(null);             fail();         } catch (final UnsupportedOperationException ex) {}     }      @Override     @SuppressWarnings("unchecked")     public void testListSetByIndex() {         // override for set behavior         resetFull();         final int size = getCollection().size();         getCollection().set(0, (E) new Long(1000));         assertEquals(size, getCollection().size());          getCollection().set(2, (E) new Long(1000));         assertEquals(size - 1, getCollection().size());         assertEquals(new Long(1000), getCollection().get(1));  // set into 2, but shifted down to 1     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         final List<E> list = new ArrayList<>(10);         final SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);         for (int i = 0; i < 10; ++i) {             uniqueList.add((E) Integer.valueOf(i));         }          final Collection<E> retained = new ArrayList<>(5);         for (int i = 0; i < 5; ++i) {             retained.add((E) Integer.valueOf(i * 2));         }          assertTrue(uniqueList.retainAll(retained));         assertEquals(5, uniqueList.size());         assertTrue(uniqueList.contains(Integer.valueOf(0)));         assertTrue(uniqueList.contains(Integer.valueOf(2)));         assertTrue(uniqueList.contains(Integer.valueOf(4)));         assertTrue(uniqueList.contains(Integer.valueOf(6)));         assertTrue(uniqueList.contains(Integer.valueOf(8)));     }      @SuppressWarnings("unchecked")     public void testRetainAllWithInitialList() {         // initialized with empty list         final List<E> list = new ArrayList<>(10);         for (int i = 0; i < 5; ++i) {             list.add((E) Integer.valueOf(i));         }         final SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);         for (int i = 5; i < 10; ++i) {             uniqueList.add((E) Integer.valueOf(i));         }          final Collection<E> retained = new ArrayList<>(5);         for (int i = 0; i < 5; ++i) {             retained.add((E) Integer.valueOf(i * 2));         }          assertTrue(uniqueList.retainAll(retained));         assertEquals(5, uniqueList.size());         assertTrue(uniqueList.contains(Integer.valueOf(0)));         assertTrue(uniqueList.contains(Integer.valueOf(2)));         assertTrue(uniqueList.contains(Integer.valueOf(4)));         assertTrue(uniqueList.contains(Integer.valueOf(6)));         assertTrue(uniqueList.contains(Integer.valueOf(8)));     }      @SuppressWarnings("unchecked")     public void testSet() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          // Duplicate element         final E obj1 = (E) Integer.valueOf(1);         final E obj2 = (E) Integer.valueOf(2);         final E obj3 = (E) Integer.valueOf(3);          lset.add(obj1);         lset.add(obj2);         lset.set(0, obj1);         assertEquals(2, lset.size());         assertSame(obj1, lset.get(0));         assertSame(obj2, lset.get(1));          lset.clear();         lset.add(obj1);         lset.add(obj2);         lset.set(0, obj2);         assertEquals(1, lset.size());         assertSame(obj2, lset.get(0));          lset.clear();         lset.add(obj1);         lset.add(obj2);         lset.set(0, obj3);         assertEquals(2, lset.size());         assertSame(obj3, lset.get(0));         assertSame(obj2, lset.get(1));          lset.clear();         lset.add(obj1);         lset.add(obj2);         lset.set(1, obj1);         assertEquals(1, lset.size());         assertSame(obj1, lset.get(0));     }      public void testSetCollections444() {         final SetUniqueList<Integer> lset = new SetUniqueList<>(new ArrayList<Integer>(), new HashSet<Integer>());          // Duplicate element         final Integer obj1 = Integer.valueOf(1);         final Integer obj2 = Integer.valueOf(2);          lset.add(obj1);         lset.add(obj2);         lset.set(0, obj1);         assertEquals(2, lset.size());         assertSame(obj1, lset.get(0));         assertSame(obj2, lset.get(1));          assertTrue(lset.contains(obj1));         assertTrue(lset.contains(obj2));     }      @SuppressWarnings("unchecked")     public void testSetDownwardsInList() {         /*          * Checks the following semantics          * [a,b]          * set(0,b): [b]->a          * So UniqList contains [b] and a is returned          */         final ArrayList<E> l = new ArrayList<>();         final HashSet<E> s = new HashSet<>();         final SetUniqueList<E> ul = new SetUniqueList<>(l, s);          final E a = (E) new Object();         final E b = (E) new Object();         ul.add(a);         ul.add(b);         assertEquals(a, l.get(0));         assertEquals(b, l.get(1));         assertTrue(s.contains(a));         assertTrue(s.contains(b));          assertEquals(a, ul.set(0, b));         assertEquals(1, s.size());         assertEquals(1, l.size());         assertEquals(b, l.get(0));         assertTrue(s.contains(b));         assertFalse(s.contains(a));     }     @SuppressWarnings("unchecked")     public void testSetInBiggerList() {         /*          * Checks the following semantics          * [a,b,c]          * set(0,b): [b,c]->a          * So UniqList contains [b,c] and a is returned          */         final ArrayList<E> l = new ArrayList<>();         final HashSet<E> s = new HashSet<>();         final SetUniqueList<E> ul = new SetUniqueList<>(l, s);          final E a = (E) new Object();         final E b = (E) new Object();         final E c = (E) new Object();          ul.add(a);         ul.add(b);         ul.add(c);         assertEquals(a, l.get(0));         assertEquals(b, l.get(1));         assertEquals(c, l.get(2));         assertTrue(s.contains(a));         assertTrue(s.contains(b));         assertTrue(s.contains(c));          assertEquals(a, ul.set(0, b));         assertEquals(2, s.size());         assertEquals(2, l.size());         assertEquals(b, l.get(0));         assertEquals(c, l.get(1));         assertFalse(s.contains(a));         assertTrue(s.contains(b));         assertTrue(s.contains(c));     }      @SuppressWarnings("unchecked")     public void testSetUpwardsInList() {         /*          * Checks the following semantics          * [a,b,c]          * set(1,a): [a,c]->b          * So UniqList contains [a,c] and b is returned          */         final ArrayList<E> l = new ArrayList<>();         final HashSet<E> s = new HashSet<>();         final SetUniqueList<E> ul = new SetUniqueList<>(l, s);          final E a = (E) "A";         final E b = (E) "B";         final E c = (E) "C";          ul.add(a);         ul.add(b);         ul.add(c);         assertEquals(a, l.get(0));         assertEquals(b, l.get(1));         assertEquals(c, l.get(2));         assertTrue(s.contains(a));         assertTrue(s.contains(b));         assertTrue(s.contains(c));          assertEquals(b, ul.set(1, a));         assertEquals(2, s.size());         assertEquals(2, l.size());         assertEquals(a, l.get(0));         assertEquals(c, l.get(1));         assertTrue(s.contains(a));         assertFalse(s.contains(b));         assertTrue(s.contains(c));     }      public void testSubListIsUnmodifiable() {         resetFull();         final List<E> subList = getCollection().subList(1, 3);         try {             subList.remove(0);             fail("subList should be unmodifiable");         } catch (final UnsupportedOperationException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testUniqueListDoubleInsert() {         final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());         l.add((E) new Object());         l.add((E) new Object());          // duplicate is removed         l.set(0, l.get(1));         assertEquals(1, l.size());          // duplicate should be removed again         l.add(1, l.get(0));         assertEquals(1, l.size());     }      @SuppressWarnings("unchecked")     public void testUniqueListReInsert() {         final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());         l.add((E) new Object());         l.add((E) new Object());          final E a = l.get(0);          // duplicate is removed         l.set(0, l.get(1));         assertEquals(1, l.size());          // old object is added back in         l.add(1, a);         assertEquals(2, l.size());     }      @Override     @SuppressWarnings("unchecked")     public void verify() {         super.verify();          if (extraVerify) {             final int size = getCollection().size();             getCollection().add((E) new Long(1000));             assertEquals(size + 1, getCollection().size());              getCollection().add((E) new Long(1000));             assertEquals(size + 1, getCollection().size());             assertEquals(new Long(1000), getCollection().get(size));              getCollection().remove(size);         }     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SetUniqueList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SetUniqueList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import org.junit.Assert;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  /**  * Extension of {@link AbstractListTest} for exercising the {@link FixedSizeList}  * implementation.  *  * @since 3.0  */ public class FixedSizeListTest<E> extends AbstractListTest<E> {      public FixedSizeListTest(final String testName) {         super(testName);     }      @Override     public List<E> makeObject() {         return FixedSizeList.fixedSizeList(new ArrayList<E>());     }      @Override     public List<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return FixedSizeList.fixedSizeList(list);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/FixedSizeList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/FixedSizeList.fullCollection.version4.obj"); //    }      public void testListAllowsMutationOfUnderlyingCollection() {          final List<String> decoratedList = new ArrayList<>();         decoratedList.add("item 1");         decoratedList.add("item 2");         //         final FixedSizeList<String> fixedSizeList = FixedSizeList.fixedSizeList(decoratedList);         final int sizeBefore = fixedSizeList.size();         //         final boolean changed = decoratedList.add("New Value");         Assert.assertTrue(changed);         //         Assert.assertEquals("Modifying an the underlying list is allowed",                 sizeBefore + 1, fixedSizeList.size());     }      private FixedSizeList<String> initFixedSizeList() {         final List<String> decoratedList = new ArrayList<>();         decoratedList.add("item 1");         decoratedList.add("item 2");         //         return FixedSizeList.fixedSizeList(decoratedList);     }      public void testAdd() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          try {             fixedSizeList.add(2, "New Value");             fail();         } catch (final UnsupportedOperationException ex) {}     }       public void testAddAll() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          final List<String> addList = new ArrayList<>();         addList.add("item 3");         addList.add("item 4");          try {             fixedSizeList.addAll(2, addList);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testRemove() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          try {             fixedSizeList.remove(1);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testSubList() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          final List<String> subFixedSizeList = fixedSizeList.subList(1, 1);         Assert.assertNotNull(subFixedSizeList);         Assert.assertEquals(0, subFixedSizeList.size());     }      public void testIsFull() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          Assert.assertTrue(fixedSizeList.isFull());     }      public void testMaxSize() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          Assert.assertEquals(2, fixedSizeList.maxSize());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Test class.  *  */ public class CursorableLinkedListTest<E> extends AbstractLinkedListTest<E> {     public CursorableLinkedListTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(CursorableLinkedListTest.class);     }      private CursorableLinkedList<E> list;      @Override     public void setUp() {         list = new CursorableLinkedList<>();     }      @Override     public CursorableLinkedList<E> makeObject() {         return new CursorableLinkedList<>();     }      @SuppressWarnings("unchecked")     public void testAdd() {         assertEquals("[]", list.toString());         assertTrue(list.add((E) Integer.valueOf(1)));         assertEquals("[1]", list.toString());         assertTrue(list.add((E) Integer.valueOf(2)));         assertEquals("[1, 2]", list.toString());         assertTrue(list.add((E) Integer.valueOf(3)));         assertEquals("[1, 2, 3]", list.toString());         assertTrue(list.addFirst((E) Integer.valueOf(0)));         assertEquals("[0, 1, 2, 3]", list.toString());         assertTrue(list.addLast((E) Integer.valueOf(4)));         assertEquals("[0, 1, 2, 3, 4]", list.toString());         list.add(0, (E) Integer.valueOf(-2));         assertEquals("[-2, 0, 1, 2, 3, 4]", list.toString());         list.add(1, (E) Integer.valueOf(-1));         assertEquals("[-2, -1, 0, 1, 2, 3, 4]", list.toString());         list.add(7, (E) Integer.valueOf(5));         assertEquals("[-2, -1, 0, 1, 2, 3, 4, 5]", list.toString());          final List<E> list2 = new LinkedList<>();         list2.add((E) "A");         list2.add((E) "B");         list2.add((E) "C");          assertTrue(list.addAll(list2));         assertEquals("[-2, -1, 0, 1, 2, 3, 4, 5, A, B, C]", list.toString());         assertTrue(list.addAll(3, list2));         assertEquals("[-2, -1, 0, A, B, C, 1, 2, 3, 4, 5, A, B, C]", list.toString());     }      @SuppressWarnings("unchecked")     public void testClear() {         assertEquals(0, list.size());         assertTrue(list.isEmpty());         list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());          list.add((E) "element");         assertEquals(1, list.size());         assertTrue(!list.isEmpty());          list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());          list.add((E) "element1");         list.add((E) "element2");         assertEquals(2, list.size());         assertTrue(!list.isEmpty());          list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());          for (int i = 0; i < 1000; i++) {             list.add((E) Integer.valueOf(i));         }         assertEquals(1000, list.size());         assertTrue(!list.isEmpty());          list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());     }      @SuppressWarnings("unchecked")     public void testContains() {         assertTrue(!list.contains("A"));         assertTrue(list.add((E) "A"));         assertTrue(list.contains("A"));         assertTrue(list.add((E) "B"));         assertTrue(list.contains("A"));         assertTrue(list.addFirst((E) "a"));         assertTrue(list.contains("A"));         assertTrue(list.remove("a"));         assertTrue(list.contains("A"));         assertTrue(list.remove("A"));         assertTrue(!list.contains("A"));     }      @SuppressWarnings("unchecked")     public void testContainsAll() {         assertTrue(list.containsAll(list));         final java.util.List<E> list2 = new java.util.LinkedList<>();         assertTrue(list.containsAll(list2));         list2.add((E) "A");         assertTrue(!list.containsAll(list2));         list.add((E) "B");         list.add((E) "A");         assertTrue(list.containsAll(list2));         list2.add((E) "B");         assertTrue(list.containsAll(list2));         list2.add((E) "C");         assertTrue(!list.containsAll(list2));         list.add((E) "C");         assertTrue(list.containsAll(list2));         list2.add((E) "C");         assertTrue(list.containsAll(list2));         assertTrue(list.containsAll(list));     }      @SuppressWarnings("unchecked")     public void testCursorNavigation() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         final CursorableLinkedList.Cursor<E> it = list.cursor();         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("3", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("4", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("5", it.next());         assertTrue(!it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("5", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("4", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("3", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorSet() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> it = list.cursor();         assertEquals("1", it.next());         it.set((E) "a");         assertEquals("a", it.previous());         it.set((E) "A");         assertEquals("A", it.next());         assertEquals("2", it.next());         it.set((E) "B");         assertEquals("3", it.next());         assertEquals("4", it.next());         it.set((E) "D");         assertEquals("5", it.next());         it.set((E) "E");         assertEquals("[A, B, 3, D, E]", list.toString());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorRemove() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> it = list.cursor();         try {             it.remove();             fail();         } catch (final IllegalStateException e) {             // expected         }         assertEquals("1", it.next());         assertEquals("2", it.next());         assertEquals("[1, 2, 3, 4, 5]", list.toString());         it.remove();         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("3", it.next());         assertEquals("3", it.previous());         assertEquals("1", it.previous());         it.remove();         assertEquals("[3, 4, 5]", list.toString());         assertTrue(!it.hasPrevious());         assertEquals("3", it.next());         it.remove();         assertEquals("[4, 5]", list.toString());         try {             it.remove();         } catch (final IllegalStateException e) {             // expected         }         assertEquals("4", it.next());         assertEquals("5", it.next());         it.remove();         assertEquals("[4]", list.toString());         assertEquals("4", it.previous());         it.remove();         assertEquals("[]", list.toString());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorAdd() {         final CursorableLinkedList.Cursor<E> it = list.cursor();         it.add((E) "1");         assertEquals("[1]", list.toString());         it.add((E) "3");         assertEquals("[1, 3]", list.toString());         it.add((E) "5");         assertEquals("[1, 3, 5]", list.toString());         assertEquals("5", it.previous());         it.add((E) "4");         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("4", it.previous());         assertEquals("3", it.previous());         it.add((E) "2");         assertEquals("[1, 2, 3, 4, 5]", list.toString());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorConcurrentModification() {         // this test verifies that cursors remain valid when the list         // is modified via other means.         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");         list.add((E) "7");         list.add((E) "9");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         final CursorableLinkedList.Cursor<E> c2 = list.cursor();         final Iterator<E> li = list.iterator();          // test cursors remain valid when list modified by std Iterator         // test cursors skip elements removed via ListIterator         assertEquals("1", li.next());         assertEquals("2", li.next());         li.remove();         assertEquals("3", li.next());         assertEquals("1", c1.next());         assertEquals("3", c1.next());         assertEquals("1", c2.next());          // test cursor c1 can remove elements from previously modified list         // test cursor c2 skips elements removed via different cursor         c1.remove();         assertEquals("5", c2.next());         c2.add((E) "6");         assertEquals("5", c1.next());         assertEquals("6", c1.next());         assertEquals("7", c1.next());          // test cursors remain valid when list mod via CursorableLinkedList         // test cursor remains valid when elements inserted into list before         // the current position of the cursor.         list.add(0, (E) "0");          // test cursor remains valid when element inserted immediately after         // current element of a cursor, and the element is seen on the         // next call to the next method of that cursor.         list.add(5, (E) "8");          assertEquals("8", c1.next());         assertEquals("9", c1.next());         c1.add((E) "10");         assertEquals("7", c2.next());         assertEquals("8", c2.next());         assertEquals("9", c2.next());         assertEquals("10", c2.next());          try {             c2.next();             fail();         } catch (final NoSuchElementException nse) {         }          try {             li.next();             fail();         } catch (final ConcurrentModificationException cme) {         }          c1.close(); // not necessary         c2.close(); // not necessary     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexMid() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         final Iterator<E> li = list.iterator();          // test cursors remain valid when list modified by std Iterator         // test cursors skip elements removed via ListIterator         assertEquals("1", li.next());         assertEquals("2", li.next());         li.remove();         assertEquals(0, c1.nextIndex());         assertEquals("1", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("3", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexFirst() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         list.remove(0);         assertEquals(0, c1.nextIndex());         assertEquals("2", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("3", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexAddBefore() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         assertEquals("1", c1.next());         list.add(0, (E) "0");         assertEquals(2, c1.nextIndex());         assertEquals("2", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexAddNext() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         list.add(0, (E) "0");         assertEquals(0, c1.nextIndex());         assertEquals("0", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("1", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexAddAfter() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         list.add(1, (E) "0");         assertEquals(0, c1.nextIndex());         assertEquals("1", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("0", c1.next());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          assertEquals("B", list.remove(1));          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(true, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());          assertEquals("B", list.remove(1));          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals("A", c1.current.value);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         c1.remove();  // works ok         assertEquals("[C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          assertEquals("B", list.remove(1));          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(true, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextNextRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("C", c1.next());          assertEquals("B", list.remove(1));          assertEquals(false, c1.nextIndexValid);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals("C", c1.current.value);         assertEquals("D", c1.next.value);          assertEquals("[A, C, D]", list.toString());         c1.remove();  // works ok         assertEquals("[A, D]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousRemoveByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          c1.remove();          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextRemoveByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          c1.remove();          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousAddIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          list.add(1, (E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals("B", c1.current.value);         assertEquals("Z", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, Z, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextAddIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());          list.add(1, (E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals("A", c1.current.value);         assertEquals("Z", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         c1.remove();  // works ok         assertEquals("[Z, B, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextAddIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          list.add(1, (E) "Z");          assertEquals(false, c1.nextIndexValid);         assertEquals("B", c1.current.value);         assertEquals("C", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, Z, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousAddByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          c1.add((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(2, c1.nextIndex);         assertEquals(null, c1.current);         assertEquals("B", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextAddByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          c1.add((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(3, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, B, Z, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextRemoveByListSetByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          list.remove(1);          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);         assertEquals("[A, C]", list.toString());          try {             c1.set((E) "Z");             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousSetByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          c1.set((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals("Z", c1.current.value);         assertEquals("Z", c1.next.value);          assertEquals("[A, Z, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextSetByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          c1.set((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(2, c1.nextIndex);         assertEquals("Z", c1.current.value);         assertEquals("C", c1.next.value);          assertEquals("[A, Z, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEqualsAndHashCode() {         assertTrue(list.equals(list));         assertEquals(list.hashCode(), list.hashCode());         list.add((E) "A");         assertTrue(list.equals(list));         assertEquals(list.hashCode(), list.hashCode());          final CursorableLinkedList<E> list2 = new CursorableLinkedList<>();         assertTrue(!list.equals(list2));         assertTrue(!list2.equals(list));          final java.util.List<E> list3 = new java.util.LinkedList<>();         assertTrue(!list.equals(list3));         assertTrue(!list3.equals(list));         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list2.hashCode(), list3.hashCode());          list2.add((E) "A");         assertTrue(list.equals(list2));         assertTrue(list2.equals(list));         assertTrue(!list2.equals(list3));         assertTrue(!list3.equals(list2));          list3.add((E) "A");         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list2.hashCode(), list3.hashCode());          list.add((E) "B");         assertTrue(list.equals(list));         assertTrue(!list.equals(list2));         assertTrue(!list2.equals(list));         assertTrue(!list.equals(list3));         assertTrue(!list3.equals(list));          list2.add((E) "B");         list3.add((E) "B");         assertTrue(list.equals(list));         assertTrue(list.equals(list2));         assertTrue(list2.equals(list));         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list2.hashCode(), list3.hashCode());          list.add((E) "C");         list2.add((E) "C");         list3.add((E) "C");         assertTrue(list.equals(list));         assertTrue(list.equals(list2));         assertTrue(list2.equals(list));         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list.hashCode(), list2.hashCode());         assertEquals(list2.hashCode(), list3.hashCode());          list.add((E) "D");         list2.addFirst((E) "D");         assertTrue(list.equals(list));         assertTrue(!list.equals(list2));         assertTrue(!list2.equals(list));     }      @SuppressWarnings("unchecked")     public void testGet() {         try {             list.get(0);             fail("shouldn't get here");         } catch(final IndexOutOfBoundsException e) {             // expected         }          assertTrue(list.add((E) "A"));         assertEquals("A", list.get(0));         assertTrue(list.add((E) "B"));         assertEquals("A", list.get(0));         assertEquals("B", list.get(1));          try {             list.get(-1);             fail("shouldn't get here");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(2);             fail("shouldn't get here");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testIndexOf() {         assertEquals(-1, list.indexOf("A"));         assertEquals(-1, list.lastIndexOf("A"));         list.add((E) "A");         assertEquals(0, list.indexOf("A"));         assertEquals(0, list.lastIndexOf("A"));         assertEquals(-1, list.indexOf("B"));         assertEquals(-1, list.lastIndexOf("B"));         list.add((E) "B");         assertEquals(0, list.indexOf("A"));         assertEquals(0, list.lastIndexOf("A"));         assertEquals(1, list.indexOf("B"));         assertEquals(1, list.lastIndexOf("B"));         list.addFirst((E) "B");         assertEquals(1, list.indexOf("A"));         assertEquals(1, list.lastIndexOf("A"));         assertEquals(0, list.indexOf("B"));         assertEquals(2, list.lastIndexOf("B"));     }      @SuppressWarnings("unchecked")     public void testIsEmpty() {         assertTrue(list.isEmpty());         list.add((E) "element");         assertTrue(!list.isEmpty());         list.remove("element");         assertTrue(list.isEmpty());         list.add((E) "element");         assertTrue(!list.isEmpty());         list.clear();         assertTrue(list.isEmpty());     }      @SuppressWarnings("unchecked")     public void testIterator() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         Iterator<E> it = list.iterator();         assertTrue(it.hasNext());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertEquals("3", it.next());         assertTrue(it.hasNext());         assertEquals("4", it.next());         assertTrue(it.hasNext());         assertEquals("5", it.next());         assertTrue(!it.hasNext());          it = list.iterator();         assertTrue(it.hasNext());         assertEquals("1", it.next());         it.remove();         assertEquals("[2, 3, 4, 5]", list.toString());         assertTrue(it.hasNext());         assertEquals("2", it.next());         it.remove();         assertEquals("[3, 4, 5]", list.toString());         assertTrue(it.hasNext());         assertEquals("3", it.next());         it.remove();         assertEquals("[4, 5]", list.toString());         assertTrue(it.hasNext());         assertEquals("4", it.next());         it.remove();         assertEquals("[5]", list.toString());         assertTrue(it.hasNext());         assertEquals("5", it.next());         it.remove();         assertEquals("[]", list.toString());         assertTrue(!it.hasNext());     }      @SuppressWarnings("unchecked")     public void testListIteratorNavigation() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         final ListIterator<E> it = list.listIterator();         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals(-1, it.previousIndex());         assertEquals(0, it.nextIndex());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals(-1, it.previousIndex());         assertEquals(0, it.nextIndex());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals(2, it.nextIndex());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals(2, it.nextIndex());         assertEquals("3", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(2, it.previousIndex());         assertEquals(3, it.nextIndex());         assertEquals("4", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(3, it.previousIndex());         assertEquals(4, it.nextIndex());         assertEquals("5", it.next());         assertTrue(!it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(4, it.previousIndex());         assertEquals(5, it.nextIndex());         assertEquals("5", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(3, it.previousIndex());         assertEquals(4, it.nextIndex());         assertEquals("4", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(2, it.previousIndex());         assertEquals(3, it.nextIndex());         assertEquals("3", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals(2, it.nextIndex());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals(-1, it.previousIndex());         assertEquals(0, it.nextIndex());     }      @Override     @SuppressWarnings("unchecked")     public void testListIteratorSet() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final ListIterator<E> it = list.listIterator();         assertEquals("1", it.next());         it.set((E) "a");         assertEquals("a", it.previous());         it.set((E) "A");         assertEquals("A", it.next());         assertEquals("2", it.next());         it.set((E) "B");         assertEquals("3", it.next());         assertEquals("4", it.next());         it.set((E) "D");         assertEquals("5", it.next());         it.set((E) "E");         assertEquals("[A, B, 3, D, E]", list.toString());     }      @SuppressWarnings("unchecked")     public void testListIteratorRemove() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final ListIterator<E> it = list.listIterator();         try {             it.remove();         } catch(final IllegalStateException e) {             // expected         }         assertEquals("1", it.next());         assertEquals("2", it.next());         assertEquals("[1, 2, 3, 4, 5]", list.toString());         it.remove();         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("3", it.next());         assertEquals("3", it.previous());         assertEquals("1", it.previous());         it.remove();         assertEquals("[3, 4, 5]", list.toString());         assertTrue(!it.hasPrevious());         assertEquals("3", it.next());         it.remove();         assertEquals("[4, 5]", list.toString());         try {             it.remove();         } catch (final IllegalStateException e) {             // expected         }         assertEquals("4", it.next());         assertEquals("5", it.next());         it.remove();         assertEquals("[4]", list.toString());         assertEquals("4", it.previous());         it.remove();         assertEquals("[]", list.toString());     }      @Override     @SuppressWarnings("unchecked")     public void testListIteratorAdd() {         final ListIterator<E> it = list.listIterator();         it.add((E) "1");         assertEquals("[1]", list.toString());         it.add((E) "3");         assertEquals("[1, 3]", list.toString());         it.add((E) "5");         assertEquals("[1, 3, 5]", list.toString());         assertEquals("5", it.previous());         it.add((E) "4");         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("4", it.previous());         assertEquals("3", it.previous());         it.add((E) "2");         assertEquals("[1, 2, 3, 4, 5]", list.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveAll() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final HashSet<E> set = new HashSet<>();         set.add((E) "A");         set.add((E) "2");         set.add((E) "C");         set.add((E) "4");         set.add((E) "D");          assertTrue(list.removeAll(set));         assertEquals("[1, 3, 5]", list.toString());         assertTrue(!list.removeAll(set));     }      @SuppressWarnings("unchecked")     public void testRemoveByIndex() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         assertEquals("[1, 2, 3, 4, 5]", list.toString());         assertEquals("1", list.remove(0));         assertEquals("[2, 3, 4, 5]", list.toString());         assertEquals("3", list.remove(1));         assertEquals("[2, 4, 5]", list.toString());         assertEquals("4", list.remove(1));         assertEquals("[2, 5]", list.toString());         assertEquals("5", list.remove(1));         assertEquals("[2]", list.toString());         assertEquals("2", list.remove(0));         assertEquals("[]", list.toString());     }      @SuppressWarnings("unchecked")     public void testRemove() {         list.add((E) "1");         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         assertEquals("[1, 1, 2, 3, 4, 5, 2, 3, 4, 5]", list.toString());         assertTrue(!list.remove("6"));         assertTrue(list.remove("5"));         assertEquals("[1, 1, 2, 3, 4, 2, 3, 4, 5]", list.toString());         assertTrue(list.remove("5"));         assertEquals("[1, 1, 2, 3, 4, 2, 3, 4]", list.toString());         assertTrue(!list.remove("5"));         assertTrue(list.remove("1"));         assertEquals("[1, 2, 3, 4, 2, 3, 4]", list.toString());         assertTrue(list.remove("1"));         assertEquals("[2, 3, 4, 2, 3, 4]", list.toString());         assertTrue(list.remove("2"));         assertEquals("[3, 4, 2, 3, 4]", list.toString());         assertTrue(list.remove("2"));         assertEquals("[3, 4, 3, 4]", list.toString());         assertTrue(list.remove("3"));         assertEquals("[4, 3, 4]", list.toString());         assertTrue(list.remove("3"));         assertEquals("[4, 4]", list.toString());         assertTrue(list.remove("4"));         assertEquals("[4]", list.toString());         assertTrue(list.remove("4"));         assertEquals("[]", list.toString());     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         list.add((E) "1");         list.add((E) "1");         list.add((E) "2");         list.add((E) "2");         list.add((E) "3");         list.add((E) "3");         list.add((E) "4");         list.add((E) "4");         list.add((E) "5");         list.add((E) "5");          final HashSet<E> set = new HashSet<>();         set.add((E) "A");         set.add((E) "2");         set.add((E) "C");         set.add((E) "4");         set.add((E) "D");          assertTrue(list.retainAll(set));         assertEquals("[2, 2, 4, 4]", list.toString());         assertTrue(!list.retainAll(set));     }      @SuppressWarnings("unchecked")     public void testSet() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         assertEquals("[1, 2, 3, 4, 5]", list.toString());         list.set(0, (E) "A");         assertEquals("[A, 2, 3, 4, 5]", list.toString());         list.set(1, (E) "B");         assertEquals("[A, B, 3, 4, 5]", list.toString());         list.set(2, (E) "C");         assertEquals("[A, B, C, 4, 5]", list.toString());         list.set(3, (E) "D");         assertEquals("[A, B, C, D, 5]", list.toString());         list.set(4, (E) "E");         assertEquals("[A, B, C, D, E]", list.toString());     }      @SuppressWarnings("unchecked")     public void testSubList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          assertEquals("[A, B, C, D, E]", list.toString());         assertEquals("[A, B, C, D, E]", list.subList(0, 5).toString());         assertEquals("[B, C, D, E]", list.subList(1, 5).toString());         assertEquals("[C, D, E]", list.subList(2, 5).toString());         assertEquals("[D, E]", list.subList(3, 5).toString());         assertEquals("[E]", list.subList(4, 5).toString());         assertEquals("[]", list.subList(5, 5).toString());     }      @SuppressWarnings("unchecked")     public void testSubListAddEnd() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(5, 5);         sublist.add((E) "F");         assertEquals("[A, B, C, D, E, F]", list.toString());         assertEquals("[F]", sublist.toString());         sublist.add((E) "G");         assertEquals("[A, B, C, D, E, F, G]", list.toString());         assertEquals("[F, G]", sublist.toString());     }      @SuppressWarnings("unchecked")     public void testSubListAddBegin() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(0, 0);         sublist.add((E) "a");         assertEquals("[a, A, B, C, D, E]", list.toString());         assertEquals("[a]", sublist.toString());         sublist.add((E) "b");         assertEquals("[a, b, A, B, C, D, E]", list.toString());         assertEquals("[a, b]", sublist.toString());     }      @SuppressWarnings("unchecked")     public void testSubListAddMiddle() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(1, 3);         sublist.add((E) "a");         assertEquals("[A, B, C, a, D, E]", list.toString());         assertEquals("[B, C, a]", sublist.toString());         sublist.add((E) "b");         assertEquals("[A, B, C, a, b, D, E]", list.toString());         assertEquals("[B, C, a, b]", sublist.toString());     }      @SuppressWarnings("unchecked")     public void testSubListRemove() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(1, 4);         assertEquals("[B, C, D]", sublist.toString());         assertEquals("[A, B, C, D, E]", list.toString());         sublist.remove("C");         assertEquals("[B, D]", sublist.toString());         assertEquals("[A, B, D, E]", list.toString());         sublist.remove(1);         assertEquals("[B]", sublist.toString());         assertEquals("[A, B, E]", list.toString());         sublist.clear();         assertEquals("[]", sublist.toString());         assertEquals("[A, E]", list.toString());     }      @SuppressWarnings("unchecked")     public void testToArray() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final Object[] elts = list.toArray();         assertEquals("1", elts[0]);         assertEquals("2", elts[1]);         assertEquals("3", elts[2]);         assertEquals("4", elts[3]);         assertEquals("5", elts[4]);         assertEquals(5, elts.length);          final String[] elts2 = list.toArray(new String[0]);         assertEquals("1", elts2[0]);         assertEquals("2", elts2[1]);         assertEquals("3", elts2[2]);         assertEquals("4", elts2[3]);         assertEquals("5", elts2[4]);         assertEquals(5, elts2.length);          final String[] elts3 = new String[5];         assertSame(elts3, list.toArray(elts3));         assertEquals("1", elts3[0]);         assertEquals("2", elts3[1]);         assertEquals("3", elts3[2]);         assertEquals("4", elts3[3]);         assertEquals("5", elts3[4]);         assertEquals(5, elts3.length);          final String[] elts4 = new String[3];         final String[] elts4b = list.toArray(elts4);         assertTrue(elts4 != elts4b);         assertEquals("1", elts4b[0]);         assertEquals("2", elts4b[1]);         assertEquals("3", elts4b[2]);         assertEquals("4", elts4b[3]);         assertEquals("5", elts4b[4]);         assertEquals(5, elts4b.length);     }      @SuppressWarnings("unchecked")     public void testSerialization() throws Exception {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();         final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);         out.writeObject(list);         out.flush();         out.close();          final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());         final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);         final Object list2 = in.readObject();          assertTrue(list != list2);         assertTrue(list2.equals(list));         assertTrue(list.equals(list2));     }      @SuppressWarnings("unchecked")     public void testSerializationWithOpenCursor() throws Exception {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");         final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();         final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);         out.writeObject(list);         out.flush();         out.close();          final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());         final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);         final Object list2 = in.readObject();          assertTrue(list != list2);         assertTrue(list2.equals(list));         assertTrue(list.equals(list2));     }      @SuppressWarnings("unchecked")     public void testLongSerialization() throws Exception {         // recursive serialization will cause a stack         // overflow exception with long lists         for (int i = 0; i < 10000; i++) {             list.add((E) Integer.valueOf(i));         }          final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();         final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);         out.writeObject(list);         out.flush();         out.close();          final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());         final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);         final Object list2 = in.readObject();          assertTrue(list != list2);         assertTrue(list2.equals(list));         assertTrue(list.equals(list2));     }      /**      *  Ignore the serialization tests for sublists and sub-sublists.      *      *  @return an array of sublist serialization test names      */     @Override     public String[] ignoredTests() {         final ArrayList<String> list = new ArrayList<>();         final String prefix = "CursorableLinkedListTest";         final String bulk = ".bulkTestSubList";         final String[] ignored = new String[] {             ".testEmptyListSerialization",             ".testFullListSerialization",             ".testEmptyListCompatibility",             ".testFullListCompatibility",             ".testSimpleSerialization",             ".testCanonicalEmptyCollectionExists",             ".testCanonicalFullCollectionExists",             ".testSerializeDeserializeThenCompare"         };         for (final String element : ignored) {             list.add(prefix + bulk + element);             list.add(prefix + bulk + bulk + element);         }         return list.toArray(new String[0]);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CursorableLinkedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CursorableLinkedList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.io.IOException; import java.io.Serializable; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.AbstractCollection; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.iterators.AbstractListIteratorTest;  /**  * Abstract test class for {@link java.util.List} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your {@link List} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link List} fails or override one of the  * protected methods from AbstractCollectionTest.  *  */ public abstract class AbstractListTest<E> extends AbstractCollectionTest<E> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the <code>set operation.<p>      *  Default implementation returns true.  Override if your collection      *  class does not support set.      */     public boolean isSetSupported() {         return true;     }      //-----------------------------------------------------------------------     /**      *  Verifies that the test list implementation matches the confirmed list      *  implementation.      */     @Override     @SuppressWarnings("unchecked")     public void verify() {         super.verify();          final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          assertEquals("List should equal confirmed", list1, list2);         assertEquals("Confirmed should equal list", list2, list1);          assertEquals("Hash codes should be equal", list1.hashCode(), list2.hashCode());          int i = 0;         final Iterator<E> iterator1 = list1.iterator();         final Iterator<E> iterator2 = list2.iterator();         final E[] array = (E[]) list1.toArray();         while (iterator2.hasNext()) {             assertTrue("List iterator should have next", iterator1.hasNext());             final Object o1 = iterator1.next();             Object o2 = iterator2.next();             assertEquals("Iterator elements should be equal", o1, o2);             o2 = list1.get(i);             assertEquals("get should return correct element", o1, o2);             o2 = array[i];             assertEquals("toArray should have correct element", o1, o2);             i++;         }     }      //-----------------------------------------------------------------------     /**      * List equals method is defined.      */     @Override     public boolean isEqualsCheckable() {         return true;     }      /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedCollection() {         final ArrayList<E> list = new ArrayList<>();         return list;     }      /**      * Returns a full {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      /**      * Returns {@link #makeObject()}.      *      * @return an empty list to be used for testing      */     @Override     public abstract List<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public List<E> makeFullCollection() {         // only works if list supports optional "addAll(Collection)"         final List<E> list = makeObject();         list.addAll(Arrays.asList(getFullElements()));         return list;     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link List}.      *      * @return the collection field as a List      */     @Override     public List<E> getCollection() {         return (List<E>) super.getCollection();     }      /**      * Returns the {@link #confirmed} field cast to a {@link List}.      *      * @return the confirmed field as a List      */     @Override     public List<E> getConfirmed() {         return (List<E>) super.getConfirmed();     }      //-----------------------------------------------------------------------     /**      *  Tests bounds checking for {@link List#add(int, Object)} on an      *  empty list.      */     public void testListAddByIndexBoundsChecking() {         if (!isAddSupported()) {             return;         }          List<E> list;         final E element = getOtherElements()[0];          try {             list = makeObject();             list.add(Integer.MIN_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeObject();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeObject();             list.add(1, element);             fail("List.add should throw IndexOutOfBoundsException [1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeObject();             list.add(Integer.MAX_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests bounds checking for {@link List#add(int, Object)} on a      *  full list.      */     public void testListAddByIndexBoundsChecking2() {         if (!isAddSupported()) {             return;         }          List<E> list;         final E element = getOtherElements()[0];          try {             list = makeFullCollection();             list.add(Integer.MIN_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeFullCollection();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeFullCollection();             list.add(list.size() + 1, element);             fail("List.add should throw IndexOutOfBoundsException [size + 1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeFullCollection();             list.add(Integer.MAX_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests {@link List#add(int,Object)}.      */     public void testListAddByIndex() {         if (!isAddSupported()) {             return;         }          final E element = getOtherElements()[0];         final int max = getFullElements().length;          for (int i = 0; i <= max; i++) {             resetFull();             getCollection().add(i, element);             getConfirmed().add(i, element);             verify();         }     }      /**      *  Tests {@link List#equals(Object)}.      */     public void testListEquals() {         resetEmpty();         List<E> list = getCollection();         assertEquals("Empty lists should be equal", true, list.equals(getConfirmed()));         verify();         assertEquals("Empty list should equal self", true, list.equals(list));         verify();          List<E> list2 = Arrays.asList(getFullElements());         assertEquals("Empty list shouldn't equal full", false, list.equals(list2));         verify();          list2 = Arrays.asList(getOtherElements());         assertEquals("Empty list shouldn't equal other", false, list.equals(list2));         verify();          resetFull();         list = getCollection();         assertEquals("Full lists should be equal", true, list.equals(getConfirmed()));         verify();         assertEquals("Full list should equal self", true, list.equals(list));         verify();          list2 = makeObject();         assertEquals("Full list shouldn't equal empty", false, list.equals(list2));         verify();          list2 = Arrays.asList(getOtherElements());         assertEquals("Full list shouldn't equal other", false, list.equals(list2));         verify();          list2 = Arrays.asList(getFullElements());         if (list2.size() < 2 && isAddSupported()) {             // main list is only size 1, so lets add other elements to get a better list             list.addAll(Arrays.asList(getOtherElements()));             getConfirmed().addAll(Arrays.asList(getOtherElements()));             list2 = new ArrayList<>(list2);             list2.addAll(Arrays.asList(getOtherElements()));         }         if (list2.size() > 1) {             Collections.reverse(list2);             assertEquals(                 "Full list shouldn't equal full list with same elements but different order",                 false, list.equals(list2));             verify();         }          resetFull();         list = getCollection();         assertEquals("List shouldn't equal String", false, list.equals(""));         verify();          final List<E> listForC = Arrays.asList(getFullElements());         final Collection<E> c = new AbstractCollection<E>() {             @Override             public int size() {                 return listForC.size();             }              @Override             public Iterator<E> iterator() {                 return listForC.iterator();             }         };          assertEquals("List shouldn't equal nonlist with same elements in same order", false, list.equals(c));         verify();     }      /**      *  Tests {@link List#hashCode()}.      */     public void testListHashCode() {         resetEmpty();         int hash1 = getCollection().hashCode();         int hash2 = getConfirmed().hashCode();         assertEquals("Empty lists should have equal hashCodes", hash1, hash2);         verify();          resetFull();         hash1 = getCollection().hashCode();         hash2 = getConfirmed().hashCode();         assertEquals("Full lists should have equal hashCodes", hash1, hash2);         verify();     }      /**      *  Tests {@link List#get(int)}.      */     public void testListGetByIndex() {         resetFull();         final List<E> list = getCollection();         final E[] elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             assertEquals("List should contain correct elements", elements[i], list.get(i));             verify();         }     }      /**      *  Tests bounds checking for {@link List#get(int)} on an      *  empty list.      */     public void testListGetByIndexBoundsChecking() {         final List<E> list = makeObject();          try {             list.get(Integer.MIN_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(-1);             fail("List.get should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(0);             fail("List.get should throw IndexOutOfBoundsException [0]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(1);             fail("List.get should throw IndexOutOfBoundsException [1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(Integer.MAX_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests bounds checking for {@link List#get(int)} on a      *  full list.      */     public void testListGetByIndexBoundsChecking2() {         final List<E> list = makeFullCollection();          try {             list.get(Integer.MIN_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(-1);             fail("List.get should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(getFullElements().length);             fail("List.get should throw IndexOutOfBoundsException [size]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(Integer.MAX_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests {@link List#indexOf}.      */     public void testListIndexOf() {         resetFull();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          for (final E element : list2) {             assertEquals("indexOf should return correct result",                     list1.indexOf(element), list2.indexOf(element));             verify();         }          final E[] other = getOtherElements();         for (final E element : other) {             assertEquals("indexOf should return -1 for nonexistent element",                 -1, list1.indexOf(element));             verify();         }     }      /**      *  Tests {@link List#lastIndexOf}.      */     public void testListLastIndexOf() {         resetFull();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          final Iterator<E> iterator = list2.iterator();         while (iterator.hasNext()) {             final E element = iterator.next();             assertEquals("lastIndexOf should return correct result",                 list1.lastIndexOf(element), list2.lastIndexOf(element));             verify();         }          final E[] other = getOtherElements();         for (final E element : other) {             assertEquals("lastIndexOf should return -1 for nonexistent " +                 "element", -1, list1.lastIndexOf(element));             verify();         }     }      /**      *  Tests bounds checking for {@link List#set(int,Object)} on an      *  empty list.      */     public void testListSetByIndexBoundsChecking() {         if (!isSetSupported()) {             return;         }          final List<E> list = makeObject();         final E element = getOtherElements()[0];          try {             list.set(Integer.MIN_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(0, element);             fail("List.set should throw IndexOutOfBoundsException [0]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(1, element);             fail("List.set should throw IndexOutOfBoundsException [1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(Integer.MAX_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }       /**      *  Tests bounds checking for {@link List#set(int,Object)} on a      *  full list.      */     public void testListSetByIndexBoundsChecking2() {         if (!isSetSupported()) {             return;         }          final List<E> list = makeFullCollection();         final E element = getOtherElements()[0];          try {             list.set(Integer.MIN_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException " +                 "[Integer.MIN_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(getFullElements().length, element);             fail("List.set should throw IndexOutOfBoundsException [size]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(Integer.MAX_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException " +                 "[Integer.MAX_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }       /**      *  Test {@link List#set(int,Object)}.      */     public void testListSetByIndex() {         if (!isSetSupported()) {             return;         }          resetFull();         final E[] elements = getFullElements();         final E[] other = getOtherElements();          for (int i = 0; i < elements.length; i++) {             final E n = other[i % other.length];             final E v = getCollection().set(i, n);             assertEquals("Set should return correct element", elements[i], v);             getConfirmed().set(i, n);             verify();         }     }      /**      *  If {@link #isSetSupported()} returns false, tests that set operation      *  raises <Code>UnsupportedOperationException.      */     public void testUnsupportedSet() {         if (isSetSupported()) {             return;         }          resetFull();         try {             getCollection().set(0, getFullElements()[0]);             fail("Empty collection should not support set.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();     }      /**      *  Tests bounds checking for {@link List#remove(int)} on an      *  empty list.      */     public void testListRemoveByIndexBoundsChecking() {         if (!isRemoveSupported()) {             return;         }          final List<E> list = makeObject();          try {             list.remove(Integer.MIN_VALUE);             fail("List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(-1);             fail("List.remove should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(0);             fail("List.remove should throw IndexOutOfBoundsException [0]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(1);             fail("List.remove should throw IndexOutOfBoundsException [1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(Integer.MAX_VALUE);             fail("List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests bounds checking for {@link List#remove(int)} on a      *  full list.      */     public void testListRemoveByIndexBoundsChecking2() {         if (!isRemoveSupported()) {             return;         }          final List<E> list = makeFullCollection();          try {             list.remove(Integer.MIN_VALUE);             fail("List.remove should throw IndexOutOfBoundsException " +                 "[Integer.MIN_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(-1);             fail("List.remove should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(getFullElements().length);             fail("List.remove should throw IndexOutOfBoundsException [size]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(Integer.MAX_VALUE);             fail("List.remove should throw IndexOutOfBoundsException " +                 "[Integer.MAX_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }       /**      *  Tests {@link List#remove(int)}.      */     public void testListRemoveByIndex() {         if (!isRemoveSupported()) {             return;         }          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             resetFull();             final E o1 = getCollection().remove(i);             final E o2 = getConfirmed().remove(i);             assertEquals("remove should return correct element", o1, o2);             verify();         }     }      /**      *  Tests the read-only bits of {@link List#listIterator()}.      */     public void testListListIterator() {         resetFull();         forwardTest(getCollection().listIterator(), 0);         backwardTest(getCollection().listIterator(), 0);     }      /**      *  Tests the read-only bits of {@link List#listIterator(int)}.      */     public void testListListIteratorByIndex() {         resetFull();         try {             getCollection().listIterator(-1);         } catch (final IndexOutOfBoundsException ex) {}         resetFull();         try {             getCollection().listIterator(getCollection().size() + 1);         } catch (final IndexOutOfBoundsException ex) {}         resetFull();         for (int i = 0; i <= getConfirmed().size(); i++) {             forwardTest(getCollection().listIterator(i), i);             backwardTest(getCollection().listIterator(i), i);         }         resetFull();         for (int i = 0; i <= getConfirmed().size(); i++) {             backwardTest(getCollection().listIterator(i), i);         }     }      //-----------------------------------------------------------------------     /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorPreviousRemoveNext() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         final E two2 = it.previous();         final E one2 = it.previous();         assertEquals(one, one2);         assertEquals(two, two2);         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));          it.remove(); // removed element at index 1 (one)         assertEquals(zero, getCollection().get(0));         assertEquals(two, getCollection().get(1));         final E two3 = it.next();  // do next after remove         assertEquals(two, two3);         assertEquals(getCollection().size() > 2, it.hasNext());         assertEquals(true, it.hasPrevious());     }      /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorPreviousRemovePrevious() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         final E two2 = it.previous();         final E one2 = it.previous();         assertEquals(one, one2);         assertEquals(two, two2);         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));          it.remove(); // removed element at index 1 (one)         assertEquals(zero, getCollection().get(0));         assertEquals(two, getCollection().get(1));         final E zero3 = it.previous();  // do previous after remove         assertEquals(zero, zero3);         assertEquals(false, it.hasPrevious());         assertEquals(getCollection().size() > 2, it.hasNext());     }      /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorNextRemoveNext() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));         final E three = getCollection().get(3);          it.remove(); // removed element at index 2 (two)         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         final E three2 = it.next();  // do next after remove         assertEquals(three, three2);         assertEquals(getCollection().size() > 3, it.hasNext());         assertEquals(true, it.hasPrevious());     }      /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorNextRemovePrevious() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));          it.remove(); // removed element at index 2 (two)         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         final E one2 = it.previous();  // do previous after remove         assertEquals(one, one2);         assertEquals(true, it.hasNext());         assertEquals(true, it.hasPrevious());     }      //-----------------------------------------------------------------------     /**      *  Traverses to the end of the given iterator.      *      *  @param iter  the iterator to traverse      *  @param i     the starting index      */     private void forwardTest(final ListIterator<E> iter, int i) {         final List<E> list = getCollection();         final int max = getFullElements().length;          while (i < max) {             assertTrue("Iterator should have next", iter.hasNext());             assertEquals("Iterator.nextIndex should work",                 i, iter.nextIndex());             assertEquals("Iterator.previousIndex should work",                 i - 1, iter.previousIndex());             final Object o = iter.next();             assertEquals("Iterator returned correct element", list.get(i), o);             i++;         }          assertTrue("Iterator shouldn't have next", !iter.hasNext());         assertEquals("nextIndex should be size", max, iter.nextIndex());         assertEquals("previousIndex should be size - 1", max - 1, iter.previousIndex());          try {             iter.next();             fail("Exhausted iterator should raise NoSuchElement");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      *  Traverses to the beginning of the given iterator.      *      *  @param iter  the iterator to traverse      *  @param i     the starting index      */     private void backwardTest(final ListIterator<E> iter, int i) {         final List<E> list = getCollection();          while (i > 0) {             assertTrue("Iterator should have previous, i:" + i,                 iter.hasPrevious());             assertEquals("Iterator.nextIndex should work, i:" + i,                 i, iter.nextIndex());             assertEquals("Iterator.previousIndex should work, i:" + i,                 i - 1, iter.previousIndex());             final E o = iter.previous();             assertEquals("Iterator returned correct element",                 list.get(i - 1), o);             i--;         }          assertTrue("Iterator shouldn't have previous", !iter.hasPrevious());         final int nextIndex = iter.nextIndex();         assertEquals("nextIndex should be 0", 0, nextIndex);         final int prevIndex = iter.previousIndex();         assertEquals("previousIndex should be -1", -1, prevIndex);          try {             iter.previous();             fail("Exhausted iterator should raise NoSuchElement");         } catch (final NoSuchElementException e) {             // expected         }      }       /**      *  Tests the {@link ListIterator#add(Object)} method of the list      *  iterator.      */     public void testListIteratorAdd() {         if (!isAddSupported()) {             return;         }          resetEmpty();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          final E[] elements = getFullElements();         ListIterator<E> iter1 = list1.listIterator();         ListIterator<E> iter2 = list2.listIterator();          for (final E element : elements) {             iter1.add(element);             iter2.add(element);             verify();         }          resetFull();         iter1 = getCollection().listIterator();         iter2 = getConfirmed().listIterator();         for (final E element : elements) {             iter1.next();             iter2.next();             iter1.add(element);             iter2.add(element);             verify();         }     }      /**      *  Tests the {@link ListIterator#set(Object)} method of the list      *  iterator.      */     public void testListIteratorSet() {         if (!isSetSupported()) {             return;         }          final E[] elements = getFullElements();          resetFull();         final ListIterator<E> iter1 = getCollection().listIterator();         final ListIterator<E> iter2 = getConfirmed().listIterator();         for (final E element : elements) {             iter1.next();             iter2.next();             iter1.set(element);             iter2.set(element);             verify();         }     }      @SuppressWarnings("unchecked")     public void testEmptyListSerialization() throws IOException, ClassNotFoundException {         final List<E> list = makeObject();         if (!(list instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) list);         final List<E> list2 = (List<E>) readExternalFormFromBytes(object);          assertEquals("Both lists are empty", 0, list.size());         assertEquals("Both lists are empty", 0, list2.size());     }      @SuppressWarnings("unchecked")     public void testFullListSerialization() throws IOException, ClassNotFoundException {         final List<E> list = makeFullCollection();         final int size = getFullElements().length;         if (!(list instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) list);         final List<E> list2 = (List<E>) readExternalFormFromBytes(object);          assertEquals("Both lists are same size", size, list.size());         assertEquals("Both lists are same size", size, list2.size());     }      /**      * Compare the current serialized form of the List      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         List list = makeEmptyList();         if (!(list instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));         */          // test to make sure the canonical form has been preserved         final List<E> list = makeObject();         if (list instanceof Serializable && !skipSerializedCanonicalTests()                 && isTestSerialization()) {             final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));             assertEquals("List is empty", 0, list2.size());             assertEquals(list, list2);         }     }      /**      * Compare the current serialized form of the List      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testFullListCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         List list = makeFullList();         if (!(list instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));         */          // test to make sure the canonical form has been preserved         final List<E> list = makeFullCollection();         if (list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));             if (list2.size() == 4) {                 // old serialized tests                 return;             }             assertEquals("List is the right size", list.size(), list2.size());             assertEquals(list, list2);         }     }      //-----------------------------------------------------------------------     /**      *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.      *  The returned bulk test will run through every {@code TestList}      *  method, <i>including</i> another {@code bulkTestSubList}.      *  Sublists are tested until the size of the sublist is less than 10.      *  Each sublist is 6 elements smaller than its parent list.      *  (By default this means that two rounds of sublists will be tested).      *  The verify() method is overloaded to test that the original list is      *  modified when the sublist is.      */     public BulkTest bulkTestSubList() {         if (getFullElements().length - 6 < 10) {             return null;         }         return new BulkTestSubList<>(this);     }      public static class BulkTestSubList<E> extends AbstractListTest<E> {          private final AbstractListTest<E> outer;          public BulkTestSubList(final AbstractListTest<E> outer) {             super("");             this.outer = outer;         }          @Override         @SuppressWarnings("unchecked")         public E[] getFullElements() {             final List<E> l = Arrays.asList(outer.getFullElements());             return (E[]) l.subList(3, l.size() - 3).toArray();         }          @Override         public E[] getOtherElements() {             return outer.getOtherElements();         }          @Override         public boolean isAddSupported() {             return outer.isAddSupported();         }          @Override         public boolean isSetSupported() {             return outer.isSetSupported();         }          @Override         public boolean isRemoveSupported() {             return outer.isRemoveSupported();         }          @Override         public List<E> makeObject() {             return outer.makeFullCollection().subList(4, 4);         }          @Override         public List<E> makeFullCollection() {             final int size = getFullElements().length;             return outer.makeFullCollection().subList(3, size - 3);         }          @Override         public void resetEmpty() {             outer.resetFull();             this.setCollection(outer.getCollection().subList(4, 4));             this.setConfirmed(outer.getConfirmed().subList(4, 4));         }          @Override         public void resetFull() {             outer.resetFull();             final int size = outer.getConfirmed().size();             this.setCollection(outer.getCollection().subList(3, size - 3));             this.setConfirmed(outer.getConfirmed().subList(3, size - 3));         }          @Override         public void verify() {             super.verify();             outer.verify();         }          @Override         public boolean isTestSerialization() {             return false;         }     }      /**      * Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}      * if elements are added to the original list.      */     public void testListSubListFailFastOnAdd() {         if (!isFailFastSupported()) {             return;         }         if (!isAddSupported()) {             return;         }          resetFull();         final int size = getCollection().size();         List<E> sub = getCollection().subList(1, size);         getCollection().add(getOtherElements()[0]);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().add(0, getOtherElements()[0]);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().addAll(Arrays.asList(getOtherElements()));         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().addAll(0, Arrays.asList(getOtherElements()));         failFastAll(sub);     }      /**      * Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}      * if elements are removed from the original list.      */     public void testListSubListFailFastOnRemove() {         if (!isFailFastSupported()) {             return;         }         if (!isRemoveSupported()) {             return;         }          resetFull();         final int size = getCollection().size();         List<E> sub = getCollection().subList(1, size);         getCollection().remove(0);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().remove(getFullElements()[2]);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().removeAll(Arrays.asList(getFullElements()));         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().retainAll(Arrays.asList(getOtherElements()));         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().clear();         failFastAll(sub);     }      /**      * Invokes all the methods on the given sublist to make sure they raise      * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.      */     protected void failFastAll(final List<E> list) {         final Method[] methods = List.class.getMethods();         for (final Method method : methods) {             failFastMethod(list, method);         }     }      /**      * Invokes the given method on the given sublist to make sure it raises      * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.      *      * Unless the method happens to be the equals() method, in which case      * the test is skipped. There seems to be a bug in      * java.util.AbstractList.subList(int,int).equals(Object) -- it never      * raises a ConcurrentModificationException.      *      * @param list the sublist to test      * @param m the method to invoke      */     protected void failFastMethod(final List<E> list, final Method m) {         if (m.getName().equals("equals")) {             return;         }          final E element = getOtherElements()[0];         final Collection<E> c = Collections.singleton(element);          final Class<?>[] types = m.getParameterTypes();         final Object[] params = new Object[types.length];         for (int i = 0; i < params.length; i++) {             if (types[i] == Integer.TYPE) {                 params[i] = Integer.valueOf(0);             } else if (types[i] == Collection.class) {                 params[i] = c;             } else if (types[i] == Object.class) {                 params[i] = element;             } else if (types[i] == Object[].class) {                 params[i] = new Object[0];             }         }          try {             m.invoke(list, params);             fail(m.getName() + " should raise ConcurrentModification");         } catch (final IllegalAccessException e) {             // impossible         } catch (final InvocationTargetException e) {             final Throwable t = e.getTargetException();             if (t instanceof ConcurrentModificationException) {                 // expected                 return;             }             fail(m.getName() + " raised unexpected " + e);         }     }      // -----------------------------------------------------------------------     public BulkTest bulkTestListIterator() {         return new TestListIterator();     }      public class TestListIterator extends AbstractListIteratorTest<E> {         public TestListIterator() {             super("TestListIterator");         }          @Override         public E addSetValue() {             return AbstractListTest.this.getOtherElements()[0];         }          @Override         public boolean supportsRemove() {             return AbstractListTest.this.isRemoveSupported();         }          @Override         public boolean supportsAdd() {             return AbstractListTest.this.isAddSupported();         }          @Override         public boolean supportsSet() {             return AbstractListTest.this.isSetSupported();         }          @Override         public ListIterator<E> makeEmptyIterator() {             resetEmpty();             return AbstractListTest.this.getCollection().listIterator();         }          @Override         public ListIterator<E> makeObject() {             resetFull();             return AbstractListTest.this.getCollection().listIterator();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  import org.junit.Assert; import org.junit.Test;  /**  * Tests for COLLECTIONS-701.  */ public class Collections701Test {      @Test     public void testArrayList() {         final List<Object> list = new ArrayList<>();         list.add(list);         Assert.assertEquals(1, list.size());         Assert.assertEquals(list, list.get(0));     }      @Test     public void testHashSet() {         final Set<Object> set = new HashSet<>();         set.add(set);         Assert.assertEquals(1, set.size());         Assert.assertEquals(set, set.iterator().next());     }      @Test     public void testSetUniqueList() {         final List<Object> source = new ArrayList<>();         final List<Object> list = SetUniqueList.setUniqueList(source);         list.add(list);         Assert.assertEquals(1, list.size());         Assert.assertEquals(list, list.get(0));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractListTest} for exercising the  * {@link PredicatedList} implementation.  *  * @since 3.0  */ public class PredicatedListTest<E> extends AbstractListTest<E> {      public PredicatedListTest(final String testName) {         super(testName);     }   //-------------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected List<E> decorateList(final List<E> list, final Predicate<E> predicate) {         return PredicatedList.predicatedList(list, predicate);     }      @Override     public List<E> makeObject() {         return decorateList(new ArrayList<E>(), truePredicate);     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };     }  //--------------------------------------------------------------------      protected Predicate<E> testPredicate =         o -> o instanceof String;      public List<E> makeTestList() {         return decorateList(new ArrayList<E>(), testPredicate);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final List<E> list = makeTestList();         final Integer i = Integer.valueOf(3);         try {             list.add((E) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !list.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final List<E> list = makeTestList();         final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) Integer.valueOf(3));         elements.add((E) "four");         try {             list.addAll(0, elements);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("List shouldn't contain illegal element", !list.contains("one"));         assertTrue("List shouldn't contain illegal element", !list.contains("two"));         assertTrue("List shouldn't contain illegal element", !list.contains(Integer.valueOf(3)));         assertTrue("List shouldn't contain illegal element", !list.contains("four"));     }      @SuppressWarnings("unchecked")     public void testIllegalSet() {         final List<E> list = makeTestList();         try {             list.set(0, (E) Integer.valueOf(3));             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testLegalAddAll() {         final List<E> list = makeTestList();         list.add((E) "zero");         final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) "three");         list.addAll(1, elements);         assertTrue("List should contain legal element", list.contains("zero"));         assertTrue("List should contain legal element", list.contains("one"));         assertTrue("List should contain legal element", list.contains("two"));         assertTrue("List should contain legal element", list.contains("three"));     }      public void testSubList() {         final List<E> list = makeTestList();         list.add((E) "zero");         //subList without any element of list         List<E> subList = list.subList(0, 0);         assertNotNull(subList);         assertEquals(0, subList.size());          //subList with one element oif list         subList = list.subList(0, 1);         assertEquals(1, subList.size());          final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) "three");         list.addAll(1, elements);         //subList with all elements of list         subList = list.subList(0, list.size());         assertEquals(list.size(), subList.size());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.splitmap;  import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.math.BigInteger; import java.util.HashMap;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.NOPTransformer;  /**  * Tests for {@link TransformedSplitMap}  *  * @since 4.0  */ @SuppressWarnings("boxing") public class TransformedSplitMapTest extends BulkTest {      private final Transformer<Integer, String> intToString = String::valueOf;      private final Transformer<Object, Class<?>> objectToClass = input -> input == null ? null : input.getClass();      private final Transformer<String, Integer> stringToInt = Integer::valueOf;      public TransformedSplitMapTest(final String testName) {         super(testName);     }      // -----------------------------------------------------------------------     public void testTransformedMap() {         final TransformedSplitMap<Integer, String, Object, Class<?>> map = TransformedSplitMap.transformingMap(                 new HashMap<String, Class<?>>(), intToString, objectToClass);          final Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };         final Object[] v = new Object[] { "", new Object(), new HashMap<>(), 0, BigInteger.TEN, null,             new Object[0] };          assertEquals(0, map.size());         for (int i = 0; i < k.length; i++) {             map.put(k[i], v[i]);             assertEquals(i + 1, map.size());             assertTrue(map.containsKey(intToString.transform(k[i])));             assertFalse(map.containsKey(k[i]));             assertTrue(map.containsValue(objectToClass.transform(v[i])));             assertTrue(objectToClass.transform(v[i]) != v[i] ^ map.containsValue(v[i]));             assertEquals(objectToClass.transform(v[i]), map.get(intToString.transform(k[i])));         }          int sz = map.size();         assertEquals(null, map.remove(k[0]));         assertEquals(sz, map.size());         assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));         assertEquals(--sz, map.size());          final TransformedSplitMap<String, String, String, Integer> map2 = TransformedSplitMap.transformingMap(                 new HashMap<String, Integer>(), NOPTransformer.<String>nopTransformer(), stringToInt);         assertEquals(0, map2.size());         for (int i = 0; i < 6; i++) {             map2.put(String.valueOf(i), String.valueOf(i));             assertEquals(i + 1, map2.size());             assertTrue(map2.containsValue(i));             assertFalse(map2.containsValue(String.valueOf(i)));             assertTrue(map2.containsKey(String.valueOf(i)));             assertEquals(i, map2.get(String.valueOf(i)).intValue());         }          int sz2 = map2.size();         assertEquals(Integer.valueOf(0), map2.remove("0"));         assertEquals(--sz2, map2.size());     }      // -----------------------------------------------------------------------      public void testMapIterator() {         final TransformedSplitMap<String, String, String, Integer> map =                 TransformedSplitMap.transformingMap(new HashMap<String, Integer>(),                                                     NOPTransformer.<String>nopTransformer(), stringToInt);         assertEquals(0, map.size());         for (int i = 0; i < 6; i++) {             map.put(String.valueOf(i), String.valueOf(i));         }          for (final MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {             final String k = it.next();             assertEquals(k, it.getKey());             assertEquals(map.get(k), it.getValue());         }     }      public void testEmptyMap() throws IOException, ClassNotFoundException {         final TransformedSplitMap<String, String, String, String> map =                 TransformedSplitMap.transformingMap(new HashMap<String, String>(),                                                     NOPTransformer.<String>nopTransformer(),                                                     NOPTransformer.<String>nopTransformer() );          final ObjectInputStream in =                 new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+"/TransformedSplitMap.emptyCollection.version4.obj" ) );         final Object readObject = in.readObject();         in.close();          final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;         assertTrue( "Map should be empty", readMap.size() == 0 );         assertEquals( map.entrySet(), readMap.entrySet() );     }      public void testFullMap() throws IOException, ClassNotFoundException {         final TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap(                 new HashMap<String, String>(),                 NOPTransformer.<String>nopTransformer(),                 NOPTransformer.<String>nopTransformer() );         map.put( "a", "b" );         map.put( "c", "d" );         map.put( "e", "f" );         map.put( "g", "h" );          final ObjectInputStream in =                 new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+"TransformedSplitMap.fullCollection.version4.obj" ) );         final Object readObject = in.readObject();         in.close();          final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;         assertFalse( "Map should not be empty", readMap.size() == 0 );         assertEquals( map.entrySet(), readMap.entrySet() );     }  //    public void testCreate() throws IOException { //        TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap( //                new HashMap<String, String>(), //                NOPTransformer.<String>nopTransformer(), //                NOPTransformer.<String>nopTransformer() ); // //        ObjectOutputStream out = new ObjectOutputStream( //                new FileOutputStream( "src/test/resources/data/test/TransformedSplitMap.emptyCollection.version4.obj" ) ); //        out.writeObject( map ); // //        map.put( "a", "b" ); //        map.put( "c", "d" ); //        map.put( "e", "f" ); //        map.put( "g", "h" ); // //        out = new ObjectOutputStream( //                new FileOutputStream( "src/test/resources/data/test/TransformedSplitMap.fullCollection.version4.obj" ) ); //        out.writeObject( map ); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.io.FileNotFoundException; import java.io.IOException; import java.io.Serializable; import java.util.Collections; import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.apache.commons.collections4.AbstractObjectTest; import org.junit.Test;  /**  * Abstract test class for testing the Comparator interface.  * <p>  * Concrete subclasses declare the comparator to be tested.  * They also declare certain aspects of the tests.  */ public abstract class AbstractComparatorTest<T> extends AbstractObjectTest {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractComparatorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------      /**      * Implement this method to return a list of sorted objects.      *      * @return sorted objects      */     public abstract List<T> getComparableObjectsOrdered();      //-----------------------------------------------------------------------     /**      * Implements the abstract superclass method to return the comparator.      *      * @return a full iterator      */     @Override     public abstract Comparator<T> makeObject();      /**      * Overrides superclass to block tests.      */     @Override     public boolean supportsEmptyCollections() {         return false;     }      /**      * Overrides superclass to block tests.      */     @Override     public boolean supportsFullCollections() {         return false;     }      //-----------------------------------------------------------------------     /**      * Reverse the list.      */     protected void reverseObjects(final List<?> list) {         Collections.reverse(list);     }      /**      * Randomize the list.      */     protected void randomizeObjects(final List<?> list) {         Collections.shuffle(list);     }      /**      * Sort the list.      */     protected void sortObjects(final List<T> list, final Comparator<? super T> comparator) {         list.sort(comparator);     }      //-----------------------------------------------------------------------     /**      * Test sorting an empty list      */     @Test     public void testEmptyListSort() {         final List<T> list = new LinkedList<>();         sortObjects(list, makeObject());          final List<T> list2 = new LinkedList<>();          assertEquals("Comparator cannot sort empty lists", list2, list);     }      /**      * Test sorting a reversed list.      */     @Test     public void testReverseListSort() {         final Comparator<T> comparator = makeObject();          final List<T> randomList = getComparableObjectsOrdered();         reverseObjects(randomList);         sortObjects(randomList, comparator);          final List<T> orderedList = getComparableObjectsOrdered();          assertEquals("Comparator did not reorder the List correctly", orderedList, randomList);     }      /**      * Test sorting a random list.      */     @Test     public void testRandomListSort() {         final Comparator<T> comparator = makeObject();          final List<T> randomList = getComparableObjectsOrdered();         randomizeObjects(randomList);         sortObjects(randomList, comparator);          final List<T> orderedList = getComparableObjectsOrdered();          /* debug         Iterator i = randomList.iterator();         while (i.hasNext()) {             System.out.println(i.next());         }         */          assertEquals("Comparator did not reorder the List correctly", orderedList, randomList);     }      /**      * Nearly all Comparators should be Serializable.      */     @Test     public void testComparatorIsSerializable() {         final Comparator<T> comparator = makeObject();         assertTrue("This comparator should be Serializable.",                    comparator instanceof Serializable);     }      public String getCanonicalComparatorName(final Object object) {         final StringBuilder retval = new StringBuilder();         retval.append(TEST_DATA_PATH);         String colName = object.getClass().getName();         colName = colName.substring(colName.lastIndexOf(".") + 1, colName.length());         retval.append(colName);         retval.append(".version");         retval.append(getCompatibilityVersion());         retval.append(".obj");         return retval.toString();     }      /**      * Compare the current serialized form of the Comparator      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     @Test     public void testComparatorCompatibility() throws IOException, ClassNotFoundException {         if (!skipSerializedCanonicalTests()) {             Comparator<T> comparator = null;              // test to make sure the canonical form has been preserved             try {                 comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));             } catch (final FileNotFoundException exception) {                  final boolean autoCreateSerialized = false;                  if (autoCreateSerialized) {                     comparator = makeObject();                     final String fileName = getCanonicalComparatorName(comparator);                     writeExternalFormToDisk((Serializable) comparator, fileName);                     fail("Serialized form could not be found.  A serialized version "                             + "has now been written (and should be added to CVS): " + fileName);                 } else {                     fail("The Serialized form could be located to test serialization "                             + "compatibility: " + exception.getMessage());                 }             }               // make sure the canonical form produces the ordering we currently             // expect             final List<T> randomList = getComparableObjectsOrdered();             reverseObjects(randomList);             sortObjects(randomList, comparator);              final List<T> orderedList = getComparableObjectsOrdered();              assertEquals("Comparator did not reorder the List correctly", orderedList, randomList);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Arrays; import java.util.Comparator; import java.util.LinkedList; import java.util.List; import java.util.Random;  import org.junit.Test;  /**  * Test class for FixedOrderComparator.  *  */ public class FixedOrderComparatorTest extends AbstractComparatorTest<String> {      /**      * Top cities of the world, by population including metro areas.      */     private static final String topCities[] = new String[] {         "Tokyo",         "Mexico City",         "Mumbai",         "Sao Paulo",         "New York",         "Shanghai",         "Lagos",         "Los Angeles",         "Calcutta",         "Buenos Aires"     };      //     // Initialization and busywork     //      public FixedOrderComparatorTest(final String name) {         super(name);     }      //     // Set up and tear down     //      @Override     public Comparator<String> makeObject() {         return new FixedOrderComparator<>(topCities);     }      @Override     public List<String> getComparableObjectsOrdered() {         return Arrays.asList(topCities);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/FixedOrderComparator.version4.obj"); //    }      //     // The tests     //      /**      * Tests that the constructor plus add method compares items properly.      */     @Test     public void testConstructorPlusAdd() {         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>();         for (final String topCity : topCities) {             comparator.add(topCity);         }         final String[] keys = topCities.clone();         assertComparatorYieldsOrder(keys, comparator);     }      /**      * Tests that the array constructor compares items properly.      */     @Test     public void testArrayConstructor() {         final String[] keys = topCities.clone();         final String[] topCitiesForTest = topCities.clone();         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCitiesForTest);         assertComparatorYieldsOrder(keys, comparator);         // test that changing input after constructor has no effect         topCitiesForTest[0] = "Brighton";         assertComparatorYieldsOrder(keys, comparator);     }      /**      * Tests the list constructor.      */     @Test     public void testListConstructor() {         final String[] keys = topCities.clone();         final List<String> topCitiesForTest = new LinkedList<>(Arrays.asList(topCities));         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCitiesForTest);         assertComparatorYieldsOrder(keys, comparator);         // test that changing input after constructor has no effect         topCitiesForTest.set(0, "Brighton");         assertComparatorYieldsOrder(keys, comparator);     }      /**      * Tests addAsEqual method.      */     @Test     public void testAddAsEqual() {         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);         comparator.addAsEqual("New York", "Minneapolis");         assertEquals(0, comparator.compare("New York", "Minneapolis"));         assertEquals(-1, comparator.compare("Tokyo", "Minneapolis"));         assertEquals(1, comparator.compare("Shanghai", "Minneapolis"));     }      /**      * Tests whether or not updates are disabled after a comparison is made.      */     @Test     public void testLock() {         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);         assertFalse(comparator.isLocked());         comparator.compare("New York", "Tokyo");         assertTrue(comparator.isLocked());         try {             comparator.add("Minneapolis");             fail("Should have thrown an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // success -- ignore         }          try {             comparator.addAsEqual("New York", "Minneapolis");             fail("Should have thrown an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // success -- ignore         }     }      @Test     public void testUnknownObjectBehavior() {         FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);         try {             comparator.compare("New York", "Minneapolis");             fail("Should have thrown a IllegalArgumentException");         } catch (final IllegalArgumentException e) {             // success-- ignore         }         try {             comparator.compare("Minneapolis", "New York");             fail("Should have thrown a IllegalArgumentException");         } catch (final IllegalArgumentException e) {             // success-- ignore         }         assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());          comparator = new FixedOrderComparator<>(topCities);         comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);         assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());         LinkedList<String> keys = new LinkedList<>(Arrays.asList(topCities));         keys.addFirst("Minneapolis");         assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);          assertEquals(-1, comparator.compare("Minneapolis", "New York"));         assertEquals( 1, comparator.compare("New York", "Minneapolis"));         assertEquals( 0, comparator.compare("Minneapolis", "St Paul"));          comparator = new FixedOrderComparator<>(topCities);         comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);         keys = new LinkedList<>(Arrays.asList(topCities));         keys.add("Minneapolis");         assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);          assertEquals( 1, comparator.compare("Minneapolis", "New York"));         assertEquals(-1, comparator.compare("New York", "Minneapolis"));         assertEquals( 0, comparator.compare("Minneapolis", "St Paul"));      }      //     // Helper methods     //      /** Shuffles the keys and asserts that the comparator sorts them back to      * their original order.      */     private void assertComparatorYieldsOrder(final String[] orderedObjects,                                              final Comparator<String> comparator) {         final String[] keys = orderedObjects.clone();          // shuffle until the order changes.  It's extremely rare that         // this requires more than one shuffle.          boolean isInNewOrder = false;         final Random rand = new Random();         while (keys.length > 1 && !isInNewOrder) {             // shuffle:             for (int i = keys.length-1; i > 0; i--) {                 final String swap = keys[i];                 final int j = rand.nextInt(i+1);                 keys[i] = keys[j];                 keys[j] = swap;             }              // testShuffle             for (int i = 0; i < keys.length; i++) {                 if (!orderedObjects[i].equals(keys[i])) {                     isInNewOrder = true;                     break;                 }             }         }          // The real test:  sort and make sure they come out right.          Arrays.sort(keys, comparator);          for (int i = 0; i < orderedObjects.length; i++) {             assertEquals(orderedObjects[i], keys[i]);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.apache.commons.collections4.ComparatorUtils; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils;  /**  * Test class for TransformingComparator.  *  */ public class TransformingComparatorTest extends AbstractComparatorTest<Integer> {      //     // Initialization and busywork     //      public TransformingComparatorTest(final String name) {         super(name);     }      //     // Set up and tear down     //      @Override     public Comparator<Integer> makeObject() {         final Comparator<String> decorated = new ComparableComparator<>();         return ComparatorUtils.transformedComparator(decorated, TransformerUtils.<Integer>stringValueTransformer());     }      @Override     @SuppressWarnings("boxing") // OK in test code     public List<Integer> getComparableObjectsOrdered() {         final List<Integer> list = new LinkedList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         list.add(5);         return list;     }      public void testEquals() {         final Transformer<String, String> t1 = TransformerUtils.nopTransformer();         final TransformingComparator<String, String> comp1 = new TransformingComparator<>(t1);         final TransformingComparator<String, String> comp2 = new TransformingComparator<>(t1, comp1);          // Checks the contract: equals-hashcode on comp1 and comp2         assertTrue("Contract failed: equals-hashcode",                 comp1.equals(comp2) ? comp1.hashCode() == comp2.hashCode() : true);          // Checks the contract: equals-hashcode on comp1 and comp2         assertTrue("Contract failed: equals-hashcode",                 comp2.equals(comp1) ? comp2.hashCode() == comp1.hashCode() : true);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/TransformingComparator.version4.obj"); //    }      //     // The tests     //  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.io.Serializable; import java.util.Arrays; import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.junit.Test;  /**  * Tests for ComparatorChain.  *  */ public class ComparatorChainTest extends AbstractComparatorTest<ComparatorChainTest.PseudoRow> {      public ComparatorChainTest(final String testName) {         super(testName);     }      @Override     public Comparator<PseudoRow> makeObject() {         final ComparatorChain<PseudoRow> chain = new ComparatorChain<>(new ColumnComparator(0));         chain.addComparator(new ColumnComparator(1), true); // reverse the second column         chain.addComparator(new ColumnComparator(2), false);         return chain;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/ComparatorChain.version4.obj"); //    }      @Test     public void testNoopComparatorChain() {         final ComparatorChain<Integer> chain = new ComparatorChain<>();         final Integer i1 = 4;         final Integer i2 = 6;         chain.addComparator(new ComparableComparator<>());          final int correctValue = i1.compareTo(i2);         assertEquals("Comparison returns the right order", chain.compare(i1, i2), correctValue);     }      @Test     public void testBadNoopComparatorChain() {         final ComparatorChain<Integer> chain = new ComparatorChain<>();         final Integer i1 = 4;         final Integer i2 = 6;         try {             chain.compare(i1, i2);             fail("An exception should be thrown when a chain contains zero comparators.");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testListComparatorChain() {         final List<Comparator<Integer>> list = new LinkedList<>();         list.add(new ComparableComparator<>());         final ComparatorChain<Integer> chain = new ComparatorChain<>(list);         final Integer i1 = 4;         final Integer i2 = 6;          final int correctValue = i1.compareTo(i2);         assertEquals("Comparison returns the right order", chain.compare(i1, i2), correctValue);     }      @Test     public void testBadListComparatorChain() {         final List<Comparator<Integer>> list = new LinkedList<>();         final ComparatorChain<Integer> chain = new ComparatorChain<>(list);         final Integer i1 = 4;         final Integer i2 = 6;         try {             chain.compare(i1, i2);             fail("An exception should be thrown when a chain contains zero comparators.");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testComparatorChainOnMinvaluedCompatator() {         // -1 * Integer.MIN_VALUE is less than 0,         // test that ComparatorChain handles this edge case correctly         final ComparatorChain<Integer> chain = new ComparatorChain<>();         chain.addComparator((a, b) -> {             final int result = a.compareTo(b);             if (result < 0) {                 return Integer.MIN_VALUE;             }             if (result > 0) {                 return Integer.MAX_VALUE;             }             return 0;         }, true);          assertTrue(chain.compare(4, 5) > 0);         assertTrue(chain.compare(5, 4) < 0);         assertEquals(0, chain.compare(4, 4));     }      @Override     public List<PseudoRow> getComparableObjectsOrdered() {         // this is the correct order assuming a         // "0th forward, 1st reverse, 2nd forward" sort         return new LinkedList<>(Arrays.asList(new PseudoRow(1, 2, 3), new PseudoRow(2, 3, 5),                 new PseudoRow(2, 2, 4), new PseudoRow(2, 2, 8), new PseudoRow(3, 1, 0),                 new PseudoRow(4, 4, 4), new PseudoRow(4, 4, 7)));     }      public static class PseudoRow implements Serializable {          /**          * Generated serial version ID.          */         private static final long serialVersionUID = 8085570439751032499L;         public int[] cols = new int[3];          public PseudoRow(final int col1, final int col2, final int col3) {             cols[0] = col1;             cols[1] = col2;             cols[2] = col3;         }          public int getColumn(final int colIndex) {             return cols[colIndex];         }          @Override         public String toString() {             return "[" + cols[0] + "," + cols[1] + "," + cols[2] + "]";         }          @Override         public boolean equals(final Object o) {             if (!(o instanceof PseudoRow)) {                 return false;             }              final PseudoRow row = (PseudoRow) o;              return getColumn(0) == row.getColumn(0) && getColumn(1) == row.getColumn(1) && getColumn(2) == row.getColumn(2);         }     }      public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {         private static final long serialVersionUID = -2284880866328872105L;          protected int colIndex = 0;          public ColumnComparator(final int colIndex) {             this.colIndex = colIndex;         }          @Override         public int compare(final PseudoRow o1, final PseudoRow o2) {             return Integer.compare(o1.getColumn(colIndex), o2.getColumn(colIndex));         }          @Override         public int hashCode() {             return colIndex;         }          @Override         public boolean equals(final Object that) {             return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import junit.framework.Test; import junit.framework.TestSuite;  /**  * Test the NullComparator.  *  */ public abstract class AbstractNullComparatorTest extends AbstractComparatorTest<Integer> {      public AbstractNullComparatorTest(final String testName) {         super(testName);     }      public static Test suite() {         final TestSuite suite = new TestSuite(AbstractNullComparatorTest.class.getName());         suite.addTest(new TestSuite(TestNullComparator1.class));         suite.addTest(new TestSuite(TestNullComparator2.class));         return suite;     }      /**      *  Test the NullComparator with nulls high, using comparable comparator      **/     public static class TestNullComparator1 extends AbstractNullComparatorTest {          public TestNullComparator1(final String testName) {             super(testName);         }          @Override         public Comparator<Integer> makeObject() {             return new NullComparator<>();         }          @Override         public List<Integer> getComparableObjectsOrdered() {             final List<Integer> list = new LinkedList<>();             list.add(Integer.valueOf(1));             list.add(Integer.valueOf(2));             list.add(Integer.valueOf(3));             list.add(Integer.valueOf(4));             list.add(Integer.valueOf(5));             list.add(null);             return list;         }          @Override         public String getCanonicalComparatorName(final Object object) {             return super.getCanonicalComparatorName(object) + "1";         }          @Override         public String getCompatibilityVersion() {             return "4";         }  //        public void testCreate() throws Exception { //            writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/NullComparator.version4.obj1"); //        }      }      /**      *  Test the NullComparator with nulls low using the comparable comparator      **/     public static class TestNullComparator2 extends AbstractNullComparatorTest {          public TestNullComparator2(final String testName) {             super(testName);         }          @Override         public Comparator<Integer> makeObject() {             return new NullComparator<>(false);         }          @Override         public List<Integer> getComparableObjectsOrdered() {             final List<Integer> list = new LinkedList<>();             list.add(null);             list.add(Integer.valueOf(1));             list.add(Integer.valueOf(2));             list.add(Integer.valueOf(3));             list.add(Integer.valueOf(4));             list.add(Integer.valueOf(5));             return list;         }          @Override         public String getCanonicalComparatorName(final Object object) {             return super.getCanonicalComparatorName(object) + "2";         }          @Override         public String getCompatibilityVersion() {             return "4";         }  //        public void testCreate() throws Exception { //            writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/NullComparator.version4.obj2"); //        }      } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Collections; import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.junit.Test;  /**  * Tests for ReverseComparator.  *  */ public class ReverseComparatorTest extends AbstractComparatorTest<Integer> {      public ReverseComparatorTest(final String testName) {         super(testName);     }      /**      * For the purposes of this test, return a      * ReverseComparator that wraps the java.util.Collections.reverseOrder()      * Comparator.  The resulting comparator should      * sort according to natural Order.  (Note: we wrap      * a Comparator taken from the JDK so that we can      * save a "canonical" form in SCM.      *      * @return Comparator that returns "natural" order      */     @Override     public Comparator<Integer> makeObject() {         return new ReverseComparator<>(Collections.<Integer>reverseOrder());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/ReverseComparator.version4.obj"); //    }      @Override     public List<Integer> getComparableObjectsOrdered() {         final List<Integer> list = new LinkedList<>();         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         list.add(Integer.valueOf(3));         list.add(Integer.valueOf(4));         list.add(Integer.valueOf(5));         return list;     }      /**      * Override this inherited test since Collections.reverseOrder      * doesn't adhere to the "soft" Comparator contract, and we've      * already "canonized" the comparator returned by makeComparator.      */     @Override     @Test     public void testSerializeDeserializeThenCompare() throws Exception {         final Comparator<?> comp = new ReverseComparator<>(new ComparableComparator<String>());          final ByteArrayOutputStream buffer = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(buffer);         out.writeObject(comp);         out.close();          final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));         final Object dest = in.readObject();         in.close();         assertEquals("obj != deserialize(serialize(obj))", comp, dest);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List;  import org.junit.Test;  import static org.junit.Assert.assertNotEquals;  /**  * Tests for {@link BooleanComparator}.  *  */ @SuppressWarnings("boxing") public class BooleanComparatorTest extends AbstractComparatorTest<Boolean> {      // conventional     // ------------------------------------------------------------------------      public BooleanComparatorTest(final String testName) {         super(testName);     }      // collections testing framework     // ------------------------------------------------------------------------      @Override     public Comparator<Boolean> makeObject() {         return new BooleanComparator();     }      @Override     public List<Boolean> getComparableObjectsOrdered() {         return new ArrayList<>(Arrays.asList(Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.TRUE, Boolean.TRUE,                 true));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/BooleanComparator.version4.obj"); //    }      // tests     // ------------------------------------------------------------------------      @Test     public void testConstructors() {         allTests(false, new BooleanComparator());         allTests(false, new BooleanComparator(false));         allTests(true, new BooleanComparator(true));     }      @Test      public void testStaticFactoryMethods() {         allTests(false, BooleanComparator.getFalseFirstComparator());         allTests(false, BooleanComparator.booleanComparator(false));         allTests(true, BooleanComparator.getTrueFirstComparator());         allTests(true, BooleanComparator.booleanComparator(true));     }      @Test     public void testEqualsCompatibleInstance() {         assertEquals(new BooleanComparator(), new BooleanComparator(false));         assertEquals(new BooleanComparator(false), new BooleanComparator(false));         assertEquals(new BooleanComparator(false), BooleanComparator.getFalseFirstComparator());         assertSame(BooleanComparator.getFalseFirstComparator(), BooleanComparator.booleanComparator(false));          assertEquals(new BooleanComparator(true), new BooleanComparator(true));         assertEquals(new BooleanComparator(true), BooleanComparator.getTrueFirstComparator());         assertSame(BooleanComparator.getTrueFirstComparator(), BooleanComparator.booleanComparator(true));          assertNotEquals(new BooleanComparator(), new BooleanComparator(true));         assertNotEquals(new BooleanComparator(true), new BooleanComparator(false));     }      // utilities     // ------------------------------------------------------------------------      protected void allTests(final boolean trueFirst, final BooleanComparator comp) {         orderIndependentTests(comp);         if (trueFirst) {             trueFirstTests(comp);         } else {             falseFirstTests(comp);         }     }      protected void trueFirstTests(final BooleanComparator comp) {         assertNotNull(comp);         assertEquals(0, comp.compare(true, true));         assertEquals(0, comp.compare(false, false));         assertTrue(comp.compare(false, true) > 0);         assertTrue(comp.compare(true, false) < 0);     }      protected void falseFirstTests(final BooleanComparator comp) {         assertNotNull(comp);         assertEquals(0, comp.compare(true, true));         assertEquals(0, comp.compare(false, false));         assertTrue(comp.compare(false, true) < 0);         assertTrue(comp.compare(true, false) > 0);     }      protected void orderIndependentTests(final BooleanComparator comp) {         nullArgumentTests(comp);     }      protected void nullArgumentTests(final BooleanComparator comp) {         assertNotNull(comp);         try {             comp.compare(null, null);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(Boolean.TRUE, null);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(Boolean.FALSE, null);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(null, Boolean.TRUE);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(null, Boolean.FALSE);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Comparator; import java.util.LinkedList; import java.util.List;  /**  * Tests for ComparableComparator.  *  *  */ @SuppressWarnings("boxing") public class ComparableComparatorTest extends AbstractComparatorTest<Integer> {      public ComparableComparatorTest(final String testName) {         super(testName);     }      @Override     public Comparator<Integer> makeObject() {         return new ComparableComparator<>();     }      @Override     public List<Integer> getComparableObjectsOrdered() {         final List<Integer> list = new LinkedList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         list.add(5);         return list;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/ComparableComparator.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape;  import java.util.Arrays; import java.util.PrimitiveIterator.OfInt;  /**  * A Hasher implementation to return fixed indexes. Duplicates are allowed.  * The shape is ignored when generating the indexes.  *  * <p><strong>This is not a real hasher and is used for testing only</strong>.  */ class FixedIndexesTestHasher implements Hasher {     /** The shape. */     private final Shape shape;     /** The indexes. */     private final int[] indexes;      /**      * Create an instance.      *      * @param shape the shape      * @param indexes the indexes      */     FixedIndexesTestHasher(final Shape shape, final int... indexes) {         this.shape = shape;         this.indexes = indexes;     }      @Override     public OfInt iterator(final Shape shape) {         if (!this.shape.equals(shape)) {             throw new IllegalArgumentException(                 String.format("shape (%s) does not match internal shape (%s)", shape, this.shape));         }         return Arrays.stream(indexes).iterator();     }      @Override     public HashFunctionIdentity getHashFunctionIdentity() {         return shape.getHashFunctionIdentity();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape;  /**  * Tests for the {@link BitSetBloomFilter}.  */ public class BitSetBloomFilterTest extends AbstractBloomFilterTest {     @Override     protected BitSetBloomFilter createEmptyFilter(final Shape shape) {         return new BitSetBloomFilter(shape);     }      @Override     protected BitSetBloomFilter createFilter(final Hasher hasher, final Shape shape) {         final BitSetBloomFilter testFilter = new BitSetBloomFilter(shape);         testFilter.merge( hasher );         return testFilter;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import java.util.Arrays; import java.util.HashMap; import java.util.Map; import java.util.concurrent.ThreadLocalRandom; import java.util.function.BiPredicate; import java.util.function.Function; import java.util.function.ToIntBiFunction;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.junit.Test;  /**  * Tests for the {@link ArrayCountingBloomFilter}.  */ public class ArrayCountingBloomFilterTest extends AbstractBloomFilterTest {      /**      * Function to convert int arrays to BloomFilters for testing.      */     private final Function<int[], BloomFilter> converter = counts -> {         final BloomFilter testingFilter = new BitSetBloomFilter(shape);         testingFilter.merge(new FixedIndexesTestHasher(shape, counts));         return testingFilter;     };      @Override     protected ArrayCountingBloomFilter createEmptyFilter(final Shape shape) {         return new ArrayCountingBloomFilter(shape);     }      @Override     protected ArrayCountingBloomFilter createFilter(final Hasher hasher, final Shape shape) {         final ArrayCountingBloomFilter result = new ArrayCountingBloomFilter(shape);         result.merge( hasher );         return result;     }      private ArrayCountingBloomFilter createFromCounts(final int[] counts) {         // Use a dummy filter to add the counts to an empty filter         final CountingBloomFilter dummy = new ArrayCountingBloomFilter(shape) {             @Override             public void forEachCount(final BitCountConsumer action) {                 for (int i = 0; i < counts.length; i++) {                     action.accept(i, counts[i]);                 }             }         };         final ArrayCountingBloomFilter bf = new ArrayCountingBloomFilter(shape);         bf.add(dummy);         return bf;     }      /**      * Assert the counts match the expected values. Values are for indices starting      * at 0. Assert the cardinality equals the number of non-zero counts.      *      * @param bf the bloom filter      * @param expected the expected counts      */     private static void assertCounts(final CountingBloomFilter bf, final int[] expected) {         final Map<Integer, Integer> m = new HashMap<>();         bf.forEachCount(m::put);         int zeros = 0;         for (int i = 0; i < expected.length; i++) {             if (m.get(i) == null) {                 assertEquals("Wrong value for " + i, expected[i], 0);                 zeros++;             } else {                 assertEquals("Wrong value for " + i, expected[i], m.get(i).intValue());             }         }         assertEquals(expected.length - zeros, bf.cardinality());     }      /**      * Tests that counts are correct when a hasher with duplicates is used in the      * constructor.      */     @Test     public void constructorTest_Hasher_Duplicates() {         final int[] expected = {0, 1, 1, 0, 0, 1};         // Some indexes with duplicates         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 2, 5);          final ArrayCountingBloomFilter bf = createFilter(hasher, shape);         final long[] lb = bf.getBits();         assertEquals(1, lb.length);         assertEquals(0b100110L, lb[0]);          assertCounts(bf, expected);     }      /**      * Test the contains function with a standard Bloom filter.      * The contains function is tested using a counting Bloom filter in the parent test class.      */     @Test     public void contains_BloomFilter() {         // Some indexes with duplicates         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 5);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);         BitSetBloomFilter testingFilter = new BitSetBloomFilter(shape);         testingFilter.merge( new FixedIndexesTestHasher(shape, 3, 4));         assertFalse(bf.contains(testingFilter));         testingFilter = new BitSetBloomFilter(shape);         testingFilter.merge( new FixedIndexesTestHasher(shape, 2, 5));         assertTrue(bf.contains(testingFilter));     }      /**      * Tests that merge correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void mergeTest_Counts_CountingBloomFilter() {         assertMerge(counts -> createFilter(new FixedIndexesTestHasher(shape, counts), shape),                 BloomFilter::merge);     }      /**      * Tests that merge correctly updates the counts when a BloomFilter is passed.      */     @Test     public void mergeTest_Counts_BloomFilter() {         assertMerge(converter, BloomFilter::merge);     }      /**      * Test that merge correctly updates the counts when a Hasher is passed.      */     @Test     public void mergeTest_Counts_Hasher() {         assertMerge(counts -> new FixedIndexesTestHasher(shape, counts),                 BloomFilter::merge);     }      /**      * Test that merge correctly updates the counts when a Hasher is passed with duplicates.      */     @Test     public void mergeTest_Counts_Hasher_Duplicates() {         assertMerge(counts -> new FixedIndexesTestHasher(shape, createDuplicates(counts)),                 BloomFilter::merge);     }      /**      * Tests that remove correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void removeTest_Counts_CountingBloomFilter() {         assertRemove(counts -> createFilter(new FixedIndexesTestHasher(shape, counts), shape),                 CountingBloomFilter::remove);     }      /**      * Tests that remove correctly updates the counts when a BloomFilter is passed.      */     @Test     public void removeTest_Counts_BloomFilter() {         assertRemove(converter, CountingBloomFilter::remove);     }      /**      * Test that remove correctly updates the counts when a Hasher is passed.      */     @Test     public void removeTest_Counts_Hasher() {         assertRemove(counts -> new FixedIndexesTestHasher(shape, counts),                 CountingBloomFilter::remove);     }      /**      * Test that remove correctly updates the counts when a Hasher is passed with duplicates.      */     @Test     public void removeTest_Counts_Hasher_Duplicates() {         assertRemove(counts -> new FixedIndexesTestHasher(shape, createDuplicates(counts)),                 CountingBloomFilter::remove);     }      /**      * Creates duplicates in the counts.      *      * @param counts the counts      * @return the new counts      */     private static int[] createDuplicates(final int[] counts) {         // Duplicate some values randomly         final int length = counts.length;         final int[] countsWithDuplicates = Arrays.copyOf(counts, 2 * length);         for (int i = length; i < countsWithDuplicates.length; i++) {             // Copy a random value from the counts into the end position             countsWithDuplicates[i] = countsWithDuplicates[ThreadLocalRandom.current().nextInt(i)];         }         return countsWithDuplicates;     }      /**      * Assert a merge operation. The converter should construct a suitable object      * to remove the indices from the provided Bloom filter with the remove operation.      *      * @param <F> the type of the filter      * @param converter the converter      * @param merge the merge operation      */     private <F> void assertMerge(final Function<int[], F> converter,             final BiPredicate<ArrayCountingBloomFilter, F> merge) {         final int[] indexes1 = {   1, 2,    4, 5, 6};         final int[] indexes2 = {         3, 4,    6};         final int[] expected = {0, 1, 1, 1, 2, 1, 2};         assertOperation(indexes1, indexes2, converter, merge, true, expected);     }      /**      * Assert a remove operation. The converter should construct a suitable object      * to remove the indices from the provided Bloom filter with the remove operation.      *      * @param <F> the type of the filter      * @param converter the converter      * @param remove the remove operation      */     private <F> void assertRemove(final Function<int[], F> converter,             final BiPredicate<ArrayCountingBloomFilter, F> remove) {         final int[] indexes1 = {   1, 2,    4, 5, 6};         final int[] indexes2 = {      2,       5, 6};         final int[] expected = {0, 1, 0, 0, 1, 0, 0};         assertOperation(indexes1, indexes2, converter, remove, true, expected);     }      /**      * Assert a counting operation. The first set of indexes is used to create the      * CountingBloomFilter. The second set of indices is passed to the converter to      * construct a suitable object to combine with the counting Bloom filter. The counts      * of the first Bloom filter are checked using the expected counts.      *      * <p>Counts are assumed to map to indexes starting from 0.      *      * @param <F> the type of the filter      * @param indexes1 the first set of indexes      * @param indexes2 the second set of indexes      * @param converter the converter      * @param operation the operation      * @param isValid the expected value for the operation result      * @param expected the expected counts after the operation      */     private <F> void assertOperation(final int[] indexes1, final int[] indexes2,             final Function<int[], F> converter,             final BiPredicate<ArrayCountingBloomFilter, F> operation,             final boolean isValid, final int[] expected) {         final Hasher hasher = new FixedIndexesTestHasher(shape, indexes1);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);         final F filter = converter.apply(indexes2);         final boolean result = operation.test(bf, filter);         assertEquals(isValid, result);         assertEquals(isValid, bf.isValid());         assertCounts(bf, expected);     }      /**      * Tests that merge errors when the counts overflow the maximum integer value.      */     @Test     public void mergeTest_Overflow() {         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 3);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);          final ArrayCountingBloomFilter bf2 = createFromCounts(new int[] {0, 0, Integer.MAX_VALUE});          // Small + 1 = OK         // should not fail as the counts are ignored         assertTrue(bf.merge(bf2));         assertTrue(bf.isValid());         assertCounts(bf, new int[] {0, 1, 2, 1});          // Big + 1 = Overflow         assertTrue(bf2.isValid());         assertFalse(bf2.merge(bf));         assertFalse("Merge should overflow and the filter is invalid", bf2.isValid());          // The counts are not clipped to max. They have simply overflowed.         // Note that this is a merge and the count is only incremented by 1         // and not the actual count at each index. So it is not 2 + Integer.MAX_VALUE.         assertCounts(bf2, new int[] {0, 1, 1 + Integer.MAX_VALUE, 1});     }      /**      * Tests that removal errors when the counts become negative.      */     @Test     public void removeTest_Negative() {         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 3);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);          final Hasher hasher2 = new FixedIndexesTestHasher(shape, 2);         final ArrayCountingBloomFilter bf2 = createFilter(hasher2, shape);          // More - Less = OK         bf.remove(bf2);         assertTrue(bf.isValid());         assertCounts(bf, new int[] {0, 1, 0, 1});          // Less - More = Negative         assertTrue(bf2.isValid());         bf2.remove(bf);         assertFalse("Remove should create negative counts and the filter is invalid", bf2.isValid());          // The counts are not clipped to zero. They have been left as negative.         assertCounts(bf2, new int[] {0, -1, 1, -1});     }      /**      * Tests that counts can be added to a new instance.      *      * <p>Note: This test ensures the CountingBloomFilter      * can be created with whatever counts are required for other tests.      */     @Test     public void addTest_NewInstance() {         for (final int[] counts : new int[][] {             { /* empty */},             {0, 0, 1},             {0, 1, 2},             {2, 3, 4},             {66, 77, 0, 99},             {Integer.MAX_VALUE, 42},         }) {             assertCounts(createFromCounts(counts), counts);         }     }      /**      * Test that add correctly ignores an empty CountingBloomFilter.      */     @Test     public void addTest_Empty() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[0],                 CountingBloomFilter::add,                 true,                 new int[] {5, 2, 1});     }      /**      * Test that add correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void addTest_Counts() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[] {0, 6, 4, 1},                 CountingBloomFilter::add,                 true,                 new int[] {5, 8, 5, 1});     }      /**      * Test that add correctly updates the isValid state when a CountingBloomFilter is      * passed and an integer overflow occurs.      */     @Test     public void addTest_Overflow() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[] {0, 6, Integer.MAX_VALUE},                 CountingBloomFilter::add,                 false,                 new int[] {5, 8, 1 + Integer.MAX_VALUE});     }      /**      * Test that subtract correctly ignores an empty CountingBloomFilter.      */     @Test     public void subtractTest_Empty() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[0],                 CountingBloomFilter::subtract,                 true,                 new int[] {5, 2, 1});     }      /**      * Test that subtract correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void subtractTest_Counts() {         assertCountingOperation(new int[] {5, 9, 1, 1},                 new int[] {0, 2, 1},                 CountingBloomFilter::subtract,                 true,                 new int[] {5, 7, 0, 1});     }      /**      * Test that subtract correctly updates the isValid state when a CountingBloomFilter is      * passed and the counts become negative.      */     @Test     public void subtractTest_Negative() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[] {0, 6, 1},                 CountingBloomFilter::subtract,                 false,                 new int[] {5, -4, 0});     }      /**      * Assert a counting operation. Two CountingBloomFilters are created from the      * two sets of counts. The operation is applied and the counts of the first      * Bloom filter is checked using the expected counts.      *      * <p>Counts are assumed to map to indexes starting from 0.      *      * @param counts1 the first set counts      * @param counts2 the first set counts      * @param operation the operation      * @param isValid the expected value for the operation result      * @param expected the expected counts after the operation      */     private void assertCountingOperation(final int[] counts1, final int[] counts2,             final BiPredicate<ArrayCountingBloomFilter, ArrayCountingBloomFilter> operation,             final boolean isValid, final int[] expected) {         final ArrayCountingBloomFilter bf1 = createFromCounts(counts1);         final ArrayCountingBloomFilter bf2 = createFromCounts(counts2);         final boolean result = operation.test(bf1, bf2);         assertEquals(isValid, result);         assertEquals(isValid, bf1.isValid());         assertCounts(bf1, expected);     }      /**      * Tests that the andCardinality calculation executes correctly when using a      * CountingBloomFilter argument.      */     @Test     public void andCardinalityTest_CountingBloomFilter() {         assertCardinalityOperation(new int[] {1, 1},                 new int[] {1, 1},                 BloomFilter::andCardinality,                 2);         assertCardinalityOperation(new int[] {0, 1, 0, 1, 1, 1, 0, 1, 0},                 new int[] {1, 1, 0, 0, 0, 1},                 BloomFilter::andCardinality,                 2);         assertCardinalityOperation(new int[] {1, 1},                 new int[] {0, 0, 1, 1, 1},                 BloomFilter::andCardinality,                 0);     }      /**      * Tests that the orCardinality calculation executes correctly when using a      * CountingBloomFilter argument.      */     @Test     public void orCardinalityTest_CountingBloomFilter() {         assertCardinalityOperation(new int[] {1, 1},                 new int[] {1, 1},                 BloomFilter::orCardinality,                 2);         assertCardinalityOperation(new int[] {0, 1, 0, 1, 1, 1, 0, 1, 0},                 new int[] {1, 1, 0, 0, 0, 1},                 BloomFilter::orCardinality,                 6);         assertCardinalityOperation(new int[] {1, 1},                 new int[] {0, 0, 1, 1, 1},                 BloomFilter::orCardinality,                 5);     }      /**      * Tests that the xorCardinality calculation executes correctly when using a      * CountingBloomFilter argument.      */     @Test     public void xorCardinalityTest_CountingBloomFilter() {         assertCardinalityOperation(new int[] {1, 1},                 new int[] {1, 1},                 BloomFilter::xorCardinality,                 0);         assertCardinalityOperation(new int[] {0, 1, 0, 1, 1, 1, 0, 1, 0},                 new int[] {1, 1, 0, 0, 0, 1},                 BloomFilter::xorCardinality,                 4);         assertCardinalityOperation(new int[] {1, 1},                 new int[] {0, 0, 1, 1, 1},                 BloomFilter::xorCardinality,                 5);     }      /**      * Assert a cardinality operation. Two CountingBloomFilters are created from the      * two sets of counts. The operation is applied and the counts of the first      * Bloom filter is checked using the expected counts.      *      * <p>Counts are assumed to map to indexes starting from 0.      *      * @param counts1 the first set counts      * @param counts2 the first set counts      * @param operation the operation      * @param expected the expected cardinality      */     private void assertCardinalityOperation(final int[] counts1, final int[] counts2,             final ToIntBiFunction<ArrayCountingBloomFilter, ArrayCountingBloomFilter> operation,             final int expected) {         final ArrayCountingBloomFilter bf1 = createFromCounts(counts1);         final ArrayCountingBloomFilter bf2 = createFromCounts(counts2);         assertEquals(expected, operation.applyAsInt(bf1, bf2));         assertEquals(expected, operation.applyAsInt(bf2, bf1));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic; import org.junit.Assert; import org.junit.Test; import java.nio.charset.StandardCharsets; import java.util.Arrays; import java.util.PrimitiveIterator.OfInt;  /**  * Tests the {@link HasherBloomFilter}.  */ public class HasherBloomFilterTest extends AbstractBloomFilterTest {      /**      * Tests that the constructor works correctly.      */     @Test     public void constructorTest_NonStatic() {         final Shape shape = new Shape(new MD5Cyclic(), 3, 72, 17);         final DynamicHasher hasher = new DynamicHasher.Builder(new MD5Cyclic()).with("Hello", StandardCharsets.UTF_8).build();         final HasherBloomFilter filter = createFilter(hasher, shape);         final long[] lb = filter.getBits();         assertEquals(2, lb.length);         assertEquals(0x6203101001888c44L, lb[0]);         assertEquals(0x60L, lb[1]);     }      @Override     protected AbstractBloomFilter createEmptyFilter(final Shape shape) {         return new HasherBloomFilter(shape);     }      @Override     protected HasherBloomFilter createFilter(final Hasher hasher, final Shape shape) {         return new HasherBloomFilter(hasher, shape);     }      /**      * Test the edge case where the filter is empty and the getBits() function returns a      * zero length array.      */     @Test     public void getBitsTest_Empty() {         final BloomFilter filter = createEmptyFilter(shape);         Assert.assertArrayEquals(new long[0], filter.getBits());     }      /**      * Test the edge case where the filter has only 1 bit in the lowest index and the getBits()      * function returns an array of length 1.      */     @Test     public void getBitsTest_LowestBitOnly() {         final BloomFilter filter = createEmptyFilter(shape);         // Set the lowest bit index only.         filter.merge(new Hasher() {             @Override             public OfInt iterator(final Shape shape) {                 return Arrays.stream(new int[] {0}).iterator();             }              @Override             public HashFunctionIdentity getHashFunctionIdentity() {                 return shape.getHashFunctionIdentity();             }         });         Assert.assertArrayEquals(new long[] {1L}, filter.getBits());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentityImpl; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness; import org.junit.Assert; import org.junit.Test;  import java.util.ArrayList; import java.util.Arrays; import java.util.Set; import java.util.function.IntConsumer; import java.util.stream.Collectors;  /**  * Tests for the {@link IndexFilters}.  */ public class IndexFilterTest {      /**      * The shape of the dummy Bloom filter.      * This is used as an argument to a Hasher that just returns fixed indexes      * so the parameters do not matter.      */     private final Shape shape = new Shape(new HashFunctionIdentityImpl(         "Apache Commons Collections", "Dummy", Signedness.SIGNED, ProcessType.CYCLIC, 0L),         50, 3000, 4);      @Test     public void testApplyThrowsWithNullArguments() {         final FixedIndexesTestHasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 3);         final Shape shape = this.shape;         final ArrayList<Integer> actual = new ArrayList<>();         final IntConsumer consumer = actual::add;          try {             IndexFilters.distinctIndexes(null, shape, consumer);             Assert.fail("null hasher");         } catch (final NullPointerException expected) {             // Ignore         }          try {             IndexFilters.distinctIndexes(hasher, null, consumer);             Assert.fail("null shape");         } catch (final NullPointerException expected) {             // Ignore         }          try {             IndexFilters.distinctIndexes(hasher, shape, null);             Assert.fail("null consumer");         } catch (final NullPointerException expected) {             // Ignore         }          // All OK together         IndexFilters.distinctIndexes(hasher, shape, consumer);     }      @Test     public void testApply() {         assertFilter(1, 4, 6, 7, 9);     }      @Test     public void testApplyWithDuplicates() {         assertFilter(1, 4, 4, 6, 7, 7, 7, 7, 7, 9);     }      private void assertFilter(final int... indexes) {         final FixedIndexesTestHasher hasher = new FixedIndexesTestHasher(shape, indexes);         final Set<Integer> expected = Arrays.stream(indexes).boxed().collect(Collectors.toSet());         final ArrayList<Integer> actual = new ArrayList<>();          IndexFilters.distinctIndexes(hasher, shape, actual::add);          Assert.assertEquals(expected.size(), actual.size());         // Check the array has all the values.         // We do not currently check the order of indexes from the         // hasher.iterator() function.         for (final Integer index : actual) {             Assert.assertTrue(expected.contains(index));         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals; import java.util.List; import java.util.Arrays; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher; import org.junit.Assert; import org.junit.Test;  /**  * Test {@link SetOperations}.  */ public class SetOperationsTest {      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      private final Shape shape = new Shape(testFunction, 3, 72, 17);      @Test     public void testDifferentShapesThrows() {         final List<Integer> lst = Arrays.asList(1, 2);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          final Shape shape2 = new Shape(testFunction, 3, 72, 18);         final List<Integer> lst2 = Arrays.asList(2, 3);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape2);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape2);          try {             SetOperations.cosineDistance(filter1, filter2);             Assert.fail("Expected an IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // Ignore         }     }      /**      * Tests that the Cosine similarity is correctly calculated.      */     @Test     public final void cosineDistanceTest() {         List<Integer> lst = Arrays.asList(1, 2);         Hasher hasher = new StaticHasher(lst.iterator(), shape);         BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(2, 3);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.5, SetOperations.cosineDistance(filter1, filter2), 0.0001);         assertEquals(0.5, SetOperations.cosineDistance(filter2, filter1), 0.0001);          lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         hasher = new StaticHasher(lst.iterator(), shape);         filter1 = new HasherBloomFilter(hasher, shape);          lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.0, SetOperations.cosineDistance(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.cosineDistance(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.514928749927334, SetOperations.cosineDistance(filter1, filter2), 0.000000000000001);         assertEquals(0.514928749927334, SetOperations.cosineDistance(filter2, filter1), 0.000000000000001);     }      /**      * Tests that the Cosine distance is correctly calculated when one or      * both filters are empty      */     @Test     public final void cosineDistanceTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(1.0, SetOperations.cosineDistance(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.cosineDistance(filter2, filter1), 0.0001);         assertEquals(1.0, SetOperations.cosineDistance(filter1, filter3), 0.0001);         assertEquals(1.0, SetOperations.cosineDistance(filter3, filter1), 0.0001);     }      /**      * Tests that the Cosine similarity is correctly calculated.      */     @Test     public final void cosineSimilarityTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(1.0, SetOperations.cosineSimilarity(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.cosineSimilarity(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.485071250072666, SetOperations.cosineSimilarity(filter1, filter2), 0.000000000000001);         assertEquals(0.485071250072666, SetOperations.cosineSimilarity(filter2, filter1), 0.000000000000001);     }      /**      * Tests that the Cosine similarity is correctly calculated when one or      * both filters are empty      */     @Test     public final void cosineSimilarityTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(0.0, SetOperations.cosineSimilarity(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.cosineSimilarity(filter2, filter1), 0.0001);         assertEquals(0.0, SetOperations.cosineSimilarity(filter1, filter3), 0.0001);         assertEquals(0.0, SetOperations.cosineSimilarity(filter3, filter1), 0.0001);     }      /**      * Tests that the intersection size estimate is correctly calculated.      */     @Test     public final void estimateIntersectionSizeTest() {         // build a filter         List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          lst = Arrays.asList(8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,             31, 32, 33, 34, 35, 36, 37, 38, 39, 40);         final Hasher hasher2 = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          final long estimate = SetOperations.estimateIntersectionSize(filter1, filter2);         assertEquals(1, estimate);     }      /**      * Tests that the size estimate is correctly calculated.      */     @Test     public final void estimateSizeTest() {         // build a filter         List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher = new StaticHasher(lst.iterator(), shape);         BloomFilter filter1 = new HasherBloomFilter(hasher, shape);         assertEquals(1, SetOperations.estimateSize(filter1));          // the data provided above do not generate an estimate that is equivalent to the         // actual.         lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);         hasher = new StaticHasher(lst.iterator(), shape);         filter1 = new HasherBloomFilter(hasher, shape);         assertEquals(1, SetOperations.estimateSize(filter1));          lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,             26, 27, 28, 29, 30, 31, 32, 33);         final Hasher hasher2 = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(3, SetOperations.estimateSize(filter2));     }      /**      * Tests that the union size estimate is correctly calculated.      */     @Test     public final void estimateUnionSizeTest() {         // build a filter         List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          lst = Arrays.asList(17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,             40);         final Hasher hasher2 = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          final long estimate = SetOperations.estimateUnionSize(filter1, filter2);         assertEquals(3, estimate);     }      /**      * Tests that the Hamming distance is correctly calculated.      */     @Test     public final void hammingDistanceTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0, SetOperations.hammingDistance(filter1, filter2));         assertEquals(0, SetOperations.hammingDistance(filter2, filter1));          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(17, SetOperations.hammingDistance(filter1, filter2));         assertEquals(17, SetOperations.hammingDistance(filter2, filter1));     }      /**      * Tests that the Jaccard distance is correctly calculated.      */     @Test     public final void jaccardDistanceTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(1.0, SetOperations.jaccardDistance(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.jaccardDistance(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.32, SetOperations.jaccardDistance(filter1, filter2), 0.001);         assertEquals(0.32, SetOperations.jaccardDistance(filter2, filter1), 0.001);     }      /**      * Tests that the Jaccard distance is correctly calculated when one or      * both filters are empty      */     @Test     public final void jaccardDistanceTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(1.0, SetOperations.jaccardDistance(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.jaccardDistance(filter2, filter1), 0.0001);         assertEquals(0.0, SetOperations.jaccardDistance(filter1, filter3), 0.0001);         assertEquals(0.0, SetOperations.jaccardDistance(filter3, filter1), 0.0001);     }      /**      * Tests that the Jaccard similarity is correctly calculated.      */     @Test     public final void jaccardSimilarityTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.0, SetOperations.jaccardSimilarity(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.jaccardSimilarity(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.68, SetOperations.jaccardSimilarity(filter1, filter2), 0.001);         assertEquals(0.68, SetOperations.jaccardSimilarity(filter2, filter1), 0.001);     }      /**      * Tests that the Jaccard similarity is correctly calculated when one or      * both filters are empty      */     @Test     public final void jaccardSimilarityTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(0.0, SetOperations.jaccardSimilarity(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.jaccardSimilarity(filter2, filter1), 0.0001);         assertEquals(1.0, SetOperations.jaccardSimilarity(filter1, filter3), 0.0001);         assertEquals(1.0, SetOperations.jaccardSimilarity(filter3, filter1), 0.0001);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.List; import java.util.PrimitiveIterator.OfInt; import java.util.function.BiFunction; import java.util.function.IntConsumer; import java.util.ArrayList; import java.util.Arrays; import java.util.BitSet;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher; import org.junit.Test;  /**  * Test standard methods in the {@link BloomFilter} interface.  */ public abstract class AbstractBloomFilterTest {      /**      * An implementation of BloomFilter that is used to test merge and cardinality      * operations with a filter type that does not match the type of the filter      * being tested.      */     private static class TestBloomFilter extends AbstractBloomFilter {         /** The bits. */         final BitSet bits;          protected TestBloomFilter(final Shape shape, final BitSet bits) {             super(shape);             this.bits = bits;         }          @Override         public long[] getBits() {             return bits.toLongArray();         }          @Override         public StaticHasher getHasher() {             return new StaticHasher(bits.stream().iterator(), getShape());         }          @Override         public boolean merge(final BloomFilter other) {             throw new UnsupportedOperationException();         }          @Override         public boolean merge(final Hasher hasher) {             throw new UnsupportedOperationException();         }     }      /**      * A HashFunctionIdentity for testing.      */     protected HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /**      * A second HashFunctionIdentity for testing.      */     protected HashFunctionIdentity testFunctionX = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test FunctionX";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 1;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /**      * The shape of the Bloom filters for testing      */     protected Shape shape = new Shape(testFunction, 3, 72, 17);      /**      * Tests that the andCardinality calculations are correct.      */     @Test     public final void andCardinalityTest() {         andCardinalityTest(this::createFilter);     }      /**      * Tests that the andCardinality calculations are correct with a generic BloomFilter.      */     @Test     public final void andCardinalityTest_GenericBloomFilter() {         andCardinalityTest(this::createGenericFilter);     }      /**      * Tests that the andCardinality calculations are correct.      *      * @param filterFactory the factory function to create the filter      */     private void andCardinalityTest(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertEquals(7, bf.andCardinality(bf2));     }      /**      * Tests that the andCardinality calculations are correct when there are more than Long.LENGTH bits.      */     @Test     public final void andCardinalityTest_ExtraLongs() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = createFilter(hasher2, shape);          assertEquals(7, bf.andCardinality(bf2));         assertEquals(7, bf2.andCardinality(bf));     }      /**      * Compare 2 static hashers to verify they have the same bits enabled.      *      * @param hasher1 the first static hasher.      * @param hasher2 the second static hasher.      */     private void assertSameBits(final StaticHasher hasher1, final StaticHasher hasher2) {         final OfInt iter1 = hasher1.iterator(shape);         final OfInt iter2 = hasher2.iterator(shape);          while (iter1.hasNext()) {             assertTrue("Not enough data in second hasher", iter2.hasNext());             assertEquals(iter1.nextInt(), iter2.nextInt());         }         assertFalse("Too much data in second hasher", iter2.hasNext());     }      /**      * Tests that cardinality is correct.      */     @Test     public final void cardinalityTest() {          final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);         assertEquals(17, bf.cardinality());     }      /**      * Tests that creating an empty hasher works as expected.      */     @Test     public final void constructorTest_Empty() {          final BloomFilter bf = createEmptyFilter(shape);         final long[] lb = bf.getBits();         assertEquals(0, lb.length);     }      /**      * Tests that creating a filter with a hasher works as expected.      */     @Test     public final void constructorTest_Hasher() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);         final long[] lb = bf.getBits();         assertEquals(0x1FFFF, lb[0]);         assertEquals(1, lb.length);     }      /**      * Tests that creating a Bloom filter with a Static hasher that has one shape and a      * different specified shape fails.      */     @Test     public final void constructorTest_WrongShape() {         final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);          final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), anotherShape);         try {             createFilter(hasher, shape);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that contains() with a Bloom filter argument returns the proper results.      */     @Test     public final void containsTest_BloomFilter() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(4, 5, 6, 7, 8, 9, 10);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         final BloomFilter bf2 = createFilter(hasher2, shape);         assertTrue(bf.contains(bf2));         assertFalse(bf2.contains(bf));     }      /**      * Tests that contains() fails properly if the other Bloom filter is not of the proper shape.      */     @Test     public final void containsTest_BloomFilter_WrongShape() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);         final Hasher hasher2 = new StaticHasher(lst.iterator(), anotherShape);         final BloomFilter bf2 = createFilter(hasher2, anotherShape);         try {             bf.contains(bf2);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that contains() with a Hasher argument returns the proper results.      */     @Test     public final void containsTest_Hasher() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(4, 5, 6, 7, 8, 9, 10);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         assertTrue(bf.contains(hasher2));          lst2 = Arrays.asList(17, 18, 19, 20);         hasher2 = new StaticHasher(lst2.iterator(), shape);         assertFalse(bf.contains(hasher2));          lst2 = Arrays.asList(10, 11, 12, 17, 18, 19, 20);         hasher2 = new StaticHasher(lst2.iterator(), shape);         assertFalse(bf.contains(hasher2));     }      /**      * Tests that contains() fails properly if the hasher is not of the proper shape.      */     @Test     public final void containsTest_Hasher_WrongShape() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);          final List<Integer> lst2 = Arrays.asList(4, 5, 6, 7, 8, 9, 10);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), anotherShape);         try {             bf.contains(hasher2);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Create an empty version of the BloomFilter implementation we are testing.      *      * @param shape the shape of the filter.      * @return a BloomFilter implementation.      */     protected abstract AbstractBloomFilter createEmptyFilter(Shape shape);      /**      * Create the BloomFilter implementation we are testing.      *      * @param hasher the hasher to use to create the filter.      * @param shape the shape of the filter.      * @return a BloomFilter implementation.      */     protected abstract AbstractBloomFilter createFilter(Hasher hasher, Shape shape);      /**      * Create a generic BloomFilter implementation.      *      * @param hasher the hasher to use to create the filter.      * @param shape the shape of the filter.      * @return a BloomFilter implementation.      */     private AbstractBloomFilter createGenericFilter(final Hasher hasher, final Shape shape) {         final BitSet bits = new BitSet();         hasher.iterator(shape).forEachRemaining((IntConsumer) bits::set);         return new TestBloomFilter(shape, bits);     }      /**      * Tests that getBits() works correctly when multiple long values are returned.      */     @Test     public final void getBitsTest_SpanLong() {         final List<Integer> lst = Arrays.asList(63, 64);         final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);         final long[] lb = bf.getBits();         assertEquals(2, lb.length);         assertEquals(0x8000000000000000L, lb[0]);         assertEquals(0x1, lb[1]);     }      /**      * Tests that the the hasher returned from getHasher() works correctly.      */     @Test     public final void getHasherTest() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final StaticHasher hasher2 = bf.getHasher();          assertEquals(shape, hasher2.getShape());         assertSameBits(hasher, hasher2);     }      /**      * Tests that isFull() returns the proper values.      */     @Test     public final void isFullTest() {          // create empty filter         AbstractBloomFilter filter = createEmptyFilter(shape);         assertFalse(filter.isFull());          final List<Integer> values = new ArrayList<>(shape.getNumberOfBits());         for (int i = 0; i < shape.getNumberOfBits(); i++) {             values.add(i);         }          StaticHasher hasher2 = new StaticHasher(values.iterator(), shape);         filter = createFilter(hasher2, shape);          assertTrue(filter.isFull());          final int mid = shape.getNumberOfBits() / 2;         values.remove(Integer.valueOf(mid));         hasher2 = new StaticHasher(values.iterator(), shape);         filter = createFilter(hasher2, shape);         assertFalse(filter.isFull());     }      /**      * Tests that merging bloom filters works as expected.      */     @Test     public final void mergeTest_BloomFilter() {         mergeTest_BloomFilter(this::createFilter);     }      /**      * Tests that merging bloom filters works as expected with a generic BloomFilter.      */     @Test     public final void mergeTest_GenericBloomFilter() {         mergeTest_BloomFilter(this::createGenericFilter);     }      /**      * Tests that merging bloom filters works as expected.      *      * @param filterFactory the factory function to create the filter      */     private void mergeTest_BloomFilter(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertTrue("Merge should not fail", bf.merge(bf2));         assertEquals(27, bf.cardinality());     }      /**      * Tests that merging bloom filters with different shapes fails properly      */     @Test     public final void mergeTest_BloomFilter_WrongShape() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);         final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), anotherShape);         final BloomFilter bf2 = createFilter(hasher2, anotherShape);          try {             bf.merge(bf2);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that merging a hasher into a Bloom filter works as expected      */     @Test     public final void mergeTest_Hasher() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          assertTrue("Merge should not fail", bf.merge(hasher2));         assertEquals(27, bf.cardinality());     }      /**      * Tests that merging a static hasher with the wrong shape into a Bloom filter fails as expected      */     @Test     public final void mergeTest_Hasher_WrongShape() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);         final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), anotherShape);          try {             bf.merge(hasher2);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that the orCardinality calculations are correct.      */     @Test     public final void orCardinalityTest() {         orCardinalityTest(this::createFilter);     }      /**      * Tests that the orCardinality calculations are correct with a generic BloomFilter.      */     @Test     public final void orCardinalityTest_GenericBloomFilter() {         orCardinalityTest(this::createGenericFilter);     }      /**      * Tests that the andCardinality calculations are correct.      *      * @param filterFactory the factory function to create the filter      */     private void orCardinalityTest(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final AbstractBloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertEquals(27, bf.orCardinality(bf2));     }      /**      * Tests that the orCardinality calculations are correct when there are more than Long.LENGTH bits.      */     @Test     public final void orCardinalityTest_ExtraLongs() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final AbstractBloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final AbstractBloomFilter bf2 = createFilter(hasher2, shape);          assertEquals(27, bf.orCardinality(bf2));         assertEquals(27, bf2.orCardinality(bf));     }      /**      * Tests that the xorCardinality calculations are correct.      */     @Test     public final void xorCardinalityTest() {         xorCardinalityTest(this::createFilter);     }      /**      * Tests that the xorCardinality calculations are correct with a generic BloomFilter.      */     @Test     public final void xorCardinalityTest_GenericBloomFilter() {         xorCardinalityTest(this::createGenericFilter);     }      /**      * Tests that the andCardinality calculations are correct.      *      * @param filterFactory the factory function to create the filter      */     private void xorCardinalityTest(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertEquals(20, bf.xorCardinality(bf2));     }      /**      * Tests that the xorCardinality calculations are correct when there are more than Long.LENGTH bits.      */     @Test     public final void xorCardinalityTest_ExtraLongs() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         final BloomFilter bf2 = createFilter(hasher2, shape);          assertEquals(20, bf.xorCardinality(bf2));         assertEquals(20, bf2.xorCardinality(bf));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher.Builder; import org.apache.commons.lang3.NotImplementedException; import org.junit.Assert; import org.junit.Test; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.nio.CharBuffer; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.ArrayList;  /**  * Tests the  * {@link org.apache.commons.collections4.bloomfilter.hasher.Hasher.Builder Hasher.Builder}.  */ public class HasherBuilderTest {      /**      * Simple class to collect byte[] items added to the builder.      */     private static class TestBuilder implements Hasher.Builder {         ArrayList<byte[]> items = new ArrayList<>();          @Override         public Hasher build() {             throw new NotImplementedException("Not required");         }          @Override         public Builder with(final byte[] item) {             items.add(item);             return this;         }     }      /**      * Tests that adding CharSequence items works correctly.      */     @Test     public void withCharSequenceTest() {         final String ascii = "plain";         final String extended = getExtendedString();         for (final String s : new String[] {ascii, extended}) {             for (final Charset cs : new Charset[] {                 StandardCharsets.ISO_8859_1, StandardCharsets.UTF_8, StandardCharsets.UTF_16             }) {                 final TestBuilder builder = new TestBuilder();                 builder.with(s, cs);                 Assert.assertArrayEquals(s.getBytes(cs), builder.items.get(0));             }         }     }      /**      * Tests that adding unencoded CharSequence items works correctly.      */     @Test     public void withUnencodedCharSequenceTest() {         final String ascii = "plain";         final String extended = getExtendedString();         for (final String s : new String[] {ascii, extended}) {             final TestBuilder builder = new TestBuilder();             builder.withUnencoded(s);             final byte[] encoded = builder.items.get(0);             final char[] original = s.toCharArray();             // Should be twice the length             Assert.assertEquals(original.length * 2, encoded.length);             // Should be little endian (lower bits first)             final CharBuffer buffer = ByteBuffer.wrap(encoded)                                                 .order(ByteOrder.LITTLE_ENDIAN).asCharBuffer();             for (int i = 0; i < original.length; i++) {                 Assert.assertEquals(original[i], buffer.get(i));             }         }     }      /**      * Gets a string with non-standard characters.      *      * @return the extended string      */     static String getExtendedString() {         final char[] data = {'e', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ',             // Add some characters that are non standard             // non-ascii             0xCA98,             // UTF-16 surrogate pair             0xD803, 0xDE6D             // Add other cases here ...         };         return String.valueOf(data);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.nio.charset.StandardCharsets; import java.util.NoSuchElementException; import java.util.PrimitiveIterator.OfInt;  import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic; import org.junit.Before; import org.junit.Test;  /**  * {@link DynamicHasher.Builder} tests.  */ public class DynamicHasherBuilderTest {      private DynamicHasher.Builder builder;     private final HashFunction hf = new MD5Cyclic();     private final Shape shape = new Shape(hf, 1, 345, 1);     private final String testString = HasherBuilderTest.getExtendedString();      /**      * Tests that hashing a byte array works as expected.      */     @Test     public void buildTest_byteArray() {         final byte[] bytes = testString.getBytes();         final DynamicHasher hasher = builder.with(bytes).build();         final int expected = (int) Math.floorMod((long) hf.apply(bytes, 0), (long) shape.getNumberOfBits());          final OfInt iter = hasher.iterator(shape);          assertTrue(iter.hasNext());         assertEquals(expected, iter.nextInt());         assertFalse(iter.hasNext());     }      /**      * Tests that an empty hasher works as expected.      */     @Test     public void buildTest_Empty() {         final DynamicHasher hasher = builder.build();          final OfInt iter = hasher.iterator(shape);          assertFalse(iter.hasNext());         try {             iter.nextInt();             fail("Should have thrown NoSuchElementException");         } catch (final NoSuchElementException ignore) {             // do nothing         }     }      /**      * Tests that hashing a string works as expected.      */     @Test     public void buildTest_String() {         final byte[] bytes = testString.getBytes(StandardCharsets.UTF_8);         final DynamicHasher hasher = builder.with(testString, StandardCharsets.UTF_8).build();         final int expected = (int) Math.floorMod((long) hf.apply(bytes, 0), (long) shape.getNumberOfBits());          final OfInt iter = hasher.iterator(shape);          assertTrue(iter.hasNext());         assertEquals(expected, iter.nextInt());         assertFalse(iter.hasNext());     }      /**      * Tests that hashing a string works as expected.      */     @Test     public void buildTest_UnencodedString() {         final byte[] bytes = testString.getBytes(StandardCharsets.UTF_16LE);         final DynamicHasher hasher = builder.withUnencoded(testString).build();         final int expected = (int) Math.floorMod((long) hf.apply(bytes, 0), (long) shape.getNumberOfBits());          final OfInt iter = hasher.iterator(shape);          assertTrue(iter.hasNext());         assertEquals(expected, iter.nextInt());         assertFalse(iter.hasNext());     }      /**      * Tests that build resets the builder.      */     @Test     public void buildResetTest() {         builder.with(new byte[] {123});         final OfInt iter = builder.build().iterator(shape);          assertTrue(iter.hasNext());         iter.next();         assertFalse(iter.hasNext());          // Nothing added since last build so it should be an empty hasher         final OfInt iter2 = builder.build().iterator(shape);         assertFalse(iter2.hasNext());     }      /**      * Sets up the builder for testing.      */     @Before     public void setup() {         builder = new DynamicHasher.Builder(hf);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.junit.Test;  /**  * Tests the signature of a hash function.  */ public abstract class AbstractHashFunctionTest {      /**      * Test that the signature is properly generated.      */     @Test     public void signatureTest() {         final HashFunction hf = createHashFunction();         final long expected = hf.apply(HashFunctionIdentity.prepareSignatureBuffer(hf), 0);         assertEquals(expected, hf.getSignature());         // Should be repeatable         final long expected2 = hf.apply(HashFunctionIdentity.prepareSignatureBuffer(hf), 0);         assertEquals(expected, expected2);         assertEquals("Apache Commons Collections", hf.getProvider());     }      /**      * Creates the hash function.      *      * @return the hash function      */     protected abstract HashFunction createHashFunction(); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import java.nio.charset.StandardCharsets; import java.util.Arrays; import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Tests that the Objects hash works correctly.  */ public class ObjectsHashIterativeTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final ObjectsHashIterative obj = new ObjectsHashIterative();          final byte[] buffer = "Now is the time for all good men to come to the aid of their country"             .getBytes(StandardCharsets.UTF_8);          long l = obj.apply(buffer, 0);         long prev = 0;         assertEquals(Arrays.deepHashCode(new Object[] {prev, buffer}), l);         for (int i = 1; i <= 5; i++) {             prev += l;             l = obj.apply(buffer, i);             assertEquals(Arrays.deepHashCode(new Object[] {prev, buffer}), l);         }     }      @Override     protected HashFunction createHashFunction() {         return new ObjectsHashIterative();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import java.nio.charset.StandardCharsets; import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Test that the Murmur3 128 x64 hash function works correctly.  */ public class Murmur128x64CyclicTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final Murmur128x64Cyclic murmur = new Murmur128x64Cyclic();          final long l1 = 0xe7eb60dabb386407L;         final long l2 = 0xc3ca49f691f73056L;         final byte[] buffer = "Now is the time for all good men to come to the aid of their country"             .getBytes(StandardCharsets.UTF_8);          long l = murmur.apply(buffer, 0);         assertEquals(l1, l);         l = murmur.apply(buffer, 1);         assertEquals(l1 + l2, l);         l = murmur.apply(buffer, 2);         assertEquals(l1 + l2 + l2, l);     }      @Override     protected HashFunction createHashFunction() {         return new Murmur128x64Cyclic();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import java.nio.charset.StandardCharsets; import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Test that the Murmur3 32 x86 hash function works correctly.  */ public class Murmur32x86IterativeTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final Murmur32x86Iterative murmur = new Murmur32x86Iterative();          final byte[] buffer = "Now is the time for all good men to come to the aid of their country"             .getBytes(StandardCharsets.UTF_8);          long l = murmur.apply(buffer, 0);         assertEquals(82674681, l);         l = murmur.apply(buffer, 1);         assertEquals(-1475490736, l);         l = murmur.apply(buffer, 2);         assertEquals(-1561435247, l);     }      @Override     protected HashFunction createHashFunction() {         return new Murmur32x86Iterative();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Tests the MD5 cyclic hash function.  */ public class MD5CyclicTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final MD5Cyclic md5 = new MD5Cyclic();         final long l1 = 0x8b1a9953c4611296L;         final long l2 = 0xa827abf8c47804d7L;         final byte[] buffer = "Hello".getBytes();          long l = md5.apply(buffer, 0);         assertEquals(l1, l);         l = md5.apply(buffer, 1);         assertEquals(l1 + l2, l);         l = md5.apply(buffer, 2);         assertEquals(l1 + l2 + l2, l);     }      @Override     protected HashFunction createHashFunction() {         return new MD5Cyclic();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness; import org.junit.Test;  /**  * Tests of the {@link HashFunctionValidator}.  */ public class HashFunctionValidatorTest {      /**      * Tests that name is used in the equality check.      */     @Test     public void testName() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl2", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertFalse(HashFunctionValidator.areEqual(impl1, impl2));         assertFalse(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Tests that name is not affected by case.      */     @Test     public void testNameIsCaseInsensitive() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "IMPL1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl2));     }      /**      * Tests that process type is used in the equality check.      */     @Test     public void testProcessType() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.ITERATIVE, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertFalse(HashFunctionValidator.areEqual(impl1, impl2));         assertFalse(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Tests that provider is <strong>not</strong> used in the equality check.      */     @Test     public void testProviderIsNotUsedInEqualityCheck() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite2", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertTrue(HashFunctionValidator.areEqual(impl1, impl2));         assertTrue(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Tests that signedness is used in the equality check.      */     @Test     public void testSignedness() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.UNSIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertFalse(HashFunctionValidator.areEqual(impl1, impl2));         assertFalse(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Test the check method throws when the two hash functions are not equal.      */     @Test(expected=IllegalArgumentException.class)     public void testCheckThrows() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.UNSIGNED,             ProcessType.CYCLIC, 300L);         HashFunctionValidator.checkAreEqual(impl1, impl2);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Arrays; import java.util.Iterator; import java.util.List; import java.util.PrimitiveIterator.OfInt;  import org.junit.Test;  /**  * Tests the {@link StaticHasher}.  */ public class StaticHasherTest {      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      private final HashFunctionIdentity testFunctionX = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test FunctionX";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      private final Shape shape = new Shape(testFunction, 3, 72, 17);      /**      * Compare 2 static hashers to verify they have the same bits enabled.      *      * @param hasher1 the first static hasher.      * @param hasher2 the second static hasher.      */     private void assertSameBits(final StaticHasher hasher1, final StaticHasher hasher2) {         final OfInt iter1 = hasher1.iterator(shape);         final OfInt iter2 = hasher2.iterator(shape);          while (iter1.hasNext()) {             assertTrue("Not enough data in second hasher", iter2.hasNext());             assertEquals(iter1.nextInt(), iter2.nextInt());         }         assertFalse("Too much data in second hasher", iter2.hasNext());     }      /**      * Tests that passing a hasher other than a StaticHasher to the constructor works as      * expected.      */     @Test     public void testConstructor_Hasher() {         final int[] expected = {1, 3, 5, 7, 9};          final Hasher testHasher = new Hasher() {              @Override             public OfInt iterator(final Shape shape) {                 final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};                 return Arrays.stream(values).iterator();             }              @Override             public HashFunctionIdentity getHashFunctionIdentity() {                 return testFunction;             }         };          final StaticHasher hasher = new StaticHasher(testHasher, shape);         final OfInt iter = hasher.iterator(shape);         for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that passing a hasher other than a StaticHasher and the wrong Shape to the      * constructor throws an IllegalArgumentException.      */     @Test     public void testConstructor_Hasher_WrongShape() {         final Hasher testHasher = new Hasher() {              @Override             public OfInt iterator(final Shape shape) {                 final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};                 return Arrays.stream(values).iterator();             }              @Override             public HashFunctionIdentity getHashFunctionIdentity() {                 return testFunctionX;             }         };          try {             new StaticHasher(testHasher, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Test that the iterator based constructor works correctly and removes duplicates.      */     @Test     public void testConstructor_Iterator() {          final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};         Iterator<Integer> iter = Arrays.stream(values).iterator();         final StaticHasher hasher = new StaticHasher(iter, shape);          assertEquals(5, hasher.size());         assertEquals(shape, hasher.getShape());         // All function properties are equal         assertEquals(testFunction.getName(), hasher.getHashFunctionIdentity().getName());         assertEquals(testFunction.getProcessType(), hasher.getHashFunctionIdentity().getProcessType());         assertEquals(testFunction.getProvider(), hasher.getHashFunctionIdentity().getProvider());         assertEquals(testFunction.getSignedness(), hasher.getHashFunctionIdentity().getSignedness());          iter = hasher.iterator(shape);         int idx = 0;         while (iter.hasNext()) {             assertEquals("Error at idx " + idx, Integer.valueOf(values[idx]), iter.next());             idx++;         }         assertEquals(5, idx);     }      /**      * Tests that if the iterator passed to the constructor contains a value greater than      * or equal to Shape.numberOfBits() an exception is thrown.      */     @Test     public void testConstructor_Iterator_ValueTooBig() {          final int[] values = {shape.getNumberOfBits(), 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         try {             new StaticHasher(iter, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Tests that if the iterator passed to the constructor contains a value less than 0      * (zero) an exception is thrown.      */     @Test     public void testConstructor_Iterator_ValueTooSmall() {          final int[] values = {-1, 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         try {             new StaticHasher(iter, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Tests that the constructor that accepts a static hasher properly builds the hasher.      */     @Test     public void testConstructor_StaticHasher() {         final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         final StaticHasher hasher = new StaticHasher(iter, shape);          final StaticHasher hasher2 = new StaticHasher(hasher, shape);         assertEquals(shape, hasher2.getShape());         assertSameBits(hasher, hasher2);     }      /**      * Tests that calling the constructor with a hasher and the wrong shape throws an      * IllegalArgumentException.      */     @Test     public void testConstructor_StaticHasher_WrongShape() {         final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         final StaticHasher hasher = new StaticHasher(iter, new Shape(testFunctionX, 3, 72, 17));          try {             new StaticHasher(hasher, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Tests that iterator returns the proper values.      */     @Test     public void testGetBits() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);          final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);         assertEquals(17, hasher.size());         final OfInt iter = hasher.iterator(shape);         for (int i = 0; i < 17; i++) {             assertTrue(iter.hasNext());             assertEquals(i, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that iterator does not return duplicates and orders the indices.      */     @Test     public void testGetBits_DuplicateValues() {         final int[] input = {6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7, 69, 59,             49, 39, 13, 3, 65, 55, 45, 35, 25};         final int[] expected = {1, 2, 3, 6, 7, 10, 11, 13, 15, 17, 19, 23, 24, 25, 35, 36, 39, 43, 44, 45, 48, 49, 53, 55, 57,             59, 61, 62, 63, 65, 69, 70};          final StaticHasher hasher = new StaticHasher(Arrays.stream(input).iterator(), shape);          final OfInt iter = hasher.iterator(shape);         for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that gitBits is called with the wrong shape an exception is thrown.      */     @Test     public void testGetBits_WrongShape() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);          try {             hasher.iterator(new Shape(testFunctionX, 3, 72, 17));             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.junit.Test;  /**  * Tests the HashFunctionIdentity implementation ({@link HashFunctionIdentityImpl})..  */ public class HashFunctionIdentityImplTest {      /**      * Tests a copy constructor of the HashFunctionIdentity.      */     @Test     public void copyConstructorTest() {         final HashFunctionIdentity identity = new HashFunctionIdentity() {              @Override             public String getName() {                 return "NAME";             }              @Override             public ProcessType getProcessType() {                 return ProcessType.CYCLIC;             }              @Override             public String getProvider() {                 return "Provider";             }              @Override             public long getSignature() {                 return -1L;             }              @Override             public Signedness getSignedness() {                 return Signedness.SIGNED;             }          };         final HashFunctionIdentityImpl impl = new HashFunctionIdentityImpl(identity);         assertEquals("NAME", impl.getName());         assertEquals("Provider", impl.getProvider());         assertEquals(Signedness.SIGNED, impl.getSignedness());         assertEquals(ProcessType.CYCLIC, impl.getProcessType());         assertEquals(-1L, impl.getSignature());     }      /**      * Test the constructor from component values.      */     @Test     public void valuesConstructorTest() {         final HashFunctionIdentityImpl impl = new HashFunctionIdentityImpl("Provider", "NAME", Signedness.UNSIGNED,             ProcessType.ITERATIVE, -2L);         assertEquals("NAME", impl.getName());         assertEquals("Provider", impl.getProvider());         assertEquals(Signedness.UNSIGNED, impl.getSignedness());         assertEquals(ProcessType.ITERATIVE, impl.getProcessType());         assertEquals(-2L, impl.getSignature());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.nio.charset.StandardCharsets; import java.util.NoSuchElementException; import java.util.PrimitiveIterator.OfInt;  import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic; import org.junit.Before; import org.junit.Test;  /**  * Tests the {@link DynamicHasher}.  */ public class DynamicHasherTest {     private DynamicHasher.Builder builder;     private Shape shape;      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /**      * Sets up the DynamicHasher.      */     @Before     public void setup() {         builder = new DynamicHasher.Builder(new MD5Cyclic());         shape = new Shape(new MD5Cyclic(), 3, 72, 17);     }      /**      * Tests that the expected bits are returned from hashing.      */     @Test     public void testGetBits() {          final int[] expected = {6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62};          final Hasher hasher = builder.with("Hello", StandardCharsets.UTF_8).build();          final OfInt iter = hasher.iterator(shape);          for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that bits from multiple hashes are returned correctly.      */     @Test     public void testGetBits_MultipleHashes() {         final int[] expected = {6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7, 69,             59, 49, 39, 13, 3, 65, 55, 45, 35, 25};          final Hasher hasher = builder.with("Hello", StandardCharsets.UTF_8).with("World", StandardCharsets.UTF_8).build();          final OfInt iter = hasher.iterator(shape);          for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());         try {             iter.next();             fail("Should have thrown NoSuchElementException");         } catch (final NoSuchElementException ignore) {             // do nothing         }     }      /**      * Tests that retrieving bits for the wrong shape throws an exception.      */     @Test     public void testGetBits_WrongShape() {          final Hasher hasher = builder.with("Hello", StandardCharsets.UTF_8).build();          try {             hasher.iterator(new Shape(testFunction, 3, 72, 17));             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotEquals; import static org.junit.Assert.fail;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness;  import java.util.ArrayList;  import org.junit.Test;  /**  * Tests the {@link Shape} class.  */ public class ShapeTest {      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /*      * values from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=      *      * n = 5      *      * p = 0.100375138 (1 in 10)      *      * m = 24 (3B)      *      * k = 3      */      private final Shape shape = new Shape(testFunction, 5, 0.1);      /**      * Tests that if the number of bits less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_bits_BadNumberOfBitsTest() {         try {             new Shape(testFunction, 5, 0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of hash functions is less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_bits_BadNumberOfHashFunctionsTest() {         try {             new Shape(testFunction, 16, 8);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of items less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_bits_BadNumberOfItemsTest() {         try {             new Shape(testFunction, 0, 24);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of bits is less than 1 an exception is thrown      */     @Test     public void constructor_items_bits_hash_BadNumberOfBitsTest() {         try {             new Shape(testFunction, 5, 0, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of hash functions is less than 1 an exception is thrown.      */     @Test     public void constructor_items_bits_hash_BadNumberOfHashFunctionsTest() {         try {             new Shape(testFunction, 5, 24, 0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of items is less than 1 an exception is thrown.      */     @Test     public void constructor_items_bits_hash_BadNumberOfItemsTest() {         try {             new Shape(testFunction, 0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the calculated probability is greater than or equal to 1 an IllegalArgumentException is thrown      */     @Test     public void constructor_items_bits_hash_BadProbabilityTest() {         try {             new Shape(testFunction, 4000, 8, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that when the number of items, number of bits and number of hash functions is passed the values are      * calculated correctly.      */     @Test     public void constructor_items_bits_hashTest() {         /*          * values from https://hur.st/bloomfilter/?n=5&m=24&k=4          */         final Shape filterConfig = new Shape(testFunction, 5, 24, 4);          assertEquals(24, filterConfig.getNumberOfBits());         assertEquals(4, filterConfig.getNumberOfHashFunctions());         assertEquals(5, filterConfig.getNumberOfItems());         assertEquals(0.102194782, filterConfig.getProbability(), 0.000001);     }      /**      * Tests that the number of items and number of bits is passed the other values are calculated correctly.      */     @Test     public void constructor_items_bitsTest() {         /*          * values from https://hur.st/bloomfilter/?n=5&m=24          */         final Shape filterConfig = new Shape(testFunction, 5, 24);          assertEquals(24, filterConfig.getNumberOfBits());         assertEquals(3, filterConfig.getNumberOfHashFunctions());         assertEquals(5, filterConfig.getNumberOfItems());         assertEquals(0.100375138, filterConfig.getProbability(), 0.000001);     }      /**      * Tests that if the number of items is less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_probability_BadNumberOfItemsTest() {         try {             new Shape(testFunction, 0, 1.0 / 10);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that if the probability is less than or equal to 0 or more than or equal to 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_probability_BadProbabilityTest() {         try {             new Shape(testFunction, 10, 0.0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }         try {             new Shape(testFunction, 10, 1.0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }         try {             new Shape(testFunction, 10, Double.NaN);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that if calculated number of bits is greater than Integer.MAX_VALUE an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_probability_NumberOfBitsOverflowTest() {         try {             new Shape(testFunction, Integer.MAX_VALUE, 1.0 / 10);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests the the probability is calculated correctly.      */     @Test     public void constructor_items_probability_Test() {          assertEquals(24, shape.getNumberOfBits());         assertEquals(3, shape.getNumberOfHashFunctions());         assertEquals(5, shape.getNumberOfItems());         assertEquals(0.100375138, shape.getProbability(), 0.000001);     }      /**      * Tests that the constructor with a null name, number of items and size of filter fails.      */     @Test     public void constructor_nm_noName() {         try {             new Shape(null, 5, 72);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that the constructor with a null name, number of items, size of filter, and number of functions fails.      */     @Test     public void constructor_nmk_noName() {         try {             new Shape(null, 5, 72, 17);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that the constructor with a null name, number of items, and probability fails.      */     @Test     public void constructor_np_noName() {         try {             new Shape(null, 5, 0.1);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that the constructor with a null name, probability, size of filter, and number of functions fails.      */     @Test     public void constructor_pmk_noName() {         try {             new Shape(null, 0.1, 72, 17);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that if the number of bits is less than 1 an exception is thrown      */     @Test     public void constructor_probability_bits_hash_BadNumberOfBitsTest() {         try {             new Shape(testFunction, 0.5, 0, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of functions is less than 1 an exception is thrown      */     @Test     public void constructor_probability_bits_hash_BadNumberOfHashFunctionsTest() {         try {             new Shape(testFunction, 0.5, 24, 0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that invalid probability values cause and IllegalArgumentException to be thrown.      */     @Test     public void constructor_probability_bits_hash_BadProbabilityTest() {         // probability should not be 0         try {             new Shape(testFunction, 0.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be = -1         try {             new Shape(testFunction, -1.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be < -1         try {             new Shape(testFunction, -1.5, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be = 1         try {             new Shape(testFunction, 1.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be > 1         try {             new Shape(testFunction, 2.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests the calculated values of calling the constructor with the probability, number of bits and number of hash      * functions.      */     @Test     public void constructor_probability_bits_hashTest() {         /*          * values from https://hur.st/bloomfilter/?n=5&p=.1&m=24&k=3          */         final Shape filterConfig = new Shape(testFunction, 0.1, 24, 3);          assertEquals(24, filterConfig.getNumberOfBits());         assertEquals(3, filterConfig.getNumberOfHashFunctions());         assertEquals(5, filterConfig.getNumberOfItems());         assertEquals(0.100375138, filterConfig.getProbability(), 0.000001);     }      /**      * Test equality of shape.      */     @Test     public void equalsTest() {          assertEquals(shape, shape);         assertEquals(shape, new Shape(testFunction, 5, 1.0 / 10));         assertNotEquals(shape, null);         assertNotEquals(shape, new Shape(testFunction, 5, 1.0 / 11));         assertNotEquals(shape, new Shape(testFunction, 4, 1.0 / 10));         // Number of bits does not change equality,         // only the number of bits and the number of hash functions         final int numberOfBits = 10000;         final int numberOfItems = 15;         final int numberOfHashFunctions = 4;         assertEquals(new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions),                      new Shape(testFunction, numberOfItems + 1, numberOfBits, numberOfHashFunctions));         assertNotEquals(new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions),                         new Shape(testFunction, numberOfItems, numberOfBits + 1, numberOfHashFunctions));         assertNotEquals(new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions),                         new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions + 1));          final HashFunctionIdentity testFunction2 = new HashFunctionIdentity() {              @Override             public String getName() {                 return "Test Function2";             }              @Override             public ProcessType getProcessType() {                 return ProcessType.CYCLIC;             }              @Override             public String getProvider() {                 return "Apache Commons Collection Tests";             }              @Override             public long getSignature() {                 return 0;             }              @Override             public Signedness getSignedness() {                 return Signedness.SIGNED;             }         };          assertNotEquals(shape, new Shape(testFunction2, 4, 1.0 / 10));     }      /**      * Test that hashCode satisfies the contract between {@link Object#hashCode()} and      * {@link Object#equals(Object)}. Equal shapes must have the same hash code.      */     @Test     public void hashCodeTest() {         // Hash function equality is based on process type, signedness and name (case insensitive)         final ArrayList<HashFunctionIdentity> list = new ArrayList<>();         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         // Provider changes         list.add(new HashFunctionIdentityImpl("PROVIDER", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         list.add(new HashFunctionIdentityImpl("Provider2", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         // Name changes         list.add(new HashFunctionIdentityImpl("Provider", "name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         list.add(new HashFunctionIdentityImpl("Provider", "NAME", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         list.add(new HashFunctionIdentityImpl("Provider", "Other", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         // Signedness changes         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.UNSIGNED, ProcessType.ITERATIVE, 0L));         // ProcessType changes         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.SIGNED, ProcessType.CYCLIC, 0L));         // Signature changes         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 1L));          // Create shapes that only differ in the hash function.         final int numberOfItems = 30;         final int numberOfBits = 3000;         final int numberOfHashFunctions = 10;         final Shape shape1 = new Shape(list.get(0), numberOfItems, numberOfBits, numberOfHashFunctions);         assertEquals(shape1, shape1);          // Try variations         for (int i = 1; i < list.size(); i++) {             final Shape shape2 = new Shape(list.get(i), numberOfItems, numberOfBits, numberOfHashFunctions);             assertEquals(shape2, shape2);              // Equal shapes must have the same hash code             if (shape1.equals(shape2)) {                 assertEquals(shape1.hashCode(), shape2.hashCode());             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.junit.Assert; import org.junit.Test;  import java.util.ArrayList; import java.util.Random; import java.util.concurrent.ThreadLocalRandom;  /**  * Tests for the {@link BloomFilterIndexer}.  */ public class BloomFilterIndexerTest {      @Test(expected = IndexOutOfBoundsException.class)     public void testCheckPositiveThrows() {         BloomFilterIndexer.checkPositive(-1);     }      @Test     public void testGetLongIndex() {         Assert.assertEquals(0, BloomFilterIndexer.getLongIndex(0));          for (final int index : getIndexes()) {             // getLongIndex is expected to identify a block of 64-bits (starting from zero)             Assert.assertEquals(index / Long.SIZE, BloomFilterIndexer.getLongIndex(index));              // Verify the behavior for negatives. It should produce a negative (invalid)             // as a simple trip for incorrect usage.             Assert.assertTrue(BloomFilterIndexer.getLongIndex(-index) < 0);              // If index is not zero then when negated this is what a signed shift             // of 6-bits actually does             Assert.assertEquals(((1 - index) / Long.SIZE) - 1,                     BloomFilterIndexer.getLongIndex(-index));         }     }      @Test     public void testGetLongBit() {         Assert.assertEquals(1L, BloomFilterIndexer.getLongBit(0));          for (final int index : getIndexes()) {             // getLongBit is expected to identify a single bit in a 64-bit block             Assert.assertEquals(1L << (index % Long.SIZE), BloomFilterIndexer.getLongBit(index));              // Verify the behavior for negatives             Assert.assertEquals(1L << (64 - (index & 0x3f)), BloomFilterIndexer.getLongBit(-index));         }     }      /**      * Gets non-zero positive indexes for testing.      *      * @return the indices      */     private static int[] getIndexes() {         final Random rng = ThreadLocalRandom.current();         final ArrayList<Integer> indexes = new ArrayList<>(40);         for (int i = 0; i < 10; i++) {             // random positive numbers             indexes.add(rng.nextInt() >>> 1);             indexes.add(rng.nextInt(23647826));             indexes.add(rng.nextInt(245));         }         // Quickly remove zeros (as these cannot be negated)         indexes.removeIf(i -> i == 0);         // Add edge cases here         indexes.add(1);         indexes.add(2);         indexes.add(63);         indexes.add(64);         indexes.add(Integer.MAX_VALUE);         return indexes.stream().mapToInt(Integer::intValue).toArray();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import java.util.BitSet; import java.util.function.IntConsumer;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher;  /**  * Test all the default implementations of the BloomFilter in {@link AbstractBloomFilter}.  */ public class DefaultBloomFilterMethodsTest extends AbstractBloomFilterTest {      /**      * A testing class that implements only the abstract methods from BloomFilter.      *      */     private static class BF extends AbstractBloomFilter {          /**          * The bits for this BloomFilter.          */         private final BitSet bitSet;          /**          * Constructs a BitSetBloomFilter from a hasher and a shape.          *          * @param hasher the Hasher to use.          * @param shape the desired shape of the filter.          */         BF(final Hasher hasher, final Shape shape) {             this(shape);             verifyHasher(hasher);             hasher.iterator(shape).forEachRemaining((IntConsumer) bitSet::set);         }          /**          * Constructs an empty BitSetBloomFilter.          *          * @param shape the desired shape of the filter.          */         BF(final Shape shape) {             super(shape);             this.bitSet = new BitSet();         }          @Override         public long[] getBits() {             return bitSet.toLongArray();         }          @Override         public StaticHasher getHasher() {             return new StaticHasher(bitSet.stream().iterator(), getShape());         }          @Override         public boolean merge(final BloomFilter other) {             verifyShape(other);             bitSet.or(BitSet.valueOf(other.getBits()));             return true;         }          @Override         public boolean merge(final Hasher hasher) {             verifyHasher(hasher);             hasher.iterator(getShape()).forEachRemaining((IntConsumer) bitSet::set);             return true;         }     }      @Override     protected AbstractBloomFilter createEmptyFilter(final Shape shape) {         return new BF(shape);     }      @Override     protected AbstractBloomFilter createFilter(final Hasher hasher, final Shape shape) {         return new BF(hasher, shape);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.io.IOException; import java.io.Serializable; import java.util.Date; import java.util.TimeZone;  import org.apache.commons.collections4.functors.ConstantFactory; import org.apache.commons.collections4.functors.ExceptionFactory; import org.junit.Test;  /**  * Tests the org.apache.commons.collections.FactoryUtils class.  *  * @since 3.0  */ public class FactoryUtilsTest {      // exceptionFactory     //------------------------------------------------------------------      @Test     public void testExceptionFactory() {         assertNotNull(FactoryUtils.exceptionFactory());         assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());         try {             FactoryUtils.exceptionFactory().create();         } catch (final FunctorException ex) {             try {                 FactoryUtils.exceptionFactory().create();             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // nullFactory     //------------------------------------------------------------------      @Test     public void testNullFactory() {         final Factory<Object> factory = FactoryUtils.nullFactory();         assertNotNull(factory);         final Object created = factory.create();         assertNull(created);     }      // constantFactory     //------------------------------------------------------------------      @Test     public void testConstantFactoryNull() {         final Factory<Object> factory = FactoryUtils.constantFactory(null);         assertNotNull(factory);         final Object created = factory.create();         assertNull(created);     }      @Test     public void testConstantFactoryConstant() {         final Integer constant = Integer.valueOf(9);         final Factory<Integer> factory = FactoryUtils.constantFactory(constant);         assertNotNull(factory);         final Integer created = factory.create();         assertSame(constant, created);     }      // prototypeFactory     //------------------------------------------------------------------      @Test     public void testPrototypeFactoryNull() {         assertSame(ConstantFactory.NULL_INSTANCE, FactoryUtils.prototypeFactory(null));     }      @Test     public void testPrototypeFactoryPublicCloneMethod() throws Exception {         final Date proto = new Date();         final Factory<Date> factory = FactoryUtils.prototypeFactory(proto);         assertNotNull(factory);         final Date created = factory.create();         assertNotSame(proto, created);         assertEquals(proto, created);     }      @Test     public void testPrototypeFactoryPublicCopyConstructor() throws Exception {         final Mock1 proto = new Mock1(6);         final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);         assertNotNull(factory);         final Object created = factory.create();         assertNotSame(proto, created);         assertEquals(proto, created);     }      @Test     public void testPrototypeFactoryPublicSerialization() throws Exception {         final Integer proto = 9;         final Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);         assertNotNull(factory);         final Integer created = factory.create();         assertNotSame(proto, created);         assertEquals(proto, created);     }      @Test     public void testPrototypeFactoryPublicSerializationError() {         final Mock2 proto = new Mock2(new Object());         final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);         assertNotNull(factory);         try {             factory.create();         } catch (final FunctorException ex) {             assertTrue(ex.getCause() instanceof IOException);             return;         }         fail();     }      @Test     public void testPrototypeFactoryPublicBad() {         final Object proto = new Object();         try {             FactoryUtils.prototypeFactory(proto);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      public static class Mock1 {         private final int iVal;         public Mock1(final int val) {             iVal = val;         }         public Mock1(final Mock1 mock) {             iVal = mock.iVal;         }         @Override         public boolean equals(final Object obj) {             if (obj instanceof Mock1) {                 if (iVal == ((Mock1) obj).iVal) {                     return true;                 }             }             return false;         }         @Override         public int hashCode() { // please Findbugs             return super.hashCode();         }     }      public static class Mock2 implements Serializable {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = 4899282162482588924L;         private final Object iVal;         public Mock2(final Object val) {             iVal = val;         }         @Override         public boolean equals(final Object obj) {             if (obj instanceof Mock2) {                 if (iVal == ((Mock2) obj).iVal) {                     return true;                 }             }             return false;         }         @Override         public int hashCode() { // please Findbugs             return super.hashCode();         }     }      public static class Mock3 {         private static int cCounter = 0;         private final int iVal;         public Mock3() {             iVal = cCounter++;         }         public int getValue() {             return iVal;         }     }      // instantiateFactory     //------------------------------------------------------------------      @Test(expected=NullPointerException.class)     public void instantiateFactoryNull() {         FactoryUtils.instantiateFactory(null);     }      @Test     public void instantiateFactorySimple() {         final Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);         assertNotNull(factory);         Mock3 created = factory.create();         assertEquals(0, created.getValue());         created = factory.create();         assertEquals(1, created.getValue());     }      @Test(expected=IllegalArgumentException.class)     public void instantiateFactoryMismatch() {         FactoryUtils.instantiateFactory(Date.class, null, new Object[] {null});     }      @Test(expected=IllegalArgumentException.class)     public void instantiateFactoryNoConstructor() {         FactoryUtils.instantiateFactory(Date.class, new Class[] {Long.class}, new Object[] {null});     }      @Test     public void instantiateFactoryComplex() {         TimeZone.setDefault(TimeZone.getTimeZone("GMT"));         // 2nd Jan 1970         final Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,             new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},             new Object[] {Integer.valueOf(70), Integer.valueOf(0), Integer.valueOf(2)});         assertNotNull(factory);         final Date created = factory.create();         // long time of 1 day (== 2nd Jan 1970)         assertEquals(new Date(1000 * 60 * 60 * 24), created);     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Factory singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionFactory.INSTANCE,         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization(                     "Singleton pattern broken for " + original.getClass(),                     original             );         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertSame;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;  public final class TestUtils {      private TestUtils() {}      /**      * Asserts that deserialization of the object returns the same object as the      * one that was serialized. Object is first serialized, then deserialized      * and finally check is performed to see if original and deserialized      * object references are the same.      * <p>      * This method is especially good for testing singleton pattern on classes      * that support serialization.      *      * @param msg the identifying message for the {@code AssertionError}.      * @param o object that will be tested.      * @see #assertSameAfterSerialization(Object)      */     public static void assertSameAfterSerialization(final String msg, final Object o) {         try {             // write object to byte buffer             final ByteArrayOutputStream baos = new ByteArrayOutputStream();             final ObjectOutputStream oos = new ObjectOutputStream(baos);             oos.writeObject(o);             oos.close();              // read same object from byte buffer             final InputStream is = new ByteArrayInputStream(baos.toByteArray());             final ObjectInputStream ois = new ObjectInputStream(is);             final Object object = ois.readObject();             ois.close();              // assert that original object and deserialized objects are the same             assertSame(msg, o, object);         } catch (final IOException e) {             // should never happen             throw new RuntimeException(e);         } catch (final ClassNotFoundException e) {             // should never happen             throw new RuntimeException(e);         }     }      /**      * Asserts that deserialization of the object returns the same object as the      * one that was serialized.      * <p>      * Effect of method call is the same as:      * {@code assertSameAfterSerialization(null, o)}.      *      * @param o object that will be tested.      * @see #assertSameAfterSerialization(String, Object)      */     public static void assertSameAfterSerialization(final Object o) {         assertSameAfterSerialization(null, o);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map;  import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.functors.ExceptionTransformer; import org.apache.commons.collections4.functors.FalsePredicate; import org.apache.commons.collections4.functors.NOPTransformer; import org.apache.commons.collections4.functors.StringValueTransformer; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests the TransformerUtils class.  *  * @since 3.0  */ public class TransformerUtilsTest {      private static final Object cObject = new Object();     private static final Object cString = "Hello";     private static final Object cInteger = Integer.valueOf(6);      // exceptionTransformer     //------------------------------------------------------------------      @Test     public void testExceptionTransformer() {         assertNotNull(TransformerUtils.exceptionTransformer());         assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer());         try {             TransformerUtils.exceptionTransformer().transform(null);         } catch (final FunctorException ex) {             try {                 TransformerUtils.exceptionTransformer().transform(cString);             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // nullTransformer     //------------------------------------------------------------------      @Test     public void testNullTransformer() {         assertNotNull(TransformerUtils.nullTransformer());         assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());         assertNull(TransformerUtils.nullTransformer().transform(null));         assertNull(TransformerUtils.nullTransformer().transform(cObject));         assertNull(TransformerUtils.nullTransformer().transform(cString));         assertNull(TransformerUtils.nullTransformer().transform(cInteger));     }      // nopTransformer     //------------------------------------------------------------------      @Test     public void testNopTransformer() {         assertNotNull(TransformerUtils.nullTransformer());         assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());         assertNull(TransformerUtils.nopTransformer().transform(null));         assertEquals(cObject, TransformerUtils.nopTransformer().transform(cObject));         assertEquals(cString, TransformerUtils.nopTransformer().transform(cString));         assertEquals(cInteger, TransformerUtils.nopTransformer().transform(cInteger));     }      // constantTransformer     //------------------------------------------------------------------      @Test     public void testConstantTransformer() {         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(null));         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cObject));         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cString));         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cInteger));         assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.constantTransformer(null));     }      // cloneTransformer     //------------------------------------------------------------------      @Test     public void testCloneTransformer() {         assertNull(TransformerUtils.cloneTransformer().transform(null));         assertEquals(cString, TransformerUtils.cloneTransformer().transform(cString));         assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));         try {             assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject));         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      // mapTransformer     //------------------------------------------------------------------      @Test     @SuppressWarnings("boxing") // OK in test code     public void testMapTransformer() {         final Map<Object, Integer> map = new HashMap<>();         map.put(null, 0);         map.put(cObject, 1);         map.put(cString, 2);         assertEquals(Integer.valueOf(0), TransformerUtils.mapTransformer(map).transform(null));         assertEquals(Integer.valueOf(1), TransformerUtils.mapTransformer(map).transform(cObject));         assertEquals(Integer.valueOf(2), TransformerUtils.mapTransformer(map).transform(cString));         assertNull(TransformerUtils.mapTransformer(map).transform(cInteger));         assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.mapTransformer(null));     }      // commandTransformer     //------------------------------------------------------------------      @Test     public void testExecutorTransformer() {         assertNull(TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));         assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));         assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));         assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));         try {             TransformerUtils.asTransformer((Closure<Object>) null);         } catch (final NullPointerException ex) {             return;         }         fail();     }      // predicateTransformer     //------------------------------------------------------------------      @Test     public void testPredicateTransformer() {         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(null));         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cObject));         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cString));         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cInteger));         try {             TransformerUtils.asTransformer((Predicate<Object>) null);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      // factoryTransformer     //------------------------------------------------------------------      @Test     public void testFactoryTransformer() {         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(null));         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cObject));         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cString));         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));         try {             TransformerUtils.asTransformer((Factory<Object>) null);         } catch (final NullPointerException ex) {             return;         }         fail();     }      // chainedTransformer     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testChainedTransformer() {         final Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer("A");         final Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) "B");          assertEquals("A", TransformerUtils.chainedTransformer(b, a).transform(null));         assertEquals("B", TransformerUtils.chainedTransformer(a, b).transform(null));         assertEquals("A", TransformerUtils.chainedTransformer(b, a).transform(null));         Collection<Transformer<Object, Object>> coll = new ArrayList<>();         coll.add(b);         coll.add(a);         assertEquals("A", TransformerUtils.chainedTransformer(coll).transform(null));          assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer());         assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(Collections.<Transformer<Object, Object>>emptyList()));          try {             TransformerUtils.chainedTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.chainedTransformer((Transformer[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.chainedTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             coll = new ArrayList<>();             coll.add(null);             coll.add(null);             TransformerUtils.chainedTransformer(coll);             fail();         } catch (final NullPointerException ex) {}     }      // ifTransformer     //------------------------------------------------------------------      @Test     public void testIfTransformer() {         final Transformer<Object, String> a = TransformerUtils.constantTransformer("A");         final Transformer<Object, String> b = TransformerUtils.constantTransformer("B");         final Transformer<Object, String> c = TransformerUtils.constantTransformer("C");          assertEquals("A", TransformerUtils.ifTransformer(TruePredicate.truePredicate(), a, b).transform(null));         assertEquals("B", TransformerUtils.ifTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));          final Predicate<Integer> lessThanFivePredicate = value -> value < 5;         // if/else tests         assertEquals("A", TransformerUtils.ifTransformer(lessThanFivePredicate, a, b).transform(1));         assertEquals("B", TransformerUtils.ifTransformer(lessThanFivePredicate, a, b).transform(5));          // if tests         final Predicate<String> equalsAPredicate = EqualPredicate.equalPredicate("A");         assertEquals("C", TransformerUtils.ifTransformer(equalsAPredicate, c).transform("A"));         assertEquals("B", TransformerUtils.ifTransformer(equalsAPredicate, c).transform("B"));          try {             TransformerUtils.ifTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.ifTransformer(TruePredicate.truePredicate(), null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.ifTransformer(null, ConstantTransformer.constantTransformer("A"));             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.ifTransformer(null, null, null);             fail();         } catch (final NullPointerException ex) {}     }      // switchTransformer     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testSwitchTransformer() {         final Transformer<String, String> a = TransformerUtils.constantTransformer("A");         final Transformer<String, String> b = TransformerUtils.constantTransformer("B");         final Transformer<String, String> c = TransformerUtils.constantTransformer("C");          assertEquals("A", TransformerUtils.switchTransformer(TruePredicate.truePredicate(), a, b).transform(null));         assertEquals("B", TransformerUtils.switchTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));          assertNull(TransformerUtils.<Object, String>switchTransformer(                 new Predicate[]{EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE")},                 new Transformer[]{a, b}).transform("WELL"));         assertEquals("A", TransformerUtils.switchTransformer(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Transformer[] { a, b }).transform("HELLO"));         assertEquals("B", TransformerUtils.switchTransformer(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Transformer[] { a, b }).transform("THERE"));          assertEquals("C", TransformerUtils.switchTransformer(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Transformer[] { a, b }, c).transform("WELL"));          Map<Predicate<String>, Transformer<String, String>> map = new HashMap<>();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         assertNull(TransformerUtils.switchTransformer(map).transform("WELL"));         assertEquals("A", TransformerUtils.switchTransformer(map).transform("HELLO"));         assertEquals("B", TransformerUtils.switchTransformer(map).transform("THERE"));         map.put(null, c);         assertEquals("C", TransformerUtils.switchTransformer(map).transform("WELL"));          assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]));         assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new HashMap<Predicate<Object>, Transformer<Object, Object>>()));         map = new HashMap<>();         map.put(null, null);         assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(map));          try {             TransformerUtils.switchTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(null, (Transformer[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(                     new Predicate[] { TruePredicate.truePredicate() },                     new Transformer[] { a, b });             fail();         } catch (final IllegalArgumentException ex) {}     }      // switchMapTransformer     //------------------------------------------------------------------      @Test     public void testSwitchMapTransformer() {         final Transformer<String, String> a = TransformerUtils.constantTransformer("A");         final Transformer<String, String> b = TransformerUtils.constantTransformer("B");         final Transformer<String, String> c = TransformerUtils.constantTransformer("C");          Map<String, Transformer<String, String>> map = new HashMap<>();         map.put("HELLO", a);         map.put("THERE", b);         assertNull(TransformerUtils.switchMapTransformer(map).transform("WELL"));         assertEquals("A", TransformerUtils.switchMapTransformer(map).transform("HELLO"));         assertEquals("B", TransformerUtils.switchMapTransformer(map).transform("THERE"));         map.put(null, c);         assertEquals("C", TransformerUtils.switchMapTransformer(map).transform("WELL"));          assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(new HashMap<Object, Transformer<Object, Object>>()));         map = new HashMap<>();         map.put(null, null);         assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(map));          try {             TransformerUtils.switchMapTransformer(null);             fail();         } catch (final NullPointerException ex) {}     }      // invokerTransformer     //------------------------------------------------------------------      @Test     public void testInvokerTransformer() {         final List<Object> list = new ArrayList<>();         assertEquals(0, TransformerUtils.invokerTransformer("size").transform(list));         list.add(new Object());         assertEquals(1, TransformerUtils.invokerTransformer("size").transform(list));         assertNull(TransformerUtils.invokerTransformer("size").transform(null));          try {             TransformerUtils.invokerTransformer(null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.invokerTransformer("noSuchMethod").transform(new Object());             fail();         } catch (final FunctorException ex) {}     }      // invokerTransformer2     //------------------------------------------------------------------      @Test     public void testInvokerTransformer2() {         final List<Object> list = new ArrayList<>();         assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer("contains",                 new Class[] { Object.class }, new Object[] { cString }).transform(list));         list.add(cString);         assertEquals(Boolean.TRUE, TransformerUtils.invokerTransformer("contains",                 new Class[] { Object.class }, new Object[] { cString }).transform(list));         assertNull(TransformerUtils.invokerTransformer("contains",                 new Class[]{Object.class}, new Object[]{cString}).transform(null));          try {             TransformerUtils.invokerTransformer(null, null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.invokerTransformer("noSuchMethod", new Class[] { Object.class },                     new Object[] { cString }).transform(new Object());             fail();         } catch (final FunctorException ex) {}         try {             TransformerUtils.invokerTransformer("badArgs", null, new Object[] { cString });             fail();         } catch (final IllegalArgumentException ex) {}         try {             TransformerUtils.invokerTransformer("badArgs", new Class[] { Object.class }, null);             fail();         } catch (final IllegalArgumentException ex) {}         try {             TransformerUtils.invokerTransformer("badArgs", new Class[] {}, new Object[] { cString });             fail();         } catch (final IllegalArgumentException ex) {}     }      // stringValueTransformer     //------------------------------------------------------------------      @Test     public void testStringValueTransformer() {         assertNotNull( "StringValueTransformer should NEVER return a null value.",             TransformerUtils.stringValueTransformer().transform(null));         assertEquals( "StringValueTransformer should return \"null\" when given a null argument.", "null",             TransformerUtils.stringValueTransformer().transform(null));         assertEquals( "StringValueTransformer should return toString value", "6",             TransformerUtils.stringValueTransformer().transform(6));     }      // instantiateFactory     //------------------------------------------------------------------      @Test     public void testInstantiateTransformerNull() {         try {             TransformerUtils.instantiateTransformer(null, new Object[] { "str" });             fail();         } catch (final IllegalArgumentException ex) {}         try {             TransformerUtils.instantiateTransformer(new Class[] {}, new Object[] { "str" });             fail();         } catch (final IllegalArgumentException ex) {}          Transformer<Class<?>, Object> trans = TransformerUtils.instantiateTransformer(new Class[] { Long.class }, new Object[] { null });         try {             trans.transform(String.class);             fail();         } catch (final FunctorException ex) {}          trans = TransformerUtils.instantiateTransformer();         assertEquals("", trans.transform(String.class));          trans = TransformerUtils.instantiateTransformer(new Class[] { Long.TYPE }, new Object[] {1000L});         assertEquals(new Date(1000L), trans.transform(Date.class));     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Transformer singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionTransformer.INSTANCE,             NOPTransformer.INSTANCE,             StringValueTransformer.stringValueTransformer(),         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization("Singleton pattern broken for " + original.getClass(), original);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Comparator;  import org.junit.Test;  /**  * Tests ComparatorUtils.  *  */ public class ComparatorUtilsTest {     @Test     public void booleanComparator() {         Comparator<Boolean> comp = ComparatorUtils.booleanComparator(true);         assertTrue(comp.compare(Boolean.TRUE, Boolean.FALSE) < 0);         assertEquals(0, comp.compare(Boolean.TRUE, Boolean.TRUE));         assertTrue(comp.compare(Boolean.FALSE, Boolean.TRUE) > 0);          comp = ComparatorUtils.booleanComparator(false);         assertTrue(comp.compare(Boolean.TRUE, Boolean.FALSE) > 0);         assertEquals(0, comp.compare(Boolean.TRUE, Boolean.TRUE));         assertTrue(comp.compare(Boolean.FALSE, Boolean.TRUE) < 0);     }      @Test     public void chainedComparator() {         // simple test: chain 2 natural comparators         final Comparator<Integer> comp = ComparatorUtils.chainedComparator(ComparatorUtils.<Integer>naturalComparator(),                 ComparatorUtils.naturalComparator());         assertTrue(comp.compare(1, 2) < 0);         assertEquals(0, comp.compare(1, 1));         assertTrue(comp.compare(2, 1) > 0);     }      @Test     public void max() {         final Comparator<Integer> reversed =                 ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());          assertEquals(Integer.valueOf(10), ComparatorUtils.max(1, 10, null));         assertEquals(Integer.valueOf(10), ComparatorUtils.max(10, -10, null));          assertEquals(Integer.valueOf(1), ComparatorUtils.max(1, 10, reversed));         assertEquals(Integer.valueOf(-10), ComparatorUtils.max(10, -10, reversed));          try {             ComparatorUtils.max(1, null, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             ComparatorUtils.max(null, 10, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void min() {         final Comparator<Integer> reversed =                 ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());          assertEquals(Integer.valueOf(1), ComparatorUtils.min(1, 10, null));         assertEquals(Integer.valueOf(-10), ComparatorUtils.min(10, -10, null));          assertEquals(Integer.valueOf(10), ComparatorUtils.min(1, 10, reversed));         assertEquals(Integer.valueOf(10), ComparatorUtils.min(10, -10, reversed));          try {             ComparatorUtils.min(1, null, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             ComparatorUtils.min(null, 10, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void nullLowComparator() {         final Comparator<Integer> comp = ComparatorUtils.nullLowComparator(null);         assertTrue(comp.compare(null, 10) < 0);         assertEquals(0, comp.compare(null, null));         assertTrue(comp.compare(10, null) > 0);     }      @Test     public void nullHighComparator() {         final Comparator<Integer> comp = ComparatorUtils.nullHighComparator(null);         assertTrue(comp.compare(null, 10) > 0);         assertEquals(0, comp.compare(null, null));         assertTrue(comp.compare(10, null) < 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.List; import java.util.ListIterator; import java.util.Map; import java.util.HashMap; import java.util.Arrays; import java.util.ArrayList;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.ListValuedMap; import org.apache.commons.collections4.MultiValuedMap;  /**  * Test ArrayListValuedHashMap  *  * @since 4.1  */ public class ArrayListValuedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public ArrayListValuedHashMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ArrayListValuedHashMapTest.class);     }      // -----------------------------------------------------------------------     @Override     public ListValuedMap<K, V> makeObject() {         return new ArrayListValuedHashMap<>();     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testListValuedMapAdd() {         final ListValuedMap<K, V> listMap = makeObject();         assertTrue(listMap.get((K) "whatever") instanceof List);         final List<V> list = listMap.get((K) "A");         list.add((V) "a1");         assertEquals(1, listMap.size());         assertTrue(listMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testListValuedMapAddViaListIterator() {         final ListValuedMap<K, V> listMap = makeObject();         final ListIterator<V> listIt = listMap.get((K) "B").listIterator();         assertFalse(listIt.hasNext());         listIt.add((V) "b1");         listIt.add((V) "b2");         listIt.add((V) "b3");         assertEquals(3, listMap.size());         assertTrue(listMap.containsKey("B"));         // As ListIterator always adds before the current cursor         assertFalse(listIt.hasNext());     }      @SuppressWarnings("unchecked")     public void testListValuedMapRemove() {         final ListValuedMap<K, V> listMap = makeObject();         final List<V> list = listMap.get((K) "A");         list.add((V) "a1");         list.add((V) "a2");         list.add((V) "a3");         assertEquals(3, listMap.size());         assertEquals("a1", list.remove(0));         assertEquals(2, listMap.size());         assertEquals("a2", list.remove(0));         assertEquals(1, listMap.size());         assertEquals("a3", list.remove(0));         assertEquals(0, listMap.size());         assertFalse(listMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testListValuedMapRemoveViaListIterator() {         final ListValuedMap<K, V> listMap = makeObject();         ListIterator<V> listIt = listMap.get((K) "B").listIterator();         listIt.add((V) "b1");         listIt.add((V) "b2");         assertEquals(2, listMap.size());         assertTrue(listMap.containsKey("B"));         listIt = listMap.get((K) "B").listIterator();         while (listIt.hasNext()) {             listIt.next();             listIt.remove();         }         assertFalse(listMap.containsKey("B"));         listIt.add((V) "b1");         listIt.add((V) "b2");         assertTrue(listMap.containsKey("B"));         assertEquals(2, listMap.get((K) "B").size());     }      @SuppressWarnings({ "unchecked", "rawtypes" })     public void testEqualsHashCodeContract() {         final MultiValuedMap map1 = makeObject();         final MultiValuedMap map2 = makeObject();          map1.put("a", "a1");         map1.put("a", "a2");         map2.put("a", "a1");         map2.put("a", "a2");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map2.put("a", "a2");         assertNotSame(map1, map2);         assertNotSame(map1.hashCode(), map2.hashCode());     }      @SuppressWarnings({ "unchecked", "rawtypes" })     public void testListValuedMapEqualsHashCodeContract() {         final ListValuedMap map1 = makeObject();         final ListValuedMap map2 = makeObject();          map1.put("a", "a1");         map1.put("a", "a2");         map2.put("a", "a1");         map2.put("a", "a2");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map1.put("b", "b1");         map1.put("b", "b2");         map2.put("b", "b2");         map2.put("b", "b1");         assertNotSame(map1, map2);         assertNotSame(map1.hashCode(), map2.hashCode());     }      public void testArrayListValuedHashMap() {         ListValuedMap<K, V> listMap;         ListValuedMap<K, V> listMap1;         final Map<K, V> map = new HashMap<>();         final Map<K, V> map1 = new HashMap<>();         map.put((K) "A", (V) "W");         map.put((K) "B", (V) "X");         map.put((K) "C", (V) "F");          listMap = new ArrayListValuedHashMap<>(map);         assertEquals(1, listMap.get((K) "A").size());         assertEquals(1, listMap.get((K) "B").size());         assertEquals(1, listMap.get((K) "C").size());          listMap1 = new ArrayListValuedHashMap<>(map1);         assertEquals("{}", listMap1.toString());     }      public void testTrimToSize(){         final ArrayListValuedHashMap<K, V> listMap = new ArrayListValuedHashMap<>(4);          assertEquals("{}", listMap.toString());         listMap.put((K) "A", (V) "W");         listMap.put((K) "A", (V) "X");         listMap.put((K) "B", (V) "F");         assertEquals(2, listMap.get((K) "A").size());         assertEquals(1, listMap.get((K) "B").size());          listMap.trimToSize();         assertEquals(2, listMap.get((K) "A").size());         assertEquals(1, listMap.get((K) "B").size());     }      public void testWrappedListAdd() {         final ListValuedMap<K, V> listMap = makeObject();         final List<V> listA = listMap.get((K) "A");         listA.add(0, (V) "W");         listA.add(1, (V) "X");         listA.add(2, (V) "F");         assertEquals("{A=[W, X, F]}", listMap.toString());         listMap.get((K) "A").set(1, (V) "Q");         assertEquals("{A=[W, Q, F]}", listMap.toString());     }      public void testWrappedListAddAll() {         final ListValuedMap<K, V> listMap = makeObject();         final List<V> listA = listMap.get((K) "A");         final List<V> list = Arrays.asList((V) "W", (V) "X", (V) "F");         listA.addAll(0, list);         assertEquals("{A=[W, X, F]}", listMap.toString());          final List<V> list1 = Arrays.asList((V) "Q", (V) "Q", (V) "L");         listA.addAll(3, list1);         assertEquals("{A=[W, X, F, Q, Q, L]}", listMap.toString());         assertEquals("W", listMap.get((K) "A").get(0));         assertEquals("X", listMap.get((K) "A").get(1));         assertEquals("F", listMap.get((K) "A").get(2));         assertEquals("Q", listMap.get((K) "A").get(3));         assertEquals("Q", listMap.get((K) "A").get(4));         assertEquals("L", listMap.get((K) "A").get(5));         assertEquals(0, listMap.get((K) "A").indexOf("W"));         assertEquals(2, listMap.get((K) "A").indexOf("F"));         assertEquals(-1, listMap.get((K) "A").indexOf("C"));         assertEquals(3, listMap.get((K) "A").indexOf("Q"));         assertEquals(4, listMap.get((K) "A").lastIndexOf("Q"));         assertEquals(-1, listMap.get((K) "A").lastIndexOf("A"));          final List<V> list2 = new ArrayList<>();         listMap.get((K) "B").addAll(0, list2);         assertEquals("{A=[W, X, F, Q, Q, L]}", listMap.toString());         final List<V> list3 = listMap.get((K) "A").subList(1, 4);         assertEquals(3, list3.size());         assertEquals("Q", list3.get(2));     }      public void testValuesListIteratorMethods(){         final ListValuedMap<K, V> listMap = makeObject();         final List<V> listA = listMap.get((K) "A");         final List<V> list = Arrays.asList((V) "W", (V) "X", (V) "F", (V) "Q", (V) "Q", (V) "F");         listA.addAll(0, list);         final ListIterator<V> it = listMap.get((K) "A").listIterator(1);         assertTrue(it.hasNext());         assertEquals("X", it.next());         assertEquals("F", it.next());         assertTrue(it.hasPrevious());         assertEquals("F", it.previous());         assertEquals(2, it.nextIndex());         assertEquals(1, it.previousIndex());         it.set((V) "Z");         assertEquals("Z", it.next());         assertEquals("Q", it.next());     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/ArrayListValuedHashMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/ArrayListValuedHashMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.SetValuedMap; import org.apache.commons.collections4.bag.AbstractBagTest; import org.apache.commons.collections4.bag.HashBag; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.map.AbstractMapTest; import org.apache.commons.collections4.multiset.AbstractMultiSetTest; import org.apache.commons.collections4.set.AbstractSetTest;  /**  * Abstract test class for {@link MultiValuedMap} contract and methods.  * <p>  * To use, extend this class and implement the {@link #makeObject} method and if  * necessary override the {@link #makeFullMap()} method.  *  * @since 4.1  */ public abstract class AbstractMultiValuedMapTest<K, V> extends AbstractObjectTest {      /** Map created by reset(). */     protected MultiValuedMap<K, V> map;      /** MultiValuedHashMap created by reset(). */     protected MultiValuedMap<K, V> confirmed;      public AbstractMultiValuedMapTest(final String testName) {         super(testName);     }      @Override     public abstract MultiValuedMap<K, V> makeObject();      @Override     public String getCompatibilityVersion() {         return "4.1"; // MultiValuedMap has been added in version 4.1     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} support the {@code put} and      * {@code putAll} operations adding new mappings.      * <p>      * Default implementation returns true. Override if your collection class      * does not support put adding.      */     public boolean isAddSupported() {         return true;     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} support the {@code remove} and      * {@code clear} operations.      * <p>      * Default implementation returns true. Override if your collection class      * does not support removal operations.      */     public boolean isRemoveSupported() {         return true;     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} supports null keys.      * <p>      * Default implementation returns true. Override if your collection class      * does not support null keys.      */     public boolean isAllowNullKey() {         return true;     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} supports set value.      * <p>      * Default implementation returns false. Override if your collection class      * supports set value.      */     public boolean isHashSetValue() {         return false;     }      @Override     public boolean isTestSerialization() {         return true;     }      /**      * Returns the set of keys in the mappings used to test the map. This method      * must return an array with the same length as {@link #getSampleValues()}      * and all array elements must be different. The default implementation      * constructs a set of String keys, and includes a single null key if      * {@link #isAllowNullKey()} returns {@code true}.      */     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         final Object[] result = new Object[] {             "one", "one", "two", "two",             "three", "three"         };         return (K[]) result;     }      /**      * Returns the set of values in the mappings used to test the map. This      * method must return an array with the same length as      * {@link #getSampleKeys()}. The default implementation constructs a set of      * String values      */     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         final Object[] result = new Object[] {             "uno", "un", "dos", "deux",             "tres", "trois"         };         return (V[]) result;     }      protected MultiValuedMap<K, V> makeFullMap() {         final MultiValuedMap<K, V> map = makeObject();         addSampleMappings(map);         return map;     }      protected void addSampleMappings(final MultiValuedMap<? super K, ? super V> map) {         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         for (int i = 0; i < keys.length; i++) {             map.put(keys[i], values[i]);         }     }      /**      * Override to return a MultiValuedMap other than ArrayListValuedHashMap      * as the confirmed map.      *      * @return a MultiValuedMap that is known to be valid      */     public MultiValuedMap<K, V> makeConfirmedMap() {         return new ArrayListValuedHashMap<>();     }      public MultiValuedMap<K, V> getConfirmed() {         return this.confirmed;     }      public void setConfirmed(final MultiValuedMap<K, V> map) {         this.confirmed = map;     }      public MultiValuedMap<K, V> getMap() {         return this.map;     }      /**      * Resets the {@link #map} and {@link #confirmed} fields to empty.      */     public void resetEmpty() {         this.map = makeObject();         this.confirmed = makeConfirmedMap();     }      /**      * Resets the {@link #map} and {@link #confirmed} fields to full.      */     public void resetFull() {         this.map = makeFullMap();         this.confirmed = makeConfirmedMap();         final K[] k = getSampleKeys();         final V[] v = getSampleValues();         for (int i = 0; i < k.length; i++) {             confirmed.put(k[i], v[i]);         }     }      @SuppressWarnings("unchecked")     public void testNoMappingReturnsEmptyCol() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.get((K) "whatever").isEmpty());     }      public void testMultipleValues() {         final MultiValuedMap<K, V> map = makeFullMap();         @SuppressWarnings("unchecked")         final Collection<V> col = map.get((K) "one");         assertTrue(col.contains("uno"));         assertTrue(col.contains("un"));     }      @SuppressWarnings("unchecked")     public void testGet() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.get((K) "one").contains("uno"));         assertTrue(map.get((K) "one").contains("un"));         assertTrue(map.get((K) "two").contains("dos"));         assertTrue(map.get((K) "two").contains("deux"));         assertTrue(map.get((K) "three").contains("tres"));         assertTrue(map.get((K) "three").contains("trois"));     }      @SuppressWarnings("unchecked")     public void testAddMappingThroughGet(){         if (!isAddSupported()) {             return;         }         resetEmpty();         final MultiValuedMap<K, V> map =  getMap();         final Collection<V> col1 = map.get((K) "one");         final Collection<V> col2 = map.get((K) "one");         assertTrue(col1.isEmpty());         assertTrue(col2.isEmpty());         assertEquals(0, map.size());         col1.add((V) "uno");         col2.add((V) "un");         assertTrue(map.containsKey("one"));         assertTrue(map.containsMapping("one", "uno"));         assertTrue(map.containsMapping("one", "un"));         assertTrue(map.containsValue("uno"));         assertTrue(map.containsValue("un"));         assertTrue(col1.contains("un"));         assertTrue(col2.contains("uno"));     }      public void testRemoveMappingThroughGet() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final MultiValuedMap<K, V> map = getMap();         @SuppressWarnings("unchecked")         Collection<V> col = map.get((K) "one");         assertEquals(2, col.size());         assertEquals(6, map.size());         col.remove("uno");         col.remove("un");         assertFalse(map.containsKey("one"));         assertFalse(map.containsMapping("one", "uno"));         assertFalse(map.containsMapping("one", "un"));         assertFalse(map.containsValue("uno"));         assertFalse(map.containsValue("un"));         assertEquals(4, map.size());         col = map.remove("one");         assertNotNull(col);         assertEquals(0, col.size());     }      public void testRemoveMappingThroughGetIterator() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final MultiValuedMap<K, V> map = getMap();         @SuppressWarnings("unchecked")         final Iterator<V> it = map.get((K) "one").iterator();         while (it.hasNext()) {             it.next();             it.remove();         }         assertFalse(map.containsKey("one"));         assertFalse(map.containsMapping("one", "uno"));         assertFalse(map.containsMapping("one", "un"));         assertFalse(map.containsValue("uno"));         assertFalse(map.containsValue("un"));         assertEquals(4, map.size());         final Collection<V> coll = map.remove("one");         assertNotNull(coll);         assertEquals(0, coll.size());     }      public void testContainsValue() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.containsValue("uno"));         assertTrue(map.containsValue("un"));         assertTrue(map.containsValue("dos"));         assertTrue(map.containsValue("deux"));         assertTrue(map.containsValue("tres"));         assertTrue(map.containsValue("trois"));         assertFalse(map.containsValue("quatro"));     }      public void testKeyContainsValue() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.containsMapping("one", "uno"));         assertTrue(map.containsMapping("one", "un"));         assertTrue(map.containsMapping("two", "dos"));         assertTrue(map.containsMapping("two", "deux"));         assertTrue(map.containsMapping("three", "tres"));         assertTrue(map.containsMapping("three", "trois"));         assertFalse(map.containsMapping("four", "quatro"));     }      @SuppressWarnings("unchecked")     public void testValues() {         final MultiValuedMap<K, V> map = makeFullMap();         final HashSet<V> expected = new HashSet<>();         expected.add((V) "uno");         expected.add((V) "dos");         expected.add((V) "tres");         expected.add((V) "un");         expected.add((V) "deux");         expected.add((V) "trois");         final Collection<V> c = map.values();         assertEquals(6, c.size());         assertEquals(expected, new HashSet<>(c));     }  //    public void testKeyedIterator() { //        final MultiValuedMap<K, V> map = makeFullMap(); //        final ArrayList<Object> actual = new ArrayList<Object>(IteratorUtils.toList(map.iterator("one"))); //        final ArrayList<Object> expected = new ArrayList<Object>(Arrays.asList("uno", "un")); //        assertEquals(expected, actual); //    }      @SuppressWarnings("unchecked")     public void testRemoveAllViaValuesIterator() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertTrue(map.get((K) "one").isEmpty());         assertTrue(map.isEmpty());     }      public void testRemoveViaValuesRemove() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         final Collection<V> values = map.values();         values.remove("uno");         values.remove("un");         assertFalse(map.containsKey("one"));         assertEquals(4, map.size());     }      /*public void testRemoveViaGetCollectionRemove() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         Collection<V> values = map.get("one");         values.remove("uno");         values.remove("un");         assertFalse(map.containsKey("one"));         assertEquals(4, map.size());     }*/  //    public void testRemoveAllViaKeyedIterator() { //        if (!isRemoveSupported()) { //            return; //        } //        final MultiValuedMap<K, V> map = makeFullMap(); //        for (final Iterator<?> i = map.iterator("one"); i.hasNext();) { //            i.next(); //            i.remove(); //        } //        assertNull(map.get("one")); //        assertEquals(4, map.size()); //    }      public void testEntriesCollectionIterator() {         final MultiValuedMap<K, V> map = makeFullMap();         final Collection<V> values = new ArrayList<>(map.values());         final Iterator<Map.Entry<K, V>> iterator = map.entries().iterator();         while (iterator.hasNext()) {             final Map.Entry<K, V> entry = iterator.next();             assertTrue(map.containsMapping(entry.getKey(), entry.getValue()));             assertTrue(values.contains(entry.getValue()));             if (isRemoveSupported()) {                 assertTrue(values.remove(entry.getValue()));             }         }         if (isRemoveSupported()) {             assertTrue(values.isEmpty());         }     }      @SuppressWarnings("unchecked")     public void testRemoveAllViaEntriesIterator() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         for (final Iterator<?> i = map.entries().iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertTrue(map.get((K) "one").isEmpty());         assertEquals(0, map.size());     }      public void testSize() {         assertEquals(6, makeFullMap().size());     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMapEquals() {         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> one = makeObject();         final Integer value = Integer.valueOf(1);         one.put((K) "One", (V) value);         one.removeMapping("One", value);          final MultiValuedMap<K, V> two = makeObject();         assertEquals(two, one);     }      @SuppressWarnings("unchecked")     public void testSizeWithPutRemove() {         if (!isRemoveSupported() || !isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         assertEquals(0, map.size());         map.put((K) "A", (V) "AA");         assertEquals(1, map.size());         map.put((K) "B", (V) "BA");         assertEquals(2, map.size());         map.put((K) "B", (V) "BB");         assertEquals(3, map.size());         map.put((K) "B", (V) "BC");         assertEquals(4, map.size());         map.remove("A");         assertEquals(3, map.size());         map.removeMapping("B", "BC");         assertEquals(2, map.size());     }      public void testKeySetSize() {         final MultiValuedMap<K, V> map = makeFullMap();         assertEquals(3, map.keySet().size());     }      @SuppressWarnings("unchecked")     public void testSize_Key() {         final MultiValuedMap<K, V> map = makeFullMap();         assertEquals(2, map.get((K) "one").size());         assertEquals(2, map.get((K) "two").size());         assertEquals(2, map.get((K) "three").size());         if (!isAddSupported()) {             return;         }         map.put((K) "A", (V) "AA");         assertEquals(1, map.get((K) "A").size());         //assertEquals(0, map.get("B").size());         map.put((K) "B", (V) "BA");         assertEquals(1, map.get((K) "A").size());         assertEquals(1, map.get((K) "B").size());         map.put((K) "B", (V) "BB");         assertEquals(1, map.get((K) "A").size());         assertEquals(2, map.get((K) "B").size());         map.put((K) "B", (V) "BC");         assertEquals(1, map.get((K) "A").size());         assertEquals(3, map.get((K) "B").size());         if (!isRemoveSupported()) {             return;         }         map.remove("A");         //assertEquals(0, map.get("A").size());         assertEquals(3, map.get((K) "B").size());         map.removeMapping("B", "BC");         //assertEquals(0, map.get("A").size());         assertEquals(2, map.get((K) "B").size());     }  //    @SuppressWarnings("unchecked") //    public void testIterator_Key() { //        final MultiValuedMap<K, V> map = makeFullMap(); //        Iterator<V> it = map.iterator("one"); //        assertEquals(true, it.hasNext()); //        Set<V> values = new HashSet<V>(); //        while (it.hasNext()) { //            values.add(it.next()); //        } //        assertEquals(true, values.contains("un")); //        assertEquals(true, values.contains("uno")); //        assertEquals(false, map.iterator("A").hasNext()); //        assertEquals(false, map.iterator("A").hasNext()); //        if (!isAddSupported()) { //            return; //        } //        map.put((K) "A", (V) "AA"); //        it = map.iterator("A"); //        assertEquals(true, it.hasNext()); //        it.next(); //        assertEquals(false, it.hasNext()); //    }      @SuppressWarnings("unchecked")     public void testContainsValue_Key() {         final MultiValuedMap<K, V> map = makeFullMap();         assertEquals(true, map.containsMapping("one", "uno"));         assertEquals(false, map.containsMapping("two", "2"));         if (!isAddSupported()) {             return;         }         map.put((K) "A", (V) "AA");         assertEquals(true, map.containsMapping("A", "AA"));         assertEquals(false, map.containsMapping("A", "AB"));     }      @SuppressWarnings("unchecked")     public void testPutAll_Map1() {         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> original = makeObject();         original.put((K) "key", (V) "object1");         original.put((K) "key", (V) "object2");          final MultiValuedMap<K, V> test = makeObject();         test.put((K) "keyA", (V) "objectA");         test.put((K) "key", (V) "object0");         test.putAll(original);          try {             final MultiValuedMap<K, V> originalNull = null;             test.putAll(originalNull);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          assertEquals(2, test.keySet().size());         assertEquals(4, test.size());         assertEquals(1, test.get((K) "keyA").size());         assertEquals(3, test.get((K) "key").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_Map2() {         if (!isAddSupported()) {             return;         }         final Map<K, V> original = new HashMap<>();         original.put((K) "keyX", (V) "object1");         original.put((K) "keyY", (V) "object2");          final MultiValuedMap<K, V> test = makeObject();         test.put((K) "keyA", (V) "objectA");         test.put((K) "keyX", (V) "object0");         test.putAll(original);          try {             final Map<K, V> originalNull = null;             test.putAll(originalNull);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          assertEquals(3, test.keySet().size());         assertEquals(4, test.size());         assertEquals(1, test.get((K) "keyA").size());         assertEquals(2, test.get((K) "keyX").size());         assertEquals(1, test.get((K) "keyY").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_KeyIterable() {         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         Collection<V> coll = (Collection<V>) Arrays.asList("X", "Y", "Z");          assertEquals(true, map.putAll((K) "A", coll));         assertEquals(3, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));          try {             map.putAll((K) "A", null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          assertEquals(3, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));          assertEquals(false, map.putAll((K) "A", new ArrayList<V>()));         assertEquals(3, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));          coll = (Collection<V>) Arrays.asList("M");         assertEquals(true, map.putAll((K) "A", coll));         assertEquals(4, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));         assertEquals(true, map.containsMapping("A", "M"));     }      @SuppressWarnings("unchecked")     public void testRemove_KeyItem() {         if (!isRemoveSupported() || !isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         map.put((K) "A", (V) "AA");         map.put((K) "A", (V) "AB");         map.put((K) "A", (V) "AC");         assertEquals(false, map.removeMapping("C", "CA"));         assertEquals(false, map.removeMapping("A", "AD"));         assertEquals(true, map.removeMapping("A", "AC"));         assertEquals(true, map.removeMapping("A", "AB"));         assertEquals(true, map.removeMapping("A", "AA"));         //assertEquals(new MultiValuedHashMap<K, V>(), map);     }      public void testToString(){         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         map.put((K) "A", (V) "X");         map.put((K) "A", (V) "Y");         map.put((K) "A", (V) "Z");         map.put((K) "B", (V) "U");         map.put((K) "B", (V) "V");         map.put((K) "B", (V) "W");         assertTrue(             "{A=[X, Y, Z], B=[U, V, W]}".equals(map.toString()) ||             "{B=[U, V, W], A=[X, Y, Z]}".equals(map.toString())         );          try {             final MultiValuedMap<K, V> originalNull = null;             map.putAll(originalNull);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }         assertTrue(             "{A=[X, Y, Z], B=[U, V, W]}".equals(map.toString()) ||             "{B=[U, V, W], A=[X, Y, Z]}".equals(map.toString())         );          map.remove("A");         map.remove("B");         assertEquals("{}", map.toString());     }      public void testKeysMultiSet() {         final MultiValuedMap<K, V> map = makeFullMap();         final MultiSet<K> keyMultiSet = map.keys();         assertEquals(2, keyMultiSet.getCount("one"));         assertEquals(2, keyMultiSet.getCount("two"));         assertEquals(2, keyMultiSet.getCount("three"));         assertEquals(0, keyMultiSet.getCount("conut"));         assertEquals(6, keyMultiSet.size());     }      public void testKeysBagIterator() {         final MultiValuedMap<K, V> map = makeFullMap();         final Collection<K> col = new ArrayList<>();         final Iterator<K> it = map.keys().iterator();         while (it.hasNext()) {             col.add(it.next());         }         final Bag<K> bag = new HashBag<>(col);         assertEquals(2, bag.getCount("one"));         assertEquals(2, bag.getCount("two"));         assertEquals(2, bag.getCount("three"));         assertEquals(6, bag.size());     }      @SuppressWarnings("unchecked")     public void testKeysBagContainsAll() {         final MultiValuedMap<K, V> map = makeFullMap();         final MultiSet<K> keyMultiSet = map.keys();         final Collection<K> col = (Collection<K>) Arrays.asList("one", "two", "three", "one", "two", "three");         assertTrue(keyMultiSet.containsAll(col));     }      public void testAsMapGet() {         resetEmpty();         Map<K, Collection<V>> mapCol = getMap().asMap();         assertNull(mapCol.get("one"));         assertEquals(0, mapCol.size());          resetFull();         mapCol = getMap().asMap();         final Collection<V> col = mapCol.get("one");         assertNotNull(col);         assertTrue(col.contains("un"));         assertTrue(col.contains("uno"));     }      public void testAsMapRemove() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final Map<K, Collection<V>> mapCol = getMap().asMap();         mapCol.remove("one");         assertFalse(getMap().containsKey("one"));         assertEquals(4, getMap().size());     }      public void testMapIterator() {         resetEmpty();         MapIterator<K, V> mapIt  = getMap().mapIterator();         assertFalse(mapIt.hasNext());          resetFull();         mapIt = getMap().mapIterator();         while (mapIt.hasNext()) {             final K key = mapIt.next();             final V value = mapIt.getValue();             assertTrue(getMap().containsMapping(key, value));         }     }      public void testMapIteratorRemove() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final MapIterator<K, V> mapIt = getMap().mapIterator();         while (mapIt.hasNext()) {             mapIt.next();             mapIt.remove();         }         assertTrue(getMap().isEmpty());     }      @SuppressWarnings("unchecked")     public void testMapIteratorUnsupportedSet() {         resetFull();         final MapIterator<K, V> mapIt = getMap().mapIterator();         mapIt.next();         try {             mapIt.setValue((V) "some value");             fail();         } catch (final UnsupportedOperationException e) {         }     }      public void testMultiValuedMapIterator() {         final MultiValuedMap<K, V> map = makeFullMap();         final MapIterator<K, V> it = map.mapIterator();          try {             it.getKey();             fail();         } catch (final IllegalStateException ise) {         }         try {             it.getValue();             fail();         } catch (final IllegalStateException ise) {         }         if (isAddSupported()) {             try {                 it.setValue((V) "V");                 fail();             } catch (final IllegalStateException ise) {             }         }          if (!isHashSetValue() && isAddSupported()) {             assertTrue(it.hasNext() );             assertEquals("one", it.next());             assertEquals("one", it.getKey());             assertEquals("uno", it.getValue());             assertEquals("one", it.next());             assertEquals("one", it.getKey());             assertEquals("un", it.getValue());             assertEquals("two", it.next());             assertEquals("two", it.getKey());             assertEquals("dos", it.getValue());             assertEquals("two", it.next());             assertEquals("two", it.getKey());             assertEquals("deux", it.getValue());             assertEquals("three", it.next());             assertEquals("three", it.getKey());             assertEquals("tres", it.getValue());             assertEquals("three", it.next());             assertEquals("three", it.getKey());             assertEquals("trois", it.getValue());             try {                 it.setValue((V) "threetrois");                 fail();             } catch (final UnsupportedOperationException e) {             }         }     }      // -----------------------------------------------------------------------     // Manual serialization testing as this class cannot easily     // extend the AbstractTestMap     // -----------------------------------------------------------------------      public void testEmptyMapCompatibility() throws Exception {         final MultiValuedMap<?, ?> map = makeObject();         final MultiValuedMap<?, ?> map2 =                 (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));         assertEquals("Map is empty", 0, map2.size());     }      @SuppressWarnings({ "rawtypes", "unchecked" })     public void testFullMapCompatibility() throws Exception {         final MultiValuedMap map = makeFullMap();         final MultiValuedMap map2 =                 (MultiValuedMap) readExternalFormFromDisk(getCanonicalFullCollectionName(map));         assertEquals("Map is the right size", map.size(), map2.size());         for (final Object key : map.keySet()) {             assertTrue("Map had inequal elements",                        CollectionUtils.isEqualCollection(map.get(key), map2.get(key)));             if (isRemoveSupported()) {                 map2.remove(key);             }         }         if (isRemoveSupported()) {             assertEquals("Map had extra values", 0, map2.size());         }     }      // Bulk Tests     /**      * Bulk test {@link MultiValuedMap#entries()}. This method runs through all      * of the tests in {@link AbstractCollectionTest}. After modification      * operations, {@link #verify()} is invoked to ensure that the map and the      * other collection views are still valid.      *      * @return a {@link AbstractCollectionTest} instance for testing the map's      *         values collection      */     public BulkTest bulkTestMultiValuedMapEntries() {         return new TestMultiValuedMapEntries();     }      public class TestMultiValuedMapEntries extends AbstractCollectionTest<Entry<K, V>> {         public TestMultiValuedMapEntries() {             super("");         }          @SuppressWarnings("unchecked")         @Override         public Entry<K, V>[] getFullElements() {             return makeFullMap().entries().toArray(new Entry[0]);         }          @Override         public Collection<Entry<K, V>> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().entries();         }          @Override         public Collection<Entry<K, V>> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().entries();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             // Add not supported in entries view             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMultiValuedMapTest.this.resetFull();             setCollection(AbstractMultiValuedMapTest.this.getMap().entries());             TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());         }          @Override         public void resetEmpty() {             AbstractMultiValuedMapTest.this.resetEmpty();             setCollection(AbstractMultiValuedMapTest.this.getMap().entries());             TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());         }          @Override         public Collection<Entry<K, V>> makeConfirmedCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public Collection<Entry<K, V>> makeConfirmedFullCollection() {             // never gets called, reset methods are overridden             return null;         }      }      /**      * Bulk test {@link MultiValuedMap#keySet()}. This method runs through all      * of the tests in {@link AbstractSetTest}. After modification operations,      * {@link #verify()} is invoked to ensure that the map and the other      * collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the map's key set      */     public BulkTest bulkTestMultiValuedMapKeySet() {         return new TestMultiValuedMapKeySet();     }      public class TestMultiValuedMapKeySet extends AbstractSetTest<K> {         public TestMultiValuedMapKeySet() {             super("");         }          @SuppressWarnings("unchecked")         @Override         public K[] getFullElements() {             return (K[]) AbstractMultiValuedMapTest.this.makeFullMap().keySet().toArray();         }          @Override         public Set<K> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().keySet();         }          @Override         public Set<K> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().keySet();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }      }      /**      * Bulk test {@link MultiValuedMap#values()}. This method runs through all      * of the tests in {@link AbstractCollectionTest}. After modification      * operations, {@link #verify()} is invoked to ensure that the map and the      * other collection views are still valid.      *      * @return a {@link AbstractCollectionTest} instance for testing the map's      *         values collection      */     public BulkTest bulkTestMultiValuedMapValues() {         return new TestMultiValuedMapValues();     }      public class TestMultiValuedMapValues extends AbstractCollectionTest<V> {         public TestMultiValuedMapValues() {             super("");         }          @Override         public V[] getFullElements() {             return getSampleValues();         }          @Override         public Collection<V> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().values();         }          @Override         public Collection<V> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().values();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMultiValuedMapTest.this.resetFull();             setCollection(AbstractMultiValuedMapTest.this.getMap().values());             TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());         }          @Override         public void resetEmpty() {             AbstractMultiValuedMapTest.this.resetEmpty();             setCollection(AbstractMultiValuedMapTest.this.getMap().values());             TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());         }          @Override         public Collection<V> makeConfirmedCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public Collection<V> makeConfirmedFullCollection() {             // never gets called, reset methods are overridden             return null;         }      }      /**      * Bulk test {@link MultiValuedMap#keys()}. This method runs through all of      * the tests in {@link AbstractBagTest}. After modification operations,      * {@link #verify()} is invoked to ensure that the map and the other      * collection views are still valid.      *      * @return a {@link AbstractBagTest} instance for testing the map's values      *         collection      */     public BulkTest bulkTestMultiValuedMapKeys() {         return new TestMultiValuedMapKeys();     }      public class TestMultiValuedMapKeys extends AbstractMultiSetTest<K> {          public TestMultiValuedMapKeys() {             super("");         }          @Override         public K[] getFullElements() {             return getSampleKeys();         }          @Override         public MultiSet<K> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().keys();         }          @Override         public MultiSet<K> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().keys();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return false;         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMultiValuedMapTest.this.resetFull();             setCollection(AbstractMultiValuedMapTest.this.getMap().keys());             TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());         }          @Override         public void resetEmpty() {             AbstractMultiValuedMapTest.this.resetEmpty();             setCollection(AbstractMultiValuedMapTest.this.getMap().keys());             TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());         }      }      public BulkTest bulkTestAsMap() {         return new TestMultiValuedMapAsMap();     }      public class TestMultiValuedMapAsMap extends AbstractMapTest<K, Collection<V>> {          public TestMultiValuedMapAsMap() {             super("");         }          @Override         public Map<K, Collection<V>> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().asMap();         }          @Override         public Map<K, Collection<V>> makeFullMap() {             return AbstractMultiValuedMapTest.this.makeFullMap().asMap();         }          @Override         @SuppressWarnings("unchecked")         public K[] getSampleKeys() {             final K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();             final Object[] finalKeys = new Object[3];             for (int i = 0; i < 3; i++) {                 finalKeys[i] = samplekeys[i * 2];             }             return (K[]) finalKeys;         }          @Override         @SuppressWarnings("unchecked")         public Collection<V>[] getSampleValues() {             // Calling getMap() instead of makeObject() would make more sense, but due to concurrency             // issues, this may lead to intermittent issues. See COLLECTIONS-661. A better solution             // would be to re-design the tests, or add a boolean method to the parent.             final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;             final V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();             final Collection<V>[] colArr = new Collection[3];             for (int i = 0; i < 3; i++) {                 final Collection<V> coll = Arrays.asList(sampleValues[i*2], sampleValues[i*2 + 1]);                 colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;             }             return colArr;         }          @Override         @SuppressWarnings("unchecked")         public Collection<V>[] getNewSampleValues() {             // See comment in getSampleValues() to understand why we are calling makeObject() and not             // getMap(). See COLLECTIONS-661 for more.             final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;             final Object[] sampleValues = { "ein", "ek", "zwei", "duey", "drei", "teen" };             final Collection<V>[] colArr = new Collection[3];             for (int i = 0; i < 3; i++) {                 final Collection<V> coll = Arrays.asList((V) sampleValues[i * 2], (V) sampleValues[i * 2 + 1]);                 colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;             }             return colArr;         }          @Override         public boolean isAllowNullKey() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isPutAddSupported() {             return false;         }          @Override         public boolean isPutChangeSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean areEqualElementsDistinguishable() {             // work-around for a problem with the EntrySet: the entries contain             // the wrapped collection, which will be automatically cleared             // when the associated key is removed from the map as the collection             // is not cached atm.             return true;         }          @Override         public boolean isTestSerialization() {             return false;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.Collection;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Tests for TransformedMultiValuedMap  *  * @since 4.1  */ public class TransformedMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public TransformedMultiValuedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedMultiValuedMapTest.class);     }      // -----------------------------------------------------------------------     @Override     public MultiValuedMap<K, V> makeObject() {         return TransformedMultiValuedMap.transformingMap(new ArrayListValuedHashMap<K, V>(),                 TransformerUtils.<K>nopTransformer(), TransformerUtils.<V>nopTransformer());     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testKeyTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          final MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(                 new ArrayListValuedHashMap<K, V>(),                 (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,                 null);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsKey(els[i]));             assertEquals(true, map.containsValue(els[i]));             assertEquals(true, map.get((K) Integer.valueOf((String) els[i])).contains(els[i]));         }          final Collection<V> coll = map.remove(els[0]);         assertNotNull(coll);         assertEquals(0, coll.size());         assertEquals(true, map.remove(Integer.valueOf((String) els[0])).contains(els[0]));     }      @SuppressWarnings("unchecked")     public void testValueTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          final MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(                 new ArrayListValuedHashMap<K, V>(), null,                 (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsValue(els[i]));             assertEquals(true, map.containsKey(els[i]));             assertEquals(true, map.get((K) els[i]).contains(Integer.valueOf((String) els[i])));         }         assertEquals(true, map.remove(els[0]).contains(Integer.valueOf((String) els[0])));     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testFactory_Decorate() {         final MultiValuedMap<K, V> base = new ArrayListValuedHashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final MultiValuedMap<K, V> trans = TransformedMultiValuedMap                 .transformingMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(true, trans.get((K) "A").contains("1"));         assertEquals(true, trans.get((K) "B").contains("2"));         assertEquals(true, trans.get((K) "C").contains("3"));         trans.put((K) "D", (V) "4");         assertEquals(true, trans.get((K) "D").contains(Integer.valueOf(4)));     }      @SuppressWarnings("unchecked")     public void testFactory_decorateTransform() {         final MultiValuedMap<K, V> base = new ArrayListValuedHashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final MultiValuedMap<K, V> trans = TransformedMultiValuedMap                 .transformedMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(true, trans.get((K) "A").contains(Integer.valueOf(1)));         assertEquals(true, trans.get((K) "B").contains(Integer.valueOf(2)));         assertEquals(true, trans.get((K) "C").contains(Integer.valueOf(3)));         trans.put((K) "D", (V) "4");         assertEquals(true, trans.get((K) "D").contains(Integer.valueOf(4)));          final MultiValuedMap<K, V> baseMap = new ArrayListValuedHashMap<>();         final MultiValuedMap<K, V> transMap = TransformedMultiValuedMap                 .transformedMap(                         baseMap,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, transMap.size());         transMap.put((K) "D", (V) "4");         assertEquals(1, transMap.size());         assertEquals(true, transMap.get((K) "D").contains(Integer.valueOf(4)));     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/TransformedMultiValuedMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/TransformedMultiValuedMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.Set; import java.util.Map; import java.util.Map.Entry; import java.util.HashMap; import java.util.Arrays; import java.util.Collection; import java.util.Iterator;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.Unmodifiable;  /**  * Tests for UnmodifiableMultiValuedMap  *  * @since 4.1  */ public class UnmodifiableMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public UnmodifiableMultiValuedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableMultiValuedMapTest.class);     }      /**      * Assert the given map contains all added values after it was initialized      * with makeFullMap(). See COLLECTIONS-769.      * @param map the MultiValuedMap<K, V> to check      */     private void assertMapContainsAllValues(final MultiValuedMap<K, V> map) {         assertEquals("[uno, un]", map.get((K) "one").toString());         assertEquals("[dos, deux]", map.get((K) "two").toString());         assertEquals("[tres, trois]", map.get((K) "three").toString());     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public MultiValuedMap<K, V> makeObject() {         return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(                 new ArrayListValuedHashMap<K, V>());     }      @Override     protected MultiValuedMap<K, V> makeFullMap() {         final MultiValuedMap<K, V> map = new ArrayListValuedHashMap<>();         addSampleMappings(map);         return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);     }      // -----------------------------------------------------------------------     public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final MultiValuedMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(map));     }      public void testDecoratorFactoryNullMap() {         try {             UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(null);             fail("map must not be null");         } catch (final NullPointerException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testAddException() {         final MultiValuedMap<K, V> map = makeObject();         try {             map.put((K) "one", (V) "uno");             fail();         } catch (final UnsupportedOperationException e) {         }     }      public void testRemoveException() {         final MultiValuedMap<K, V> map = makeFullMap();         try {             map.remove("one");             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support remove() method             // UnmodifiableMultiValuedMap does not support change         }         this.assertMapContainsAllValues(map);     }      public void testRemoveMappingException() {         final MultiValuedMap<K, V> map = makeFullMap();         try {             map.removeMapping("one", "uno");             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support removeMapping() method             // UnmodifiableMultiValuedMap does not support change         }         this.assertMapContainsAllValues(map);     }      public void testClearException() {         final MultiValuedMap<K, V> map = makeFullMap();         try {             map.clear();             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support clear() method             // UnmodifiableMultiValuedMap does not support change         }         this.assertMapContainsAllValues(map);     }      public void testPutAllException() {         final MultiValuedMap<K, V> map = makeObject();         final MultiValuedMap<K, V> original = new ArrayListValuedHashMap<>();         final Map<K, V> originalMap = new HashMap<>();         final Collection<V> coll = (Collection<V>) Arrays.asList("X", "Y", "Z");         original.put((K) "key", (V) "object1");         original.put((K) "key", (V) "object2");         originalMap.put((K) "keyX", (V) "object1");         originalMap.put((K) "keyY", (V) "object2");          try {             map.putAll(original);             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support putAll() method             // UnmodifiableMultiValuedMap does not support change         }         assertEquals("{}", map.toString());          try {             map.putAll(originalMap);             fail();         } catch (final UnsupportedOperationException e) {             // expected         }         assertEquals("{}", map.toString());          try {             map.putAll((K) "A", coll);             fail();         } catch (final UnsupportedOperationException e) {             // expected         }         assertEquals("{}", map.toString());     }      @SuppressWarnings("unchecked")     public void testUnmodifiableEntries() {         resetFull();         final Collection<Entry<K, V>> entries = getMap().entries();         try {             entries.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<Entry<K, V>> it = entries.iterator();         final Entry<K, V> entry = it.next();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }          try {             entry.setValue((V) "three");             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableMapIterator() {         resetFull();         final MapIterator<K, V> mapIt = getMap().mapIterator();         try {             mapIt.remove();             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapIt.setValue((V) "three");             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableKeySet() {         resetFull();         final Set<K> keySet = getMap().keySet();         try {             keySet.add((K) "four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keySet.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keySet.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<K> it = keySet.iterator();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableValues() {         resetFull();         final Collection<V> values = getMap().values();         try {             values.add((V) "four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             values.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             values.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<V> it = values.iterator();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableAsMap() {         resetFull();         final Map<K, Collection<V>> mapCol = getMap().asMap();         try {             mapCol.put((K) "four", (Collection<V>) Arrays.asList("four"));             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapCol.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapCol.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapCol.clear();             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableKeys() {         resetFull();         final MultiSet<K> keys = getMap().keys();         try {             keys.add((K) "four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keys.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keys.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<K> it = keys.iterator();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/UnmodifiableMultiValuedMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/UnmodifiableMultiValuedMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.SetValuedMap;  /**  * Test HashSetValuedHashMap  *  * @since 4.1  */ public class HashSetValuedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public HashSetValuedHashMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashSetValuedHashMapTest.class);     }      // -----------------------------------------------------------------------     @Override     public SetValuedMap<K, V> makeObject() {         return new HashSetValuedHashMap<>();     }      @Override     public MultiValuedMap<K, V> makeConfirmedMap() {         return new HashSetValuedHashMap<>();     }      @Override     public boolean isHashSetValue() {         return true;     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testSetValuedMapAdd() {         final SetValuedMap<K, V> setMap = makeObject();         assertTrue(setMap.get((K) "whatever") instanceof Set);          final Set<V> set = setMap.get((K) "A");         assertTrue(set.add((V) "a1"));         assertTrue(set.add((V) "a2"));         assertFalse(set.add((V) "a1"));         assertEquals(2, setMap.size());         assertTrue(setMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testSetValuedMapRemove() {         final SetValuedMap<K, V> setMap = makeObject();         assertTrue(setMap.get((K) "whatever") instanceof Set);          final Set<V> set = setMap.get((K) "A");         assertTrue(set.add((V) "a1"));         assertTrue(set.add((V) "a2"));         assertFalse(set.add((V) "a1"));         assertEquals(2, setMap.size());         assertTrue(setMap.containsKey("A"));          assertTrue(set.remove("a1"));         assertTrue(set.remove("a2"));         assertFalse(set.remove("a1"));          assertEquals(0, setMap.size());         assertFalse(setMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testSetValuedMapRemoveViaIterator() {         final SetValuedMap<K, V> setMap = makeObject();         assertTrue(setMap.get((K) "whatever") instanceof Set);          final Set<V> set = setMap.get((K) "A");         set.add((V) "a1");         set.add((V) "a2");         set.add((V) "a1");          final Iterator<V> it = set.iterator();         while (it.hasNext()) {             it.next();             it.remove();         }         assertEquals(0, setMap.size());         assertFalse(setMap.containsKey("A"));     }      @SuppressWarnings({ "unchecked", "rawtypes" })     public void testSetValuedMapEqualsHashCodeContract() {         final SetValuedMap map1 = makeObject();         final SetValuedMap map2 = makeObject();          map1.put("a", "a1");         map1.put("a", "a2");         map2.put("a", "a2");         map2.put("a", "a1");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map2.put("a", "a2");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map2.put("a", "a3");         assertNotSame(map1, map2);         assertNotSame(map1.hashCode(), map2.hashCode());     }      public void testHashSetValueHashMap() {         final SetValuedMap<K, V> setMap = new HashSetValuedHashMap<>(4);         assertEquals(0, setMap.get((K) "whatever").size());          final Set<V> set = setMap.get((K) "A");         set.add((V) "W");         set.add((V) "X");         set.add((V) "F");         assertEquals(3, setMap.get((K) "A").size());     }      public void testHashSetValueHashMap_1() {         final MultiValuedMap<K, V> map = new ArrayListValuedHashMap<>();         SetValuedMap<K, V> map1;         final SetValuedMap<K, V> map2 = makeObject();         SetValuedMap<K, V> map3;          map.put((K) "A", (V) "W");         map.put((K) "A", (V) "X");         map.put((K) "A", (V) "F");         map1 = new HashSetValuedHashMap<>(map);         assertEquals(3, map1.get((K) "A").size());         map2.put((K) "A", (V) "X");         map2.put((K) "A", (V) "F");         map2.put((K) "A", (V) "W");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map.remove("A");         map3 = new HashSetValuedHashMap<>(map);         assertEquals("{}", map3.toString());     }      public void testHashSetValuedHashMap_2(){         final Map<K, V> map = new HashMap<>();         SetValuedMap<K, V> map1;         SetValuedMap<K, V> map2;          map.put((K) "A", (V) "W");         map.put((K) "B", (V) "X");         map.put((K) "C", (V) "F");         map1 = new HashSetValuedHashMap<>(map);         assertEquals(1, map1.get((K) "A").size());          map.remove("A");         map.remove("B");         map.remove("C");         map2 = new HashSetValuedHashMap<>(map);         assertEquals("{}", map2.toString());     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/HashSetValuedHashMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/HashSetValuedHashMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.functors.ExceptionClosure; import org.apache.commons.collections4.functors.FalsePredicate; import org.apache.commons.collections4.functors.NOPClosure; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests the ClosureUtils class.  *  * @since 3.0  */ public class ClosureUtilsTest {      private static final Object cString = "Hello";      static class MockClosure<T> implements Closure<T> {         int count = 0;          @Override         public void execute(final T object) {             count++;         }          public void reset() {             count = 0;         }     }      static class MockTransformer<T> implements Transformer<T, T> {         int count = 0;          @Override         public T transform(final T object) {             count++;             return object;         }     }      // exceptionClosure     //------------------------------------------------------------------      @Test     public void testExceptionClosure() {         assertNotNull(ClosureUtils.exceptionClosure());         assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());         try {             ClosureUtils.exceptionClosure().execute(null);         } catch (final FunctorException ex) {             try {                 ClosureUtils.exceptionClosure().execute(cString);             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // nopClosure     //------------------------------------------------------------------      @Test     public void testNopClosure() {         final StringBuilder buf = new StringBuilder("Hello");         ClosureUtils.nopClosure().execute(null);         assertEquals("Hello", buf.toString());         ClosureUtils.nopClosure().execute("Hello");         assertEquals("Hello", buf.toString());     }      // invokeClosure     //------------------------------------------------------------------      @Test     public void testInvokeClosure() {         StringBuffer buf = new StringBuffer("Hello"); // Only StringBuffer has setLength() method         ClosureUtils.invokerClosure("reverse").execute(buf);         assertEquals("olleH", buf.toString());         buf = new StringBuffer("Hello");         ClosureUtils.invokerClosure("setLength", new Class[] {Integer.TYPE}, new Object[] {Integer.valueOf(2)}).execute(buf);         assertEquals("He", buf.toString());     }      // forClosure     //------------------------------------------------------------------      @Test     public void testForClosure() {         final MockClosure<Object> cmd = new MockClosure<>();         ClosureUtils.forClosure(5, cmd).execute(null);         assertEquals(5, cmd.count);         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure<>()));         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(-1, new MockClosure<>()));         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(1, null));         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(3, null));         assertSame(cmd, ClosureUtils.forClosure(1, cmd));     }      // whileClosure     //------------------------------------------------------------------      @Test     public void testWhileClosure() {         MockClosure<Object> cmd = new MockClosure<>();         ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), cmd).execute(null);         assertEquals(0, cmd.count);          cmd = new MockClosure<>();         ClosureUtils.whileClosure(PredicateUtils.uniquePredicate(), cmd).execute(null);         assertEquals(1, cmd.count);          try {             ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.whileClosure(null, null);             fail();         } catch (final NullPointerException ex) {}     }      // doWhileClosure     //------------------------------------------------------------------      @Test     public void testDoWhileClosure() {         MockClosure<Object> cmd = new MockClosure<>();         ClosureUtils.doWhileClosure(cmd, FalsePredicate.falsePredicate()).execute(null);         assertEquals(1, cmd.count);          cmd = new MockClosure<>();         ClosureUtils.doWhileClosure(cmd, PredicateUtils.uniquePredicate()).execute(null);         assertEquals(2, cmd.count);          try {             ClosureUtils.doWhileClosure(null, null);             fail();         } catch (final NullPointerException ex) {}     }      // chainedClosure     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testChainedClosure() {         MockClosure<Object> a = new MockClosure<>();         MockClosure<Object> b = new MockClosure<>();         ClosureUtils.chainedClosure(a, b).execute(null);         assertEquals(1, a.count);         assertEquals(1, b.count);          a = new MockClosure<>();         b = new MockClosure<>();         ClosureUtils.<Object>chainedClosure(a, b, a).execute(null);         assertEquals(2, a.count);         assertEquals(1, b.count);          a = new MockClosure<>();         b = new MockClosure<>();         Collection<Closure<Object>> coll = new ArrayList<>();         coll.add(b);         coll.add(a);         coll.add(b);         ClosureUtils.<Object>chainedClosure(coll).execute(null);         assertEquals(1, a.count);         assertEquals(2, b.count);          assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure());         assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(Collections.<Closure<Object>>emptyList()));          try {             ClosureUtils.chainedClosure(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<Object>chainedClosure((Closure[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<Object>chainedClosure(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             coll = new ArrayList<>();             coll.add(null);             coll.add(null);             ClosureUtils.chainedClosure(coll);             fail();         } catch (final NullPointerException ex) {}     }      // ifClosure     //------------------------------------------------------------------      @Test     public void testIfClosure() {         MockClosure<Object> a = new MockClosure<>();         MockClosure<Object> b;         ClosureUtils.ifClosure(TruePredicate.truePredicate(), a).execute(null);         assertEquals(1, a.count);          a = new MockClosure<>();         ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a).execute(null);         assertEquals(0, a.count);          a = new MockClosure<>();         b = new MockClosure<>();         ClosureUtils.ifClosure(TruePredicate.<Object>truePredicate(), a, b).execute(null);         assertEquals(1, a.count);         assertEquals(0, b.count);          a = new MockClosure<>();         b = new MockClosure<>();         ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a, b).execute(null);         assertEquals(0, a.count);         assertEquals(1, b.count);     }      // switchClosure     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testSwitchClosure() {         final MockClosure<String> a = new MockClosure<>();         final MockClosure<String> b = new MockClosure<>();         ClosureUtils.<String>switchClosure(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Closure[] { a, b }).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         ClosureUtils.<String>switchClosure(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Closure[] { a, b }).execute("HELLO");         assertEquals(1, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         final MockClosure<String> c = new MockClosure<>();         ClosureUtils.<String>switchClosure(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Closure[] { a, b }, c).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);         assertEquals(1, c.count);          a.reset();         b.reset();         final Map<Predicate<String>, Closure<String>> map = new HashMap<>();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         ClosureUtils.<String>switchClosure(map).execute(null);         assertEquals(0, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         map.clear();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         ClosureUtils.switchClosure(map).execute("THERE");         assertEquals(0, a.count);         assertEquals(1, b.count);          a.reset();         b.reset();         c.reset();         map.clear();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         map.put(null, c);         ClosureUtils.switchClosure(map).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);         assertEquals(1, c.count);          assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new Predicate[0], new Closure[0]));         assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new HashMap<Predicate<String>, Closure<String>>()));         map.clear();         map.put(null, null);         assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchClosure(map));          try {             ClosureUtils.switchClosure(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2]);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure(                     new Predicate[] { TruePredicate.<String>truePredicate() },                     new Closure[] { a, b });             fail();         } catch (final IllegalArgumentException ex) {}     }      // switchMapClosure     //------------------------------------------------------------------      @Test     public void testSwitchMapClosure() {         final MockClosure<String> a = new MockClosure<>();         final MockClosure<String> b = new MockClosure<>();         final Map<String, Closure<String>> map = new HashMap<>();         map.put("HELLO", a);         map.put("THERE", b);         ClosureUtils.switchMapClosure(map).execute(null);         assertEquals(0, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         map.clear();         map.put("HELLO", a);         map.put("THERE", b);         ClosureUtils.switchMapClosure(map).execute("THERE");         assertEquals(0, a.count);         assertEquals(1, b.count);          a.reset();         b.reset();         map.clear();         final MockClosure<String> c = new MockClosure<>();         map.put("HELLO", a);         map.put("THERE", b);         map.put(null, c);         ClosureUtils.switchMapClosure(map).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);         assertEquals(1, c.count);          assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchMapClosure(new HashMap<String, Closure<String>>()));          try {             ClosureUtils.switchMapClosure(null);             fail();         } catch (final NullPointerException ex) {}     }      // asClosure     //------------------------------------------------------------------      @Test     public void testTransformerClosure() {         final MockTransformer<Object> mock = new MockTransformer<>();         final Closure<Object> closure = ClosureUtils.asClosure(mock);         closure.execute(null);         assertEquals(1, mock.count);         closure.execute(null);         assertEquals(2, mock.count);          assertEquals(ClosureUtils.nopClosure(), ClosureUtils.asClosure(null));     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Closure singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionClosure.INSTANCE,             NOPClosure.INSTANCE,         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization(                     "Singleton pattern broken for " + original.getClass(),                     original             );         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class DualTreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualTreeBidiMapTest.class);     }      public DualTreeBidiMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public DualTreeBidiMap<K, V> makeObject() {         return new DualTreeBidiMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         final String recursiveTest = "DualTreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap";         return new String[] { recursiveTest };     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.Map; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.OrderedBidiMap; import org.apache.commons.collections4.Unmodifiable;  /**  * JUnit tests.  *  */ public class UnmodifiableOrderedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableOrderedBidiMapTest.class);     }      public UnmodifiableOrderedBidiMapTest(final String testName) {         super(testName);     }      @Override     public OrderedBidiMap<K, V> makeObject() {         return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(new TreeBidiMap<K, V>());     }      @Override     public OrderedBidiMap<K, V> makeFullMap() {         final OrderedBidiMap<K, V> bidi = new TreeBidiMap<>();         addSampleMappings(bidi);         return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);     }      @Override     public Map<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] {"UnmodifiableOrderedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final OrderedBidiMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(map));          try {             UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(null);             fail();         } catch (final NullPointerException ex) {}     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.SortedMap; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBidiMap; import org.apache.commons.collections4.Unmodifiable;  /**  * JUnit tests.  *  */ public class UnmodifiableSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSortedBidiMapTest.class);     }      public UnmodifiableSortedBidiMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public SortedBidiMap<K, V> makeObject() {         return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(new DualTreeBidiMap<K, V>());     }      @Override     public SortedBidiMap<K, V> makeFullMap() {         final SortedBidiMap<K, V> bidi = new DualTreeBidiMap<>();         addSampleMappings(bidi);         return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);     }      @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      @Override     public String[] ignoredTests() {         // Override to prevent infinite recursion of tests.         return new String[] {"UnmodifiableSortedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      //-----------------------------------------------------------------------     @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final SortedBidiMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(map));          try {             UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class DualLinkedHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualLinkedHashBidiMapTest.class);     }      public DualLinkedHashBidiMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public DualLinkedHashBidiMap<K, V> makeObject() {         return new DualLinkedHashBidiMap<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] { "DualLinkedHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap" };     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualLinkedHashBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualLinkedHashBidiMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.SortedMap; import java.util.TreeMap;  import org.apache.commons.collections4.OrderedBidiMap;  /**  * Test class for AbstractOrderedBidiMapDecorator.  *  * @param <K> the type of the keys in this map  * @param <V> the type of the values in this map  */ public class AbstractOrderedBidiMapDecoratorTest<K, V>         extends AbstractOrderedBidiMapTest<K, V> {      public AbstractOrderedBidiMapDecoratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public OrderedBidiMap<K, V> makeObject() {         return new TestOrderedBidiMap<>();     }      @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isSetValueSupported() {         return true;     }      /**      * Simple class to actually test.      */     private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {          private TestOrderedBidiMap<V, K> inverse = null;          TestOrderedBidiMap() {             super(new DualTreeBidiMap<K, V>());         }          TestOrderedBidiMap(final OrderedBidiMap<K, V> map) {             super(map);         }          @Override         public OrderedBidiMap<V, K> inverseBidiMap() {             if (inverse == null) {                 inverse = new TestOrderedBidiMap<>(decorated().inverseBidiMap());                 inverse.inverse = this;             }             return inverse;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.OrderedBidiMap; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;  /**  * Abstract test class for {@link OrderedBidiMap} methods and contracts.  *  */ public abstract class AbstractOrderedBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public AbstractOrderedBidiMapTest(final String testName) {         super(testName);     }      public AbstractOrderedBidiMapTest() {     }      //-----------------------------------------------------------------------     public void testFirstKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = getMap();         try {             bidi.firstKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         bidi = getMap();         final K confirmedFirst = confirmed.keySet().iterator().next();         assertEquals(confirmedFirst, bidi.firstKey());     }      public void testLastKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = getMap();         try {             bidi.lastKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         bidi = getMap();         K confirmedLast = null;         for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {             confirmedLast = it.next();         }         assertEquals(confirmedLast, bidi.lastKey());     }      //-----------------------------------------------------------------------     public void testNextKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = (OrderedBidiMap<K, V>) map;         assertEquals(null, bidi.nextKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, bidi.nextKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.nextKey(null));         }          resetFull();         bidi = (OrderedBidiMap<K, V>) map;         final Iterator<K> it = confirmed.keySet().iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, bidi.nextKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, bidi.nextKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 bidi.nextKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.nextKey(null));         }     }      public void testPreviousKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = getMap();         assertEquals(null, bidi.previousKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, bidi.previousKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.previousKey(null));         }          resetFull();         bidi = getMap();         final List<K> list = new ArrayList<>(confirmed.keySet());         Collections.reverse(list);         final Iterator<K> it = list.iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, bidi.previousKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, bidi.previousKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 bidi.previousKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.previousKey(null));         }     }      //-----------------------------------------------------------------------     public BulkTest bulkTestOrderedMapIterator() {         return new TestBidiOrderedMapIterator();     }      /**      * {@inheritDoc}      */     @Override     public OrderedBidiMap<K, V> getMap() {         return (OrderedBidiMap<K, V>) super.getMap();     }      public class TestBidiOrderedMapIterator extends AbstractMapIteratorTest<K, V> {         public TestBidiOrderedMapIterator() {             super("TestBidiOrderedMapIterator");         }          @Override         public V[] addSetValues() {             return AbstractOrderedBidiMapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return AbstractOrderedBidiMapTest.this.isRemoveSupported();         }          @Override         public boolean supportsSetValue() {             return AbstractOrderedBidiMapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractOrderedBidiMapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return AbstractOrderedBidiMapTest.this.getMap().mapIterator();         }          @Override         public Map<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedBidiMapTest.this.map;         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedBidiMapTest.this.confirmed;         }          @Override         public void verify() {             super.verify();             AbstractOrderedBidiMapTest.this.verify();         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Collections; import java.util.Comparator; import java.util.Iterator; import java.util.List; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBidiMap; import org.apache.commons.collections4.comparators.ComparableComparator; import org.apache.commons.collections4.comparators.ReverseComparator;  /**  * JUnit tests.  *  */ @SuppressWarnings("boxing") public class DualTreeBidiMap2Test<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualTreeBidiMap2Test.class);     }      public DualTreeBidiMap2Test(final String testName) {         super(testName);     }      @Override     public DualTreeBidiMap<K, V> makeObject() {         return new DualTreeBidiMap<>(                 new ReverseComparator<>(ComparableComparator.<K>comparableComparator()),                 new ReverseComparator<>(ComparableComparator.<V>comparableComparator()));     }      @Override     public TreeMap<K, V> makeConfirmedMap() {         return new TreeMap<>(new ReverseComparator<>(ComparableComparator.<K>comparableComparator()));     }      public void testComparator() {         resetEmpty();         final SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;         assertNotNull(bidi.comparator());         assertTrue(bidi.comparator() instanceof ReverseComparator);     }      public void testComparator2() {         final DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<>(                 String.CASE_INSENSITIVE_ORDER, null);         dtbm.put("two", 0);         dtbm.put("one", 1);         assertEquals("one", dtbm.firstKey());         assertEquals("two", dtbm.lastKey());      }      public void testSerializeDeserializeCheckComparator() throws Exception {         final SortedBidiMap<?, ?> obj = makeObject();         if (obj instanceof Serializable && isTestSerialization()) {             final ByteArrayOutputStream buffer = new ByteArrayOutputStream();             final ObjectOutputStream out = new ObjectOutputStream(buffer);             out.writeObject(obj);             out.close();              final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));             final Object dest = in.readObject();             in.close();              final SortedBidiMap<?, ?> bidi = (SortedBidiMap<?, ?>) dest;             assertNotNull(obj.comparator());             assertNotNull(bidi.comparator());             assertTrue(bidi.comparator() instanceof ReverseComparator);         }     }      private static class IntegerComparator implements Comparator<Integer>, Serializable{         private static final long serialVersionUID = 1L;         @Override         public int compare(final Integer o1, final Integer o2) {             return o1.compareTo(o2);         }     }      public void testCollections364() throws Exception {         final DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<>(                 String.CASE_INSENSITIVE_ORDER, new IntegerComparator());         final ByteArrayOutputStream buffer = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(buffer);         out.writeObject(original);         out.close();          final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));         @SuppressWarnings("unchecked")         final DualTreeBidiMap<String, Integer> deserialized = (DualTreeBidiMap<String, Integer>) in.readObject();         in.close();          assertNotNull(original.comparator());         assertNotNull(deserialized.comparator());         assertEquals(original.comparator().getClass(), deserialized.comparator().getClass());         assertEquals(original.valueComparator().getClass(), deserialized.valueComparator().getClass());     }      public void testSortOrder() throws Exception {         final SortedBidiMap<K, V> sm = makeFullMap();          // Sort by the comparator used in the makeEmptyBidiMap() method         List<K> newSortedKeys = getAsList(getSampleKeys());         Collections.sort(newSortedKeys, new ReverseComparator<>(ComparableComparator.<K>comparableComparator()));         newSortedKeys = Collections.unmodifiableList(newSortedKeys);          final Iterator<K> mapIter = sm.keySet().iterator();         final Iterator<K> expectedIter = newSortedKeys.iterator();         while (expectedIter.hasNext()) {             final K expectedKey = expectedIter.next();             final K mapKey = mapIter.next();             assertNotNull("key in sorted list may not be null", expectedKey);             assertNotNull("key in map may not be null", mapKey);             assertEquals("key from sorted list and map must be equal", expectedKey, mapKey);         }     }      @Override     public String getCompatibilityVersion() {         return "4.Test2";     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         final String recursiveTest = "DualTreeBidiMap2Test.bulkTestInverseMap.bulkTestInverseMap";         return new String[] { recursiveTest };     }   //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.Test2.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.Test2.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class DualHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualHashBidiMapTest.class);     }      public DualHashBidiMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public DualHashBidiMap<K, V> makeObject() {         return new DualHashBidiMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] { "DualHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap" };     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualHashBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualHashBidiMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.HashMap; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BidiMap; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Unmodifiable;  /**  * JUnit tests.  *  */ public class UnmodifiableBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableBidiMapTest.class);     }      public UnmodifiableBidiMapTest(final String testName) {         super(testName);     }      @Override     public BidiMap<K, V> makeObject() {         return UnmodifiableBidiMap.unmodifiableBidiMap(new DualHashBidiMap<K, V>());     }      @Override     public BidiMap<K, V> makeFullMap() {         final BidiMap<K, V> bidi = new DualHashBidiMap<>();         addSampleMappings(bidi);         return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);     }      @Override     public Map<K, V> makeConfirmedMap() {         return new HashMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] {"UnmodifiableBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final BidiMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableBidiMap.unmodifiableBidiMap(map));          try {             UnmodifiableBidiMap.unmodifiableBidiMap(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import java.util.SortedMap; import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBidiMap; import org.apache.commons.collections4.map.AbstractSortedMapTest;  /**  * Abstract test class for {@link SortedBidiMap} methods and contracts.  *  */ public abstract class AbstractSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {      protected List<K> sortedKeys;     protected List<V> sortedValues = new ArrayList<>();     protected SortedSet<V> sortedNewValues = new TreeSet<>();      public AbstractSortedBidiMapTest(final String testName) {         super(testName);         sortedKeys = getAsList(getSampleKeys());         Collections.sort(sortedKeys);         sortedKeys = Collections.unmodifiableList(sortedKeys);          final Map<K, V> map = new TreeMap<>();         addSampleMappings(map);          sortedValues.addAll(map.values());         sortedValues = Collections.unmodifiableList(sortedValues);          sortedNewValues.addAll(getAsList(getNewSampleValues()));     }  //    public AbstractTestSortedBidiMap() { //        super(); //        sortedKeys.addAll(Arrays.asList(getSampleValues())); //        Collections.sort(sortedKeys); //        sortedKeys = Collections.unmodifiableList(sortedKeys); // //        Map map = new TreeMap(); //        for (int i = 0; i < getSampleKeys().length; i++) { //            map.put(getSampleValues()[i], getSampleKeys()[i]); //        } //        sortedValues.addAll(map.values()); //        sortedValues = Collections.unmodifiableList(sortedValues); // //        sortedNewValues.addAll(Arrays.asList(getNewSampleValues())); //    }      //-----------------------------------------------------------------------     @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedBidiMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedBidiMap<K, V> makeFullMap() {         return (SortedBidiMap<K, V>) super.makeFullMap();     }      @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      //-----------------------------------------------------------------------     //-----------------------------------------------------------------------     public void testBidiHeadMapContains() {         // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K toKey = it.next();         final K second = it.next();         final V firstValue = sm.get(first);         final V secondValue = sm.get(second);          final SortedMap<K, V> head = sm.headMap(toKey);         assertEquals(1, head.size());         assertTrue(sm.containsKey(first));         assertTrue(head.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertTrue(head.containsValue(firstValue));         assertTrue(sm.containsKey(second));         assertFalse(head.containsKey(second));         assertTrue(sm.containsValue(secondValue));         assertFalse(head.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiClearByHeadMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final V firstValue = sm.get(first);         final V secondValue = sm.get(second);         final V toKeyValue = sm.get(toKey);          final SortedMap<K, V> sub = sm.headMap(toKey);         final int size = sm.size();         assertEquals(2, sub.size());         sub.clear();         assertEquals(0, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());          assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));          assertTrue(sm.containsKey(toKey));         assertTrue(sm.containsValue(toKeyValue));         assertTrue(sm.inverseBidiMap().containsKey(toKeyValue));         assertTrue(sm.inverseBidiMap().containsValue(toKey));         assertFalse(sub.containsKey(toKey));         assertFalse(sub.containsValue(toKeyValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByHeadMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.headMap(toKey);         assertEquals(2, sub.size());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));          final V firstValue = sub.remove(first);         assertEquals(1, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          final V secondValue = sub.remove(second);         assertEquals(0, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByHeadMapEntrySet() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.headMap(toKey);         final Set<Map.Entry<K, V>> set = sub.entrySet();         assertEquals(2, sub.size());         assertEquals(2, set.size());          final Iterator<Map.Entry<K, V>> it2 = set.iterator();         final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());         final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(set.contains(firstEntry));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(set.contains(secondEntry));          set.remove(firstEntry);         assertEquals(1, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(firstEntry.getKey()));         assertFalse(sm.containsValue(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));         assertFalse(sub.containsKey(firstEntry.getKey()));         assertFalse(sub.containsValue(firstEntry.getValue()));         assertFalse(set.contains(firstEntry));          set.remove(secondEntry);         assertEquals(0, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(secondEntry.getKey()));         assertFalse(sm.containsValue(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));         assertFalse(sub.containsKey(secondEntry.getKey()));         assertFalse(sub.containsValue(secondEntry.getValue()));         assertFalse(set.contains(secondEntry));     }      //-----------------------------------------------------------------------     //-----------------------------------------------------------------------     public void testBidiTailMapContains() {         // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K fromKey = it.next();         final K second = it.next();         final V firstValue = sm.get(first);         final V fromKeyValue = sm.get(fromKey);         final V secondValue = sm.get(second);          final SortedMap<K, V> sub = sm.tailMap(fromKey);         assertEquals(sm.size() - 1, sub.size());         assertTrue(sm.containsKey(first));         assertFalse(sub.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertFalse(sub.containsValue(firstValue));         assertTrue(sm.containsKey(fromKey));         assertTrue(sub.containsKey(fromKey));         assertTrue(sm.containsValue(fromKeyValue));         assertTrue(sub.containsValue(fromKeyValue));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(sm.containsValue(secondValue));         assertTrue(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiClearByTailMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K first = it.next();         final K fromKey = it.next();         final K second = it.next();          final V firstValue = sm.get(first);         final V fromKeyValue = sm.get(fromKey);         final V secondValue = sm.get(second);          final SortedMap<K, V> sub = sm.tailMap(fromKey);         final int size = sm.size();         assertEquals(size - 3, sub.size());         sub.clear();         assertEquals(0, sub.size());         assertEquals(3, sm.size());         assertEquals(3, sm.inverseBidiMap().size());          assertTrue(sm.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertTrue(sm.inverseBidiMap().containsKey(firstValue));         assertTrue(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          assertFalse(sm.containsKey(fromKey));         assertFalse(sm.containsValue(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsKey(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsValue(fromKey));         assertFalse(sub.containsKey(fromKey));         assertFalse(sub.containsValue(fromKeyValue));          assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByTailMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.tailMap(fromKey);         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));          final Object firstValue = sub.remove(first);         assertEquals(size - 3, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          final Object secondValue = sub.remove(second);         assertEquals(size - 4, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByTailMapEntrySet() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.tailMap(fromKey);         final Set<Map.Entry<K, V>> set = sub.entrySet();         final Iterator<Map.Entry<K, V>> it2 = set.iterator();         it2.next();         final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());         final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(set.contains(firstEntry));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(set.contains(secondEntry));          set.remove(firstEntry);         assertEquals(size - 3, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(firstEntry.getKey()));         assertFalse(sm.containsValue(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));         assertFalse(sub.containsKey(firstEntry.getKey()));         assertFalse(sub.containsValue(firstEntry.getValue()));         assertFalse(set.contains(firstEntry));          set.remove(secondEntry);         assertEquals(size - 4, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(secondEntry.getKey()));         assertFalse(sm.containsValue(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));         assertFalse(sub.containsKey(secondEntry.getKey()));         assertFalse(sub.containsValue(secondEntry.getValue()));         assertFalse(set.contains(secondEntry));     }      //-----------------------------------------------------------------------     //-----------------------------------------------------------------------     public void testBidiSubMapContains() {         // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K fromKey = it.next();         final K second = it.next();         final K toKey = it.next();         final K third = it.next();         final V firstValue = sm.get(first);         final V fromKeyValue = sm.get(fromKey);         final V secondValue = sm.get(second);         final V thirdValue = sm.get(third);          final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         assertEquals(2, sub.size());         assertTrue(sm.containsKey(first));         assertFalse(sub.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertFalse(sub.containsValue(firstValue));         assertTrue(sm.containsKey(fromKey));         assertTrue(sub.containsKey(fromKey));         assertTrue(sm.containsValue(fromKeyValue));         assertTrue(sub.containsValue(fromKeyValue));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(sm.containsValue(secondValue));         assertTrue(sub.containsValue(secondValue));         assertTrue(sm.containsKey(third));         assertFalse(sub.containsKey(third));         assertTrue(sm.containsValue(thirdValue));         assertFalse(sub.containsValue(thirdValue));     }      //-----------------------------------------------------------------------     public void testBidiClearBySubMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final V fromKeyValue = sm.get(fromKey);         final V firstValue = sm.get(first);         final V secondValue = sm.get(second);         final V toKeyValue = sm.get(toKey);          final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         final int size = sm.size();         assertEquals(3, sub.size());         sub.clear();         assertEquals(0, sub.size());         assertEquals(size - 3, sm.size());         assertEquals(size - 3, sm.inverseBidiMap().size());          assertFalse(sm.containsKey(fromKey));         assertFalse(sm.containsValue(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsKey(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsValue(fromKey));         assertFalse(sub.containsKey(fromKey));         assertFalse(sub.containsValue(fromKeyValue));          assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));          assertTrue(sm.containsKey(toKey));         assertTrue(sm.containsValue(toKeyValue));         assertTrue(sm.inverseBidiMap().containsKey(toKeyValue));         assertTrue(sm.inverseBidiMap().containsValue(toKey));         assertFalse(sub.containsKey(toKey));         assertFalse(sub.containsValue(toKeyValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveBySubMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));          final V firstValue = sub.remove(first);         assertEquals(2, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          final V secondValue = sub.remove(second);         assertEquals(1, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveBySubMapEntrySet() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         final Set<Map.Entry<K, V>> set = sub.entrySet();         assertEquals(3, set.size());         final Iterator<Map.Entry<K, V>> it2 = set.iterator();         it2.next();         final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());         final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(set.contains(firstEntry));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(set.contains(secondEntry));          set.remove(firstEntry);         assertEquals(2, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(firstEntry.getKey()));         assertFalse(sm.containsValue(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));         assertFalse(sub.containsKey(firstEntry.getKey()));         assertFalse(sub.containsValue(firstEntry.getValue()));         assertFalse(set.contains(firstEntry));          set.remove(secondEntry);         assertEquals(1, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(secondEntry.getKey()));         assertFalse(sm.containsValue(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));         assertFalse(sub.containsKey(secondEntry.getKey()));         assertFalse(sub.containsValue(secondEntry.getValue()));         assertFalse(set.contains(secondEntry));     }      //-----------------------------------------------------------------------     public BulkTest bulkTestHeadMap() {         return new AbstractSortedMapTest.TestHeadMap<>(this);     }      public BulkTest bulkTestTailMap() {         return new AbstractSortedMapTest.TestTailMap<>(this);     }      public BulkTest bulkTestSubMap() {         return new AbstractSortedMapTest.TestSubMap<>(this);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.TreeMap;  import junit.framework.Test; import org.apache.commons.collections4.BidiMap; import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class TreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(TreeBidiMapTest.class);     }      public TreeBidiMapTest(final String testName) {         super(testName);     }      @Override     public BidiMap<K, V> makeObject() {         return new TreeBidiMap<>();     }      @Override     public TreeMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] {"TreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isSetValueSupported() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/TreeBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/TreeBidiMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;  import org.apache.commons.collections4.BidiMap; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest; import org.apache.commons.collections4.map.AbstractIterableMapTest;  /**  * Abstract test class for {@link BidiMap} methods and contracts.  *  */ public abstract class AbstractBidiMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public AbstractBidiMapTest(final String testName) {         super(testName);     }      public AbstractBidiMapTest() {         super("Inverse");     }      //-----------------------------------------------------------------------     /**      * Override to create a full {@code BidiMap} other than the default.      *      * @return a full {@code BidiMap} implementation.      */     @Override     public BidiMap<K, V> makeFullMap() {         return (BidiMap<K, V>) super.makeFullMap();     }      /**      * Override to return the empty BidiMap.      */     @Override     public abstract BidiMap<K, V> makeObject();      /**      * Override to indicate to AbstractTestMap this is a BidiMap.      */     @Override     public boolean isAllowDuplicateValues() {         return false;     }      /**      * Override as DualHashBidiMap didn't exist until version 3.      */     @Override     public String getCompatibilityVersion() {         return "4";     }      // BidiPut     //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testBidiPut() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }          final BidiMap<K, V> map = makeObject();         final BidiMap<V, K> inverse = map.inverseBidiMap();         assertEquals(0, map.size());         assertEquals(map.size(), inverse.size());          map.put((K) "A", (V) "B");         assertEquals(1, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("B", map.get("A"));         assertEquals("A", inverse.get("B"));          map.put((K) "A", (V) "C");         assertEquals(1, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("C", map.get("A"));         assertEquals("A", inverse.get("C"));          map.put((K) "B", (V) "C");         assertEquals(1, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("C", map.get("B"));         assertEquals("B", inverse.get("C"));          map.put((K) "E", (V) "F");         assertEquals(2, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("F", map.get("E"));         assertEquals("E", inverse.get("F"));     }      /**      * Verifies that {@link #map} is still equal to {@link #confirmed}.      * <p>      * This implementation checks the inverse map as well.      */     @Override     public void verify() {         verifyInverse();         super.verify();     }      public void verifyInverse() {         assertEquals(map.size(), ((BidiMap<K, V>) map).inverseBidiMap().size());         final Map<K, V> map1 = new HashMap<>(map);         final Map<V, K> map2 = new HashMap<>(((BidiMap<K, V>) map).inverseBidiMap());         final Set<K> keys1 = map1.keySet();         final Set<V> keys2 = map2.keySet();         final Collection<V> values1 = map1.values();         final Collection<K> values2 = map2.values();         assertTrue(keys1.containsAll(values2));         assertTrue(values2.containsAll(keys1));         assertTrue(values1.containsAll(keys2));         assertTrue(keys2.containsAll(values1));     }      // testGetKey     //-----------------------------------------------------------------------     public void testBidiGetKey() {         doTestGetKey(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);     }      public void testBidiGetKeyInverse() {         doTestGetKey(             makeFullMap().inverseBidiMap(),             getSampleValues()[0],             getSampleKeys()[0]);     }      private void doTestGetKey(final BidiMap<?, ?> map, final Object key, final Object value) {         assertEquals("Value not found for key.", value, map.get(key));         assertEquals("Key not found for value.", key, map.getKey(value));     }      // testInverse     //-----------------------------------------------------------------------     public void testBidiInverse() {         final BidiMap<K, V> map = makeFullMap();         final BidiMap<V, K> inverseMap = map.inverseBidiMap();          assertSame(             "Inverse of inverse is not equal to original.",             map,             inverseMap.inverseBidiMap());          assertEquals(             "Value not found for key.",             getSampleKeys()[0],             inverseMap.get(getSampleValues()[0]));          assertEquals(             "Key not found for value.",             getSampleValues()[0],             inverseMap.getKey(getSampleKeys()[0]));     }      //-----------------------------------------------------------------------     public void testBidiModifyEntrySet() {         if (!isSetValueSupported()) {             return;         }          modifyEntrySet(makeFullMap());         modifyEntrySet(makeFullMap().inverseBidiMap());     }      @SuppressWarnings("unchecked")     private <T> void modifyEntrySet(final BidiMap<?, T> map) {         // Gets first entry         final Map.Entry<?, T> entry = map.entrySet().iterator().next();          // Gets key and value         final Object key = entry.getKey();         final Object oldValue = entry.getValue();          // Sets new value         final Object newValue = "newValue";         entry.setValue((T) newValue);          assertEquals(             "Modifying entrySet did not affect underlying Map.",             newValue,             map.get(key));          assertNull(             "Modifying entrySet did not affect inverse Map.",             map.getKey(oldValue));     }      //-----------------------------------------------------------------------     public void testBidiClear() {         if (!isRemoveSupported()) {             try {                 makeFullMap().clear();                 fail();             } catch(final UnsupportedOperationException ex) {}             return;         }          BidiMap<?, ?> map = makeFullMap();         map.clear();         assertTrue("Map was not cleared.", map.isEmpty());         assertTrue("Inverse map was not cleared.", map.inverseBidiMap().isEmpty());          // Tests clear on inverse         map = makeFullMap().inverseBidiMap();         map.clear();         assertTrue("Map was not cleared.", map.isEmpty());         assertTrue("Inverse map was not cleared.", map.inverseBidiMap().isEmpty());      }      //-----------------------------------------------------------------------     public void testBidiRemove() {         if (!isRemoveSupported()) {             try {                 makeFullMap().remove(getSampleKeys()[0]);                 fail();             } catch(final UnsupportedOperationException ex) {}             try {                 makeFullMap().removeValue(getSampleValues()[0]);                 fail();             } catch(final UnsupportedOperationException ex) {}             return;         }          remove(makeFullMap(), getSampleKeys()[0]);         remove(makeFullMap().inverseBidiMap(), getSampleValues()[0]);          removeValue(makeFullMap(), getSampleValues()[0]);         removeValue(makeFullMap().inverseBidiMap(), getSampleKeys()[0]);          assertNull(makeFullMap().removeValue("NotPresent"));     }      private void remove(final BidiMap<?, ?> map, final Object key) {         final Object value = map.remove(key);         assertFalse("Key was not removed.", map.containsKey(key));         assertNull("Value was not removed.", map.getKey(value));     }      private void removeValue(final BidiMap<?, ?> map, final Object value) {         final Object key = map.removeValue(value);         assertFalse("Key was not removed.", map.containsKey(key));         assertNull("Value was not removed.", map.getKey(value));     }      //-----------------------------------------------------------------------     public void testBidiKeySetValuesOrder() {         resetFull();         final Iterator<K> keys = map.keySet().iterator();         final Iterator<V> values = map.values().iterator();         while (keys.hasNext() && values.hasNext()) {             final K key = keys.next();             final V value = values.next();             assertSame(map.get(key), value);         }         assertFalse(keys.hasNext());         assertFalse(values.hasNext());     }      //-----------------------------------------------------------------------     public void testBidiRemoveByKeySet() {         if (!isRemoveSupported()) {             return;         }          removeByKeySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);         removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);     }      private void removeByKeySet(final BidiMap<?, ?> map, final Object key, final Object value) {         map.keySet().remove(key);          assertFalse("Key was not removed.", map.containsKey(key));         assertFalse("Value was not removed.", map.containsValue(value));          assertFalse("Key was not removed from inverse map.", map.inverseBidiMap().containsValue(key));         assertFalse("Value was not removed from inverse map.", map.inverseBidiMap().containsKey(value));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByEntrySet() {         if (!isRemoveSupported()) {             return;         }          removeByEntrySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);         removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);     }      private void removeByEntrySet(final BidiMap<?, ?> map, final Object key, final Object value) {         final Map<Object, Object> temp = new HashMap<>();         temp.put(key, value);         map.entrySet().remove(temp.entrySet().iterator().next());          assertFalse("Key was not removed.", map.containsKey(key));         assertFalse("Value was not removed.", map.containsValue(value));          assertFalse("Key was not removed from inverse map.", map.inverseBidiMap().containsValue(key));         assertFalse("Value was not removed from inverse map.", map.inverseBidiMap().containsKey(value));     }      /**      * {@inheritDoc}      */     @Override     public BidiMap<K, V> getMap() {         return (BidiMap<K, V>) super.getMap();     }      //-----------------------------------------------------------------------     @Override     public BulkTest bulkTestMapEntrySet() {         return new TestBidiMapEntrySet();     }      public class TestBidiMapEntrySet extends TestMapEntrySet {         public TestBidiMapEntrySet() {         }         public void testMapEntrySetIteratorEntrySetValueCrossCheck() {             final K key1 = getSampleKeys()[0];             final K key2 = getSampleKeys()[1];             final V newValue1 = getNewSampleValues()[0];             final V newValue2 = getNewSampleValues()[1];              resetFull();             // explicitly get entries as sample values/keys are connected for some maps             // such as BeanMap             Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry1 = getEntry(it, key1);             it = TestBidiMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry2 = getEntry(it, key2);             Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);             itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);             TestBidiMapEntrySet.this.verify();              if (!isSetValueSupported()) {                 try {                     entry1.setValue(newValue1);                 } catch (final UnsupportedOperationException ex) {                 }                 return;             }              // these checked in superclass             entry1.setValue(newValue1);             entryConfirmed1.setValue(newValue1);             entry2.setValue(newValue2);             entryConfirmed2.setValue(newValue2);              // at this point             // key1=newValue1, key2=newValue2             try {                 entry2.setValue(newValue1);  // should remove key1             } catch (final IllegalArgumentException ex) {                 return;  // simplest way of dealing with tricky situation             }             entryConfirmed2.setValue(newValue1);             AbstractBidiMapTest.this.getConfirmed().remove(key1);             assertEquals(newValue1, entry2.getValue());             assertTrue(AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));             assertTrue(AbstractBidiMapTest.this.getMap().containsValue(newValue1));             assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));             assertFalse(AbstractBidiMapTest.this.getMap().containsKey(key1));             assertFalse(AbstractBidiMapTest.this.getMap().containsValue(newValue2));             TestBidiMapEntrySet.this.verify();              // check for ConcurrentModification             it.next();  // if you fail here, maybe you should be throwing an IAE, see above             if (isRemoveSupported()) {                 it.remove();             }         }     }      public BulkTest bulkTestInverseMap() {         return new TestInverseBidiMap(this);     }      public class TestInverseBidiMap extends AbstractBidiMapTest<V, K> {         final AbstractBidiMapTest<K, V> main;          public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main) {             this.main = main;         }          @Override         public BidiMap<V, K> makeObject() {             return main.makeObject().inverseBidiMap();         }          @Override         public BidiMap<V, K> makeFullMap() {             return main.makeFullMap().inverseBidiMap();         }          @Override         public V[] getSampleKeys() {             return main.getSampleValues();         }         @Override         public K[] getSampleValues() {             return main.getSampleKeys();         }          @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion();         }          @Override         public boolean isAllowNullKey() {             return main.isAllowNullKey();         }          @Override         public boolean isAllowNullValue() {             return main.isAllowNullValue();         }          @Override         public boolean isPutAddSupported() {             return main.isPutAddSupported();         }          @Override         public boolean isPutChangeSupported() {             return main.isPutChangeSupported();         }          @Override         public boolean isSetValueSupported() {             return main.isSetValueSupported();         }          @Override         public boolean isRemoveSupported() {             return main.isRemoveSupported();         }      }      //-----------------------------------------------------------------------     public BulkTest bulkTestBidiMapIterator() {         return new TestBidiMapIterator();     }      public class TestBidiMapIterator extends AbstractMapIteratorTest<K, V> {         public TestBidiMapIterator() {             super("TestBidiMapIterator");         }          @Override         public V[] addSetValues() {             return AbstractBidiMapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return AbstractBidiMapTest.this.isRemoveSupported();         }          @Override         public boolean supportsSetValue() {             return AbstractBidiMapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractBidiMapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return AbstractBidiMapTest.this.getMap().mapIterator();         }          @Override         public BidiMap<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractBidiMapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractBidiMapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             AbstractBidiMapTest.this.verify();         }     }      //-----------------------------------------------------------------------     public void testBidiMapIteratorSet() {         final V newValue1 = getOtherValues()[0];         final V newValue2 = getOtherValues()[1];          resetFull();         final BidiMap<K, V> bidi = getMap();         final MapIterator<K, V> it = bidi.mapIterator();         assertTrue(it.hasNext());         final K key1 = it.next();          if (!isSetValueSupported()) {             try {                 it.setValue(newValue1);                 fail();             } catch (final UnsupportedOperationException ex) {             }             return;         }          it.setValue(newValue1);         confirmed.put(key1, newValue1);         assertSame(key1, it.getKey());         assertSame(newValue1, it.getValue());         assertTrue(bidi.containsKey(key1));         assertTrue(bidi.containsValue(newValue1));         assertEquals(newValue1, bidi.get(key1));         verify();          it.setValue(newValue1);  // same value - should be OK         confirmed.put(key1, newValue1);         assertSame(key1, it.getKey());         assertSame(newValue1, it.getValue());         assertTrue(bidi.containsKey(key1));         assertTrue(bidi.containsValue(newValue1));         assertEquals(newValue1, bidi.get(key1));         verify();          final K key2 = it.next();         it.setValue(newValue2);         confirmed.put(key2, newValue2);         assertSame(key2, it.getKey());         assertSame(newValue2, it.getValue());         assertTrue(bidi.containsKey(key2));         assertTrue(bidi.containsValue(newValue2));         assertEquals(newValue2, bidi.get(key2));         verify();          // at this point         // key1=newValue1, key2=newValue2         try {             it.setValue(newValue1);  // should remove key1             fail();         } catch (final IllegalArgumentException ex) {             return;  // simplest way of dealing with tricky situation         }         confirmed.put(key2, newValue1);         AbstractBidiMapTest.this.getConfirmed().remove(key1);         assertEquals(newValue1, it.getValue());         assertTrue(bidi.containsKey(it.getKey()));         assertTrue(bidi.containsValue(newValue1));         assertEquals(newValue1, bidi.get(it.getKey()));         assertFalse(bidi.containsKey(key1));         assertFalse(bidi.containsValue(newValue2));         verify();          // check for ConcurrentModification         it.next();  // if you fail here, maybe you should be throwing an IAE, see above         if (isRemoveSupported()) {             it.remove();         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.Enumeration; import java.util.HashMap; import java.util.HashSet; import java.util.Hashtable; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Queue; import java.util.Set; import java.util.SortedMap; import java.util.TreeMap; import java.util.Vector;  import org.apache.commons.collections4.bag.HashBag; import org.apache.commons.collections4.collection.PredicatedCollection; import org.apache.commons.collections4.collection.SynchronizedCollection; import org.apache.commons.collections4.collection.TransformedCollection; import org.apache.commons.collections4.collection.UnmodifiableCollection; import org.apache.commons.collections4.functors.DefaultEquator; import org.apache.commons.collections4.queue.CircularFifoQueue; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Tests for CollectionUtils.  *  */ @SuppressWarnings("boxing") public class CollectionUtilsTest extends MockTestCase {      /**      * Collection of {@link Integer}s      */     private List<Integer> collectionA = null;      /**      * Collection of {@link Long}s      */     private List<Long> collectionB = null;      /**      * Collection of {@link Integer}s that are equivalent to the Longs in      * collectionB.      */     private Collection<Integer> collectionC = null;      /**      * Sorted Collection of {@link Integer}s      */     private Collection<Integer> collectionD = null;      /**      * Sorted Collection of {@link Integer}s      */     private Collection<Integer> collectionE = null;      /**      * Collection of {@link Integer}s, bound as {@link Number}s      */     private Collection<Number> collectionA2 = null;      /**      * Collection of {@link Long}s, bound as {@link Number}s      */     private Collection<Number> collectionB2 = null;      /**      * Collection of {@link Integer}s (cast as {@link Number}s) that are      * equivalent to the Longs in collectionB.      */     private Collection<Number> collectionC2 = null;      private Iterable<Integer> iterableA = null;      private Iterable<Long> iterableB = null;      private Iterable<Integer> iterableC = null;      private Iterable<Number> iterableA2 = null;      private Iterable<Number> iterableB2 = null;      private final Collection<Integer> emptyCollection = new ArrayList<>(1);      @Before     public void setUp() {         collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionB = new LinkedList<>();         collectionB.add(5L);         collectionB.add(4L);         collectionB.add(4L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);          collectionC = new ArrayList<>();         for (final Long l : collectionB) {             collectionC.add(l.intValue());         }          iterableA = collectionA;         iterableB = collectionB;         iterableC = collectionC;         collectionA2 = new ArrayList<>(collectionA);         collectionB2 = new LinkedList<>(collectionB);         collectionC2 = new LinkedList<>(collectionC);         iterableA2 = collectionA2;         iterableB2 = collectionB2;          collectionD = new ArrayList<>();         collectionD.add(1);         collectionD.add(3);         collectionD.add(3);         collectionD.add(3);         collectionD.add(5);         collectionD.add(7);         collectionD.add(7);         collectionD.add(10);          collectionE = new ArrayList<>();         collectionE.add(2);         collectionE.add(4);         collectionE.add(4);         collectionE.add(5);         collectionE.add(6);         collectionE.add(6);         collectionE.add(9);     }      @Test     public void getCardinalityMap() {         final Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);         assertEquals(1, (int) freqA.get(1));         assertEquals(2, (int) freqA.get(2));         assertEquals(3, (int) freqA.get(3));         assertEquals(4, (int) freqA.get(4));         assertNull(freqA.get(5));          final Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);         assertNull(freqB.get(1L));         assertEquals(4, (int) freqB.get(2L));         assertEquals(3, (int) freqB.get(3L));         assertEquals(2, (int) freqB.get(4L));         assertEquals(1, (int) freqB.get(5L));     }      @Test(expected = NullPointerException.class)     public void testGetCardinalityMapNull() {         CollectionUtils.getCardinalityMap(null);     }      @Test     @Deprecated     public void cardinality() {         assertEquals(1, CollectionUtils.cardinality(1, iterableA));         assertEquals(2, CollectionUtils.cardinality(2, iterableA));         assertEquals(3, CollectionUtils.cardinality(3, iterableA));         assertEquals(4, CollectionUtils.cardinality(4, iterableA));         assertEquals(0, CollectionUtils.cardinality(5, iterableA));          assertEquals(0, CollectionUtils.cardinality(1L, iterableB));         assertEquals(4, CollectionUtils.cardinality(2L, iterableB));         assertEquals(3, CollectionUtils.cardinality(3L, iterableB));         assertEquals(2, CollectionUtils.cardinality(4L, iterableB));         assertEquals(1, CollectionUtils.cardinality(5L, iterableB));          // Ensure that generic bounds accept valid parameters, but return         // expected results         // e.g. no longs in the "int" Iterable<Number>, and vice versa.         assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));         assertEquals(0, CollectionUtils.cardinality(2, iterableB2));          final Set<String> set = new HashSet<>();         set.add("A");         set.add("C");         set.add("E");         set.add("E");         assertEquals(1, CollectionUtils.cardinality("A", set));         assertEquals(0, CollectionUtils.cardinality("B", set));         assertEquals(1, CollectionUtils.cardinality("C", set));         assertEquals(0, CollectionUtils.cardinality("D", set));         assertEquals(1, CollectionUtils.cardinality("E", set));          final Bag<String> bag = new HashBag<>();         bag.add("A", 3);         bag.add("C");         bag.add("E");         bag.add("E");         assertEquals(3, CollectionUtils.cardinality("A", bag));         assertEquals(0, CollectionUtils.cardinality("B", bag));         assertEquals(1, CollectionUtils.cardinality("C", bag));         assertEquals(0, CollectionUtils.cardinality("D", bag));         assertEquals(2, CollectionUtils.cardinality("E", bag));     }      @Test     @Deprecated     public void cardinalityOfNull() {         final List<String> list = new ArrayList<>();         assertEquals(0, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertNull(freq.get(null));         }         list.add("A");         assertEquals(0, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertNull(freq.get(null));         }         list.add(null);         assertEquals(1, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(1), freq.get(null));         }         list.add("B");         assertEquals(1, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(1), freq.get(null));         }         list.add(null);         assertEquals(2, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(2), freq.get(null));         }         list.add("B");         assertEquals(2, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(2), freq.get(null));         }         list.add(null);         assertEquals(3, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(3), freq.get(null));         }     }      @Test     public void containsAll() {         final Collection<String> empty = new ArrayList<>(0);         final Collection<String> one = new ArrayList<>(1);         one.add("1");         final Collection<String> two = new ArrayList<>(1);         two.add("2");         final Collection<String> three = new ArrayList<>(1);         three.add("3");         final Collection<String> odds = new ArrayList<>(2);         odds.add("1");         odds.add("3");         final Collection<String> multiples = new ArrayList<>(3);         multiples.add("1");         multiples.add("3");         multiples.add("1");          assertFalse("containsAll({1},{1,3}) should return false.", CollectionUtils.containsAll(one, odds));         assertTrue("containsAll({1,3},{1}) should return true.", CollectionUtils.containsAll(odds, one));         assertFalse("containsAll({3},{1,3}) should return false.", CollectionUtils.containsAll(three, odds));         assertTrue("containsAll({1,3},{3}) should return true.", CollectionUtils.containsAll(odds, three));         assertTrue("containsAll({2},{2}) should return true.", CollectionUtils.containsAll(two, two));         assertTrue("containsAll({1,3},{1,3}) should return true.", CollectionUtils.containsAll(odds, odds));          assertFalse("containsAll({2},{1,3}) should return false.", CollectionUtils.containsAll(two, odds));         assertFalse("containsAll({1,3},{2}) should return false.", CollectionUtils.containsAll(odds, two));         assertFalse("containsAll({1},{3}) should return false.", CollectionUtils.containsAll(one, three));         assertFalse("containsAll({3},{1}) should return false.", CollectionUtils.containsAll(three, one));         assertTrue("containsAll({1,3},{}) should return true.", CollectionUtils.containsAll(odds, empty));         assertFalse("containsAll({},{1,3}) should return false.", CollectionUtils.containsAll(empty, odds));         assertTrue("containsAll({},{}) should return true.", CollectionUtils.containsAll(empty, empty));          assertTrue("containsAll({1,3},{1,3,1}) should return true.", CollectionUtils.containsAll(odds, multiples));         assertTrue("containsAll({1,3,1},{1,3,1}) should return true.", CollectionUtils.containsAll(odds, odds));     }      @Test     public void containsAnyInCollection() {         final Collection<String> empty = new ArrayList<>(0);         final Collection<String> one = new ArrayList<>(1);         one.add("1");         final Collection<String> two = new ArrayList<>(1);         two.add("2");         final Collection<String> three = new ArrayList<>(1);         three.add("3");         final Collection<String> odds = new ArrayList<>(2);         odds.add("1");         odds.add("3");          assertTrue("containsAny({1},{1,3}) should return true.", CollectionUtils.containsAny(one, odds));         assertTrue("containsAny({1,3},{1}) should return true.", CollectionUtils.containsAny(odds, one));         assertTrue("containsAny({3},{1,3}) should return true.", CollectionUtils.containsAny(three, odds));         assertTrue("containsAny({1,3},{3}) should return true.", CollectionUtils.containsAny(odds, three));         assertTrue("containsAny({2},{2}) should return true.", CollectionUtils.containsAny(two, two));         assertTrue("containsAny({1,3},{1,3}) should return true.", CollectionUtils.containsAny(odds, odds));          assertFalse("containsAny({2},{1,3}) should return false.", CollectionUtils.containsAny(two, odds));         assertFalse("containsAny({1,3},{2}) should return false.", CollectionUtils.containsAny(odds, two));         assertFalse("containsAny({1},{3}) should return false.", CollectionUtils.containsAny(one, three));         assertFalse("containsAny({3},{1}) should return false.", CollectionUtils.containsAny(three, one));         assertFalse("containsAny({1,3},{}) should return false.", CollectionUtils.containsAny(odds, empty));         assertFalse("containsAny({},{1,3}) should return false.", CollectionUtils.containsAny(empty, odds));         assertFalse("containsAny({},{}) should return false.", CollectionUtils.containsAny(empty, empty));     }      @Test(expected = NullPointerException.class)     public void testContainsAnyNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.containsAny(null, list);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final Collection<String> list2 = null;         CollectionUtils.containsAny(list, list2);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyNullColl3() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final String[] array = null;         CollectionUtils.containsAny(list, array);     }      @Test     public void containsAnyInArray() {         final Collection<String> empty = new ArrayList<>(0);         final String[] emptyArr = {};         final Collection<String> one = new ArrayList<>(1);         one.add("1");         final String[] oneArr = {"1"};         final Collection<String> two = new ArrayList<>(1);         two.add("2");         final String[] twoArr = {"2"};         final Collection<String> three = new ArrayList<>(1);         three.add("3");         final String[] threeArr = {"3"};         final Collection<String> odds = new ArrayList<>(2);         odds.add("1");         odds.add("3");         final String[] oddsArr = {"1", "3"};          assertTrue("containsAny({1},{1,3}) should return true.", CollectionUtils.containsAny(one, oddsArr));         assertTrue("containsAny({1,3},{1}) should return true.", CollectionUtils.containsAny(odds, oneArr));         assertTrue("containsAny({3},{1,3}) should return true.", CollectionUtils.containsAny(three, oddsArr));         assertTrue("containsAny({1,3},{3}) should return true.", CollectionUtils.containsAny(odds, threeArr));         assertTrue("containsAny({2},{2}) should return true.", CollectionUtils.containsAny(two, twoArr));         assertTrue("containsAny({1,3},{1,3}) should return true.", CollectionUtils.containsAny(odds, oddsArr));          assertFalse("containsAny({2},{1,3}) should return false.", CollectionUtils.containsAny(two, oddsArr));         assertFalse("containsAny({1,3},{2}) should return false.", CollectionUtils.containsAny(odds, twoArr));         assertFalse("containsAny({1},{3}) should return false.", CollectionUtils.containsAny(one, threeArr));         assertFalse("containsAny({3},{1}) should return false.", CollectionUtils.containsAny(three, oneArr));         assertFalse("containsAny({1,3},{}) should return false.", CollectionUtils.containsAny(odds, emptyArr));         assertFalse("containsAny({},{1,3}) should return false.", CollectionUtils.containsAny(empty, oddsArr));         assertFalse("containsAny({},{}) should return false.", CollectionUtils.containsAny(empty, emptyArr));     }      @Test(expected = NullPointerException.class)     public void testContainsAnyInArrayNullColl1() {         final String[] oneArr = {"1"};         CollectionUtils.containsAny(null, oneArr);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyInArrayNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final Collection<String> list2 = null;         CollectionUtils.containsAny(list, list2);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyInArrayNullArray() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final String[] array = null;         CollectionUtils.containsAny(list, array);     }      @Test     public void union() {         final Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq.get(1));         assertEquals(Integer.valueOf(4), freq.get(2));         assertEquals(Integer.valueOf(3), freq.get(3));         assertEquals(Integer.valueOf(4), freq.get(4));         assertEquals(Integer.valueOf(1), freq.get(5));          final Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertEquals(Integer.valueOf(1), freq2.get(1));         assertEquals(Integer.valueOf(4), freq2.get(2));         assertEquals(Integer.valueOf(3), freq2.get(3));         assertEquals(Integer.valueOf(4), freq2.get(4));         assertEquals(Integer.valueOf(1), freq2.get(5));     }      @Test(expected = NullPointerException.class)     public void testUnionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.union(null, list);     }      @Test(expected = NullPointerException.class)     public void testUnionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.union(list, null);     }      @Test     public void intersection() {         final Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertNull(freq.get(1));         assertEquals(Integer.valueOf(2), freq.get(2));         assertEquals(Integer.valueOf(3), freq.get(3));         assertEquals(Integer.valueOf(2), freq.get(4));         assertNull(freq.get(5));          final Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertNull(freq2.get(1));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertEquals(Integer.valueOf(3), freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(4));         assertNull(freq2.get(5));     }      @Test(expected = NullPointerException.class)     public void testIntersectionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.intersection(null, list);     }      @Test(expected = NullPointerException.class)     public void testIntersectionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.intersection(list, null);     }      @Test     public void disjunction() {         final Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq.get(1));         assertEquals(Integer.valueOf(2), freq.get(2));         assertNull(freq.get(3));         assertEquals(Integer.valueOf(2), freq.get(4));         assertEquals(Integer.valueOf(1), freq.get(5));          final Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertEquals(Integer.valueOf(1), freq2.get(1));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertNull(freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(4));         assertEquals(Integer.valueOf(1), freq2.get(5));     }      @Test(expected = NullPointerException.class)     public void testDisjunctionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.disjunction(null, list);     }      @Test(expected = NullPointerException.class)     public void testDisjunctionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.disjunction(list, null);     }      @Test     public void testDisjunctionAsUnionMinusIntersection() {         final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);         final Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);         final Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);         assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));     }      @Test     public void testDisjunctionAsSymmetricDifference() {         final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);         final Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);         final Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);         assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));     }      @Test     public void testSubtract() {         final Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq.get(1));         assertNull(freq.get(2));         assertNull(freq.get(3));         assertEquals(Integer.valueOf(2), freq.get(4));         assertNull(freq.get(5));          final Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertEquals(Integer.valueOf(1), freq2.get(5));         assertNull(freq2.get(4));         assertNull(freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertNull(freq2.get(1));     }      @Test(expected = NullPointerException.class)     public void testSubtractNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.subtract(null, list);     }      @Test(expected = NullPointerException.class)     public void testSubtractNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.subtract(list, null);     }      @Test     public void testSubtractWithPredicate() {         // greater than 3         final Predicate<Number> predicate = n -> n.longValue() > 3L;          final Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq2.get(1));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertEquals(Integer.valueOf(3), freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(4));         assertNull(freq2.get(5));     }      @Test     public void testIsSubCollectionOfSelf() {         assertTrue(CollectionUtils.isSubCollection(collectionA, collectionA));         assertTrue(CollectionUtils.isSubCollection(collectionB, collectionB));     }      @Test     public void testIsSubCollection() {         assertFalse(CollectionUtils.isSubCollection(collectionA, collectionC));         assertFalse(CollectionUtils.isSubCollection(collectionC, collectionA));     }      @Test     public void testIsSubCollection2() {         final Collection<Integer> c = new ArrayList<>();         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(1);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(2);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(2);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(3);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(3);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(3);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertTrue(CollectionUtils.isSubCollection(collectionA, c));         c.add(5);         assertFalse(CollectionUtils.isSubCollection(c, collectionA));         assertTrue(CollectionUtils.isSubCollection(collectionA, c));     }      @Test(expected = NullPointerException.class)     public void testIsSubCollectionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isSubCollection(null, list);     }      @Test(expected = NullPointerException.class)     public void testIsSubCollectionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isSubCollection(list, null);     }      @Test     public void testIsEqualCollectionToSelf() {         assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA));         assertTrue(CollectionUtils.isEqualCollection(collectionB, collectionB));     }      @Test     public void testIsEqualCollection() {         assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionC));         assertFalse(CollectionUtils.isEqualCollection(collectionC, collectionA));     }      @Test     public void testIsEqualCollectionReturnsFalse() {         final List<Integer> b = new ArrayList<>(collectionA);         // remove an extra '2', and add a 5.  This will increase the size of the cardinality         b.remove(1);         b.add(5);         assertFalse(CollectionUtils.isEqualCollection(collectionA, b));         assertFalse(CollectionUtils.isEqualCollection(b, collectionA));     }      @Test     public void testIsEqualCollection2() {         final Collection<String> a = new ArrayList<>();         final Collection<String> b = new ArrayList<>();         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));         a.add("1");         assertFalse(CollectionUtils.isEqualCollection(a, b));         assertFalse(CollectionUtils.isEqualCollection(b, a));         b.add("1");         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));         a.add("2");         assertFalse(CollectionUtils.isEqualCollection(a, b));         assertFalse(CollectionUtils.isEqualCollection(b, a));         b.add("2");         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));         a.add("1");         assertFalse(CollectionUtils.isEqualCollection(a, b));         assertFalse(CollectionUtils.isEqualCollection(b, a));         b.add("1");         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));     }      @Test     public void testIsEqualCollectionEquator() {         final Collection<Integer> collB = CollectionUtils.collect(collectionB, TRANSFORM_TO_INTEGER);          // odd / even equator         final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();             }         };          assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA, e));         assertTrue(CollectionUtils.isEqualCollection(collectionA, collB, e));         assertTrue(CollectionUtils.isEqualCollection(collB, collectionA, e));          final Equator<Number> defaultEquator = DefaultEquator.defaultEquator();         assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionB, defaultEquator));         assertFalse(CollectionUtils.isEqualCollection(collectionA, collB, defaultEquator));     }      @Test(expected=NullPointerException.class)     public void testIsEqualCollectionNullEquator() {         CollectionUtils.isEqualCollection(collectionA, collectionA, null);     }      @Test     public void testHashCode() {         final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1 % 2 == 0 ^ o2 % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o == null ? 0 : Objects.hashCode(o);             }         };          assertEquals(collectionA.hashCode(), CollectionUtils.hashCode(collectionA, e));     }      @Test     public void testHashCodeNullCollection() {         final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1 % 2 == 0 ^ o2 % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o == null ? 0 : Objects.hashCode(o);             }         };          final Collection<Integer> collection = null;         assertEquals(0, CollectionUtils.hashCode(collection, e));     }      @Test(expected=NullPointerException.class)     public void testHashCodeNullEquator() {         CollectionUtils.hashCode(collectionB, null);     }      @Test(expected = NullPointerException.class)     public void testIsEqualCollectionNullColl1() {         final Collection<Integer> list = new ArrayList<>(1);         list.add(1);          final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();             }         };          CollectionUtils.isEqualCollection(null, list, e);     }      @Test(expected = NullPointerException.class)     public void testIsEqualCollectionNullColl2() {         final Collection<Integer> list = new ArrayList<>(1);         list.add(1);          final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();             }         };          CollectionUtils.isEqualCollection(list, null, e);     }      @Test     public void testIsProperSubCollection() {         final Collection<String> a = new ArrayList<>();         final Collection<String> b = new ArrayList<>();         assertFalse(CollectionUtils.isProperSubCollection(a, b));         b.add("1");         assertTrue(CollectionUtils.isProperSubCollection(a, b));         assertFalse(CollectionUtils.isProperSubCollection(b, a));         assertFalse(CollectionUtils.isProperSubCollection(b, b));         assertFalse(CollectionUtils.isProperSubCollection(a, a));         a.add("1");         a.add("2");         b.add("2");         assertFalse(CollectionUtils.isProperSubCollection(b, a));         assertFalse(CollectionUtils.isProperSubCollection(a, b));         a.add("1");         assertTrue(CollectionUtils.isProperSubCollection(b, a));         assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.intersection(collectionA, collectionC), collectionA));         assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.subtract(a, b), a));         assertFalse(CollectionUtils.isProperSubCollection(a, CollectionUtils.subtract(a, b)));     }      @Test(expected = NullPointerException.class)     public void testIsProperSubCollectionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isProperSubCollection(null, list);     }      @Test(expected = NullPointerException.class)     public void testIsProperSubCollectionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isProperSubCollection(list, null);     }      @Test     @Deprecated     public void find() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         Integer test = CollectionUtils.find(collectionA, testPredicate);         assertEquals(4, (int) test);         testPredicate = equalPredicate((Number) 45);         test = CollectionUtils.find(collectionA, testPredicate);         assertNull(test);         assertNull(CollectionUtils.find(null, testPredicate));         assertNull(CollectionUtils.find(collectionA, null));     }      @Test     @Deprecated     public void forAllDoCollection() {         final Closure<Collection<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<Collection<Integer>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionC);         Closure<Collection<Integer>> resultClosure = CollectionUtils.forAllDo(col, testClosure);         assertSame(testClosure, resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         // fix for various java 1.6 versions: keep the cast         resultClosure = CollectionUtils.forAllDo(col, (Closure<Collection<Integer>>) null);         assertNull(resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         resultClosure = CollectionUtils.forAllDo((Collection<Collection<Integer>>) null, testClosure);         col.add(null);         // null should be OK         CollectionUtils.forAllDo(col, testClosure);     }      @Test     @Deprecated     public void forAllDoIterator() {         final Closure<Collection<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<Collection<Integer>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionC);         Closure<Collection<Integer>> resultClosure = CollectionUtils.forAllDo(col.iterator(), testClosure);         assertSame(testClosure, resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         // fix for various java 1.6 versions: keep the cast         resultClosure = CollectionUtils.forAllDo(col.iterator(), (Closure<Collection<Integer>>) null);         assertNull(resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         resultClosure = CollectionUtils.forAllDo((Iterator<Collection<Integer>>) null, testClosure);         col.add(null);         // null should be OK         CollectionUtils.forAllDo(col.iterator(), testClosure);     }      @Test(expected = FunctorException.class)     @Deprecated     public void forAllDoFailure() {         final Closure<String> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<String> col = new ArrayList<>();         col.add("x");         CollectionUtils.forAllDo(col, testClosure);     }      @Test     @Deprecated     public void forAllButLastDoCollection() {         final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<? extends Number>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionB);         List<? extends Number> lastElement = CollectionUtils.forAllButLastDo(col, testClosure);         assertSame(lastElement, collectionB);         assertTrue(collectionA.isEmpty() && !collectionB.isEmpty());          col.clear();         col.add(collectionB);         lastElement = CollectionUtils.forAllButLastDo(col, testClosure);         assertSame(lastElement, collectionB);         assertFalse(collectionB.isEmpty());          col.clear();         lastElement = CollectionUtils.forAllButLastDo(col, testClosure);         assertNull(lastElement);          final Collection<String> strings = Arrays.asList("a", "b", "c");         final StringBuffer result = new StringBuffer();         result.append(CollectionUtils.forAllButLastDo(strings, (Closure<String>) input -> result.append(input+";")));         assertEquals("a;b;c", result.toString());          final Collection<String> oneString = Arrays.asList("a");         final StringBuffer resultOne = new StringBuffer();         resultOne.append(CollectionUtils.forAllButLastDo(oneString, (Closure<String>) input -> resultOne.append(input+";")));         assertEquals("a", resultOne.toString());         assertNull(CollectionUtils.forAllButLastDo(strings, (Closure<String>) null)); // do not remove cast         assertNull(CollectionUtils.forAllButLastDo((Collection<String>) null, (Closure<String>) null)); // do not remove cast     }      @Test     @Deprecated     public void forAllButLastDoIterator() {         final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<? extends Number>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionB);         final List<? extends Number> lastElement = CollectionUtils.forAllButLastDo(col.iterator(), testClosure);         assertSame(lastElement, collectionB);         assertTrue(collectionA.isEmpty() && !collectionB.isEmpty());          assertNull(CollectionUtils.forAllButLastDo(col.iterator(), (Closure<List<? extends Number>>) null));         assertNull(CollectionUtils.forAllButLastDo((Iterator<String>) null, (Closure<String>) null)); // do not remove cast     }      @Test     public void getFromMap() {         // Unordered map, entries exist         final Map<String, String> expected = new HashMap<>();         expected.put("zeroKey", "zero");         expected.put("oneKey", "one");          final Map<String, String> found = new HashMap<>();         Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);         found.put(entry.getKey(), entry.getValue());         entry = CollectionUtils.get(expected, 1);         found.put(entry.getKey(), entry.getValue());         assertEquals(expected, found);          // Map index out of range         try {             CollectionUtils.get(expected, 2);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         try {             CollectionUtils.get(expected, -2);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }          // Sorted map, entries exist, should respect order         final SortedMap<String, String> map = new TreeMap<>();         map.put("zeroKey", "zero");         map.put("oneKey", "one");         Map.Entry<String, String> test = CollectionUtils.get(map, 1);         assertEquals("zeroKey", test.getKey());         assertEquals("zero", test.getValue());         test = CollectionUtils.get(map, 0);         assertEquals("oneKey", test.getKey());         assertEquals("one", test.getValue());     }      /**      * Tests that {@link List}s are handled correctly - e.g. using      * {@link List#get(int)}.      */     @Test(expected=IndexOutOfBoundsException.class)     public void getFromList() throws Exception {         // List, entry exists         final List<String> list = createMock(List.class);         expect(list.get(0)).andReturn("zero");         expect(list.get(1)).andReturn("one");         replay();         final String string = CollectionUtils.get(list, 0);         assertEquals("zero", string);         assertEquals("one", CollectionUtils.get(list, 1));         // list, non-existent entry -- IndexOutOfBoundsException         CollectionUtils.get(new ArrayList<>(), 2);     }      @Test     @Deprecated     public void getFromIterator() throws Exception {         // Iterator, entry exists         Iterator<Integer> iterator = iterableA.iterator();         assertEquals(1, (int) CollectionUtils.get(iterator, 0));         iterator = iterableA.iterator();         assertEquals(2, (int) CollectionUtils.get(iterator, 1));          // Iterator, non-existent entry         try {             CollectionUtils.get(iterator, 10);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertFalse(iterator.hasNext());     }      @Test     @Deprecated     public void getFromEnumeration() throws Exception {         // Enumeration, entry exists         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         Enumeration<String> en = vector.elements();         assertEquals("zero", CollectionUtils.get(en, 0));         en = vector.elements();         assertEquals("one", CollectionUtils.get(en, 1));          // Enumerator, non-existent entry         try {             CollectionUtils.get(en, 3);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertFalse(en.hasMoreElements());     }      @Test(expected = IndexOutOfBoundsException.class)     @Deprecated     public void getFromIterable() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         assertEquals("element", CollectionUtils.get(bag, 0));          // Collection, non-existent entry         CollectionUtils.get(bag, 1);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getFromObjectArray() throws Exception {         // Object array, entry exists         final Object[] objArray = new Object[2];         objArray[0] = "zero";         objArray[1] = "one";         assertEquals("zero", CollectionUtils.get(objArray, 0));         assertEquals("one", CollectionUtils.get(objArray, 1));          // Object array, non-existent entry --         // ArrayIndexOutOfBoundsException         CollectionUtils.get(objArray, 2);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getFromPrimitiveArray() throws Exception {         // Primitive array, entry exists         final int[] array = new int[2];         array[0] = 10;         array[1] = 20;         assertEquals(10, CollectionUtils.get(array, 0));         assertEquals(20, CollectionUtils.get(array, 1));          // Object array, non-existent entry --         // ArrayIndexOutOfBoundsException         CollectionUtils.get(array, 2);     }      @Test(expected = IllegalArgumentException.class)     public void getFromObject() throws Exception {         // Invalid object         final Object obj = new Object();         CollectionUtils.get(obj, 0);     }      // -----------------------------------------------------------------------     @Test     public void testSize_List() {         List<String> list = null;         assertEquals(0, CollectionUtils.size(list));         list = new ArrayList<>();         assertEquals(0, CollectionUtils.size(list));         list.add("a");         assertEquals(1, CollectionUtils.size(list));         list.add("b");         assertEquals(2, CollectionUtils.size(list));     }      @Test     public void testSize_Map() {         final Map<String, String> map = new HashMap<>();         assertEquals(0, CollectionUtils.size(map));         map.put("1", "a");         assertEquals(1, CollectionUtils.size(map));         map.put("2", "b");         assertEquals(2, CollectionUtils.size(map));     }      @Test     public void testSize_Array() {         final Object[] objectArray = new Object[0];         assertEquals(0, CollectionUtils.size(objectArray));          final String[] stringArray = new String[3];         assertEquals(3, CollectionUtils.size(stringArray));         stringArray[0] = "a";         stringArray[1] = "b";         stringArray[2] = "c";         assertEquals(3, CollectionUtils.size(stringArray));     }      @Test     public void testSize_PrimitiveArray() {         final int[] intArray = new int[0];         assertEquals(0, CollectionUtils.size(intArray));          final double[] doubleArray = new double[3];         assertEquals(3, CollectionUtils.size(doubleArray));         doubleArray[0] = 0.0d;         doubleArray[1] = 1.0d;         doubleArray[2] = 2.5d;         assertEquals(3, CollectionUtils.size(doubleArray));     }      @Test     public void testSize_Enumeration() {         final Vector<String> list = new Vector<>();         assertEquals(0, CollectionUtils.size(list.elements()));         list.add("a");         assertEquals(1, CollectionUtils.size(list.elements()));         list.add("b");         assertEquals(2, CollectionUtils.size(list.elements()));     }      @Test     public void testSize_Iterator() {         final List<String> list = new ArrayList<>();         assertEquals(0, CollectionUtils.size(list.iterator()));         list.add("a");         assertEquals(1, CollectionUtils.size(list.iterator()));         list.add("b");         assertEquals(2, CollectionUtils.size(list.iterator()));     }      @Test(expected=IllegalArgumentException.class)     public void testSize_Other() {         CollectionUtils.size("not a list");     }      // -----------------------------------------------------------------------     @Test     public void testSizeIsEmpty_Null() {         assertTrue(CollectionUtils.sizeIsEmpty(null));     }      @Test     public void testSizeIsEmpty_List() {         final List<String> list = new ArrayList<>();         assertTrue(CollectionUtils.sizeIsEmpty(list));         list.add("a");         assertFalse(CollectionUtils.sizeIsEmpty(list));     }      @Test     public void testSizeIsEmpty_Map() {         final Map<String, String> map = new HashMap<>();         assertEquals(true, CollectionUtils.sizeIsEmpty(map));         map.put("1", "a");         assertEquals(false, CollectionUtils.sizeIsEmpty(map));     }      @Test     public void testSizeIsEmpty_Array() {         final Object[] objectArray = new Object[0];         assertTrue(CollectionUtils.sizeIsEmpty(objectArray));          final String[] stringArray = new String[3];         assertFalse(CollectionUtils.sizeIsEmpty(stringArray));         stringArray[0] = "a";         stringArray[1] = "b";         stringArray[2] = "c";         assertFalse(CollectionUtils.sizeIsEmpty(stringArray));     }      @Test     public void testSizeIsEmpty_PrimitiveArray() {         final int[] intArray = new int[0];         assertTrue(CollectionUtils.sizeIsEmpty(intArray));          final double[] doubleArray = new double[3];         assertFalse(CollectionUtils.sizeIsEmpty(doubleArray));         doubleArray[0] = 0.0d;         doubleArray[1] = 1.0d;         doubleArray[2] = 2.5d;         assertFalse(CollectionUtils.sizeIsEmpty(doubleArray));     }      @Test     public void testSizeIsEmpty_Enumeration() {         final Vector<String> list = new Vector<>();         assertTrue(CollectionUtils.sizeIsEmpty(list.elements()));         list.add("a");         assertFalse(CollectionUtils.sizeIsEmpty(list.elements()));         final Enumeration<String> en = list.elements();         en.nextElement();         assertTrue(CollectionUtils.sizeIsEmpty(en));     }      @Test     public void testSizeIsEmpty_Iterator() {         final List<String> list = new ArrayList<>();         assertTrue(CollectionUtils.sizeIsEmpty(list.iterator()));         list.add("a");         assertFalse(CollectionUtils.sizeIsEmpty(list.iterator()));         final Iterator<String> it = list.iterator();         it.next();         assertTrue(CollectionUtils.sizeIsEmpty(it));     }      @Test     public void testSizeIsEmpty_Other() {         try {             CollectionUtils.sizeIsEmpty("not a list");             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {         }     }      // -----------------------------------------------------------------------     @Test     public void testIsEmptyWithEmptyCollection() {         assertTrue(CollectionUtils.isEmpty(new ArrayList<>()));     }      @Test     public void testIsEmptyWithNonEmptyCollection() {         assertFalse(CollectionUtils.isEmpty(Collections.singletonList("item")));     }      @Test     public void testIsEmptyWithNull() {         assertTrue(CollectionUtils.isEmpty(null));     }      @Test     public void testIsNotEmptyWithEmptyCollection() {         assertFalse(CollectionUtils.isNotEmpty(new ArrayList<>()));     }      @Test     public void testIsNotEmptyWithNonEmptyCollection() {         assertTrue(CollectionUtils.isNotEmpty(Collections.singletonList("item")));     }      @Test     public void testIsNotEmptyWithNull() {         assertFalse(CollectionUtils.isNotEmpty(null));     }      // -----------------------------------------------------------------------     private static Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;  //Up to here     @Test     public void filter() {         final List<Integer> ints = new ArrayList<>();         ints.add(1);         ints.add(2);         ints.add(3);         ints.add(3);         final Iterable<Integer> iterable = ints;         assertTrue(CollectionUtils.filter(iterable, EQUALS_TWO));         assertEquals(1, ints.size());         assertEquals(2, (int) ints.get(0));     }      @Test     public void filterNullParameters() throws Exception {         final List<Long> longs = Collections.nCopies(4, 10L);         assertFalse(CollectionUtils.filter(longs, null));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filter(null, EQUALS_TWO));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filter(null, null));         assertEquals(4, longs.size());     }      @Test     public void filterInverse() {         final List<Integer> ints = new ArrayList<>();         ints.add(1);         ints.add(2);         ints.add(3);         ints.add(3);         final Iterable<Integer> iterable = ints;         assertTrue(CollectionUtils.filterInverse(iterable, EQUALS_TWO));         assertEquals(3, ints.size());         assertEquals(1, (int) ints.get(0));         assertEquals(3, (int) ints.get(1));         assertEquals(3, (int) ints.get(2));     }      @Test     public void filterInverseNullParameters() throws Exception {         final List<Long> longs = Collections.nCopies(4, 10L);         assertFalse(CollectionUtils.filterInverse(longs, null));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filterInverse(null, EQUALS_TWO));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filterInverse(null, null));         assertEquals(4, longs.size());     }      @Test     @Deprecated     public void countMatches() {         assertEquals(4, CollectionUtils.countMatches(iterableB, EQUALS_TWO));         assertEquals(0, CollectionUtils.countMatches(iterableA, null));         assertEquals(0, CollectionUtils.countMatches(null, EQUALS_TWO));         assertEquals(0, CollectionUtils.countMatches(null, null));     }      @Test     @Deprecated     public void exists() {         final List<Integer> list = new ArrayList<>();         assertFalse(CollectionUtils.exists(null, null));         assertFalse(CollectionUtils.exists(list, null));         assertFalse(CollectionUtils.exists(null, EQUALS_TWO));         assertFalse(CollectionUtils.exists(list, EQUALS_TWO));         list.add(1);         list.add(3);         list.add(4);         assertFalse(CollectionUtils.exists(list, EQUALS_TWO));          list.add(2);         assertTrue(CollectionUtils.exists(list, EQUALS_TWO));     }      @Test     public void select() {         final List<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         // Ensure that the collection is the input type or a super type         final Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);         final Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(1, output1.size());         assertEquals(2, output2.iterator().next());     }      @Test     public void selectWithOutputCollections() {         final List<Integer> input = new ArrayList<>();         input.add(1);         input.add(2);         input.add(3);         input.add(4);          final List<Integer> output = new ArrayList<>();         final List<Integer> rejected = new ArrayList<>();          CollectionUtils.select(input, EQUALS_TWO, output, rejected);          // output contains 2         assertEquals(1, output.size());         assertEquals(2, CollectionUtils.extractSingleton(output).intValue());          // rejected contains 1, 3, and 4         final Integer[] expected = {1, 3, 4};         Assert.assertArrayEquals(expected, rejected.toArray());          output.clear();         rejected.clear();         CollectionUtils.select((List<Integer>) null, EQUALS_TWO, output, rejected);         assertTrue(output.isEmpty());         assertTrue(rejected.isEmpty());     }      @Test     public void selectRejected() {         final List<Long> list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         list.add(4L);         final Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);         final Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output2));         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(3, output1.size());         assertTrue(output1.contains(1L));         assertTrue(output1.contains(3L));         assertTrue(output1.contains(4L));     }      @Test     public void collect() {         final Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);         Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);         assertTrue(collection.size() == collectionA.size());         assertCollectResult(collection);          ArrayList<Number> list;         list = CollectionUtils.collect(collectionA, transformer, new ArrayList<Number>());         assertTrue(list.size() == collectionA.size());         assertCollectResult(list);          Iterator<Integer> iterator = null;         list = CollectionUtils.collect(iterator, transformer, new ArrayList<Number>());          iterator = iterableA.iterator();         list = CollectionUtils.collect(iterator, transformer, list);         assertTrue(collection.size() == collectionA.size());         assertCollectResult(collection);          iterator = collectionA.iterator();         collection = CollectionUtils.<Integer, Number>collect(iterator, transformer);         assertTrue(collection.size() == collectionA.size());         assertTrue(collection.contains(2L) && !collection.contains(1));         collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);         assertTrue(collection.size() == 0);          final int size = collectionA.size();         collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);         assertTrue(collectionA.size() == size && collectionA.contains(1));         CollectionUtils.collect(collectionB, null, collectionA);         assertTrue(collectionA.size() == size && collectionA.contains(1));      }      private void assertCollectResult(final Collection<Number> collection) {         assertTrue(collectionA.contains(1) && !collectionA.contains(2L));         assertTrue(collection.contains(2L) && !collection.contains(1));     }      Transformer<Object, Integer> TRANSFORM_TO_INTEGER = input -> Integer.valueOf(((Long) input).intValue());      @Test     public void transform1() {         List<Number> list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         CollectionUtils.transform(list, TRANSFORM_TO_INTEGER);         assertEquals(3, list.size());         assertEquals(1, list.get(0));         assertEquals(2, list.get(1));         assertEquals(3, list.get(2));          list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         CollectionUtils.transform(null, TRANSFORM_TO_INTEGER);         assertEquals(3, list.size());         CollectionUtils.transform(list, null);         assertEquals(3, list.size());         CollectionUtils.transform(null, null);         assertEquals(3, list.size());     }      @Test     public void transform2() {         final Set<Number> set = new HashSet<>();         set.add(1L);         set.add(2L);         set.add(3L);         CollectionUtils.transform(set, input -> 4);         assertEquals(1, set.size());         assertEquals(4, set.iterator().next());     }      // -----------------------------------------------------------------------     @Test     public void addIgnoreNull() {         final Set<String> set = new HashSet<>();         set.add("1");         set.add("2");         set.add("3");         assertFalse(CollectionUtils.addIgnoreNull(set, null));         assertEquals(3, set.size());         assertFalse(CollectionUtils.addIgnoreNull(set, "1"));         assertEquals(3, set.size());         assertTrue(CollectionUtils.addIgnoreNull(set, "4"));         assertEquals(4, set.size());         assertTrue(set.contains("4"));     }      @Test(expected = NullPointerException.class)     public void testAddIgnoreNullNullColl() {         CollectionUtils.addIgnoreNull(null, "1");     }      // -----------------------------------------------------------------------     @Test     public void predicatedCollection() {         final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);         final Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), predicate);         assertTrue("returned object should be a PredicatedCollection", collection instanceof PredicatedCollection);     }      @Test(expected = NullPointerException.class)     public void testPredicatedCollectionNullColl() {         final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);         CollectionUtils.predicatedCollection(null, predicate);     }      @Test(expected = NullPointerException.class)     public void testPredicatedCollectionNullPredicate() {         final Collection<Integer> list = new ArrayList<>();         CollectionUtils.predicatedCollection(list, null);     }      @Test     public void isFull() {         final Set<String> set = new HashSet<>();         set.add("1");         set.add("2");         set.add("3");         assertFalse(CollectionUtils.isFull(set));          final CircularFifoQueue<String> buf = new CircularFifoQueue<>(set);         assertFalse(CollectionUtils.isFull(buf));         buf.remove("2");         assertFalse(CollectionUtils.isFull(buf));         buf.add("2");         assertFalse(CollectionUtils.isFull(buf));     }      @Test(expected = NullPointerException.class)     public void testIsFullNullColl() {         CollectionUtils.isFull(null);     }      @Test     public void isEmpty() {         assertFalse(CollectionUtils.isNotEmpty(null));         assertTrue(CollectionUtils.isNotEmpty(collectionA));     }      @Test     public void maxSize() {         final Set<String> set = new HashSet<>();         set.add("1");         set.add("2");         set.add("3");         assertEquals(-1, CollectionUtils.maxSize(set));          final Queue<String> buf = new CircularFifoQueue<>(set);         assertEquals(3, CollectionUtils.maxSize(buf));         buf.remove("2");         assertEquals(3, CollectionUtils.maxSize(buf));         buf.add("2");         assertEquals(3, CollectionUtils.maxSize(buf));     }      @Test(expected = NullPointerException.class)     public void testMaxSizeNullColl() {         CollectionUtils.maxSize(null);     }      @Test     public void intersectionUsesMethodEquals() {         // Let elta and eltb be objects...         final Integer elta = 17;         final Integer eltb = 17;          // ...which are the same (==)         assertSame(elta, eltb);          // Let cola and colb be collections...         final Collection<Number> cola = new ArrayList<>();         final Collection<Integer> colb = new ArrayList<>();          // ...which contain elta and eltb,         // respectively.         cola.add(elta);         colb.add(eltb);          // Then the intersection of the two         // should contain one element.         final Collection<Number> intersection = CollectionUtils.intersection(cola, colb);         assertEquals(1, intersection.size());          // In practice, this element will be the same (==) as elta         // or eltb, although this isn't strictly part of the         // contract.         final Object eltc = intersection.iterator().next();         assertTrue(eltc == elta && eltc == eltb);          // In any event, this element remains equal,         // to both elta and eltb.         assertEquals(elta, eltc);         assertEquals(eltc, elta);         assertEquals(eltb, eltc);         assertEquals(eltc, eltb);     }      // -----------------------------------------------------------------------     //Up to here     @Test     public void testRetainAll() {         final List<String> base = new ArrayList<>();         base.add("A");         base.add("B");         base.add("C");         final List<Object> sub = new ArrayList<>();         sub.add("A");         sub.add("C");         sub.add("X");          final Collection<String> result = CollectionUtils.retainAll(base, sub);         assertEquals(2, result.size());         assertTrue(result.contains("A"));         assertFalse(result.contains("B"));         assertTrue(result.contains("C"));         assertEquals(3, base.size());         assertTrue(base.contains("A"));         assertTrue(base.contains("B"));         assertTrue(base.contains("C"));         assertEquals(3, sub.size());         assertTrue(sub.contains("A"));         assertTrue(sub.contains("C"));         assertTrue(sub.contains("X"));     }      @Test(expected = NullPointerException.class)     public void testRetainAllNullBaseColl() {         final List<Object> sub = new ArrayList<>();         sub.add("A");         CollectionUtils.retainAll(null, sub);     }      @Test(expected = NullPointerException.class)     public void testRetainAllNullSubColl() {         final List<String> base = new ArrayList<>();         base.add("A");         CollectionUtils.retainAll(base, null);     }      @Test     public void testRemoveRange() {         final List<Integer> list = new ArrayList<>();         list.add(1);         Collection<Integer> result = CollectionUtils.removeRange(list, 0, 0);         assertEquals(1, list.size());         assertEquals(0, result.size());          list.add(2);         list.add(3);         result = CollectionUtils.removeRange(list, 1, 3);         assertEquals(1, list.size());         assertEquals(1, (int) list.get(0));         assertEquals(2, result.size());         assertTrue(result.contains(2));         assertTrue(result.contains(3));     }      @Test(expected=NullPointerException.class)     public void testRemoveRangeNull() {         final Collection<Integer> list = null;         CollectionUtils.removeRange(list, 0, 0);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveRangeStartIndexNegative() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeRange(list, -1, 1);     }      @Test(expected=IllegalArgumentException.class)     public void testRemoveRangeEndIndexNegative() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeRange(list, 0, -1);     }      @Test(expected=IllegalArgumentException.class)     public void testRemoveRangeEndLowStart() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         CollectionUtils.removeRange(list, 1, 0);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveRangeWrongEndIndex() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeRange(list, 0, 2);     }      @Test     public void testRemoveCount() {         final List<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);          Collection<Integer> result = CollectionUtils.removeCount(list, 0, 0);         assertEquals(4, list.size());         assertEquals(0, result.size());          result = CollectionUtils.removeCount(list, 0, 1);         assertEquals(3, list.size());         assertEquals(2, (int) list.get(0));         assertEquals(1, result.size());         assertTrue(result.contains(1));          list.add(5);         list.add(6);         result = CollectionUtils.removeCount(list, 1, 3);          assertEquals(2, list.size());         assertEquals(2, (int) list.get(0));         assertEquals(6, (int) list.get(1));         assertEquals(3, result.size());         assertTrue(result.contains(3));         assertTrue(result.contains(4));         assertTrue(result.contains(5));     }      @Test(expected=NullPointerException.class)     public void testRemoveCountWithNull() {         final Collection<Integer> list = null;         CollectionUtils.removeCount(list, 0, 1);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveCountStartNegative() {         final Collection<Integer> list = new ArrayList<>();         CollectionUtils.removeCount(list, -1, 1);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveCountNegative() {         final Collection<Integer> list = new ArrayList<>();         CollectionUtils.removeCount(list, 0, -1);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveCountWrongCount() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeCount(list, 0, 2);     }      @Test     public void testRemoveAll() {         final List<String> base = new ArrayList<>();         base.add("A");         base.add("B");         base.add("C");         final List<String> sub = new ArrayList<>();         sub.add("A");         sub.add("C");         sub.add("X");          final Collection<String> result = CollectionUtils.removeAll(base, sub);         assertEquals(1, result.size());         assertFalse(result.contains("A"));         assertTrue(result.contains("B"));         assertFalse(result.contains("C"));         assertEquals(3, base.size());         assertTrue(base.contains("A"));         assertTrue(base.contains("B"));         assertTrue(base.contains("C"));         assertEquals(3, sub.size());         assertTrue(sub.contains("A"));         assertTrue(sub.contains("C"));         assertTrue(sub.contains("X"));     }      @Test(expected = NullPointerException.class)     public void testRemoveAllNullBaseColl() {         final List<String> sub = new ArrayList<>();         sub.add("A");         CollectionUtils.removeAll(null, sub);     }      @Test(expected = NullPointerException.class)     public void testRemoveAllNullSubColl() {         final List<String> base = new ArrayList<>();         base.add("A");         CollectionUtils.removeAll(base, null);     }      // -----------------------------------------------------------------------     @Test     public void testTransformedCollection() {         final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();         final Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<>(), transformer);         assertTrue("returned object should be a TransformedCollection", collection instanceof TransformedCollection);     }      @Test(expected = NullPointerException.class)     public void testTransformingCollectionNullColl() {         final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();         CollectionUtils.transformingCollection(null, transformer);     }      @Test(expected = NullPointerException.class)     public void testTransformingCollectionNullTransformer() {         final List<String> list = new ArrayList<>();         CollectionUtils.transformingCollection(list, null);     }      @Test     public void testTransformedCollection_2() {         final List<Object> list = new ArrayList<>();         list.add("1");         list.add("2");         list.add("3");         final Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);         assertTrue(result.contains("1")); // untransformed         assertTrue(result.contains("2")); // untransformed         assertTrue(result.contains("3")); // untransformed     }      @Test     @Deprecated     public void testSynchronizedCollection() {         final Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<>());         assertTrue("Returned object should be a SynchronizedCollection.", col instanceof SynchronizedCollection);         try {             CollectionUtils.synchronizedCollection(null);             fail("Expecting NullPointerException for null collection.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     @Deprecated     public void testUnmodifiableCollection() {         final Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<>());         assertTrue("Returned object should be a UnmodifiableCollection.", col instanceof UnmodifiableCollection);         try {             CollectionUtils.unmodifiableCollection(null);             fail("Expecting NullPointerException for null collection.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void emptyCollection() throws Exception {         final Collection<Number> coll = CollectionUtils.emptyCollection();         assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);     }      @Test     public void emptyIfNull() {         assertTrue(CollectionUtils.emptyIfNull(null).isEmpty());         final Collection<Object> collection = new ArrayList<>();         assertSame(collection, CollectionUtils.emptyIfNull(collection));     }      /**      * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.      * Specifically, it uses mocks to ensure that if the passed in      * {@link Iterable} is a {@link Collection} then      * {@link Collection#addAll(Collection)} is called instead of iterating.      */     @Test     public void addAllForIterable() {         final Collection<Integer> inputCollection = createMock(Collection.class);         final Iterable<Integer> inputIterable = inputCollection;         final Iterable<Long> iterable = createMock(Iterable.class);         final Iterator<Long> iterator = createMock(Iterator.class);         final Collection<Number> c = createMock(Collection.class);          expect(iterable.iterator()).andReturn(iterator);         next(iterator, 1L);         next(iterator, 2L);         next(iterator, 3L);         expect(iterator.hasNext()).andReturn(false);         expect(c.add(1L)).andReturn(true);         expect(c.add(2L)).andReturn(true);         expect(c.add(3L)).andReturn(true);         // Check that the collection is added using         // Collection.addAll(Collection)         expect(c.addAll(inputCollection)).andReturn(true);          // Ensure the method returns false if nothing is added         expect(iterable.iterator()).andReturn(iterator);         next(iterator, 1L);         expect(iterator.hasNext()).andReturn(false);         expect(c.add(1L)).andReturn(false);         expect(c.addAll(inputCollection)).andReturn(false);          replay();         assertTrue(CollectionUtils.addAll(c, iterable));         assertTrue(CollectionUtils.addAll(c, inputIterable));          assertFalse(CollectionUtils.addAll(c, iterable));         assertFalse(CollectionUtils.addAll(c, inputIterable));         verify();     }      @Test     public void addAllForEnumeration() {         final Hashtable<Integer, Integer> h = new Hashtable<>();         h.put(5, 5);         final Enumeration<? extends Integer> enumeration = h.keys();         CollectionUtils.addAll(collectionA, enumeration);         assertTrue(collectionA.contains(5));     }      @Test     public void addAllForElements() {         CollectionUtils.addAll(collectionA, 5);         assertTrue(collectionA.contains(5));     }      @Test(expected = NullPointerException.class)     public void testaddAllNullColl1() {         final List<Integer> list = new ArrayList<>();         CollectionUtils.addAll(null, list);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl2() {         final List<Integer> list = new ArrayList<>();         final Iterable<Integer> list2 = null;         CollectionUtils.addAll(list, list2);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl3() {         final List<Integer> list = new ArrayList<>();         final Iterator<Integer> list2 = null;         CollectionUtils.addAll(list, list2);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl4() {         final List<Integer> list = new ArrayList<>();         final Enumeration<Integer> enumArray = null;         CollectionUtils.addAll(list, enumArray);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl5() {         final List<Integer> list = new ArrayList<>();         final Integer[] array = null;         CollectionUtils.addAll(list, array);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getNegative() {         CollectionUtils.get((Object) collectionA, -3);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getPositiveOutOfBounds() {         CollectionUtils.get((Object) collectionA.iterator(), 30);     }      @Test(expected = IllegalArgumentException.class)     public void get1() {         CollectionUtils.get((Object) null, 0);     }      @Test     public void get() {         assertEquals(2, CollectionUtils.get((Object) collectionA, 2));         assertEquals(2, CollectionUtils.get((Object) collectionA.iterator(), 2));         final Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);         assertEquals(map.entrySet().iterator().next(), CollectionUtils.get((Object) map, 0));     }      @Test     public void getIterator() {         final Iterator<Integer> it = collectionA.iterator();         assertEquals(Integer.valueOf(2), CollectionUtils.get((Object) it, 2));         assertTrue(it.hasNext());         assertEquals(Integer.valueOf(4), CollectionUtils.get((Object) it, 6));         assertFalse(it.hasNext());     }      @Test     public void getEnumeration() {         final Vector<Integer> vectorA = new Vector<>(collectionA);         final Enumeration<Integer> e = vectorA.elements();         assertEquals(Integer.valueOf(2), CollectionUtils.get(e, 2));         assertTrue(e.hasMoreElements());         assertEquals(Integer.valueOf(4), CollectionUtils.get(e, 6));         assertFalse(e.hasMoreElements());     }      @Test     public void reverse() {         CollectionUtils.reverseArray(new Object[] {});         final Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);         CollectionUtils.reverseArray(a);         // assume our implementation is correct if it returns the same order as the Java function         Collections.reverse(collectionA);         assertEquals(collectionA, Arrays.asList(a));     }      @Test(expected = NullPointerException.class)     public void testReverseArrayNull() {         CollectionUtils.reverseArray(null);     }      @Test     public void extractSingleton() {         ArrayList<String> coll = null;         try {             CollectionUtils.extractSingleton(coll);             fail("expected NullPointerException from extractSingleton(null)");         } catch (final NullPointerException e) {         }         coll = new ArrayList<>();         try {             CollectionUtils.extractSingleton(coll);             fail("expected IllegalArgumentException from extractSingleton(empty)");         } catch (final IllegalArgumentException e) {         }         coll.add("foo");         assertEquals("foo", CollectionUtils.extractSingleton(coll));         coll.add("bar");         try {             CollectionUtils.extractSingleton(coll);             fail("expected IllegalArgumentException from extractSingleton(size == 2)");         } catch (final IllegalArgumentException e) {         }     }      /**      * Records the next object returned for a mock iterator      */     private <T> void next(final Iterator<T> iterator, final T t) {         expect(iterator.hasNext()).andReturn(true);         expect(iterator.next()).andReturn(t);     }      @Test(expected=NullPointerException.class)     public void collateException0() {         CollectionUtils.collate(null, collectionC);     }      @Test(expected=NullPointerException.class)     public void collateException1() {         CollectionUtils.collate(collectionA, null);     }      @Test(expected=NullPointerException.class)     public void collateException2() {         CollectionUtils.collate(collectionA, collectionC, null);     }      @Test     public void testCollate() {         List<Integer> result = CollectionUtils.collate(emptyCollection, emptyCollection);         assertEquals("Merge empty with empty", 0, result.size());          result = CollectionUtils.collate(collectionA, emptyCollection);         assertEquals("Merge empty with non-empty", collectionA, result);          List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE);         List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD);         assertEquals("Merge two lists 1", result1, result2);          final List<Integer> combinedList = new ArrayList<>(collectionD);         combinedList.addAll(collectionE);         Collections.sort(combinedList);          assertEquals("Merge two lists 2", combinedList, result2);          final Comparator<Integer> reverseComparator =                 ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());          result = CollectionUtils.collate(emptyCollection, emptyCollection, reverseComparator);         assertEquals("Comparator Merge empty with empty", 0, result.size());          Collections.reverse((List<Integer>) collectionD);         Collections.reverse((List<Integer>) collectionE);         Collections.reverse(combinedList);          result1 = CollectionUtils.collate(collectionD, collectionE, reverseComparator);         result2 = CollectionUtils.collate(collectionE, collectionD, reverseComparator);         assertEquals("Comparator Merge two lists 1", result1, result2);         assertEquals("Comparator Merge two lists 2", combinedList, result2);     }      @Test     public void testCollateIgnoreDuplicates() {         final List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE, false);         final List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD, false);         assertEquals("Merge two lists 1 - ignore duplicates", result1, result2);          final Set<Integer> combinedSet = new HashSet<>(collectionD);         combinedSet.addAll(collectionE);         final List<Integer> combinedList = new ArrayList<>(combinedSet);         Collections.sort(combinedList);          assertEquals("Merge two lists 2 - ignore duplicates", combinedList, result2);     }      @Test(expected=NullPointerException.class)     public void testPermutationsWithNullCollection() {         CollectionUtils.permutations(null);     }      @Test     public void testPermutations() {         final List<Integer> sample = collectionA.subList(0, 5);         final Collection<List<Integer>> permutations = CollectionUtils.permutations(sample);          // result size = n!         final int collSize = sample.size();         int factorial = 1;         for (int i = 1; i <= collSize; i++) {             factorial *= i;         }         assertEquals(factorial, permutations.size());     }      @Test     @Deprecated     public void testMatchesAll() {         assertFalse(CollectionUtils.matchesAll(null, null));         assertFalse(CollectionUtils.matchesAll(collectionA, null));          final Predicate<Integer> lessThanFive = object -> object < 5;         assertTrue(CollectionUtils.matchesAll(collectionA, lessThanFive));          final Predicate<Integer> lessThanFour = object -> object < 4;         assertFalse(CollectionUtils.matchesAll(collectionA, lessThanFour));          assertTrue(CollectionUtils.matchesAll(null, lessThanFour));         assertTrue(CollectionUtils.matchesAll(emptyCollection, lessThanFour));     }      @Test     public void testRemoveAllWithEquator() {         final List<String> base = new ArrayList<>();         base.add("AC");         base.add("BB");         base.add("CA");          final List<String> remove = new ArrayList<>();         remove.add("AA");         remove.add("CX");         remove.add("XZ");          // use an equator which compares the second letter only         final Collection<String> result = CollectionUtils.removeAll(base, remove, new Equator<String>() {              @Override             public boolean equate(final String o1, final String o2) {                 return o1.charAt(1) == o2.charAt(1);             }              @Override             public int hash(final String o) {                 return o.charAt(1);             }         });          assertEquals(2, result.size());         assertTrue(result.contains("AC"));         assertTrue(result.contains("BB"));         assertFalse(result.contains("CA"));         assertEquals(3, base.size());         assertTrue(base.contains("AC"));         assertTrue(base.contains("BB"));         assertTrue(base.contains("CA"));         assertEquals(3, remove.size());         assertTrue(remove.contains("AA"));         assertTrue(remove.contains("CX"));         assertTrue(remove.contains("XZ"));          try {             CollectionUtils.removeAll(null, null, DefaultEquator.defaultEquator());             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want          try {             CollectionUtils.removeAll(base, remove, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want     }      @Test     public void testRetainAllWithEquator() {         final List<String> base = new ArrayList<>();         base.add("AC");         base.add("BB");         base.add("CA");          final List<String> retain = new ArrayList<>();         retain.add("AA");         retain.add("CX");         retain.add("XZ");          // use an equator which compares the second letter only         final Collection<String> result = CollectionUtils.retainAll(base, retain, new Equator<String>() {              @Override             public boolean equate(final String o1, final String o2) {                 return o1.charAt(1) == o2.charAt(1);             }              @Override             public int hash(final String o) {                 return o.charAt(1);             }         });         assertEquals(1, result.size());         assertTrue(result.contains("CA"));         assertFalse(result.contains("BB"));         assertFalse(result.contains("AC"));          assertEquals(3, base.size());         assertTrue(base.contains("AC"));         assertTrue(base.contains("BB"));         assertTrue(base.contains("CA"));          assertEquals(3, retain.size());         assertTrue(retain.contains("AA"));         assertTrue(retain.contains("CX"));         assertTrue(retain.contains("XZ"));          try {             CollectionUtils.retainAll(null, null, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want          try {             CollectionUtils.retainAll(base, retain, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.List;  import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.list.PredicatedList; import org.junit.Before; import org.junit.Test;  /**  * Tests for ListUtils.  *  */ public class ListUtilsTest {      private static final String a = "a";     private static final String b = "b";     private static final String c = "c";     private static final String d = "d";     private static final String e = "e";     private static final String x = "x";      private String[] fullArray;     private List<String> fullList;      @Before     public void setUp() {         fullArray = new String[]{a, b, c, d, e};         fullList = new ArrayList<>(Arrays.asList(fullArray));     }      /**      * Tests intersecting a non-empty list with an empty list.      */     @Test     public void testIntersectNonEmptyWithEmptyList() {         final List<String> empty = Collections.<String>emptyList();         assertTrue("result not empty", ListUtils.intersection(empty, fullList).isEmpty());     }      /**      * Tests intersecting a non-empty list with an empty list.      */     @Test     public void testIntersectEmptyWithEmptyList() {         final List<?> empty = Collections.EMPTY_LIST;         assertTrue("result not empty", ListUtils.intersection(empty, empty).isEmpty());     }      /**      * Tests intersecting a non-empty list with an subset of itself.      */     @Test     public void testIntersectNonEmptySubset() {         // create a copy         final List<String> other = new ArrayList<>(fullList);          // remove a few items         assertNotNull(other.remove(0));         assertNotNull(other.remove(1));          // make sure the intersection is equal to the copy         assertEquals(other, ListUtils.intersection(fullList, other));     }      /**      * Tests intersecting a non-empty list with an subset of itself.      */     @Test     public void testIntersectListWithNoOverlapAndDifferentTypes() {         @SuppressWarnings("boxing")         final List<Integer> other = Arrays.asList(1, 23);         assertTrue(ListUtils.intersection(fullList, other).isEmpty());     }      /**      * Tests intersecting a non-empty list with itself.      */     @Test     public void testIntersectListWithSelf() {         assertEquals(fullList, ListUtils.intersection(fullList, fullList));     }      /**      * Tests intersecting two lists in different orders.      */     @Test     public void testIntersectionOrderInsensitivity() {         final List<String> one = new ArrayList<>();         final List<String> two = new ArrayList<>();         one.add("a");         one.add("b");         two.add("a");         two.add("a");         two.add("b");         two.add("b");         assertEquals(ListUtils.intersection(one, two), ListUtils.intersection(two, one));     }      @Test     public void testPredicatedList() {         final Predicate<Object> predicate = o -> o instanceof String;         final List<Object> list = ListUtils.predicatedList(new ArrayList<>(), predicate);         assertTrue("returned object should be a PredicatedList", list instanceof PredicatedList);         try {             ListUtils.predicatedList(new ArrayList<>(), null);             fail("Expecting IllegalArgumentException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }         try {             ListUtils.predicatedList(null, predicate);             fail("Expecting IllegalArgumentException for null list.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testLazyFactoryList() {         final List<Integer> list = ListUtils.lazyList(new ArrayList<Integer>(), new Factory<Integer>() {              private int index;              @Override             public Integer create() {                 index++;                 return Integer.valueOf(index);             }         });          assertNotNull(list.get(5));         assertEquals(6, list.size());          assertNotNull(list.get(5));         assertEquals(6, list.size());     }      @Test     public void testLazyTransformerList() {         final List<Integer> offsets = Arrays.asList(3, 5, 1, 5, 3, 6);         final List<Integer> list = ListUtils.lazyList(new ArrayList<>(), new Transformer<Integer, Integer>() {              private int index;              @Override             public Integer transform(final Integer input) {                 return offsets.get(input) + index++;             }          });          assertNotNull(list.get(5));         assertEquals(6, list.size());          assertNotNull(list.get(5));         assertEquals(6, list.size());     }      @Test     public void testEmptyIfNull() {         assertTrue(ListUtils.emptyIfNull(null).isEmpty());          final List<Long> list = new ArrayList<>();         assertSame(list, ListUtils.emptyIfNull(list));     }      @Test     public void testDefaultIfNull() {         assertTrue(ListUtils.defaultIfNull(null, Collections.emptyList()).isEmpty());          final List<Long> list = new ArrayList<>();         assertSame(list, ListUtils.defaultIfNull(list, Collections.<Long>emptyList()));     }      @Test     public void testEquals() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final List<String> a = new ArrayList<>( data );         final List<String> b = new ArrayList<>( data );          assertEquals(a, b);         assertTrue(ListUtils.isEqualList(a, b));         a.clear();         assertFalse(ListUtils.isEqualList(a, b));         assertFalse(ListUtils.isEqualList(a, null));         assertFalse(ListUtils.isEqualList(null, b));         assertTrue(ListUtils.isEqualList(null, null));     }      @Test     public void testHashCode() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final List<String> a = new ArrayList<>(data);         final List<String> b = new ArrayList<>(data);          assertEquals(a.hashCode(), b.hashCode());         assertEquals(a.hashCode(), ListUtils.hashCodeForList(a));         assertEquals(b.hashCode(), ListUtils.hashCodeForList(b));         assertEquals(ListUtils.hashCodeForList(a), ListUtils.hashCodeForList(b));         a.clear();         assertNotEquals(ListUtils.hashCodeForList(a), ListUtils.hashCodeForList(b));         assertEquals(0, ListUtils.hashCodeForList(null));     }      @Test     public void testRetainAll() {         final List<String> sub = new ArrayList<>();         sub.add(a);         sub.add(b);         sub.add(x);          final List<String> retained = ListUtils.retainAll(fullList, sub);         assertEquals(2, retained.size());         sub.remove(x);         assertEquals(retained, sub);         fullList.retainAll(sub);         assertEquals(retained, fullList);          try {             ListUtils.retainAll(null, null);             fail("expecting NullPointerException");         } catch(final NullPointerException npe){} // this is what we want     }      @Test     public void testRemoveAll() {         final List<String> sub = new ArrayList<>();         sub.add(a);         sub.add(b);         sub.add(x);          final List<String> remainder = ListUtils.removeAll(fullList, sub);         assertEquals(3, remainder.size());         fullList.removeAll(sub);         assertEquals(remainder, fullList);          try {             ListUtils.removeAll(null, null);             fail("expecting NullPointerException");         } catch(final NullPointerException npe) {} // this is what we want     }      @Test     public void testSubtract() {         final List<String> list = new ArrayList<>();         list.add(a);         list.add(b);         list.add(a);         list.add(x);          final List<String> sub = new ArrayList<>();         sub.add(a);          final List<String> result = ListUtils.subtract(list, sub);         assertEquals(3, result.size());          final List<String> expected = new ArrayList<>();         expected.add(b);         expected.add(a);         expected.add(x);          assertEquals(expected, result);          try {             ListUtils.subtract(list, null);             fail("expecting NullPointerException");         } catch(final NullPointerException npe) {} // this is what we want     }      @Test     public void testSubtractNullElement() {         final List<String> list = new ArrayList<>();         list.add(a);         list.add(null);         list.add(null);         list.add(x);          final List<String> sub = new ArrayList<>();         sub.add(null);          final List<String> result = ListUtils.subtract(list, sub);         assertEquals(3, result.size());          final List<String> expected = new ArrayList<>();         expected.add(a);         expected.add(null);         expected.add(x);          assertEquals(expected, result);     }      /**      * Tests the {@code indexOf} method in {@code ListUtils} class..      */     @Test     public void testIndexOf() {         Predicate<String> testPredicate = EqualPredicate.equalPredicate("d");         int index = ListUtils.indexOf(fullList, testPredicate);         assertEquals(d, fullList.get(index));          testPredicate = EqualPredicate.equalPredicate("de");         index = ListUtils.indexOf(fullList, testPredicate);         assertEquals(index, -1);          assertEquals(ListUtils.indexOf(null, testPredicate), -1);         assertEquals(ListUtils.indexOf(fullList, null), -1);     }      @Test     @SuppressWarnings("boxing") // OK in test code     public void testLongestCommonSubsequence() {          try {             ListUtils.longestCommonSubsequence((List<?>) null, null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence(Arrays.asList('A'), null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence(null, Arrays.asList('A'));             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          @SuppressWarnings("unchecked")         List<Character> lcs = ListUtils.longestCommonSubsequence(Collections.EMPTY_LIST, Collections.EMPTY_LIST);         assertEquals(0, lcs.size());          final List<Character> list1 = Arrays.asList('B', 'A', 'N', 'A', 'N', 'A');         final List<Character> list2 = Arrays.asList('A', 'N', 'A', 'N', 'A', 'S');         lcs = ListUtils.longestCommonSubsequence(list1, list2);          List<Character> expected = Arrays.asList('A', 'N', 'A', 'N', 'A');         assertEquals(expected, lcs);          final List<Character> list3 = Arrays.asList('A', 'T', 'A', 'N', 'A');         lcs = ListUtils.longestCommonSubsequence(list1, list3);          expected = Arrays.asList('A', 'A', 'N', 'A');         assertEquals(expected, lcs);          final List<Character> listZorro = Arrays.asList('Z', 'O', 'R', 'R', 'O');         lcs = ListUtils.longestCommonSubsequence(list1, listZorro);          assertTrue(lcs.isEmpty());     }      @Test     public void testLongestCommonSubsequenceWithString() {          try {             ListUtils.longestCommonSubsequence((String) null, null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence("A", null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence(null, "A");             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          String lcs = ListUtils.longestCommonSubsequence("", "");         assertEquals(0, lcs.length());          final String banana = "BANANA";         final String ananas = "ANANAS";         lcs = ListUtils.longestCommonSubsequence(banana, ananas);          assertEquals("ANANA", lcs);          final String atana = "ATANA";         lcs = ListUtils.longestCommonSubsequence(banana, atana);          assertEquals("AANA", lcs);          final String zorro = "ZORRO";         lcs = ListUtils.longestCommonSubsequence(banana, zorro);          assertEquals(0, lcs.length());     }      @Test     @SuppressWarnings("boxing") // OK in test code     public void testPartition() {         final List<Integer> strings = new ArrayList<>();         for (int i = 0; i <= 6; i++) {             strings.add(i);         }          final List<List<Integer>> partition = ListUtils.partition(strings, 3);          assertNotNull(partition);         assertEquals(3, partition.size());         assertEquals(1, partition.get(2).size());          try {             ListUtils.partition(null, 3);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.partition(strings, 0);             fail("failed to check for size argument");         } catch (final IllegalArgumentException e) {}          try {             ListUtils.partition(strings, -10);             fail("failed to check for size argument");         } catch (final IllegalArgumentException e) {}          final List<List<Integer>> partitionMax = ListUtils.partition(strings, Integer.MAX_VALUE);         assertEquals(1, partitionMax.size());         assertEquals(strings.size(), partitionMax.get(0).size());         assertEquals(strings, partitionMax.get(0));     }      private static Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;      @Test     @SuppressWarnings("boxing") // OK in test code     public void testSelect() {         final List<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         // Ensure that the collection is the input type or a super type         final List<Integer> output1 = ListUtils.select(list, EQUALS_TWO);         final List<Number> output2 = ListUtils.<Number>select(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(1, output1.size());         assertEquals(2, output2.iterator().next());     }      @Test     @SuppressWarnings("boxing") // OK in test code     public void testSelectRejected() {         final List<Long> list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         list.add(4L);         final List<Long> output1 = ListUtils.selectRejected(list, EQUALS_TWO);         final List<? extends Number> output2 = ListUtils.selectRejected(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output2));         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(3, output1.size());         assertTrue(output1.contains(1L));         assertTrue(output1.contains(3L));         assertTrue(output1.contains(4L));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.functors.NOPTransformer; import org.apache.commons.collections4.map.HashedMap; import org.apache.commons.collections4.splitmap.TransformedSplitMap; import org.junit.Before; import org.junit.Test;  /**  * Tests for {@link TransformedSplitMap}  *  * @since 4.0  */ @SuppressWarnings("boxing") public class SplitMapUtilsTest {     private Map<String, Integer> backingMap;     private TransformedSplitMap<String, String, String, Integer> transformedMap;      private final Transformer<String, Integer> stringToInt = Integer::valueOf;      @Before     public void setUp() throws Exception {         backingMap = new HashMap<>();         transformedMap = TransformedSplitMap.transformingMap(backingMap, NOPTransformer.<String>nopTransformer(),                 stringToInt);         for (int i = 0; i < 10; i++) {             transformedMap.put(String.valueOf(i), String.valueOf(i));         }     }      // -----------------------------------------------------------------------      @Test     public void testReadableMap() {         final IterableMap<String, Integer> map = SplitMapUtils.readableMap(transformedMap);          // basic         for (int i = 0; i < 10; i++) {             assertFalse(map.containsValue(String.valueOf(i)));             assertEquals(i, map.get(String.valueOf(i)).intValue());         }          // mapIterator         final MapIterator<String, Integer> it = map.mapIterator();         while (it.hasNext()) {             final String k = it.next();             assertEquals(k, it.getKey());             assertEquals(Integer.valueOf(k), it.getValue());         }          // unmodifiable         assertTrue(map instanceof Unmodifiable);          // check individual operations         int sz = map.size();          attemptPutOperation(() -> map.clear());          assertEquals(sz, map.size());          attemptPutOperation(() -> map.put("foo", 100));          final HashMap<String, Integer> m = new HashMap<>();         m.put("foo", 100);         m.put("bar", 200);         m.put("baz", 300);         attemptPutOperation(() -> map.putAll(m));          // equals, hashcode         final IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);         assertEquals(other, map);         assertEquals(other.hashCode(), map.hashCode());          // remove         for (int i = 0; i < 10; i++) {             assertEquals(i, map.remove(String.valueOf(i)).intValue());             assertEquals(--sz, map.size());         }         assertTrue(map.isEmpty());         assertSame(map, SplitMapUtils.readableMap(map));     }      @Test     public void testAlreadyReadableMap() {         final HashedMap<String, Integer> hashedMap = new HashedMap<>();         assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));     }      @Test     @SuppressWarnings("unchecked")     public void testWritableMap() {         final Map<String, String> map = SplitMapUtils.writableMap(transformedMap);         attemptGetOperation(() -> map.get(null));         attemptGetOperation(() -> map.entrySet());         attemptGetOperation(() -> map.keySet());         attemptGetOperation(() -> map.values());         attemptGetOperation(() -> map.size());         attemptGetOperation(() -> map.isEmpty());         attemptGetOperation(() -> map.containsKey(null));         attemptGetOperation(() -> map.containsValue(null));         attemptGetOperation(() -> map.remove(null));          // equals, hashcode         final Map<String, String> other = SplitMapUtils.writableMap(transformedMap);         assertEquals(other, map);         assertEquals(other.hashCode(), map.hashCode());          // put         int sz = backingMap.size();         assertFalse(backingMap.containsKey("foo"));         map.put("new", "66");         assertEquals(++sz, backingMap.size());          // putall         final Map<String, String> more = new HashMap<>();         more.put("foo", "77");         more.put("bar", "88");         more.put("baz", "99");         map.putAll(more);         assertEquals(sz + more.size(), backingMap.size());          // clear         map.clear();         assertTrue(backingMap.isEmpty());         assertSame(map, SplitMapUtils.writableMap((Put<String, String>) map));     }      @Test     public void testAlreadyWritableMap() {         final HashedMap<String, String> hashedMap = new HashedMap<>();         assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));     }      private void attemptGetOperation(final Runnable r) {         attemptMapOperation("Put exposed as writable Map must not allow Get operations", r);     }      private void attemptPutOperation(final Runnable r) {         attemptMapOperation("Get exposed as writable Map must not allow Put operations", r);     }      private void attemptMapOperation(final String s, final Runnable r) {         try {             r.run();             fail(s);         } catch (final UnsupportedOperationException e) {         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.junit;  import java.util.Locale;  import org.junit.rules.TestRule; import org.junit.runner.Description; import org.junit.runners.model.Statement;  /**  * Sets the default {@code Locale} to the given locale for the duration of the test.  */ public class SetDefaultLocaleTestRule implements TestRule {      private final Locale locale;      public SetDefaultLocaleTestRule(final Locale locale) {         this.locale = locale;     }      @Override     public Statement apply(final Statement base, final Description description) {         return new Statement() {             @Override             public void evaluate() throws Throwable {                 final Locale savedLocale = Locale.getDefault();                 Locale.setDefault(getLocale());                 try {                     base.evaluate();                 } finally {                     Locale.setDefault(savedLocale);                 }             }         };     }      public Locale getLocale() {         return locale;     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.junit;  import java.io.Serializable; import java.util.Comparator;  public final class ObjectToStringComparator implements Comparator<Object>, Serializable {      private static final long serialVersionUID = 1L;      @Override     public int compare(final Object o1, final Object o2) {         if (o1 == null && o2 == null) {             return 0;         }         if (o1 == null) {             return 1;         }         if (o2 == null) {             return -1;         }         return o1.toString().compareTo(o2.toString());     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.junit;  import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.Locale;  import org.apache.commons.lang3.reflect.FieldUtils; import org.junit.Rule; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  @RunWith(Parameterized.class) public abstract class AbstractAvailableLocalesTest {  //    public static List<Object[]> combine(final Object[] objects, final List<Locale> locales) { //        final List<Object[]> result = new ArrayList<>(objects.length * locales.size()); //        Arrays.stream(objects).forEachOrdered(object -> locales.stream().forEachOrdered(locale -> result.add(new Object[] { object, locale }))); //        return result; //    } // //    public static List<Object[]> combine(final Object[] objects, final Locale[] locales) { //        final List<Object[]> result = new ArrayList<>(objects.length * locales.length); //        Arrays.stream(objects).forEachOrdered(object -> Arrays.stream(locales).forEachOrdered(locale -> result.add(new Object[] { object, locale }))); //        return result; //    }  //    public static List<Object[]> combineAvailableLocales(final Object[] objects) { //        return combine(objects, getSortedAvailableLocales()); //    } // //    public static List<Object[]> combineDeclaredLocales(final Object[] objects) { //        return combine(objects, getSortedDeclaredLocales()); //    }      @Parameters(name = "{0}")     public static Locale[] getSortedAvailableLocales() {         final Locale[] availableLocales = Locale.getAvailableLocales();         Arrays.sort(availableLocales, new ObjectToStringComparator());         return availableLocales;     }      public static List<Locale> getSortedDeclaredLocales() {         final Field[] allFields = FieldUtils.getAllFields(Locale.class);         final List<Locale> availableLocales = new ArrayList<>(allFields.length);         for (final Field field : allFields) {             final int modifiers = field.getModifiers();             if (field.getType() == Locale.class && Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {                 try {                     availableLocales.add((Locale) field.get(Locale.class));                 } catch (IllegalArgumentException | IllegalAccessException e) {                     throw new IllegalStateException("Field " + field, e);                 }             }         }         Collections.sort(availableLocales, new ObjectToStringComparator());         return availableLocales;     }      private final Locale locale;      @Rule     public final SetDefaultLocaleTestRule rule;      public AbstractAvailableLocalesTest(final Locale locale)  {         this.locale = locale;         this.rule = new SetDefaultLocaleTestRule(locale);     }      public Locale getLocale() {         return locale;     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link SynchronizedCollection} implementation.  *  * @since 3.1  */ public class SynchronizedCollectionTest<E> extends AbstractCollectionTest<E> {      public SynchronizedCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<E> makeObject() {         return SynchronizedCollection.synchronizedCollection(new ArrayList<E>());     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SynchronizedCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SynchronizedCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link PredicatedCollection} implementation.  *  * @since 3.0  */ public class PredicatedCollectionTest<E> extends AbstractCollectionTest<E> {      public PredicatedCollectionTest(final String name) {         super(name);     }     //------------------------------------------------------------------------     protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected Collection<E> decorateCollection(                 final Collection<E> collection, final Predicate<E> predicate) {         return PredicatedCollection.predicatedCollection(collection, predicate);     }      @Override     public Collection<E> makeObject() {         return decorateCollection(new ArrayList<E>(), truePredicate);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };     }      @Override     public Collection<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return decorateCollection(list, truePredicate);     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      //-----------------------------------------------------------------------     protected Predicate<E> testPredicate =         o -> o instanceof String;      public Collection<E> makeTestCollection() {         return decorateCollection(new ArrayList<E>(), testPredicate);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final Collection<E> c = makeTestCollection();         final Integer i = 3;         try {             c.add((E) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertFalse("Collection shouldn't contain illegal element", c.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final Collection<E> c = makeTestCollection();         final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) Integer.valueOf(3));         elements.add((E) "four");         try {             c.addAll(elements);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertFalse("Collection shouldn't contain illegal element", c.contains("one"));         assertFalse("Collection shouldn't contain illegal element", c.contains("two"));         assertFalse("Collection shouldn't contain illegal element", c.contains(3));         assertFalse("Collection shouldn't contain illegal element", c.contains("four"));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;  import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableCollection} implementation.  *  * @since 3.0  */ public class UnmodifiableCollectionTest<E> extends AbstractCollectionTest<E> {      public UnmodifiableCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<E> makeObject() {         return UnmodifiableCollection.unmodifiableCollection(new ArrayList<E>());     }      @Override     public Collection<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return UnmodifiableCollection.unmodifiableCollection(list);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Collection<E> coll = makeFullCollection();         assertSame(coll, UnmodifiableCollection.unmodifiableCollection(coll));          try {             UnmodifiableCollection.unmodifiableCollection(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.function.Predicate;  import org.junit.Assert;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link CompositeCollection} implementation.  *  * @since 3.0  */ public class CompositeCollectionTest<E> extends AbstractCollectionTest<E> {      protected CompositeCollection<E> c;      protected Collection<E> one;      protected Collection<E> two;      public CompositeCollectionTest(final String name) {         super(name);     }      @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] { "1", "2", "3", "4" };     }      //-----------------------------------------------------------------------------     /**      * Run stock collection tests without Mutator, so turn off add, remove      */     @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public Collection<E> makeConfirmedCollection() {         return new HashSet<>();     }      //--------------------------------------------------------------------------      /**      * Full collection should look like a collection with 4 elements      */     @Override     public Collection<E> makeConfirmedFullCollection() {         return new HashSet<>(Arrays.asList(getFullElements()));     }     /**      * Full collection consists of 4 collections, each with one element      */     @Override     public Collection<E> makeFullCollection() {         final CompositeCollection<E> compositeCollection = new CompositeCollection<>();         final E[] elements = getFullElements();         for (final E element : elements) {             final Collection<E> summand = new HashSet<>();             summand.add(element);             compositeCollection.addComposited(summand);         }         return compositeCollection;     }     /**      * Empty collection is empty composite      */     @Override     public Collection<E> makeObject() {         return new CompositeCollection<>();     }      @SuppressWarnings("serial")     protected void setUpMutatorTest() {         setUpTest();         c.setMutator(new CompositeCollection.CollectionMutator<E>() {              @Override             public boolean add(final CompositeCollection<E> composite, final List<Collection<E>> collections, final E obj) {                 for (final Collection<E> coll : collections) {                     coll.add(obj);                 }                 return true;             }              @Override             public boolean addAll(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Collection<? extends E> coll) {                 for (final Collection<E> collection : collections) {                     collection.addAll(coll);                 }                 return true;             }              @Override             public boolean remove(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Object obj) {                 for (final Collection<E> collection : collections) {                     collection.remove(obj);                 }                 return true;             }         });     }      protected void setUpTest() {         c = new CompositeCollection<>();         one = new HashSet<>();         two = new HashSet<>();     }      @SuppressWarnings({ "unchecked", "serial" })     public void testAddAllMutator() {         setUpTest();         c.setMutator(new CompositeCollection.CollectionMutator<E>() {             @Override             public boolean add(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final E obj) {                 for (final Collection<E> collection : collections) {                     collection.add(obj);                 }                 return true;             }              @Override             public boolean addAll(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Collection<? extends E> coll) {                 for (final Collection<E> collection : collections) {                     collection.addAll(coll);                 }                 return true;             }              @Override             public boolean remove(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Object obj) {                 return false;             }         });          c.addComposited(one);         two.add((E) "foo");         c.addAll(two);         assertTrue(c.contains("foo"));         assertTrue(one.contains("foo"));     }      @SuppressWarnings("unchecked")     public void testAddAllToCollection() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one, two);         final Collection<E> toCollection = new HashSet<>(c);         assertTrue(toCollection.containsAll(c));         assertEquals(c.size(), toCollection.size());     }      @SuppressWarnings({ "unchecked", "serial" })     public void testAddMutator() {         setUpTest();         c.setMutator(new CompositeCollection.CollectionMutator<E>() {             @Override             public boolean add(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final E obj) {                 for (final Collection<E> collection : collections) {                     collection.add(obj);                 }                 return true;             }              @Override             public boolean addAll(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Collection<? extends E> coll) {                 for (final Collection<E> collection : collections) {                     collection.addAll(coll);                 }                 return true;             }              @Override             public boolean remove(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Object obj) {                 return false;             }         });          c.addComposited(one);         c.add((E) "foo");         assertTrue(c.contains("foo"));         assertTrue(one.contains("foo"));     }       @SuppressWarnings("unchecked")     public void testClear() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one, two);         c.clear();         assertTrue(one.isEmpty());         assertTrue(two.isEmpty());         assertTrue(c.isEmpty());     }      @SuppressWarnings("unchecked")     public void testContainsAll() {         setUpTest();         one.add((E) "1");         two.add((E) "1");         c.addComposited(one);         assertTrue(c.containsAll(two));         assertFalse(c.containsAll(null));     }      public void testAddNullList() {         final ArrayList<String> nullList = null;         final CompositeCollection<String> cc = new CompositeCollection<>();         cc.addComposited(nullList);         Assert.assertEquals(0, cc.size());     }      public void testAddNullLists2Args() {         final ArrayList<String> nullList = null;         final CompositeCollection<String> cc = new CompositeCollection<>();         cc.addComposited(nullList, nullList);         Assert.assertEquals(0, cc.size());     }      public void testAddNullListsVarArgs() {         final ArrayList<String> nullList = null;         final CompositeCollection<String> cc = new CompositeCollection<>();         cc.addComposited(nullList, nullList, nullList);         Assert.assertEquals(0, cc.size());     }      @SuppressWarnings("unchecked")     public void testIsEmpty() {         setUpTest();         assertTrue(c.isEmpty());         final HashSet<E> empty = new HashSet<>();         c.addComposited(empty);         assertTrue(c.isEmpty());         empty.add((E) "a");         assertFalse(c.isEmpty());     }      @SuppressWarnings("unchecked")     public void testIterator() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one);         c.addComposited(two);         final Iterator<E> i = c.iterator();         E next = i.next();         assertTrue(c.contains(next));         assertTrue(one.contains(next));         next = i.next();         i.remove();         assertFalse(c.contains(next));         assertFalse(two.contains(next));     }      @SuppressWarnings("unchecked")     public void testMultipleCollectionsSize() {         setUpTest();         final HashSet<E> set = new HashSet<>();         set.add((E) "a");         set.add((E) "b");         c.addComposited(set);         final HashSet<E> other = new HashSet<>();         other.add((E) "c");         c.addComposited(other);         assertEquals(set.size() + other.size(), c.size());     }      @SuppressWarnings("unchecked")     public void testRemove() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         c.addComposited(one, two);         c.remove("1");         assertFalse(c.contains("1"));         assertFalse(one.contains("1"));         assertFalse(two.contains("1"));     }      @SuppressWarnings("unchecked")     public void testRemoveAll() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         // need separate list to remove, as otherwise one clears itself         final Collection<E> removing = new ArrayList<>(one);         c.addComposited(one, two);         c.removeAll(removing);         assertTrue(!c.contains("1"));         assertTrue(!one.contains("1"));         assertTrue(!two.contains("1"));         c.removeAll(null);         assertFalse(c.contains("1"));         assertFalse(one.contains("1"));         assertFalse(two.contains("1"));     }      /**      * @since 4.4      */     @SuppressWarnings("unchecked")     public void testRemoveIf() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         // need separate list to remove, as otherwise one clears itself         final Predicate<E> predicate = e -> e == "1";         c.addComposited(one, two);         c.removeIf(predicate);         assertTrue(!c.contains("1"));         assertTrue(!one.contains("1"));         assertTrue(!two.contains("1"));         c.removeIf(null);         assertTrue(!c.contains("1"));         assertTrue(!one.contains("1"));         assertTrue(!two.contains("1"));     }      @SuppressWarnings("unchecked")     public void testRemoveComposited() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         c.addComposited(one, two);         c.removeComposited(one);         assertTrue(c.contains("1"));         assertEquals(2, c.size());     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         setUpTest();         one.add((E) "1");         one.add((E) "2");         two.add((E) "1");         c.addComposited(one);         c.retainAll(two);         assertFalse(c.contains("2"));         assertFalse(one.contains("2"));         assertTrue(c.contains("1"));         assertTrue(one.contains("1"));         c.retainAll(null);         assertFalse(c.contains("2"));         assertFalse(one.contains("2"));         assertTrue(c.contains("1"));         assertTrue(one.contains("1"));     }      @SuppressWarnings("unchecked")     public void testSize() {         setUpTest();         final HashSet<E> set = new HashSet<>();         set.add((E) "a");         set.add((E) "b");         c.addComposited(set);         assertEquals(set.size(), c.size());     }      @SuppressWarnings("unchecked")     public void testToCollection() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one, two);         final Collection<E> foo = c.toCollection();         assertTrue(foo.containsAll(c));         assertEquals(c.size(), foo.size());         one.add((E) "3");         assertFalse(foo.containsAll(c));     }      /**      * Override testUnsupportedRemove, since the default impl expects removeAll,      * retainAll and iterator().remove to throw      */     @Override     public void testUnsupportedRemove() {         resetFull();         try {             getCollection().remove(null);             fail("remove should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.Queue; import java.util.Set;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.Predicate; import org.junit.Assert; import org.junit.Test;  /**  * Tests the PredicatedCollection.Builder class.  *  * @since 4.1  */ public class PredicatedCollectionBuilderTest {      /**      * Verify that passing the Predicate means ending up in the buffer.      */     @Test     public void addPass() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.add("test");         Assert.assertEquals(builder.createPredicatedList().size(), 1);     }      /**      * Verify that failing the Predicate means NOT ending up in the buffer.      */     @Test     public void addFail() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.add((String) null);         Assert.assertTrue(builder.createPredicatedList().isEmpty());          Assert.assertEquals(1, builder.rejectedElements().size());     }      /**      * Verify that only items that pass the Predicate end up in the buffer.      */     @Test     public void addAllPass() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.addAll(Arrays.asList("test1", null, "test2"));         Assert.assertEquals(builder.createPredicatedList().size(), 2);     }      @Test     public void createPredicatedCollectionWithNotNullPredicate() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.add("test1");         builder.add((String) null);          final List<String> predicatedList = builder.createPredicatedList();         checkPredicatedCollection1(predicatedList);          final Set<String> predicatedSet = builder.createPredicatedSet();         checkPredicatedCollection1(predicatedSet);          final Bag<String> predicatedBag = builder.createPredicatedBag();         checkPredicatedCollection1(predicatedBag);          final Queue<String> predicatedQueue = builder.createPredicatedQueue();         checkPredicatedCollection1(predicatedQueue);     }      private void checkPredicatedCollection1(final Collection<String> collection) {         Assert.assertEquals(1, collection.size());          collection.add("test2");         Assert.assertEquals(2, collection.size());          try {             collection.add(null);             Assert.fail("Expecting IllegalArgumentException for failing predicate!");         } catch (final IllegalArgumentException iae) {             // expected         }     }      @Test     public void createPredicatedCollectionWithPredicate() {         final OddPredicate p = new OddPredicate();         final PredicatedCollection.Builder<Integer> builder = PredicatedCollection.builder(p);          builder.add(1);         builder.add(2);         builder.add(3);          final List<Integer> predicatedList = builder.createPredicatedList();         checkPredicatedCollection2(predicatedList);          final Set<Integer> predicatedSet = builder.createPredicatedSet();         checkPredicatedCollection2(predicatedSet);          final Bag<Integer> predicatedBag = builder.createPredicatedBag();         checkPredicatedCollection2(predicatedBag);          final Queue<Integer> predicatedQueue = builder.createPredicatedQueue();         checkPredicatedCollection2(predicatedQueue);     }      private void checkPredicatedCollection2(final Collection<Integer> collection) {         Assert.assertEquals(2, collection.size());          try {             collection.add(4);             Assert.fail("Expecting IllegalArgumentException for failing predicate!");         } catch (final IllegalArgumentException iae) {         }         Assert.assertEquals(2, collection.size());          collection.add(5);         Assert.assertEquals(3, collection.size());     }      private static class OddPredicate implements Predicate<Integer> {         @Override         public boolean evaluate(final Integer value) {             return value % 2 == 1;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.ConcurrentModificationException; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.Objects; import java.util.function.Predicate;  import org.apache.commons.collections4.AbstractObjectTest;  /**  * Abstract test class for {@link java.util.Collection} methods and contracts.  * <p>  * You should create a concrete subclass of this class to test any custom  * {@link Collection} implementation.  At minimum, you'll have to  * implement the @{@link #makeObject()}, {@link #makeConfirmedCollection()}  * and {@link #makeConfirmedFullCollection()} methods.  * You might want to override some of the additional public methods as well:  * <p>  * <b>Element Population Methods</b>  * <p>  * Override these if your collection restricts what kind of elements are  * allowed (for instance, if {@code null} is not permitted):  * <ul>  * <li>{@link #getFullElements()}  * <li>{@link #getOtherElements()}  * </ul>  * <p>  * <b>Supported Operation Methods</b>  * <p>  * Override these if your collection doesn't support certain operations:  * <ul>  * <li>{@link #isAddSupported()}  * <li>{@link #isRemoveSupported()}  * <li>{@link #areEqualElementsDistinguishable()}  * <li>{@link #isNullSupported()}  * <li>{@link #isFailFastSupported()}  * </ul>  * <p>  * <b>Fixture Methods</b>  * <p>  * Fixtures are used to verify that the operation results in correct state  * for the collection.  Basically, the operation is performed against your  * collection implementation, and an identical operation is performed against a  * <i>confirmed</i> collection implementation.  A confirmed collection  * implementation is something like {@code java.util.ArrayList}, which is  * known to conform exactly to its collection interface's contract.  After the  * operation takes place on both your collection implementation and the  * confirmed collection implementation, the two collections are compared to see  * if their state is identical.  The comparison is usually much more involved  * than a simple {@code equals} test.  This verification is used to ensure  * proper modifications are made along with ensuring that the collection does  * not change when read-only modifications are made.  * <p>  * The {@link #collection} field holds an instance of your collection  * implementation; the {@link #confirmed} field holds an instance of the  * confirmed collection implementation.  The {@link #resetEmpty()} and  * {@link #resetFull()} methods set these fields to empty or full collections,  * so that tests can proceed from a known state.  * <p>  * After a modification operation to both {@link #collection} and  * {@link #confirmed}, the {@link #verify()} method is invoked to compare  * the results.  You may want to override {@link #verify()} to perform  * additional verifications.  For instance, when testing the collection  * views of a map, {@link org.apache.commons.collections4.map.AbstractMapTest AbstractTestMap}  * would override {@link #verify()} to make  * sure the map is changed after the collection view is changed.  * <p>  * If you're extending this class directly, you will have to provide  * implementations for the following:  * <ul>  * <li>{@link #makeConfirmedCollection()}  * <li>{@link #makeConfirmedFullCollection()}  * </ul>  * <p>  * Those methods should provide a confirmed collection implementation  * that's compatible with your collection implementation.  * <p>  * If you're extending {@link org.apache.commons.collections4.list.AbstractListTest AbstractListTest},  * {@link org.apache.commons.collections4.set.AbstractSetTest AbstractTestSet},  * or {@link org.apache.commons.collections4.bag.AbstractBagTest AbstractBagTest},  * you probably don't have to worry about the  * above methods, because those three classes already override the methods  * to provide standard JDK confirmed collections.<P>  * <p>  * <b>Other notes</b>  * <p>  * If your {@link Collection} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link Collection} fails.  *  */ public abstract class AbstractCollectionTest<E> extends AbstractObjectTest {      //     // NOTE:     //     // Collection doesn't define any semantics for equals, and recommends you     // use reference-based default behavior of Object.equals.  (And a test for     // that already exists in AbstractTestObject).  Tests for equality of lists, sets     // and bags will have to be written in test subclasses.  Thus, there is no     // tests on Collection.equals nor any for Collection.hashCode.     //      // These fields are used by reset() and verify(), and any test     // method that tests a modification.      /**      *  A collection instance that will be used for testing.      */     private Collection<E> collection;      /**      *  Confirmed collection.  This is an instance of a collection that is      *  confirmed to conform exactly to the java.util.Collection contract.      *  Modification operations are tested by performing a mod on your      *  collection, performing the exact same mod on an equivalent confirmed      *  collection, and then calling verify() to make sure your collection      *  still matches the confirmed collection.      */     private Collection<E> confirmed;      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Specifies whether equal elements in the collection are, in fact,      *  distinguishable with information not readily available.  That is, if a      *  particular value is to be removed from the collection, then there is      *  one and only one value that can be removed, even if there are other      *  elements which are equal to it.      *      *  <P>In most collection cases, elements are not distinguishable (equal is      *  equal), thus this method defaults to return false.  In some cases,      *  however, they are.  For example, the collection returned from the map's      *  values() collection view are backed by the map, so while there may be      *  two values that are equal, their associated keys are not.  Since the      *  keys are distinguishable, the values are.      *      *  <P>This flag is used to skip some verifications for iterator.remove()      *  where it is impossible to perform an equivalent modification on the      *  confirmed collection because it is not possible to determine which      *  value in the confirmed collection to actually remove.  Tests that      *  override the default (i.e. where equal elements are distinguishable),      *  should provide additional tests on iterator.remove() to make sure the      *  proper elements are removed when remove() is called on the iterator.      **/     public boolean areEqualElementsDistinguishable() {         return false;     }      /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the {@code add} and {@code addAll}      *  operations.<P>      *  Default implementation returns true.  Override if your collection      *  class does not support add or addAll.      */     public boolean isAddSupported() {         return true;     }      /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the {@code remove}, {@code removeAll},      *  {@code retainAll}, {@code clear} and      *  {@code iterator().remove()} methods.      *  Default implementation returns true.  Override if your collection      *  class does not support removal operations.      */     public boolean isRemoveSupported() {         return true;     }      /**      * Returns true to indicate that the collection supports holding null.      * The default implementation returns true;      */     public boolean isNullSupported() {         return true;     }      /**      * Returns true to indicate that the collection supports fail fast iterators.      * The default implementation returns true;      */     public boolean isFailFastSupported() {         return false;     }      /**      * Returns true to indicate that the collection supports equals() comparisons.      * This implementation returns false;      */     @Override     public boolean isEqualsCheckable() {         return false;     }      //-----------------------------------------------------------------------     /**      *  Verifies that {@link #collection} and {@link #confirmed} have      *  identical state.      */     public void verify() {         final int confirmedSize = getConfirmed().size();         assertEquals("Collection size should match confirmed collection's", confirmedSize,                 getCollection().size());         assertEquals("Collection isEmpty() result should match confirmed collection's",                 getConfirmed().isEmpty(), getCollection().isEmpty());          // verify the collections are the same by attempting to match each         // object in the collection and confirmed collection.  To account for         // duplicates and differing orders, each confirmed element is copied         // into an array and a flag is maintained for each element to determine         // whether it has been matched once and only once.  If all elements in         // the confirmed collection are matched once and only once and there         // aren't any elements left to be matched in the collection,         // verification is a success.          // copy each collection value into an array         final Object[] confirmedValues = new Object[confirmedSize];          Iterator<E> iter;          iter = getConfirmed().iterator();         int pos = 0;         while (iter.hasNext()) {             confirmedValues[pos++] = iter.next();         }          // allocate an array of boolean flags for tracking values that have         // been matched once and only once.         final boolean[] matched = new boolean[confirmedSize];          // now iterate through the values of the collection and try to match         // the value with one in the confirmed array.         iter = getCollection().iterator();         while (iter.hasNext()) {             final Object o = iter.next();             boolean match = false;             for (int i = 0; i < confirmedSize; i++) {                 if (matched[i]) {                     // skip values already matched                     continue;                 }                 if (Objects.equals(o, confirmedValues[i])) {                     // values matched                     matched[i] = true;                     match = true;                     break;                 }             }             // no match found!             if (!match) {                 fail("Collection should not contain a value that the "                         + "confirmed collection does not have: " + o + "\nTest: " + getCollection()                         + "\nReal: " + getConfirmed());             }         }          // make sure there aren't any unmatched values         for (int i = 0; i < confirmedSize; i++) {             if (!matched[i]) {                 // the collection didn't match all the confirmed values                 fail("Collection should contain all values that are in the confirmed collection"                         + "\nTest: " + getCollection() + "\nReal: " + getConfirmed());             }         }     }      //-----------------------------------------------------------------------     /**      *  Resets the {@link #collection} and {@link #confirmed} fields to empty      *  collections.  Invoke this method before performing a modification      *  test.      */     public void resetEmpty() {         this.setCollection(makeObject());         this.setConfirmed(makeConfirmedCollection());     }      /**      *  Resets the {@link #collection} and {@link #confirmed} fields to full      *  collections.  Invoke this method before performing a modification      *  test.      */     public void resetFull() {         this.setCollection(makeFullCollection());         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      *  Returns a confirmed empty collection.      *  For instance, an {@link java.util.ArrayList} for lists or a      *  {@link java.util.HashSet} for sets.      *      *  @return a confirmed empty collection      */     public abstract Collection<E> makeConfirmedCollection();      /**      *  Returns a confirmed full collection.      *  For instance, an {@link java.util.ArrayList} for lists or a      *  {@link java.util.HashSet} for sets.  The returned collection      *  should contain the elements returned by {@link #getFullElements()}.      *      *  @return a confirmed full collection      */     public abstract Collection<E> makeConfirmedFullCollection();      /**      * Return a new, empty {@link Collection} to be used for testing.      */     @Override     public abstract Collection<E> makeObject();      /**      *  Returns a full collection to be used for testing.  The collection      *  returned by this method should contain every element returned by      *  {@link #getFullElements()}.  The default implementation, in fact,      *  simply invokes {@code addAll} on an empty collection with      *  the results of {@link #getFullElements()}.  Override this default      *  if your collection doesn't support addAll.      */     public Collection<E> makeFullCollection() {         final Collection<E> c = makeObject();         c.addAll(Arrays.asList(getFullElements()));         return c;     }      /**      * Creates a new Map Entry that is independent of the first and the map.      */     public Map.Entry<E, E> cloneMapEntry(final Map.Entry<E, E> entry) {         final HashMap<E, E> map = new HashMap<>();         map.put(entry.getKey(), entry.getValue());         return map.entrySet().iterator().next();     }      //-----------------------------------------------------------------------     /**      *  Returns an array of objects that are contained in a collection      *  produced by {@link #makeFullCollection()}.  Every element in the      *  returned array <I>must</I> be an element in a full collection.<P>      *  The default implementation returns a heterogenous array of      *  objects with some duplicates. null is added if allowed.      *  Override if you require specific testing elements.  Note that if you      *  override {@link #makeFullCollection()}, you <I>must</I> override      *  this method to reflect the contents of a full collection.      */     @SuppressWarnings("unchecked")     public E[] getFullElements() {         if (isNullSupported()) {             final ArrayList<E> list = new ArrayList<>(Arrays.asList(getFullNonNullElements()));             list.add(4, null);             return (E[]) list.toArray();         }         return getFullNonNullElements().clone();     }      /**      *  Returns an array of elements that are <I>not</I> contained in a      *  full collection.  Every element in the returned array must      *  not exist in a collection returned by {@link #makeFullCollection()}.      *  The default implementation returns a heterogenous array of elements      *  without null.  Note that some of the tests add these elements      *  to an empty or full collection, so if your collection restricts      *  certain kinds of elements, you should override this method.      */     public E[] getOtherElements() {         return getOtherNonNullElements();     }      //-----------------------------------------------------------------------     /**      *  Returns a list of elements suitable for return by      *  {@link #getFullElements()}.  The array returned by this method      *  does not include null, but does include a variety of objects      *  of different types.  Override getFullElements to return      *  the results of this method if your collection does not support      *  the null element.      */     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         return (E[]) new Object[] {             "",             "One",             Integer.valueOf(2),             "Three",             Integer.valueOf(4),             "One",             new Double(5),             new Float(6),             "Seven",             "Eight",             "Nine",             Integer.valueOf(10),             new Short((short) 11),             new Long(12),             "Thirteen",             "14",             "15",             new Byte((byte) 16)         };     }      /**      *  Returns the default list of objects returned by      *  {@link #getOtherElements()}.  Includes many objects      *  of different types.      */     @SuppressWarnings("unchecked")     public E[] getOtherNonNullElements() {         return (E[]) new Object[] {             Integer.valueOf(0),             new Float(0),             new Double(0),             "Zero",             new Short((short) 0),             new Byte((byte) 0),             new Long(0),             new Character('\u0000'),             "0"         };     }      /**      *  Returns a list of string elements suitable for return by      *  {@link #getFullElements()}.  Override getFullElements to return      *  the results of this method if your collection does not support      *  heterogenous elements or the null element.      */     public Object[] getFullNonNullStringElements() {         return new Object[] {             "If", "the", "dull", "substance", "of", "my", "flesh", "were",             "thought", "Injurious", "distance", "could", "not", "stop", "my", "way",         };     }      /**      *  Returns a list of string elements suitable for return by      *  {@link #getOtherElements()}.  Override getOtherElements to return      *  the results of this method if your collection does not support      *  heterogenous elements or the null element.      */     public Object[] getOtherNonNullStringElements() {         return new Object[] {             "For", "then", "despite", /* of */"space", "I", "would", "be",             "brought", "From", "limits", "far", "remote", "where", "thou", "dost", "stay"         };     }      // Tests     //-----------------------------------------------------------------------     /**      *  Tests {@link Collection#add(Object)}.      */     public void testCollectionAdd() {         if (!isAddSupported()) {             return;         }          final E[] elements = getFullElements();         for (final E element : elements) {             resetEmpty();             final boolean r = getCollection().add(element);             getConfirmed().add(element);             verify();             assertTrue("Empty collection changed after add", r);             assertEquals("Collection size is 1 after first add", 1, getCollection().size());         }          resetEmpty();         int size = 0;         for (final E element : elements) {             final boolean r = getCollection().add(element);             getConfirmed().add(element);             verify();             if (r) {                 size++;             }             assertEquals("Collection size should grow after add", size, getCollection().size());             assertTrue("Collection should contain added element", getCollection().contains(element));         }     }      /**      *  Tests {@link Collection#addAll(Collection)}.      */     public void testCollectionAddAll() {         if (!isAddSupported()) {             return;         }          resetEmpty();         E[] elements = getFullElements();         boolean r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Empty collection should change after addAll", r);         for (final E element : elements) {             assertTrue("Collection should contain added element", getCollection().contains(element));         }          resetFull();         int size = getCollection().size();         elements = getOtherElements();         r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Full collection should change after addAll", r);         for (final E element : elements) {             assertTrue("Full collection should contain added element",                     getCollection().contains(element));         }         assertEquals("Size should increase after addAll", size + elements.length, getCollection().size());          resetFull();         size = getCollection().size();         r = getCollection().addAll(Arrays.asList(getFullElements()));         getConfirmed().addAll(Arrays.asList(getFullElements()));         verify();         if (r) {             assertTrue("Size should increase if addAll returns true", size < getCollection().size());         } else {             assertEquals("Size should not change if addAll returns false", size, getCollection().size());         }     }      /**      *  If {@link #isAddSupported()} returns false, tests that add operations      *  raise <code>UnsupportedOperationException.      */     public void testUnsupportedAdd() {         if (isAddSupported()) {             return;         }          resetEmpty();         try {             getCollection().add(getFullNonNullElements()[0]);             fail("Empty collection should not support add.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();          try {             getCollection().addAll(Arrays.asList(getFullElements()));             fail("Empty collection should not support addAll.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();          resetFull();         try {             getCollection().add(getFullNonNullElements()[0]);             fail("Full collection should not support add.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();          try {             getCollection().addAll(Arrays.asList(getOtherElements()));             fail("Full collection should not support addAll.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();     }      /**      *  Test {@link Collection#clear()}.      */     public void testCollectionClear() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         getCollection().clear(); // just to make sure it doesn't raise anything         verify();          resetFull();         getCollection().clear();         getConfirmed().clear();         verify();     }      /**      *  Tests {@link Collection#contains(Object)}.      */     public void testCollectionContains() {         Object[] elements;          resetEmpty();         elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             assertFalse("Empty collection shouldn't contain element[" + i + "]", getCollection().contains(elements[i]));         }         // make sure calls to "contains" don't change anything         verify();          elements = getOtherElements();         for (int i = 0; i < elements.length; i++) {             assertFalse("Empty collection shouldn't contain element[" + i + "]", getCollection().contains(elements[i]));         }         // make sure calls to "contains" don't change anything         verify();          resetFull();         elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             assertTrue("Full collection should contain element[" + i + "]",                     getCollection().contains(elements[i]));         }         // make sure calls to "contains" don't change anything         verify();          resetFull();         elements = getOtherElements();         for (final Object element : elements) {             assertFalse("Full collection shouldn't contain element", getCollection().contains(element));         }     }      /**      *  Tests {@link Collection#containsAll(Collection)}.      */     public void testCollectionContainsAll() {         resetEmpty();         Collection<E> col = new HashSet<>();         assertTrue("Every Collection should contain all elements of an " +                 "empty Collection.", getCollection().containsAll(col));         col.addAll(Arrays.asList(getOtherElements()));         assertFalse("Empty Collection shouldn't contain all elements of " +                 "a non-empty Collection.", getCollection().containsAll(col));         // make sure calls to "containsAll" don't change anything         verify();          resetFull();         assertFalse("Full collection shouldn't contain other elements", getCollection().containsAll(col));          col.clear();         col.addAll(Arrays.asList(getFullElements()));         assertTrue("Full collection should containAll full elements",                 getCollection().containsAll(col));         // make sure calls to "containsAll" don't change anything         verify();          final int min = getFullElements().length < 4 ? 0 : 2;         final int max = getFullElements().length == 1 ? 1 :                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;         col = Arrays.asList(getFullElements()).subList(min, max);         assertTrue("Full collection should containAll partial full elements",                 getCollection().containsAll(col));         assertTrue("Full collection should containAll itself", getCollection().containsAll(getCollection()));         // make sure calls to "containsAll" don't change anything         verify();          col = new ArrayList<>(Arrays.asList(getFullElements()));         col.addAll(Arrays.asList(getFullElements()));         assertTrue("Full collection should containAll duplicate full elements",                 getCollection().containsAll(col));          // make sure calls to "containsAll" don't change anything         verify();     }      /**      *  Tests {@link Collection#isEmpty()}.      */     public void testCollectionIsEmpty() {         resetEmpty();         assertTrue("New Collection should be empty.", getCollection().isEmpty());         // make sure calls to "isEmpty() don't change anything         verify();          resetFull();         assertFalse("Full collection shouldn't be empty", getCollection().isEmpty());         // make sure calls to "isEmpty() don't change anything         verify();     }      /**      *  Tests the read-only functionality of {@link Collection#iterator()}.      */     public void testCollectionIterator() {         resetEmpty();         Iterator<E> it1 = getCollection().iterator();         assertFalse("Iterator for empty Collection shouldn't have next.", it1.hasNext());         try {             it1.next();             fail("Iterator at end of Collection should throw "                     + "NoSuchElementException when next is called.");         } catch (final NoSuchElementException e) {             // expected         }         // make sure nothing has changed after non-modification         verify();          resetFull();         it1 = getCollection().iterator();         for (final E element : getCollection()) {             assertTrue("Iterator for full collection should haveNext", it1.hasNext());             it1.next();         }         assertFalse("Iterator should be finished", it1.hasNext());          final ArrayList<E> list = new ArrayList<>();         it1 = getCollection().iterator();         for (int i = 0; i < getCollection().size(); i++) {             final E next = it1.next();             assertTrue("Collection should contain element returned by its iterator",                     getCollection().contains(next));             list.add(next);         }         try {             it1.next();             fail("iterator.next() should raise NoSuchElementException after it finishes");         } catch (final NoSuchElementException e) {             // expected         }         // make sure nothing has changed after non-modification         verify();     }      /**      *  Tests removals from {@link Collection#iterator()}.      */     @SuppressWarnings("unchecked")     public void testCollectionIteratorRemove() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().iterator().remove();             fail("New iterator.remove should raise IllegalState");         } catch (final IllegalStateException e) {             // expected         }         verify();          try {             final Iterator<E> iter = getCollection().iterator();             iter.hasNext();             iter.remove();             fail("New iterator.remove should raise IllegalState even after hasNext");         } catch (final IllegalStateException e) {             // expected         }         verify();          resetFull();         int size = getCollection().size();         Iterator<E> iter = getCollection().iterator();         while (iter.hasNext()) {             Object o = iter.next();             // TreeMap reuses the Map Entry, so the verify below fails             // Clone it here if necessary             if (o instanceof Map.Entry) {                 o = cloneMapEntry((Map.Entry<E, E>) o);             }             iter.remove();              // if the elements aren't distinguishable, we can just remove a             // matching element from the confirmed collection and verify             // contents are still the same.  Otherwise, we don't have the             // ability to distinguish the elements and determine which to             // remove from the confirmed collection (in which case, we don't             // verify because we don't know how).             //             // see areEqualElementsDistinguishable()             if (!areEqualElementsDistinguishable()) {                 getConfirmed().remove(o);                 verify();             }              size--;             assertEquals("Collection should shrink by one after iterator.remove", size,                     getCollection().size());         }         assertTrue("Collection should be empty after iterator purge", getCollection().isEmpty());          resetFull();         iter = getCollection().iterator();         iter.next();         iter.remove();         try {             iter.remove();             fail("Second iter.remove should raise IllegalState");         } catch (final IllegalStateException e) {             // expected         }     }      /**      *  Tests {@link Collection#remove(Object)}.      */     public void testCollectionRemove() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         final E[] elements = getFullElements();         for (final E element : elements) {             assertTrue("Shouldn't remove nonexistent element", !getCollection().remove(element));             verify();         }          final E[] other = getOtherElements();          resetFull();         for (final E element : other) {             assertFalse("Shouldn't remove nonexistent other element", getCollection().remove(element));             verify();         }          final int size = getCollection().size();         for (final E element : elements) {             resetFull();             assertTrue("Collection should remove extant element: " + element,                     getCollection().remove(element));              // if the elements aren't distinguishable, we can just remove a             // matching element from the confirmed collection and verify             // contents are still the same.  Otherwise, we don't have the             // ability to distinguish the elements and determine which to             // remove from the confirmed collection (in which case, we don't             // verify because we don't know how).             //             // see areEqualElementsDistinguishable()             if (!areEqualElementsDistinguishable()) {                 getConfirmed().remove(element);                 verify();             }              assertEquals("Collection should shrink after remove", size - 1, getCollection().size());         }     }      /**      *  Tests {@link Collection#removeAll(Collection)}.      */     public void testCollectionRemoveAll() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         assertTrue("Empty collection removeAll should return false for empty input",                 !getCollection().removeAll(Collections.EMPTY_SET));         verify();          assertTrue("Empty collection removeAll should return false for nonempty input",                    !getCollection().removeAll(new ArrayList<>(getCollection())));         verify();          resetFull();         assertFalse("Full collection removeAll should return false for empty input", getCollection().removeAll(Collections.EMPTY_SET));         verify();          assertFalse("Full collection removeAll should return false for other elements", getCollection().removeAll(Arrays.asList(getOtherElements())));         verify();          assertTrue("Full collection removeAll should return true for full elements",                 getCollection().removeAll(new HashSet<>(getCollection())));         getConfirmed().removeAll(new HashSet<>(getConfirmed()));         verify();          resetFull();         final int size = getCollection().size();         final int min = getFullElements().length < 4 ? 0 : 2;         final int max = getFullElements().length == 1 ? 1 :                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;         final Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);         assertTrue("Full collection removeAll should work", getCollection().removeAll(all));         getConfirmed().removeAll(all);         verify();          assertTrue("Collection should shrink after removeAll", getCollection().size() < size);         for (final E element : all) {             assertFalse("Collection shouldn't contain removed element", getCollection().contains(element));         }     }      /**      *  Tests {@link Collection#removeIf(Predicate)}.      * @since 4.4      */     public void testCollectionRemoveIf() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         assertFalse("Empty collection removeIf should return false for a predicate that returns only false", getCollection().removeIf(e -> false));         verify();          assertFalse("Empty collection removeIf should return false for a predicate that returns only true", getCollection().removeIf(e -> true));         verify();          resetFull();         assertFalse("Full collection removeIf should return false for a predicate that returns only false", getCollection().removeIf(e -> false));         verify();          assertTrue("Full collection removeIf should return true for a predicate that returns only true",                 getCollection().removeIf(e -> true));         getConfirmed().removeIf(e -> true);         verify();          resetFull();         final List<E> elements = Arrays.asList(getFullElements());          final int mid = getFullElements().length / 2;         final E target = elements.get(mid);          final int size = getCollection().size();         final int targetCount = Collections.frequency(elements, target);          final Predicate<E> filter = e -> target.equals(e);          assertTrue("Full collection removeIf should work", getCollection().removeIf(filter));         getConfirmed().removeIf(filter);         verify();          assertEquals("Collection should shrink after removeIf", getCollection().size(), size - targetCount);         assertFalse("Collection shouldn't contain removed element", getCollection().contains(target));     }      /**      *  Tests {@link Collection#retainAll(Collection)}.      */     public void testCollectionRetainAll() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         final List<E> elements = Arrays.asList(getFullElements());         final List<E> other = Arrays.asList(getOtherElements());          assertFalse("Empty retainAll() should return false", getCollection().retainAll(Collections.EMPTY_SET));         verify();          assertFalse("Empty retainAll() should return false", getCollection().retainAll(elements));         verify();          resetFull();         assertTrue("Collection should change from retainAll empty",                 getCollection().retainAll(Collections.EMPTY_SET));         getConfirmed().retainAll(Collections.EMPTY_SET);         verify();          resetFull();         assertTrue("Collection changed from retainAll other", getCollection().retainAll(other));         getConfirmed().retainAll(other);         verify();          resetFull();         int size = getCollection().size();         assertFalse("Collection shouldn't change from retainAll elements", getCollection().retainAll(elements));         verify();         assertEquals("Collection size shouldn't change", size, getCollection().size());          if (getFullElements().length > 1) {             resetFull();             size = getCollection().size();             final int min = getFullElements().length < 4 ? 0 : 2;             final int max = getFullElements().length <= 5 ? getFullElements().length - 1 : 5;             assertTrue("Collection should changed by partial retainAll",                     getCollection().retainAll(elements.subList(min, max)));             getConfirmed().retainAll(elements.subList(min, max));             verify();              for (final E element : getCollection()) {                 assertTrue("Collection only contains retained element", elements.subList(min, max).contains(element));             }         }          resetFull();         final HashSet<E> set = new HashSet<>(elements);         size = getCollection().size();         assertFalse("Collection shouldn't change from retainAll without " +                 "duplicate elements", getCollection().retainAll(set));         verify();         assertEquals("Collection size didn't change from nonduplicate " +                      "retainAll", size, getCollection().size());     }      /**      *  Tests {@link Collection#size()}.      */     public void testCollectionSize() {         resetEmpty();         assertEquals("Size of new Collection is 0.", 0, getCollection().size());          resetFull();         assertTrue("Size of full collection should be greater than zero", getCollection().size() > 0);     }      /**      *  Tests {@link Collection#toArray()}.      */     public void testCollectionToArray() {         resetEmpty();         assertEquals("Empty Collection should return empty array for toArray",                      0, getCollection().toArray().length);          resetFull();         final Object[] array = getCollection().toArray();         assertEquals("Full collection toArray should be same size as collection",                 array.length, getCollection().size());         final Object[] confirmedArray = getConfirmed().toArray();         assertEquals("length of array from confirmed collection should "                 + "match the length of the collection's array", confirmedArray.length, array.length);         final boolean[] matched = new boolean[array.length];          for (int i = 0; i < array.length; i++) {             assertTrue("Collection should contain element in toArray",                     getCollection().contains(array[i]));              boolean match = false;             // find a match in the confirmed array             for (int j = 0; j < array.length; j++) {                 // skip already matched                 if (matched[j]) {                     continue;                 }                 if (Objects.equals(array[i], confirmedArray[j])) {                     matched[j] = true;                     match = true;                     break;                 }             }             if (!match) {                 fail("element " + i + " in returned array should be found "                         + "in the confirmed collection's array");             }         }         for (final boolean element : matched) {             assertTrue("Collection should return all its elements in " + "toArray", element);         }     }      /**      *  Tests {@link Collection#toArray(Object[])}.      */     public void testCollectionToArray2() {         resetEmpty();         Object[] a = new Object[] { new Object(), null, null };         Object[] array = getCollection().toArray(a);         assertEquals("Given array shouldn't shrink", array, a);         assertNull("Last element should be set to null", a[0]);         verify();          resetFull();         try {             array = getCollection().toArray(new Void[0]);             fail("toArray(new Void[0]) should raise ArrayStore");         } catch (final ArrayStoreException e) {             // expected         }         verify();          try {             // Casting to Object[] allows compilation on Java 11.             array = getCollection().toArray((Object[]) null);             fail("toArray(null) should raise NPE");         } catch (final NullPointerException e) {             // expected         }         verify();          array = getCollection().toArray(new Object[0]);         a = getCollection().toArray();         assertEquals("toArrays should be equal",                      Arrays.asList(array), Arrays.asList(a));          // Figure out if they're all the same class         // TODO: It'd be nicer to detect a common superclass         final HashSet<Class<?>> classes = new HashSet<>();         for (final Object element : array) {             classes.add(element == null ? null : element.getClass());         }         if (classes.size() > 1) {             return;         }          Class<?> cl = classes.iterator().next();         if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet             cl = Map.Entry.class;         }         a = (Object[]) Array.newInstance(cl, 0);         array = getCollection().toArray(a);         assertEquals("toArray(Object[]) should return correct array type",                 a.getClass(), array.getClass());         assertEquals("type-specific toArrays should be equal",                 Arrays.asList(array),                 Arrays.asList(getCollection().toArray()));         verify();     }      /**      *  Tests {@code toString} on a collection.      */     public void testCollectionToString() {         resetEmpty();         assertNotNull("toString shouldn't return null", getCollection().toString());          resetFull();         assertNotNull("toString shouldn't return null", getCollection().toString());     }      /**      *  If isRemoveSupported() returns false, tests to see that remove      *  operations raise an UnsupportedOperationException.      */     public void testUnsupportedRemove() {         if (isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().clear();             fail("clear should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().remove(null);             fail("remove should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().removeIf(e -> true);             fail("removeIf should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().removeAll(null);             fail("removeAll should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().retainAll(null);             fail("retainAll should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          resetFull();         try {             final Iterator<E> iterator = getCollection().iterator();             iterator.next();             iterator.remove();             fail("iterator.remove should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();      }      /**      *  Tests that the collection's iterator is fail-fast.      */     public void testCollectionIteratorFailFast() {         if (!isFailFastSupported()) {             return;         }          if (isAddSupported()) {             resetFull();             try {                 final Iterator<E> iter = getCollection().iterator();                 final E o = getOtherElements()[0];                 getCollection().add(o);                 getConfirmed().add(o);                 iter.next();                 fail("next after add should raise ConcurrentModification");             } catch (final ConcurrentModificationException e) {                 // expected             }             verify();              resetFull();             try {                 final Iterator<E> iter = getCollection().iterator();                 getCollection().addAll(Arrays.asList(getOtherElements()));                 getConfirmed().addAll(Arrays.asList(getOtherElements()));                 iter.next();                 fail("next after addAll should raise ConcurrentModification");             } catch (final ConcurrentModificationException e) {                 // expected             }             verify();         }          if (!isRemoveSupported()) {             return;         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             getCollection().clear();             iter.next();             fail("next after clear should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         } catch (final NoSuchElementException e) {             // (also legal given spec)         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             getCollection().remove(getFullElements()[0]);             iter.next();             fail("next after remove should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             getCollection().removeIf(e -> false);             iter.next();             fail("next after removeIf should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             final List<E> sublist = Arrays.asList(getFullElements()).subList(2, 5);             getCollection().removeAll(sublist);             iter.next();             fail("next after removeAll should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             final List<E> sublist = Arrays.asList(getFullElements()).subList(2, 5);             getCollection().retainAll(sublist);             iter.next();             fail("next after retainAll should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }     }      @Override     public void testSerializeDeserializeThenCompare() throws Exception {         Object obj = makeObject();         if (obj instanceof Serializable && isTestSerialization()) {             final ByteArrayOutputStream buffer = new ByteArrayOutputStream();             final ObjectOutputStream out = new ObjectOutputStream(buffer);             out.writeObject(obj);             out.close();              final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));             final Object dest = in.readObject();             in.close();             if (isEqualsCheckable()) {                 assertEquals("obj != deserialize(serialize(obj)) - EMPTY Collection", obj, dest);             }         }         obj = makeFullCollection();         if (obj instanceof Serializable && isTestSerialization()) {             final ByteArrayOutputStream buffer = new ByteArrayOutputStream();             final ObjectOutputStream out = new ObjectOutputStream(buffer);             out.writeObject(obj);             out.close();              final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));             final Object dest = in.readObject();             in.close();             if (isEqualsCheckable()) {                 assertEquals("obj != deserialize(serialize(obj)) - FULL Collection", obj, dest);             }         }     }      public Collection<E> getCollection() {         return collection;     }      /**      * Set the collection.      * @param collection the Collection<E> to set      */     public void setCollection(final Collection<E> collection) {         this.collection = collection;     }      public Collection<E> getConfirmed() {         return confirmed;     }      /**      * Set the confirmed.      * @param confirmed the Collection<E> to set      */     public void setConfirmed(final Collection<E> confirmed) {         this.confirmed = confirmed;     }      /**      * Handle the optional exceptions declared by {@link Collection#contains(Object)}      * @param coll      * @param element      */     protected static void assertNotCollectionContains(final Collection<?> coll, final Object element) {         try {             assertFalse(coll.contains(element));         } catch (final ClassCastException e) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     }      /**      * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}      * @param coll      * @param sub      */     protected static void assertNotCollectionContainsAll(final Collection<?> coll, final Collection<?> sub) {         try {             assertFalse(coll.containsAll(sub));         } catch (final ClassCastException cce) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     }      /**      * Handle optional exceptions of {@link Collection#remove(Object)}      * @param coll      * @param element      */     protected static void assertNotRemoveFromCollection(final Collection<?> coll, final Object element) {         try {             assertFalse(coll.remove(element));         } catch (final ClassCastException cce) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     }      /**      * Handle optional exceptions of {@link Collection#removeAll(Collection)}      * @param coll      * @param sub      */     protected static void assertNotRemoveAllFromCollection(final Collection<?> coll, final Collection<?> sub) {         try {             assertFalse(coll.removeAll(sub));         } catch (final ClassCastException cce) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.List;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils;  /**  * Extension of {@link AbstractCollectionTest} for exercising the {@link TransformedCollection}  * implementation.  *  * @since 3.0  */ public class TransformedCollectionTest extends AbstractCollectionTest<Object> {      private static class StringToInteger implements Transformer<Object, Object> {         @Override         public Object transform(final Object input) {             return Integer.valueOf((String) input);         }     }      private static class ToLowerCase implements Transformer<Object, Object> {         @Override         public Object transform(final Object input) {             return ((String) input).toLowerCase();         }     }      public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();     public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();     public static final Transformer<Object, Object> TO_LOWER_CASE_TRANSFORMER = new ToLowerCase();      public TransformedCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<Object> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<Object> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public Collection<Object> makeObject() {         return TransformedCollection.transformingCollection(new ArrayList<>(), NOOP_TRANSFORMER);     }      @Override     public Collection<Object> makeFullCollection() {         final List<Object> list = new ArrayList<>(Arrays.asList(getFullElements()));         return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     @Override     public Object[] getFullElements() {         return new Object[] {"1", "3", "5", "7", "2", "4", "6"};     }      @Override     public Object[] getOtherElements() {         return new Object[] {"9", "88", "678", "87", "98", "78", "99"};     }      //-----------------------------------------------------------------------     public void testTransformedCollection() {         final Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<>(), STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, coll.size());         final Object[] elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             coll.add(elements[i]);             assertEquals(i + 1, coll.size());             assertTrue(coll.contains(Integer.valueOf((String) elements[i])));             assertFalse(coll.contains(elements[i]));         }          assertTrue(coll.remove(Integer.valueOf((String) elements[0])));     }      public void testTransformedCollection_decorateTransform() {         final Collection<Object> originalCollection = new ArrayList<>();         final Object[] elements = getFullElements();         Collections.addAll(originalCollection, elements);         final Collection<Object> collection = TransformedCollection.transformedCollection(originalCollection, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(elements.length, collection.size());         for (final Object element : elements) {             assertTrue(collection.contains(Integer.valueOf((String) element)));             assertFalse(collection.contains(element));         }          assertFalse(collection.remove(elements[0]));         assertTrue(collection.remove(Integer.valueOf((String) elements[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.BoundedCollection; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.list.FixedSizeList;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableBoundedCollection} implementation.  *  */ public class UnmodifiableBoundedCollectionTest<E> extends AbstractCollectionTest<E> {      public UnmodifiableBoundedCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<E> makeObject() {         final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<E>());         return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);     }      @Override     public BoundedCollection<E> makeFullCollection() {         final E[] allElements = getFullElements();         final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<>(Arrays.asList(allElements)));         return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     protected boolean skipSerializedCanonicalTests() {         return true;     }      @Override     public String getCompatibilityVersion() {         return "4";     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final BoundedCollection<E> coll = makeFullCollection();         assertSame(coll, UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll));          try {             UnmodifiableBoundedCollection.unmodifiableBoundedCollection(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import static java.util.Arrays.asList;  import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.Transformer;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link IndexedCollection} implementation.  *  * @since 4.0  */ @SuppressWarnings("boxing") public class IndexedCollectionTest extends AbstractCollectionTest<String> {      public IndexedCollectionTest(final String name) {         super(name);     }     //------------------------------------------------------------------------      protected Collection<String> decorateCollection(final Collection<String> collection) {         return IndexedCollection.nonUniqueIndexedCollection(collection, new IntegerTransformer());     }      protected IndexedCollection<Integer, String> decorateUniqueCollection(final Collection<String> collection) {         return IndexedCollection.uniqueIndexedCollection(collection, new IntegerTransformer());     }      private static final class IntegerTransformer implements Transformer<String, Integer>, Serializable {         private static final long serialVersionUID = 809439581555072949L;          @Override         public Integer transform(final String input) {             return Integer.valueOf(input);         }     }      @Override     public Collection<String> makeObject() {         return decorateCollection(new ArrayList<String>());     }      @Override     public Collection<String> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public String[] getFullElements() {         return new String[] { "1", "3", "5", "7", "2", "4", "6" };     }      @Override     public String[] getOtherElements() {         return new String[] {"9", "88", "678", "87", "98", "78", "99"};     }      @Override     public Collection<String> makeFullCollection() {         return decorateCollection(new ArrayList<>(Arrays.asList(getFullElements())));     }      @Override     public Collection<String> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      public Collection<String> makeTestCollection() {         return decorateCollection(new ArrayList<String>());     }      public Collection<String> makeUniqueTestCollection() {         return decorateUniqueCollection(new ArrayList<String>());     }      @Override     protected boolean skipSerializedCanonicalTests() {         // FIXME: support canonical tests         return true;     }      //------------------------------------------------------------------------      public void testAddedObjectsCanBeRetrievedByKey() throws Exception {         final Collection<String> coll = makeTestCollection();         coll.add("12");         coll.add("16");         coll.add("1");         coll.addAll(asList("2", "3", "4"));          @SuppressWarnings("unchecked")         final IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;         assertEquals("12", indexed.get(12));         assertEquals("16", indexed.get(16));         assertEquals("1", indexed.get(1));         assertEquals("2", indexed.get(2));         assertEquals("3", indexed.get(3));         assertEquals("4", indexed.get(4));     }      public void testEnsureDuplicateObjectsCauseException() throws Exception {         final Collection<String> coll = makeUniqueTestCollection();          coll.add("1");         try {             coll.add("1");             fail();         } catch (final IllegalArgumentException e) {             // expected         }     }      public void testDecoratedCollectionIsIndexedOnCreation() throws Exception {         final Collection<String> original = makeFullCollection();         final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);          assertEquals("1", indexed.get(1));         assertEquals("2", indexed.get(2));         assertEquals("3", indexed.get(3));     }      public void testReindexUpdatesIndexWhenDecoratedCollectionIsModifiedSeparately() throws Exception {         final Collection<String> original = new ArrayList<>();         final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);          original.add("1");         original.add("2");         original.add("3");          assertNull(indexed.get(1));         assertNull(indexed.get(2));         assertNull(indexed.get(3));          indexed.reindex();          assertEquals("1", indexed.get(1));         assertEquals("2", indexed.get(2));         assertEquals("3", indexed.get(3));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import org.apache.commons.collections4.trie.PatriciaTrie; import org.apache.commons.collections4.trie.UnmodifiableTrie; import org.junit.Test;  /**  * Tests for TrieUtils factory methods.  *  */ public class TrieUtilsTest {      //----------------------------------------------------------------------      @Test     public void testUnmodifiableTrie() {         final Trie<String, Object> trie = TrieUtils.unmodifiableTrie(new PatriciaTrie<>());         assertTrue("Returned object should be an UnmodifiableTrie.",             trie instanceof UnmodifiableTrie);         try {             TrieUtils.unmodifiableTrie(null);             fail("Expecting NullPointerException for null trie.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableTrie shall not be decorated", trie, TrieUtils.unmodifiableTrie(trie));     }  }   
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.NullPredicate.*; import static org.apache.commons.collections4.functors.TruePredicate.*; import static org.junit.Assert.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map;  import org.apache.commons.collections4.functors.AbstractPredicateTest; import org.apache.commons.collections4.functors.AllPredicate; import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.functors.ExceptionPredicate; import org.apache.commons.collections4.functors.FalsePredicate; import org.apache.commons.collections4.functors.NotNullPredicate; import org.apache.commons.collections4.functors.NullPredicate; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests the PredicateUtils class.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class PredicateUtilsTest extends AbstractPredicateTest {      // exceptionPredicate     //------------------------------------------------------------------      @Test     public void testExceptionPredicate() {         assertNotNull(PredicateUtils.exceptionPredicate());         assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());         try {             PredicateUtils.exceptionPredicate().evaluate(null);         } catch (final FunctorException ex) {             try {                 PredicateUtils.exceptionPredicate().evaluate(cString);             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // notNullPredicate     //------------------------------------------------------------------      @Test     public void testIsNotNullPredicate() {         assertNotNull(PredicateUtils.notNullPredicate());         assertSame(PredicateUtils.notNullPredicate(), PredicateUtils.notNullPredicate());         assertFalse(PredicateUtils.notNullPredicate().evaluate(null));         assertTrue(PredicateUtils.notNullPredicate().evaluate(cObject));         assertTrue(PredicateUtils.notNullPredicate().evaluate(cString));         assertTrue(PredicateUtils.notNullPredicate().evaluate(cInteger));     }      // identityPredicate     //------------------------------------------------------------------      @Test     public void testIdentityPredicate() {         assertSame(nullPredicate(), PredicateUtils.identityPredicate(null));         assertNotNull(PredicateUtils.identityPredicate(6));         assertFalse(PredicateUtils.identityPredicate(6).evaluate(null));         assertFalse(PredicateUtils.<Object>identityPredicate(6).evaluate(cObject));         assertFalse(PredicateUtils.<Object>identityPredicate(6).evaluate(cString));         assertTrue(PredicateUtils.identityPredicate(6).evaluate(cInteger)); // Cannot use valueOf here         assertTrue(PredicateUtils.identityPredicate(cInteger).evaluate(cInteger));     }      // truePredicate     //------------------------------------------------------------------      @Test     public void testTruePredicate() {         assertNotNull(TruePredicate.truePredicate());         assertSame(TruePredicate.truePredicate(), TruePredicate.truePredicate());         assertTrue(truePredicate().evaluate(null));         assertTrue(truePredicate().evaluate(cObject));         assertTrue(truePredicate().evaluate(cString));         assertTrue(truePredicate().evaluate(cInteger));     }      // falsePredicate     //------------------------------------------------------------------      @Test     public void testFalsePredicate() {         assertNotNull(FalsePredicate.falsePredicate());         assertSame(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate());         assertFalse(FalsePredicate.falsePredicate().evaluate(null));         assertFalse(FalsePredicate.falsePredicate().evaluate(cObject));         assertFalse(FalsePredicate.falsePredicate().evaluate(cString));         assertFalse(FalsePredicate.falsePredicate().evaluate(cInteger));     }      // notPredicate     //------------------------------------------------------------------      @Test     public void testNotPredicate() {         assertNotNull(PredicateUtils.notPredicate(TruePredicate.truePredicate()));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(null));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cObject));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cString));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cInteger));     }      @Test(expected=NullPointerException.class)     public void testNotPredicateEx() {         PredicateUtils.notPredicate(null);     }      // andPredicate     //------------------------------------------------------------------      @Test     public void testAndPredicate() {         assertTrue(PredicateUtils.andPredicate(truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.andPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertFalse(PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testAndPredicateEx() {         PredicateUtils.andPredicate(null, null);     }      // allPredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testAllPredicate() {         assertPredicateTrue(AllPredicate.allPredicate(), null);         assertTrue(AllPredicate.allPredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertFalse(AllPredicate.allPredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(AllPredicate.allPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(AllPredicate.allPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertFalse(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateFalse(AllPredicate.allPredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateTrue(AllPredicate.allPredicate(coll), null);         coll.clear();         assertPredicateTrue(AllPredicate.allPredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx1() {         AllPredicate.allPredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testAllPredicateEx2() {         AllPredicate.<Object>allPredicate(new Predicate[] { null });     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx3() {         AllPredicate.allPredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx4() {         AllPredicate.allPredicate((Collection<Predicate<Object>>) null);     }      @Test     public void testAllPredicateEx5() {         AllPredicate.allPredicate(Collections.emptyList());     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx6() {         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         AllPredicate.allPredicate(coll);     }      // orPredicate     //------------------------------------------------------------------      @Test     public void testOrPredicate() {         assertTrue(PredicateUtils.orPredicate(truePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.orPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testOrPredicateEx() {         PredicateUtils.orPredicate(null, null);     }      // anyPredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testAnyPredicate() {         assertPredicateFalse(PredicateUtils.anyPredicate(), null);          assertTrue(PredicateUtils.anyPredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.anyPredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.anyPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.anyPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertFalse(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateFalse(PredicateUtils.anyPredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateTrue(PredicateUtils.anyPredicate(coll), null);         coll.clear();         assertPredicateFalse(PredicateUtils.anyPredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx1() {         PredicateUtils.anyPredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testAnyPredicateEx2() {         PredicateUtils.anyPredicate(new Predicate[] {null});     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx3() {         PredicateUtils.anyPredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx4() {         PredicateUtils.anyPredicate((Collection<Predicate<Object>>) null);     }      @Test     public void testAnyPredicateEx5() {         PredicateUtils.anyPredicate(Collections.emptyList());     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx6() {         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         PredicateUtils.anyPredicate(coll);     }      // eitherPredicate     //------------------------------------------------------------------      @Test     public void testEitherPredicate() {         assertFalse(PredicateUtils.eitherPredicate(truePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.eitherPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testEitherPredicateEx() {         PredicateUtils.eitherPredicate(null, null);     }      // onePredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testOnePredicate() {         assertPredicateFalse(PredicateUtils.onePredicate((Predicate<Object>[]) new Predicate[] {}), null);         assertFalse(PredicateUtils.onePredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.onePredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.onePredicate(truePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateFalse(PredicateUtils.onePredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateTrue(PredicateUtils.onePredicate(coll), null);         coll.clear();         assertPredicateFalse(PredicateUtils.onePredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx1() {         PredicateUtils.onePredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testOnePredicateEx2() {         PredicateUtils.onePredicate(new Predicate[] {null});     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx3() {         PredicateUtils.onePredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx4() {         PredicateUtils.onePredicate((Collection<Predicate<Object>>) null);     }      @SuppressWarnings("unchecked")     @Test     public void testOnePredicateEx5() {         PredicateUtils.onePredicate(Collections.EMPTY_LIST);     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx6() {         PredicateUtils.onePredicate(Arrays.asList(null, null));     }      // neitherPredicate     //------------------------------------------------------------------      @Test     public void testNeitherPredicate() {         assertFalse(PredicateUtils.neitherPredicate(truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.neitherPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertFalse(PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testNeitherPredicateEx() {         PredicateUtils.neitherPredicate(null, null);     }      // nonePredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testNonePredicate() {         assertPredicateTrue(PredicateUtils.nonePredicate(), null);         assertFalse(PredicateUtils.nonePredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.nonePredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.nonePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.nonePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertTrue(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateTrue(PredicateUtils.nonePredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateFalse(PredicateUtils.nonePredicate(coll), null);         coll.clear();         assertPredicateTrue(PredicateUtils.nonePredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testNonePredicateEx1() {         PredicateUtils.nonePredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testNonePredicateEx2() {         PredicateUtils.nonePredicate(new Predicate[] {null});     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testNonePredicateEx3() {         PredicateUtils.nonePredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testNonePredicateEx4() {         PredicateUtils.nonePredicate((Collection<Predicate<Object>>) null);     }      @Test     public void testNonePredicateEx5() {         PredicateUtils.nonePredicate(Collections.emptyList());     }      @Test(expected=NullPointerException.class)     public void testNonePredicateEx6() {         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         PredicateUtils.nonePredicate(coll);     }      // instanceofPredicate     //------------------------------------------------------------------      @Test     public void testInstanceOfPredicate() {         assertNotNull(PredicateUtils.instanceofPredicate(String.class));         assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(null));         assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(cObject));         assertTrue(PredicateUtils.instanceofPredicate(String.class).evaluate(cString));         assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(cInteger));     }      // uniquePredicate     //------------------------------------------------------------------      @Test     public void testUniquePredicate() {         final Predicate<Object> p = PredicateUtils.uniquePredicate();         assertTrue(p.evaluate(new Object()));         assertTrue(p.evaluate(new Object()));         assertTrue(p.evaluate(new Object()));         assertTrue(p.evaluate(cString));         assertFalse(p.evaluate(cString));         assertFalse(p.evaluate(cString));     }      // asPredicate(Transformer)     //------------------------------------------------------------------      @Test     public void testAsPredicateTransformer() {         assertFalse(PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(false));         assertTrue(PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(true));     }      @Test(expected=NullPointerException.class)     public void testAsPredicateTransformerEx1() {         PredicateUtils.asPredicate(null);     }      @Test(expected=FunctorException.class)     public void testAsPredicateTransformerEx2() {         PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(null);     }      // invokerPredicate     //------------------------------------------------------------------      @Test     public void testInvokerPredicate() {         final List<Object> list = new ArrayList<>();         assertTrue(PredicateUtils.invokerPredicate("isEmpty").evaluate(list));         list.add(new Object());         assertFalse(PredicateUtils.invokerPredicate("isEmpty").evaluate(list));     }      @Test(expected=NullPointerException.class)     public void testInvokerPredicateEx1() {         PredicateUtils.invokerPredicate(null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicateEx2() {         PredicateUtils.invokerPredicate("isEmpty").evaluate(null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicateEx3() {         PredicateUtils.invokerPredicate("noSuchMethod").evaluate(new Object());     }      // invokerPredicate2     //------------------------------------------------------------------      @Test     public void testInvokerPredicate2() {         final List<String> list = new ArrayList<>();         assertFalse(PredicateUtils.invokerPredicate(                 "contains", new Class[]{Object.class}, new Object[]{cString}).evaluate(list));         list.add(cString);         assertTrue(PredicateUtils.invokerPredicate(                 "contains", new Class[]{Object.class}, new Object[]{cString}).evaluate(list));     }      @Test(expected=NullPointerException.class)     public void testInvokerPredicate2Ex1() {         PredicateUtils.invokerPredicate(null, null, null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicate2Ex2() {         PredicateUtils.invokerPredicate("contains", new Class[] {Object.class}, new Object[] {cString}).evaluate(null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicate2Ex3() {         PredicateUtils.invokerPredicate(                 "noSuchMethod", new Class[] {Object.class}, new Object[] {cString}).evaluate(new Object());     }      // nullIsException     //------------------------------------------------------------------      @Test(expected=FunctorException.class)     public void testNullIsExceptionPredicate() {         assertTrue(PredicateUtils.nullIsExceptionPredicate(truePredicate()).evaluate(new Object()));         PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(null);     }      @Test(expected=NullPointerException.class)     public void testNullIsExceptionPredicateEx1() {         PredicateUtils.nullIsExceptionPredicate(null);     }      // nullIsTrue     //------------------------------------------------------------------      @Test     public void testNullIsTruePredicate() {         assertTrue(PredicateUtils.nullIsTruePredicate(truePredicate()).evaluate(null));         assertTrue(PredicateUtils.nullIsTruePredicate(truePredicate()).evaluate(new Object()));         assertFalse(PredicateUtils.nullIsTruePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));     }      @Test(expected=NullPointerException.class)     public void testNullIsTruePredicateEx1() {         PredicateUtils.nullIsTruePredicate(null);     }      // nullIsFalse     //------------------------------------------------------------------      @Test     public void testNullIsFalsePredicate() {         assertFalse(PredicateUtils.nullIsFalsePredicate(truePredicate()).evaluate(null));         assertTrue(PredicateUtils.nullIsFalsePredicate(truePredicate()).evaluate(new Object()));         assertFalse(PredicateUtils.nullIsFalsePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));     }      @Test(expected=NullPointerException.class)     public void testNullIsFalsePredicateEx1() {         PredicateUtils.nullIsFalsePredicate(null);     }      // transformed     //------------------------------------------------------------------      @Test     public void testTransformedPredicate() {         assertTrue(PredicateUtils.transformedPredicate(                 TransformerUtils.nopTransformer(),                 truePredicate()).evaluate(new Object()));          final Map<Object, Object> map = new HashMap<>();         map.put(Boolean.TRUE, "Hello");         final Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);         final Predicate<Object> p = EqualPredicate.<Object>equalPredicate("Hello");         assertFalse(PredicateUtils.transformedPredicate(t, p).evaluate(null));         assertTrue(PredicateUtils.transformedPredicate(t, p).evaluate(Boolean.TRUE));         try {             PredicateUtils.transformedPredicate(null, null);             fail();         } catch (final NullPointerException ex) {}     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Predicate singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionPredicate.INSTANCE,             FalsePredicate.INSTANCE,             NotNullPredicate.INSTANCE,             NullPredicate.INSTANCE,             TruePredicate.INSTANCE         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization(                     "Singleton pattern broken for " + original.getClass(),                     original             );         }     }      @Override     protected Predicate<?> generatePredicate() {         return truePredicate();  //Just return something to satisfy super class.     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.SetUtils.SetView; import org.apache.commons.collections4.set.PredicatedSet; import org.junit.Before; import org.junit.Test;  /**  * Tests for SetUtils.  *  */ public class SetUtilsTest {      private Set<Integer> setA;     private Set<Integer> setB;      @Test     public void difference() {         final SetView<Integer> set = SetUtils.difference(setA, setB);         assertEquals(2, set.size());         assertTrue(set.contains(1));         assertTrue(set.contains(2));         for (final Integer i : setB) {             assertFalse(set.contains(i));         }          final Set<Integer> set2 = SetUtils.difference(setA, SetUtils.<Integer>emptySet());         assertEquals(setA, set2);          try {             SetUtils.difference(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.difference(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void disjunction() {         final SetView<Integer> set = SetUtils.disjunction(setA, setB);         assertEquals(4, set.size());         assertTrue(set.contains(1));         assertTrue(set.contains(2));         assertTrue(set.contains(6));         assertTrue(set.contains(7));         assertFalse(set.contains(3));         assertFalse(set.contains(4));         assertFalse(set.contains(5));          final Set<Integer> set2 = SetUtils.disjunction(setA, SetUtils.<Integer>emptySet());         assertEquals(setA, set2);          try {             SetUtils.disjunction(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.disjunction(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void intersection() {         final SetView<Integer> set = SetUtils.intersection(setA, setB);         assertEquals(3, set.size());         assertTrue(set.contains(3));         assertTrue(set.contains(4));         assertTrue(set.contains(5));         assertFalse(set.contains(1));         assertFalse(set.contains(2));         assertFalse(set.contains(6));         assertFalse(set.contains(7));          final Set<Integer> set2 = SetUtils.intersection(setA, SetUtils.<Integer>emptySet());         assertEquals(SetUtils.<Integer>emptySet(), set2);          try {             SetUtils.intersection(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.intersection(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Before     public void setUp() {         setA = new HashSet<>();         setA.add(1);         setA.add(2);         setA.add(3);         setA.add(4);         setA.add(5);          setB = new HashSet<>();         setB.add(3);         setB.add(4);         setB.add(5);         setB.add(6);         setB.add(7);     }      @Test     public void testEmptyIfNull() {         assertTrue(SetUtils.emptyIfNull(null).isEmpty());          final Set<Long> set = new HashSet<>();         assertSame(set, SetUtils.emptyIfNull(set));     }      @Test     public void testEquals() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final Set<String> a = new HashSet<>(data);         final Set<String> b = new HashSet<>(data);          assertEquals(a, b);         assertTrue(SetUtils.isEqualSet(a, b));         a.clear();         assertFalse(SetUtils.isEqualSet(a, b));         assertFalse(SetUtils.isEqualSet(a, null));         assertFalse(SetUtils.isEqualSet(null, b));         assertTrue(SetUtils.isEqualSet(null, null));     }      @Test     public void testHashCode() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final Set<String> a = new HashSet<>(data);         final Set<String> b = new HashSet<>(data);          assertEquals(a.hashCode(), b.hashCode());         assertEquals(a.hashCode(), SetUtils.hashCodeForSet(a));         assertEquals(b.hashCode(), SetUtils.hashCodeForSet(b));         assertEquals(SetUtils.hashCodeForSet(a), SetUtils.hashCodeForSet(b));         a.clear();         assertNotEquals(SetUtils.hashCodeForSet(a), SetUtils.hashCodeForSet(b));         assertEquals(0, SetUtils.hashCodeForSet(null));     }      @Test     public void testHashSet() {         final Set<?> set1 = SetUtils.unmodifiableSet();         assertTrue("set is empty", set1.isEmpty());          final Set<Integer> set2 = SetUtils.hashSet(1, 2, 2, 3);         assertEquals("set has 3 elements", 3, set2.size());         assertTrue("set contains 1", set2.contains(1));         assertTrue("set contains 2", set2.contains(2));         assertTrue("set contains 3", set2.contains(3));          final Set<String> set3 = SetUtils.hashSet("1", "2", "2", "3");         assertEquals("set has 3 elements", 3, set3.size());         assertTrue("set contains 1", set3.contains("1"));         assertTrue("set contains 2", set3.contains("2"));         assertTrue("set contains 3", set3.contains("3"));          final Set<?> set4 = SetUtils.hashSet(null, null);         assertEquals("set has 1 element", 1, set4.size());         assertTrue("set contains null", set4.contains(null));          final Set<?> set5 = SetUtils.hashSet((Object[]) null);         assertNull("set is null", set5);     }      @Test     public void testNewIdentityHashSet() {         final Set<String> set = SetUtils.newIdentityHashSet();         final String a = new String("a");         set.add(a);         set.add(new String("b"));         set.add(a);          assertEquals(2, set.size());          set.add(new String("a"));         assertEquals(3, set.size());          set.remove(a);         assertEquals(2, set.size());     }      @Test     public void testpredicatedSet() {         final Predicate<Object> predicate = o -> o instanceof String;         final Set<Object> set = SetUtils.predicatedSet(new HashSet<>(), predicate);         assertTrue("returned object should be a PredicatedSet", set instanceof PredicatedSet);         try {             SetUtils.predicatedSet(new HashSet<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }         try {             SetUtils.predicatedSet(null, predicate);             fail("Expecting NullPointerException for null set.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableSet() {         final Set<?> set1 = SetUtils.unmodifiableSet();         assertTrue("set is empty", set1.isEmpty());          final Set<Integer> set2 = SetUtils.unmodifiableSet(1, 2, 2, 3);         assertEquals("set has 3 elements", 3, set2.size());         assertTrue("set contains 1", set2.contains(1));         assertTrue("set contains 2", set2.contains(2));         assertTrue("set contains 3", set2.contains(3));          final Set<String> set3 = SetUtils.unmodifiableSet("1", "2", "2", "3");         assertEquals("set has 3 elements", 3, set3.size());         assertTrue("set contains 1", set3.contains("1"));         assertTrue("set contains 2", set3.contains("2"));         assertTrue("set contains 3", set3.contains("3"));          final Set<?> set4 = SetUtils.unmodifiableSet(null, null);         assertEquals("set has 1 element", 1, set4.size());         assertTrue("set contains null", set4.contains(null));          final Set<?> set5 = SetUtils.unmodifiableSet((Object[]) null);         assertNull("set is null", set5);     }      @Test     public void testUnmodifiableSetWrap() {         final Set<Integer> set1 = SetUtils.unmodifiableSet(1, 2, 2, 3);         final Set<Integer> set2 = SetUtils.unmodifiableSet(set1);         assertSame(set1, set2);     }      @Test     public void union() {         final SetView<Integer> set = SetUtils.union(setA, setB);         assertEquals(7, set.size());         assertTrue(set.containsAll(setA));         assertTrue(set.containsAll(setB));          final Set<Integer> set2 = SetUtils.union(setA, SetUtils.<Integer>emptySet());         assertEquals(setA, set2);          try {             SetUtils.union(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.union(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBag;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link TreeBag}  * implementation.  *  */ public class TreeBagTest<T> extends AbstractSortedBagTest<T> {      public TreeBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TreeBagTest.class);     }      //-----------------------------------------------------------------------      @Override     public SortedBag<T> makeObject() {         return new TreeBag<>();     }      @SuppressWarnings("unchecked")     public SortedBag<T> setupBag() {         final SortedBag<T> bag = makeObject();         bag.add((T) "C");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "D");         return bag;     }      public void testCollections265() {         final Bag<Object> bag = new TreeBag<>();         try {             bag.add(new Object());             fail("IllegalArgumentException expected");         } catch(final IllegalArgumentException iae) {             // expected;         }     }      public void testCollections555() {         final Bag<Object> bag = new TreeBag<>();         try {             bag.add(null);             fail("NullPointerException expected");         } catch(final NullPointerException npe) {             // expected;         }          final Bag<String> bag2 = new TreeBag<>(String::compareTo);         try {             // jdk bug: adding null to an empty TreeMap works             // thus ensure that the bag is not empty before adding null             bag2.add("a");             bag2.add(null);             fail("NullPointerException expected");         } catch(final NullPointerException npe) {             // expected;         }     }      public void testOrdering() {         final Bag<T> bag = setupBag();         assertEquals("Should get elements in correct order", "A", bag.toArray()[0]);         assertEquals("Should get elements in correct order", "B", bag.toArray()[1]);         assertEquals("Should get elements in correct order", "C", bag.toArray()[2]);         assertEquals("Should get first key", "A", ((SortedBag<T>) bag).first());         assertEquals("Should get last key", "D", ((SortedBag<T>) bag).last());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TreeBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TreeBag.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link HashBag}  * implementation.  *  */ public class HashBagTest<T> extends AbstractBagTest<T> {      public HashBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashBagTest.class);     }      //-----------------------------------------------------------------------      @Override     public Bag<T> makeObject() {         return new HashBag<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/HashBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/HashBag.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link PredicatedBag}  * implementation.  *  * @since 3.0  */ public class PredicatedBagTest<T> extends AbstractBagTest<T> {      public PredicatedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedBagTest.class);     }      //--------------------------------------------------------------------------      protected Predicate<T> stringPredicate() {         return o -> o instanceof String;     }      protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();      protected Bag<T> decorateBag(final HashBag<T> bag, final Predicate<T> predicate) {         return PredicatedBag.predicatedBag(bag, predicate);     }      @Override     public Bag<T> makeObject() {         return decorateBag(new HashBag<T>(), truePredicate);     }      protected Bag<T> makeTestBag() {         return decorateBag(new HashBag<T>(), stringPredicate());     }      //--------------------------------------------------------------------------      @SuppressWarnings("unchecked")     public void testlegalAddRemove() {         final Bag<T> bag = makeTestBag();         assertEquals(0, bag.size());         final T[] els = (T[]) new Object[] { "1", "3", "5", "7", "2", "4", "1" };         for (int i = 0; i < els.length; i++) {             bag.add(els[i]);             assertEquals(i + 1, bag.size());             assertTrue(bag.contains(els[i]));         }         Set<T> set = bag.uniqueSet();         assertTrue("Unique set contains the first element", set.contains(els[0]));         assertTrue(bag.remove(els[0]));         set = bag.uniqueSet();         assertFalse("Unique set now does not contain the first element", set.contains(els[0]));     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final Bag<T> bag = makeTestBag();         final Integer i = 3;         try {             bag.add((T) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertFalse("Collection shouldn't contain illegal element", bag.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalDecorate() {         final HashBag<Object> elements = new HashBag<>();         elements.add("one");         elements.add("two");         elements.add(3);         elements.add("four");         try {             decorateBag((HashBag<T>) elements, stringPredicate());             fail("Bag contains an element that should fail the predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         try {             decorateBag(new HashBag<T>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException e) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Test class for {@link CollectionBag}.  * <p>  * Note: This test is mainly for serialization support, the CollectionBag decorator  * is extensively used and tested in AbstractBagTest.  *  * @since 4.0  */ public class CollectionBagTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public CollectionBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------      @Override     public Bag<T> makeObject() {         return CollectionBag.collectionBag(new HashBag<T>());     }      /**      * Returns an empty List for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public Collection<T> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full Set for use in modification testing.      *      * @return a confirmed full collection      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> set = makeConfirmedCollection();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionBag.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionBag.fullCollection.version4.obj"); //    }      //-----------------------------------------------------------------------      /**      * Compares the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeObject();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));             assertTrue("Bag is empty", bag2.isEmpty());             assertEquals(bag, bag2);         }     }      /**      * Compares the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testFullBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = (Bag<T>) makeFullCollection();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));             assertEquals("Bag is the right size", bag.size(), bag2.size());             assertEquals(bag, bag2);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link TransformedBag}  * implementation.  *  * @since 3.0  */ public class TransformedBagTest<T> extends AbstractBagTest<T> {      public TransformedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedBagTest.class);     }      //-----------------------------------------------------------------------      @Override     @SuppressWarnings("unchecked")     public Bag<T> makeObject() {         return TransformedBag.transformingBag(new HashBag<T>(),                 (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedBag() {         //T had better be Object!         final Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(),                 (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertTrue(bag.isEmpty());         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (int i = 0; i < els.length; i++) {             bag.add((T) els[i]);             assertEquals(i + 1, bag.size());             assertTrue(bag.contains(Integer.valueOf((String) els[i])));             assertFalse(bag.contains(els[i]));         }          assertFalse(bag.remove(els[0]));         assertTrue(bag.remove(Integer.valueOf((String) els[0])));     }      @SuppressWarnings("unchecked")     public void testTransformedBag_decorateTransform() {         final Bag<T> originalBag = new HashBag<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (final Object el : els) {             originalBag.add((T) el);         }         final Bag<T> bag = TransformedBag.transformedBag(originalBag,                 (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, bag.size());         for (final Object el : els) {             assertTrue(bag.contains(Integer.valueOf((String) el)));             assertFalse(bag.contains(el));         }          assertFalse(bag.remove(els[0]));         assertTrue(bag.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Arrays;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableSortedBag} implementation.  *  * @since 4.0  */ public class UnmodifiableSortedBagTest<E> extends AbstractSortedBagTest<E> {      public UnmodifiableSortedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSortedBagTest.class);     }      //-----------------------------------------------------------------------     @Override     public SortedBag<E> makeObject() {         return UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<E>());     }      @Override     public SortedBag<E> makeFullCollection() {         final SortedBag<E> bag = new TreeBag<>();         bag.addAll(Arrays.asList(getFullElements()));         return UnmodifiableSortedBag.unmodifiableSortedBag(bag);     }      @Override     public SortedBag<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final SortedBag<E> queue = makeFullCollection();         assertSame(queue, UnmodifiableSortedBag.unmodifiableSortedBag(queue));          try {             UnmodifiableSortedBag.unmodifiableSortedBag(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        SortedBag<E> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableSortedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableSortedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Test class for {@link CollectionSortedBag}.  * <p>  * Note: This test is mainly for serialization support, the CollectionSortedBag decorator  * is extensively used and tested in AbstractSortedBagTest.  *  * @since 4.0  */ public class CollectionSortedBagTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public CollectionSortedBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------      /**      * Overridden because SortedBags don't allow null elements (normally).      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      @Override     public Bag<T> makeObject() {         return CollectionSortedBag.collectionSortedBag(new TreeBag<T>());     }      /**      * Returns an empty List for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public Collection<T> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full Set for use in modification testing.      *      * @return a confirmed full collection      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> set = makeConfirmedCollection();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (T[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (T[]) elements;     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionSortedBag.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionSortedBag.fullCollection.version4.obj"); //    }      //-----------------------------------------------------------------------      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeObject();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));             assertEquals("Bag is empty", 0, bag2.size());             assertEquals(bag, bag2);         }     }      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testFullBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final SortedBag<T> bag = (SortedBag<T>) makeFullCollection();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final SortedBag<?> bag2 = (SortedBag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));             assertEquals("Bag is the right size", bag.size(), bag2.size());             assertEquals(bag, bag2);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Comparator;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractSortedBagTest} for exercising the {@link PredicatedSortedBag}  * implementation.  *  * @since 3.0  */ public class PredicatedSortedBagTest<T> extends AbstractSortedBagTest<T> {      private final SortedBag<T> nullBag = null;      public PredicatedSortedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedSortedBagTest.class);     }      //--------------------------------------------------------------------------      protected Predicate<T> stringPredicate() {         return o -> o instanceof String;     }      protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();      protected SortedBag<T> decorateBag(final SortedBag<T> bag, final Predicate<T> predicate) {         return PredicatedSortedBag.predicatedSortedBag(bag, predicate);     }      @Override     public SortedBag<T> makeObject() {         return decorateBag(new TreeBag<T>(), truePredicate);     }      protected SortedBag<T> makeTestBag() {         return decorateBag(new TreeBag<T>(), stringPredicate());     }      //--------------------------------------------------------------------------      public void testDecorate() {         final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());         ((PredicatedSortedBag<T>) bag).decorated();         try {             decorateBag(new TreeBag<T>(), null);             fail("Expecting NullPointerException for null predicate");         } catch (final NullPointerException e) {}         try {             decorateBag(nullBag, stringPredicate());             fail("Expecting NullPointerException for null bag");         } catch (final NullPointerException e) {}     }      @SuppressWarnings("unchecked")     public void testSortOrder() {         final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());         final String one = "one";         final String two = "two";         final String three = "three";         bag.add((T) one);         bag.add((T) two);         bag.add((T) three);         assertEquals("first element", bag.first(), one);         assertEquals("last element", bag.last(), two);         final Comparator<? super T> c = bag.comparator();         assertNull("natural order, so comparator should be null", c);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedSortedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedSortedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Arrays;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableBag} implementation.  *  * @since 4.0  */ public class UnmodifiableBagTest<E> extends AbstractBagTest<E> {      public UnmodifiableBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableBagTest.class);     }      //-----------------------------------------------------------------------     @Override     public Bag<E> makeObject() {         return UnmodifiableBag.unmodifiableBag(new HashBag<E>());     }      @Override     public Bag<E> makeFullCollection() {         final Bag<E> bag = new HashBag<>();         bag.addAll(Arrays.asList(getFullElements()));         return UnmodifiableBag.unmodifiableBag(bag);     }      @Override     public Bag<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Bag<E> queue = makeFullCollection();         assertSame(queue, UnmodifiableBag.unmodifiableBag(queue));          try {             UnmodifiableBag.unmodifiableBag(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<E> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.set.AbstractSetTest;  import static org.junit.Assert.assertNotEquals;  /**  * Abstract test class for {@link org.apache.commons.collections4.Bag Bag} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your bag fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your bag fails.  * <p>  * <b>Note:</b> The Bag interface does not conform to the Collection interface  * so the generic collection tests from AbstractCollectionTest would normally fail.  * As a work-around since 4.0, a CollectionBag decorator can be used  * to make any Bag implementation comply to the Collection contract.  * <p>  * This abstract test class does wrap the concrete bag implementation  * with such a decorator, see the overridden {@link #resetEmpty()} and  * {@link #resetFull()} methods.  * <p>  * In addition to the generic collection tests (prefix testCollection) inherited  * from AbstractCollectionTest, there are test methods that test the "normal" Bag  * interface (prefix testBag). For Bag specific tests use the {@link #makeObject()} and  * {@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull(),  * otherwise the collection will be wrapped by a {@link CollectionBag} decorator.  *  */ public abstract class AbstractBagTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<T> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full collection.      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> coll = makeConfirmedCollection();         coll.addAll(Arrays.asList(getFullElements()));         return coll;     }      /**      * Return a new, empty bag to used for testing.      *      * @return the bag to be tested      */     @Override     public abstract Bag<T> makeObject();      /**      * {@inheritDoc}      */     @Override     public Bag<T> makeFullCollection() {         final Bag<T> bag = makeObject();         bag.addAll(Arrays.asList(getFullElements()));         return bag;     }      //-----------------------------------------------------------------------      @Override     public void resetEmpty() {         this.setCollection(CollectionBag.collectionBag(makeObject()));         this.setConfirmed(makeConfirmedCollection());     }      @Override     public void resetFull() {         this.setCollection(CollectionBag.collectionBag(makeFullCollection()));         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link Bag}.      *      * @return the collection field as a Bag      */     @Override     public Bag<T> getCollection() {         return (Bag<T>) super.getCollection();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testBagAdd() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         assertTrue("Should contain 'A'", bag.contains("A"));         assertEquals("Should have count of 1", 1, bag.getCount("A"));         bag.add((T) "A");         assertTrue("Should contain 'A'", bag.contains("A"));         assertEquals("Should have count of 2", 2, bag.getCount("A"));         bag.add((T) "B");         assertTrue(bag.contains("A"));         assertTrue(bag.contains("B"));     }      @SuppressWarnings("unchecked")     public void testBagEqualsSelf() {         final Bag<T> bag = makeObject();         assertEquals(bag, bag);          if (!isAddSupported()) {             return;         }          bag.add((T) "elt");         assertEquals(bag, bag);         bag.add((T) "elt"); // again         assertEquals(bag, bag);         bag.add((T) "elt2");         assertEquals(bag, bag);     }      @SuppressWarnings("unchecked")     public void testBagRemove() {         if (!isRemoveSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         assertEquals("Should have count of 1", 1, bag.getCount("A"));         bag.remove("A");         assertEquals("Should have count of 0", 0, bag.getCount("A"));         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "A");         assertEquals("Should have count of 4", 4, bag.getCount("A"));         bag.remove("A", 0);         assertEquals("Should have count of 4", 4, bag.getCount("A"));         bag.remove("A", 2);         assertEquals("Should have count of 2", 2, bag.getCount("A"));         bag.remove("A");         assertEquals("Should have count of 0", 0, bag.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testBagRemoveAll() {         if (!isRemoveSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A", 2);         assertEquals("Should have count of 2", 2, bag.getCount("A"));         bag.add((T) "B");         bag.add((T) "C");         assertEquals("Should have count of 4", 4, bag.size());         final List<String> delete = new ArrayList<>();         delete.add("A");         delete.add("B");         bag.removeAll(delete);         assertEquals("Should have count of 1", 1, bag.getCount("A"));         assertEquals("Should have count of 0", 0, bag.getCount("B"));         assertEquals("Should have count of 1", 1, bag.getCount("C"));         assertEquals("Should have count of 2", 2, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagContains() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();          assertFalse("Bag does not have at least 1 'A'", bag.contains("A"));         assertFalse("Bag does not have at least 1 'B'", bag.contains("B"));          bag.add((T) "A");  // bag 1A         assertTrue("Bag has at least 1 'A'", bag.contains("A"));         assertFalse("Bag does not have at least 1 'B'", bag.contains("B"));          bag.add((T) "A");  // bag 2A         assertTrue("Bag has at least 1 'A'", bag.contains("A"));         assertFalse("Bag does not have at least 1 'B'", bag.contains("B"));          bag.add((T) "B");  // bag 2A,1B         assertTrue("Bag has at least 1 'A'", bag.contains("A"));         assertTrue("Bag has at least 1 'B'", bag.contains("B"));     }      @SuppressWarnings("unchecked")     public void testBagContainsAll() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final List<String> known = new ArrayList<>();         final List<String> known1A = new ArrayList<>();         known1A.add("A");         final List<String> known2A = new ArrayList<>();         known2A.add("A");         known2A.add("A");         final List<String> known1B = new ArrayList<>();         known1B.add("B");         final List<String> known1A1B = new ArrayList<>();         known1A1B.add("A");         known1A1B.add("B");          assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertFalse("Bag does not containsAll of 1 'A'", bag.containsAll(known1A));         assertFalse("Bag does not containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "A");  // bag 1A         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertFalse("Bag does not containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "A");  // bag 2A         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertTrue("Bag containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "A");  // bag 3A         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertTrue("Bag containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "B");  // bag 3A1B         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertTrue("Bag containsAll of 2 'A'", bag.containsAll(known2A));         assertTrue("Bag containsAll of 1 'B'", bag.containsAll(known1B));         assertTrue("Bag containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));     }      @SuppressWarnings("unchecked")     public void testBagSize() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         assertEquals("Should have 0 total items", 0, bag.size());         bag.add((T) "A");         assertEquals("Should have 1 total items", 1, bag.size());         bag.add((T) "A");         assertEquals("Should have 2 total items", 2, bag.size());         bag.add((T) "A");         assertEquals("Should have 3 total items", 3, bag.size());         bag.add((T) "B");         assertEquals("Should have 4 total items", 4, bag.size());         bag.add((T) "B");         assertEquals("Should have 5 total items", 5, bag.size());         bag.remove("A", 2);         assertEquals("Should have 1 'A'", 1, bag.getCount("A"));         assertEquals("Should have 3 total items", 3, bag.size());         bag.remove("B");         assertEquals("Should have 1 total item", 1, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagRetainAll() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         final List<String> retains = new ArrayList<>();         retains.add("B");         retains.add("C");         bag.retainAll(retains);         assertEquals("Should have 2 total items", 2, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagIterator() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         assertEquals("Bag should have 3 items", 3, bag.size());         final Iterator<T> i = bag.iterator();          boolean foundA = false;         while (i.hasNext()) {             final String element = (String) i.next();             // ignore the first A, remove the second via Iterator.remove()             if (element.equals("A")) {                 if (!foundA) {                     foundA = true;                 } else {                     i.remove();                 }             }         }          assertTrue("Bag should still contain 'A'", bag.contains("A"));         assertEquals("Bag should have 2 items", 2, bag.size());         assertEquals("Bag should have 1 'A'", 1, bag.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testBagIteratorFail() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         final Iterator<T> it = bag.iterator();         it.next();         bag.remove("A");         try {             it.next();             fail("Should throw ConcurrentModificationException");         } catch (final ConcurrentModificationException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testBagIteratorFailNoMore() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         final Iterator<T> it = bag.iterator();         it.next();         it.next();         it.next();         try {             it.next();             fail("Should throw NoSuchElementException");         } catch (final NoSuchElementException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testBagIteratorFailDoubleRemove() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         final Iterator<T> it = bag.iterator();         it.next();         it.next();         assertEquals(3, bag.size());         it.remove();         assertEquals(2, bag.size());         try {             it.remove();             fail("Should throw IllegalStateException");         } catch (final IllegalStateException ex) {             // expected         }         assertEquals(2, bag.size());         it.next();         it.remove();         assertEquals(1, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagIteratorRemoveProtectsInvariants() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         assertEquals(2, bag.size());         final Iterator<T> it = bag.iterator();         assertEquals("A", it.next());         assertTrue(it.hasNext());         it.remove();         assertEquals(1, bag.size());         assertTrue(it.hasNext());         assertEquals("A", it.next());         assertFalse(it.hasNext());         it.remove();         assertEquals(0, bag.size());         assertFalse(it.hasNext());          final Iterator<T> it2 = bag.iterator();         assertFalse(it2.hasNext());     }      @SuppressWarnings("unchecked")     public void testBagToArray() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         final Object[] array = bag.toArray();         int a = 0, b = 0, c = 0;         for (final Object element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      @SuppressWarnings("unchecked")     public void testBagToArrayPopulate() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         final String[] array = bag.toArray(new String[0]);         int a = 0, b = 0, c = 0;         for (final String element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testBagEquals() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final Bag<T> bag2 = makeObject();         assertEquals(bag, bag2);         bag.add((T) "A");         assertNotEquals(bag, bag2);         bag2.add((T) "A");         assertEquals(bag, bag2);         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         bag2.add((T) "A");         bag2.add((T) "B");         bag2.add((T) "B");         bag2.add((T) "C");         assertEquals(bag, bag2);     }      @SuppressWarnings("unchecked")     public void testBagEqualsHashBag() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final Bag<T> bag2 = new HashBag<>();         assertEquals(bag, bag2);         bag.add((T) "A");         assertNotEquals(bag, bag2);         bag2.add((T) "A");         assertEquals(bag, bag2);         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         bag2.add((T) "A");         bag2.add((T) "B");         bag2.add((T) "B");         bag2.add((T) "C");         assertEquals(bag, bag2);     }      @SuppressWarnings("unchecked")     public void testBagHashCode() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final Bag<T> bag2 = makeObject();         assertEquals(0, bag.hashCode());         assertEquals(0, bag2.hashCode());         assertEquals(bag.hashCode(), bag2.hashCode());         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         bag2.add((T) "A");         bag2.add((T) "A");         bag2.add((T) "B");         bag2.add((T) "B");         bag2.add((T) "C");         assertEquals(bag.hashCode(), bag2.hashCode());          int total = 0;         total += "A".hashCode() ^ 2;         total += "B".hashCode() ^ 2;         total += "C".hashCode() ^ 1;         assertEquals(total, bag.hashCode());         assertEquals(total, bag2.hashCode());     }      //-----------------------------------------------------------------------      /**      * Bulk test {@link Bag#uniqueSet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the bag and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the bag's unique set      */     public BulkTest bulkTestBagUniqueSet() {         return new TestBagUniqueSet();     }      public class TestBagUniqueSet extends AbstractSetTest<T> {         public TestBagUniqueSet() {             super("");         }          @Override         public T[] getFullElements() {             return AbstractBagTest.this.getFullElements();         }          @Override         public T[] getOtherElements() {             return AbstractBagTest.this.getOtherElements();         }          @Override         public Set<T> makeObject() {             return AbstractBagTest.this.makeObject().uniqueSet();         }          @Override         public Set<T> makeFullCollection() {             return AbstractBagTest.this.makeFullCollection().uniqueSet();         }          @Override         public boolean isNullSupported() {             return AbstractBagTest.this.isNullSupported();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return false;         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetEmpty() {             AbstractBagTest.this.resetEmpty();             TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());             TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));         }          @Override         public void resetFull() {             AbstractBagTest.this.resetFull();             TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());             TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));         }          @Override         public void verify() {             super.verify();         }     }      //-----------------------------------------------------------------------      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeObject();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));             assertTrue("Bag is empty", bag2.isEmpty());             assertEquals(bag, bag2);         }     }      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testFullBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeFullCollection();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));             assertEquals("Bag is the right size", bag.size(), bag2.size());             assertEquals(bag, bag2);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Iterator;  import org.apache.commons.collections4.SortedBag;  /**  * Abstract test class for  * {@link org.apache.commons.collections4.SortedBag SortedBag}  * methods and contracts.  *  * @since 3.0  */ public abstract class AbstractSortedBagTest<T> extends AbstractBagTest<T> {      public AbstractSortedBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Verification extension, will check the order of elements,      * the sets should already be verified equal.      */     @Override     public void verify() {         super.verify();          // Check that iterator returns elements in order and first() and last()         // are consistent         final Iterator<T> colliter = getCollection().iterator();         final Iterator<T> confiter = getConfirmed().iterator();         T first = null;         T last = null;         while (colliter.hasNext()) {             if (first == null) {                 first = colliter.next();                 last = first;             } else {                 last = colliter.next();             }             assertEquals("Element appears to be out of order.", last, confiter.next());         }         if (getCollection().size() > 0) {             assertEquals("Incorrect element returned by first().", first,                 getCollection().first());             assertEquals("Incorrect element returned by last().", last,                 getCollection().last());         }     }      //-----------------------------------------------------------------------     /**      * Overridden because SortedBags don't allow null elements (normally).      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedBag<T> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedBag<T> makeFullCollection() {         return (SortedBag<T>) super.makeFullCollection();     }      /**      * Returns an empty {@link TreeBag} for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public SortedBag<T> makeConfirmedCollection() {         return new TreeBag<>();     }      //-----------------------------------------------------------------------      @Override     public void resetEmpty() {         this.setCollection(CollectionSortedBag.collectionSortedBag(makeObject()));         this.setConfirmed(makeConfirmedCollection());     }      @Override     public void resetFull() {         this.setCollection(CollectionSortedBag.collectionSortedBag(makeFullCollection()));         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (T[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (T[]) elements;     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link SortedBag}.      *      * @return the collection field as a SortedBag      */     @Override     public SortedBag<T> getCollection() {         return (SortedBag<T>) super.getCollection();     }      //-----------------------------------------------------------------------      // TODO: Add the SortedBag tests! } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSortedBagTest} for exercising the {@link TransformedSortedBag}  * implementation.  *  * @since 3.0  */ public class TransformedSortedBagTest<T> extends AbstractSortedBagTest<T> {      public TransformedSortedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedSortedBagTest.class);     }      //-----------------------------------------------------------------------      @Override     @SuppressWarnings("unchecked")     public SortedBag<T> makeObject() {         return TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedBag() {         final SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, bag.size());         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (int i = 0; i < els.length; i++) {             bag.add((T) els[i]);             assertEquals(i + 1, bag.size());             assertTrue(bag.contains(Integer.valueOf((String) els[i])));         }          assertTrue(bag.remove(Integer.valueOf((String) els[0])));      }      public void testTransformedBag_decorateTransform() {         final TreeBag<T> originalBag = new TreeBag<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (final Object el : els) {             originalBag.add((T) el);         }         final SortedBag<T> bag = TransformedSortedBag.transformedSortedBag(originalBag, (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, bag.size());         for (final Object el : els) {             assertTrue(bag.contains(Integer.valueOf((String) el)));         }          assertTrue(bag.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedSortedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedSortedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link SynchronizedBag}  * implementation.  *  * @since 4.0  */ public class SynchronizedBagTest<T> extends AbstractBagTest<T> {      public SynchronizedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(SynchronizedBagTest.class);     }      //-----------------------------------------------------------------------      @Override     public Bag<T> makeObject() {         return SynchronizedBag.synchronizedBag(new HashBag<T>());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/SynchronizedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/SynchronizedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link SynchronizedMultiSet} implementation.  *  * @since 4.1  */ public class SynchronizedMultiSetTest<T> extends AbstractMultiSetTest<T> {      public SynchronizedMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(SynchronizedMultiSetTest.class);     }      //-----------------------------------------------------------------------      @Override     public MultiSet<T> makeObject() {         return SynchronizedMultiSet.synchronizedMultiSet(new HashMultiSet<T>());     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<T> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/SynchronizedMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/SynchronizedMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link PredicatedMultiSet} implementation.  *  * @since 4.1  */ public class PredicatedMultiSetTest<T> extends AbstractMultiSetTest<T> {      public PredicatedMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedMultiSetTest.class);     }      //--------------------------------------------------------------------------      protected Predicate<T> stringPredicate() {         return o -> o instanceof String;     }      protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();      protected MultiSet<T> decorateMultiSet(final HashMultiSet<T> multiset, final Predicate<T> predicate) {         return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);     }      @Override     public MultiSet<T> makeObject() {         return decorateMultiSet(new HashMultiSet<T>(), truePredicate);     }      protected MultiSet<T> makeTestMultiSet() {         return decorateMultiSet(new HashMultiSet<T>(), stringPredicate());     }      //--------------------------------------------------------------------------      @SuppressWarnings("unchecked")     public void testLegalAddRemove() {         final MultiSet<T> multiset = makeTestMultiSet();         assertEquals(0, multiset.size());         final T[] els = (T[]) new Object[] { "1", "3", "5", "7", "2", "4", "1" };         for (int i = 0; i < els.length; i++) {             multiset.add(els[i]);             assertEquals(i + 1, multiset.size());             assertEquals(true, multiset.contains(els[i]));         }         Set<T> set = ((PredicatedMultiSet<T>) multiset).uniqueSet();         assertTrue("Unique set contains the first element", set.contains(els[0]));         assertEquals(true, multiset.remove(els[0]));         set = ((PredicatedMultiSet<T>) multiset).uniqueSet();         assertTrue("Unique set does not contain anymore the first element",             set.contains(els[0]));     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final MultiSet<T> multiset = makeTestMultiSet();         final Integer i = Integer.valueOf(3);         try {             multiset.add((T) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element",                    !multiset.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalDecorate() {         final HashMultiSet<Object> elements = new HashMultiSet<>();         elements.add("one");         elements.add("two");         elements.add(Integer.valueOf(3));         elements.add("four");         try {             decorateMultiSet((HashMultiSet<T>) elements, stringPredicate());             fail("MultiSet contains an element that should fail the predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         try {             decorateMultiSet(new HashMultiSet<T>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException e) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<T> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/PredicatedMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/PredicatedMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link HashMultiSet} implementation.  *  * @since 4.1  */ public class HashMultiSetTest<T> extends AbstractMultiSetTest<T> {      public HashMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashMultiSetTest.class);     }      //-----------------------------------------------------------------------      @Override     public MultiSet<T> makeObject() {         return new HashMultiSet<>();     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<T> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/HashMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/HashMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.set.AbstractSetTest;  /**  * Abstract test class for {@link org.apache.commons.collections4.MultiSet MultiSet}  * methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your multiset fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your multiset fails.  * <p>  * This abstract test class does wrap the concrete multiset implementation  * with such a decorator, see the overridden {@link #resetEmpty()} and  * {@link #resetFull()} methods.  * <p>  * In addition to the generic collection tests (prefix testCollection) inherited  * from AbstractCollectionTest, there are test methods that test the "normal" MultiSet  * interface (prefix testMultiSet). For MultiSet specific tests use the {@link #makeObject()} and  * {@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull().  *  * @since 4.1  */ public abstract class AbstractMultiSetTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractMultiSetTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<T> makeConfirmedCollection() {         final ArrayList<T> list = new ArrayList<>();         return list;     }      /**      * Returns a full collection.      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> coll = makeConfirmedCollection();         coll.addAll(Arrays.asList(getFullElements()));         return coll;     }      /**      * Return a new, empty multiset to used for testing.      *      * @return the multiset to be tested      */     @Override     public abstract MultiSet<T> makeObject();      /**      * {@inheritDoc}      */     @Override     public MultiSet<T> makeFullCollection() {         final MultiSet<T> multiset = makeObject();         multiset.addAll(Arrays.asList(getFullElements()));         return multiset;     }      //-----------------------------------------------------------------------      @Override     public void resetEmpty() {         this.setCollection(makeObject());         this.setConfirmed(makeConfirmedCollection());     }      @Override     public void resetFull() {         this.setCollection(makeFullCollection());         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link MultiSet}.      *      * @return the collection field as a MultiSet      */     @Override     public MultiSet<T> getCollection() {         return (MultiSet<T>) super.getCollection();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMultiSetAdd() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         assertTrue("Should contain 'A'", multiset.contains("A"));         assertEquals("Should have count of 1", 1, multiset.getCount("A"));         multiset.add((T) "A");         assertTrue("Should contain 'A'", multiset.contains("A"));         assertEquals("Should have count of 2", 2, multiset.getCount("A"));         multiset.add((T) "B");         assertTrue(multiset.contains("A"));         assertTrue(multiset.contains("B"));     }      @SuppressWarnings("unchecked")     public void testMultiSetEqualsSelf() {         final MultiSet<T> multiset = makeObject();         assertTrue(multiset.equals(multiset));          if (!isAddSupported()) {             return;         }          multiset.add((T) "elt");         assertTrue(multiset.equals(multiset));         multiset.add((T) "elt"); // again         assertTrue(multiset.equals(multiset));         multiset.add((T) "elt2");         assertTrue(multiset.equals(multiset));     }      @SuppressWarnings("unchecked")     public void testMultiSetRemove() {         if (!isRemoveSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         assertEquals("Should have count of 1", 1, multiset.getCount("A"));         multiset.remove("A");         assertEquals("Should have count of 0", 0, multiset.getCount("A"));         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "A");         assertEquals("Should have count of 4", 4, multiset.getCount("A"));         multiset.remove("A", 0);         assertEquals("Should have count of 4", 4, multiset.getCount("A"));         multiset.remove("A", 2);         assertEquals("Should have count of 2", 2, multiset.getCount("A"));         multiset.remove("A");         assertEquals("Should have count of 1", 1, multiset.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testMultiSetRemoveAll() {         if (!isRemoveSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A", 2);         assertEquals("Should have count of 2", 2, multiset.getCount("A"));         multiset.add((T) "B");         multiset.add((T) "C");         assertEquals("Should have count of 4", 4, multiset.size());         final List<String> delete = new ArrayList<>();         delete.add("A");         delete.add("B");         multiset.removeAll(delete);         assertEquals("Should have count of 0", 0, multiset.getCount("A"));         assertEquals("Should have count of 0", 0, multiset.getCount("B"));         assertEquals("Should have count of 1", 1, multiset.getCount("C"));         assertEquals("Should have count of 1", 1, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetContains() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();          assertEquals("MultiSet does not have at least 1 'A'", false, multiset.contains("A"));         assertEquals("MultiSet does not have at least 1 'B'", false, multiset.contains("B"));          multiset.add((T) "A");  // multiset 1A         assertEquals("MultiSet has at least 1 'A'", true, multiset.contains("A"));         assertEquals("MultiSet does not have at least 1 'B'", false, multiset.contains("B"));          multiset.add((T) "A");  // multiset 2A         assertEquals("MultiSet has at least 1 'A'", true, multiset.contains("A"));         assertEquals("MultiSet does not have at least 1 'B'", false, multiset.contains("B"));          multiset.add((T) "B");  // multiset 2A,1B         assertEquals("MultiSet has at least 1 'A'", true, multiset.contains("A"));         assertEquals("MultiSet has at least 1 'B'", true, multiset.contains("B"));     }      @SuppressWarnings("unchecked")     public void testMultiSetContainsAll() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final List<String> known = new ArrayList<>();         final List<String> known1A = new ArrayList<>();         known1A.add("A");         final List<String> known2A = new ArrayList<>();         known2A.add("A");         known2A.add("A");         final List<String> known1B = new ArrayList<>();         known1B.add("B");         final List<String> known1A1B = new ArrayList<>();         known1A1B.add("A");         known1A1B.add("B");          assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet does not containsAll of 1 'A'", false, multiset.containsAll(known1A));         assertEquals("MultiSet does not containsAll of 2 'A'", false, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "A");  // multiset 1A         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet does not containsAll 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "A");  // multiset 2A         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet containsAll of 2 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "A");  // multiset 3A         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet containsAll of 2 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "B");  // multiset 3A1B         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet containsAll of 2 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet containsAll of 1 'B'", true, multiset.containsAll(known1B));         assertEquals("MultiSet containsAll of 1 'A' 1 'B'", true, multiset.containsAll(known1A1B));     }      @SuppressWarnings("unchecked")     public void testMultiSetSize() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         assertEquals("Should have 0 total items", 0, multiset.size());         multiset.add((T) "A");         assertEquals("Should have 1 total items", 1, multiset.size());         multiset.add((T) "A");         assertEquals("Should have 2 total items", 2, multiset.size());         multiset.add((T) "A");         assertEquals("Should have 3 total items", 3, multiset.size());         multiset.add((T) "B");         assertEquals("Should have 4 total items", 4, multiset.size());         multiset.add((T) "B");         assertEquals("Should have 5 total items", 5, multiset.size());         multiset.remove("A", 2);         assertEquals("Should have 1 'A'", 1, multiset.getCount("A"));         assertEquals("Should have 3 total items", 3, multiset.size());         multiset.remove("B");         assertEquals("Should have 2 total item", 2, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetRetainAll() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         final List<String> retains = new ArrayList<>();         retains.add("B");         retains.add("C");         multiset.retainAll(retains);         assertEquals("Should have 3 total items", 3, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetIterator() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         assertEquals("MultiSet should have 3 items", 3, multiset.size());         final Iterator<T> i = multiset.iterator();          boolean foundA = false;         while (i.hasNext()) {             final String element = (String) i.next();             // ignore the first A, remove the second via Iterator.remove()             if (element.equals("A")) {                 if (!foundA) {                     foundA = true;                 } else {                     i.remove();                 }             }         }          assertTrue("MultiSet should still contain 'A'", multiset.contains("A"));         assertEquals("MultiSet should have 2 items", 2, multiset.size());         assertEquals("MultiSet should have 1 'A'", 1, multiset.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorFail() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         final Iterator<T> it = multiset.iterator();         it.next();         multiset.remove("A");         try {             it.next();             fail("Should throw ConcurrentModificationException");         } catch (final ConcurrentModificationException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorFailNoMore() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         final Iterator<T> it = multiset.iterator();         it.next();         it.next();         it.next();         try {             it.next();             fail("Should throw NoSuchElementException");         } catch (final NoSuchElementException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorFailDoubleRemove() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         final Iterator<T> it = multiset.iterator();         it.next();         it.next();         assertEquals(3, multiset.size());         it.remove();         assertEquals(2, multiset.size());         try {             it.remove();             fail("Should throw IllegalStateException");         } catch (final IllegalStateException ex) {             // expected         }         assertEquals(2, multiset.size());         it.next();         it.remove();         assertEquals(1, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorRemoveProtectsInvariants() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         assertEquals(2, multiset.size());         final Iterator<T> it = multiset.iterator();         assertEquals("A", it.next());         assertEquals(true, it.hasNext());         it.remove();         assertEquals(1, multiset.size());         assertEquals(true, it.hasNext());         assertEquals("A", it.next());         assertEquals(false, it.hasNext());         it.remove();         assertEquals(0, multiset.size());         assertEquals(false, it.hasNext());          final Iterator<T> it2 = multiset.iterator();         assertEquals(false, it2.hasNext());     }      @SuppressWarnings("unchecked")     public void testMultiSetEntrySetUpdatedToZero() {         if (!isAddSupported()) {             return;         }         final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         final MultiSet.Entry<T> entry = multiset.entrySet().iterator().next();         assertEquals(2, entry.getCount());         multiset.remove("A");         assertEquals(1, entry.getCount());         multiset.remove("A");         assertEquals(0, entry.getCount());     }      @SuppressWarnings("unchecked")     public void testMultiSetToArray() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         final Object[] array = multiset.toArray();         int a = 0, b = 0, c = 0;         for (final Object element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      @SuppressWarnings("unchecked")     public void testMultiSetToArrayPopulate() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         final String[] array = multiset.toArray(new String[0]);         int a = 0, b = 0, c = 0;         for (final String element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMultiSetEquals() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final MultiSet<T> multiset2 = makeObject();         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         assertEquals(false, multiset.equals(multiset2));         multiset2.add((T) "A");         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         multiset2.add((T) "A");         multiset2.add((T) "B");         multiset2.add((T) "B");         multiset2.add((T) "C");         assertEquals(true, multiset.equals(multiset2));     }      @SuppressWarnings("unchecked")     public void testMultiSetEqualsHashMultiSet() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final MultiSet<T> multiset2 = new HashMultiSet<>();         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         assertEquals(false, multiset.equals(multiset2));         multiset2.add((T) "A");         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         multiset2.add((T) "A");         multiset2.add((T) "B");         multiset2.add((T) "B");         multiset2.add((T) "C");         assertEquals(true, multiset.equals(multiset2));     }      @SuppressWarnings("unchecked")     public void testMultiSetHashCode() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final MultiSet<T> multiset2 = makeObject();         assertEquals(0, multiset.hashCode());         assertEquals(0, multiset2.hashCode());         assertEquals(multiset.hashCode(), multiset2.hashCode());         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         multiset2.add((T) "A");         multiset2.add((T) "A");         multiset2.add((T) "B");         multiset2.add((T) "B");         multiset2.add((T) "C");         assertEquals(multiset.hashCode(), multiset2.hashCode());          int total = 0;         total += "A".hashCode() ^ 2;         total += "B".hashCode() ^ 2;         total += "C".hashCode() ^ 1;         assertEquals(total, multiset.hashCode());         assertEquals(total, multiset2.hashCode());     }      //-----------------------------------------------------------------------      /**      * Bulk test {@link MultiSet#uniqueSet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the multiset and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the multiset's unique set      */     public BulkTest bulkTestMultiSetUniqueSet() {         return new TestMultiSetUniqueSet();     }      public class TestMultiSetUniqueSet extends AbstractSetTest<T> {         public TestMultiSetUniqueSet() {             super("");         }          @Override         public T[] getFullElements() {             return AbstractMultiSetTest.this.getFullElements();         }          @Override         public T[] getOtherElements() {             return AbstractMultiSetTest.this.getOtherElements();         }          @Override         public Set<T> makeObject() {             return AbstractMultiSetTest.this.makeObject().uniqueSet();         }          @Override         public Set<T> makeFullCollection() {             return AbstractMultiSetTest.this.makeFullCollection().uniqueSet();         }          @Override         public boolean isNullSupported() {             return AbstractMultiSetTest.this.isNullSupported();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiSetTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetEmpty() {             AbstractMultiSetTest.this.resetEmpty();             TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());             TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));         }          @Override         public void resetFull() {             AbstractMultiSetTest.this.resetFull();             TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());             TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));         }          @Override         public void verify() {             super.verify();         }     }      //-----------------------------------------------------------------------      /**      * Compare the current serialized form of the MultiSet      * against the canonical version in SCM.      */     public void testEmptyMultiSetCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final MultiSet<T> multiset = makeObject();         if (multiset instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final MultiSet<?> multiset2 = (MultiSet<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(multiset));             assertTrue("MultiSet is empty", multiset2.size() == 0);             assertEquals(multiset, multiset2);         }     }      /**      * Compare the current serialized form of the MultiSet      * against the canonical version in SCM.      */     public void testFullMultiSetCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final MultiSet<T> multiset = makeFullCollection();         if (multiset instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final MultiSet<?> multiset2 = (MultiSet<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(multiset));             assertEquals("MultiSet is the right size", multiset.size(), multiset2.size());             assertEquals(multiset, multiset2);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import java.util.Arrays;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link UnmodifiableMultiSet} implementation.  *  * @since 4.1  */ public class UnmodifiableMultiSetTest<E> extends AbstractMultiSetTest<E> {      public UnmodifiableMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableMultiSetTest.class);     }      //-----------------------------------------------------------------------     @Override     public MultiSet<E> makeObject() {         return UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<E>());     }      @Override     public MultiSet<E> makeFullCollection() {         final MultiSet<E> multiset = new HashMultiSet<>();         multiset.addAll(Arrays.asList(getFullElements()));         return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);     }      @Override     public MultiSet<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final MultiSet<E> multiset = makeFullCollection();         assertSame(multiset, UnmodifiableMultiSet.unmodifiableMultiSet(multiset));          try {             UnmodifiableMultiSet.unmodifiableMultiSet(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      public void testAdd() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         try {             unmodifiableMultiSet.add((E) "One", 1);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testRemove() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         try {             unmodifiableMultiSet.remove("One", 1);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testSetCount() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         try {             unmodifiableMultiSet.setCount((E) "One", 2);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testEntrySet() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         assertSame( unmodifiableMultiSet.entrySet().size(), multiset.entrySet().size());     }     //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<E> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/UnmodifiableMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/UnmodifiableMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.BulkTest; import org.junit.Ignore;  import junit.framework.Test;  /**  * Extension of {@link AbstractQueueTest} for exercising the {@link SynchronizedQueue} implementation.  *  * @since 4.2  */ public class SynchronizedQueueTest<T> extends AbstractQueueTest<T> {      public static Test suite() {         return BulkTest.makeSuite(SynchronizedQueueTest.class);     }      public SynchronizedQueueTest(final String testName) {         super(testName);     }      // -----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4.2";     }      @Override     public Queue<T> makeObject() {         return SynchronizedQueue.synchronizedQueue(new LinkedList<T>());     }      @Ignore("Run once")     public void testCreate() throws Exception {         Queue<T> queue = makeObject();         writeExternalFormToDisk((java.io.Serializable) queue,             BulkTest.TEST_DATA_PATH + "SynchronizedQueue.emptyCollection.version4.2.obj");         queue = makeFullCollection();         writeExternalFormToDisk((java.io.Serializable) queue,             BulkTest.TEST_DATA_PATH + "SynchronizedQueue.fullCollection.version4.2.obj");     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.Arrays; import java.util.Collections; import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link TransformedQueue} implementation.  *  * @since 4.0  */ public class TransformedQueueTest<E> extends AbstractQueueTest<E> {      public TransformedQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Queue<E> makeConfirmedCollection() {         return new LinkedList<>();     }      @Override     public Queue<E> makeConfirmedFullCollection() {         return new LinkedList<>(Arrays.asList(getFullElements()));     }      @Override     @SuppressWarnings("unchecked")     public Queue<E> makeObject() {         return TransformedQueue.transformingQueue(new LinkedList<E>(),                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public Queue<E> makeFullCollection() {         final Queue<E> list = new LinkedList<>(Arrays.asList(getFullElements()));         return TransformedQueue.transformingQueue(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     public void testTransformedQueue() {         final Queue<Object> queue = TransformedQueue.transformingQueue(new LinkedList<>(),                 TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, queue.size());         final Object[] elements = new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < elements.length; i++) {             queue.add(elements[i]);             assertEquals(i + 1, queue.size());             assertEquals(true, queue.contains(Integer.valueOf((String) elements[i])));             assertEquals(false, queue.contains(elements[i]));         }          assertEquals(false, queue.remove(elements[0]));         assertEquals(true, queue.remove(Integer.valueOf((String) elements[0])));      }      @SuppressWarnings({ "rawtypes", "unchecked" })     public void testTransformedQueue_decorateTransform() {         final Queue originalQueue = new LinkedList();         final Object[] elements = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalQueue, elements);         final Queue<?> queue = TransformedQueue.transformedQueue(originalQueue,                 TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(elements.length, queue.size());         for (final Object el : elements) {             assertEquals(true, queue.contains(Integer.valueOf((String) el)));             assertEquals(false, queue.contains(el));         }          assertEquals(false, queue.remove(elements[0]));         assertEquals(true, queue.remove(Integer.valueOf((String) elements[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //  public void testCreate() throws Exception { //      resetEmpty(); //      writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedQueue.emptyCollection.version4.obj"); //      resetFull(); //      writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedQueue.fullCollection.version4.obj"); //  }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Queue;  /**  * Test cases for CircularFifoQueue.  *  * @since 4.0  */ public class CircularFifoQueueTest<E> extends AbstractQueueTest<E> {      public CircularFifoQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Runs through the regular verifications, but also verifies that      *  the buffer contains the same elements in the same sequence as the      *  list.      */     @Override     public void verify() {         super.verify();         final Iterator<E> iterator1 = getCollection().iterator();         for (final E e : getConfirmed()) {             assertTrue(iterator1.hasNext());             final Object o1 = iterator1.next();             final Object o2 = e;             assertEquals(o1, o2);         }     }      //-----------------------------------------------------------------------     /**      * Overridden because CircularFifoQueue doesn't allow null elements.      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      /**      * Overridden because CircularFifoQueue isn't fail fast.      * @return false      */     @Override     public boolean isFailFastSupported() {         return false;     }      //-----------------------------------------------------------------------     /**      * Returns an empty ArrayList.      *      * @return an empty ArrayList      */     @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full ArrayList.      *      * @return a full ArrayList      */     @Override     public Collection<E> makeConfirmedFullCollection() {         final Collection<E> c = makeConfirmedCollection();         c.addAll(java.util.Arrays.asList(getFullElements()));         return c;     }      /**      * Returns an empty CircularFifoQueue that won't overflow.      *      * @return an empty CircularFifoQueue      */     @Override     public Queue<E> makeObject() {         return new CircularFifoQueue<>(100);     }      //-----------------------------------------------------------------------     /**      * Tests that the removal operation actually removes the first element.      */     @SuppressWarnings("unchecked")     public void testCircularFifoQueueCircular() {         final List<E> list = new ArrayList<>();         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         final Queue<E> queue = new CircularFifoQueue<>(list);          assertEquals(true, queue.contains("A"));         assertEquals(true, queue.contains("B"));         assertEquals(true, queue.contains("C"));          queue.add((E) "D");          assertEquals(false, queue.contains("A"));         assertEquals(true, queue.contains("B"));         assertEquals(true, queue.contains("C"));         assertEquals(true, queue.contains("D"));          assertEquals("B", queue.peek());         assertEquals("B", queue.remove());         assertEquals("C", queue.remove());         assertEquals("D", queue.remove());     }      /**      * Tests that the removal operation actually removes the first element.      */     public void testCircularFifoQueueRemove() {         resetFull();         final int size = getConfirmed().size();         for (int i = 0; i < size; i++) {             final Object o1 = getCollection().remove();             final Object o2 = ((List<?>) getConfirmed()).remove(0);             assertEquals("Removed objects should be equal", o1, o2);             verify();         }          try {             getCollection().remove();             fail("Empty queue should raise Underflow.");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      * Tests that the constructor correctly throws an exception.      */     public void testConstructorException1() {         try {             new CircularFifoQueue<E>(0);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      /**      * Tests that the constructor correctly throws an exception.      */     public void testConstructorException2() {         try {             new CircularFifoQueue<E>(-20);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      /**      * Tests that the constructor correctly throws an exception.      */     public void testConstructorException3() {         try {             new CircularFifoQueue<E>(null);         } catch (final NullPointerException ex) {             return;         }         fail();     }      @SuppressWarnings("unchecked")     public void testRemoveError1() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");          assertEquals("[1, 2, 3, 4, 5]", fifo.toString());          fifo.remove("3");         assertEquals("[1, 2, 4, 5]", fifo.toString());          fifo.remove("4");         assertEquals("[1, 2, 5]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError2() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");         fifo.add((E) "6");          assertEquals(5, fifo.size());         assertEquals("[2, 3, 4, 5, 6]", fifo.toString());          fifo.remove("3");         assertEquals("[2, 4, 5, 6]", fifo.toString());          fifo.remove("4");         assertEquals("[2, 5, 6]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError3() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");          assertEquals("[1, 2, 3, 4, 5]", fifo.toString());          fifo.remove("3");         assertEquals("[1, 2, 4, 5]", fifo.toString());          fifo.add((E) "6");         fifo.add((E) "7");         assertEquals("[2, 4, 5, 6, 7]", fifo.toString());          fifo.remove("4");         assertEquals("[2, 5, 6, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError4() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("4");  // remove element in middle of array, after start         assertEquals("[3, 5, 6, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError5() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("5");  // remove element at last pos in array         assertEquals("[3, 4, 6, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError6() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("6");  // remove element at position zero in array         assertEquals("[3, 4, 5, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError7() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("7");  // remove element at position one in array         assertEquals("[3, 4, 5, 6]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError8() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2         fifo.add((E) "8");  // end=3          assertEquals("[4, 5, 6, 7, 8]", fifo.toString());          fifo.remove("7");  // remove element at position one in array, need to shift 8         assertEquals("[4, 5, 6, 8]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError9() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2         fifo.add((E) "8");  // end=3          assertEquals("[4, 5, 6, 7, 8]", fifo.toString());          fifo.remove("8");  // remove element at position two in array         assertEquals("[4, 5, 6, 7]", fifo.toString());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testRepeatedSerialization() throws Exception {         // bug 31433         final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);         b.add((E) "a");         assertEquals(1, b.size());         assertEquals(true, b.contains("a"));          ByteArrayOutputStream bos = new ByteArrayOutputStream();         new ObjectOutputStream(bos).writeObject(b);          final CircularFifoQueue<E> b2 = (CircularFifoQueue<E>) new ObjectInputStream(             new ByteArrayInputStream(bos.toByteArray())).readObject();          assertEquals(1, b2.size());         assertEquals(true, b2.contains("a"));         b2.add((E) "b");         assertEquals(2, b2.size());         assertEquals(true, b2.contains("a"));         assertEquals(true, b2.contains("b"));          bos = new ByteArrayOutputStream();         new ObjectOutputStream(bos).writeObject(b2);          final CircularFifoQueue<E> b3 = (CircularFifoQueue<E>) new ObjectInputStream(             new ByteArrayInputStream(bos.toByteArray())).readObject();          assertEquals(2, b3.size());         assertEquals(true, b3.contains("a"));         assertEquals(true, b3.contains("b"));         b3.add((E) "c");         assertEquals(2, b3.size());         assertEquals(true, b3.contains("b"));         assertEquals(true, b3.contains("c"));     }      public void testGetIndex() {         resetFull();          final CircularFifoQueue<E> queue = getCollection();         final List<E> confirmed = (List<E>) getConfirmed();         for (int i = 0; i < confirmed.size(); i++) {             assertEquals(confirmed.get(i), queue.get(i));         }          // remove the first two elements and check again         queue.remove();         queue.remove();          for (int i = 0; i < queue.size(); i++) {             assertEquals(confirmed.get(i + 2), queue.get(i));         }     }      public void testAddNull() {         final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);         try {             b.add(null);             fail();         } catch (final NullPointerException ex) {             return;         }         fail();     }      public void testDefaultSizeAndGetError1() {         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();         assertEquals(32, fifo.maxSize());         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");         assertEquals(5, fifo.size());         try {             fifo.get(5);         } catch (final NoSuchElementException ex) {             return;         }         fail();     }      public void testDefaultSizeAndGetError2() {         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();         assertEquals(32, fifo.maxSize());         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");         assertEquals(5, fifo.size());         try {             fifo.get(-2);         } catch (final NoSuchElementException ex) {             return;         }         fail();     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CircularFifoQueue.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CircularFifoQueue.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public CircularFifoQueue<E> getCollection() {         return (CircularFifoQueue<E>) super.getCollection();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableQueue} implementation.  *  * @since 4.0  */ public class UnmodifiableQueueTest<E> extends AbstractQueueTest<E> {      public UnmodifiableQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Queue<E> makeObject() {         return UnmodifiableQueue.unmodifiableQueue(new LinkedList<E>());     }      @Override     public Queue<E> makeFullCollection() {         final Queue<E> queue = new LinkedList<>(Arrays.asList(getFullElements()));         return UnmodifiableQueue.unmodifiableQueue(queue);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new LinkedList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new LinkedList<>(Arrays.asList(getFullElements()));     }      @Override     public Queue<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------     @Override     public void testQueueRemove() {         resetEmpty();         try {             getCollection().remove();             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Queue<E> queue = makeFullCollection();         assertSame(queue, UnmodifiableQueue.unmodifiableQueue(queue));          try {             UnmodifiableQueue.unmodifiableQueue(null);             fail();         } catch (final NullPointerException ex) {}     }      public void testOffer() {         final Queue<E> queue = makeFullCollection();         final E e = null;         try {             queue.offer(e);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testPoll() {         final Queue<E> queue = makeFullCollection();         try {             queue.poll();             fail();         } catch (final UnsupportedOperationException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableQueue.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableQueue.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedList; import java.util.List; import java.util.Queue;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.collection.PredicatedCollectionTest; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link PredicatedCollectionTest} for exercising the  * {@link PredicatedQueue} implementation.  *  * @since 4.0  */ public class PredicatedQueueTest<E> extends AbstractQueueTest<E> {      public PredicatedQueueTest(final String testName) {         super(testName);     }      //---------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected Queue<E> decorateCollection(final Queue<E> queue, final Predicate<E> predicate) {         return PredicatedQueue.predicatedQueue(queue, predicate);     }      @Override     public Queue<E> makeObject() {         return decorateCollection(new LinkedList<E>(), truePredicate);     }      @Override     public Queue<E> makeFullCollection() {         final Queue<E> queue = new LinkedList<>(Arrays.asList(getFullElements()));         return decorateCollection(queue, truePredicate);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new LinkedList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         final List<E> list = new LinkedList<>(Arrays.asList(getFullElements()));         return list;     }      //------------------------------------------------------------      protected Predicate<E> testPredicate = o -> o instanceof String;      public Queue<E> makeTestQueue() {         return decorateCollection(new LinkedList<E>(), testPredicate);     }      @SuppressWarnings("unchecked")     public void testGet() {         final Queue<E> queue = makeTestQueue();          assertNull(queue.peek());          queue.add((E) "one");         queue.add((E) "two");         queue.add((E) "three");         assertEquals("Queue get", "one", queue.peek());     }      @SuppressWarnings("unchecked")     public void testRemove() {         final Queue<E> queue = makeTestQueue();         queue.add((E) "one");         assertEquals("Queue get", "one", queue.poll());         assertNull(queue.peek());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedQueue.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedQueue.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue;  import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Abstract test class for {@link java.util.Queue} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your {@link Queue} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link Queue} fails or override one of the  * protected methods from AbstractCollectionTest.  *  * @since 4.0  */ public abstract class AbstractQueueTest<E> extends AbstractCollectionTest<E> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the <code>set operation.<p>      *  Default implementation returns true.  Override if your collection      *  class does not support set.      */     public boolean isSetSupported() {         return true;     }      //-----------------------------------------------------------------------     /**      *  Verifies that the test queue implementation matches the confirmed queue      *  implementation.      */     @Override     public void verify() {         super.verify();         final Iterator<E> iterator1 = getCollection().iterator();         for (final E e : getConfirmed()) {             assertTrue(iterator1.hasNext());             final Object o1 = iterator1.next();             final Object o2 = e;             assertEquals(o1, o2);         }     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      /**      * Returns {@link #makeObject()}.      *      * @return an empty queue to be used for testing      */     @Override     public abstract Queue<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public Queue<E> makeFullCollection() {         // only works if queue supports optional "addAll(Collection)"         final Queue<E> queue = makeObject();         queue.addAll(Arrays.asList(getFullElements()));         return queue;     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link Queue}.      *      * @return the collection field as a Queue      */     @Override     public Queue<E> getCollection() {         return (Queue<E>) super.getCollection();     }      //-----------------------------------------------------------------------     /**      *  Tests {@link Queue#offer(Object)}.      */     public void testQueueOffer() {         if (!isAddSupported()) {             return;         }          final E[] elements = getFullElements();         for (final E element : elements) {             resetEmpty();             final boolean r = getCollection().offer(element);             getConfirmed().add(element);             verify();             assertTrue("Empty queue changed after add", r);             assertEquals("Queue size is 1 after first add", 1, getCollection().size());         }          resetEmpty();         int size = 0;         for (final E element : elements) {             final boolean r = getCollection().offer(element);             getConfirmed().add(element);             verify();             if (r) {                 size++;             }             assertEquals("Queue size should grow after add", size, getCollection().size());             assertTrue("Queue should contain added element", getCollection().contains(element));         }     }      /**      *  Tests {@link Queue#element()}.      */     public void testQueueElement() {         resetEmpty();          try {             getCollection().element();             fail("Queue.element should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }          resetFull();          assertTrue(getConfirmed().contains(getCollection().element()));          if (!isRemoveSupported()) {             return;         }          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             final E element = getCollection().element();              if (!isNullSupported()) {                 assertNotNull(element);             }              assertTrue(getConfirmed().contains(element));              getCollection().remove(element);             getConfirmed().remove(element);              verify();         }          try {             getCollection().element();             fail("Queue.element should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      *  Tests {@link Queue#peek()}.      */     public void testQueuePeek() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();          E element = getCollection().peek();         assertNull(element);          resetFull();          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             element = getCollection().peek();              if (!isNullSupported()) {                 assertNotNull(element);             }              assertTrue(getConfirmed().contains(element));              getCollection().remove(element);             getConfirmed().remove(element);              verify();         }          element = getCollection().peek();         assertNull(element);     }      /**      *  Tests {@link Queue#remove()}.      */     public void testQueueRemove() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();          try {             getCollection().remove();             fail("Queue.remove should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }          resetFull();          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             final E element = getCollection().remove();             final boolean success = getConfirmed().remove(element);             assertTrue("remove should return correct element", success);             verify();         }          try {             getCollection().element();             fail("Queue.remove should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      *  Tests {@link Queue#poll()}.      */     public void testQueuePoll() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();          E element = getCollection().poll();         assertNull(element);          resetFull();          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             element = getCollection().poll();             final boolean success = getConfirmed().remove(element);             assertTrue("poll should return correct element", success);             verify();         }          element = getCollection().poll();         assertNull(element);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEmptyQueueSerialization() throws IOException, ClassNotFoundException {         final Queue<E> queue = makeObject();         if (!(queue instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) queue);         final Queue<E> queue2 = (Queue<E>) readExternalFormFromBytes(object);          assertEquals("Both queues are empty", 0, queue.size());         assertEquals("Both queues are empty", 0, queue2.size());     }      @SuppressWarnings("unchecked")     public void testFullQueueSerialization() throws IOException, ClassNotFoundException {         final Queue<E> queue = makeFullCollection();         final int size = getFullElements().length;         if (!(queue instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) queue);         final Queue<E> queue2 = (Queue<E>) readExternalFormFromBytes(object);          assertEquals("Both queues are same size", size, queue.size());         assertEquals("Both queues are same size", size, queue2.size());     }      /**      * Compare the current serialized form of the Queue      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testEmptyQueueCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         Queue queue = makeEmptyQueue();         if (!(queue instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) queue, getCanonicalEmptyCollectionName(queue));         */          // test to make sure the canonical form has been preserved         final Queue<E> queue = makeObject();         if (queue instanceof Serializable && !skipSerializedCanonicalTests()                 && isTestSerialization()) {             final Queue<E> queue2 = (Queue<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(queue));             assertEquals("Queue is empty", 0, queue2.size());         }     }      /**      * Compare the current serialized form of the Queue      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testFullQueueCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         Queue queue = makeFullQueue();         if (!(queue instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) queue, getCanonicalFullCollectionName(queue));         */          // test to make sure the canonical form has been preserved         final Queue<E> queue = makeFullCollection();         if (queue instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Queue<E> queue2 = (Queue<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(queue));             assertEquals("Queues are not the right size", queue.size(), queue2.size());         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.multimap.ArrayListValuedHashMap; import org.junit.Test;  /**  * Tests for MultiMapUtils  *  * @since 4.1  */ public class MultiMapUtilsTest {      @Test     @SuppressWarnings({ "unchecked", "rawtypes" })     public void testEmptyUnmodifiableMultiValuedMap() {         final MultiValuedMap map = MultiMapUtils.EMPTY_MULTI_VALUED_MAP;         assertTrue(map.isEmpty());         try {             map.put("key", "value");             fail("Should throw UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testTypeSafeEmptyMultiValuedMap() {         final MultiValuedMap<String, String> map = MultiMapUtils.<String, String>emptyMultiValuedMap();         assertTrue(map.isEmpty());         try {             map.put("key", "value");             fail("Should throw UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testEmptyIfNull() {         assertTrue(MultiMapUtils.emptyIfNull(null).isEmpty());          final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         map.put("item", "value");         assertFalse(MultiMapUtils.emptyIfNull(map).isEmpty());     }      @Test     public void testIsEmptyWithEmptyMap() {         assertTrue(MultiMapUtils.isEmpty(new ArrayListValuedHashMap<>()));     }      @Test     public void testIsEmptyWithNonEmptyMap() {         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         map.put("item", "value");         assertFalse(MultiMapUtils.isEmpty(map));     }      @Test     public void testIsEmptyWithNull() {         assertTrue(MultiMapUtils.isEmpty(null));     }      @Test     public void testGetCollection() {         assertNull(MultiMapUtils.getCollection(null, "key1"));          final String[] values = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);         }          final Collection<String> col = MultiMapUtils.getCollection(map, "key1");         assertEquals(Arrays.asList(values), col);     }      @Test     public void testGetValuesAsList() {         assertNull(MultiMapUtils.getValuesAsList(null, "key1"));          final String[] values = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);         }          final List<String> list = MultiMapUtils.getValuesAsList(map, "key1");         assertEquals(Arrays.asList(values), list);     }      @Test     public void testGetValuesAsSet() {         assertNull(MultiMapUtils.getValuesAsList(null, "key1"));          final String[] values = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);             map.put("key1", val);         }          final Set<String> set = MultiMapUtils.getValuesAsSet(map, "key1");         assertEquals(new HashSet<>(Arrays.asList(values)), set);     }      @Test     public void testGetValuesAsBag() {         assertNull(MultiMapUtils.getValuesAsBag(null, "key1"));          final String values[] = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);             map.put("key1", val);         }          final Bag<String> bag = MultiMapUtils.getValuesAsBag(map, "key1");         assertEquals(6, bag.size());         for (final String val : values) {             assertTrue(bag.contains(val));             assertEquals(2, bag.getCount(val));         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.fail; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.io.ByteArrayOutputStream; import java.io.PrintStream; import java.text.DecimalFormat; import java.text.NumberFormat; import java.util.AbstractMap; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.ListResourceBundle; import java.util.Map; import java.util.Properties; import java.util.ResourceBundle; import java.util.Set; import java.util.SortedMap; import java.util.TreeMap; import org.apache.commons.collections4.collection.TransformedCollectionTest; import org.apache.commons.collections4.keyvalue.DefaultKeyValue; import org.apache.commons.collections4.keyvalue.DefaultMapEntry; import org.apache.commons.collections4.map.HashedMap; import org.apache.commons.collections4.map.LazyMap; import org.apache.commons.collections4.map.MultiValueMap; import org.apache.commons.collections4.map.PredicatedMap; import org.junit.jupiter.api.Test;  /**  * Tests for MapUtils.  */ @SuppressWarnings("boxing") public class MapUtilsTest {     private static final String THREE = "Three";     private static final String TWO = "Two";      public Predicate<Object> getPredicate() {         return o -> o instanceof String;     }      @Test     public void testPredicatedMap() {         final Predicate<Object> p = getPredicate();         final Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<>(), p, p);         assertTrue(map instanceof PredicatedMap);         try {             MapUtils.predicatedMap(null, p, p);             fail("Expecting NullPointerException for null map.");         } catch (final NullPointerException e) {             // expected         }     }      @Test     public void testLazyMapFactory() {         final Factory<Integer> factory = FactoryUtils.constantFactory(Integer.valueOf(5));         Map<Object, Object> map = MapUtils.lazyMap(new HashMap<>(), factory);         assertTrue(map instanceof LazyMap);         try {             MapUtils.lazyMap(new HashMap<>(), (Factory<Object>) null);             fail("Expecting NullPointerException for null factory");         } catch (final NullPointerException e) {             // expected         }         try {             MapUtils.lazyMap((Map<Object, Object>) null, factory);             fail("Expecting NullPointerException for null map");         } catch (final NullPointerException e) {             // expected         }         final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);         map = MapUtils.lazyMap(new HashMap<>(), transformer);         assertTrue(map instanceof LazyMap);         try {             MapUtils.lazyMap(new HashMap<>(), (Transformer<Object, Object>) null);             fail("Expecting NullPointerException for null transformer");         } catch (final NullPointerException e) {             // expected         }         try {             MapUtils.lazyMap((Map<Object, Object>) null, transformer);             fail("Expecting NullPointerException for null map");         } catch (final NullPointerException e) {             // expected         }     }      @Test     public void testLazyMapTransformer() {         final Map<Object, Object> map = MapUtils.lazyMap(new HashMap<>(), (Transformer<Object, Object>) mapKey -> {             if (mapKey instanceof String) {                 return Integer.valueOf((String) mapKey);             }             return null;         });          assertEquals(0, map.size());         final Integer i1 = (Integer) map.get("5");         assertEquals(Integer.valueOf(5), i1);         assertEquals(1, map.size());         final Integer i2 = (Integer) map.get(new String(new char[] {'5'}));         assertEquals(Integer.valueOf(5), i2);         assertEquals(1, map.size());         assertSame(i1, i2);     }      @Test     public void testInvertMap() {         final Map<String, String> in = new HashMap<>(5, 1);         in.put("1", "A");         in.put("2", "B");         in.put("3", "C");         in.put("4", "D");         in.put("5", "E");          final Set<String> inKeySet = new HashSet<>(in.keySet());         final Set<String> inValSet = new HashSet<>(in.values());          final Map<String, String> out = MapUtils.invertMap(in);          final Set<String> outKeySet = new HashSet<>(out.keySet());         final Set<String> outValSet = new HashSet<>(out.values());          assertEquals(inKeySet, outValSet);         assertEquals(inValSet, outKeySet);          assertEquals("1", out.get("A"));         assertEquals("2", out.get("B"));         assertEquals("3", out.get("C"));         assertEquals("4", out.get("D"));         assertEquals("5", out.get("E"));     }      @Test     public void testInvertEmptyMap() {         final Map<String, String> emptyMap = new HashMap<>();         final Map<String, String> resultMap = MapUtils.invertMap(emptyMap);         assertEquals(emptyMap, resultMap);     }      @Test     public void testInvertMapNull() {         final Map<String, String> nullMap = null;         final Exception exception = assertThrows(NullPointerException.class, () -> {             MapUtils.invertMap(nullMap);         });         final String actualMessage = exception.getMessage();         assertTrue(actualMessage.contains("map"));     }      @Test     public void testPutAll_Map_array() {         try {             MapUtils.putAll(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             MapUtils.putAll(null, new Object[0]);             fail();         } catch (final NullPointerException ex) {}          Map<String, String> test = MapUtils.putAll(new HashMap<String, String>(), new String[0]);         assertEquals(0, test.size());          // sub array         test = MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 {"GREEN", "#00FF00"},                 {"BLUE", "#0000FF"}         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          try {             MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 null,                 {"BLUE", "#0000FF"}             });             fail();         } catch (final IllegalArgumentException ex) {}          try {             MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 {"GREEN"},                 {"BLUE", "#0000FF"}             });             fail();         } catch (final IllegalArgumentException ex) {}          try {             MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 {},                 {"BLUE", "#0000FF"}             });             fail();         } catch (final IllegalArgumentException ex) {}          // flat array         test = MapUtils.putAll(new HashMap<String, String>(), new String[] {             "RED", "#FF0000",             "GREEN", "#00FF00",             "BLUE", "#0000FF"         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          test = MapUtils.putAll(new HashMap<String, String>(), new String[] {             "RED", "#FF0000",             "GREEN", "#00FF00",             "BLUE", "#0000FF",             "PURPLE" // ignored         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          test = MapUtils.putAll(new HashMap<String, String>(), null);         assertEquals(0, test.size());          // map entry         test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {             new DefaultMapEntry<>("RED", "#FF0000"),             new DefaultMapEntry<>("GREEN", "#00FF00"),             new DefaultMapEntry<>("BLUE", "#0000FF")         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          // key value         test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {             new DefaultKeyValue<>("RED", "#FF0000"),             new DefaultKeyValue<>("GREEN", "#00FF00"),             new DefaultKeyValue<>("BLUE", "#0000FF")         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());     }      @Test     public void testConvertResourceBundle() {         final Map<String, String> in = new HashMap<>(5, 1);         in.put("1", "A");         in.put("2", "B");         in.put("3", "C");         in.put("4", "D");         in.put("5", "E");          final ResourceBundle b = new ListResourceBundle() {             @Override             public Object[][] getContents() {                 final Object[][] contents = new Object[in.size()][2];                 final Iterator<String> i = in.keySet().iterator();                 int n = 0;                 while (i.hasNext()) {                     final Object key = i.next();                     final Object val = in.get(key);                     contents[n][0] = key;                     contents[n][1] = val;                     ++n;                 }                 return contents;             }         };          final Map<String, Object> out = MapUtils.toMap(b);          assertEquals(in, out);     }      @Test     public void testDebugAndVerbosePrintCasting() {         final Map<Integer, String> inner = new HashMap<>(2, 1);         inner.put(2, "B");         inner.put(3, "C");          final Map<Integer, Object> outer = new HashMap<>(2, 1);         outer.put(0, inner);         outer.put(1, "A");          final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          try {             MapUtils.debugPrint(outPrint, "Print Map", outer);         } catch (final ClassCastException e) {             fail("No Casting should be occurring!");         }     }      @Test     public void testDebugAndVerbosePrintNullMap() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         outPrint.println(LABEL + " = " + String.valueOf((Object) null));         final String EXPECTED_OUT = out.toString();          out.reset();          MapUtils.debugPrint(outPrint, LABEL, null);         assertEquals(EXPECTED_OUT, out.toString());          out.reset();          MapUtils.verbosePrint(outPrint, LABEL, null);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullLabel() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Integer, String> map = new TreeMap<>(); // treeMap guarantees order across JDKs for test         map.put(2, "B");         map.put(3, "C");         map.put(4, null);          outPrint.println("{");         outPrint.println(INDENT + "2 = B");         outPrint.println(INDENT + "3 = C");         outPrint.println(INDENT + "4 = null");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullLabel() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Integer, String> map = new TreeMap<>(); // treeMap guarantees order across JDKs for test         map.put(2, "B");         map.put(3, "C");         map.put(4, null);          outPrint.println("{");         outPrint.println(INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + "3 = C " + String.class.getName());         outPrint.println(INDENT + "4 = null");         outPrint.println("} " + TreeMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullLabelAndMap() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          outPrint.println("null");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, null);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullLabelAndMap() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          outPrint.println("null");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, null);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullStream() {         try {             MapUtils.verbosePrint(null, "Map", new HashMap<>());             fail("Should generate NullPointerException");         } catch (final NullPointerException expected) {         }     }      @Test     public void testDebugPrintNullStream() {         try {             MapUtils.debugPrint(null, "Map", new HashMap<>());             fail("Should generate NullPointerException");         } catch (final NullPointerException expected) {         }     }      @Test     public void testDebugPrintNullKey() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, String> map = new HashMap<>();         map.put(null, "A");          outPrint.println("{");         outPrint.println(INDENT + "null = A " + String.class.getName());         outPrint.println("} " + HashMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullKey() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, String> map = new HashMap<>();         map.put(null, "A");          outPrint.println("{");         outPrint.println(INDENT + "null = A");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullKeyToMap1() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Map<?, ?>> map = new HashMap<>();         map.put(null, map);          outPrint.println("{");         outPrint.println(INDENT + "null = (this Map) " + HashMap.class.getName());         outPrint.println("} " + HashMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullKeyToMap1() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Map<?, ?>> map = new HashMap<>();         map.put(null, map);          outPrint.println("{");         outPrint.println(INDENT + "null = (this Map)");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullKeyToMap2() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Object> map = new HashMap<>();         final Map<Object, Object> map2= new HashMap<>();         map.put(null, map2);         map2.put("2", "B");          outPrint.println("{");         outPrint.println(INDENT + "null = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + "} " + HashMap.class.getName());         outPrint.println("} " + HashMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullKeyToMap2() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Object> map = new HashMap<>();         final Map<Object, Object> map2 = new HashMap<>();         map.put(null, map2);         map2.put("2", "B");          outPrint.println("{");         outPrint.println(INDENT + "null = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B");         outPrint.println(INDENT + "}");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrint() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A");         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B");         outPrint.println(INDENT + INDENT + "3 = C");         outPrint.println(INDENT + "}");         outPrint.println(INDENT + "7 = (this Map)");         outPrint.println("}");          final String EXPECTED_OUT = out.toString();          out.reset();          final Map<Integer, String> inner = new TreeMap<>(); // treeMap guarantees order across JDKs for test         inner.put(2, "B");         inner.put(3, "C");          final Map<Integer, Object> outer = new TreeMap<>();         outer.put(1, inner);         outer.put(0, "A");         outer.put(7, outer);          MapUtils.verbosePrint(outPrint, "Print Map", outer);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrint() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A " + String.class.getName());         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + INDENT + "3 = C " + String.class.getName());         outPrint.println(INDENT + "} " + TreeMap.class.getName());         outPrint.println(INDENT + "7 = (this Map) " + TreeMap.class.getName());         outPrint.println("} " + TreeMap.class.getName());          final String EXPECTED_OUT = out.toString();          out.reset();          final Map<Integer, String> inner = new TreeMap<>(); // treeMap guarantees order across JDKs for test         inner.put(2, "B");         inner.put(3, "C");          final Map<Integer, Object> outer = new TreeMap<>();         outer.put(1, inner);         outer.put(0, "A");         outer.put(7, outer);          MapUtils.debugPrint(outPrint, "Print Map", outer);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintSelfReference() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          final Map<Integer, Object> grandfather = new TreeMap<>(); // treeMap guarantees order across JDKs for test         final Map<Integer, Object> father = new TreeMap<>();         final Map<Integer, Object> son    = new TreeMap<>();          grandfather.put(0, "A");         grandfather.put(1, father);          father.put(2, "B");         father.put(3, grandfather);         father.put(4, son);          son.put(5, "C");         son.put(6, grandfather);         son.put(7, father);          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A");         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B");         outPrint.println(INDENT + INDENT + "3 = (ancestor[0] Map)");         outPrint.println(INDENT + INDENT + "4 = ");         outPrint.println(INDENT + INDENT + "{");         outPrint.println(INDENT + INDENT + INDENT + "5 = C");         outPrint.println(INDENT + INDENT + INDENT + "6 = (ancestor[1] Map)");         outPrint.println(INDENT + INDENT + INDENT + "7 = (ancestor[0] Map)");         outPrint.println(INDENT + INDENT + "}");         outPrint.println(INDENT + "}");         outPrint.println("}");          final String EXPECTED_OUT = out.toString();          out.reset();         MapUtils.verbosePrint(outPrint, "Print Map", grandfather);          assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintSelfReference() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          final Map<Integer, Object> grandfather = new TreeMap<>(); // treeMap guarantees order across JDKs for test         final Map<Integer, Object> father = new TreeMap<>();         final Map<Integer, Object> son    = new TreeMap<>();          grandfather.put(0, "A");         grandfather.put(1, father);          father.put(2, "B");         father.put(3, grandfather);         father.put(4, son);          son.put(5, "C");         son.put(6, grandfather);         son.put(7, father);          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A " + String.class.getName());         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + INDENT + "3 = (ancestor[0] Map) " + TreeMap.class.getName());         outPrint.println(INDENT + INDENT + "4 = ");         outPrint.println(INDENT + INDENT + "{");         outPrint.println(INDENT + INDENT + INDENT + "5 = C " + String.class.getName());         outPrint.println(INDENT + INDENT + INDENT + "6 = (ancestor[1] Map) " + TreeMap.class.getName());         outPrint.println(INDENT + INDENT + INDENT + "7 = (ancestor[0] Map) " + TreeMap.class.getName());         outPrint.println(INDENT + INDENT + "} " + TreeMap.class.getName());         outPrint.println(INDENT + "} " + TreeMap.class.getName());         outPrint.println("} " + TreeMap.class.getName());          final String EXPECTED_OUT = out.toString();          out.reset();         MapUtils.debugPrint(outPrint, "Print Map", grandfather);          assertEquals(EXPECTED_OUT, out.toString());     }      //-----------------------------------------------------------------------      @Test     public void testEmptyIfNull() {         assertTrue(MapUtils.emptyIfNull(null).isEmpty());          final Map<Long, Long> map = new HashMap<>();         assertSame(map, MapUtils.emptyIfNull(map));     }      @Test     public void testIsEmptyWithEmptyMap() {         final Map<Object, Object> map = new HashMap<>();         assertTrue(MapUtils.isEmpty(map));     }      @Test     public void testIsEmptyWithNonEmptyMap() {         final Map<String, String> map = new HashMap<>();         map.put("item", "value");         assertFalse(MapUtils.isEmpty(map));     }      @Test     public void testIsEmptyWithNull() {         final Map<Object, Object> map = null;         assertTrue(MapUtils.isEmpty(map));     }      @Test     public void testIsNotEmptyWithEmptyMap() {         final Map<Object, Object> map = new HashMap<>();         assertFalse(MapUtils.isNotEmpty(map));     }      @Test     public void testIsNotEmptyWithNonEmptyMap() {         final Map<String, String> map = new HashMap<>();         map.put("item", "value");         assertTrue(MapUtils.isNotEmpty(map));     }      @Test     public void testIsNotEmptyWithNull() {         final Map<Object, Object> map = null;         assertFalse(MapUtils.isNotEmpty(map));     }      @Test     public void testPopulateMap() {         // Setup Test Data         final List<String> list = new ArrayList<>();         list.add("1");         list.add("3");         list.add("5");         list.add("7");         list.add("2");         list.add("4");         list.add("6");          // Now test key transform population         Map<Object, Object> map = new HashMap<>();         MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(list.size(), map.size());          for (final String element : list) {             assertTrue(map.containsKey(Integer.valueOf(element)));             assertFalse(map.containsKey(element));             assertTrue(map.containsValue(element));             assertEquals(element, map.get(Integer.valueOf(element)));         }          // Now test both Key-Value transform population         map = new HashMap<>();         MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);          assertEquals(list.size(), map.size());         for (final String element : list) {             assertTrue(map.containsKey(Integer.valueOf(element)));             assertFalse(map.containsKey(element));             assertTrue(map.containsValue(Integer.valueOf(element)));             assertEquals(Integer.valueOf(element), map.get(Integer.valueOf(element)));         }     }      /**      * Test class for populateMap(MultiMap).      */     static class X implements Comparable<X> {         int key;         String name;          X(final int key, final String name) {             this.key = key;             this.name = name;         }          @Override         public int compareTo(final X o) {             return key - o.key | name.compareTo(o.name);         }     }      @Test     public void testPopulateMultiMap() {         // Setup Test Data         final List<X> list = new ArrayList<>();         list.add(new X(1, "x1"));         list.add(new X(2, "x2"));         list.add(new X(2, "x3"));         list.add(new X(5, "x4"));         list.add(new X(5, "x5"));          // Now test key transform population         final MultiValueMap<Integer, X> map = MultiValueMap.multiValueMap(new TreeMap<Integer, Collection<X>>());         MapUtils.populateMap(map, list, (Transformer<X, Integer>) input -> input.key, TransformerUtils.<X>nopTransformer());         assertEquals(list.size(), map.totalSize());          for (final X element : list) {             assertTrue(map.containsKey(element.key));             assertTrue(map.containsValue(element));         }     }      @Test     public void testIterableMap() {         try {             MapUtils.iterableMap(null);             fail("Should throw NullPointerException");         } catch (final NullPointerException e) {         }         final HashMap<String, String> map = new HashMap<>();         map.put("foo", "foov");         map.put("bar", "barv");         map.put("baz", "bazv");         final IterableMap<String, String> iMap = MapUtils.iterableMap(map);         assertEquals(map, iMap);         assertNotSame(map, iMap);         final HashedMap<String, String> hMap = new HashedMap<>(map);         assertSame(hMap, MapUtils.iterableMap(hMap));     }      @Test     public void testIterableSortedMap() {         try {             MapUtils.iterableSortedMap(null);             fail("Should throw NullPointerException");         } catch (final NullPointerException e) {         }         final TreeMap<String, String> map = new TreeMap<>();         map.put("foo", "foov");         map.put("bar", "barv");         map.put("baz", "bazv");         final IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);         assertEquals(map, iMap);         assertNotSame(map, iMap);         assertSame(iMap, MapUtils.iterableMap(iMap));     }      @Test     public void testLazyMap() {         final Map<String, Integer> lazyMap = MapUtils.lazyMap(new HashMap<>(), () -> 1);         lazyMap.put(TWO, 2);          assertEquals(Integer.valueOf(2), lazyMap.get(TWO));         assertEquals(Integer.valueOf(1), lazyMap.get(THREE));     }      @Test     public void testLazySortedMapFactory() {         final SortedMap<String, Integer> lazySortedMap = MapUtils.lazySortedMap(new TreeMap<>(), () -> 1);         lazySortedMap.put(TWO, 2);          assertEquals(Integer.valueOf(2), lazySortedMap.get(TWO));         assertEquals(Integer.valueOf(1), lazySortedMap.get(THREE));          final Set<Map.Entry<String, Integer>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(THREE, 1));         entrySet.add(new AbstractMap.SimpleEntry<>(TWO, 2));          assertEquals(entrySet, lazySortedMap.entrySet());     }      @Test     public void testLazySortedMapTransformer() {         final SortedMap<String, Integer> lazySortedMap = MapUtils.lazySortedMap(new TreeMap<>(), s -> 1);         lazySortedMap.put(TWO, 2);          assertEquals(Integer.valueOf(2), lazySortedMap.get(TWO));         assertEquals(Integer.valueOf(1), lazySortedMap.get(THREE));          final Set<Map.Entry<String, Integer>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(THREE, 1));         entrySet.add(new AbstractMap.SimpleEntry<>(TWO, 2));          assertEquals(entrySet, lazySortedMap.entrySet());     }      @Test     public void testSize0() {         assertEquals(0, MapUtils.size(new HashMap<>()));     }      @Test     public void testSizeNull() {         assertEquals(0, MapUtils.size(null));     }      @Test     public void testSize() {         final HashMap<Object, Object> map = new HashMap<>();         map.put("A", "1");         map.put("B", "2");         assertEquals(2, MapUtils.size(map));     }      @Test     public void testToProperties() {         final Map<String, String> in = new HashMap<>();         in.put("key1", "A");         in.put("key2", "B");         in.put("key3", "C");          final Properties out =  MapUtils.toProperties(in);          assertEquals(in.get("key1"), out.get("key1"));         assertEquals(in.get("key2"), out.get("key2"));         assertEquals(in.get("key3"), out.get("key3"));     }      @Test     public void testToPropertiesEmpty() {         final Map<String, String> in = null;         final Properties out =  MapUtils.toProperties(in);          assertEquals(out.size(), 0);     }      @Test     public void testTransformedMap() {         final Map<Long, Long> map = new HashMap<>();          final Map<Long, Long> transformedMap = MapUtils.transformedMap(map, i -> i + 1, i -> i + 10);         transformedMap.put(1L, 100L);          final Set<Map.Entry<Long, Long>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(2L, 110L));          assertEquals(entrySet, transformedMap.entrySet());     }      @Test     public void testTransformedSortedMap() {         final SortedMap<Long, Long> sortedMap = new TreeMap<>();          final SortedMap<Long, Long> transformedSortedMap = MapUtils.transformedSortedMap(sortedMap, i -> i + 1, i -> i + 10);         transformedSortedMap.put(2L, 200L);         transformedSortedMap.put(1L, 100L);          final Set<Map.Entry<Long, Long>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(2L, 110L));         entrySet.add(new AbstractMap.SimpleEntry<>(3L, 210L));          assertEquals(entrySet, transformedSortedMap.entrySet());     }      @Test     public void testUnmodifiableMap() {         final Exception exception = assertThrows(UnsupportedOperationException.class, () -> {             MapUtils.unmodifiableMap(new HashMap<>()).clear();         });     }      @Test     public void testUnmodifiableSortedMap() {         final Exception exception = assertThrows(UnsupportedOperationException.class, () -> {             MapUtils.unmodifiableSortedMap(new TreeMap<>()).clear();         });     }      @Test     public void testFixedSizeMap() {         final Exception exception = assertThrows(IllegalArgumentException.class, () -> {             MapUtils.fixedSizeMap(new HashMap<>()).put(new Object(), new Object());         });     }      @Test     public void testFixedSizeSortedMap() {         final Exception exception = assertThrows(IllegalArgumentException.class, () -> {             MapUtils.fixedSizeSortedMap(new TreeMap<Long, Long>()).put(1L, 1L);         });     }      @Test     public void testGetNumberValueWithInvalidString() {         final Map<String, String> map = new HashMap<>();         map.put("key", "one");          assertNull(MapUtils.getNumber(map, "key"));     }      @Test     public void testGetDoubleValue() {         final Map<String, Double> in = new HashMap<>();         in.put("key", 2.0);          assertEquals(2.0, MapUtils.getDoubleValue(in, "key", 0.0), 0);         assertEquals(2.0, MapUtils.getDoubleValue(in, "key"), 0);         assertEquals(1.0, MapUtils.getDoubleValue(in, "noKey", 1.0), 0);         assertEquals(5.0, MapUtils.getDoubleValue(in, "noKey", key -> 5.0D), 0);          assertEquals(0, MapUtils.getDoubleValue(in, "noKey"), 0);         assertEquals(2.0, MapUtils.getDouble(in, "key", 0.0), 0);         assertEquals(1.0, MapUtils.getDouble(in, "noKey", 1.0), 0);         assertEquals(1.0, MapUtils.getDouble(in, "noKey", key -> 1.0), 0);           final Map<String, String> inStr = new HashMap<>();         final char decimalSeparator = getDecimalSeparator();         inStr.put("str1", "2" + decimalSeparator + "0");          assertEquals(MapUtils.getDoubleValue(inStr, "str1", 0.0), 2.0, 0);     }      @Test     public void testGetFloatValue() {         final Map<String, Float> in = new HashMap<>();         in.put("key", 2.0f);          assertEquals(2.0, MapUtils.getFloatValue(in, "key", 0.0f), 0);         assertEquals(2.0, MapUtils.getFloatValue(in, "key"), 0);         assertEquals(1.0, MapUtils.getFloatValue(in, "noKey", 1.0f), 0);         assertEquals(1.0, MapUtils.getFloatValue(in, "noKey", key -> 1.0F), 0);         assertEquals(0, MapUtils.getFloatValue(in, "noKey"), 0);         assertEquals(2.0, MapUtils.getFloat(in, "key", 0.0f), 0);         assertEquals(1.0, MapUtils.getFloat(in, "noKey", 1.0f), 0);         assertEquals(1.0, MapUtils.getFloat(in, "noKey", key -> 1.0F), 0);          final Map<String, String> inStr = new HashMap<>();         final char decimalSeparator = getDecimalSeparator();         inStr.put("str1", "2" + decimalSeparator + "0");          assertEquals(MapUtils.getFloatValue(inStr, "str1", 0.0f), 2.0, 0);     }      @Test     public void testGetLongValue() {         final Map<String, Long> in = new HashMap<>();         in.put("key", 2L);          assertEquals(2.0, MapUtils.getLongValue(in, "key", 0L), 0);         assertEquals(2.0, MapUtils.getLongValue(in, "key"), 0);         assertEquals(1, MapUtils.getLongValue(in, "noKey", 1L), 0);         assertEquals(1, MapUtils.getLongValue(in, "noKey", key -> 1L), 0);         assertEquals(0, MapUtils.getLongValue(in, "noKey"), 0);         assertEquals(2.0, MapUtils.getLong(in, "key", 0L), 0);         assertEquals(1, MapUtils.getLong(in, "noKey", 1L), 0);         assertEquals(1, MapUtils.getLong(in, "noKey", key -> 1L), 0);          final Map<String, Number> in1 = new HashMap<>();         in1.put("key", 2);          assertEquals(Long.valueOf(2), MapUtils.getLong(in1, "key"));          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "2");          assertEquals(MapUtils.getLongValue(inStr, "str1", 0L), 2, 0);         assertEquals(MapUtils.getLong(inStr, "str1", 1L), 2, 0);      }      @Test     public void testGetIntValue() {         final Map<String, Integer> in = new HashMap<>();         in.put("key", 2);          assertEquals(2, MapUtils.getIntValue(in, "key", 0), 0);         assertEquals(2, MapUtils.getIntValue(in, "key"), 0);         assertEquals(0, MapUtils.getIntValue(in, "noKey", 0), 0);         assertEquals(0, MapUtils.getIntValue(in, "noKey", key -> 0), 0);         assertEquals(0, MapUtils.getIntValue(in, "noKey"), 0);         assertEquals(2, MapUtils.getInteger(in, "key", 0), 0);         assertEquals(0, MapUtils.getInteger(in, "noKey", 0), 0);         assertEquals(0, MapUtils.getInteger(in, "noKey", key -> 0), 0);          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "2");          assertEquals(MapUtils.getIntValue(inStr, "str1", 0), 2, 0);     }      @Test     public void testGetShortValue() {         final Map<String, Short> in = new HashMap<>();         final short val = 10;         in.put("key", val);          assertEquals(val, MapUtils.getShortValue(in, "key", val), 0);         assertEquals(val, MapUtils.getShortValue(in, "key"), 0);         assertEquals(val, MapUtils.getShortValue(in, "noKey", val), 0);         assertEquals(val, MapUtils.getShortValue(in, "noKey", key -> val), 0);         assertEquals(0, MapUtils.getShortValue(in, "noKey"), 0);         assertEquals(val, MapUtils.getShort(in, "key", val), 0);         assertEquals(val, MapUtils.getShort(in, "noKey", val), 0);         assertEquals(val, MapUtils.getShort(in, "noKey", key -> val), 0);          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "10");          assertEquals(MapUtils.getShortValue(inStr, "str1", val), val, 0);     }      @Test     public void testGetByteValue() {         final Map<String, Byte> in = new HashMap<>();         final byte val = 100;         in.put("key", val);          assertEquals(val, MapUtils.getByteValue(in, "key", val), 0);         assertEquals(val, MapUtils.getByteValue(in, "key"), 0);         assertEquals(val, MapUtils.getByteValue(in, "noKey", val), 0);         assertEquals(val, MapUtils.getByteValue(in, "noKey", key -> ((byte) 100)), 0);         assertEquals(0, MapUtils.getByteValue(in, "noKey"), 0);         assertEquals(val, MapUtils.getByte(in, "key", val), 0);         assertEquals(val, MapUtils.getByte(in, "noKey", val), 0);         assertEquals(val, MapUtils.getByte(in, "noKey", key -> val), 0);           final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "100");          assertEquals(MapUtils.getByteValue(inStr, "str1", val), val, 0);     }      @Test     public void testGetNumber() {         final Map<String, Number> in = new HashMap<>();         final Number val = 1000;         in.put("key", val);          assertEquals(val.intValue(), MapUtils.getNumber(in, "key", val).intValue(), 0);         assertEquals(val.intValue(), MapUtils.getNumber(in, "noKey", val).intValue(), 0);         assertEquals(val.intValue(), MapUtils.getNumber(in, "noKey", key -> {             if (true) {                 return val;             } else {                 return null;             }         }).intValue(), 0);      }      @Test     public void testGetString() {         final Map<String, String> in = new HashMap<>();         in.put("key", "str");          assertEquals("str", MapUtils.getString(in, "key", "default"));         assertEquals("str", MapUtils.getString(in, "key"));         assertNull(MapUtils.getString(null, "key"));         assertEquals("default", MapUtils.getString(in, "noKey", "default"));         assertEquals("default", MapUtils.getString(in, "noKey", key -> {             if ("noKey".equals(key)) {                 return "default";             } else {                 return "";             }         }));         assertEquals("default", MapUtils.getString(null, "noKey", "default"));     }      @Test     public void testGetObject() {         final Map<String, Object> in = new HashMap<>();         in.put("key", "str");          assertEquals("str", MapUtils.getObject(in, "key", "default"));         assertEquals("str", MapUtils.getObject(in, "key"));         assertNull(MapUtils.getObject(null, "key"));         assertEquals("default", MapUtils.getObject(in, "noKey", "default"));         assertEquals("default", MapUtils.getObject(null, "noKey", "default"));     }      @Test     public void testGetBooleanValue() {         final Map<String, Object> in = new HashMap<>();         in.put("key", true);         in.put("keyNumberTrue", 1);         in.put("keyNumberFalse", 0);         in.put("keyUnmapped", new Object());          assertFalse(MapUtils.getBooleanValue(null, "keyString", null));         assertFalse(MapUtils.getBooleanValue(in, null, null));         assertFalse(MapUtils.getBooleanValue(null, null, null));         assertTrue(MapUtils.getBooleanValue(in, "key", true));         assertTrue(MapUtils.getBooleanValue(in, "key"));         assertTrue(MapUtils.getBooleanValue(in, "noKey", true));         assertTrue(MapUtils.getBooleanValue(in, "noKey", key -> true));         assertFalse(MapUtils.getBooleanValue(in, "noKey"));         assertTrue(MapUtils.getBoolean(in, "key", true));         assertTrue(MapUtils.getBoolean(in, "noKey", true));         assertTrue(MapUtils.getBoolean(in, "noKey", key -> {             if (System.currentTimeMillis() > 0) {                 return true;             }             return false;         }));         assertNull(MapUtils.getBoolean(in, "noKey", key -> null));         assertFalse(MapUtils.getBooleanValue(in, "noKey", key -> null));         assertNull(MapUtils.getBoolean(null, "noKey"));         // Values are Numbers         assertFalse(MapUtils.getBoolean(in, "keyNumberFalse"));         assertTrue(MapUtils.getBoolean(in, "keyNumberTrue"));         assertNull(MapUtils.getBoolean(in, "keyString"));         assertNull(MapUtils.getBoolean(null, "keyString"));         assertNull(MapUtils.getBoolean(in, null));         assertNull(MapUtils.getBoolean(null, null));          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "true");          assertTrue(MapUtils.getBooleanValue(inStr, "str1", true));         assertTrue(MapUtils.getBoolean(inStr, "str1", true));     }      @Test     public void testGetMap() {         final Map<String, Map<String, String>> in = new HashMap<>();         final Map<String, String> valMap = new HashMap<>();         valMap.put("key1", "value1");         in.put("key1", valMap);         final Map<?, ?> outValue =  MapUtils.getMap(in, "key1", (Map<?, ?>) null);          assertEquals("value1", outValue.get("key1"));         assertNull(outValue.get("key2"));         assertNull(MapUtils.getMap(in, "key2", (Map<?, ?>) null));         assertNull(MapUtils.getMap(null, "key2", (Map<?, ?>) null));     }      @Test     public void testSafeAddToMap() {          final Map<String, Object> inMap = new HashMap<>();          MapUtils.safeAddToMap(inMap, "key1", "value1");         MapUtils.safeAddToMap(inMap, "key2", null);         assertEquals("value1", inMap.get("key1"));         assertEquals("", inMap.get("key2"));     }      @Test     public void testOrderedMap() {         final Map<String, String> inMap = new HashMap<>();         inMap.put("key1", "value1");         inMap.put("key2", "value2");         final Map<String, String> map = MapUtils.orderedMap(inMap);         assertTrue(map instanceof OrderedMap);     }      private char getDecimalSeparator() {         final NumberFormat numberFormat = NumberFormat.getInstance();         if (numberFormat instanceof DecimalFormat) {             return ((DecimalFormat) numberFormat).getDecimalFormatSymbols().getDecimalSeparator();         }         return '.';     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.sequence;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Random;  import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class SequencesComparatorTest {      private List<String> before;     private List<String> after;     private int[]        length;      @Test     public void testLength() {         for (int i = 0; i < before.size(); ++i) {             final SequencesComparator<Character> comparator =                     new SequencesComparator<>(sequence(before.get(i)),                             sequence(after.get(i)));             Assert.assertEquals(length[i], comparator.getScript().getModifications());         }     }      @Test     public void testExecution() {         final ExecutionVisitor<Character> ev = new ExecutionVisitor<>();         for (int i = 0; i < before.size(); ++i) {             ev.setList(sequence(before.get(i)));             new SequencesComparator<>(sequence(before.get(i)),                     sequence(after.get(i))).getScript().visit(ev);             Assert.assertEquals(after.get(i), ev.getString());         }     }      @Test     public void testMinimal() {         final String[] shadokAlph = new String[] {             "GA",             "BU",             "ZO",             "MEU"         };         final List<String> sentenceBefore = new ArrayList<>();         final List<String> sentenceAfter  = new ArrayList<>();         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[3]);          final Random random = new Random(4564634237452342L);          for (int nbCom = 0; nbCom <= 40; nbCom+=5) {             sentenceAfter.clear();             sentenceAfter.addAll(sentenceBefore);             for (int i = 0; i<nbCom; i++) {                 if (random.nextInt(2) == 0) {                     sentenceAfter.add(random.nextInt(sentenceAfter.size() + 1),                                       shadokAlph[random.nextInt(4)]);                 } else {                     sentenceAfter.remove(random.nextInt(sentenceAfter.size()));                 }             }              final SequencesComparator<String> comparator =                     new SequencesComparator<>(sentenceBefore, sentenceAfter);             Assert.assertTrue(comparator.getScript().getModifications() <= nbCom);         }     }      @Test     public void testShadok() {         final int lgMax = 5;         final String[] shadokAlph = new String[] {             "GA",             "BU",             "ZO",             "MEU"         };         List<List<String>> shadokSentences = new ArrayList<>();         for (int lg=0; lg<lgMax; ++lg) {             final List<List<String>> newTab = new ArrayList<>();             newTab.add(new ArrayList<String>());             for (final String element : shadokAlph) {                 for (final List<String> sentence : shadokSentences) {                     final List<String> newSentence = new ArrayList<>(sentence);                     newSentence.add(element);                     newTab.add(newSentence);                 }             }             shadokSentences = newTab;         }          final ExecutionVisitor<String> ev = new ExecutionVisitor<>();          for (final List<String> element : shadokSentences) {             for (final List<String> shadokSentence : shadokSentences) {                 ev.setList(element);                 new SequencesComparator<>(element,                         shadokSentence).getScript().visit(ev);                  final StringBuilder concat = new StringBuilder();                 for (final String s : shadokSentence) {                     concat.append(s);                 }                 Assert.assertEquals(concat.toString(), ev.getString());             }         }     }      private List<Character> sequence(final String string) {         final List<Character> list = new ArrayList<>();         for (int i = 0; i < string.length(); ++i) {             list.add(new Character(string.charAt(i)));         }         return list;     }      private class ExecutionVisitor<T> implements CommandVisitor<T> {          private List<T> v;         private int index;          public void setList(final List<T> array) {             v = new ArrayList<>(array);             index = 0;         }          @Override         public void visitInsertCommand(final T object) {             v.add(index++, object);         }          @Override         public void visitKeepCommand(final T object) {             ++index;         }          @Override         public void visitDeleteCommand(final T object) {             v.remove(index);         }          public String getString() {             final StringBuilder buffer = new StringBuilder();             for (final T c : v) {                 buffer.append(c);             }             return buffer.toString();         }      }      @Before     public void setUp() {          before = Arrays.asList(             "bottle",             "nematode knowledge",             "",             "aa",             "prefixed string",             "ABCABBA",             "glop glop",             "coq",             "spider-man");          after = Arrays.asList(             "noodle",             "empty bottle",             "",             "C",             "prefix",             "CBABAC",             "pas glop pas glop",             "ane",             "klingon");          length = new int[] {             6,             16,             0,             3,             9,             5,             8,             6,             13         };      }      @After     public void tearDown() {         before = null;         after  = null;         length = null;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.ArrayList;  import org.apache.commons.collections4.list.AbstractListTest;  /**  * Abstract test class for ArrayList.  *  */ public abstract class AbstractArrayListTest<E> extends AbstractListTest<E> {      public AbstractArrayListTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public abstract ArrayList<E> makeObject();      //-----------------------------------------------------------------------     public void testNewArrayList() {         final ArrayList<E> list = makeObject();         assertTrue("New list is empty", list.isEmpty());         assertEquals("New list has size zero", 0, list.size());          try {             list.get(1);             fail("get(int i) should have thrown IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException e) {             // Expected result         }     }      @SuppressWarnings("unchecked")     public void testSearch() {         final ArrayList<E> list = makeObject();         list.add((E) "First Item");         list.add((E) "Last Item");         assertEquals("First item is 'First Item'", "First Item", list.get(0));         assertEquals("Last Item is 'Last Item'", "Last Item", list.get(1));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail;  import java.util.Arrays;  import org.apache.commons.collections4.multiset.HashMultiSet; import org.junit.Before; import org.junit.Test;  /**  * Tests for MultiSetUtils.  * @since 4.2  */ public class MultiSetUtilsTest {      private String[] fullArray;     private MultiSet<String> multiSet;      @Before     public void setUp() {         fullArray = new String[]{             "a", "a", "b", "c", "d", "d", "d"         };         multiSet = new HashMultiSet<>(Arrays.asList(fullArray));     }      /**      * Tests {@link MultiSetUtils#emptyMultiSet()}.      */     @Test     public void testEmptyMultiSet() {         final MultiSet<Integer> empty = MultiSetUtils.emptyMultiSet();         assertEquals(0, empty.size());         try {             empty.add(55);             fail("Empty multi set must be read-only");         } catch (final UnsupportedOperationException e) {         }     }      /**      * Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}.      */     @Test     public void testUnmodifiableMultiSet() {         final MultiSet<String> unmodifiable = MultiSetUtils.unmodifiableMultiSet(multiSet);         assertEquals(multiSet, unmodifiable);          try {             unmodifiable.add("a");             fail("Empty multi set must be read-only");         } catch (final UnsupportedOperationException e) {         }          try {             MultiSetUtils.unmodifiableMultiSet(null);             fail("Expecting NPE");         } catch (final NullPointerException e) {         }     }      /**      * Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}.      */     @Test     public void testSynchronizedMultiSet() {         final MultiSet<String> synced = MultiSetUtils.synchronizedMultiSet(multiSet);         assertEquals(multiSet, synced);         synced.add("a"); // ensure adding works     }      /**      * Tests {@link MultiSetUtils#predicatedMultiSet(org.apache.commons.collections4.MultiSet, org.apache.commons.collections4.Predicate)}.      */     @Test     public void testPredicatedMultiSet() {         final Predicate<String> predicate = object -> object.length() == 1;         final MultiSet<String> predicated = MultiSetUtils.predicatedMultiSet(multiSet, predicate);         assertEquals(multiSet.size(), predicated.size());         assertEquals(multiSet.getCount("a"), predicated.getCount("a"));          try {             MultiSetUtils.predicatedMultiSet(null, predicate);             fail("Expecting NPE");         } catch (final NullPointerException e) {         }          try {             MultiSetUtils.predicatedMultiSet(multiSet, null);             fail("Expecting NPE");         } catch (final NullPointerException e) {         }          try {             MultiSetUtils.predicatedMultiSet(multiSet, object -> object.equals("a"));             fail("Predicate is violated for all elements not being 'a'");         } catch (final IllegalArgumentException iae) {         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.bag.HashBag; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Tests for IterableUtils.  *  * @since 4.1  */ public class IterableUtilsTest {      /**      * Iterable of {@link Integer}s      */     private Iterable<Integer> iterableA = null;      /**      * Iterable of {@link Long}s      */     private Iterable<Long> iterableB = null;      /**      * An empty Iterable.      */     private Iterable<Integer> emptyIterable = null;      @Before     public void setUp() {         final Collection<Integer> collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         iterableA = collectionA;          final Collection<Long> collectionB = new LinkedList<>();         collectionB.add(5L);         collectionB.add(4L);         collectionB.add(4L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         iterableB = collectionB;          emptyIterable = Collections.emptyList();     }      private static Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;      private static Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;      // -----------------------------------------------------------------------     @Test     public void forEach() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         IterableUtils.forEach(col, testClosure);         assertTrue(listA.isEmpty() && listB.isEmpty());         try {             IterableUtils.forEach(col, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IterableUtils.forEach(null, testClosure);          // null should be OK         col.add(null);         IterableUtils.forEach(col, testClosure);     }      @Test(expected = FunctorException.class)     public void forEachFailure() {         final Closure<String> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<String> col = new ArrayList<>();         col.add("x");         IterableUtils.forEach(col, testClosure);     }      @Test     public void forEachButLast() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         List<Integer> last = IterableUtils.forEachButLast(col, testClosure);         assertTrue(listA.isEmpty() && !listB.isEmpty());         assertSame(listB, last);          try {             IterableUtils.forEachButLast(col, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IterableUtils.forEachButLast(null, testClosure);          // null should be OK         col.add(null);         col.add(null);         last = IterableUtils.forEachButLast(col, testClosure);         assertNull(last);     }      @Test     public void containsWithEquator() {         final List<String> base = new ArrayList<>();         base.add("AC");         base.add("BB");         base.add("CA");          final Equator<String> secondLetterEquator = new Equator<String>() {              @Override             public boolean equate(final String o1, final String o2) {                 return o1.charAt(1) == o2.charAt(1);             }              @Override             public int hash(final String o) {                 return o.charAt(1);             }          };          assertFalse(base.contains("CC"));         assertTrue(IterableUtils.contains(base, "AC", secondLetterEquator));         assertTrue(IterableUtils.contains(base, "CC", secondLetterEquator));         assertFalse(IterableUtils.contains(base, "CX", secondLetterEquator));         assertFalse(IterableUtils.contains(null, null, secondLetterEquator));          try {             IterableUtils.contains(base, "AC", null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want     }      @Test     public void frequency() {         // null iterable test         assertEquals(0, IterableUtils.frequency(null, 1));          assertEquals(1, IterableUtils.frequency(iterableA, 1));         assertEquals(2, IterableUtils.frequency(iterableA, 2));         assertEquals(3, IterableUtils.frequency(iterableA, 3));         assertEquals(4, IterableUtils.frequency(iterableA, 4));         assertEquals(0, IterableUtils.frequency(iterableA, 5));          assertEquals(0, IterableUtils.frequency(iterableB, 1L));         assertEquals(4, IterableUtils.frequency(iterableB, 2L));         assertEquals(3, IterableUtils.frequency(iterableB, 3L));         assertEquals(2, IterableUtils.frequency(iterableB, 4L));         assertEquals(1, IterableUtils.frequency(iterableB, 5L));          // Ensure that generic bounds accept valid parameters, but return         // expected results         // e.g. no longs in the "int" Iterable<Number>, and vice versa.         final Iterable<Number> iterableIntAsNumber = Arrays.<Number>asList(1, 2, 3, 4, 5);         final Iterable<Number> iterableLongAsNumber = Arrays.<Number>asList(1L, 2L, 3L, 4L, 5L);         assertEquals(0, IterableUtils.frequency(iterableIntAsNumber, 2L));         assertEquals(0, IterableUtils.frequency(iterableLongAsNumber, 2));          final Set<String> set = new HashSet<>();         set.add("A");         set.add("C");         set.add("E");         set.add("E");         assertEquals(1, IterableUtils.frequency(set, "A"));         assertEquals(0, IterableUtils.frequency(set, "B"));         assertEquals(1, IterableUtils.frequency(set, "C"));         assertEquals(0, IterableUtils.frequency(set, "D"));         assertEquals(1, IterableUtils.frequency(set, "E"));          final Bag<String> bag = new HashBag<>();         bag.add("A", 3);         bag.add("C");         bag.add("E");         bag.add("E");         assertEquals(3, IterableUtils.frequency(bag, "A"));         assertEquals(0, IterableUtils.frequency(bag, "B"));         assertEquals(1, IterableUtils.frequency(bag, "C"));         assertEquals(0, IterableUtils.frequency(bag, "D"));         assertEquals(2, IterableUtils.frequency(bag, "E"));     }      @Test     public void frequencyOfNull() {         final List<String> list = new ArrayList<>();         assertEquals(0, IterableUtils.frequency(list, null));         list.add("A");         assertEquals(0, IterableUtils.frequency(list, null));         list.add(null);         assertEquals(1, IterableUtils.frequency(list, null));         list.add("B");         assertEquals(1, IterableUtils.frequency(list, null));         list.add(null);         assertEquals(2, IterableUtils.frequency(list, null));         list.add("B");         assertEquals(2, IterableUtils.frequency(list, null));         list.add(null);         assertEquals(3, IterableUtils.frequency(list, null));     }      @Test     public void find() {         Predicate<Number> testPredicate = equalPredicate(4);         Integer test = IterableUtils.find(iterableA, testPredicate);         assertEquals(4, (int) test);         testPredicate = equalPredicate(45);         test = IterableUtils.find(iterableA, testPredicate);         assertNull(test);         assertNull(IterableUtils.find(null, testPredicate));         try {             IterableUtils.find(iterableA, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void indexOf() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         int index = IterableUtils.indexOf(iterableA, testPredicate);         assertEquals(6, index);         testPredicate = equalPredicate((Number) 45);         index = IterableUtils.indexOf(iterableA, testPredicate);         assertEquals(-1, index);         assertEquals(-1, IterableUtils.indexOf(null, testPredicate));         try {             IterableUtils.indexOf(iterableA, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void countMatches() {         assertEquals(4, IterableUtils.countMatches(iterableB, EQUALS_TWO));         assertEquals(0, IterableUtils.countMatches(null, EQUALS_TWO));          try {             assertEquals(0, IterableUtils.countMatches(iterableA, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          try {             assertEquals(0, IterableUtils.countMatches(null, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void matchesAny() {         final List<Integer> list = new ArrayList<>();          try {             assertFalse(IterableUtils.matchesAny(null, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          try {             assertFalse(IterableUtils.matchesAny(list, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          assertFalse(IterableUtils.matchesAny(null, EQUALS_TWO));         assertFalse(IterableUtils.matchesAny(list, EQUALS_TWO));         list.add(1);         list.add(3);         list.add(4);         assertFalse(IterableUtils.matchesAny(list, EQUALS_TWO));          list.add(2);         assertTrue(IterableUtils.matchesAny(list, EQUALS_TWO));     }      @Test     public void matchesAll() {         try {             assertFalse(IterableUtils.matchesAll(null, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          try {             assertFalse(IterableUtils.matchesAll(iterableA, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          final Predicate<Integer> lessThanFive = object -> object < 5;         assertTrue(IterableUtils.matchesAll(iterableA, lessThanFive));          final Predicate<Integer> lessThanFour = object -> object < 4;         assertFalse(IterableUtils.matchesAll(iterableA, lessThanFour));          assertTrue(IterableUtils.matchesAll(null, lessThanFour));         assertTrue(IterableUtils.matchesAll(emptyIterable, lessThanFour));     }      public void getFromIterable() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         assertEquals("element", IterableUtils.get(bag, 0));     }      @Test(expected = IndexOutOfBoundsException.class)     public void getFromIterableIndexOutOfBoundsException() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         // Collection, non-existent entry         IterableUtils.get(bag, 1);     }      public void firstFromIterable() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         assertEquals("element", IterableUtils.first(bag));     }      @Test(expected = IndexOutOfBoundsException.class)     public void firstFromIterableIndexOutOfBoundsException() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         // Collection, non-existent entry         IterableUtils.first(bag);     }      @SuppressWarnings("unchecked")     @Test     public void partition() {         final List<Integer> input = new ArrayList<>();         input.add(1);         input.add(2);         input.add(3);         input.add(4);         List<List<Integer>> partitions = IterableUtils.partition(input, EQUALS_TWO);         assertEquals(2, partitions.size());          // first partition contains 2         Collection<Integer> partition = partitions.get(0);         assertEquals(1, partition.size());         assertEquals(2, CollectionUtils.extractSingleton(partition).intValue());          // second partition contains 1, 3, and 4         final Integer[] expected = {1, 3, 4};         partition = partitions.get(1);         Assert.assertArrayEquals(expected, partition.toArray());          partitions = IterableUtils.partition((List<Integer>) null, EQUALS_TWO);         assertEquals(2, partitions.size());         assertTrue(partitions.get(0).isEmpty());         assertTrue(partitions.get(1).isEmpty());          partitions = IterableUtils.partition(input);         assertEquals(1, partitions.size());         assertEquals(input, partitions.get(0));          try {             IterableUtils.partition(input, (Predicate<Integer>) null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @SuppressWarnings("unchecked")     @Test     public void partitionMultiplePredicates() {         final List<Integer> input = new ArrayList<>();         input.add(1);         input.add(2);         input.add(3);         input.add(4);         final List<List<Integer>> partitions = IterableUtils.partition(input, EQUALS_TWO, EVEN);          // first partition contains 2         Collection<Integer> partition = partitions.get(0);         assertEquals(1, partition.size());         assertEquals(2, partition.iterator().next().intValue());          // second partition contains 4         partition = partitions.get(1);         assertEquals(1, partition.size());         assertEquals(4, partition.iterator().next().intValue());          // third partition contains 1 and 3         final Integer[] expected = {1, 3};         partition = partitions.get(2);         Assert.assertArrayEquals(expected, partition.toArray());          try {             IterableUtils.partition(input, EQUALS_TWO, null);         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void testToString() {         String result = IterableUtils.toString(iterableA);         assertEquals("[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]", result);          result = IterableUtils.toString(new ArrayList<Integer>());         assertEquals("[]", result);          result = IterableUtils.toString(null);         assertEquals("[]", result);          result = IterableUtils.toString(iterableA, input -> Integer.toString(input * 2));         assertEquals("[2, 4, 4, 6, 6, 6, 8, 8, 8, 8]", result);          result = IterableUtils.toString(new ArrayList<Integer>(), input -> {             fail("not supposed to reach here");             return "";         });         assertEquals("[]", result);          result = IterableUtils.toString(null, input -> {             fail("not supposed to reach here");             return "";         });         assertEquals("[]", result);     }      @Test     public void testToStringDelimiter() {          final Transformer<Integer, String> transformer = input -> Integer.toString(input * 2);          String result = IterableUtils.toString(iterableA, transformer, "", "", "");         assertEquals("2446668888", result);          result = IterableUtils.toString(iterableA, transformer, ",", "", "");         assertEquals("2,4,4,6,6,6,8,8,8,8", result);          result = IterableUtils.toString(iterableA, transformer, "", "[", "]");         assertEquals("[2446668888]", result);          result = IterableUtils.toString(iterableA, transformer, ",", "[", "]");         assertEquals("[2,4,4,6,6,6,8,8,8,8]", result);          result = IterableUtils.toString(iterableA, transformer, ",", "[[", "]]");         assertEquals("[[2,4,4,6,6,6,8,8,8,8]]", result);          result = IterableUtils.toString(iterableA, transformer, ",,", "[", "]");         assertEquals("[2,,4,,4,,6,,6,,6,,8,,8,,8,,8]", result);          result = IterableUtils.toString(iterableA, transformer, ",,", "((", "))");         assertEquals("((2,,4,,4,,6,,6,,6,,8,,8,,8,,8))", result);          result = IterableUtils.toString(new ArrayList<Integer>(), transformer, "", "(", ")");         assertEquals("()", result);          result = IterableUtils.toString(new ArrayList<Integer>(), transformer, "", "", "");         assertEquals("", result);     }      @Test     public void testToStringWithNullArguments() {         final String result = IterableUtils.toString(null, input -> {             fail("not supposed to reach here");             return "";         }, "", "(", ")");         assertEquals("()", result);          try {             IterableUtils.toString(new ArrayList<Integer>(), null, "", "(", ")");             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          try {             IterableUtils.toString(new ArrayList<Integer>(), input -> {                 fail("not supposed to reach here");                 return "";             }, null, "(", ")");             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          try {             IterableUtils.toString(new ArrayList<Integer>(), input -> {                 fail("not supposed to reach here");                 return "";             }, "", null, ")");             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          try {             IterableUtils.toString(new ArrayList<Integer>(), input -> {                 fail("not supposed to reach here");                 return "";             }, "", "(", null);             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void size() {         assertEquals(0, IterableUtils.size(null));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.functors.TruePredicate; import org.apache.commons.collections4.queue.PredicatedQueue; import org.apache.commons.collections4.queue.SynchronizedQueue; import org.apache.commons.collections4.queue.TransformedQueue; import org.apache.commons.collections4.queue.UnmodifiableQueue; import org.junit.Test;  /**  * Tests for QueueUtils factory methods.  *  */ public class QueueUtilsTest {      protected Predicate<Object> truePredicate = TruePredicate.truePredicate();     protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();      // ----------------------------------------------------------------------      @Test     public void testSynchronizedQueue() {         final Queue<Object> queue = QueueUtils.synchronizedQueue(new LinkedList<>());         assertTrue("Returned object should be a SynchronizedQueue.", queue instanceof SynchronizedQueue);         try {             QueueUtils.synchronizedQueue(null);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableQueue() {         final Queue<Object> queue = QueueUtils.unmodifiableQueue(new LinkedList<>());         assertTrue("Returned object should be an UnmodifiableQueue.", queue instanceof UnmodifiableQueue);         try {             QueueUtils.unmodifiableQueue(null);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableQueue shall not be decorated", queue, QueueUtils.unmodifiableQueue(queue));     }      @Test     public void testPredicatedQueue() {         final Queue<Object> queue = QueueUtils.predicatedQueue(new LinkedList<>(), truePredicate);         assertTrue("Returned object should be a PredicatedQueue.", queue instanceof PredicatedQueue);         try {             QueueUtils.predicatedQueue(null, truePredicate);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }         try {             QueueUtils.predicatedQueue(new LinkedList<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testTransformedQueue() {         final Queue<Object> queue = QueueUtils.transformingQueue(new LinkedList<>(), nopTransformer);         assertTrue("Returned object should be an TransformedQueue.", queue instanceof TransformedQueue);         try {             QueueUtils.transformingQueue(null, nopTransformer);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }         try {             QueueUtils.transformingQueue(new LinkedList<>(), null);             fail("Expecting NullPointerException for null transformer.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testEmptyQueue() {         final Queue<Object> queue = QueueUtils.emptyQueue();         assertTrue("Returned object should be an UnmodifiableQueue.", queue instanceof UnmodifiableQueue);         assertTrue("Returned queue is not empty.", queue.isEmpty());          try {             queue.add(new Object());             fail("Expecting UnsupportedOperationException for empty queue.");         } catch (final UnsupportedOperationException ex) {             // expected         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import org.apache.commons.collections4.bag.HashBag; import org.apache.commons.collections4.bag.PredicatedBag; import org.apache.commons.collections4.bag.PredicatedSortedBag; import org.apache.commons.collections4.bag.SynchronizedBag; import org.apache.commons.collections4.bag.SynchronizedSortedBag; import org.apache.commons.collections4.bag.TransformedBag; import org.apache.commons.collections4.bag.TransformedSortedBag; import org.apache.commons.collections4.bag.TreeBag; import org.apache.commons.collections4.bag.UnmodifiableBag; import org.apache.commons.collections4.bag.UnmodifiableSortedBag; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests for BagUtils factory methods.  *  */ public class BagUtilsTest {      protected Predicate<Object> truePredicate = TruePredicate.truePredicate();     protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();      //----------------------------------------------------------------------      @Test     public void testSynchronizedBag() {         final Bag<Object> bag = BagUtils.synchronizedBag(new HashBag<>());         assertTrue("Returned object should be a SynchronizedBag.",             bag instanceof SynchronizedBag);         try {             BagUtils.synchronizedBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableBag() {         final Bag<Object> bag = BagUtils.unmodifiableBag(new HashBag<>());         assertTrue("Returned object should be an UnmodifiableBag.",             bag instanceof UnmodifiableBag);         try {             BagUtils.unmodifiableBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableBag shall not be decorated", bag, BagUtils.unmodifiableBag(bag));     }      @Test     public void testPredicatedBag() {         final Bag<Object> bag = BagUtils.predicatedBag(new HashBag<>(), truePredicate);         assertTrue("Returned object should be a PredicatedBag.",             bag instanceof PredicatedBag);         try {             BagUtils.predicatedBag(null, truePredicate);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.predicatedBag(new HashBag<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testTransformedBag() {         final Bag<Object> bag = BagUtils.transformingBag(new HashBag<>(), nopTransformer);         assertTrue("Returned object should be an TransformedBag.",             bag instanceof TransformedBag);         try {             BagUtils.transformingBag(null, nopTransformer);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.transformingBag(new HashBag<>(), null);             fail("Expecting NullPointerException for null transformer.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testSynchronizedSortedBag() {         final Bag<Object> bag = BagUtils.synchronizedSortedBag(new TreeBag<>());         assertTrue("Returned object should be a SynchronizedSortedBag.",             bag instanceof SynchronizedSortedBag);         try {             BagUtils.synchronizedSortedBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableSortedBag() {         final SortedBag<Object> bag = BagUtils.unmodifiableSortedBag(new TreeBag<>());         assertTrue("Returned object should be an UnmodifiableSortedBag.",             bag instanceof UnmodifiableSortedBag);         try {             BagUtils.unmodifiableSortedBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableSortedBag shall not be decorated", bag, BagUtils.unmodifiableSortedBag(bag));     }      @Test     public void testPredicatedSortedBag() {         final Bag<Object> bag = BagUtils.predicatedSortedBag(new TreeBag<>(), truePredicate);         assertTrue("Returned object should be a PredicatedSortedBag.",             bag instanceof PredicatedSortedBag);         try {             BagUtils.predicatedSortedBag(null, truePredicate);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.predicatedSortedBag(new TreeBag<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testTransformedSortedBag() {         final Bag<Object> bag = BagUtils.transformingSortedBag(new TreeBag<>(), nopTransformer);         assertTrue("Returned object should be an TransformedSortedBag",             bag instanceof TransformedSortedBag);         try {             BagUtils.transformingSortedBag(null, nopTransformer);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.transformingSortedBag(new TreeBag<>(), null);             fail("Expecting NullPointerException for null transformer.");         } catch (final NullPointerException ex) {             // expected         }     } }   
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator;  import org.easymock.EasyMock; import org.easymock.IExpectationSetters;  /**  * Provides utilities for making mock-based tests.  Most notable is the generic "type-safe"  * {@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods  * that call the respective methods on all created mock objects.  */ public abstract class MockTestCase {     private final List<Object> mockObjects = new ArrayList<>();      @SuppressWarnings("unchecked")     protected <T> T createMock(final Class<?> name) {         final T mock = (T) EasyMock.createMock(name);         return registerMock(mock);     }      private <T> T registerMock(final T mock) {         mockObjects.add(mock);         return mock;     }      protected <T> IExpectationSetters<T> expect(final T t) {         return EasyMock.expect(t);     }      protected final void replay() {         for (final Object o : mockObjects) {             EasyMock.replay(o);         }     }      protected final void verify() {         for (final ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {             try {                 EasyMock.verify(i.next());             } catch (final AssertionError e) {                 throw new AssertionError(i.previousIndex() + 1 + ""                         + e.getMessage());             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Comparator; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.SortedMap; import java.util.TreeMap; import java.util.concurrent.ConcurrentSkipListMap;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link PredicatedMapTest} for exercising the  * {@link PredicatedSortedMap} implementation.  *  * @since 3.0  */ public class PredicatedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      private class ReverseStringComparator implements Comparator<K> {         @Override         public int compare(final K arg0, final K arg1) {             return ((String) arg1).compareTo((String) arg0);         }     }      protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();      protected static final Predicate<Object> testPredicate = o -> o instanceof String;      protected final Comparator<K> reverseStringComparator = new ReverseStringComparator();      public PredicatedSortedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     protected SortedMap<K, V> decorateMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,         final Predicate<? super V> valuePredicate) {         return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);     }      @Override     public SortedMap<K, V> makeObject() {         return decorateMap(new TreeMap<K, V>(), truePredicate, truePredicate);     }      public SortedMap<K, V> makeTestMap() {         return decorateMap(new TreeMap<K, V>(), testPredicate, testPredicate);     }      public SortedMap<K, V> makeTestMapWithComparator() {         return decorateMap(new ConcurrentSkipListMap<K, V>(reverseStringComparator), testPredicate, testPredicate);     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      @Override     public boolean isAllowNullKey() {         return false;     }      // from TestPredicatedMap     //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEntrySet() {         SortedMap<K, V> map = makeTestMap();         assertTrue("returned entryset should not be null",             map.entrySet() != null);         map = decorateMap(new TreeMap<K, V>(), null, null);         map.put((K) "oneKey", (V) "oneValue");         assertTrue("returned entryset should contain one entry",             map.entrySet().size() == 1);         map = decorateMap(map, null, null);     }      @SuppressWarnings("unchecked")     public void testPut() {         final Map<K, V> map = makeTestMap();         try {             map.put((K) "Hi", (V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          try {             map.put((K) Integer.valueOf(3), (V) "Hi");             fail("Illegal key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          assertTrue(!map.containsKey(Integer.valueOf(3)));         assertTrue(!map.containsValue(Integer.valueOf(3)));          final Map<K, V> map2 = new HashMap<>();         map2.put((K) "A", (V) "a");         map2.put((K) "B", (V) "b");         map2.put((K) "C", (V) "c");         map2.put((K) "c", (V) Integer.valueOf(3));          try {             map.putAll(map2);             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "E", (V) "e");         Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();         try {             final Map.Entry<K, V> entry = iterator.next();             entry.setValue((V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "F", (V) "f");         iterator = map.entrySet().iterator();         final Map.Entry<K, V> entry = iterator.next();         entry.setValue((V) "x");      }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testSortOrder() {         final SortedMap<K, V> map = makeTestMap();         map.put((K) "A",  (V) "a");         map.put((K) "B", (V) "b");         try {             map.put(null, (V) "c");             fail("Null key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         map.put((K) "C", (V) "c");         try {             map.put((K) "D", null);             fail("Null value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         assertEquals("First key should be A", "A", map.firstKey());         assertEquals("Last key should be C", "C", map.lastKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap((K) "B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap((K) "C").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap((K) "A", (K) "C").lastKey());          final Comparator<? super K> c = map.comparator();         assertTrue("natural order, so comparator should be null",             c == null);     }      @SuppressWarnings("unchecked")     public void testReverseSortOrder() {         final SortedMap<K, V> map = makeTestMapWithComparator();         map.put((K) "A",  (V) "a");         map.put((K) "B", (V) "b");         try {             map.put(null, (V) "c");             fail("Null key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         map.put((K) "C", (V) "c");         try {             map.put((K) "D", null);             fail("Null value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         assertEquals("Last key should be A", "A", map.lastKey());         assertEquals("First key should be C", "C", map.firstKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap((K) "B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap((K) "A").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap((K) "C", (K) "A").lastKey());          final Comparator<? super K> c = map.comparator();         assertTrue("reverse order, so comparator should be reverseStringComparator",             c == reverseStringComparator);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedSortedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Map;  /**  * A {@code Map} implementation that matches keys and values based  * on {@code ==} not {@code equals()}.  * <p>  * <strong>This map will violate the detail of various Map and map view contracts.</strong>  * As a general rule, don't compare this map to other maps. In particular, you can't  * use decorators like {@link ListOrderedMap} on it, which silently assume that these  * contracts are fulfilled.  * <p>  * <strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>  * If you wish to use this map from multiple threads concurrently, you must use  * appropriate synchronization. The simplest approach is to wrap this map  * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw  * exceptions when accessed by concurrent threads without synchronization.  * <p>  * From 4.0, this class is replaced by java.util.IdentityHashMap but kept as a  * test-class because it is still used by the ReferenceIdentityMapTest.  *  * @param <K> the type of the keys in this map  * @param <V> the type of the values in this map  * @since 3.0  */ public class IdentityMap<K, V>         extends AbstractHashedMap<K, V> implements Serializable, Cloneable {      /** Serialisation version */     private static final long serialVersionUID = 2028493495224302329L;      /**      * Constructs a new empty map with default size and load factor.      */     public IdentityMap() {         super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);     }      /**      * Constructs a new, empty map with the specified initial capacity.      *      * @param initialCapacity  the initial capacity      * @throws IllegalArgumentException if the initial capacity is negative      */     public IdentityMap(final int initialCapacity) {         super(initialCapacity);     }      /**      * Constructs a new, empty map with the specified initial capacity and      * load factor.      *      * @param initialCapacity  the initial capacity      * @param loadFactor  the load factor      * @throws IllegalArgumentException if the initial capacity is negative      * @throws IllegalArgumentException if the load factor is less than zero      */     public IdentityMap(final int initialCapacity, final float loadFactor) {         super(initialCapacity, loadFactor);     }      /**      * Constructor copying elements from another map.      *      * @param map  the map to copy      * @throws NullPointerException if the map is null      */     public IdentityMap(final Map<K, V> map) {         super(map);     }      //-----------------------------------------------------------------------     /**      * Gets the hash code for the key specified.      * This implementation uses the identity hash code.      *      * @param key  the key to get a hash code for      * @return the hash code      */     @Override     protected int hash(final Object key) {         return System.identityHashCode(key);     }      /**      * Compares two keys for equals.      * This implementation uses {@code ==}.      *      * @param key1  the first key to compare      * @param key2  the second key to compare      * @return true if equal by identity      */     @Override     protected boolean isEqualKey(final Object key1, final Object key2) {         return key1 == key2;     }      /**      * Compares two values for equals.      * This implementation uses {@code ==}.      *      * @param value1  the first value to compare      * @param value2  the second value to compare      * @return true if equal by identity      */     @Override     protected boolean isEqualValue(final Object value1, final Object value2) {         return value1 == value2;     }      /**      * Creates an entry to store the data.      * This implementation creates an IdentityEntry instance.      *      * @param next  the next entry in sequence      * @param hashCode  the hash code to use      * @param key  the key to store      * @param value  the value to store      * @return the newly created entry      */     @Override     protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,                                               final K key, final V value) {         return new IdentityEntry<>(next, hashCode, key, value);     }      //-----------------------------------------------------------------------     /**      * HashEntry      */     protected static class IdentityEntry<K, V> extends HashEntry<K, V> {          protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {             super(next, hashCode, key, value);         }          @Override         public boolean equals(final Object obj) {             if (obj == this) {                 return true;             }             if (!(obj instanceof Entry)) {                 return false;             }             final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;             return                 getKey() == other.getKey() &&                 getValue() == other.getValue();         }          @Override         public int hashCode() {             return System.identityHashCode(getKey()) ^                    System.identityHashCode(getValue());         }     }      //-----------------------------------------------------------------------     /**      * Clones the map without cloning the keys or values.      *      * @return a shallow clone      */     @Override     public IdentityMap<K, V> clone() {         return (IdentityMap<K, V>) super.clone();     }      /**      * Write the map out using a custom routine.      */     private void writeObject(final ObjectOutputStream out) throws IOException {         out.defaultWriteObject();         doWriteObject(out);     }      /**      * Read the map in using a custom routine.      */     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {         in.defaultReadObject();         doReadObject(in);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Iterator; import java.util.Map;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link PredicatedMap} implementation.  *  * @since 3.0  */ public class PredicatedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();      protected static final Predicate<Object> testPredicate = o -> o instanceof String;      public PredicatedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     protected IterableMap<K, V> decorateMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,         final Predicate<? super V> valuePredicate) {         return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);     }      @Override     public IterableMap<K, V> makeObject() {         return decorateMap(new HashMap<K, V>(), truePredicate, truePredicate);     }      public IterableMap<K, V> makeTestMap() {         return decorateMap(new HashMap<K, V>(), testPredicate, testPredicate);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEntrySet() {         Map<K, V> map = makeTestMap();         assertTrue("returned entryset should not be null",             map.entrySet() != null);         map = decorateMap(new HashMap<K, V>(), null, null);         map.put((K) "oneKey", (V) "oneValue");         assertTrue("returned entryset should contain one entry",             map.entrySet().size() == 1);         map = decorateMap(map, null, null);     }      @SuppressWarnings("unchecked")     public void testPut() {         final Map<K, V> map = makeTestMap();         try {             map.put((K) "Hi", (V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          try {             map.put((K) Integer.valueOf(3), (V) "Hi");             fail("Illegal key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          assertTrue(!map.containsKey(Integer.valueOf(3)));         assertTrue(!map.containsValue(Integer.valueOf(3)));          final Map<K, V> map2 = new HashMap<>();         map2.put((K) "A", (V) "a");         map2.put((K) "B", (V) "b");         map2.put((K) "C", (V) "c");         map2.put((K) "c", (V) Integer.valueOf(3));          try {             map.putAll(map2);             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "E", (V) "e");         Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();         try {             final Map.Entry<K, V> entry = iterator.next();             entry.setValue((V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "F", (V) "f");         iterator = map.entrySet().iterator();         final Map.Entry<K, V> entry = iterator.next();         entry.setValue((V) "x");      }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link UnmodifiableMap} implementation.  *  * @since 3.0  */ public class UnmodifiableMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public UnmodifiableMapTest(final String testName) {         super(testName);     }      //-------------------------------------------------------------------      @Override     public IterableMap<K, V> makeObject() {         return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(new HashMap<K, V>());     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public IterableMap<K, V> makeFullMap() {         final Map<K, V> m = new HashMap<>();         addSampleMappings(m);         return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Map<K, V> map = makeFullMap();         assertSame(map, UnmodifiableMap.unmodifiableMap(map));          try {             UnmodifiableMap.unmodifiableMap(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.ResettableIterator; import org.apache.commons.collections4.list.AbstractListTest;  /**  * JUnit tests.  *  */ public class LinkedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public LinkedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(LinkedMapTest.class);     }      @Override     public LinkedMap<K, V> makeObject() {         return new LinkedMap<>();     }      /**      * {@inheritDoc}      */     @Override     public LinkedMap<K, V> makeFullMap() {         return (LinkedMap<K, V>) super.makeFullMap();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testReset() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         ((ResettableIterator<K>) ordered.mapIterator()).reset();          resetFull();         ordered = getMap();         final List<K> list = new ArrayList<>(ordered.keySet());         final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();         assertSame(list.get(0), it.next());         assertSame(list.get(1), it.next());         it.reset();         assertSame(list.get(0), it.next());     }      //-----------------------------------------------------------------------     public void testInsertionOrder() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> keyIter;         Iterator<V> valueIter;          resetEmpty();         map.put(keys[0], values[0]);         map.put(keys[1], values[1]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[0], valueIter.next());         assertSame(values[1], valueIter.next());          // no change to order         map.put(keys[1], values[1]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[0], valueIter.next());         assertSame(values[1], valueIter.next());          // no change to order         map.put(keys[1], values[2]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[0], valueIter.next());         assertSame(values[2], valueIter.next());          // no change to order         map.put(keys[0], values[3]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[3], valueIter.next());         assertSame(values[2], valueIter.next());     }      //-----------------------------------------------------------------------     public void testGetByIndex() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         try {             lm.get(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.get(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lm = getMap();         try {             lm.get(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.get(lm.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {             assertSame(it.next(), lm.get(i));         }     }      public void testGetValueByIndex() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         try {             lm.getValue(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lm = getMap();         try {             lm.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.getValue(lm.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {             it.next();             assertSame(it.getValue(), lm.getValue(i));         }     }      public void testIndexOf() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         assertEquals(-1, lm.indexOf(getOtherKeys()));          resetFull();         lm = getMap();         final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             assertEquals(i, lm.indexOf(list.get(i)));         }     }      public void testRemoveByIndex() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         try {             lm.remove(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lm = getMap();         try {             lm.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.remove(lm.size());         } catch (final IndexOutOfBoundsException ex) {}          final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             final Object key = list.get(i);             final Object value = lm.get(key);             assertEquals(value, lm.remove(i));             list.remove(i);             assertEquals(false, lm.containsKey(key));         }     }      public BulkTest bulkTestListView() {         return new TestListView();     }      public class TestListView extends AbstractListTest<K> {          TestListView() {             super("TestListView");         }          @Override         public List<K> makeObject() {             return LinkedMapTest.this.makeObject().asList();         }          @Override         public List<K> makeFullCollection() {             return LinkedMapTest.this.makeFullMap().asList();         }          @Override         public K[] getFullElements() {             return LinkedMapTest.this.getSampleKeys();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return false;         }         @Override         public boolean isSetSupported() {             return false;         }         @Override         public boolean isNullSupported() {             return LinkedMapTest.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      @SuppressWarnings("unchecked")     public void testClone() {         final LinkedMap<K, V> map = new LinkedMap<>(10);         map.put((K) "1", (V) "1");         final Map<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LinkedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LinkedMap.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public LinkedMap<K, V> getMap() {         return (LinkedMap<K, V>) super.getMap();     }      /**      * Test for <a href="https://issues.apache.org/jira/browse/COLLECTIONS-323">COLLECTIONS-323</a>.      */     public void testInitialCapacityZero() {         final LinkedMap<String, String> map = new LinkedMap<>(0);         assertEquals(1, map.data.length);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Tests for the {@link CaseInsensitiveMap} implementation.  *  */ public class CaseInsensitiveMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(CaseInsensitiveMapTest.class);     }      public CaseInsensitiveMapTest(final String testName) {         super(testName);     }      @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     public CaseInsensitiveMap<K, V> makeObject() {         return new CaseInsensitiveMap<>();     }      @SuppressWarnings("unchecked")     public void testCaseInsensitive() {         final Map<K, V> map = makeObject();         map.put((K) "One", (V) "One");         map.put((K) "Two", (V) "Two");         assertEquals("One", map.get("one"));         assertEquals("One", map.get("oNe"));         map.put((K) "two", (V) "Three");         assertEquals("Three", map.get("Two"));     }      @SuppressWarnings("unchecked")     public void testClone() {         final CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<>(10);         map.put((K) "1", (V) "1");         final CaseInsensitiveMap<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }      /**      * Test for <a href="https://issues.apache.org/jira/browse/COLLECTIONS-323">COLLECTIONS-323</a>.      */     public void testInitialCapacityZero() {         final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<>(0);         assertEquals(1, map.data.length);     }      // COLLECTIONS-294     public void testLocaleIndependence() {         final Locale orig = Locale.getDefault();          final Locale[] locales = { Locale.ENGLISH, new Locale("tr", "", ""), Locale.getDefault() };          final String[][] data = {             { "i", "I" },             { "\u03C2", "\u03C3" },             { "\u03A3", "\u03C2" },             { "\u03A3", "\u03C3" },         };          try {             for (final Locale locale : locales) {                 Locale.setDefault(locale);                 for (int j = 0; j < data.length; j++) {                     assertTrue("Test data corrupt: " + j, data[j][0].equalsIgnoreCase(data[j][1]));                     final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<>();                     map.put(data[j][0], "value");                     assertEquals(Locale.getDefault() + ": " + j, "value", map.get(data[j][1]));                 }             }         } finally {             Locale.setDefault(orig);         }     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CaseInsensitiveMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CaseInsensitiveMap.fullCollection.version4.obj"); //    }      @SuppressWarnings("unchecked")     public void testNullHandling() {         final Map<K, V> map = makeObject();         map.put((K) "One", (V) "One");         map.put((K) "Two", (V) "Two");         map.put(null, (V) "Three");         assertEquals("Three", map.get(null));         map.put(null, (V) "Four");         assertEquals("Four", map.get(null));         final Set<K> keys = map.keySet();         assertTrue(keys.contains("one"));         assertTrue(keys.contains("two"));         assertTrue(keys.contains(null));         assertEquals(3, keys.size());     }      public void testPutAll() {         final Map<Object, String> map = new HashMap<>();         map.put("One", "One");         map.put("Two", "Two");         map.put("one", "Three");         map.put(null, "Four");         map.put(Integer.valueOf(20), "Five");         final Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<>(map);         assertEquals(4, caseInsensitiveMap.size()); // ones collapsed         final Set<Object> keys = caseInsensitiveMap.keySet();         assertTrue(keys.contains("one"));         assertTrue(keys.contains("two"));         assertTrue(keys.contains(null));         assertTrue(keys.contains(Integer.toString(20)));         assertEquals(4, keys.size());         assertTrue(!caseInsensitiveMap.containsValue("One")             || !caseInsensitiveMap.containsValue("Three")); // ones collapsed         assertEquals("Four", caseInsensitiveMap.get(null));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map; import java.util.Set;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractMapTest} for exercising the {@link TransformedMap}  * implementation.  *  * @since 3.0  */ public class TransformedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public TransformedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public IterableMap<K, V> makeObject() {         return TransformedMap.transformingMap(new HashMap<K, V>(), TransformerUtils.<K>nopTransformer(),                 TransformerUtils.<V>nopTransformer());     }      //-----------------------------------------------------------------------     @SuppressWarnings({ "unchecked", "rawtypes" })     public void testTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          Map<K, V> map = TransformedMap                 .transformingMap(                         new HashMap<K, V>(),                         (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,                         null);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsKey(els[i]));             assertEquals(true, map.containsValue(els[i]));             assertEquals(els[i], map.get(Integer.valueOf((String) els[i])));         }          assertEquals(null, map.remove(els[0]));         assertEquals(els[0], map.remove(Integer.valueOf((String) els[0])));          map = TransformedMap.transformingMap(new HashMap(), null,                                              // cast needed for eclipse compiler                                              (Transformer) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsValue(els[i]));             assertEquals(true, map.containsKey(els[i]));             assertEquals(Integer.valueOf((String) els[i]), map.get(els[i]));         }          assertEquals(Integer.valueOf((String) els[0]), map.remove(els[0]));          final Set<Map.Entry<K, V>> entrySet = map.entrySet();         final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);         array[0].setValue((V) "66");         assertEquals(Integer.valueOf(66), array[0].getValue());         assertEquals(Integer.valueOf(66), map.get(array[0].getKey()));          final Map.Entry<K, V> entry = entrySet.iterator().next();         entry.setValue((V) "88");         assertEquals(Integer.valueOf(88), entry.getValue());         assertEquals(Integer.valueOf(88), map.get(entry.getKey()));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testFactory_Decorate() {         final Map<K, V> base = new HashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final Map<K, V> trans = TransformedMap                 .transformingMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals("1", trans.get("A"));         assertEquals("2", trans.get("B"));         assertEquals("3", trans.get("C"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("D"));     }      @SuppressWarnings("unchecked")     public void testFactory_decorateTransform() {         final Map<K, V> base = new HashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final Map<K, V> trans = TransformedMap                 .transformedMap(                         base,                         (Transformer<? super K, ? extends K>) TransformedCollectionTest.TO_LOWER_CASE_TRANSFORMER,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(Integer.valueOf(1), trans.get("a"));         assertEquals(Integer.valueOf(2), trans.get("b"));         assertEquals(Integer.valueOf(3), trans.get("c"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("d"));     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import static org.apache.commons.collections4.map.LazyMap.lazyMap;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.FactoryUtils; import org.apache.commons.collections4.Transformer; import org.junit.Test;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link LazyMap} implementation.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class LazyMapTest<K, V> extends AbstractIterableMapTest<K, V> {      private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);      public LazyMapTest(final String testName) {         super(testName);     }      @Override     public LazyMap<K, V> makeObject() {         return lazyMap(new HashMap<K, V>(), FactoryUtils.<V>nullFactory());     }      //-----------------------------------------------------------------------     @Override     public void testMapGet() {         //TODO eliminate need for this via superclass - see svn history.     }      @Test     public void mapGetWithFactory() {         Map<Integer, Number> map = lazyMap(new HashMap<Integer, Number>(), oneFactory);         assertEquals(0, map.size());         final Number i1 = map.get("Five");         assertEquals(1, i1);         assertEquals(1, map.size());         final Number i2 = map.get(new String(new char[] {'F', 'i', 'v', 'e'}));         assertEquals(1, i2);         assertEquals(1, map.size());         assertSame(i1, i2);          map = lazyMap(new HashMap<Integer, Number>(), FactoryUtils.<Long>nullFactory());         final Object o = map.get("Five");         assertEquals(null, o);         assertEquals(1, map.size());     }      @Test     public void mapGetWithTransformer() {         final Transformer<Number, Integer> intConverter = Number::intValue;         final Map<Long, Number> map = lazyMap(new HashMap<Long, Number>(), intConverter);         assertEquals(0, map.size());         final Number i1 = map.get(123L);         assertEquals(123, i1);         assertEquals(1, map.size());     }       @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazyMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazyMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.List;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.list.AbstractListTest;  /**  * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}  * implementation.  *  * @since 3.1  */ public class ListOrderedMap2Test<K, V> extends AbstractOrderedMapTest<K, V> {      public ListOrderedMap2Test(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ListOrderedMap2Test.class);     }      @Override     public ListOrderedMap<K, V> makeObject() {         return new ListOrderedMap<>();     }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> makeFullMap() {         return (ListOrderedMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     public void testGetByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.get(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             assertSame(it.next(), lom.get(i));         }     }      public void testGetValueByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.getValue(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             it.next();             assertSame(it.getValue(), lom.getValue(i));         }     }      public void testIndexOf() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         assertEquals(-1, lom.indexOf(getOtherKeys()));          resetFull();         lom = getMap();         final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             assertEquals(i, lom.indexOf(list.get(i)));         }     }      public void testRemoveByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.remove(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             final Object key = list.get(i);             final Object value = lom.get(key);             assertEquals(value, lom.remove(i));             list.remove(i);             assertEquals(false, lom.containsKey(key));         }     }      public BulkTest bulkTestListView() {         return new TestListView();     }      public class TestListView extends AbstractListTest<K> {          TestListView() {             super("TestListView");         }          @Override         public List<K> makeObject() {             return ListOrderedMap2Test.this.makeObject().asList();         }          @Override         public List<K> makeFullCollection() {             return ListOrderedMap2Test.this.makeFullMap().asList();         }          @Override         public K[] getFullElements() {             return ListOrderedMap2Test.this.getSampleKeys();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return false;         }         @Override         public boolean isSetSupported() {             return false;         }         @Override         public boolean isNullSupported() {             return ListOrderedMap2Test.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> getMap() {         return (ListOrderedMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.FactoryUtils; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.functors.ConstantFactory;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link DefaultedMap} implementation.  *  * @since 3.2  */ public class DefaultedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();     protected final Transformer<K, V> nullTransformer = TransformerUtils.<K, V>nullTransformer();      public DefaultedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public IterableMap<K, V> makeObject() {         return DefaultedMap.defaultedMap(new HashMap<K, V>(), nullFactory);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public void testMapGet() {         final Map<K, V> map = new DefaultedMap<>((V) "NULL");          assertEquals(0, map.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));     }      @SuppressWarnings("unchecked")     public void testMapGet2() {         final HashMap<K, V> base = new HashMap<>();         final Map<K, V> map = DefaultedMap.defaultedMap(base, (V) "NULL");          assertEquals(0, map.size());         assertEquals(0, base.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(1, base.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));     }      @SuppressWarnings("unchecked")     public void testMapGet3() {         final HashMap<K, V> base = new HashMap<>();         final Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) "NULL"));          assertEquals(0, map.size());         assertEquals(0, base.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(1, base.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));     }      @SuppressWarnings("unchecked")     public void testMapGet4() {         final HashMap<K, V> base = new HashMap<>();         final Map<K, V> map = DefaultedMap.defaultedMap(base, (Transformer<K, V>) input -> {             if (input instanceof String) {                 return (V) "NULL";             }             return (V) "NULL_OBJECT";         });          assertEquals(0, map.size());         assertEquals(0, base.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));         assertEquals("NULL_OBJECT", map.get(Integer.valueOf(0)));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(1, base.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));         assertEquals("NULL_OBJECT", map.get(Integer.valueOf(0)));     }      public void testFactoryMethods() {         final HashMap<K, V> base = new HashMap<>();          try {             DefaultedMap.defaultedMap(null, (V) "DEFAULT_VALUE");             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap((Map<K, V>) null, nullFactory);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap(base, (Factory<V>) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap((Map<K, V>) null, nullTransformer);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap(base, (Transformer<K, V>) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/DefaultedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/DefaultedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.keyvalue.MultiKey;  /**  * JUnit tests.  *  */ public class MultiKeyMapTest<K, V> extends AbstractIterableMapTest<MultiKey<? extends K>, V> {      static final Integer I1 = Integer.valueOf(1);     static final Integer I2 = Integer.valueOf(2);     static final Integer I3 = Integer.valueOf(3);     static final Integer I4 = Integer.valueOf(4);     static final Integer I5 = Integer.valueOf(5);     static final Integer I6 = Integer.valueOf(6);     static final Integer I7 = Integer.valueOf(7);     static final Integer I8 = Integer.valueOf(8);      public MultiKeyMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(MultiKeyMapTest.class);     }      @Override     public MultiKeyMap<K, V> makeObject() {         return new MultiKeyMap<>();     }      @Override     public MultiKey<K>[] getSampleKeys() {         return getMultiKeyKeys();     }      @SuppressWarnings("unchecked")     private MultiKey<K>[] getMultiKeyKeys() {         return new MultiKey[] {             new MultiKey<>(I1, I2),             new MultiKey<>(I2, I3),             new MultiKey<>(I3, I4),             new MultiKey<>(I1, I1, I2),             new MultiKey<>(I2, I3, I4),             new MultiKey<>(I3, I7, I6),             new MultiKey<>(I1, I1, I2, I3),             new MultiKey<>(I2, I4, I5, I6),             new MultiKey<>(I3, I6, I7, I8),             new MultiKey<>(I1, I1, I2, I3, I4),             new MultiKey<>(I2, I3, I4, I5, I6),             new MultiKey<>(I3, I5, I6, I7, I8),         };     }      @Override     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         return (V[]) new Object[] {             "2A", "2B", "2C",             "3D", "3E", "3F",             "4G", "4H", "4I",             "5J", "5K", "5L",         };     }      @Override     @SuppressWarnings("unchecked")     public V[] getNewSampleValues() {         return (V[]) new Object[] {             "1a", "1b", "1c",             "2d", "2e", "2f",             "3g", "3h", "3i",             "4j", "4k", "4l",         };     }      @Override     @SuppressWarnings("unchecked")     public MultiKey<K>[] getOtherKeys() {         return new MultiKey[] {             new MultiKey<>(I1, I7),             new MultiKey<>(I1, I8),             new MultiKey<>(I2, I4),             new MultiKey<>(I2, I5),         };     }      @Override     public boolean isAllowNullKey() {         return false;     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testNullHandling() {         resetFull();         assertEquals(null, map.get(null));         assertEquals(false, map.containsKey(null));         assertEquals(false, map.containsValue(null));         assertEquals(null, map.remove(null));         assertEquals(false, map.entrySet().contains(null));         assertEquals(false, map.keySet().contains(null));         assertEquals(false, map.values().contains(null));         try {             map.put(null, null);             fail();         } catch (final NullPointerException ex) {}         assertEquals(null, map.put(new MultiKey<K>(null, null), null));         try {             map.put(null, (V) new Object());             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------     public void testMultiKeyGet() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         final MultiKey<K>[] keys = getMultiKeyKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             final MultiKey<K> key = keys[i];             final V value = values[i];              switch (key.size()) {             case 2:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));                 assertEquals(null, multimap.get(null, key.getKey(1)));                 assertEquals(null, multimap.get(key.getKey(0), null));                 assertEquals(null, multimap.get(null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null, null));                 break;             case 3:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2)));                 assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));                 assertEquals(null, multimap.get(null, null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, null));                 break;             case 4:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(null, multimap.get(null, null, null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 break;             case 5:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 assertEquals(null, multimap.get(null, null, null, null, null));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyContainsKey() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         final MultiKey<K>[] keys = getMultiKeyKeys();          for (final MultiKey<K> key : keys) {             switch (key.size()) {             case 2:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null));                 assertEquals(false, multimap.containsKey(null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null, null));                 break;             case 3:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));                 assertEquals(false, multimap.containsKey(null, null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, null));                 break;             case 4:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(false, multimap.containsKey(null, null, null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 break;             case 5:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 assertEquals(false, multimap.containsKey(null, null, null, null, null));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyPut() {         final MultiKey<K>[] keys = getMultiKeyKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             final MultiKeyMap<K, V> multimap = new MultiKeyMap<>();              final MultiKey<K> key = keys[i];             final V value = values[i];              switch (key.size()) {             case 2:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 break;             case 3:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 break;             case 4:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 break;             case 5:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyPutWithNullKey() {         final MultiKeyMap<String, String> map = new MultiKeyMap<>();         map.put("a", null, "value1");         map.put("b", null, "value2");         map.put("c", null, "value3");         map.put("a", "z",  "value4");         map.put("a", null, "value5");         map.put(null, "a", "value6");         map.put(null, null, "value7");          assertEquals(6, map.size());         assertEquals("value5", map.get("a", null));         assertEquals("value4", map.get("a", "z"));         assertEquals("value6", map.get(null, "a"));     }      public void testMultiKeyRemove() {         final MultiKey<K>[] keys = getMultiKeyKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             resetFull();             final MultiKeyMap<K, V> multimap = getMap();             final int size = multimap.size();              final MultiKey<K> key = keys[i];             final V value = values[i];              switch (key.size()) {             case 2:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));                 break;             case 3:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 break;             case 4:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 break;             case 5:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyRemoveAll1() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I1);         assertEquals(8, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I1.equals(key.getKey(0)));         }     }      public void testMultiKeyRemoveAll2() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I2, I3);         assertEquals(9, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));         }     }      public void testMultiKeyRemoveAll3() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I1, I1, I2);         assertEquals(9, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));         }     }      public void testMultiKeyRemoveAll4() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I1, I1, I2, I3);         assertEquals(10, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));         }     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testClone() {         final MultiKeyMap<K, V> map = new MultiKeyMap<>();         map.put(new MultiKey<>((K) I1, (K) I2), (V) "1-2");         final Map<MultiKey<? extends K>, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get(new MultiKey<>((K) I1, (K) I2)), cloned.get(new MultiKey<>((K) I1, (K) I2)));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testLRUMultiKeyMap() {         final MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));         map.put((K) I1, (K) I2, (V) "1-2");         map.put((K) I1, (K) I3, (V) "1-1");         assertEquals(2, map.size());         map.put((K) I1, (K) I4, (V) "1-4");         assertEquals(2, map.size());         assertEquals(true, map.containsKey(I1, I3));         assertEquals(true, map.containsKey(I1, I4));         assertEquals(false, map.containsKey(I1, I2));          final MultiKeyMap<K, V> cloned = map.clone();         assertEquals(2, map.size());         assertEquals(true, cloned.containsKey(I1, I3));         assertEquals(true, cloned.containsKey(I1, I4));         assertEquals(false, cloned.containsKey(I1, I2));         cloned.put((K) I1, (K) I5, (V) "1-5");         assertEquals(2, cloned.size());         assertEquals(true, cloned.containsKey(I1, I4));         assertEquals(true, cloned.containsKey(I1, I5));     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/MultiKeyMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/MultiKeyMap.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public MultiKeyMap<K, V> getMap() {         return (MultiKeyMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.Map;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.MultiMap;  /**  * TestMultiValueMap.  *  * @since 3.2  */ @Deprecated public class MultiValueMapTest<K, V> extends AbstractObjectTest {      public MultiValueMapTest(final String testName) {         super(testName);     }      public void testNoMappingReturnsNull() {         final MultiValueMap<K, V> map = createTestMap();         assertNull(map.get("whatever"));     }      @SuppressWarnings("unchecked")     public void testValueCollectionType() {         final MultiValueMap<K, V> map = createTestMap(LinkedList.class);         assertTrue(map.get("one") instanceof LinkedList);     }      @SuppressWarnings("unchecked")     public void testMultipleValues() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         final HashSet<V> expected = new HashSet<>();         expected.add((V) "uno");         expected.add((V) "un");         assertEquals(expected, map.get("one"));     }      @SuppressWarnings("unchecked")     public void testContainsValue() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         assertTrue(map.containsValue("uno"));         assertTrue(map.containsValue("un"));         assertTrue(map.containsValue("dos"));         assertTrue(map.containsValue("deux"));         assertTrue(map.containsValue("tres"));         assertTrue(map.containsValue("trois"));         assertFalse(map.containsValue("quatro"));     }      @SuppressWarnings("unchecked")     public void testKeyContainsValue() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         assertTrue(map.containsValue("one", "uno"));         assertTrue(map.containsValue("one", "un"));         assertTrue(map.containsValue("two", "dos"));         assertTrue(map.containsValue("two", "deux"));         assertTrue(map.containsValue("three", "tres"));         assertTrue(map.containsValue("three", "trois"));         assertFalse(map.containsValue("four", "quatro"));     }      @SuppressWarnings("unchecked")     public void testValues() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         final HashSet<V> expected = new HashSet<>();         expected.add((V) "uno");         expected.add((V) "dos");         expected.add((V) "tres");         expected.add((V) "un");         expected.add((V) "deux");         expected.add((V) "trois");         final Collection<Object> c = map.values();         assertEquals(6, c.size());         assertEquals(expected, new HashSet<>(c));     }      @SuppressWarnings("unchecked")     private MultiValueMap<K, V> createTestMap() {         return createTestMap(ArrayList.class);     }      @SuppressWarnings("unchecked")     private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(final Class<C> collectionClass) {         final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);         map.put((K) "one", (V) "uno");         map.put((K) "one", (V) "un");         map.put((K) "two", (V) "dos");         map.put((K) "two", (V) "deux");         map.put((K) "three", (V) "tres");         map.put((K) "three", (V) "trois");         return map;     }      public void testKeyedIterator() {         final MultiValueMap<K, V> map = createTestMap();         final ArrayList<Object> actual = new ArrayList<>(IteratorUtils.toList(map.iterator("one")));         final ArrayList<Object> expected = new ArrayList<>(Arrays.asList("uno", "un"));         assertEquals(expected, actual);     }      public void testRemoveAllViaIterator() {         final MultiValueMap<K, V> map = createTestMap();         for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertNull(map.get("one"));         assertTrue(map.isEmpty());     }      public void testRemoveAllViaKeyedIterator() {         final MultiValueMap<K, V> map = createTestMap();         for (final Iterator<?> i = map.iterator("one"); i.hasNext();) {             i.next();             i.remove();         }         assertNull(map.get("one"));         assertEquals(4, map.totalSize());     }      public void testIterator() {         final MultiValueMap<K, V> map = createTestMap();         @SuppressWarnings("unchecked")         final Collection<V> values = new ArrayList<>((Collection<V>) map.values());         final Iterator<Map.Entry<K, V>> iterator = map.iterator();         while (iterator.hasNext()) {             final Map.Entry<K, V> entry = iterator.next();             assertTrue(map.containsValue(entry.getKey(), entry.getValue()));             assertTrue(values.contains(entry.getValue()));             assertTrue(values.remove(entry.getValue()));         }         assertTrue(values.isEmpty());     }      public void testRemoveAllViaEntryIterator() {         final MultiValueMap<K, V> map = createTestMap();         for (final Iterator<?> i = map.iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertNull(map.get("one"));         assertEquals(0, map.totalSize());     }      public void testTotalSizeA() {         assertEquals(6, createTestMap().totalSize());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMapEquals() {         final MultiValueMap<K, V> one = new MultiValueMap<>();         final Integer value = Integer.valueOf(1);         one.put((K) "One", value);         one.removeMapping("One", value);          final MultiValueMap<K, V> two = new MultiValueMap<>();         assertEquals(two, one);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testGetCollection() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         map.put((K) "A", "AA");         assertSame(map.get("A"), map.getCollection("A"));     }      @SuppressWarnings("unchecked")     public void testTotalSize() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(0, map.totalSize());         map.put((K) "A", "AA");         assertEquals(1, map.totalSize());         map.put((K) "B", "BA");         assertEquals(2, map.totalSize());         map.put((K) "B", "BB");         assertEquals(3, map.totalSize());         map.put((K) "B", "BC");         assertEquals(4, map.totalSize());         map.remove("A");         assertEquals(3, map.totalSize());         map.removeMapping("B", "BC");         assertEquals(2, map.totalSize());     }      @SuppressWarnings("unchecked")     public void testSize() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(0, map.size());         map.put((K) "A", "AA");         assertEquals(1, map.size());         map.put((K) "B", "BA");         assertEquals(2, map.size());         map.put((K) "B", "BB");         assertEquals(2, map.size());         map.put((K) "B", "BC");         assertEquals(2, map.size());         map.remove("A");         assertEquals(1, map.size());         map.removeMapping("B", "BC");         assertEquals(1, map.size());     }      @SuppressWarnings("unchecked")     public void testSize_Key() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(0, map.size("A"));         assertEquals(0, map.size("B"));         map.put((K) "A", "AA");         assertEquals(1, map.size("A"));         assertEquals(0, map.size("B"));         map.put((K) "B", "BA");         assertEquals(1, map.size("A"));         assertEquals(1, map.size("B"));         map.put((K) "B", "BB");         assertEquals(1, map.size("A"));         assertEquals(2, map.size("B"));         map.put((K) "B", "BC");         assertEquals(1, map.size("A"));         assertEquals(3, map.size("B"));         map.remove("A");         assertEquals(0, map.size("A"));         assertEquals(3, map.size("B"));         map.removeMapping("B", "BC");         assertEquals(0, map.size("A"));         assertEquals(2, map.size("B"));     }      @SuppressWarnings("unchecked")     public void testIterator_Key() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(false, map.iterator("A").hasNext());         map.put((K) "A", "AA");         final Iterator<?> it = map.iterator("A");         assertEquals(true, it.hasNext());         it.next();         assertEquals(false, it.hasNext());     }      @SuppressWarnings("unchecked")     public void testContainsValue_Key() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(false, map.containsValue("A", "AA"));         assertEquals(false, map.containsValue("B", "BB"));         map.put((K) "A", "AA");         assertEquals(true, map.containsValue("A", "AA"));         assertEquals(false, map.containsValue("A", "AB"));     }      @SuppressWarnings("unchecked")     public void testPutWithList() {         @SuppressWarnings("rawtypes")         final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);         assertEquals("a", test.put((K) "A", "a"));         assertEquals("b", test.put((K) "A", "b"));         assertEquals(1, test.size());         assertEquals(2, test.size("A"));         assertEquals(2, test.totalSize());     }      @SuppressWarnings("unchecked")     public void testPutWithSet() {         @SuppressWarnings("rawtypes")         final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);         assertEquals("a", test.put((K) "A", "a"));         assertEquals("b", test.put((K) "A", "b"));         assertEquals(null, test.put((K) "A", "a"));         assertEquals(1, test.size());         assertEquals(2, test.size("A"));         assertEquals(2, test.totalSize());     }      @SuppressWarnings("unchecked")     public void testPutAll_Map1() {         final MultiMap<K, V> original = new MultiValueMap<>();         original.put((K) "key", "object1");         original.put((K) "key", "object2");          final MultiValueMap<K, V> test = new MultiValueMap<>();         test.put((K) "keyA", "objectA");         test.put((K) "key", "object0");         test.putAll(original);          assertEquals(2, test.size());         assertEquals(4, test.totalSize());         assertEquals(1, test.getCollection("keyA").size());         assertEquals(3, test.getCollection("key").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_Map2() {         final Map<K, V> original = new HashMap<>();         original.put((K) "keyX", (V) "object1");         original.put((K) "keyY", (V) "object2");          final MultiValueMap<K, V> test = new MultiValueMap<>();         test.put((K) "keyA", "objectA");         test.put((K) "keyX", "object0");         test.putAll(original);          assertEquals(3, test.size());         assertEquals(4, test.totalSize());         assertEquals(1, test.getCollection("keyA").size());         assertEquals(2, test.getCollection("keyX").size());         assertEquals(1, test.getCollection("keyY").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_KeyCollection() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         Collection<V> coll = (Collection<V>) Arrays.asList("X", "Y", "Z");          assertEquals(true, map.putAll((K) "A", coll));         assertEquals(3, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));          assertEquals(false, map.putAll((K) "A", null));         assertEquals(3, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));          assertEquals(false, map.putAll((K) "A", new ArrayList<V>()));         assertEquals(3, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));          coll = (Collection<V>) Arrays.asList("M");         assertEquals(true, map.putAll((K) "A", coll));         assertEquals(4, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));         assertEquals(true, map.containsValue("A", "M"));     }      @SuppressWarnings("unchecked")     public void testRemove_KeyItem() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         map.put((K) "A", "AA");         map.put((K) "A", "AB");         map.put((K) "A", "AC");         assertEquals(false, map.removeMapping("C", "CA"));         assertEquals(false, map.removeMapping("A", "AD"));         assertEquals(true, map.removeMapping("A", "AC"));         assertEquals(true, map.removeMapping("A", "AB"));         assertEquals(true, map.removeMapping("A", "AA"));         assertEquals(new MultiValueMap<K, V>(), map);     }      public void testUnsafeDeSerialization() throws Exception {         final MultiValueMap map1 = MultiValueMap.multiValueMap(new HashMap(), ArrayList.class);         byte[] bytes = serialize(map1);         Object result = deserialize(bytes);         assertEquals(map1, result);          final MultiValueMap map2 = MultiValueMap.multiValueMap(new HashMap(), (Class) String.class);         bytes = serialize(map2);         try {             result = deserialize(bytes);             fail("unsafe clazz accepted when de-serializing MultiValueMap");         } catch (final UnsupportedOperationException ex) {             // expected         }     }      private byte[] serialize(final Object object) throws IOException {         final ByteArrayOutputStream baos = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(baos);          oos.writeObject(object);         oos.close();          return baos.toByteArray();     }      private Object deserialize(final byte[] data) throws IOException, ClassNotFoundException {         final ByteArrayInputStream bais = new ByteArrayInputStream(data);         final ObjectInputStream iis = new ObjectInputStream(bais);          return iis.readObject();     }      //-----------------------------------------------------------------------     // Manual serialization testing as this class cannot easily     // extend the AbstractTestMap     //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     public Object makeObject() {         @SuppressWarnings("unchecked")         final Map<String, String> m = makeEmptyMap();         m.put("a", "1");         m.put("a", "1b");         m.put("b", "2");         m.put("c", "3");         m.put("c", "3b");         m.put("d", "4");         return m;     }      @SuppressWarnings("rawtypes")     private Map makeEmptyMap() {         return new MultiValueMap();     }      public void testEmptyMapCompatibility() throws Exception {         final Map<?, ?> map = makeEmptyMap();         final Map<?, ?> map2 = (Map<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));         assertEquals("Map is empty", 0, map2.size());     }     public void testFullMapCompatibility() throws Exception {         final Map<?, ?> map = (Map<?, ?>) makeObject();         final Map<?, ?> map2 = (Map<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));         assertEquals("Map is the right size", map.size(), map2.size());         for (final Object key : map.keySet()) {             assertEquals( "Map had inequal elements", map.get(key), map2.get(key) );             map2.remove(key);         }         assertEquals("Map had extra values", 0, map2.size());     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk( //            (java.io.Serializable) makeEmptyMap(), //            "src/test/resources/data/test/MultiValueMap.emptyCollection.version4.obj"); // //        writeExternalFormToDisk( //            (java.io.Serializable) makeObject(), //            "src/test/resources/data/test/MultiValueMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.ResettableIterator;  /**  * JUnit tests.  *  */ public class LRUMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public LRUMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(LRUMapTest.class);     }      @Override     public LRUMap<K, V> makeObject() {         return new LRUMap<>();     }      /**      * {@inheritDoc}      */     @Override     public LRUMap<K, V> makeFullMap() {         return (LRUMap<K, V>) super.makeFullMap();     }      @Override     public boolean isGetStructuralModify() {         return true;     }      /**      * {@inheritDoc}      */     @Override     public LRUMap<K, V> getMap() {         return (LRUMap<K, V>) super.getMap();     }      //-----------------------------------------------------------------------     public void testCtors() {         try {             new LRUMap<K, V>(0);             fail("maxSize must be positive");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(-1, 12, 0.75f, false);             fail("maxSize must be positive");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, -1);             fail("initialSize must not be negative");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, 12);             fail("initialSize must not be larger than maxSize");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, -1, 0.75f, false);             fail("initialSize must not be negative");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, 12, 0.75f, false);             fail("initialSize must not be larger than maxSize");         } catch(final IllegalArgumentException ex) {             // expected         }     }      public void testLRU() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> kit;         Iterator<V> vit;          final LRUMap<K, V> map = new LRUMap<>(2);         assertEquals(0, map.size());         assertEquals(false, map.isFull());         assertEquals(2, map.maxSize());          map.put(keys[0], values[0]);         assertEquals(1, map.size());         assertEquals(false, map.isFull());         assertEquals(2, map.maxSize());          map.put(keys[1], values[1]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          map.put(keys[2], values[2]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[2], kit.next());         vit = map.values().iterator();         assertSame(values[1], vit.next());         assertSame(values[2], vit.next());          map.put(keys[2], values[0]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[2], kit.next());         vit = map.values().iterator();         assertSame(values[1], vit.next());         assertSame(values[0], vit.next());          map.put(keys[1], values[3]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[2], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[3], vit.next());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testReset() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         ((ResettableIterator<K>) ordered.mapIterator()).reset();          resetFull();         ordered = getMap();         final List<K> list = new ArrayList<>(ordered.keySet());         final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();         assertSame(list.get(0), it.next());         assertSame(list.get(1), it.next());         it.reset();         assertSame(list.get(0), it.next());     }      //-----------------------------------------------------------------------     public void testAccessOrder() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> kit;         Iterator<V> vit;          resetEmpty();         map.put(keys[0], values[0]);         map.put(keys[1], values[1]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         map.put(keys[1], values[1]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         map.put(keys[1], values[2]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[2], vit.next());          // change to order         map.put(keys[0], values[3]);         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = map.values().iterator();         assertSame(values[2], vit.next());         assertSame(values[3], vit.next());          // change to order         map.get(keys[1]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[3], vit.next());         assertSame(values[2], vit.next());          // change to order         map.get(keys[0]);         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = map.values().iterator();         assertSame(values[2], vit.next());         assertSame(values[3], vit.next());          // no change to order         map.get(keys[0]);         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = map.values().iterator();         assertSame(values[2], vit.next());         assertSame(values[3], vit.next());     }      public void testAccessOrder2() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> kit;         Iterator<V> vit;          resetEmpty();         final LRUMap<K, V> lruMap = (LRUMap<K, V>) map;          lruMap.put(keys[0], values[0]);         lruMap.put(keys[1], values[1]);         kit = lruMap.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = lruMap.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         lruMap.put(keys[1], values[1]);         kit = lruMap.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = lruMap.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         lruMap.get(keys[1], false);         kit = lruMap.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = lruMap.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // change to order         lruMap.get(keys[0], true);         kit = lruMap.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = lruMap.values().iterator();         assertSame(values[1], vit.next());         assertSame(values[0], vit.next());     }      @SuppressWarnings("unchecked")     public void testClone() {         final LRUMap<K, V> map = new LRUMap<>(10);         map.put((K) "1", (V) "1");         final Map<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }      @SuppressWarnings("unchecked")     public void testRemoveLRU() {         final MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<>(2);         assertNull(map.entry);         map.put((K) "A", "a");         assertNull(map.entry);         map.put((K) "B", "b");         assertNull(map.entry);         map.put((K) "C", "c");  // removes oldest, which is A=a         assertNotNull(map.entry);         assertEquals("A", map.key);         assertEquals("a", map.value);         assertEquals("C", map.entry.getKey());  // entry is reused         assertEquals("c", map.entry.getValue());  // entry is reused         assertEquals(false, map.containsKey("A"));         assertEquals(true, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = -2126883654452042477L;         LinkEntry<K, V> entry;         K key;         V value;          MockLRUMapSubclass(final int size) {             super(size);         }          @Override         protected boolean removeLRU(final LinkEntry<K, V> entry) {             this.entry = entry;             this.key = entry.getKey();             this.value = entry.getValue();             return true;         }     }      @SuppressWarnings("unchecked")     public void testRemoveLRUBlocksRemove() {         final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<>(2, false);         assertEquals(0, map.size());         map.put((K) "A", (V) "a");         assertEquals(1, map.size());         map.put((K) "B", (V) "b");         assertEquals(2, map.size());         map.put((K) "C", (V) "c");  // should remove oldest, which is A=a, but this is blocked         assertEquals(3, map.size());         assertEquals(2, map.maxSize());         assertEquals(true, map.containsKey("A"));         assertEquals(true, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      @SuppressWarnings("unchecked")     public void testRemoveLRUBlocksRemoveScan() {         final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<>(2, true);         assertEquals(0, map.size());         map.put((K) "A", (V) "a");         assertEquals(1, map.size());         map.put((K) "B", (V) "b");         assertEquals(2, map.size());         map.put((K) "C", (V) "c");  // should remove oldest, which is A=a, but this is blocked         assertEquals(3, map.size());         assertEquals(2, map.maxSize());         assertEquals(true, map.containsKey("A"));         assertEquals(true, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = 6278917461128992945L;          MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove) {             super(size, scanUntilRemove);         }          @Override         protected boolean removeLRU(final LinkEntry<K, V> entry) {             return false;         }     }      @SuppressWarnings("unchecked")     public void testRemoveLRUFirstBlocksRemove() {         final MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<>(2);         assertEquals(0, map.size());         map.put((K) "A", (V) "a");         assertEquals(1, map.size());         map.put((K) "B", (V) "b");         assertEquals(2, map.size());         map.put((K) "C", (V) "c");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b         assertEquals(2, map.size());         assertEquals(2, map.maxSize());         assertEquals(true, map.containsKey("A"));         assertEquals(false, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = -6939790801702973428L;          MockLRUMapSubclassFirstBlocksRemove(final int size) {             super(size, true);         }          @Override         protected boolean removeLRU(final LinkEntry<K, V> entry) {             if ("a".equals(entry.getValue())) {                 return false;             }             return true;         }     }      //-----------------------------------------------------------------------     static class SingleHashCode {         private final String code;         SingleHashCode(final String code) {             this.code = code;         }         @Override         public int hashCode() {             // always return the same hashcode             // that way, it will end up in the same bucket             return 12;         }         @Override         public String toString() {             return "SingleHashCode:" + code;         }     }      @SuppressWarnings("unchecked")     public void testInternalState_Buckets() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final SingleHashCode one = new SingleHashCode("1");         final SingleHashCode two = new SingleHashCode("2");         final SingleHashCode three = new SingleHashCode("3");         final SingleHashCode four = new SingleHashCode("4");         final SingleHashCode five = new SingleHashCode("5");         final SingleHashCode six = new SingleHashCode("6");          final LRUMap<K, V> map = new LRUMap<>(3, 1.0f);         final int hashIndex = map.hashIndex(map.hash(one), 4);         map.put((K) one, (V) "A");         map.put((K) two, (V) "B");         map.put((K) three, (V) "C");          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(one, map.header.after.key);  // LRU         assertEquals(two, map.header.after.after.key);         assertEquals(three, map.header.after.after.after.key);  // MRU         assertEquals(three, map.data[hashIndex].key);         assertEquals(two, map.data[hashIndex].next.key);         assertEquals(one, map.data[hashIndex].next.next.key);          map.put((K) four, (V) "D");  // reuses last in next list          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(two, map.header.after.key);  // LRU         assertEquals(three, map.header.after.after.key);         assertEquals(four, map.header.after.after.after.key);  // MRU         assertEquals(four, map.data[hashIndex].key);         assertEquals(three, map.data[hashIndex].next.key);         assertEquals(two, map.data[hashIndex].next.next.key);          map.get(three);          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(two, map.header.after.key);  // LRU         assertEquals(four, map.header.after.after.key);         assertEquals(three, map.header.after.after.after.key);  // MRU         assertEquals(four, map.data[hashIndex].key);         assertEquals(three, map.data[hashIndex].next.key);         assertEquals(two, map.data[hashIndex].next.next.key);          map.put((K) five, (V) "E");  // reuses last in next list          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(four, map.header.after.key);  // LRU         assertEquals(three, map.header.after.after.key);         assertEquals(five, map.header.after.after.after.key);  // MRU         assertEquals(five, map.data[hashIndex].key);         assertEquals(four, map.data[hashIndex].next.key);         assertEquals(three, map.data[hashIndex].next.next.key);          map.get(three);         map.get(five);          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(four, map.header.after.key);  // LRU         assertEquals(three, map.header.after.after.key);         assertEquals(five, map.header.after.after.after.key);  // MRU         assertEquals(five, map.data[hashIndex].key);         assertEquals(four, map.data[hashIndex].next.key);         assertEquals(three, map.data[hashIndex].next.next.key);          map.put((K) six, (V) "F");  // reuses middle in next list          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(three, map.header.after.key);  // LRU         assertEquals(five, map.header.after.after.key);         assertEquals(six, map.header.after.after.after.key);  // MRU         assertEquals(six, map.data[hashIndex].key);         assertEquals(five, map.data[hashIndex].next.key);         assertEquals(three, map.data[hashIndex].next.next.key);     }      @SuppressWarnings("unchecked")     public void testInternalState_getEntry_int() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final SingleHashCode one = new SingleHashCode("1");         final SingleHashCode two = new SingleHashCode("2");         final SingleHashCode three = new SingleHashCode("3");          final LRUMap<K, V> map = new LRUMap<>(3, 1.0f);         map.put((K) one, (V) "A");         map.put((K) two, (V) "B");         map.put((K) three, (V) "C");          assertEquals(one, map.getEntry(0).key);         assertEquals(two, map.getEntry(1).key);         assertEquals(three, map.getEntry(2).key);         try {             map.getEntry(-1);             fail();         } catch (final IndexOutOfBoundsException ex) {}         try {             map.getEntry(3);             fail();         } catch (final IndexOutOfBoundsException ex) {}     }      public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {          final LRUMap<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {                                 iter.next();                                 if (iter.getValue() == this) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {          final Map<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final Iterator<Map.Entry<Object, Thread>> iter = map.entrySet().iterator(); iter.hasNext();) {                                 final Map.Entry<Object, Thread> entry = iter.next();                                 if (entry.getValue() == this) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      public void testSynchronizedRemoveFromKeySet() throws InterruptedException {          final Map<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {                                 final String name = (String) iter.next();                                 if (name.substring(0, name.indexOf('[')).equals(getName())) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      public void testSynchronizedRemoveFromValues() throws InterruptedException {          final Map<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final Iterator<Thread> iter = map.values().iterator(); iter.hasNext();) {                                 if (iter.next() == this) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LRUMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LRUMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.SortedMap; import java.util.TreeMap;  import org.apache.commons.collections4.BulkTest;  /**  * Abstract test class for {@link java.util.SortedMap} methods and contracts.  *  */ public abstract class AbstractSortedMapTest<K, V> extends AbstractMapTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractSortedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Can't sort null keys.      *      * @return false      */     @Override     public boolean isAllowNullKey() {         return false;     }      /**      * SortedMap uses TreeMap as its known comparison.      *      * @return a map that is known to be valid      */     @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      //-----------------------------------------------------------------------     public void testComparator() { //        SortedMap<K, V> sm = makeFullMap();         // no tests I can think of     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedMap<K, V> makeFullMap() {         return (SortedMap<K, V>) super.makeFullMap();     }      public void testFirstKey() {         final SortedMap<K, V> sm = makeFullMap();         assertSame(sm.keySet().iterator().next(), sm.firstKey());     }      public void testLastKey() {         final SortedMap<K, V> sm = makeFullMap();         K obj = null;         for (final K k : sm.keySet()) {             obj = k;         }         assertSame(obj, sm.lastKey());     }      //-----------------------------------------------------------------------     public BulkTest bulkTestHeadMap() {         return new TestHeadMap<>(this);     }      public BulkTest bulkTestTailMap() {         return new TestTailMap<>(this);     }      public BulkTest bulkTestSubMap() {         return new TestSubMap<>(this);     }      public abstract static class TestViewMap<K, V> extends AbstractSortedMapTest<K, V> {         protected final AbstractMapTest<K, V> main;         protected final List<K> subSortedKeys = new ArrayList<>();         protected final List<V> subSortedValues = new ArrayList<>();         protected final List<V> subSortedNewValues = new ArrayList<>();          public TestViewMap(final String name, final AbstractMapTest<K, V> main) {             super(name);             this.main = main;         }         @Override         public void resetEmpty() {             // needed to init verify correctly             main.resetEmpty();             super.resetEmpty();         }         @Override         public void resetFull() {             // needed to init verify correctly             main.resetFull();             super.resetFull();         }         @Override         public void verify() {             // cross verify changes on view with changes on main map             super.verify();             main.verify();         }         @Override         public BulkTest bulkTestHeadMap() {             return null;  // block infinite recursion         }         @Override         public BulkTest bulkTestTailMap() {             return null;  // block infinite recursion         }         @Override         public BulkTest bulkTestSubMap() {             return null;  // block infinite recursion         }          @Override         @SuppressWarnings("unchecked")         public K[] getSampleKeys() {             return (K[]) subSortedKeys.toArray();         }         @Override         @SuppressWarnings("unchecked")         public V[] getSampleValues() {             return (V[]) subSortedValues.toArray();         }         @Override         @SuppressWarnings("unchecked")         public V[] getNewSampleValues() {             return (V[]) subSortedNewValues.toArray();         }          @Override         public boolean isAllowNullKey() {             return main.isAllowNullKey();         }         @Override         public boolean isAllowNullValue() {             return main.isAllowNullValue();         }         @Override         public boolean isPutAddSupported() {             return main.isPutAddSupported();         }         @Override         public boolean isPutChangeSupported() {             return main.isPutChangeSupported();         }         @Override         public boolean isRemoveSupported() {             return main.isRemoveSupported();         }         @Override         public boolean isTestSerialization() {             return false;         } //        public void testSimpleSerialization() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testSimpleSerialization(); //        } //        public void testSerializeDeserializeThenCompare() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testSerializeDeserializeThenCompare(); //        } //        public void testEmptyMapCompatibility() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testEmptyMapCompatibility(); //        } //        public void testFullMapCompatibility() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testFullMapCompatibility(); //        }     }      public static class TestHeadMap<K, V> extends TestViewMap<K, V> {         static final int SUBSIZE = 6;         final K toKey;          public TestHeadMap(final AbstractMapTest<K, V> main) {             super("SortedMap.HeadMap", main);             final Map<K, V> sm = main.makeFullMap();             for (final Entry<K, V> entry : sm.entrySet()) {                 this.subSortedKeys.add(entry.getKey());                 this.subSortedValues.add(entry.getValue());             }             this.toKey = this.subSortedKeys.get(SUBSIZE);             this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();             this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();             this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));         }         @Override         public SortedMap<K, V> makeObject() {             // done this way so toKey is correctly set in the returned map             return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);         }         @Override         public SortedMap<K, V> makeFullMap() {             return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);         }         public void testHeadMapOutOfRange() {             if (!isPutAddSupported()) {                 return;             }             resetEmpty();             try {                 getMap().put(toKey, subSortedValues.get(0));                 fail();             } catch (final IllegalArgumentException ex) {}             verify();         }         @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion() + ".HeadMapView";         }  //        public void testCreate() throws Exception { //            Map map = makeEmptyMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.HeadMapView.obj"); //            map = makeFullMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj"); //        }     }      public static class TestTailMap<K, V> extends TestViewMap<K, V> {         static final int SUBSIZE = 6;         final K fromKey;         final K invalidKey;          public TestTailMap(final AbstractMapTest<K, V> main) {             super("SortedMap.TailMap", main);             final Map<K, V> sm = main.makeFullMap();             for (final Entry<K, V> entry : sm.entrySet()) {                 this.subSortedKeys.add(entry.getKey());                 this.subSortedValues.add(entry.getValue());             }             this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);             this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);             this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();             this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();             this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));         }         @Override         public SortedMap<K, V> makeObject() {             // done this way so toKey is correctly set in the returned map             return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);         }         @Override         public SortedMap<K, V> makeFullMap() {             return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);         }         public void testTailMapOutOfRange() {             if (!isPutAddSupported()) {                 return;             }             resetEmpty();             try {                 getMap().put(invalidKey, subSortedValues.get(0));                 fail();             } catch (final IllegalArgumentException ex) {}             verify();         }         @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion() + ".TailMapView";         }  //        public void testCreate() throws Exception { //            Map map = makeEmptyMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.TailMapView.obj"); //            map = makeFullMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj"); //        }     }      public static class TestSubMap<K, V> extends TestViewMap<K, V> {         static final int SUBSIZE = 3;         final K fromKey;         final K toKey;          public TestSubMap(final AbstractMapTest<K, V> main) {             super("SortedMap.SubMap", main);             final Map<K, V> sm = main.makeFullMap();             for (final Entry<K, V> entry : sm.entrySet()) {                 this.subSortedKeys.add(entry.getKey());                 this.subSortedValues.add(entry.getValue());             }             this.fromKey = this.subSortedKeys.get(SUBSIZE);             this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);              this.subSortedKeys.subList(0, SUBSIZE).clear();             this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();              this.subSortedValues.subList(0, SUBSIZE).clear();             this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();              this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(                 SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));         }          @Override         public SortedMap<K, V> makeObject() {             // done this way so toKey is correctly set in the returned map             return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);         }         @Override         public SortedMap<K, V> makeFullMap() {             return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);         }         public void testSubMapOutOfRange() {             if (!isPutAddSupported()) {                 return;             }             resetEmpty();             try {                 getMap().put(toKey, subSortedValues.get(0));                 fail();             } catch (final IllegalArgumentException ex) {}             verify();         }         @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion() + ".SubMapView";         }  //        public void testCreate() throws Exception { //            Map map = makeEmptyMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.SubMapView.obj"); //            map = makeFullMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj"); //        }     }      /**      * {@inheritDoc}      */     @Override     public SortedMap<K, V> getMap() {         return (SortedMap<K, V>) super.getMap();     }      /**      * {@inheritDoc}      */     @Override     public SortedMap<K, V> getConfirmed() {         return (SortedMap<K, V>) super.getConfirmed();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap;  import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractOrderedMapTest} for exercising the  * {@link UnmodifiableOrderedMap} implementation.  *  * @since 3.0  */ public class UnmodifiableOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public UnmodifiableOrderedMapTest(final String testName) {         super(testName);     }      //-------------------------------------------------------------------      @Override     public OrderedMap<K, V> makeObject() {         return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public OrderedMap<K, V> makeFullMap() {         final OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());         addSampleMappings(m);         return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final OrderedMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));          try {             UnmodifiableOrderedMap.unmodifiableOrderedMap(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableOrderedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableOrderedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map; import java.util.Set; import java.util.SortedMap; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the {@link TransformedSortedMap}  * implementation.  *  * @since 3.0  */ public class TransformedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      public TransformedSortedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedSortedMapTest.class);     }      @Override     public String[] ignoredTests() {         return null;     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public SortedMap<K, V> makeObject() {         return TransformedSortedMap.transformingSortedMap(new TreeMap<K, V>(),                 (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),                 (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          SortedMap<K, V> map = TransformedSortedMap                 .transformingSortedMap(                         new TreeMap<K, V>(),                         (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,                         null);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));             try {                 map.containsKey(els[i]);                 fail();             } catch (final ClassCastException ex) {}             assertEquals(true, map.containsValue(els[i]));             assertEquals(els[i], map.get(Integer.valueOf((String) els[i])));         }          try {             map.remove(els[0]);             fail();         } catch (final ClassCastException ex) {}         assertEquals(els[0], map.remove(Integer.valueOf((String) els[0])));          map = TransformedSortedMap                 .transformingSortedMap(                         new TreeMap<K, V>(),                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsValue(els[i]));             assertEquals(true, map.containsKey(els[i]));             assertEquals(Integer.valueOf((String) els[i]), map.get(els[i]));         }          assertEquals(Integer.valueOf((String) els[0]), map.remove(els[0]));          final Set<Map.Entry<K, V>> entrySet = map.entrySet();         final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);         array[0].setValue((V) "66");         assertEquals(Integer.valueOf(66), array[0].getValue());         assertEquals(Integer.valueOf(66), map.get(array[0].getKey()));          final Map.Entry<K, V> entry = entrySet.iterator().next();         entry.setValue((V) "88");         assertEquals(Integer.valueOf(88), entry.getValue());         assertEquals(Integer.valueOf(88), map.get(entry.getKey()));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testFactory_Decorate() {         final SortedMap<K, V> base = new TreeMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final SortedMap<K, V> trans = TransformedSortedMap                 .transformingSortedMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals("1", trans.get("A"));         assertEquals("2", trans.get("B"));         assertEquals("3", trans.get("C"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("D"));     }      @SuppressWarnings("unchecked")     public void testFactory_decorateTransform() {         final SortedMap<K, V> base = new TreeMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final SortedMap<K, V> trans = TransformedSortedMap                 .transformedSortedMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(Integer.valueOf(1), trans.get("A"));         assertEquals(Integer.valueOf(2), trans.get("B"));         assertEquals(Integer.valueOf(3), trans.get("C"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("D"));     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedSortedMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.list.AbstractListTest;  /**  * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}  * implementation.  *  * @since 3.0  */ public class ListOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public ListOrderedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ListOrderedMapTest.class);     }      @Override     public ListOrderedMap<K, V> makeObject() {         return ListOrderedMap.listOrderedMap(new HashMap<K, V>());     }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> makeFullMap() {         return (ListOrderedMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     public void testGetByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.get(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             assertSame(it.next(), lom.get(i));         }     }      public void testGetValueByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.getValue(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             it.next();             assertSame(it.getValue(), lom.getValue(i));         }     }      public void testIndexOf() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         assertEquals(-1, lom.indexOf(getOtherKeys()));          resetFull();         lom = getMap();         final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             assertEquals(i, lom.indexOf(list.get(i)));         }     }      @SuppressWarnings("unchecked")     public void testSetValueByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.setValue(0, (V) "");         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.setValue(-1, (V) "");         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.setValue(-1, (V) "");         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.setValue(lom.size(), (V) "");         } catch (final IndexOutOfBoundsException ex) {}          for (int i = 0; i < lom.size(); i++) {             final V value = lom.getValue(i);             final Object input = Integer.valueOf(i);             assertEquals(value, lom.setValue(i, (V) input));             assertEquals(input, lom.getValue(i));         }     }      public void testRemoveByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.remove(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             final Object key = list.get(i);             final Object value = lom.get(key);             assertEquals(value, lom.remove(i));             list.remove(i);             assertEquals(false, lom.containsKey(key));         }     }      @SuppressWarnings("unchecked")     public void testPut_intObjectObject() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();          try {             lom.put(1, (K) "testInsert1", (V) "testInsert1v");             fail("should not be able to insert at pos 1 in empty Map");         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.put(-1, (K) "testInsert-1", (V) "testInsert-1v");             fail("should not be able to insert at pos -1 in empty Map");         } catch (final IndexOutOfBoundsException ex) {}          // put where key doesn't exist         lom.put(0, (K) "testInsert1", (V) "testInsert1v");         assertEquals("testInsert1v", lom.getValue(0));          lom.put((K) "testInsertPut", (V) "testInsertPutv");         assertEquals("testInsert1v", lom.getValue(0));         assertEquals("testInsertPutv", lom.getValue(1));          lom.put(0, (K) "testInsert0", (V) "testInsert0v");         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("testInsert1v", lom.getValue(1));         assertEquals("testInsertPutv", lom.getValue(2));          lom.put(3, (K) "testInsert3", (V) "testInsert3v");         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("testInsert1v", lom.getValue(1));         assertEquals("testInsertPutv", lom.getValue(2));         assertEquals("testInsert3v", lom.getValue(3));          // put in a full map         resetFull();         lom = getMap();         final ListOrderedMap<K, V> lom2 = new ListOrderedMap<>();         lom2.putAll(lom);          lom2.put(0, (K) "testInsert0", (V) "testInsert0v");         assertEquals("testInsert0v", lom2.getValue(0));         for (int i = 0; i < lom.size(); i++) {             assertEquals(lom2.getValue(i + 1), lom.getValue(i));         }          // put where key does exist         final Integer i1 = Integer.valueOf(1);         final Integer i1b = Integer.valueOf(1);         final Integer i2 = Integer.valueOf(2);         final Integer i3 = Integer.valueOf(3);          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(0, (K) i1, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("One", lom.getValue(0));         assertSame(i1, lom.get(0));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(0, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("One", lom.getValue(0));         assertEquals("2", lom.getValue(1));         assertEquals("3", lom.getValue(2));         assertSame(i1b, lom.get(0));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(1, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("One", lom.getValue(0));         assertEquals("2", lom.getValue(1));         assertEquals("3", lom.getValue(2));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(2, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("2", lom.getValue(0));         assertEquals("One", lom.getValue(1));         assertEquals("3", lom.getValue(2));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(3, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("2", lom.getValue(0));         assertEquals("3", lom.getValue(1));         assertEquals("One", lom.getValue(2));     }      public void testPutAllWithIndex() {         resetEmpty();         @SuppressWarnings("unchecked")         final ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;          // Create Initial Data         lom.put("testInsert0", "testInsert0v");         lom.put("testInsert1", "testInsert1v");         lom.put("testInsert2", "testInsert2v");         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("testInsert1v", lom.getValue(1));         assertEquals("testInsert2v", lom.getValue(2));          // Create New Test Map and Add using putAll(int, Object, Object)         final Map<String, String> values = new ListOrderedMap<>();         values.put("NewInsert0", "NewInsert0v");         values.put("NewInsert1", "NewInsert1v");         lom.putAll(1, values);          // Perform Asserts         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("NewInsert0v", lom.getValue(1));         assertEquals("NewInsert1v", lom.getValue(2));         assertEquals("testInsert1v", lom.getValue(3));         assertEquals("testInsert2v", lom.getValue(4));     }      @SuppressWarnings("unchecked")     public void testPutAllWithIndexBug441() {         // see COLLECTIONS-441         resetEmpty();         final ListOrderedMap<K, V> lom = getMap();          final int size = 5;         for (int i = 0; i < size; i++) {             lom.put((K) Integer.valueOf(i), (V) Boolean.TRUE);         }          final Map<K, V> map = new TreeMap<>();         for (int i = 0; i < size; i++) {             map.put((K) Integer.valueOf(i), (V) Boolean.FALSE);         }          lom.putAll(3, map);          final List<K> orderedList = lom.asList();         for (int i = 0; i < size; i++) {             assertEquals(Integer.valueOf(i), orderedList.get(i));         }     }      //-----------------------------------------------------------------------     public void testValueList_getByIndex() {         resetFull();         final ListOrderedMap<K, V> lom = getMap();         for (int i = 0; i < lom.size(); i++) {             final V expected = lom.getValue(i);             assertEquals(expected, lom.valueList().get(i));         }     }      @SuppressWarnings("unchecked")     public void testValueList_setByIndex() {         resetFull();         final ListOrderedMap<K, V> lom = getMap();         for (int i = 0; i < lom.size(); i++) {             final Object input = Integer.valueOf(i);             final V expected = lom.getValue(i);             assertEquals(expected, lom.valueList().set(i, (V) input));             assertEquals(input, lom.getValue(i));             assertEquals(input, lom.valueList().get(i));         }     }      public void testValueList_removeByIndex() {         resetFull();         final ListOrderedMap<K, V> lom = getMap();         while (lom.size() > 1) {             final V expected = lom.getValue(1);             assertEquals(expected, lom.valueList().remove(1));         }     }      public void testCOLLECTIONS_474_nullValues () {         final Object key1 = new Object();         final Object key2 = new Object();         final HashMap<Object, Object> hmap = new HashMap<>();         hmap.put(key1, null);         hmap.put(key2, null);         assertEquals("Should have two elements", 2, hmap.size());         final ListOrderedMap<Object, Object> listMap = new ListOrderedMap<>();         listMap.put(key1, null);         listMap.put(key2, null);         assertEquals("Should have two elements", 2, listMap.size());         listMap.putAll(2, hmap);     }      public void testCOLLECTIONS_474_nonNullValues () {         final Object key1 = new Object();         final Object key2 = new Object();         final HashMap<Object, Object> hmap = new HashMap<>();         hmap.put(key1, "1");         hmap.put(key2, "2");         assertEquals("Should have two elements", 2, hmap.size());         final ListOrderedMap<Object, Object> listMap = new ListOrderedMap<>();         listMap.put(key1, "3");         listMap.put(key2, "4");         assertEquals("Should have two elements", 2, listMap.size());         listMap.putAll(2, hmap);     }      //-----------------------------------------------------------------------     public BulkTest bulkTestKeyListView() {         return new TestKeyListView();     }      public BulkTest bulkTestValueListView() {         return new TestValueListView();     }      //-----------------------------------------------------------------------     public class TestKeyListView extends AbstractListTest<K> {         TestKeyListView() {             super("TestKeyListView");         }          @Override         public List<K> makeObject() {             return ListOrderedMapTest.this.makeObject().keyList();         }         @Override         public List<K> makeFullCollection() {             return ListOrderedMapTest.this.makeFullMap().keyList();         }          @Override         public K[] getFullElements() {             return ListOrderedMapTest.this.getSampleKeys();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return false;         }         @Override         public boolean isSetSupported() {             return false;         }         @Override         public boolean isNullSupported() {             return ListOrderedMapTest.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      //-----------------------------------------------------------------------     public class TestValueListView extends AbstractListTest<V> {         TestValueListView() {             super("TestValueListView");         }          @Override         public List<V> makeObject() {             return ListOrderedMapTest.this.makeObject().valueList();         }         @Override         public List<V> makeFullCollection() {             return ListOrderedMapTest.this.makeFullMap().valueList();         }          @Override         public V[] getFullElements() {             return ListOrderedMapTest.this.getSampleValues();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return true;         }         @Override         public boolean isSetSupported() {             return true;         }         @Override         public boolean isNullSupported() {             return ListOrderedMapTest.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ListOrderedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ListOrderedMap.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> getMap() {         return (ListOrderedMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map; import java.util.HashMap; import java.util.Collection;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link CompositeMap} implementation.  *  * @since 3.0  */ public class CompositeMapTest<K, V> extends AbstractIterableMapTest<K, V> {     /** used as a flag in MapMutator tests */     private boolean pass = false;      public CompositeMapTest(final String testName) {         super(testName);     }      @Override     public void setUp() throws Exception {         super.setUp();         this.pass = false;     }      @Override     public CompositeMap<K, V> makeObject() {         final CompositeMap<K, V> map = new CompositeMap<>();         map.addComposited(new HashMap<K, V>());         map.setMutator( new EmptyMapMutator<K, V>() );         return map;     }      @SuppressWarnings("unchecked")     private Map<K, V> buildOne() {         final HashMap<K, V> map = new HashMap<>();         map.put((K) "1", (V) "one");         map.put((K) "2", (V) "two");         return map;     }      @SuppressWarnings("unchecked")     public Map<K, V> buildTwo() {         final HashMap<K, V> map = new HashMap<>();         map.put((K) "3", (V) "three");         map.put((K) "4", (V) "four");         return map;     }      public void testGet() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         assertEquals("one", map.get("1"));         assertEquals("four", map.get("4"));     }      @SuppressWarnings("unchecked")     public void testAddComposited() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));         try {             map.addComposited(three);             fail("Expecting IllegalArgumentException.");         } catch (final IllegalArgumentException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testRemoveComposited() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));          map.removeComposited(three);         assertFalse(map.containsKey("5"));          map.removeComposited(buildOne());         assertFalse(map.containsKey("2"));      }      @SuppressWarnings("unchecked")     public void testRemoveFromUnderlying() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));          //Now remove "5"         three.remove("5");         assertFalse(map.containsKey("5"));     }      @SuppressWarnings("unchecked")     public void testRemoveFromComposited() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));          //Now remove "5"         map.remove("5");         assertFalse(three.containsKey("5"));     }      public void testResolveCollision() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),             new CompositeMap.MapMutator<K, V>() {                 private static final long serialVersionUID = 1L;                  @Override                 public void resolveCollision(final CompositeMap<K, V> composite,                     final Map<K, V> existing,                     final Map<K, V> added,                     final Collection<K> intersect) {                     pass = true;                 }                  @Override                 public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,                     final V value) {                     throw new UnsupportedOperationException();                 }                  @Override                 public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {                     throw new UnsupportedOperationException();                 }             });          map.addComposited(buildOne());         assertTrue(pass);     }      @SuppressWarnings("unchecked")     public void testPut() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),             new CompositeMap.MapMutator<K, V>() {                 private static final long serialVersionUID = 1L;                 @Override                 public void resolveCollision(final CompositeMap<K, V> composite,                     final Map<K, V> existing,                     final Map<K, V> added,                     final Collection<K> intersect) {                     throw new UnsupportedOperationException();                 }                  @Override                 public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,                     final V value) {                     pass = true;                     return (V) "foo";                 }                  @Override                 public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {                     throw new UnsupportedOperationException();                 }             });          map.put((K) "willy", (V) "wonka");         assertTrue(pass);     }      public void testPutAll() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),             new CompositeMap.MapMutator<K, V>() {                 private static final long serialVersionUID = 1L;                 @Override                 public void resolveCollision(final CompositeMap<K, V> composite,                     final Map<K, V> existing,                     final Map<K, V> added,                     final Collection<K> intersect) {                     throw new UnsupportedOperationException();                 }                  @Override                 public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,                     final V value) {                     throw new UnsupportedOperationException();                 }                  @Override                 public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {                     pass = true;                 }             });          map.putAll(null);         assertTrue(pass);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CompositeMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CompositeMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.keyvalue.DefaultMapEntry; import org.apache.commons.collections4.set.AbstractSetTest;  /**  * Abstract test class for {@link java.util.Map} methods and contracts.  * <p>  * The forces at work here are similar to those in {@link AbstractCollectionTest}.  * If your class implements the full Map interface, including optional  * operations, simply extend this class, and implement the  * {@link #makeObject()} method.  * <p>  * On the other hand, if your map implementation is weird, you may have to  * override one or more of the other protected methods.  They're described  * below.  * <p>  * <b>Entry Population Methods</b>  * <p>  * Override these methods if your map requires special entries:  *  * <ul>  * <li>{@link #getSampleKeys()}  * <li>{@link #getSampleValues()}  * <li>{@link #getNewSampleValues()}  * <li>{@link #getOtherKeys()}  * <li>{@link #getOtherValues()}  * </ul>  *  * <b>Supported Operation Methods</b>  * <p>  * Override these methods if your map doesn't support certain operations:  *  * <ul>  * <li> {@link #isPutAddSupported()}  * <li> {@link #isPutChangeSupported()}  * <li> {@link #isSetValueSupported()}  * <li> {@link #isRemoveSupported()}  * <li> {@link #isGetStructuralModify()}  * <li> {@link #isAllowDuplicateValues()}  * <li> {@link #isAllowNullKey()}  * <li> {@link #isAllowNullValue()}  * </ul>  *  * <b>Fixture Methods</b>  * <p>  * For tests on modification operations (puts and removes), fixtures are used  * to verify that that operation results in correct state for the map and its  * collection views.  Basically, the modification is performed against your  * map implementation, and an identical modification is performed against  * a <I>confirmed</I> map implementation.  A confirmed map implementation is  * something like <Code>java.util.HashMap</Code>, which is known to conform  * exactly to the {@link Map} contract.  After the modification takes place  * on both your map implementation and the confirmed map implementation, the  * two maps are compared to see if their state is identical.  The comparison  * also compares the collection views to make sure they're still the same.<P>  *  * The upshot of all that is that <I>any</I> test that modifies the map in  * <I>any</I> way will verify that <I>all</I> of the map's state is still  * correct, including the state of its collection views.  So for instance  * if a key is removed by the map's key set's iterator, then the entry set  * is checked to make sure the key/value pair no longer appears.<P>  *  * The {@link #map} field holds an instance of your collection implementation.  * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold  * that map's collection views.  And the {@link #confirmed} field holds  * an instance of the confirmed collection implementation.  The  * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to  * empty or full maps, so that tests can proceed from a known state.<P>  *  * After a modification operation to both {@link #map} and {@link #confirmed},  * the {@link #verify()} method is invoked to compare the results.  The  * {@link #verify} method calls separate methods to verify the map and its three  * collection views ({@link #verifyMap}, {@link #verifyEntrySet},  * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override  * one of the verification methods to perform additional verifications.  For  * instance, TestDoubleOrderedMap would want override its  * {@link #verifyValues()} method to verify that the values are unique and in  * ascending order.<P>  *  * <b>Other Notes</b>  * <p>  * If your {@link Map} fails one of these tests by design, you may still use  * this base set of cases.  Simply override the test case (method) your map  * fails and/or the methods that define the assumptions used by the test  * cases.  For example, if your map does not allow duplicate values, override  * {@link #isAllowDuplicateValues()} and have it return {@code false}  *  */ public abstract class AbstractMapTest<K, V> extends AbstractObjectTest {      /**      * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString      * This avoids nulls for JDK1.2      */     private static final boolean JDK12;     static {         final String str = System.getProperty("java.version");         JDK12 = str.startsWith("1.2");     }      // These instance variables are initialized with the reset method.     // Tests for map methods that alter the map (put, putAll, remove)     // first call reset() to create the map and its views; then perform     // the modification on the map; perform the same modification on the     // confirmed; and then call verify() to ensure that the map is equal     // to the confirmed, that the already-constructed collection views     // are still equal to the confirmed's collection views.      /** Map created by reset(). */     protected Map<K, V> map;      /** Entry set of map created by reset(). */     protected Set<Map.Entry<K, V>> entrySet;      /** Key set of map created by reset(). */     protected Set<K> keySet;      /** Values collection of map created by reset(). */     protected Collection<V> values;      /** HashMap created by reset(). */     protected Map<K, V> confirmed;      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractMapTest(final String testName) {         super(testName);     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code put} and {@code putAll} operations      * adding new mappings.      * <p>      * Default implementation returns true.      * Override if your collection class does not support put adding.      */     public boolean isPutAddSupported() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code put} and {@code putAll} operations      * changing existing mappings.      * <p>      * Default implementation returns true.      * Override if your collection class does not support put changing.      */     public boolean isPutChangeSupported() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code setValue} operation on entrySet entries.      * <p>      * Default implementation returns isPutChangeSupported().      * Override if your collection class does not support setValue but does      * support put changing.      */     public boolean isSetValueSupported() {         return isPutChangeSupported();     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code remove} and {@code clear} operations.      * <p>      * Default implementation returns true.      * Override if your collection class does not support removal operations.      */     public boolean isRemoveSupported() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * can cause structural modification on a get(). The example is LRUMap.      * <p>      * Default implementation returns false.      * Override if your map class structurally modifies on get.      */     public boolean isGetStructuralModify() {         return false;     }      /**      * Returns whether the sub map views of SortedMap are serializable.      * If the class being tested is based around a TreeMap then you should      * override and return false as TreeMap has a bug in deserialization.      *      * @return false      */     public boolean isSubMapViewsSerializable() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * supports null keys.      * <p>      * Default implementation returns true.      * Override if your collection class does not support null keys.      */     public boolean isAllowNullKey() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * supports null values.      * <p>      * Default implementation returns true.      * Override if your collection class does not support null values.      */     public boolean isAllowNullValue() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * supports duplicate values.      * <p>      * Default implementation returns true.      * Override if your collection class does not support duplicate values.      */     public boolean isAllowDuplicateValues() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * provide fail-fast behavior on their various iterators.      * <p>      * Default implementation returns true.      * Override if your collection class does not support fast failure.      */     public boolean isFailFastExpected() {         return true;     }      public boolean areEqualElementsDistinguishable() {         return false;     }      /**      *  Returns the set of keys in the mappings used to test the map.  This      *  method must return an array with the same length as {@link      *  #getSampleValues()} and all array elements must be different. The      *  default implementation constructs a set of String keys, and includes a      *  single null key if {@link #isAllowNullKey()} returns {@code true}.      */     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         final Object[] result = new Object[] {             "blah", "foo", "bar", "baz", "tmp", "gosh", "golly", "gee",             "hello", "goodbye", "we'll", "see", "you", "all", "again",             "key",             "key2",             isAllowNullKey() && !JDK12 ? null : "nonnullkey"         };         return (K[]) result;     }      @SuppressWarnings("unchecked")     public K[] getOtherKeys() {         return (K[]) getOtherNonNullStringElements();     }      @SuppressWarnings("unchecked")     public V[] getOtherValues() {         return (V[]) getOtherNonNullStringElements();     }      @SuppressWarnings("unchecked")     protected <E> List<E> getAsList(final Object[] o) {         final ArrayList<E> result = new ArrayList<>();         for (final Object element : o) {             result.add((E) element);         }         return result;     }      /**      * Returns a list of string elements suitable for return by      * {@link #getOtherKeys()} or {@link #getOtherValues}.      *      * <p>Override getOtherElements to return the results of this method if your      * collection does not support heterogenous elements or the null element.      * </p>      */     public Object[] getOtherNonNullStringElements() {         return new Object[] {             "For", "then", "despite", /* of */"space", "I", "would", "be", "brought",             "From", "limits", "far", "remote", "where", "thou", "dost", "stay"         };     }      /**      * Returns the set of values in the mappings used to test the map.  This      * method must return an array with the same length as      * {@link #getSampleKeys()}.  The default implementation constructs a set of      * String values and includes a single null value if      * {@link #isAllowNullValue()} returns {@code true}, and includes      * two values that are the same if {@link #isAllowDuplicateValues()} returns      * {@code true}.      */     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         final Object[] result = new Object[] {             "blahv", "foov", "barv", "bazv", "tmpv", "goshv", "gollyv", "geev",             "hellov", "goodbyev", "we'llv", "seev", "youv", "allv", "againv",             isAllowNullValue() && !JDK12 ? null : "nonnullvalue",             "value",             isAllowDuplicateValues() ? "value" : "value2",         };         return (V[]) result;     }      /**      * Returns a the set of values that can be used to replace the values      * returned from {@link #getSampleValues()}.  This method must return an      * array with the same length as {@link #getSampleValues()}.  The values      * returned from this method should not be the same as those returned from      * {@link #getSampleValues()}.  The default implementation constructs a      * set of String values and includes a single null value if      * {@link #isAllowNullValue()} returns {@code true}, and includes two values      * that are the same if {@link #isAllowDuplicateValues()} returns      * {@code true}.      */     @SuppressWarnings("unchecked")     public V[] getNewSampleValues() {         final Object[] result = new Object[] {             isAllowNullValue() && !JDK12 && isAllowDuplicateValues() ? null : "newnonnullvalue",             "newvalue",             isAllowDuplicateValues() ? "newvalue" : "newvalue2",             "newblahv", "newfoov", "newbarv", "newbazv", "newtmpv", "newgoshv",             "newgollyv", "newgeev", "newhellov", "newgoodbyev", "newwe'llv",             "newseev", "newyouv", "newallv", "newagainv",         };         return (V[]) result;     }      /**      *  Helper method to add all the mappings described by      * {@link #getSampleKeys()} and {@link #getSampleValues()}.      */     public void addSampleMappings(final Map<? super K, ? super V> m) {          final K[] keys = getSampleKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             try {                 m.put(keys[i], values[i]);             } catch (final NullPointerException exception) {                 assertTrue("NullPointerException only allowed to be thrown " +                            "if either the key or value is null.",                            keys[i] == null || values[i] == null);                  assertTrue("NullPointerException on null key, but " +                            "isAllowNullKey is not overridden to return false.",                            keys[i] == null || !isAllowNullKey());                  assertTrue("NullPointerException on null value, but " +                            "isAllowNullValue is not overridden to return false.",                            values[i] == null || !isAllowNullValue());                  assertTrue("Unknown reason for NullPointer.", false);             }         }         assertEquals("size must reflect number of mappings added.",                      keys.length, m.size());     }      //-----------------------------------------------------------------------     /**      * Return a new, empty {@link Map} to be used for testing.      *      * @return the map to be tested      */     @Override     public abstract Map<K, V> makeObject();      /**      * Return a new, populated map.  The mappings in the map should match the      * keys and values returned from {@link #getSampleKeys()} and      * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()      * and calls {@link #addSampleMappings} to add all the mappings to the      * map.      *      * @return the map to be tested      */     public Map<K, V> makeFullMap() {         final Map<K, V> m = makeObject();         addSampleMappings(m);         return m;     }      /**      * Override to return a map other than HashMap as the confirmed map.      *      * @return a map that is known to be valid      */     public Map<K, V> makeConfirmedMap() {         return new HashMap<>();     }      /**      * Creates a new Map Entry that is independent of the first and the map.      */     public static <K, V> Map.Entry<K, V> cloneMapEntry(final Map.Entry<K, V> entry) {         final HashMap<K, V> map = new HashMap<>();         map.put(entry.getKey(), entry.getValue());         return map.entrySet().iterator().next();     }      /**      * Gets the compatibility version, needed for package access.      */     @Override     public String getCompatibilityVersion() {         return super.getCompatibilityVersion();     }      //-----------------------------------------------------------------------     /**      * Test to ensure the test setup is working properly.  This method checks      * to ensure that the getSampleKeys and getSampleValues methods are      * returning results that look appropriate.  That is, they both return a      * non-null array of equal length.  The keys array must not have any      * duplicate values, and may only contain a (single) null key if      * isNullKeySupported() returns true.  The values array must only have a null      * value if useNullValue() is true and may only have duplicate values if      * isAllowDuplicateValues() returns true.      */     public void testSampleMappings() {         final Object[] keys = getSampleKeys();         final Object[] values = getSampleValues();         final Object[] newValues = getNewSampleValues();          assertNotNull("failure in test: Must have keys returned from " +                  "getSampleKeys.", keys);          assertNotNull("failure in test: Must have values returned from " +                  "getSampleValues.", values);          // verify keys and values have equivalent lengths (in case getSampleX are         // overridden)         assertEquals("failure in test: not the same number of sample " +                    "keys and values.",  keys.length, values.length);          assertEquals("failure in test: not the same number of values and new values.",                    values.length, newValues.length);          // verify there aren't duplicate keys, and check values         for (int i = 0; i < keys.length - 1; i++) {             for (int j = i + 1; j < keys.length; j++) {                 assertTrue("failure in test: duplicate null keys.",                         keys[i] != null || keys[j] != null);                 assertTrue(                         "failure in test: duplicate non-null key.",                         keys[i] == null || keys[j] == null || !keys[i].equals(keys[j]) && !keys[j]                                 .equals(keys[i]));             }             assertTrue("failure in test: found null key, but isNullKeySupported " + "is false.",                     keys[i] != null || isAllowNullKey());             assertTrue(                     "failure in test: found null value, but isNullValueSupported " + "is false.",                     values[i] != null || isAllowNullValue());             assertTrue("failure in test: found null new value, but isNullValueSupported "                     + "is false.", newValues[i] != null || isAllowNullValue());             assertTrue("failure in test: values should not be the same as new value",                     values[i] != newValues[i]                             && (values[i] == null || !values[i].equals(newValues[i])));         }     }      // tests begin here.  Each test adds a little bit of tested functionality.     // Many methods assume previous methods passed.  That is, they do not     // exhaustively recheck things that have already been checked in a previous     // test methods.      /**      * Test to ensure that makeEmptyMap and makeFull returns a new non-null      * map with each invocation.      */     public void testMakeMap() {         final Map<K, V> em = makeObject();         assertTrue("failure in test: makeEmptyMap must return a non-null map.",                    em != null);          final Map<K, V> em2 = makeObject();         assertTrue("failure in test: makeEmptyMap must return a non-null map.",                    em != null);          assertTrue("failure in test: makeEmptyMap must return a new map " +                    "with each invocation.", em != em2);          final Map<K, V> fm = makeFullMap();         assertTrue("failure in test: makeFullMap must return a non-null map.",                    fm != null);          final Map<K, V> fm2 = makeFullMap();         assertTrue("failure in test: makeFullMap must return a non-null map.",                    fm != null);          assertTrue("failure in test: makeFullMap must return a new map " +                    "with each invocation.", fm != fm2);     }      /**      * Tests Map.isEmpty()      */     public void testMapIsEmpty() {         resetEmpty();         assertEquals("Map.isEmpty() should return true with an empty map",                      true, getMap().isEmpty());         verify();          resetFull();         assertEquals("Map.isEmpty() should return false with a non-empty map",                      false, getMap().isEmpty());         verify();     }      /**      * Tests Map.size()      */     public void testMapSize() {         resetEmpty();         assertEquals("Map.size() should be 0 with an empty map",                      0, getMap().size());         verify();          resetFull();         assertEquals("Map.size() should equal the number of entries " +                      "in the map", getSampleKeys().length, getMap().size());         verify();     }      /**      * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}      * can add and remove elements}, then {@link Map#size()} and      * {@link Map#isEmpty()} are used to ensure that map has no elements after      * a call to clear.  If the map does not support adding and removing      * elements, this method checks to ensure clear throws an      * UnsupportedOperationException.      */     public void testMapClear() {         if (!isRemoveSupported()) {             try {                 resetFull();                 getMap().clear();                 fail("Expected UnsupportedOperationException on clear");             } catch (final UnsupportedOperationException ex) {}             return;         }          resetEmpty();         getMap().clear();         getConfirmed().clear();         verify();          resetFull();         getMap().clear();         getConfirmed().clear();         verify();     }      /**      * Tests Map.containsKey(Object) by verifying it returns false for all      * sample keys on a map created using an empty map and returns true for      * all sample keys returned on a full map.      */     public void testMapContainsKey() {         final Object[] keys = getSampleKeys();          resetEmpty();         for (final Object key : keys) {             assertTrue("Map must not contain key when map is empty",                     !getMap().containsKey(key));         }         verify();          resetFull();         for (final Object key : keys) {             assertTrue("Map must contain key for a mapping in the map. " +                        "Missing: " + key, getMap().containsKey(key));         }         verify();     }      /**      * Tests Map.containsValue(Object) by verifying it returns false for all      * sample values on an empty map and returns true for all sample values on      * a full map.      */     public void testMapContainsValue() {         final Object[] values = getSampleValues();          resetEmpty();         for (final Object value : values) {             assertTrue("Empty map must not contain value",                        !getMap().containsValue(value));         }         verify();          resetFull();         for (final Object value : values) {             assertTrue("Map must contain value for a mapping in the map.",                     getMap().containsValue(value));         }         verify();     }       /**      * Tests Map.equals(Object)      */     public void testMapEquals() {         resetEmpty();         assertTrue("Empty maps unequal.", getMap().equals(confirmed));         verify();          resetFull();         assertTrue("Full maps unequal.", getMap().equals(confirmed));         verify();          resetFull();         // modify the HashMap created from the full map and make sure this         // change results in map.equals() to return false.         final Iterator<K> iter = confirmed.keySet().iterator();         iter.next();         iter.remove();         assertTrue("Different maps equal.", !getMap().equals(confirmed));          resetFull();         assertTrue("equals(null) returned true.", !getMap().equals(null));         assertTrue("equals(new Object()) returned true.",                    !getMap().equals(new Object()));         verify();     }      /**      * Tests Map.get(Object)      */     public void testMapGet() {         resetEmpty();          final Object[] keys = getSampleKeys();         final Object[] values = getSampleValues();          for (final Object key : keys) {             assertTrue("Empty map.get() should return null.",                     getMap().get(key) == null);         }         verify();          resetFull();         for (int i = 0; i < keys.length; i++) {             assertEquals("Full map.get() should return value from mapping.",                          values[i], getMap().get(keys[i]));         }     }      /**      * Tests Map.hashCode()      */     public void testMapHashCode() {         resetEmpty();         assertTrue("Empty maps have different hashCodes.",                 getMap().hashCode() == confirmed.hashCode());          resetFull();         assertTrue("Equal maps have different hashCodes.",                 getMap().hashCode() == confirmed.hashCode());     }      /**      * Tests Map.toString().  Since the format of the string returned by the      * toString() method is not defined in the Map interface, there is no      * common way to test the results of the toString() method.  Therefore,      * it is encouraged that Map implementations override this test with one      * that checks the format matches any format defined in its API.  This      * default implementation just verifies that the toString() method does      * not return null.      */     public void testMapToString() {         resetEmpty();         assertTrue("Empty map toString() should not return null",                 getMap().toString() != null);         verify();          resetFull();         assertTrue("Empty map toString() should not return null",                 getMap().toString() != null);         verify();     }      /**      * Compare the current serialized form of the Map      * against the canonical version in SCM.      */     public void testEmptyMapCompatibility() throws Exception {         /*          * Create canonical objects with this code         Map map = makeEmptyMap();         if (!(map instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));         */          // test to make sure the canonical form has been preserved         final Map<K, V> map = makeObject();         if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             @SuppressWarnings("unchecked")             final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));             assertEquals("Map is empty", 0, map2.size());         }     }      /**      * Compare the current serialized form of the Map      * against the canonical version in SCM.      */     public void testFullMapCompatibility() throws Exception {         /*          * Create canonical objects with this code         Map map = makeFullMap();         if (!(map instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));         */          // test to make sure the canonical form has been preserved         final Map<K, V> map = makeFullMap();         if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             @SuppressWarnings("unchecked")             final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));             assertEquals("Map is the right size", getSampleKeys().length, map2.size());         }     }      /**      * Tests Map.put(Object, Object)      */     public void testMapPut() {         resetEmpty();         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         final V[] newValues = getNewSampleValues();          if (isPutAddSupported()) {             for (int i = 0; i < keys.length; i++) {                 final Object o = getMap().put(keys[i], values[i]);                 getConfirmed().put(keys[i], values[i]);                 verify();                 assertTrue("First map.put should return null", o == null);                 assertTrue("Map should contain key after put",                         getMap().containsKey(keys[i]));                 assertTrue("Map should contain value after put",                         getMap().containsValue(values[i]));             }             if (isPutChangeSupported()) {                 for (int i = 0; i < keys.length; i++) {                     final Object o = getMap().put(keys[i], newValues[i]);                     getConfirmed().put(keys[i], newValues[i]);                     verify();                     assertEquals("Map.put should return previous value when changed", values[i], o);                     assertTrue("Map should still contain key after put when changed",                             getMap().containsKey(keys[i]));                     assertTrue("Map should contain new value after put when changed",                             getMap().containsValue(newValues[i]));                      // if duplicates are allowed, we're not guaranteed that the value                     // no longer exists, so don't try checking that.                     if (!isAllowDuplicateValues()) {                         assertTrue("Map should not contain old value after put when changed",                                 !getMap().containsValue(values[i]));                     }                 }             } else {                 try {                     // two possible exception here, either valid                     getMap().put(keys[0], newValues[0]);                     fail("Expected IllegalArgumentException or UnsupportedOperationException on put (change)");                 } catch (final IllegalArgumentException ex) {                 } catch (final UnsupportedOperationException ex) {}             }          } else if (isPutChangeSupported()) {             resetEmpty();             try {                 getMap().put(keys[0], values[0]);                 fail("Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size");             } catch (final IllegalArgumentException ex) {             } catch (final UnsupportedOperationException ex) {             }              resetFull();             int i = 0;             for (final Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {                 final K  key = it.next();                 final V o = getMap().put(key, newValues[i]);                 final V value = getConfirmed().put(key, newValues[i]);                 verify();                 assertEquals("Map.put should return previous value when changed", value, o);                 assertTrue("Map should still contain key after put when changed", getMap()                         .containsKey(key));                 assertTrue("Map should contain new value after put when changed", getMap()                         .containsValue(newValues[i]));                  // if duplicates are allowed, we're not guaranteed that the value                 // no longer exists, so don't try checking that.                 if (!isAllowDuplicateValues()) {                     assertTrue("Map should not contain old value after put when changed",                         !getMap().containsValue(values[i]));                 }             }         } else {             try {                 getMap().put(keys[0], values[0]);                 fail("Expected UnsupportedOperationException on put (add)");             } catch (final UnsupportedOperationException ex) {}         }     }      /**      * Tests Map.put(null, value)      */     public void testMapPutNullKey() {         resetFull();         final V[] values = getSampleValues();          if (isPutAddSupported()) {             if (isAllowNullKey()) {                 getMap().put(null, values[0]);             } else {                 try {                     getMap().put(null, values[0]);                     fail("put(null, value) should throw NPE/IAE");                 } catch (final NullPointerException ex) {                 } catch (final IllegalArgumentException ex) {}             }         }     }      /**      * Tests Map.put(null, value)      */     public void testMapPutNullValue() {         resetFull();         final K[] keys = getSampleKeys();          if (isPutAddSupported()) {             if (isAllowNullValue()) {                 getMap().put(keys[0], null);             } else {                 try {                     getMap().put(keys[0], null);                     fail("put(key, null) should throw NPE/IAE");                 } catch (final NullPointerException ex) {                 } catch (final IllegalArgumentException ex) {}             }         }     }      /**      * Tests Map.putAll(map)      */     public void testMapPutAll() {         if (!isPutAddSupported()) {             if (!isPutChangeSupported()) {                 final Map<K, V> temp = makeFullMap();                 resetEmpty();                 try {                     getMap().putAll(temp);                     fail("Expected UnsupportedOperationException on putAll");                 } catch (final UnsupportedOperationException ex) {}             }             return;         }          // check putAll OK adding empty map to empty map         resetEmpty();         assertEquals(0, getMap().size());         getMap().putAll(new HashMap<K, V>());         assertEquals(0, getMap().size());          // check putAll OK adding empty map to non-empty map         resetFull();         final int size = getMap().size();         getMap().putAll(new HashMap<K, V>());         assertEquals(size, getMap().size());          // check putAll OK adding non-empty map to empty map         resetEmpty();         Map<K, V> m2 = makeFullMap();         getMap().putAll(m2);         getConfirmed().putAll(m2);         verify();          // check putAll OK adding non-empty JDK map to empty map         resetEmpty();         m2 = makeConfirmedMap();         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         for (int i = 0; i < keys.length; i++) {             m2.put(keys[i], values[i]);         }         getMap().putAll(m2);         getConfirmed().putAll(m2);         verify();          // check putAll OK adding non-empty JDK map to non-empty map         resetEmpty();         m2 = makeConfirmedMap();         getMap().put(keys[0], values[0]);         getConfirmed().put(keys[0], values[0]);         verify();         for (int i = 1; i < keys.length; i++) {             m2.put(keys[i], values[i]);         }         getMap().putAll(m2);         getConfirmed().putAll(m2);         verify();     }      /**      * Tests Map.remove(Object)      */     public void testMapRemove() {         if (!isRemoveSupported()) {             try {                 resetFull();                 getMap().remove(getMap().keySet().iterator().next());                 fail("Expected UnsupportedOperationException on remove");             } catch (final UnsupportedOperationException ex) {}             return;         }          resetEmpty();          final Object[] keys = getSampleKeys();         final Object[] values = getSampleValues();         for (final Object key : keys) {             final Object o = getMap().remove(key);             assertTrue("First map.remove should return null", o == null);         }         verify();          resetFull();          for (int i = 0; i < keys.length; i++) {             final Object o = getMap().remove(keys[i]);             getConfirmed().remove(keys[i]);             verify();              assertEquals("map.remove with valid key should return value",                          values[i], o);         }          final Object[] other = getOtherKeys();          resetFull();         final int size = getMap().size();         for (final Object element : other) {             final Object o = getMap().remove(element);             assertNull("map.remove for nonexistent key should return null", o);             assertEquals("map.remove for nonexistent key should not " +                          "shrink map", size, getMap().size());         }         verify();     }      //-----------------------------------------------------------------------     /**      * Tests that the {@link Map#values} collection is backed by      * the underlying map for clear().      */     public void testValuesClearChangesMap() {         if (!isRemoveSupported()) {             return;         }          // clear values, reflected in map         resetFull();         Collection<V> values = getMap().values();         assertTrue(getMap().size() > 0);         assertTrue(values.size() > 0);         values.clear();         assertTrue(getMap().size() == 0);         assertTrue(values.size() == 0);          // clear map, reflected in values         resetFull();         values = getMap().values();         assertTrue(getMap().size() > 0);         assertTrue(values.size() > 0);         getMap().clear();         assertTrue(getMap().size() == 0);         assertTrue(values.size() == 0);     }      /**      * Tests that the {@link Map#keySet} collection is backed by      * the underlying map for clear().      */     public void testKeySetClearChangesMap() {         if (!isRemoveSupported()) {             return;         }          // clear values, reflected in map         resetFull();         Set<K> keySet = getMap().keySet();         assertTrue(getMap().size() > 0);         assertTrue(keySet.size() > 0);         keySet.clear();         assertTrue(getMap().size() == 0);         assertTrue(keySet.size() == 0);          // clear map, reflected in values         resetFull();         keySet = getMap().keySet();         assertTrue(getMap().size() > 0);         assertTrue(keySet.size() > 0);         getMap().clear();         assertTrue(getMap().size() == 0);         assertTrue(keySet.size() == 0);     }      /**      * Tests that the {@link Map#entrySet()} collection is backed by      * the underlying map for clear().      */     public void testEntrySetClearChangesMap() {         if (!isRemoveSupported()) {             return;         }          // clear values, reflected in map         resetFull();         Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         assertTrue(getMap().size() > 0);         assertTrue(entrySet.size() > 0);         entrySet.clear();         assertTrue(getMap().size() == 0);         assertTrue(entrySet.size() == 0);          // clear map, reflected in values         resetFull();         entrySet = getMap().entrySet();         assertTrue(getMap().size() > 0);         assertTrue(entrySet.size() > 0);         getMap().clear();         assertTrue(getMap().size() == 0);         assertTrue(entrySet.size() == 0);     }      //-----------------------------------------------------------------------     public void testEntrySetContains1() {         resetFull();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         assertEquals(true, entrySet.contains(entry));     }      public void testEntrySetContains2() {         resetFull();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final Map.Entry<K, V> test = cloneMapEntry(entry);         assertEquals(true, entrySet.contains(test));     }      @SuppressWarnings("unchecked")     public void testEntrySetContains3() {         resetFull();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final HashMap<K, V> temp = new HashMap<>();         temp.put(entry.getKey(), (V) "A VERY DIFFERENT VALUE");         final Map.Entry<K, V> test = temp.entrySet().iterator().next();         assertEquals(false, entrySet.contains(test));     }      public void testEntrySetRemove1() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final int size = getMap().size();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final K key = entry.getKey();          assertEquals(true, entrySet.remove(entry));         assertEquals(false, getMap().containsKey(key));         assertEquals(size - 1, getMap().size());     }      public void testEntrySetRemove2() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final int size = getMap().size();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final K key = entry.getKey();         final Map.Entry<K, V> test = cloneMapEntry(entry);          assertEquals(true, entrySet.remove(test));         assertEquals(false, getMap().containsKey(key));         assertEquals(size - 1, getMap().size());     }      @SuppressWarnings("unchecked")     public void testEntrySetRemove3() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final int size = getMap().size();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final K key = entry.getKey();         final HashMap<K, V> temp = new HashMap<>();         temp.put(entry.getKey(), (V) "A VERY DIFFERENT VALUE");         final Map.Entry<K, V> test = temp.entrySet().iterator().next();          assertEquals(false, entrySet.remove(test));         assertEquals(true, getMap().containsKey(key));         assertEquals(size, getMap().size());     }      //-----------------------------------------------------------------------     /**      * Tests that the {@link Map#values} collection is backed by      * the underlying map by removing from the values collection      * and testing if the value was removed from the map.      * <p>      * We should really test the "vice versa" case--that values removed      * from the map are removed from the values collection--also,      * but that's a more difficult test to construct (lacking a      * "removeValue" method.)      * </p>      * <p>      * See bug <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=9573">      * 9573</a>.      * </p>      */     public void testValuesRemoveChangesMap() {         resetFull();         final V[] sampleValues = getSampleValues();         final Collection<V> values = getMap().values();         for (final V sampleValue : sampleValues) {             if (map.containsValue(sampleValue)) {                 int j = 0;  // loop counter prevents infinite loops when remove is broken                 while (values.contains(sampleValue) && j < 10000) {                     try {                         values.remove(sampleValue);                     } catch (final UnsupportedOperationException e) {                         // if values.remove is unsupported, just skip this test                         return;                     }                     j++;                 }                 assertTrue("values().remove(obj) is broken", j < 10000);                 assertTrue(                     "Value should have been removed from the underlying map.",                     !getMap().containsValue(sampleValue));             }         }     }      /**      * Tests values.removeAll.      */     public void testValuesRemoveAll() {         resetFull();         final Collection<V> values = getMap().values();         final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());         if (!values.equals(sampleValuesAsList)) {             return;         }         try {             assertFalse(values.removeAll(Collections.<V>emptySet()));         } catch (final UnsupportedOperationException e) {             // if values.removeAll is unsupported, just skip this test             return;         }         assertEquals(sampleValuesAsList.size(), getMap().size());         try {             assertTrue(values.removeAll(sampleValuesAsList));         } catch (final UnsupportedOperationException e) {             // if values.removeAll is unsupported, just skip this test             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Test values.retainAll.      */     public void testValuesRetainAll() {         resetFull();         final Collection<V> values = getMap().values();         final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());         if (!values.equals(sampleValuesAsList)) {             return;         }         try {             assertFalse(values.retainAll(sampleValuesAsList));         } catch (final UnsupportedOperationException e) {             // if values.retainAll is unsupported, just skip this test             return;         }         assertEquals(sampleValuesAsList.size(), getMap().size());         try {             assertTrue(values.retainAll(Collections.<V>emptySet()));         } catch (final UnsupportedOperationException e) {             // if values.retainAll is unsupported, just skip this test             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Verifies that values.iterator.remove changes the underlying map.      */     @SuppressWarnings("boxing") // OK in test code     public void testValuesIteratorRemoveChangesMap() {         resetFull();         final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());         final Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);         final Collection<V> values = getMap().values();         for (final Iterator<V> iter = values.iterator(); iter.hasNext();) {             final V value = iter.next();             Integer count = cardinality.get(value);             if (count == null) {                 return;             }             try {                 iter.remove();                 cardinality.put(value, --count);             } catch (final UnsupportedOperationException e) {                 // if values.iterator.remove is unsupported, just skip this test                 return;             }             final boolean expected = count > 0;             final StringBuilder msg = new StringBuilder("Value should ");             msg.append(expected ? "yet " : "no longer ");             msg.append("be present in the underlying map");             assertEquals(msg.toString(), expected, getMap().containsValue(value));         }         assertTrue(getMap().isEmpty());     }      /**      * Tests that the {@link Map#keySet} set is backed by      * the underlying map by removing from the keySet set      * and testing if the key was removed from the map.      */     public void testKeySetRemoveChangesMap() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final Set<K> keys = getMap().keySet();         for (final K sampleKey : sampleKeys) {             try {                 keys.remove(sampleKey);             } catch (final UnsupportedOperationException e) {                 // if key.remove is unsupported, just skip this test                 return;             }             assertTrue(                 "Key should have been removed from the underlying map.",                 !getMap().containsKey(sampleKey));         }     }      /**      * Test keySet.removeAll.      */     public void testKeySetRemoveAll() {         resetFull();         final Set<K> keys = getMap().keySet();         final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());         if (!keys.equals(sampleKeysAsList)) {             return;         }         try {             assertFalse(keys.removeAll(Collections.<K>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeysAsList, keys);         try {             assertTrue(keys.removeAll(sampleKeysAsList));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Test keySet.retainAll.      */     public void testKeySetRetainAll() {         resetFull();         final Set<K> keys = getMap().keySet();         final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());         if (!keys.equals(sampleKeysAsList)) {             return;         }         try {             assertFalse(keys.retainAll(sampleKeysAsList));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeysAsList, keys);         try {             assertTrue(keys.retainAll(Collections.<K>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Verify that keySet.iterator.remove changes the underlying map.      */     public void testKeySetIteratorRemoveChangesMap() {         resetFull();         for (final Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {             final K key = iter.next();             try {                 iter.remove();             } catch (final UnsupportedOperationException e) {                 return;             }             assertFalse(getMap().containsKey(key));         }     }      /**      * Tests that the {@link Map#entrySet} set is backed by      * the underlying map by removing from the entrySet set      * and testing if the entry was removed from the map.      */     public void testEntrySetRemoveChangesMap() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final V[] sampleValues = getSampleValues();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         for (int i = 0; i < sampleKeys.length; i++) {             try {                 entrySet.remove(new DefaultMapEntry<>(sampleKeys[i], sampleValues[i]));             } catch (final UnsupportedOperationException e) {                 // if entrySet removal is unsupported, just skip this test                 return;             }             assertTrue(                     "Entry should have been removed from the underlying map.",                     !getMap().containsKey(sampleKeys[i]));         }     }      /**      * Test entrySet.removeAll.      */     public void testEntrySetRemoveAll() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final V[] sampleValues = getSampleValues();         //verify map looks as expected:         for (int i = 0; i < sampleKeys.length; i++) {             if (!getMap().containsKey(sampleKeys[i])) {                 return;             }             final V value = sampleValues[i];             final V test = getMap().get(sampleKeys[i]);             if (value == test || value != null && value.equals(test)) {                 continue;             }             return;         }         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<>(entrySet);         try {             assertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeys.length, getMap().size());         try {             assertTrue(entrySet.removeAll(comparisonSet));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Test entrySet.retainAll.      */     public void testEntrySetRetainAll() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final V[] sampleValues = getSampleValues();         //verify map looks as expected:         for (int i = 0; i < sampleKeys.length; i++) {             if (!getMap().containsKey(sampleKeys[i])) {                 return;             }             final V value = sampleValues[i];             final V test = getMap().get(sampleKeys[i]);             if (value == test || value != null && value.equals(test)) {                 continue;             }             return;         }         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<>(entrySet);         try {             assertFalse(entrySet.retainAll(comparisonSet));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeys.length, getMap().size());         try {             assertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Verify that entrySet.iterator.remove changes the underlying map.      */     public void testEntrySetIteratorRemoveChangesMap() {         resetFull();         for (final Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {             final K key = iter.next().getKey();             try {                 iter.remove();             } catch (final UnsupportedOperationException e) {                 return;             }             assertFalse(getMap().containsKey(key));         }     }      /**      * Utility methods to create an array of Map.Entry objects      * out of the given key and value arrays.<P>      *      * @param keys    the array of keys      * @param values  the array of values      * @return an array of Map.Entry of those keys to those values      */     @SuppressWarnings("unchecked")     private Map.Entry<K, V>[] makeEntryArray(final K[] keys, final V[] values) {         final Map.Entry<K, V>[] result = new Map.Entry[keys.length];         for (int i = 0; i < keys.length; i++) {             final Map<K, V> map = makeConfirmedMap();             map.put(keys[i], values[i]);             result[i] = map.entrySet().iterator().next();         }         return result;     }      /**      * Bulk test {@link Map#entrySet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the map and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the map's entry set      */     public BulkTest bulkTestMapEntrySet() {         return new TestMapEntrySet();     }      public class TestMapEntrySet extends AbstractSetTest<Map.Entry<K, V>> {         public TestMapEntrySet() {             super("MapEntrySet");         }          // Have to implement manually; entrySet doesn't support addAll         /**          * {@inheritDoc}          */         @Override         public Entry<K, V>[] getFullElements() {             return getFullNonNullElements();         }          /**          * {@inheritDoc}          */         @Override         public Map.Entry<K, V>[] getFullNonNullElements() {             final K[] k = getSampleKeys();             final V[] v = getSampleValues();             return makeEntryArray(k, v);         }          // Have to implement manually; entrySet doesn't support addAll         @Override         public Map.Entry<K, V>[] getOtherElements() {             final K[] k = getOtherKeys();             final V[] v = getOtherValues();             return makeEntryArray(k, v);         }          @Override         public Set<Map.Entry<K, V>> makeObject() {             return AbstractMapTest.this.makeObject().entrySet();         }          @Override         public Set<Map.Entry<K, V>> makeFullCollection() {             return makeFullMap().entrySet();         }          @Override         public boolean isAddSupported() {             // Collection views don't support add operations.             return false;         }          @Override         public boolean isRemoveSupported() {             // Entry set should only support remove if map does             return AbstractMapTest.this.isRemoveSupported();         }          public boolean isGetStructuralModify() {             return AbstractMapTest.this.isGetStructuralModify();         }          @Override         public boolean areEqualElementsDistinguishable() {             return AbstractMapTest.this.areEqualElementsDistinguishable();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMapTest.this.resetFull();             setCollection(AbstractMapTest.this.getMap().entrySet());             TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());         }          @Override         public void resetEmpty() {             AbstractMapTest.this.resetEmpty();             setCollection(AbstractMapTest.this.getMap().entrySet());             TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());         }          public void testMapEntrySetIteratorEntry() {             resetFull();             final Iterator<Map.Entry<K, V>> it = getCollection().iterator();             int count = 0;             while (it.hasNext()) {                 final Map.Entry<K, V> entry = it.next();                 assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry.getKey()));                 assertEquals(true, AbstractMapTest.this.getMap().containsValue(entry.getValue()));                 if (!isGetStructuralModify()) {                     assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());                 }                 count++;             }             assertEquals(getCollection().size(), count);         }          public void testMapEntrySetIteratorEntrySetValue() {             final K key1 = getSampleKeys()[0];             final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];             final V newValue1 = getNewSampleValues()[0];             final V newValue2 = getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1];              resetFull();             // explicitly get entries as sample values/keys are connected for some maps             // such as BeanMap             Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry1 = getEntry(it, key1);             it = TestMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry2 = getEntry(it, key2);             Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);             itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);             verify();              if (!isSetValueSupported()) {                 try {                     entry1.setValue(newValue1);                 } catch (final UnsupportedOperationException ex) {                 }                 return;             }              entry1.setValue(newValue1);             entryConfirmed1.setValue(newValue1);             assertEquals(newValue1, entry1.getValue());             assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));             assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));             assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));             verify();              entry1.setValue(newValue1);             entryConfirmed1.setValue(newValue1);             assertEquals(newValue1, entry1.getValue());             assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));             assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));             assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));             verify();              entry2.setValue(newValue2);             entryConfirmed2.setValue(newValue2);             assertEquals(newValue2, entry2.getValue());             assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry2.getKey()));             assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue2));             assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));             verify();         }          public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key) {             Map.Entry<K, V> entry = null;             while (itConfirmed.hasNext()) {                 final Map.Entry<K, V> temp = itConfirmed.next();                 if (temp.getKey() == null) {                     if (key == null) {                         entry = temp;                         break;                     }                 } else if (temp.getKey().equals(key)) {                     entry = temp;                     break;                 }             }             assertNotNull("No matching entry in map for key '" + key + "'", entry);             return entry;         }          public void testMapEntrySetRemoveNonMapEntry() {             if (!isRemoveSupported()) {                 return;             }             resetFull();             assertEquals(false, getCollection().remove(null));             assertEquals(false, getCollection().remove(new Object()));         }          @Override         public void verify() {             super.verify();             AbstractMapTest.this.verify();         }     }       /**      * Bulk test {@link Map#keySet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the map and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the map's key set      */     public BulkTest bulkTestMapKeySet() {         return new TestMapKeySet();     }      public class TestMapKeySet extends AbstractSetTest<K> {         public TestMapKeySet() {             super("");         }          @Override         public K[] getFullElements() {             return getSampleKeys();         }          @Override         public K[] getOtherElements() {             return getOtherKeys();         }          @Override         public Set<K> makeObject() {             return AbstractMapTest.this.makeObject().keySet();         }          @Override         public Set<K> makeFullCollection() {             return AbstractMapTest.this.makeFullMap().keySet();         }          @Override         public boolean isNullSupported() {             return AbstractMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetEmpty() {             AbstractMapTest.this.resetEmpty();             setCollection(AbstractMapTest.this.getMap().keySet());             TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());         }          @Override         public void resetFull() {             AbstractMapTest.this.resetFull();             setCollection(AbstractMapTest.this.getMap().keySet());             TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());         }          @Override         public void verify() {             super.verify();             AbstractMapTest.this.verify();         }     }      /**      * Bulk test {@link Map#values()}.  This method runs through all of      * the tests in {@link AbstractCollectionTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the map and the other collection views are still valid.      *      * @return a {@link AbstractCollectionTest} instance for testing the map's      *    values collection      */     public BulkTest bulkTestMapValues() {         return new TestMapValues();     }      public class TestMapValues extends AbstractCollectionTest<V> {         public TestMapValues() {             super("");         }          @Override         public V[] getFullElements() {             return getSampleValues();         }          @Override         public V[] getOtherElements() {             return getOtherValues();         }          @Override         public Collection<V> makeObject() {             return AbstractMapTest.this.makeObject().values();         }          @Override         public Collection<V> makeFullCollection() {             return AbstractMapTest.this.makeFullMap().values();         }          @Override         public boolean isNullSupported() {             return AbstractMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public boolean areEqualElementsDistinguishable() {             // equal values are associated with different keys, so they are             // distinguishable.             return true;         }          @Override         public Collection<V> makeConfirmedCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public Collection<V> makeConfirmedFullCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public void resetFull() {             AbstractMapTest.this.resetFull();             setCollection(map.values());             TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());         }          @Override         public void resetEmpty() {             AbstractMapTest.this.resetEmpty();             setCollection(map.values());             TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());         }          @Override         public void verify() {             super.verify();             AbstractMapTest.this.verify();         }          // TODO: should test that a remove on the values collection view         // removes the proper mapping and not just any mapping that may have         // the value equal to the value returned from the values iterator.     }       /**      * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},      * {@link #values} and {@link #confirmed} fields to empty.      */     public void resetEmpty() {         this.map = makeObject();         views();         this.confirmed = makeConfirmedMap();     }      /**      * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},      * {@link #values} and {@link #confirmed} fields to full.      */     public void resetFull() {         this.map = makeFullMap();         views();         this.confirmed = makeConfirmedMap();         final K[] k = getSampleKeys();         final V[] v = getSampleValues();         for (int i = 0; i < k.length; i++) {             confirmed.put(k[i], v[i]);         }     }      /**      * Resets the collection view fields.      */     private void views() {         this.keySet = getMap().keySet();         // see verifyValues: retrieve the values collection only when verifying them         // this.values = getMap().values();         this.entrySet = getMap().entrySet();     }      /**      * Verifies that {@link #map} is still equal to {@link #confirmed}.      * This method checks that the map is equal to the HashMap,      * <I>and</I> that the map's collection views are still equal to      * the HashMap's collection views.  An <Code>equals</Code> test      * is done on the maps and their collection views; their size and      * <Code>isEmpty</Code> results are compared; their hashCodes are      * compared; and <Code>containsAll</Code> tests are run on the      * collection views.      */     public void verify() {         verifyMap();         verifyEntrySet();         verifyKeySet();         verifyValues();     }      public void verifyMap() {         final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("Map should be same size as HashMap", size, getMap().size());         assertEquals("Map should be empty if HashMap is", empty, getMap().isEmpty());         assertEquals("hashCodes should be the same", getConfirmed().hashCode(), getMap().hashCode());         // changing the order of the assertion below fails for LRUMap because confirmed is         // another collection (e.g. treemap) and confirmed.equals() creates a normal iterator (not         // #mapIterator()), which modifies the parent expected modCount of the map object, causing         // concurrent modification exceptions.         // Because of this we have assertEquals(map, confirmed), and not the other way around.         assertEquals("Map should still equal HashMap", map, confirmed);         assertTrue("Map should still equal HashMap", getMap().equals(getConfirmed()));     }      public void verifyEntrySet() {         final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("entrySet should be same size as HashMap's" +                      "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                      size, entrySet.size());         assertEquals("entrySet should be empty if HashMap is" +                      "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                      empty, entrySet.isEmpty());         assertTrue("entrySet should contain all HashMap's elements" +                    "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                    entrySet.containsAll(getConfirmed().entrySet()));         assertEquals("entrySet hashCodes should be the same" +                      "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                      getConfirmed().entrySet().hashCode(), entrySet.hashCode());         assertEquals("Map's entry set should still equal HashMap's",                      getConfirmed().entrySet(), entrySet);     }      public void verifyKeySet() {         final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("keySet should be same size as HashMap's" +                      "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                      size, keySet.size());         assertEquals("keySet should be empty if HashMap is" +                      "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                      empty, keySet.isEmpty());         assertTrue("keySet should contain all HashMap's elements" +                    "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                    keySet.containsAll(getConfirmed().keySet()));         assertEquals("keySet hashCodes should be the same" +                      "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                      getConfirmed().keySet().hashCode(), keySet.hashCode());         assertEquals("Map's key set should still equal HashMap's",                 getConfirmed().keySet(), keySet);     }      public void verifyValues() {         final List<V> known = new ArrayList<>(getConfirmed().values());          values = getMap().values();          final List<V> test = new ArrayList<>(values);          final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("values should be same size as HashMap's" +                      "\nTest: " + test + "\nReal: " + known,                      size, values.size());         assertEquals("values should be empty if HashMap is" +                      "\nTest: " + test + "\nReal: " + known,                      empty, values.isEmpty());         assertTrue("values should contain all HashMap's elements" +                    "\nTest: " + test + "\nReal: " + known,                     test.containsAll(known));         assertTrue("values should contain all HashMap's elements" +                    "\nTest: " + test + "\nReal: " + known,                    known.containsAll(test));         // originally coded to use a HashBag, but now separate jar so...         for (final V v : known) {             final boolean removed = test.remove(v);             assertTrue("Map's values should still equal HashMap's", removed);         }         assertTrue("Map's values should still equal HashMap's", test.isEmpty());     }      /**      * Erases any leftover instance variables by setting them to null.      */     @Override     public void tearDown() throws Exception {         map = null;         keySet = null;         entrySet = null;         values = null;         confirmed = null;     }      /**      * Get the map.      * @return Map<K, V>      */     public Map<K, V> getMap() {         return map;     }      /**      * Get the confirmed.      * @return Map<K, V>      */     public Map<K, V> getConfirmed() {         return confirmed;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.SortedMap; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the {@link FixedSizeSortedMap}  * implementation.  *  * @since 3.0  */ public class FixedSizeSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      public FixedSizeSortedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(FixedSizeSortedMapTest.class);     }      //-----------------------------------------------------------------------     @Override     public SortedMap<K, V> makeObject() {         return FixedSizeSortedMap.fixedSizeSortedMap(new TreeMap<K, V>());     }      @Override     public SortedMap<K, V> makeFullMap() {         final SortedMap<K, V> map = new TreeMap<>();         addSampleMappings(map);         return FixedSizeSortedMap.fixedSizeSortedMap(map);     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeSortedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class HashedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public HashedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashedMapTest.class);     }      @Override     public HashedMap<K, V> makeObject() {         return new HashedMap<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      @SuppressWarnings("unchecked")     public void testClone() {         final HashedMap<K, V> map = new HashedMap<>(10);         map.put((K) "1", (V) "1");         final HashedMap<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }      public void testInternalState() {         final HashedMap<Integer, Integer> map = new HashedMap<>(42, 0.75f);         assertEquals(0.75f, map.loadFactor, 0.1f);         assertEquals(0, map.size);         assertEquals(64, map.data.length);         assertEquals(48, map.threshold);         assertEquals(0, map.modCount);          // contract: the capacity is ensured when too many elements are added         final HashedMap<Integer, Integer> tmpMap = new HashedMap<>();         // we need to put at least the "threshold" number of elements         // in order to double the capacity         for (int i = 1; i <= map.threshold; i++) {             tmpMap.put(i, i);         }         map.putAll(tmpMap);         // the threshold has changed due to calling ensureCapacity         assertEquals(96, map.threshold);     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/HashedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/HashedMap.fullCollection.version4.obj"); //    }      /**      * Test for <a href="https://issues.apache.org/jira/browse/COLLECTIONS-323">COLLECTIONS-323</a>.      */     public void testInitialCapacityZero() {         final HashedMap<String, String> map = new HashedMap<>(0);         assertEquals(1, map.data.length);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.Map;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;  /**  * Abstract test class for {@link IterableMap} methods and contracts.  *  */ public abstract class AbstractIterableMapTest<K, V> extends AbstractMapTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractIterableMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public abstract IterableMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public IterableMap<K, V> makeFullMap() {         return (IterableMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     public void testFailFastEntrySet() {         if (!isRemoveSupported()) {             return;         }         if (!isFailFastExpected()) {             return;         }         resetFull();         Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();         final Map.Entry<K, V> val = it.next();         getMap().remove(val.getKey());         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}          resetFull();         it = getMap().entrySet().iterator();         it.next();         getMap().clear();         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}     }      public void testFailFastKeySet() {         if (!isRemoveSupported()) {             return;         }         if (!isFailFastExpected()) {             return;         }         resetFull();         Iterator<K> it = getMap().keySet().iterator();         final K val = it.next();         getMap().remove(val);         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}          resetFull();         it = getMap().keySet().iterator();         it.next();         getMap().clear();         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}     }      public void testFailFastValues() {         if (!isRemoveSupported()) {             return;         }         if (!isFailFastExpected()) {             return;         }         resetFull();         Iterator<V> it = getMap().values().iterator();         it.next();         getMap().remove(getMap().keySet().iterator().next());         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}          resetFull();         it = getMap().values().iterator();         it.next();         getMap().clear();         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}     }      //-----------------------------------------------------------------------     public BulkTest bulkTestMapIterator() {         return new InnerTestMapIterator();     }      public class InnerTestMapIterator extends AbstractMapIteratorTest<K, V> {         public InnerTestMapIterator() {             super("InnerTestMapIterator");         }          @Override         public V[] addSetValues() {             return AbstractIterableMapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return AbstractIterableMapTest.this.isRemoveSupported();         }          @Override         public boolean isGetStructuralModify() {             return AbstractIterableMapTest.this.isGetStructuralModify();         }          @Override         public boolean supportsSetValue() {             return AbstractIterableMapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractIterableMapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return AbstractIterableMapTest.this.getMap().mapIterator();         }          @Override         public Map<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractIterableMapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractIterableMapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             AbstractIterableMapTest.this.verify();         }     }  //  public void testCreate() throws Exception { //      resetEmpty(); //      writeExternalFormToDisk((Serializable) map, "D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj"); //      resetFull(); //      writeExternalFormToDisk((Serializable) map, "D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj"); //  }      /**      * {@inheritDoc}      */     @Override     public IterableMap<K, V> getMap() {         return (IterableMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.function.Consumer;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.map.AbstractHashedMap.HashEntry; import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceEntry; import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;  import junit.framework.Test;  /**  * Tests for ReferenceMap.  *  */ public class ReferenceMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public ReferenceMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ReferenceMapTest.class);     }      @Override     public ReferenceMap<K, V> makeObject() {         return new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceMap.fullCollection.version4.obj"); //    }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testNullHandling() {         resetFull();         assertEquals(null, map.get(null));         assertEquals(false, map.containsKey(null));         assertEquals(false, map.containsValue(null));         assertEquals(null, map.remove(null));         assertEquals(false, map.entrySet().contains(null));         assertEquals(false, map.keySet().contains(null));         assertEquals(false, map.values().contains(null));         try {             map.put(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             map.put((K) new Object(), null);             fail();         } catch (final NullPointerException ex) {}         try {             map.put(null, (V) new Object());             fail();         } catch (final NullPointerException ex) {}     }      //----------------------------------------------------------------------- /*     // Tests often fail because gc is uncontrollable      public void testPurge() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < hard.length; i++) {             hard[i] = new Object();             map.put(hard[i], new Object());         }         gc();         assertTrue("map should be empty after purge of weak values", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);         }         gc();         assertTrue("map should be empty after purge of weak keys", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);             map.put(hard[i], new Object());         }          gc();         assertTrue("map should be empty after purge of weak keys and values", map.isEmpty());     }       public void testGetAfterGC() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         for (int i = 0; i < 10; i++) {             map.put(Integer.valueOf(i), Integer.valueOf(i));         }          gc();         for (int i = 0; i < 10; i++) {             Integer I = Integer.valueOf(i);             assertTrue("map.containsKey should return false for GC'd element", !map.containsKey(I));             assertTrue("map.get should return null for GC'd element", map.get(I) == null);         }     }       public void testEntrySetIteratorAfterGC() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         Iterator iterator = map.entrySet().iterator();         while (iterator.hasNext()) {             Map.Entry entry = (Map.Entry)iterator.next();             Integer key = (Integer)entry.getKey();             Integer value = (Integer)entry.getValue();             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC2() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             gc();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      } */      WeakReference<K> keyReference;     WeakReference<V> valueReference;      @SuppressWarnings("unchecked")     public Map<K, V> buildRefMap() {         final K key = (K) new Object();         final V value = (V) new Object();          keyReference = new WeakReference<>(key);         valueReference = new WeakReference<>(value);          final Map<K, V> testMap = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);         testMap.put(key, value);          assertEquals("In map", value, testMap.get(key));         assertNotNull("Weak reference released early (1)", keyReference.get());         assertNotNull("Weak reference released early (2)", valueReference.get());         return testMap;     }      /** Tests whether purge values setting works */     public void testPurgeValues() throws Exception {         // many thanks to Juozas Baliuka for suggesting this method         final Map<K, V> testMap = buildRefMap();          int iterations = 0;         int bytz = 2;         while (true) {             System.gc();             if (iterations++ > 50) {                 fail("Max iterations reached before resource released.");             }             testMap.isEmpty();             if (keyReference.get() == null && valueReference.get() == null) {                 break;              }             // create garbage:             @SuppressWarnings("unused")             final byte[] b = new byte[bytz];             bytz = bytz * 2;         }     }      public void testCustomPurge() {         final List<Integer> expiredValues = new ArrayList<>();         @SuppressWarnings("unchecked")         final Consumer<Integer> consumer = (Consumer<Integer> & Serializable) v -> expiredValues.add(v);         final Map<Integer, Integer> map = new ReferenceMap<Integer, Integer>(ReferenceStrength.WEAK, ReferenceStrength.HARD, false) {             private static final long serialVersionUID = 1L;              @Override             protected ReferenceEntry<Integer, Integer> createEntry(final HashEntry<Integer, Integer> next, final int hashCode, final Integer key, final Integer value) {                 return new AccessibleEntry<>(this, next, hashCode, key, value, consumer);             }         };         for (int i = 100000; i < 100010; i++) {             map.put(Integer.valueOf(i), Integer.valueOf(i));         }         int iterations = 0;         int bytz = 2;         while (true) {             System.gc();             if (iterations++ > 50 || bytz < 0) {                 fail("Max iterations reached before resource released.");             }             map.isEmpty();             if (!expiredValues.isEmpty()) {                 break;             }             // create garbage:             @SuppressWarnings("unused")             final byte[] b = new byte[bytz];             bytz = bytz * 2;         }         assertFalse("Value should be stored", expiredValues.isEmpty());     }      /**      * Test whether after serialization the "data" HashEntry array is the same size as the original.<p>      *      * See <a href="https://issues.apache.org/jira/browse/COLLECTIONS-599">COLLECTIONS-599: HashEntry array object naming data initialized with double the size during deserialization</a>      */     public void testDataSizeAfterSerialization() throws IOException, ClassNotFoundException {          final ReferenceMap<String, String> serializeMap = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK, true);         serializeMap.put("KEY", "VALUE");          final ByteArrayOutputStream baos = new ByteArrayOutputStream();         try (ObjectOutputStream out = new ObjectOutputStream(baos)) {             out.writeObject(serializeMap);         }          final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());         try (ObjectInputStream in = new ObjectInputStream(bais)) {             @SuppressWarnings("unchecked")             final ReferenceMap<String, String> deserializedMap = (ReferenceMap<String, String>) in.readObject();             assertEquals(1, deserializedMap.size());             assertEquals(serializeMap.data.length, deserializedMap.data.length);         }      }      @SuppressWarnings("unused")     private static void gc() {         try {             // trigger GC             final byte[][] tooLarge = new byte[1000000000][1000000000];             fail("you have too much RAM");         } catch (final OutOfMemoryError ex) {             System.gc(); // ignore         }     }      private static class AccessibleEntry<K, V> extends ReferenceEntry<K, V> {         final AbstractReferenceMap<K, V> parent;         final Consumer<V> consumer;          AccessibleEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value, final Consumer<V> consumer) {             super(parent, next, hashCode, key, value);             this.parent = parent;             this.consumer = consumer;         }          @Override         protected void onPurge() {             if (parent.isValueType(ReferenceStrength.HARD)) {                 consumer.accept(getValue());             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map; import java.util.Collection;  /**  * This class is used in TestCompositeMap. When testing serialization,  * the class has to be separate of TestCompositeMap, else the test  * class also has to be serialized.  */ class EmptyMapMutator<K, V> implements CompositeMap.MapMutator<K, V> {     /** Serialization version */     private static final long serialVersionUID = -2729718980002476794L;      @Override     public void resolveCollision(final CompositeMap<K, V> composite,         final Map<K, V> existing,         final Map<K, V> added,         final Collection<K> intersect) {         // Do nothing     }      @Override     public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, final V value) {         return composited[0].put(key, value);     }      @Override     public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {         composited[0].putAll(t);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.TreeMap;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.OrderedMapIterator; import org.apache.commons.collections4.comparators.NullComparator; import org.apache.commons.collections4.iterators.AbstractOrderedMapIteratorTest;  /**  * Abstract test class for {@link OrderedMap} methods and contracts.  *  */ public abstract class AbstractOrderedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractOrderedMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public abstract OrderedMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public OrderedMap<K, V> makeFullMap() {         return (OrderedMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     /**      * OrderedMap uses TreeMap as its known comparison.      *      * @return a map that is known to be valid      */     @Override     public Map<K, V> makeConfirmedMap() {         return new TreeMap<>(new NullComparator<K>());     }      /**      * The only confirmed collection we have that is ordered is the sorted one.      * Thus, sort the keys.      */     @Override     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         final List<K> list = new ArrayList<>(Arrays.asList(super.getSampleKeys()));         Collections.sort(list, new NullComparator<K>());         return (K[]) list.toArray();     }      //-----------------------------------------------------------------------     public void testFirstKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         try {             ordered.firstKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         ordered = getMap();         final K confirmedFirst = confirmed.keySet().iterator().next();         assertEquals(confirmedFirst, ordered.firstKey());     }      public void testLastKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         try {             ordered.lastKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         ordered = getMap();         K confirmedLast = null;         for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {             confirmedLast = it.next();         }         assertEquals(confirmedLast, ordered.lastKey());     }      //-----------------------------------------------------------------------     public void testNextKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         assertEquals(null, ordered.nextKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, ordered.nextKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, ordered.nextKey(null));         }          resetFull();         ordered = getMap();         final Iterator<K> it = confirmed.keySet().iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, ordered.nextKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, ordered.nextKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 ordered.nextKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, ordered.nextKey(null));         }     }      public void testPreviousKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         assertEquals(null, ordered.previousKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, ordered.previousKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, ordered.previousKey(null));         }          resetFull();         ordered = getMap();         final List<K> list = new ArrayList<>(confirmed.keySet());         Collections.reverse(list);         final Iterator<K> it = list.iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, ordered.previousKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, ordered.previousKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 ordered.previousKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             if (!isAllowNullKey()) {                 assertEquals(null, ordered.previousKey(null));             }         }     }      //-----------------------------------------------------------------------     public BulkTest bulkTestOrderedMapIterator() {         return new InnerTestOrderedMapIterator();     }      public class InnerTestOrderedMapIterator extends AbstractOrderedMapIteratorTest<K, V> {         public InnerTestOrderedMapIterator() {             super("InnerTestOrderedMapIterator");         }          @Override         public boolean supportsRemove() {             return AbstractOrderedMapTest.this.isRemoveSupported();         }          @Override         public boolean isGetStructuralModify() {             return AbstractOrderedMapTest.this.isGetStructuralModify();         }          @Override         public boolean supportsSetValue() {             return AbstractOrderedMapTest.this.isSetValueSupported();         }          @Override         public OrderedMapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractOrderedMapTest.this.getMap().mapIterator();         }          @Override         public OrderedMapIterator<K, V> makeObject() {             resetFull();             return AbstractOrderedMapTest.this.getMap().mapIterator();         }          @Override         public OrderedMap<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedMapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedMapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             AbstractOrderedMapTest.this.verify();         }     }      /**      * {@inheritDoc}      */     @Override     public OrderedMap<K, V> getMap() {         return (OrderedMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import static org.apache.commons.collections4.map.LazySortedMap.*;  import java.util.Comparator; import java.util.Map; import java.util.SortedMap; import java.util.TreeMap; import java.util.concurrent.ConcurrentSkipListMap;  import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.FactoryUtils; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.junit.Test;  /**  * Extension of {@link LazyMapTest} for exercising the  * {@link LazySortedMap} implementation.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class LazySortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      private class ReverseStringComparator implements Comparator<String> {         @Override         public int compare(final String arg0, final String arg1) {             return arg1.compareTo(arg0);         }     }      private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);      protected final Comparator<String> reverseStringComparator = new ReverseStringComparator();      public LazySortedMapTest(final String testName) {         super(testName);     }      @Override     public SortedMap<K, V> makeObject() {         return lazySortedMap(new TreeMap<K, V>(), FactoryUtils.<V>nullFactory());     }      @Override     public boolean isAllowNullKey() {         return false;     }      // from LazyMapTest     //-----------------------------------------------------------------------     @Override     public void testMapGet() {         //TODO eliminate need for this via superclass - see svn history.     }      @Test     public void mapGet() {         Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), oneFactory);         assertEquals(0, map.size());         final Number i1 = map.get(5);         assertEquals(1, i1);         assertEquals(1, map.size());          map = lazySortedMap(new TreeMap<Integer, Number>(), FactoryUtils.<Number>nullFactory());         final Number o = map.get(5);         assertEquals(null, o);         assertEquals(1, map.size());      }      //-----------------------------------------------------------------------     public void testSortOrder() {         final SortedMap<String, Number> map = lazySortedMap(new TreeMap<String, Number>(), oneFactory);         map.put("A",  5);         map.get("B"); // Entry with value "One" created         map.put("C", 8);         assertEquals("First key should be A", "A", map.firstKey());         assertEquals("Last key should be C", "C", map.lastKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap("B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap("C").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap("A", "C").lastKey());          final Comparator<?> c = map.comparator();         assertTrue("natural order, so comparator should be null",             c == null);     }      public void testReverseSortOrder() {         final SortedMap<String, Number> map = lazySortedMap(new ConcurrentSkipListMap<String, Number>(reverseStringComparator), oneFactory);         map.put("A",  5);         map.get("B"); // Entry with value "One" created         map.put("C", 8);         assertEquals("Last key should be A", "A", map.lastKey());         assertEquals("First key should be C", "C", map.firstKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap("B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap("A").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap("C", "A").lastKey());          final Comparator<?> c = map.comparator();         assertTrue("natural order, so comparator should be null",             c == reverseStringComparator);     }      public void testTransformerDecorate() {         final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);         SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);         assertTrue(map instanceof LazySortedMap);         try {             map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);             fail("Expecting NullPointerException for null transformer");         } catch (final NullPointerException e) {             // expected         }         try {             map = lazySortedMap((SortedMap<Integer, Number>) null, transformer);             fail("Expecting NullPointerException for null map");         } catch (final NullPointerException e) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazySortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazySortedMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Unit tests.  * {@link StaticBucketMap}.  *  */ public class StaticBucketMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public StaticBucketMapTest(final String name) {         super(name);     }      public static Test suite() {         return BulkTest.makeSuite(StaticBucketMapTest.class);     }      @Override     public StaticBucketMap<K, V> makeObject() {         return new StaticBucketMap<>(30);     }      /**      * {@inheritDoc}      */     @Override     public boolean isFailFastExpected() {         return false;     }      @Override     public String[] ignoredTests() {         final String pre = "StaticBucketMapTest.bulkTestMap";         final String post = ".testCollectionIteratorFailFast";         return new String[] {             pre + "EntrySet" + post,             pre + "KeySet" + post,             pre + "Values" + post         };     }      // Bugzilla 37567     @SuppressWarnings("unchecked")     public void test_get_nullMatchesIncorrectly() {         final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);         map.put(null, (V) "A");         assertEquals("A", map.get(null));         // loop so we find a string that is in the same bucket as the null         for (int i = 'A'; i <= 'Z'; i++) {             final String str = String.valueOf((char) i);             assertEquals("String: " + str, null, map.get(str));         }     }      @SuppressWarnings("unchecked")     public void test_containsKey_nullMatchesIncorrectly() {         final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);         map.put(null, (V) "A");         assertEquals(true, map.containsKey(null));         // loop so we find a string that is in the same bucket as the null         for (int i = 'A'; i <= 'Z'; i++) {             final String str = String.valueOf((char) i);             assertEquals("String: " + str, false, map.containsKey(str));         }     }      @SuppressWarnings("unchecked")     public void test_containsValue_nullMatchesIncorrectly() {         final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);         map.put((K) "A", null);         assertEquals(true, map.containsValue(null));         // loop so we find a string that is in the same bucket as the null         for (int i = 'A'; i <= 'Z'; i++) {             final String str = String.valueOf((char) i);             assertEquals("String: " + str, false, map.containsValue(str));         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.IterableMap;  /**  * Extension of {@link AbstractMapTest} for exercising the {@link FixedSizeMap}  * implementation.  *  * @since 3.0  */ public class FixedSizeMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public FixedSizeMapTest(final String testName) {         super(testName);     }      @Override     public IterableMap<K, V> makeObject() {         return FixedSizeMap.fixedSizeMap(new HashMap<K, V>());     }      @Override     public IterableMap<K, V> makeFullMap() {         final Map<K, V> map = new HashMap<>();         addSampleMappings(map);         return FixedSizeMap.fixedSizeMap(map);     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy;  /**  * JUnit tests.  *  * @since 4.0  */ public class PassiveExpiringMapTest<K, V> extends AbstractMapTest<K, V> {      private static class TestExpirationPolicy         implements ExpirationPolicy<Integer, String> {          private static final long serialVersionUID = 1L;          @Override         public long expirationTime(final Integer key, final String value) {             // odd keys expire immediately, even keys never expire             if (key == null) {                 return 0;             }              if (key.intValue() % 2 == 0) {                 return -1;             }              return 0;         }     }      public static Test suite() {         return BulkTest.makeSuite(PassiveExpiringMapTest.class);     }      public PassiveExpiringMapTest(final String testName) {         super(testName);     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/PassiveExpiringMap.emptyCollection.version4.obj"); // //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/PassiveExpiringMap.fullCollection.version4.obj"); //    }      @Override     public String getCompatibilityVersion() {         return "4";     }      private Map<Integer, String> makeDecoratedTestMap() {         final Map<Integer, String> m = new HashMap<>();         m.put(Integer.valueOf(1), "one");         m.put(Integer.valueOf(2), "two");         m.put(Integer.valueOf(3), "three");         m.put(Integer.valueOf(4), "four");         m.put(Integer.valueOf(5), "five");         m.put(Integer.valueOf(6), "six");         return new PassiveExpiringMap<>(new TestExpirationPolicy(), m);     }      @Override     public Map<K, V> makeObject() {         return new PassiveExpiringMap<>();     }      private Map<Integer, String> makeTestMap() {         final Map<Integer, String> m =                 new PassiveExpiringMap<>(new TestExpirationPolicy());         m.put(Integer.valueOf(1), "one");         m.put(Integer.valueOf(2), "two");         m.put(Integer.valueOf(3), "three");         m.put(Integer.valueOf(4), "four");         m.put(Integer.valueOf(5), "five");         m.put(Integer.valueOf(6), "six");         return m;     }      public void testConstructors() {         try {             final Map<String, String> map = null;             new PassiveExpiringMap<>(map);             fail("constructor - exception should have been thrown.");         } catch (final NullPointerException ex) {             // success         }          try {             final ExpirationPolicy<String, String> policy = null;             new PassiveExpiringMap<>(policy);             fail("constructor - exception should have been thrown.");         } catch (final NullPointerException ex) {             // success         }          try {             final TimeUnit unit = null;             new PassiveExpiringMap<String, String>(10L, unit);             fail("constructor - exception should have been thrown.");         } catch (final NullPointerException ex) {             // success         }     }      public void testContainsKey() {         final Map<Integer, String> m = makeTestMap();         assertFalse(m.containsKey(Integer.valueOf(1)));         assertFalse(m.containsKey(Integer.valueOf(3)));         assertFalse(m.containsKey(Integer.valueOf(5)));         assertTrue(m.containsKey(Integer.valueOf(2)));         assertTrue(m.containsKey(Integer.valueOf(4)));         assertTrue(m.containsKey(Integer.valueOf(6)));     }      public void testContainsValue() {         final Map<Integer, String> m = makeTestMap();         assertFalse(m.containsValue("one"));         assertFalse(m.containsValue("three"));         assertFalse(m.containsValue("five"));         assertTrue(m.containsValue("two"));         assertTrue(m.containsValue("four"));         assertTrue(m.containsValue("six"));     }      public void testDecoratedMap() {         // entries shouldn't expire         final Map<Integer, String> m = makeDecoratedTestMap();         assertEquals(6, m.size());         assertEquals("one", m.get(Integer.valueOf(1)));          // removing a single item shouldn't affect any other items         assertEquals("two", m.get(Integer.valueOf(2)));         m.remove(Integer.valueOf(2));         assertEquals(5, m.size());         assertEquals("one", m.get(Integer.valueOf(1)));         assertNull(m.get(Integer.valueOf(2)));          // adding a single, even item shouldn't affect any other items         assertNull(m.get(Integer.valueOf(2)));         m.put(Integer.valueOf(2), "two");         assertEquals(6, m.size());         assertEquals("one", m.get(Integer.valueOf(1)));         assertEquals("two", m.get(Integer.valueOf(2)));          // adding a single, odd item (one that expires) shouldn't affect any         // other items         // put the entry expires immediately         m.put(Integer.valueOf(1), "one-one");         assertEquals(5, m.size());         assertNull(m.get(Integer.valueOf(1)));         assertEquals("two", m.get(Integer.valueOf(2)));     }      public void testEntrySet() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.entrySet().size());     }      public void testExpiration() {         validateExpiration(new PassiveExpiringMap<String, String>(500), 500);         validateExpiration(new PassiveExpiringMap<String, String>(1000), 1000);         validateExpiration(new PassiveExpiringMap<>(                 new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<String, String>(500)), 500);         validateExpiration(new PassiveExpiringMap<>(                 new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<String, String>(1, TimeUnit.SECONDS)), 1000);     }      public void testGet() {         final Map<Integer, String> m = makeTestMap();         assertNull(m.get(Integer.valueOf(1)));         assertEquals("two", m.get(Integer.valueOf(2)));         assertNull(m.get(Integer.valueOf(3)));         assertEquals("four", m.get(Integer.valueOf(4)));         assertNull(m.get(Integer.valueOf(5)));         assertEquals("six", m.get(Integer.valueOf(6)));     }      public void testIsEmpty() {         Map<Integer, String> m = makeTestMap();         assertFalse(m.isEmpty());          // remove just evens         m = makeTestMap();         m.remove(Integer.valueOf(2));         m.remove(Integer.valueOf(4));         m.remove(Integer.valueOf(6));         assertTrue(m.isEmpty());     }      public void testKeySet() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.keySet().size());     }      public void testPut() {         final Map<Integer, String> m = makeTestMap();         assertNull(m.put(Integer.valueOf(1), "ONE"));         assertEquals("two", m.put(Integer.valueOf(2), "TWO"));         assertNull(m.put(Integer.valueOf(3), "THREE"));         assertEquals("four", m.put(Integer.valueOf(4), "FOUR"));         assertNull(m.put(Integer.valueOf(5), "FIVE"));         assertEquals("six", m.put(Integer.valueOf(6), "SIX"));     }      public void testSize() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.size());     }      public void testValues() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.values().size());     }      public void testZeroTimeToLive() {         // item should not be available         final PassiveExpiringMap<String, String> m = new PassiveExpiringMap<>(0L);         m.put("a", "b");         assertNull(m.get("a"));     }      private void validateExpiration(final Map<String, String> map, final long timeout) {         map.put("a", "b");          assertNotNull(map.get("a"));          try {             Thread.sleep(2 * timeout);         } catch (final InterruptedException e) {             fail();         }          assertNull(map.get("a"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap;  import junit.framework.Test; import org.apache.commons.collections4.BoundedMap; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.KeyValue; import org.apache.commons.collections4.OrderedMap;  /**  * JUnit tests.  *  */ public class SingletonMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      private static final Integer ONE = Integer.valueOf(1);     private static final Integer TWO = Integer.valueOf(2);     private static final String TEN = "10";      public SingletonMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(SingletonMapTest.class);     }      //-----------------------------------------------------------------------     @Override     public OrderedMap<K, V> makeObject() {         // need an empty singleton map, but thats not possible         // use a ridiculous fake instead to make the tests pass         return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));     }      @Override     public String[] ignoredTests() {         // the ridiculous map above still doesn't pass these tests         // but its not relevant, so we ignore them         return new String[] {             "SingletonMapTest.bulkTestMapIterator.testEmptyMapIterator",             "SingletonMapTest.bulkTestOrderedMapIterator.testEmptyMapIterator",         };     }      @Override     @SuppressWarnings("unchecked")     public SingletonMap<K, V> makeFullMap() {         return new SingletonMap<>((K) ONE, (V) TWO);     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         return (K[]) new Object[] { ONE };     }      @Override     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         return (V[]) new Object[] { TWO };     }      @Override     @SuppressWarnings("unchecked")     public V[] getNewSampleValues() {         return (V[]) new Object[] { TEN };     }      //-----------------------------------------------------------------------     public void testClone() {         final SingletonMap<K, V> map = makeFullMap();         assertEquals(1, map.size());         final SingletonMap<K, V> cloned = map.clone();         assertEquals(1, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsValue(TWO));     }      public void testKeyValue() {         final SingletonMap<K, V> map = makeFullMap();         assertEquals(1, map.size());         assertEquals(ONE, map.getKey());         assertEquals(TWO, map.getValue());         assertTrue(map instanceof KeyValue);     }      public void testBoundedMap() {         final SingletonMap<K, V> map = makeFullMap();         assertEquals(1, map.size());         assertEquals(true, map.isFull());         assertEquals(1, map.maxSize());         assertTrue(map instanceof BoundedMap);     }      //----------------------------------------------------------------------- //    public BulkTest bulkTestMapIterator() { //        return new TestFlatMapIterator(); //    } // //    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator { //        public TestFlatMapIterator() { //            super("TestFlatMapIterator"); //        } // //        public Object[] addSetValues() { //            return TestSingletonMap.this.getNewSampleValues(); //        } // //        public boolean supportsRemove() { //            return TestSingletonMap.this.isRemoveSupported(); //        } // //        public boolean supportsSetValue() { //            return TestSingletonMap.this.isSetValueSupported(); //        } // //        public MapIterator makeEmptyMapIterator() { //            resetEmpty(); //            return ((Flat3Map) TestSingletonMap.this.map).mapIterator(); //        } // //        public MapIterator makeFullMapIterator() { //            resetFull(); //            return ((Flat3Map) TestSingletonMap.this.map).mapIterator(); //        } // //        public Map getMap() { //            // assumes makeFullMapIterator() called first //            return TestSingletonMap.this.map; //        } // //        public Map getConfirmedMap() { //            // assumes makeFullMapIterator() called first //            return TestSingletonMap.this.confirmed; //        } // //        public void verify() { //            super.verify(); //            TestSingletonMap.this.verify(); //        } //    }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/SingletonMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/SingletonMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.lang.ref.WeakReference; import java.util.Iterator; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;  /**  * Tests for ReferenceIdentityMap.  *  */ public class ReferenceIdentityMapTest<K, V> extends AbstractIterableMapTest<K, V> {      private static final Integer I1A = new Integer(1); // Cannot use valueOf here     private static final Integer I1B = new Integer(1);     private static final Integer I2A = new Integer(2);     private static final Integer I2B = new Integer(2);      @SuppressWarnings("unused")     private static void gc() {         try {             // trigger GC             final byte[][] tooLarge = new byte[1000000000][1000000000];             fail("you have too much RAM");         } catch (final OutOfMemoryError ex) {             System.gc(); // ignore         }     }      public static Test suite() {         return BulkTest.makeSuite(ReferenceIdentityMapTest.class);     }      WeakReference<K> keyReference;      WeakReference<V> valueReference;      public ReferenceIdentityMapTest(final String testName) {         super(testName);     }      @SuppressWarnings("unchecked")     private Map<K, V> buildRefMap() {         final K key = (K) new Object();         final V value = (V) new Object();          keyReference = new WeakReference<>(key);         valueReference = new WeakReference<>(value);          final Map<K, V> testMap = new ReferenceIdentityMap<>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);         testMap.put(key, value);          assertEquals("In map", value, testMap.get(key));         assertNotNull("Weak reference released early (1)", keyReference.get());         assertNotNull("Weak reference released early (2)", valueReference.get());         return testMap;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceIdentityMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceIdentityMap.fullCollection.version4.obj"); //    }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public Map<K, V> makeConfirmedMap() {         // Testing against another [collections] class generally isn't a good idea,         // but the closest alternative is IdentityHashMap, which propagates reference-equality down to keySet and values.         // arguably ReferenceIdentityMap should do the same but that's a later discussion.         return new IdentityMap<>();     }  /*     // Tests often fail because gc is uncontrollable      public void testPurge() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < hard.length; i++) {             hard[i] = new Object();             map.put(hard[i], new Object());         }         gc();         assertTrue("map should be empty after purge of weak values", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);         }         gc();         assertTrue("map should be empty after purge of weak keys", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);             map.put(hard[i], new Object());         }          gc();         assertTrue("map should be empty after purge of weak keys and values", map.isEmpty());     }       public void testGetAfterGC() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         for (int i = 0; i < 10; i++) {             map.put(Integer.valueOf(i), Integer.valueOf(i));         }          gc();         for (int i = 0; i < 10; i++) {             Integer I = Integer.valueOf(i);             assertTrue("map.containsKey should return false for GC'd element", !map.containsKey(I));             assertTrue("map.get should return null for GC'd element", map.get(I) == null);         }     }       public void testEntrySetIteratorAfterGC() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         Iterator iterator = map.entrySet().iterator();         while (iterator.hasNext()) {             Map.Entry entry = (Map.Entry)iterator.next();             Integer key = (Integer)entry.getKey();             Integer value = (Integer)entry.getValue();             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC2() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             gc();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      } */      @Override     public ReferenceIdentityMap<K, V> makeObject() {         return new ReferenceIdentityMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);     }      @SuppressWarnings("unchecked")     public void testBasics() {         final IterableMap<K, V> map = new ReferenceIdentityMap<>(ReferenceStrength.HARD, ReferenceStrength.HARD);         assertEquals(0, map.size());          map.put((K) I1A, (V) I2A);         assertEquals(1, map.size());         assertSame(I2A, map.get(I1A));         assertSame(null, map.get(I1B));         assertEquals(true, map.containsKey(I1A));         assertEquals(false, map.containsKey(I1B));         assertEquals(true, map.containsValue(I2A));         assertEquals(false, map.containsValue(I2B));          map.put((K) I1A, (V) I2B);         assertEquals(1, map.size());         assertSame(I2B, map.get(I1A));         assertSame(null, map.get(I1B));         assertEquals(true, map.containsKey(I1A));         assertEquals(false, map.containsKey(I1B));         assertEquals(false, map.containsValue(I2A));         assertEquals(true, map.containsValue(I2B));          map.put((K) I1B, (V) I2B);         assertEquals(2, map.size());         assertSame(I2B, map.get(I1A));         assertSame(I2B, map.get(I1B));         assertEquals(true, map.containsKey(I1A));         assertEquals(true, map.containsKey(I1B));         assertEquals(false, map.containsValue(I2A));         assertEquals(true, map.containsValue(I2B));     }      @SuppressWarnings("unchecked")     public void testHashEntry() {         final IterableMap<K, V> map = new ReferenceIdentityMap<>(ReferenceStrength.HARD, ReferenceStrength.HARD);          map.put((K) I1A, (V) I2A);         map.put((K) I1B, (V) I2A);          final Map.Entry<K, V> entry1 = map.entrySet().iterator().next();         final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         final Map.Entry<K, V> entry2 = it.next();         final Map.Entry<K, V> entry3 = it.next();          assertEquals(true, entry1.equals(entry2));         assertEquals(true, entry2.equals(entry1));         assertEquals(false, entry1.equals(entry3));     }      @SuppressWarnings("unchecked")     public void testNullHandling() {         resetFull();         assertEquals(null, getMap().get(null));         assertEquals(false, getMap().containsKey(null));         assertEquals(false, getMap().containsValue(null));         assertEquals(null, getMap().remove(null));         assertEquals(false, getMap().entrySet().contains(null));         assertEquals(false, getMap().keySet().contains(null));         assertEquals(false, getMap().values().contains(null));         try {             getMap().put(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             getMap().put((K) new Object(), null);             fail();         } catch (final NullPointerException ex) {}         try {             getMap().put(null, (V) new Object());             fail();         } catch (final NullPointerException ex) {}     }      /** Tests whether purge values setting works */     public void testPurgeValues() throws Exception {         // many thanks to Juozas Baliuka for suggesting this method         final Map<K, V> testMap = buildRefMap();          int iterations = 0;         int bytz = 2;         while (true) {             System.gc();             if (iterations++ > 50) {                 fail("Max iterations reached before resource released.");             }             testMap.isEmpty();             if (                 keyReference.get() == null &&                 valueReference.get() == null) {                 break;              }             // create garbage:             @SuppressWarnings("unused")             final byte[] b =  new byte[bytz];             bytz = bytz * 2;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.HashMap; import java.util.Iterator; import java.util.Map;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;  import junit.framework.Test;  /**  * JUnit tests.  *  */ public class Flat3MapTest<K, V> extends AbstractIterableMapTest<K, V> {      private static final Integer ONE = Integer.valueOf(1);     private static final Integer TWO = Integer.valueOf(2);     private static final Integer THREE = Integer.valueOf(3);     private static final String TEN = "10";     private static final String TWENTY = "20";     private static final String THIRTY = "30";      public Flat3MapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(Flat3MapTest.class);     }      @Override     public Flat3Map<K, V> makeObject() {         return new Flat3Map<>();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEquals1() {         final Flat3Map<K, V> map1 = makeObject();         map1.put((K) "a", (V) "testA");         map1.put((K) "b", (V) "testB");         final Flat3Map<K, V> map2 = makeObject();         map2.put((K) "a", (V) "testB");         map2.put((K) "b", (V) "testA");         assertEquals(false, map1.equals(map2));     }      @SuppressWarnings("unchecked")     public void testEquals2() {         final Flat3Map<K, V> map1 = makeObject();         map1.put((K) "a", (V) "testA");         map1.put((K) "b", (V) "testB");         final Flat3Map<K, V> map2 = makeObject();         map2.put((K) "a", (V) "testB");         map2.put((K) "c", (V) "testA");         assertEquals(false, map1.equals(map2));     }      @SuppressWarnings("unchecked")     public void testClone2() {         final Flat3Map<K, V> map = makeObject();         assertEquals(0, map.size());         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         assertEquals(2, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertSame(TEN, map.get(ONE));         assertSame(TWENTY, map.get(TWO));          // clone works (size = 2)         final Flat3Map<K, V> cloned = map.clone();         assertEquals(2, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));          // change original doesn't change clone         map.put((K) TEN, (V) ONE);         map.put((K) TWENTY, (V) TWO);         assertEquals(4, map.size());         assertEquals(2, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));     }      @SuppressWarnings("unchecked")     public void testClone4() {         final Flat3Map<K, V> map = makeObject();         assertEquals(0, map.size());         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) TEN, (V) ONE);         map.put((K) TWENTY, (V) TWO);          // clone works (size = 4)         final Flat3Map<K, V> cloned = map.clone();         assertEquals(4, map.size());         assertEquals(4, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertEquals(true, cloned.containsKey(TEN));         assertEquals(true, cloned.containsKey(TWENTY));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));         assertSame(ONE, cloned.get(TEN));         assertSame(TWO, cloned.get(TWENTY));          // change original doesn't change clone         map.clear();         assertEquals(0, map.size());         assertEquals(4, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertEquals(true, cloned.containsKey(TEN));         assertEquals(true, cloned.containsKey(TWENTY));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));         assertSame(ONE, cloned.get(TEN));         assertSame(TWO, cloned.get(TWENTY));     }      public void testSerialisation0() throws Exception {         final Flat3Map<K, V> map = makeObject();         final ByteArrayOutputStream bout = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(bout);         out.writeObject(map);         final byte[] bytes = bout.toByteArray();         out.close();         final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);         final ObjectInputStream in = new ObjectInputStream(bin);         final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();         in.close();         assertEquals(0, map.size());         assertEquals(0, ser.size());     }      @SuppressWarnings("unchecked")     public void testSerialisation2() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);          final ByteArrayOutputStream bout = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(bout);         out.writeObject(map);         final byte[] bytes = bout.toByteArray();         out.close();         final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);         final ObjectInputStream in = new ObjectInputStream(bin);         final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();         in.close();         assertEquals(2, map.size());         assertEquals(2, ser.size());         assertEquals(true, ser.containsKey(ONE));         assertEquals(true, ser.containsKey(TWO));         assertEquals(TEN, ser.get(ONE));         assertEquals(TWENTY, ser.get(TWO));     }      @SuppressWarnings("unchecked")     public void testSerialisation4() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) TEN, (V) ONE);         map.put((K) TWENTY, (V) TWO);          final ByteArrayOutputStream bout = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(bout);         out.writeObject(map);         final byte[] bytes = bout.toByteArray();         out.close();         final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);         final ObjectInputStream in = new ObjectInputStream(bin);         final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();         in.close();         assertEquals(4, map.size());         assertEquals(4, ser.size());         assertEquals(true, ser.containsKey(ONE));         assertEquals(true, ser.containsKey(TWO));         assertEquals(true, ser.containsKey(TEN));         assertEquals(true, ser.containsKey(TWENTY));         assertEquals(TEN, ser.get(ONE));         assertEquals(TWENTY, ser.get(TWO));         assertEquals(ONE, ser.get(TEN));         assertEquals(TWO, ser.get(TWENTY));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEntryIteratorSetValue1() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         final Map.Entry<K, V> entry = it.next();         entry.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals("NewValue", map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testEntryIteratorSetValue2() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         it.next();         final Map.Entry<K, V> entry = it.next();         entry.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals("NewValue", map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testEntryIteratorSetValue3() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         it.next();         it.next();         final Map.Entry<K, V> entry = it.next();         entry.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals("NewValue", map.get(THREE));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMapIteratorSetValue1() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final MapIterator<K, V> it = map.mapIterator();         it.next();         it.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals("NewValue", map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testMapIteratorSetValue2() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final MapIterator<K, V> it = map.mapIterator();         it.next();         it.next();         it.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals("NewValue", map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testMapIteratorSetValue3() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final MapIterator<K, V> it = map.mapIterator();         it.next();         it.next();         it.next();         it.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals("NewValue", map.get(THREE));     }      public void testEntrySet() {         // Sanity check         putAndRemove(new HashMap<>());         // Actual test         putAndRemove(new Flat3Map<>());     }      private void putAndRemove(final Map<K, V> map) {         map.put((K) "A", (V) "one");         map.put((K) "B", (V) "two");         map.put((K) "C", (V) "three");         final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();          final Map.Entry<K, V> mapEntry1 = it.next();         final Map.Entry<K, V> mapEntry2 = it.next();         final Map.Entry<K, V> mapEntry3 = it.next();         it.remove();         assertEquals(2, map.size());         assertEquals("one", map.get("A"));         assertEquals("two", map.get("B"));         assertEquals(null, map.get("C"));     }      //-----------------------------------------------------------------------     @Override     public BulkTest bulkTestMapIterator() {         return new TestFlatMapIterator();     }      public class TestFlatMapIterator extends AbstractMapIteratorTest<K, V> {         public TestFlatMapIterator() {             super("TestFlatMapIterator");         }          @Override         public V[] addSetValues() {             return Flat3MapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return Flat3MapTest.this.isRemoveSupported();         }          @Override         public boolean supportsSetValue() {             return Flat3MapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return Flat3MapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return Flat3MapTest.this.getMap().mapIterator();         }          @Override         public IterableMap<K, V> getMap() {             // assumes makeFullMapIterator() called first             return Flat3MapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return Flat3MapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             Flat3MapTest.this.verify();         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/Flat3Map.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/Flat3Map.fullCollection.version4.obj"); //    }      public void testCollections261() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         m.put( Integer.valueOf(1), Integer.valueOf(1) );         m.put( Integer.valueOf(0), Integer.valueOf(0) );         assertEquals( Integer.valueOf(1), m.remove( Integer.valueOf(1) ) );         assertEquals( Integer.valueOf(0), m.remove( Integer.valueOf(0) ) );          m.put( Integer.valueOf(2), Integer.valueOf(2) );         m.put( Integer.valueOf(1), Integer.valueOf(1) );         m.put( Integer.valueOf(0), Integer.valueOf(0) );         assertEquals( Integer.valueOf(2), m.remove( Integer.valueOf(2) ) );         assertEquals( Integer.valueOf(1), m.remove( Integer.valueOf(1) ) );         assertEquals( Integer.valueOf(0), m.remove( Integer.valueOf(0) ) );     }      public void testToString() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         final String string0 = m.toString();         assertNotNull(string0);         m.put( Integer.valueOf(1), Integer.valueOf(1) );         final String string1 = m.toString();         assertNotNull(string1);         assertNotSame(string0, string1);         m.put( Integer.valueOf(0), Integer.valueOf(0) );         final String string2 = m.toString();         assertNotNull(string2);         assertNotSame(string0, string2);         assertNotSame(string1, string2);         m.put( Integer.valueOf(2), Integer.valueOf(2) );         final String string3 = m.toString();         assertNotNull(string3);         assertNotSame(string0, string3);         assertNotSame(string1, string3);         assertNotSame(string2, string3);     }      public void testRemove1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          // object is not existing         Object obj = m.remove(44);         assertNull(obj);          m.put(ONE, ONE);         obj = m.remove(ONE);         assertSame(ONE, obj);         assertEquals(0, m.size());          // after removal, be no longer there         obj = m.get(ONE);         assertNull(obj);          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(ONE);         assertSame(ONE, obj);          obj = m.get(ONE);         assertNull(obj);         obj = m.get(TWO);         assertSame(TWO, obj);     }      public void testRemove2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(ONE);         assertSame(ONE, obj);          obj = m.get(ONE);         assertNull(obj);         obj = m.get(TWO);         assertSame(TWO, obj);         obj = m.get(THREE);         assertSame(THREE, obj);     }      public void testRemove3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(TWO);         assertSame(TWO, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(TWO);         assertNull(obj);         obj = m.get(THREE);         assertSame(THREE, obj);     }      public void testRemove4() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(THREE);         assertSame(THREE, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(TWO);         assertSame(TWO, obj);         obj = m.get(THREE);         assertNull(obj);     }      public void testRemove5() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(null, ONE);          obj = m.remove(null);         assertSame(ONE, obj);          obj = m.get(null);         assertNull(obj);     }      public void testRemove6() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(null, TWO);          obj = m.remove(null);         assertSame(TWO, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(null);         assertNull(obj);     }      public void testRemove7() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(null, ONE);         m.put(TWO, TWO);          obj = m.remove(null);         assertSame(ONE, obj);          obj = m.get(null);         assertNull(obj);         obj = m.get(TWO);         assertSame(TWO, obj);     }      public void testRemove8() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);          obj = m.remove(null);         assertSame(THREE, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(TWO);         assertSame(TWO, obj);         obj = m.get(null);         assertNull(obj);     }      public void testRemove9() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);          obj = m.remove(null);         assertNull(obj);     }      public void testRemove10() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);          obj = m.remove(null);         assertNull(obj);     }      public void testRemove11() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(null);         assertNull(obj);     }      public void testRemove12() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(42);         assertNull(obj);     }      public void testRemove13() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);          obj = m.remove(42);         assertNull(obj);     }      public void testNewInstance1() {         final Map<Integer, Integer> orig = new HashMap<>();         orig.put(ONE, ONE);         orig.put(TWO, TWO);          final Flat3Map<Integer, Integer> m = new Flat3Map<>(orig);          assertEquals(orig, m);         assertEquals(2, m.size());     }      public void testGet1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(null, ONE);         obj = m.get(null);         assertSame(ONE, obj);     }      public void testGet2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(null, TWO);         obj = m.get(null);         assertSame(TWO, obj);     }      public void testGet3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);         obj = m.get(null);         assertSame(THREE, obj);     }      public void testContainsKey1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);         final boolean contains = m.containsKey(null);         assertEquals(true, contains);     }      public void testContainsKey2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(null, TWO);         final boolean contains = m.containsKey(null);         assertEquals(true, contains);     }      public void testContainsKey3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(null, ONE);         final boolean contains = m.containsKey(null);         assertEquals(true, contains);     }      public void testContainsValue1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, null);         final boolean contains = m.containsValue(null);         assertEquals(true, contains);     }      public void testContainsValue2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, null);         final boolean contains = m.containsValue(null);         assertEquals(true, contains);     }      public void testContainsValue3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, null);         final boolean contains = m.containsValue(null);         assertEquals(true, contains);     }      public void testPut1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);         final Object old = m.put(null, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(null));     }      public void testPut2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(null, THREE);         final Object old = m.put(null, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(null));     }      public void testPut3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(null, THREE);         final Object old = m.put(null, ONE);         assertEquals(THREE, old);         assertEquals(null, m.get(ONE));     }      public void testPut4() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);         final Object old = m.put(THREE, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(THREE));     }      public void testPut5() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, THREE);         final Object old = m.put(TWO, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(TWO));     }      public void testPut6() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, THREE);         final Object old = m.put(ONE, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(ONE));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.SortedMap; import java.util.TreeMap;  import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the  * {@link UnmodifiableSortedMap} implementation.  *  * @since 3.0  */ public class UnmodifiableSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      public UnmodifiableSortedMapTest(final String testName) {         super(testName);     }      //-------------------------------------------------------------------      @Override     public SortedMap<K, V> makeObject() {         return UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<K, V>());     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public SortedMap<K, V> makeFullMap() {         final SortedMap<K, V> m = new TreeMap<>();         addSampleMappings(m);         return UnmodifiableSortedMap.unmodifiableSortedMap(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final SortedMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));          try {             UnmodifiableSortedMap.unmodifiableSortedMap(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      public void testHeadMap() {         final SortedMap<K, V> map = makeFullMap();         final SortedMap<K, V> m = new TreeMap<>();         // "again" is the first key of the map         assertSame(m.isEmpty(), map.headMap((K) "again").isEmpty());         assertSame(18, map.size());         // "you" is the last key of the map         assertSame(17, map.headMap((K) "you").size());         // "we'll" is the before key of "you"         assertSame(16, map.headMap((K) "we'll").size());     }      //-----------------------------------------------------------------------      public void testTailMap() {         final SortedMap<K, V> map = makeFullMap();          assertSame(18, map.size());         // "you" is the last key of the map         assertSame(1, map.tailMap((K) "you").size());         // "we'll" is the before key of "you"         assertSame(2, map.tailMap((K) "we'll").size());         // "again" is the first key of the map         assertSame(18, map.tailMap((K) "again").size());     }      //-----------------------------------------------------------------------      public void testSubMap() {         final SortedMap<K, V> map = makeFullMap();          assertSame(18, map.size());         // get the sub map from again to you(exclusive)         assertSame(17, map.subMap((K) "again", (K) "you").size());         // get the sub map from again to we'll(exclusive)         assertSame(16, map.subMap((K) "again", (K) "we'll").size());         // "again" is the first key of the map         assertSame(0, map.subMap((K) "again", (K) "again").size());          assertSame(map.headMap((K) "you").size(), map.subMap((K) "again", (K) "you").size());     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableSortedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedList; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.list.AbstractListTest;  /**  * Tests base {@link java.util.LinkedList} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject()} method.  * <p>  * If your {@link LinkedList} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link List} fails.  *  */ public abstract class AbstractLinkedListTest<T> extends AbstractListTest<T> {      public AbstractLinkedListTest(final String testName) {         super(testName);     }      @Override     public abstract LinkedList<T> makeObject();      /**      *  Returns the {@link #collection} field cast to a {@link LinkedList}.      *      *  @return the collection field as a List      */     @Override     public LinkedList<T> getCollection() {         return (LinkedList<T>) super.getCollection();     }      /**      *  Returns the {@link #confirmed} field cast to a {@link LinkedList}.      *      *  @return the confirmed field as a List      */     protected LinkedList<T> getConfirmedLinkedList() {         return (LinkedList<T>) getConfirmed();     }      /**      *  Tests {@link LinkedList#addFirst(Object)}.      */     @SuppressWarnings("unchecked")     public void testLinkedListAddFirst() {         if (!isAddSupported()) {             return;         }         final T o = (T) "hello";          resetEmpty();         getCollection().addFirst(o);         getConfirmedLinkedList().addFirst(o);         verify();          resetFull();         getCollection().addFirst(o);         getConfirmedLinkedList().addFirst(o);         verify();     }      /**      *  Tests {@link LinkedList#addLast(Object)}.      */     @SuppressWarnings("unchecked")     public void testLinkedListAddLast() {         if (!isAddSupported()) {             return;         }         final T o = (T) "hello";          resetEmpty();         getCollection().addLast(o);         getConfirmedLinkedList().addLast(o);         verify();          resetFull();         getCollection().addLast(o);         getConfirmedLinkedList().addLast(o);         verify();     }      /**      *  Tests {@link LinkedList#getFirst()}.      */     public void testLinkedListGetFirst() {         resetEmpty();         try {             getCollection().getFirst();             fail("getFirst() should throw a NoSuchElementException for an " +                     "empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object first = getCollection().getFirst();         final Object confirmedFirst = getConfirmedLinkedList().getFirst();         assertEquals("Result returned by getFirst() was wrong.",                 confirmedFirst, first);         verify();     }      /**      *  Tests {@link LinkedList#getLast()}.      */     public void testLinkedListGetLast() {         resetEmpty();         try {             getCollection().getLast();             fail("getLast() should throw a NoSuchElementException for an " +                     "empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object last = getCollection().getLast();         final Object confirmedLast = getConfirmedLinkedList().getLast();         assertEquals("Result returned by getLast() was wrong.",                 confirmedLast, last);         verify();     }      /**      *  Tests {@link LinkedList#removeFirst()}.      */     public void testLinkedListRemoveFirst() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().removeFirst();             fail("removeFirst() should throw a NoSuchElementException for " +                     "an empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object first = getCollection().removeFirst();         final Object confirmedFirst = getConfirmedLinkedList().removeFirst();         assertEquals("Result returned by removeFirst() was wrong.",                 confirmedFirst, first);         verify();     }      /**      *  Tests {@link LinkedList#removeLast()}.      */     public void testLinkedListRemoveLast() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().removeLast();             fail("removeLast() should throw a NoSuchElementException for " +                     "an empty list.");         } catch (final NoSuchElementException e) {             // This is correct         }         verify();          resetFull();         final Object last = getCollection().removeLast();         final Object confirmedLast = getConfirmedLinkedList().removeLast();         assertEquals("Result returned by removeLast() was wrong.",                 confirmedLast, last);         verify();     }      /**      *  Returns an empty {@link LinkedList}.      */     @Override     public Collection<T> makeConfirmedCollection() {         return new LinkedList<>();     }      /**      *  Returns a full {@link LinkedList}.      */     @Override     public Collection<T> makeConfirmedFullCollection() {         return new LinkedList<>(Arrays.asList(getFullElements()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.EmptyStackException;  import junit.framework.Test;  /**  * Tests ArrayStack.  *  */ @SuppressWarnings("deprecation") // we test a deprecated class public class ArrayStackTest<E> extends AbstractArrayListTest<E> {      public ArrayStackTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ArrayStackTest.class);     }      @Override     public ArrayStack<E> makeObject() {         return new ArrayStack<>();     }      //-----------------------------------------------------------------------     public void testNewStack() {         final ArrayStack<E> stack = makeObject();         assertTrue("New stack is empty", stack.empty());         assertEquals("New stack has size zero", 0, stack.size());          try {             stack.peek();             fail("peek() should have thrown EmptyStackException");         } catch (final EmptyStackException e) {             // Expected result         }          try {             stack.pop();             fail("pop() should have thrown EmptyStackException");         } catch (final EmptyStackException e) {             // Expected result         }      }      @SuppressWarnings("unchecked")     public void testPushPeekPop() {         final ArrayStack<E> stack = makeObject();          stack.push((E) "First Item");         assertTrue("Stack is not empty", !stack.empty());         assertEquals("Stack size is one", 1, stack.size());         assertEquals("Top item is 'First Item'",                      "First Item", (String) stack.peek());         assertEquals("Stack size is one", 1, stack.size());          stack.push((E) "Second Item");         assertEquals("Stack size is two", 2, stack.size());         assertEquals("Top item is 'Second Item'",                      "Second Item", (String) stack.peek());         assertEquals("Stack size is two", 2, stack.size());          assertEquals("Popped item is 'Second Item'",                      "Second Item", (String) stack.pop());         assertEquals("Top item is 'First Item'",                      "First Item", (String) stack.peek());         assertEquals("Stack size is one", 1, stack.size());          assertEquals("Popped item is 'First Item'",                      "First Item", (String) stack.pop());         assertEquals("Stack size is zero", 0, stack.size());      }      @Override     @SuppressWarnings("unchecked")     public void testSearch() {         final ArrayStack<E> stack = makeObject();          stack.push((E) "First Item");         stack.push((E) "Second Item");         assertEquals("Top item is 'Second Item'",                      1, stack.search("Second Item"));         assertEquals("Next Item is 'First Item'",                      2, stack.search("First Item"));         assertEquals("Cannot find 'Missing Item'",                      -1, stack.search("Missing Item"));      }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ArrayStack.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ArrayStack.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.TreeMap;  import org.apache.commons.collections4.map.AbstractMapTest;  /**  * Tests TreeMap.  *  */ public abstract class AbstractTreeMapTest<K, V> extends AbstractMapTest<K, V> {      public AbstractTreeMapTest(final String testName) {         super(testName);     }      @Override     public boolean isAllowNullKey() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract TreeMap<K, V> makeObject();      public void testNewMap() {         final TreeMap<K, V> map = makeObject();         assertTrue("New map is empty", map.isEmpty());         assertEquals("New map has size zero", 0, map.size());     }      @SuppressWarnings("unchecked")     public void testSearch() {         final TreeMap<K, V> map = makeObject();         map.put((K) "first", (V) "First Item");         map.put((K) "second", (V) "Second Item");         assertEquals("Top item is 'Second Item'",             "First Item", map.get("first"));         assertEquals("Next Item is 'First Item'",             "Second Item", map.get("second"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import org.junit.Test;  import java.util.HashMap; import java.util.Map;  import static org.junit.Assert.*;  /**  * Test the DefaultKeyValue class.  *  * @since 3.0  */ public class DefaultKeyValueTest<K, V> {      private final String key = "name";     private final String value = "duke";      //-----------------------------------------------------------------------     /**      * Make an instance of DefaultKeyValue with the default (null) key and value.      * Subclasses should override this method to return a DefaultKeyValue      * of the type being tested.      */     protected DefaultKeyValue<K, V> makeDefaultKeyValue() {         return new DefaultKeyValue<>(null, null);     }      /**      * Make an instance of DefaultKeyValue with the specified key and value.      * Subclasses should override this method to return a DefaultKeyValue      * of the type being tested.      */     protected DefaultKeyValue<K, V> makeDefaultKeyValue(final K key, final V value) {         return new DefaultKeyValue<>(key, value);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     @Test     public void testAccessorsAndMutators() {         final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();          kv.setKey((K) key);         assertTrue(kv.getKey() == key);          kv.setValue((V) value);         assertTrue(kv.getValue() == value);          // check that null doesn't do anything funny         kv.setKey(null);         assertTrue(kv.getKey() == null);          kv.setValue(null);         assertTrue(kv.getValue() == null);      }      @SuppressWarnings("unchecked")     @Test     public void testSelfReferenceHandling() {         // test that #setKey and #setValue do not permit         //  the KVP to contain itself (and thus cause infinite recursion         //  in #hashCode and #toString)          final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();          try {             kv.setKey((K) kv);             fail("Should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected to happen...              // check that the KVP's state has not changed             assertTrue(kv.getKey() == null && kv.getValue() == null);         }          try {             kv.setValue((V) kv);             fail("Should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected to happen...              // check that the KVP's state has not changed             assertTrue(kv.getKey() == null && kv.getValue() == null);         }     }      /**      * Subclasses should override this method to test their own constructors.      */     @SuppressWarnings("unchecked")     @Test     public void testConstructors() {         // 1. test default constructor         DefaultKeyValue<K, V> kv = new DefaultKeyValue<>();         assertTrue(kv.getKey() == null && kv.getValue() == null);          // 2. test key-value constructor         kv = new DefaultKeyValue<>((K) key, (V) value);         assertTrue(kv.getKey() == key && kv.getValue() == value);          // 3. test copy constructor         final DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<>(kv);         assertTrue(kv2.getKey() == key && kv2.getValue() == value);          // test that the KVPs are independent         kv.setKey(null);         kv.setValue(null);          assertTrue(kv2.getKey() == key && kv2.getValue() == value);          // 4. test Map.Entry constructor         final Map<K, V> map = new HashMap<>();         map.put((K) key, (V) value);         final Map.Entry<K, V> entry = map.entrySet().iterator().next();          kv = new DefaultKeyValue<>(entry);         assertTrue(kv.getKey() == key && kv.getValue() == value);          // test that the KVP is independent of the Map.Entry         entry.setValue(null);         assertTrue(kv.getValue() == value);      }      @SuppressWarnings("unchecked")     @Test     public void testEqualsAndHashCode() {         // 1. test with object data         DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);         DefaultKeyValue<K, V> kv2 = makeDefaultKeyValue((K) key, (V) value);          assertTrue(kv.equals(kv));         assertTrue(kv.equals(kv2));         assertTrue(kv.hashCode() == kv2.hashCode());          // 2. test with nulls         kv = makeDefaultKeyValue(null, null);         kv2 = makeDefaultKeyValue(null, null);          assertTrue(kv.equals(kv));         assertTrue(kv.equals(kv2));         assertTrue(kv.hashCode() == kv2.hashCode());     }      @SuppressWarnings("unchecked")     @Test     public void testToString() {         DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);         assertTrue(kv.toString().equals(kv.getKey() + "=" + kv.getValue()));          // test with nulls         kv = makeDefaultKeyValue(null, null);         assertTrue(kv.toString().equals(kv.getKey() + "=" + kv.getValue()));     }      @SuppressWarnings("unchecked")     @Test     public void testToMapEntry() {         final DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);          final Map<K, V> map = new HashMap<>();         map.put(kv.getKey(), kv.getValue());         final Map.Entry<K, V> entry = map.entrySet().iterator().next();          assertTrue(entry.equals(kv.toMapEntry()));         assertTrue(entry.hashCode() == kv.hashCode());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import java.util.HashMap; import java.util.Map;  import org.junit.Test; import static org.junit.Assert.*;  /**  * Abstract tests that can be extended to test any Map.Entry implementation.  * Subclasses must implement {@link #makeMapEntry(Object, Object)} to return  * a new Map.Entry of the type being tested. Subclasses must also implement  * {@link #testConstructors()} to test the constructors of the Map.Entry  * type being tested.  *  * @since 3.0  */ public abstract class AbstractMapEntryTest<K, V> {      protected final String key = "name";     protected final String value = "duke";      //-----------------------------------------------------------------------     /**      * Make an instance of Map.Entry with the default (null) key and value.      * This implementation simply calls {@link #makeMapEntry(Object, Object)}      * with null for key and value. Subclasses can override this method if desired.      */     public Map.Entry<K, V> makeMapEntry() {         return makeMapEntry(null, null);     }      /**      * Make an instance of Map.Entry with the specified key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     public abstract Map.Entry<K, V> makeMapEntry(K key, V value);      /**      * Makes a Map.Entry of a type that's known to work correctly.      */     public Map.Entry<K, V> makeKnownMapEntry() {         return makeKnownMapEntry(null, null);     }      /**      * Makes a Map.Entry of a type that's known to work correctly.      */     public Map.Entry<K, V> makeKnownMapEntry(final K key, final V value) {         final Map<K, V> map = new HashMap<>(1);         map.put(key, value);         final Map.Entry<K, V> entry = map.entrySet().iterator().next();         return entry;     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     @Test     public void testAccessorsAndMutators() {         Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);          assertTrue(entry.getKey() == key);          entry.setValue((V) value);         assertTrue(entry.getValue() == value);          // check that null doesn't do anything funny         entry = makeMapEntry(null, null);         assertTrue(entry.getKey() == null);          entry.setValue(null);         assertTrue(entry.getValue() == null);     }      /**      * Subclasses should override this method to test the      * desired behavior of the class with respect to      * handling of self-references.      *      */      @SuppressWarnings("unchecked")     @Test     public void testSelfReferenceHandling() {         // test that #setValue does not permit         //  the MapEntry to contain itself (and thus cause infinite recursion         //  in #hashCode and #toString)          final Map.Entry<K, V> entry = makeMapEntry();          try {             entry.setValue((V) entry);             fail("Should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected to happen...              // check that the KVP's state has not changed             assertTrue(entry.getKey() == null && entry.getValue() == null);         }     }      /**      * Subclasses should provide tests for their constructors.      *      */     public abstract void testConstructors();      @SuppressWarnings("unchecked")     @Test     public void testEqualsAndHashCode() {         // 1. test with object data         Map.Entry<K, V> e1 = makeMapEntry((K) key, (V) value);         Map.Entry<K, V> e2 = makeKnownMapEntry((K) key, (V) value);          assertTrue(e1.equals(e1));         assertTrue(e2.equals(e1));         assertTrue(e1.equals(e2));         assertTrue(e1.hashCode() == e2.hashCode());          // 2. test with nulls         e1 = makeMapEntry();         e2 = makeKnownMapEntry();          assertTrue(e1.equals(e1));         assertTrue(e2.equals(e1));         assertTrue(e1.equals(e2));         assertTrue(e1.hashCode() == e2.hashCode());     }      @SuppressWarnings("unchecked")     @Test     public void testToString() {         Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);         assertTrue(entry.toString().equals(entry.getKey() + "=" + entry.getValue()));          // test with nulls         entry = makeMapEntry();         assertTrue(entry.toString().equals(entry.getKey() + "=" + entry.getValue()));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import org.junit.Test;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Arrays; import java.util.HashMap; import java.util.Map;  import static org.junit.Assert.*;  /**  * Unit tests for {@link org.apache.commons.collections4.keyvalue.MultiKey}.  *  */ public class MultiKeyTest {      static class DerivedMultiKey<T> extends MultiKey<T> {          private static final long serialVersionUID = 1928896152249821416L;          DerivedMultiKey(final T key1, final T key2) {             super(key1, key2);         }          public T getFirst() {             return getKey(0);         }          public T getSecond() {             return getKey(1);         }      }      static class SystemHashCodeSimulatingKey implements Serializable {          private static final long serialVersionUID = -1736147315703444603L;         private final String name;         private int hashCode = 1;          SystemHashCodeSimulatingKey(final String name) {             this.name = name;         }          @Override         public boolean equals(final Object obj) {             return obj instanceof SystemHashCodeSimulatingKey                 && name.equals(((SystemHashCodeSimulatingKey) obj).name);         }          @Override         public int hashCode() {             return hashCode;         }          private Object readResolve() {             hashCode=2; // simulate different hashCode after deserialization in another process             return this;         }     }     Integer ONE = Integer.valueOf(1);      Integer TWO = Integer.valueOf(2);     Integer THREE = Integer.valueOf(3);     Integer FOUR = Integer.valueOf(4);     Integer FIVE = Integer.valueOf(5);     //-----------------------------------------------------------------------     @Test     public void testConstructors() throws Exception {         MultiKey<Integer> mk;         mk = new MultiKey<>(ONE, TWO);         assertTrue(Arrays.equals(new Object[] { ONE, TWO }, mk.getKeys()));          mk = new MultiKey<>(ONE, TWO, THREE);         assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE }, mk.getKeys()));          mk = new MultiKey<>(ONE, TWO, THREE, FOUR);         assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR }, mk.getKeys()));          mk = new MultiKey<>(ONE, TWO, THREE, FOUR, FIVE);         assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR, FIVE }, mk.getKeys()));          mk = new MultiKey<>(new Integer[] { THREE, FOUR, ONE, TWO }, false);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));     }      @Test     public void testConstructorsByArray() throws Exception {         MultiKey<Integer> mk;         Integer[] keys = new Integer[] { THREE, FOUR, ONE, TWO };         mk = new MultiKey<>(keys);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));         keys[3] = FIVE;  // no effect         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));          keys = new Integer[] {};         mk = new MultiKey<>(keys);         assertTrue(Arrays.equals(new Object[] {}, mk.getKeys()));          keys = new Integer[] { THREE, FOUR, ONE, TWO };         mk = new MultiKey<>(keys, true);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));         keys[3] = FIVE;  // no effect         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));          keys = new Integer[] { THREE, FOUR, ONE, TWO };         mk = new MultiKey<>(keys, false);         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));         // change key - don't do this!         // the hashcode of the MultiKey is now broken         keys[3] = FIVE;         assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, FIVE }, mk.getKeys()));     }      @Test     public void testConstructorsByArrayNull() throws Exception {         final Integer[] keys = null;         try {             new MultiKey<>(keys);             fail();         } catch (final NullPointerException ex) {}         try {             new MultiKey<>(keys, true);             fail();         } catch (final NullPointerException ex) {}         try {             new MultiKey<>(keys, false);             fail();         } catch (final NullPointerException ex) {}     }      @Test     public void testEquals() {         final MultiKey<Integer> mk1 = new MultiKey<>(ONE, TWO);         final MultiKey<Integer> mk2 = new MultiKey<>(ONE, TWO);         final MultiKey<Object> mk3 = new MultiKey<>(ONE, "TWO");          assertEquals(mk1, mk1);         assertEquals(mk1, mk2);         assertFalse(mk1.equals(mk3));         assertFalse(mk1.equals(""));         assertFalse(mk1.equals(null));     }      @Test     public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException {         SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey("test");         final MultiKey<?> mk = new MultiKey<Object>(ONE, sysKey);         final Map<MultiKey<?>, Integer> map = new HashMap<>();         map.put(mk, TWO);          // serialize         final ByteArrayOutputStream baos = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(baos);         out.writeObject(sysKey);         out.writeObject(map);         out.close();          // deserialize         final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());         final ObjectInputStream in = new ObjectInputStream(bais);         sysKey = (SystemHashCodeSimulatingKey) in.readObject(); // simulate deserialization in another process         final Map<?, ?> map2 = (Map<?, ?>) in.readObject();         in.close();          assertEquals(2, sysKey.hashCode()); // different hashCode now          final MultiKey<?> mk2 = new MultiKey<Object>(ONE, sysKey);         assertEquals(TWO, map2.get(mk2));     }      @Test     public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException {         final DerivedMultiKey<?> mk = new DerivedMultiKey<>("A", "B");          // serialize         final ByteArrayOutputStream baos = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(baos);         out.writeObject(mk);         out.close();          // deserialize         final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());         final ObjectInputStream in = new ObjectInputStream(bais);         final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>) in.readObject();         in.close();          assertEquals(mk.hashCode(), mk2.hashCode());     }      @Test     public void testGetIndexed() {         final MultiKey<Integer> mk = new MultiKey<>(ONE, TWO);         assertSame(ONE, mk.getKey(0));         assertSame(TWO, mk.getKey(1));         try {             mk.getKey(-1);             fail();         } catch (final IndexOutOfBoundsException ex) {}         try {             mk.getKey(2);             fail();         } catch (final IndexOutOfBoundsException ex) {}     }      @Test     public void testGetKeysArrayConstructorCloned() {         final Integer[] keys = new Integer[] { ONE, TWO };         final MultiKey<Integer> mk = new MultiKey<>(keys, true);         final Object[] array = mk.getKeys();         assertTrue(array != keys);         assertTrue(Arrays.equals(array, keys));         assertSame(ONE, array[0]);         assertSame(TWO, array[1]);         assertEquals(2, array.length);     }      @Test     public void testGetKeysArrayConstructorNonCloned() {         final Integer[] keys = new Integer[] { ONE, TWO };         final MultiKey<Integer> mk = new MultiKey<>(keys, false);         final Object[] array = mk.getKeys();         assertTrue(array != keys);  // still not equal         assertTrue(Arrays.equals(array, keys));         assertSame(ONE, array[0]);         assertSame(TWO, array[1]);         assertEquals(2, array.length);     }      @Test     public void testGetKeysSimpleConstructor() {         final MultiKey<Integer> mk = new MultiKey<>(ONE, TWO);         final Object[] array = mk.getKeys();         assertSame(ONE, array[0]);         assertSame(TWO, array[1]);         assertEquals(2, array.length);     }      @Test     public void testHashCode() {         final MultiKey<Integer> mk1 = new MultiKey<>(ONE, TWO);         final MultiKey<Integer> mk2 = new MultiKey<>(ONE, TWO);         final MultiKey<Object> mk3 = new MultiKey<>(ONE, "TWO");          assertTrue(mk1.hashCode() == mk1.hashCode());         assertTrue(mk1.hashCode() == mk2.hashCode());         assertTrue(mk1.hashCode() != mk3.hashCode());          final int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();         assertEquals(total, mk1.hashCode());     }      @Test     public void testSize() {         assertEquals(2, new MultiKey<>(ONE, TWO).size());         assertEquals(2, new MultiKey<>(null, null).size());         assertEquals(3, new MultiKey<>(ONE, TWO, THREE).size());         assertEquals(3, new MultiKey<>(null, null, null).size());         assertEquals(4, new MultiKey<>(ONE, TWO, THREE, FOUR).size());         assertEquals(4, new MultiKey<>(null, null, null, null).size());         assertEquals(5, new MultiKey<>(ONE, TWO, THREE, FOUR, FIVE).size());         assertEquals(5, new MultiKey<>(null, null, null, null, null).size());          assertEquals(0, new MultiKey<>(new Object[] {}).size());         assertEquals(1, new MultiKey<>(new Integer[] { ONE }).size());         assertEquals(2, new MultiKey<>(new Integer[] { ONE, TWO }).size());         assertEquals(7, new MultiKey<>(new Integer[] { ONE, TWO, ONE, TWO, ONE, TWO, ONE }).size());     }      @Test     public void testTwoArgCtor() {         final MultiKeyTest key1 = new MultiKeyTest();         final MultiKeyTest key2 = new MultiKeyTest();         final MultiKeyTest[] keys = new MultiKey<>(key1, key2).getKeys();         assertNotNull(keys);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import java.util.Map;  import org.apache.commons.collections4.KeyValue; import org.junit.Test;  import static org.junit.Assert.*;  /**  * Test the DefaultMapEntry class.  *  * @since 3.0  */ public class DefaultMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {      //-----------------------------------------------------------------------     /**      * Make an instance of Map.Entry with the default (null) key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry() {         return new DefaultMapEntry<>(null, null);     }      /**      * Make an instance of Map.Entry with the specified key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry(final K key, final V value) {         return new DefaultMapEntry<>(key, value);     }      //-----------------------------------------------------------------------     /**      * Subclasses should override this method.      *      */     @Override     @SuppressWarnings("unchecked")     @Test     public void testConstructors() {         // 1. test key-value constructor         final Map.Entry<K, V> entry = new DefaultMapEntry<>((K) key, (V) value);         assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // 2. test pair constructor         final KeyValue<K, V> pair = new DefaultKeyValue<>((K) key, (V) value);         assertSame(key, pair.getKey());         assertSame(value, pair.getValue());          // 3. test copy constructor         final Map.Entry<K, V> entry2 = new DefaultMapEntry<>(entry);         assertSame(key, entry2.getKey());         assertSame(value, entry2.getValue());          // test that the objects are independent         entry.setValue(null);         assertSame(value, entry2.getValue());     }      @Override     @SuppressWarnings("unchecked")     public void testSelfReferenceHandling() {         final Map.Entry<K, V> entry = makeMapEntry();          try {             entry.setValue((V) entry);             assertSame(entry, entry.getValue());          } catch (final Exception e) {             fail("This Map.Entry implementation supports value self-reference.");         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import java.util.Map;  import org.apache.commons.collections4.KeyValue; import org.apache.commons.collections4.Unmodifiable; import org.junit.Test;  import static org.junit.Assert.*;  /**  * Test the UnmodifiableMapEntry class.  *  * @since 3.0  */ public class UnmodifiableMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {      //-----------------------------------------------------------------------     /**      * Make an instance of Map.Entry with the default (null) key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry() {         return new UnmodifiableMapEntry<>(null, null);     }      /**      * Make an instance of Map.Entry with the specified key and value.      * Subclasses should override this method to return a Map.Entry      * of the type being tested.      */     @Override     public Map.Entry<K, V> makeMapEntry(final K key, final V value) {         return new UnmodifiableMapEntry<>(key, value);     }      //-----------------------------------------------------------------------     /**      * Subclasses should override this method.      *      */     @Override     @SuppressWarnings("unchecked")     @Test     public void testConstructors() {         // 1. test key-value constructor         Map.Entry<K, V> entry = new UnmodifiableMapEntry<>((K) key, (V) value);         assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // 2. test pair constructor         final KeyValue<K, V> pair = new DefaultKeyValue<>((K) key, (V) value);         entry = new UnmodifiableMapEntry<>(pair);         assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // 3. test copy constructor         final Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<>(entry);         assertSame(key, entry2.getKey());         assertSame(value, entry2.getValue());          assertTrue(entry instanceof Unmodifiable);     }      @Override     @SuppressWarnings("unchecked")     public void testAccessorsAndMutators() {         Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);          assertSame(key, entry.getKey());         assertSame(value, entry.getValue());          // check that null doesn't do anything funny         entry = makeMapEntry(null, null);         assertSame(null, entry.getKey());         assertSame(null, entry.getValue());     }      @Override     @Test     public void testSelfReferenceHandling() {         // block     }      @Test     public void testUnmodifiable() {         final Map.Entry<K, V> entry = makeMapEntry();         try {             entry.setValue(null);             fail();         } catch (final UnsupportedOperationException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.keyvalue;  import org.junit.Test;  import java.util.HashMap; import java.util.Map; import static org.junit.Assert.*;  /**  * Test the TiedMapEntry class.  *  * @since 3.0  */ public class TiedMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {      //-----------------------------------------------------------------------     /**      * Gets the instance to test      */     @Override     public Map.Entry<K, V> makeMapEntry(final K key, final V value) {         final Map<K, V> map = new HashMap<>();         map.put(key, value);         return new TiedMapEntry<>(map, key);     }      //-----------------------------------------------------------------------     /**      * Tests the constructors.      */     @Override     @Test     public void testConstructors() {         // ignore     }      /**      * Tests the constructors.      */     @SuppressWarnings("unchecked")     @Test     public void testSetValue() {         final Map<K, V> map = new HashMap<>();         map.put((K) "A", (V) "a");         map.put((K) "B", (V) "b");         map.put((K) "C", (V) "c");         Map.Entry<K, V> entry = new TiedMapEntry<>(map, (K) "A");         assertSame("A", entry.getKey());         assertSame("a", entry.getValue());         assertSame("a", entry.setValue((V) "x"));         assertSame("A", entry.getKey());         assertSame("x", entry.getValue());          entry = new TiedMapEntry<>(map, (K) "B");         assertSame("B", entry.getKey());         assertSame("b", entry.getValue());         assertSame("b", entry.setValue((V) "y"));         assertSame("B", entry.getKey());         assertSame("y", entry.getValue());          entry = new TiedMapEntry<>(map, (K) "C");         assertSame("C", entry.getKey());         assertSame("c", entry.getValue());         assertSame("c", entry.setValue((V) "z"));         assertSame("C", entry.getKey());         assertSame("z", entry.getValue());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Enumeration; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.concurrent.atomic.AtomicInteger;  import org.junit.Before; import org.junit.Test;  /**  * Tests for FluentIterable.  *  * @since 4.1  */ public class FluentIterableTest {      /**      * Iterable of {@link Integer}s      */     private Iterable<Integer> iterableA = null;      /**      * Iterable of {@link Long}s      */     private Iterable<Long> iterableB = null;      /**      * Collection of even {@link Integer}s      */     private Iterable<Integer> iterableEven = null;      /**      * Collection of odd {@link Integer}s      */     private Iterable<Integer> iterableOdd = null;      /**      * An empty Iterable.      */     private Iterable<Integer> emptyIterable = null;      @Before     public void setUp() {         final Collection<Integer> collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         iterableA = collectionA;          final Collection<Long> collectionB = new LinkedList<>();         collectionB.add(5L);         collectionB.add(4L);         collectionB.add(4L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         iterableB = collectionB;          iterableEven = Arrays.asList(2, 4, 6, 8, 10, 12);         iterableOdd = Arrays.asList(1, 3, 5, 7, 9, 11);          emptyIterable = Collections.emptyList();     }      private static Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;      // -----------------------------------------------------------------------     @Test     public void factoryMethodOf() {         FluentIterable<Integer> iterable = FluentIterable.of(1, 2, 3, 4, 5);         List<Integer> result = iterable.toList();         assertEquals(Arrays.asList(1, 2, 3, 4, 5), result);          iterable = FluentIterable.of(1);         assertEquals(1, iterable.size());         assertFalse(iterable.isEmpty());         assertEquals(Arrays.asList(1), iterable.toList());          result = FluentIterable.of(new Integer[0]).toList();         assertTrue(result.isEmpty());          final Iterable<Integer> it = null;         try {             FluentIterable.of(it).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void appendElements() {         final FluentIterable<Integer> it = FluentIterable.of(iterableA).append(10, 20, 30);         assertEquals(IterableUtils.size(iterableA) + 3, IterableUtils.size(it));         assertTrue(IterableUtils.contains(it, 1));         assertTrue(IterableUtils.contains(it, 10));         assertTrue(IterableUtils.contains(it, 20));         assertTrue(IterableUtils.contains(it, 30));         assertFalse(IterableUtils.contains(it, 40));          final FluentIterable<Integer> empty = FluentIterable.of(emptyIterable).append();         assertTrue(IterableUtils.isEmpty(empty));     }      @Test     public void appendIterable() {         final List<Integer> listB = Arrays.asList(10, 20, 30);         final FluentIterable<Integer> it = FluentIterable.of(iterableA).append(listB);         assertEquals(IterableUtils.size(iterableA) + listB.size(), IterableUtils.size(it));         assertTrue(IterableUtils.contains(it, 1));         assertTrue(IterableUtils.contains(it, 10));         assertTrue(IterableUtils.contains(it, 20));         assertTrue(IterableUtils.contains(it, 30));         assertFalse(IterableUtils.contains(it, 40));     }      @Test     public void collate() {         final List<Integer> result = FluentIterable.of(iterableOdd).collate(iterableEven).toList();         final List<Integer> combinedList = new ArrayList<>();         CollectionUtils.addAll(combinedList, iterableOdd);         CollectionUtils.addAll(combinedList, iterableEven);         Collections.sort(combinedList);         assertEquals(combinedList, result);          try {             FluentIterable.of(iterableOdd).collate(null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void collateWithComparator() {         List<Integer> result =                 FluentIterable                     .of(iterableOdd)                     .collate(iterableEven, ComparatorUtils.<Integer>naturalComparator())                     .toList();          final List<Integer> combinedList = new ArrayList<>();         CollectionUtils.addAll(combinedList, iterableOdd);         CollectionUtils.addAll(combinedList, iterableEven);         Collections.sort(combinedList);         assertEquals(combinedList, result);          // null comparator is equivalent to natural ordering         result = FluentIterable.of(iterableOdd).collate(iterableEven, null).toList();         assertEquals(combinedList, result);     }      @Test     public void filter() {         final Predicate<Integer> smallerThan3 = object -> object.intValue() < 3;         List<Integer> result = FluentIterable.of(iterableA).filter(smallerThan3).toList();         assertEquals(3, result.size());         assertEquals(Arrays.asList(1, 2, 2), result);          // empty iterable         result = FluentIterable.of(emptyIterable).filter(smallerThan3).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).filter(null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void forEach() {         final AtomicInteger sum = new AtomicInteger(0);         final Closure<Integer> closure = input -> sum.addAndGet(input);          FluentIterable.of(iterableA).forEach(closure);         int expectedSum = 0;         for (final Integer i : iterableA) {             expectedSum += i;         }         assertEquals(expectedSum, sum.get());          try {             FluentIterable.of(iterableA).forEach((Closure<Integer>) null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void limit() {         List<Integer> result = FluentIterable.of(iterableA).limit(3).toList();         assertEquals(3, result.size());         assertEquals(Arrays.asList(1, 2, 2), result);          // limit larger than input         result = FluentIterable.of(iterableA).limit(100).toList();         final List<Integer> expected = IterableUtils.toList(iterableA);         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          // limit is 0         result = FluentIterable.of(iterableA).limit(0).toList();         assertEquals(0, result.size());          // empty iterable         result = FluentIterable.of(emptyIterable).limit(3).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).limit(-2).toList();             fail("expecting IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected         }     }      @Test     public void reverse() {         List<Integer> result = FluentIterable.of(iterableA).reverse().toList();         final List<Integer> expected = IterableUtils.toList(iterableA);         Collections.reverse(expected);         assertEquals(expected, result);          // empty iterable         result = FluentIterable.of(emptyIterable).reverse().toList();         assertEquals(0, result.size());     }      @Test     public void skip() {         List<Integer> result = FluentIterable.of(iterableA).skip(4).toList();         assertEquals(6, result.size());         assertEquals(Arrays.asList(3, 3, 4, 4, 4, 4), result);          // skip larger than input         result = FluentIterable.of(iterableA).skip(100).toList();         assertEquals(0, result.size());          // skip 0 elements         result = FluentIterable.of(iterableA).skip(0).toList();         final List<Integer> expected = IterableUtils.toList(iterableA);         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          // empty iterable         result = FluentIterable.of(emptyIterable).skip(3).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).skip(-4).toList();             fail("expecting IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected         }     }      @Test     public void transform() {         final Transformer<Integer, Integer> squared = object -> object * object;         List<Integer> result = FluentIterable.of(iterableA).transform(squared).toList();         assertEquals(10, result.size());         assertEquals(Arrays.asList(1, 4, 4, 9, 9, 9, 16, 16, 16, 16), result);          // empty iterable         result = FluentIterable.of(emptyIterable).transform(squared).toList();         assertEquals(0, result.size());          try {             FluentIterable.of(iterableA).transform(null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void unique() {         List<Integer> result = FluentIterable.of(iterableA).unique().toList();         assertEquals(4, result.size());         assertEquals(Arrays.asList(1, 2, 3, 4), result);          // empty iterable         result = FluentIterable.of(emptyIterable).unique().toList();         assertEquals(0, result.size());     }      @Test     public void unmodifiable() {         final FluentIterable<Integer> iterable1 = FluentIterable.of(iterableA).unmodifiable();         final Iterator<Integer> it = iterable1.iterator();         assertEquals(1, it.next().intValue());         try {             it.remove();             fail("expecting UnsupportedOperationException");         } catch (final UnsupportedOperationException ise) {             // expected         }          // calling unmodifiable on an already unmodifiable iterable shall return the same instance         final FluentIterable<Integer> iterable2 = iterable1.unmodifiable();         assertSame(iterable1, iterable2);     }      @SuppressWarnings("unchecked")     @Test     public void zip() {         List<Integer> result = FluentIterable.of(iterableOdd).zip(iterableEven).toList();         List<Integer> combinedList = new ArrayList<>();         CollectionUtils.addAll(combinedList, iterableOdd);         CollectionUtils.addAll(combinedList, iterableEven);         Collections.sort(combinedList);         assertEquals(combinedList, result);          try {             FluentIterable.of(iterableOdd).zip((Iterable<Integer>) null).toList();             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          result = FluentIterable                     .of(Arrays.asList(1, 4, 7))                     .zip(Arrays.asList(2, 5, 8), Arrays.asList(3, 6, 9))                     .toList();         combinedList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);         assertEquals(combinedList, result);     }      @Test     public void asEnumeration() {         Enumeration<Long> enumeration = FluentIterable.of(iterableB).asEnumeration();         final List<Long> result = EnumerationUtils.toList(enumeration);         assertEquals(iterableB, result);          enumeration = FluentIterable.<Long>empty().asEnumeration();         assertFalse(enumeration.hasMoreElements());     }      @Test     public void allMatch() {         assertTrue(FluentIterable.of(iterableEven).allMatch(EVEN));         assertFalse(FluentIterable.of(iterableOdd).allMatch(EVEN));         assertFalse(FluentIterable.of(iterableA).allMatch(EVEN));          try {             FluentIterable.of(iterableEven).allMatch(null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void anyMatch() {         assertTrue(FluentIterable.of(iterableEven).anyMatch(EVEN));         assertFalse(FluentIterable.of(iterableOdd).anyMatch(EVEN));         assertTrue(FluentIterable.of(iterableA).anyMatch(EVEN));          try {             FluentIterable.of(iterableEven).anyMatch(null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void isEmpty() {         assertTrue(FluentIterable.of(emptyIterable).isEmpty());         assertFalse(FluentIterable.of(iterableOdd).isEmpty());     }      @Test     public void size() {         assertEquals(0, FluentIterable.of(emptyIterable).size());         assertEquals(IterableUtils.toList(iterableOdd).size(), FluentIterable.of(iterableOdd).size());     }      @Test     public void eval() {         final List<Integer> listNumbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));         final FluentIterable<Integer> iterable = FluentIterable.of(listNumbers).filter(EVEN);         final FluentIterable<Integer> materialized = iterable.eval();          listNumbers.addAll(Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20));         assertEquals(5, materialized.size());         assertEquals(10, iterable.size());          assertEquals(Arrays.asList(2, 4, 6, 8, 10), materialized.toList());         assertEquals(Arrays.asList(2, 4, 6, 8, 10, 12, 14, 16, 18, 20), iterable.toList());     }      @Test     public void contains() {         assertTrue(FluentIterable.of(iterableEven).contains(2));         assertFalse(FluentIterable.of(iterableEven).contains(1));         assertFalse(FluentIterable.of(iterableEven).contains(null));         assertTrue(FluentIterable.of(iterableEven).append((Integer) null).contains(null));     }      @Test     public void copyInto() {         List<Integer> result = new ArrayList<>();         FluentIterable.of(iterableA).copyInto(result);          List<Integer> expected = IterableUtils.toList(iterableA);         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          result = new ArrayList<>();         result.add(10);         result.add(9);         result.add(8);         FluentIterable.of(iterableA).copyInto(result);          expected = new ArrayList<>(Arrays.asList(10, 9, 8));         expected.addAll(IterableUtils.toList(iterableA));         assertEquals(expected.size(), result.size());         assertEquals(expected, result);          try {             FluentIterable.of(iterableA).copyInto(null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void iterator() {         Iterator<Integer> iterator = FluentIterable.of(iterableA).iterator();         assertTrue(iterator.hasNext());          iterator = FluentIterable.<Integer>empty().iterator();         assertFalse(iterator.hasNext());     }      @Test     public void get() {         assertEquals(2, FluentIterable.of(iterableEven).get(0).intValue());          try {             FluentIterable.of(iterableEven).get(-1);             fail("expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ioe) {             // expected         }          try {             FluentIterable.of(iterableEven).get(IterableUtils.size(iterableEven));             fail("expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ioe) {             // expected         }     }      @SuppressWarnings({ "rawtypes", "unchecked" })     @Test     public void toArray() {         final Long[] arr = new Long[] {1L, 2L, 3L, 4L, 5L};         final Long[] result = FluentIterable.of(arr).toArray(Long.class);         assertNotNull(result);         assertArrayEquals(arr, result);          try {             FluentIterable.of(arr).toArray((Class) String.class);         } catch (final ArrayStoreException ase) {             // expected         }     }      @Test     public void testToString() {         String result = FluentIterable.of(iterableA).toString();         assertEquals(iterableA.toString(), result);          result = FluentIterable.empty().toString();         assertEquals("[]", result);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import static org.easymock.EasyMock.*;  import java.util.Iterator;  import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.w3c.dom.Text;  /**  * Tests the NodeListIterator.  */ public class NodeListIteratorTest extends AbstractIteratorTest<Node> {      // Node array to be filled with mocked Node instances     private Node[] nodes;      // NodeListIterator supports two constructors. This flag allows to     // control, which constructor to use in makeObject() and makeEmptyIterator     private boolean createIteratorWithStandardConstr = true;      /**      * Constructor      * @param testName      */     public NodeListIteratorTest(final String testName) {         super(testName);     }      @Override     protected void setUp() throws Exception {         super.setUp();          // Default: use standard constr.         createIteratorWithStandardConstr = true;           // create mocked Node Instances and fill Node[] to be used by test cases         final Node node1 = createMock(Element.class);         final Node node2 = createMock(Element.class);         final Node node3 = createMock(Text.class);         final Node node4 = createMock(Element.class);         nodes = new Node[] {node1, node2, node3, node4};          replay(node1);         replay(node2);         replay(node3);         replay(node4);     }      @Override     public Iterator<Node> makeEmptyIterator() {         final NodeList emptyNodeList = new NodeList() {             @Override             public Node item(final int index) {                 throw new IndexOutOfBoundsException();             }             @Override             public int getLength() {                 return 0;             }         };          if (createIteratorWithStandardConstr) {             return new NodeListIterator(emptyNodeList);         }         final Node parentNode = createMock(Node.class);         expect(parentNode.getChildNodes()).andStubReturn(emptyNodeList);         replay(parentNode);          return new NodeListIterator(parentNode);     }      @Override     public Iterator<Node> makeObject() {         final NodeList nodeList = new NodeList() {             @Override             public Node item(final int index) {                 return nodes[index];             }             @Override             public int getLength() {                 return nodes.length;             }         };          return new NodeListIterator(nodeList);     }      @Override     public boolean supportsRemove() {         return false;     }      //-----------------------------------------------------------------------     public void testNullConstructor(){         try{             new NodeListIterator((Node) null);             fail("NullPointerException expected!");         }catch(final NullPointerException e){             // expected.         }     }      /**      * tests the convenience Constructor with parameter type org.w3c.Node      */     public void testEmptyIteratorWithNodeConstructor(){         createIteratorWithStandardConstr = false;         testEmptyIterator();     }      /**      * tests the convenience Constructor with parameter type org.w3c.Node      */     public void testFullIteratorWithNodeConstructor(){         createIteratorWithStandardConstr = false;         testFullIterator();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.Predicate;  /**  * Tests the IteratorChain class.  *  */ public class IteratorChainTest extends AbstractIteratorTest<String> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<String> list1 = null;     protected List<String> list2 = null;     protected List<String> list3 = null;      public IteratorChainTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         list1 = new ArrayList<>();         list1.add("One");         list1.add("Two");         list1.add("Three");         list2 = new ArrayList<>();         list2.add("Four");         list3 = new ArrayList<>();         list3.add("Five");         list3.add("Six");     }      @Override     public IteratorChain<String> makeEmptyIterator() {         final ArrayList<String> list = new ArrayList<>();         return new IteratorChain<>(list.iterator());     }      @Override     public IteratorChain<String> makeObject() {         final IteratorChain<String> chain = new IteratorChain<>();          chain.addIterator(list1.iterator());         chain.addIterator(list2.iterator());         chain.addIterator(list3.iterator());         return chain;     }      public void testIterator() {         final Iterator<String> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testRemoveFromFilteredIterator() {          final Predicate<Integer> myPredicate = i -> i.compareTo(Integer.valueOf(4)) < 0;          final List<Integer> list1 = new ArrayList<>();         final List<Integer> list2 = new ArrayList<>();          list1.add(Integer.valueOf(1));         list1.add(Integer.valueOf(2));         list2.add(Integer.valueOf(3));         list2.add(Integer.valueOf(4)); // will be ignored by the predicate          final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);         final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);          final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);         while (it.hasNext()) {             it.next();             it.remove();         }         assertEquals(0, list1.size());         assertEquals(1, list2.size());     }      @Override     public void testRemove() {         final Iterator<String> iter = makeObject();          try {             iter.remove();             fail("Calling remove before the first call to next() should throw an exception");         } catch (final IllegalStateException e) {          }          for (final String testValue : testArray) {             final String iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);              if (!iterValue.equals("Four")) {                 iter.remove();             }         }          assertTrue("List is empty", list1.size() == 0);         assertTrue("List is empty", list2.size() == 1);         assertTrue("List is empty", list3.size() == 0);     }      public void testFirstIteratorIsEmptyBug() {         final List<String> empty = new ArrayList<>();         final List<String> notEmpty = new ArrayList<>();         notEmpty.add("A");         notEmpty.add("B");         notEmpty.add("C");         final IteratorChain<String> chain = new IteratorChain<>();         chain.addIterator(empty.iterator());         chain.addIterator(notEmpty.iterator());         assertTrue("should have next", chain.hasNext());         assertEquals("A", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("B", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("C", chain.next());         assertTrue("should not have next", !chain.hasNext());     }      public void testEmptyChain() {         final IteratorChain<Object> chain = new IteratorChain<>();         assertEquals(false, chain.hasNext());         try {             chain.next();             fail();         } catch (final NoSuchElementException ex) {}         try {             chain.remove();             fail();         } catch (final IllegalStateException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  /**  * Tests the ObjectArrayIterator.  *  */ public class ObjectArrayIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };      public ObjectArrayIteratorTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayIterator<E> makeEmptyIterator() {         return new ObjectArrayIterator<>((E[]) new Object[0]);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayIterator<E> makeObject() {         return new ObjectArrayIterator<>((E[]) testArray);     }      @SuppressWarnings("unchecked")     public ObjectArrayIterator<E> makeArrayIterator() {         return new ObjectArrayIterator<>();     }      public ObjectArrayIterator<E> makeArrayIterator(final E[] array) {         return new ObjectArrayIterator<>(array);     }      public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int index) {         return new ObjectArrayIterator<>(array, index);     }      public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int start, final int end) {         return new ObjectArrayIterator<>(array, start, end);     }      @Override     public boolean supportsRemove() {         return false;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final String testValue : testArray) {             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testNullArray() {         try {             makeArrayIterator(null);              fail("Constructor should throw a NullPointerException when constructed with a null array");         } catch (final NullPointerException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testReset() {         final ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);         it.next();         it.reset();         assertEquals("One", it.next());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableIterator;  /**  * Tests the SingletonIterator to ensure that the next() method will actually  * perform the iteration rather than the hasNext() method.  *  */ public class SingletonIteratorTest<E> extends AbstractIteratorTest<E> {      private static final Object testValue = "foo";      public SingletonIteratorTest(final String testName) {         super(testName);     }      /**      * Returns a SingletonIterator from which      * the element has already been removed.      */     @Override     public SingletonIterator<E> makeEmptyIterator() {         final SingletonIterator<E> iter = makeObject();         iter.next();         iter.remove();         iter.reset();         return iter;     }      @Override     @SuppressWarnings("unchecked")     public SingletonIterator<E> makeObject() {         return new SingletonIterator<>((E) testValue);     }      @Override     public boolean supportsRemove() {         return true;     }      @Override     public boolean supportsEmptyIterator() {         return true;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         assertTrue("Iterator has a first item", iter.hasNext());          final E iterValue = iter.next();         assertEquals("Iteration value is correct", testValue, iterValue);          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      @SuppressWarnings("unchecked")     public void testSingletonIteratorRemove() {         final ResettableIterator<E> iter = new SingletonIterator<>((E) "xyzzy");         assertTrue(iter.hasNext());         assertEquals("xyzzy", iter.next());         iter.remove();         iter.reset();         assertTrue(! iter.hasNext());     }      public void testReset() {         final ResettableIterator<E> it = makeObject();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();         it.reset();          assertEquals(true, it.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * Tests the LoopingIterator class.  *  */ public class LoopingIteratorTest {      /**      * Tests constructor exception.      */     @Test     public void testConstructorEx() throws Exception {         try {             new LoopingIterator<>(null);             fail();         } catch (final NullPointerException ex) {         }     }      /**      * Tests whether an empty looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping0() throws Exception {         final List<Object> list = new ArrayList<>();         final LoopingIterator<Object> loop = new LoopingIterator<>(list);         assertTrue("hasNext should return false", !loop.hasNext());          try {             loop.next();             fail("NoSuchElementException was not thrown during next() call.");         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests whether a populated looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping1() throws Exception {         final List<String> list = Arrays.asList("a");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());      }      /**      * Tests whether a populated looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping2() throws Exception {         final List<String> list = Arrays.asList("a", "b");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("b", loop.next());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());      }      /**      * Tests whether a populated looping iterator works as designed.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testLooping3() throws Exception {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("b", loop.next());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("c", loop.next());          assertTrue("4th hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());      }      /**      * Tests the remove() method on a LoopingIterator wrapped ArrayList.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testRemoving1() throws Exception {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingIterator<String> loop = new LoopingIterator<>(list);         assertEquals("list should have 3 elements.", 3, list.size());          assertTrue("1st hasNext should return true", loop.hasNext());         assertEquals("a", loop.next());         loop.remove();  // removes a         assertEquals("list should have 2 elements.", 2, list.size());          assertTrue("2nd hasNext should return true", loop.hasNext());         assertEquals("b", loop.next());         loop.remove();  // removes b         assertEquals("list should have 1 elements.", 1, list.size());          assertTrue("3rd hasNext should return true", loop.hasNext());         assertEquals("c", loop.next());         loop.remove();  // removes c         assertEquals("list should have 0 elements.", 0, list.size());          assertFalse("4th hasNext should return false", loop.hasNext());         try {             loop.next();             fail("Expected NoSuchElementException to be thrown.");         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests the reset() method on a LoopingIterator wrapped ArrayList.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testReset() throws Exception {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertEquals("a", loop.next());         assertEquals("b", loop.next());         loop.reset();         assertEquals("a", loop.next());         loop.reset();         assertEquals("a", loop.next());         assertEquals("b", loop.next());         assertEquals("c", loop.next());         loop.reset();         assertEquals("a", loop.next());         assertEquals("b", loop.next());         assertEquals("c", loop.next());     }      /**      * Tests the size() method on a LoopingIterator wrapped ArrayList.      * @throws Exception  If something unexpected occurs.      */     @Test     public void testSize() throws Exception {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingIterator<String> loop = new LoopingIterator<>(list);          assertEquals(3, loop.size());         loop.next();         loop.next();         assertEquals(3, loop.size());         loop.reset();         assertEquals(3, loop.size());         loop.next();         loop.remove();         assertEquals(2, loop.size());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Tests for IteratorIterable.  *  */ public class IteratorIterableTest extends BulkTest {      public static Test suite() {         return BulkTest.makeSuite(IteratorIterableTest.class);     }      public IteratorIterableTest(final String name) {         super(name);     }      private Iterator<Integer> createIterator() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iter = list.iterator();         return iter;     }      @SuppressWarnings("unused")     public void testIterator() {         final Iterator<Integer> iter = createIterator();         final Iterable<Number> iterable = new IteratorIterable<>(iter);          // first use         verifyIteration(iterable);          // second use         for (final Number actual : iterable) {             fail("should not be able to iterate twice");         }     }      public void testMultipleUserIterator() {         final Iterator<Integer> iter = createIterator();          final Iterable<Number> iterable = new IteratorIterable<>(iter, true);          // first use         verifyIteration(iterable);          // second use         verifyIteration(iterable);     }      private void verifyIteration(final Iterable<Number> iterable) {         int expected = 0;         for (final Number actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         assertTrue(expected > 0);     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.MapIterator;  /**  * Abstract class for testing the MapIterator interface.  * <p>  * This class provides a framework for testing an implementation of MapIterator.  * Concrete subclasses must provide the list iterator to be tested.  * They must also specify certain details of how the list iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractMapIteratorTest<K, V> extends AbstractIteratorTest<K> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractMapIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implement this method to return a map iterator over an empty map.      *      * @return an empty iterator      */     @Override     public abstract MapIterator<K, V> makeEmptyIterator();      /**      * Implement this method to return a map iterator over a map with elements.      *      * @return a full iterator      */     @Override     public abstract MapIterator<K, V> makeObject();      /**      * Implement this method to return the map which contains the same data as the      * iterator.      *      * @return a full map which can be updated      */     public abstract Map<K, V> getMap();      /**      * Implement this method to return the confirmed map which contains the same      * data as the iterator.      *      * @return a full map which can be updated      */     public abstract Map<K, V> getConfirmedMap();      /**      * Whether or not we are testing an iterator that supports setValue().      * Default is true.      *      * @return true if Iterator supports set      */     public boolean supportsSetValue() {         return true;     }      /**      * Whether the get operation on the map structurally modifies the map,      * such as with LRUMap. Default is false.      *      * @return true if the get method structurally modifies the map      */     public boolean isGetStructuralModify() {         return false;     }      /**      * The values to be used in the add and set tests.      * Default is two strings.      */     @SuppressWarnings("unchecked")     public V[] addSetValues() {         return (V[]) new Object[] { "A", "B" };     }      //-----------------------------------------------------------------------     /**      * Test that the empty list iterator contract is correct.      */     public void testEmptyMapIterator() {         if (!supportsEmptyIterator()) {             return;         }          final MapIterator<K, V> it = makeEmptyIterator();         assertEquals(false, it.hasNext());          // next() should throw a NoSuchElementException         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {}          // getKey() should throw an IllegalStateException         try {             it.getKey();             fail();         } catch (final IllegalStateException ex) {}          // getValue() should throw an IllegalStateException         try {             it.getValue();             fail();         } catch (final IllegalStateException ex) {}          if (!supportsSetValue()) {             // setValue() should throw an UnsupportedOperationException/IllegalStateException             try {                 it.setValue(addSetValues()[0]);                 fail();             } catch (final UnsupportedOperationException ex) {             } catch (final IllegalStateException ex) {}         } else {             // setValue() should throw an IllegalStateException             try {                 it.setValue(addSetValues()[0]);                 fail();             } catch (final IllegalStateException ex) {}         }     }      //-----------------------------------------------------------------------     /**      * Test that the full list iterator contract is correct.      */     public void testFullMapIterator() {         if (!supportsFullIterator()) {             return;         }          final MapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();         assertEquals(true, it.hasNext());          assertEquals(true, it.hasNext());         final Set<K> set = new HashSet<>();         while (it.hasNext()) {             // getKey             final K key = it.next();             assertSame("it.next() should equals getKey()", key, it.getKey());             assertTrue("Key must be in map",  map.containsKey(key));             assertTrue("Key must be unique", set.add(key));              // getValue             final V value = it.getValue();             if (!isGetStructuralModify()) {                 assertSame("Value must be mapped to key", map.get(key), value);             }             assertTrue("Value must be in map",  map.containsValue(value));              verify();         }     }      //-----------------------------------------------------------------------     public void testMapIteratorSet() {         if (!supportsFullIterator()) {             return;         }          final V newValue = addSetValues()[0];         final V newValue2 = addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1];         final MapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();         final Map<K, V> confirmed = getConfirmedMap();         assertEquals(true, it.hasNext());         final K key = it.next();         final V value = it.getValue();          if (!supportsSetValue()) {             try {                 it.setValue(newValue);                 fail();             } catch (final UnsupportedOperationException ex) {}             return;         }         final V old = it.setValue(newValue);         confirmed.put(key, newValue);         assertSame("Key must not change after setValue", key, it.getKey());         assertSame("Value must be changed after setValue", newValue, it.getValue());         assertSame("setValue must return old value", value, old);         assertEquals("Map must contain key", true, map.containsKey(key));         // test against confirmed, as map may contain value twice         assertEquals("Map must not contain old value",             confirmed.containsValue(old), map.containsValue(old));         assertEquals("Map must contain new value", true, map.containsValue(newValue));         verify();          it.setValue(newValue);  // same value - should be OK         confirmed.put(key, newValue);         assertSame("Key must not change after setValue", key, it.getKey());         assertSame("Value must be changed after setValue", newValue, it.getValue());         verify();          it.setValue(newValue2);  // new value         confirmed.put(key, newValue2);         assertSame("Key must not change after setValue", key, it.getKey());         assertSame("Value must be changed after setValue", newValue2, it.getValue());         verify();     }      //-----------------------------------------------------------------------     @Override     public void testRemove() { // override         final MapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();         final Map<K, V> confirmed = getConfirmedMap();         assertEquals(true, it.hasNext());         final K key = it.next();          if (!supportsRemove()) {             try {                 it.remove();                 fail();             } catch (final UnsupportedOperationException ex) {             }             return;         }          it.remove();         confirmed.remove(key);         assertEquals(false, map.containsKey(key));         verify();          try {             it.remove();  // second remove fails         } catch (final IllegalStateException ex) {         }         verify();     }      //-----------------------------------------------------------------------     public void testMapIteratorSetRemoveSet() {         if (!supportsSetValue() || !supportsRemove()) {             return;         }         final V newValue = addSetValues()[0];         final MapIterator<K, V> it = makeObject();         final Map<K, V> confirmed = getConfirmedMap();          assertEquals(true, it.hasNext());         final K key = it.next();          it.setValue(newValue);         it.remove();         confirmed.remove(key);         verify();          try {             it.setValue(newValue);             fail();         } catch (final IllegalStateException ex) {}         verify();     }      //-----------------------------------------------------------------------     public void testMapIteratorRemoveGetKey() {         if (!supportsRemove()) {             return;         }         final MapIterator<K, V> it = makeObject();         final Map<K, V> confirmed = getConfirmedMap();          assertEquals(true, it.hasNext());         final K key = it.next();          it.remove();         confirmed.remove(key);         verify();          try {             it.getKey();             fail();         } catch (final IllegalStateException ex) {}         verify();     }      //-----------------------------------------------------------------------     public void testMapIteratorRemoveGetValue() {         if (!supportsRemove()) {             return;         }         final MapIterator<K, V> it = makeObject();         final Map<K, V> confirmed = getConfirmedMap();          assertEquals(true, it.hasNext());         final K key = it.next();          it.remove();         confirmed.remove(key);         verify();          try {             it.getValue();             fail();         } catch (final IllegalStateException ex) {}         verify();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableIterator;  /**  * Tests the SingletonIterator to ensure that the next() method will actually  * perform the iteration rather than the hasNext() method.  *  */ public class SingletonIterator2Test<E> extends AbstractIteratorTest<E> {      private static final Object testValue = "foo";      public SingletonIterator2Test(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public SingletonIterator<E> makeEmptyIterator() {         final SingletonIterator<E> iter = new SingletonIterator<>((E) testValue);         iter.next();         iter.remove();         iter.reset();         return iter;     }      @Override     @SuppressWarnings("unchecked")     public SingletonIterator<E> makeObject() {         return new SingletonIterator<>((E) testValue, false);     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsEmptyIterator() {         return false;     }      //-----------------------------------------------------------------------     public void testIterator() {         final Iterator<E> iter = makeObject();         assertTrue("Iterator has a first item", iter.hasNext());          final E iterValue = iter.next();         assertEquals("Iteration value is correct", testValue, iterValue);          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testReset() {         final ResettableIterator<E> it = makeObject();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();          assertEquals(true, it.hasNext());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());          it.reset();         it.reset();          assertEquals(true, it.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  /**  * Test the ArrayListIterator class with primitives.  *  */ public class ArrayListIterator2Test<E> extends ArrayIterator2Test<E> {      public ArrayListIterator2Test(final String testName) {         super(testName);     }      @Override     public ArrayListIterator<E> makeEmptyIterator() {         return new ArrayListIterator<>(new int[0]);     }      @Override     public ArrayListIterator<E> makeObject() {         return new ArrayListIterator<>(testArray);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array) {         return new ArrayListIterator<>(array);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array, final int index) {         return new ArrayListIterator<>(array, index);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array, final int start, final int end) {         return new ArrayListIterator<>(array, start, end);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test; import static org.junit.Assert.*;  /**  * Tests the LoopingListIterator class.  *  */ public class LoopingListIteratorTest {      /**      * Tests constructor exception.      */     @Test     public void testConstructorEx() throws Exception {         try {             new LoopingListIterator<>(null);             fail();         } catch (final NullPointerException ex) {         }     }      /**      * Tests whether an empty looping list iterator works.      */     @Test     public void testLooping0() throws Exception {         final List<Object> list = new ArrayList<>();         final LoopingListIterator<Object> loop = new LoopingListIterator<>(list);         assertFalse(loop.hasNext());         assertFalse(loop.hasPrevious());          try {             loop.next();             fail();         } catch (final NoSuchElementException ex) {         }          try {             loop.previous();             fail();         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests whether a looping list iterator works on a list with only      * one element.      */     @Test     public void testLooping1() throws Exception {         final List<String> list = Arrays.asList("a");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a>          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // <a>          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // <a>          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // <a>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>     }      /**      * Tests whether a looping list iterator works on a list with two      * elements.      */     @Test     public void testLooping2() throws Exception {         final List<String> list = Arrays.asList("a", "b");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // a <b>          assertTrue(loop.hasNext());         assertEquals("b", loop.next());     // <a> b          assertTrue(loop.hasNext());         assertEquals("a", loop.next());     // a <b>          // Reset the iterator and try using previous.         loop.reset();                       // <a> b          assertTrue(loop.hasPrevious());         assertEquals("b", loop.previous()); // a <b>          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a> b          assertTrue(loop.hasPrevious());         assertEquals("b", loop.previous()); // a <b>     }      /**      * Tests jogging back and forth between two elements, but not over      * the begin/end boundary of the list.      */     @Test     public void testJoggingNotOverBoundary() {         final List<String> list = Arrays.asList("a", "b");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b          // Try jogging back and forth between the elements, but not         // over the begin/end boundary.         loop.reset();         assertEquals("a", loop.next());     // a <b>         assertEquals("a", loop.previous()); // <a> b         assertEquals("a", loop.next());     // a <b>          assertEquals("b", loop.next());     // <a> b         assertEquals("b", loop.previous()); // a <b>         assertEquals("b", loop.next());     // <a> b     }      /**      * Tests jogging back and forth between two elements over the      * begin/end boundary of the list.      */     @Test     public void testJoggingOverBoundary() {         final List<String> list = Arrays.asList("a", "b");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b          // Try jogging back and forth between the elements, but not         // over the begin/end boundary.         assertEquals("b", loop.previous()); // a <b>         assertEquals("b", loop.next());     // <a> b         assertEquals("b", loop.previous()); // a <b>          assertEquals("a", loop.previous()); // <a> b         assertEquals("a", loop.next());     // a <b>         assertEquals("a", loop.previous()); // <a> b     }      /**      * Tests removing an element from a wrapped ArrayList.      */     @Test     public void testRemovingElementsAndIteratingForward() {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertTrue(loop.hasNext());         assertEquals("a", loop.next()); // a <b> c         loop.remove();                  // <b> c         assertEquals(2, list.size());          assertTrue(loop.hasNext());         assertEquals("b", loop.next()); // b <c>         loop.remove();                  // <c>         assertEquals(1, list.size());          assertTrue(loop.hasNext());         assertEquals("c", loop.next()); // <c>         loop.remove();                  // ---         assertEquals(0, list.size());          assertFalse(loop.hasNext());         try {             loop.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests removing an element from a wrapped ArrayList.      */     @Test     public void testRemovingElementsAndIteratingBackwards() {         final List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertTrue(loop.hasPrevious());         assertEquals("c", loop.previous()); // a b <c>         loop.remove();                      // <a> b         assertEquals(2, list.size());          assertTrue(loop.hasPrevious());         assertEquals("b", loop.previous()); // a <b>         loop.remove();                      // <a>         assertEquals(1, list.size());          assertTrue(loop.hasPrevious());         assertEquals("a", loop.previous()); // <a>         loop.remove();                      // ---         assertEquals(0, list.size());          assertFalse(loop.hasPrevious());         try {             loop.previous();             fail();         } catch (final NoSuchElementException ex) {         }     }      /**      * Tests the reset method.      */     @Test     public void testReset() {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertEquals("a", loop.next()); // a <b> c         assertEquals("b", loop.next()); // a b <c>         loop.reset();                   // <a> b c         assertEquals("a", loop.next()); // a <b> c         loop.reset();                   // <a> b c         assertEquals("a", loop.next()); // a <b> c         assertEquals("b", loop.next()); // a b <c>         assertEquals("c", loop.next()); // <a> b c         loop.reset();                   // <a> b c          assertEquals("c", loop.previous()); // a b <c>         assertEquals("b", loop.previous()); // a <b> c         loop.reset();                       // <a> b c         assertEquals("c", loop.previous()); // a b <c>         loop.reset();                       // <a> b c         assertEquals("c", loop.previous()); // a b <c>         assertEquals("b", loop.previous()); // a <b> c         assertEquals("a", loop.previous()); // <a> b c     }      /**      * Tests the add method.      */     @Test     public void testAdd() {         List<String> list = new ArrayList<>(Arrays.asList("b", "e", "f"));         LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <b> e f          loop.add("a");                      // <a> b e f         assertEquals("b", loop.next());     // a <b> e f         loop.reset();                       // <a> b e f         assertEquals("a", loop.next());     // a <b> e f         assertEquals("b", loop.next());     // a b <e> f          loop.add("c");                      // a b c <e> f         assertEquals("e", loop.next());     // a b c e <f>         assertEquals("e", loop.previous()); // a b c <e> f         assertEquals("c", loop.previous()); // a b <c> e f         assertEquals("c", loop.next());     // a b c <e> f          loop.add("d");                      // a b c d <e> f         loop.reset();                       // <a> b c d e f         assertEquals("a", loop.next());     // a <b> c d e f         assertEquals("b", loop.next());     // a b <c> d e f         assertEquals("c", loop.next());     // a b c <d> e f         assertEquals("d", loop.next());     // a b c d <e> f         assertEquals("e", loop.next());     // a b c d e <f>         assertEquals("f", loop.next());     // <a> b c d e f         assertEquals("a", loop.next());     // a <b> c d e f          list = new ArrayList<>(Arrays.asList("b", "e", "f"));         loop = new LoopingListIterator<>(list); // <b> e f          loop.add("a");                      // a <b> e f         assertEquals("a", loop.previous()); // a b e <f>         loop.reset();                       // <a> b e f         assertEquals("f", loop.previous()); // a b e <f>         assertEquals("e", loop.previous()); // a b <e> f          loop.add("d");                      // a b d <e> f         assertEquals("d", loop.previous()); // a b <d> e f          loop.add("c");                      // a b c <d> e f         assertEquals("c", loop.previous()); // a b <c> d e f          loop.reset();         assertEquals("a", loop.next());     // a <b> c d e f         assertEquals("b", loop.next());     // a b <c> d e f         assertEquals("c", loop.next());     // a b c <d> e f         assertEquals("d", loop.next());     // a b c d <e> f         assertEquals("e", loop.next());     // a b c d e <f>         assertEquals("f", loop.next());     // <a> b c d e f         assertEquals("a", loop.next());     // a <b> c d e f     }      /**      * Tests nextIndex and previousIndex.      */     @Test     public void testNextAndPreviousIndex() {         final List<String> list = Arrays.asList("a", "b", "c");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c          assertEquals(0, loop.nextIndex());         assertEquals(2, loop.previousIndex());          assertEquals("a", loop.next());        // a <b> c         assertEquals(1, loop.nextIndex());         assertEquals(0, loop.previousIndex());          assertEquals("a", loop.previous());    // <a> b c         assertEquals(0, loop.nextIndex());         assertEquals(2, loop.previousIndex());          assertEquals("c", loop.previous());    // a b <c>         assertEquals(2, loop.nextIndex());         assertEquals(1, loop.previousIndex());          assertEquals("b", loop.previous());    // a <b> c         assertEquals(1, loop.nextIndex());         assertEquals(0, loop.previousIndex());          assertEquals("a", loop.previous());    // <a> b c         assertEquals(0, loop.nextIndex());         assertEquals(2, loop.previousIndex());     }      /**      * Tests using the set method to change elements.      */     @Test     public void testSet() {         final List<String> list = Arrays.asList("q", "r", "z");         final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <q> r z          assertEquals("z", loop.previous()); // q r <z>         loop.set("c");                      // q r <c>          loop.reset();                       // <q> r c         assertEquals("q", loop.next());     // q <r> c         loop.set("a");                      // a <r> c          assertEquals("r", loop.next());     // a r <c>         loop.set("b");                      // a b <c>          loop.reset();                       // <a> b c         assertEquals("a", loop.next());     // a <b> c         assertEquals("b", loop.next());     // a b <c>         assertEquals("c", loop.next());     // <a> b c     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Arrays; import java.util.ListIterator; import java.util.NoSuchElementException;  /**  * Test the ArrayListIterator class.  *  */ public class ArrayListIteratorTest<E> extends ArrayIteratorTest<E> {      public ArrayListIteratorTest(final String testName) {         super(testName);     }      @Override     public ArrayListIterator<E> makeEmptyIterator() {         return new ArrayListIterator<>(new Object[0]);     }      @Override     public ArrayListIterator<E> makeObject() {         return new ArrayListIterator<>(testArray);     }      public ArrayListIterator<E> makeArrayListIterator(final Object array) {         return new ArrayListIterator<>(array);     }      @Override     public boolean supportsRemove() {         return false;     }      /**      * Test the basic ListIterator functionality - going backwards using      * {@code previous()}.      */     public void testListIterator() {         final ListIterator<E> iter = makeObject();          // TestArrayIterator#testIterator() has already tested the iterator forward,         //  now we need to test it in reverse          // fast-forward the iterator to the end...         while (iter.hasNext()) {             iter.next();         }          for (int x = testArray.length - 1; x >= 0; x--) {             final Object testValue = testArray[x];             final Object iterValue = iter.previous();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasPrevious());          try {             iter.previous();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }      }      /**      * Tests the {@link java.util.ListIterator#set} operation.      */     @SuppressWarnings("unchecked")     public void testListIteratorSet() {         final String[] testData = new String[] { "a", "b", "c" };          final String[] result = new String[] { "0", "1", "2" };          ListIterator<E> iter = makeArrayListIterator(testData);         int x = 0;          while (iter.hasNext()) {             iter.next();             iter.set((E) Integer.toString(x));             x++;         }          assertTrue("The two arrays should have the same value, i.e. {0,1,2}", Arrays.equals(testData, result));          // a call to set() before a call to next() or previous() should throw an IllegalStateException         iter = makeArrayListIterator(testArray);          try {             iter.set((E) "should fail");             fail("ListIterator#set should fail if next() or previous() have not yet been called.");         } catch (final IllegalStateException e) {             // expected         } catch (final Throwable t) { // should never happen             fail(t.toString());         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.AbstractObjectTest;  /**  * Abstract class for testing the Iterator interface.  * <p>  * This class provides a framework for testing an implementation of Iterator.  * Concrete subclasses must provide the iterator to be tested.  * They must also specify certain details of how the iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractIteratorTest<E> extends AbstractObjectTest {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implement this method to return an iterator over an empty collection.      *      * @return an empty iterator      */     public abstract Iterator<E> makeEmptyIterator();      /**      * Implements the abstract superclass method to return the full iterator.      *      * @return a full iterator      */     @Override     public abstract Iterator<E> makeObject();      /**      * Whether or not we are testing an iterator that can be empty.      * Default is true.      *      * @return true if Iterator can be empty      */     public boolean supportsEmptyIterator() {         return true;     }      /**      * Whether or not we are testing an iterator that can contain elements.      * Default is true.      *      * @return true if Iterator can be full      */     public boolean supportsFullIterator() {         return true;     }      /**      * Whether or not we are testing an iterator that supports remove().      * Default is true.      *      * @return true if Iterator supports remove      */     public boolean supportsRemove() {         return true;     }      /**      * Allows subclasses to add complex cross verification      */     public void verify() {         // do nothing     }      //-----------------------------------------------------------------------     /**      * Test the empty iterator.      */     public void testEmptyIterator() {         if (!supportsEmptyIterator()) {             return;         }          final Iterator<E> it = makeEmptyIterator();          // hasNext() should return false         assertEquals("hasNext() should return false for empty iterators", false, it.hasNext());          // next() should throw a NoSuchElementException         try {             it.next();             fail("NoSuchElementException must be thrown when Iterator is exhausted");         } catch (final NoSuchElementException e) {         }         verify();          assertNotNull(it.toString());     }      /**      * Test normal iteration behavior.      */     public void testFullIterator() {         if (!supportsFullIterator()) {             return;         }          final Iterator<E> it = makeObject();          // hasNext() must be true (ensure makeFullIterator is correct!)         assertEquals("hasNext() should return true for at least one element", true, it.hasNext());          // next() must not throw exception (ensure makeFullIterator is correct!)         try {             it.next();         } catch (final NoSuchElementException e) {             fail("Full iterators must have at least one element");         }          // iterate through         while (it.hasNext()) {             it.next();             verify();         }          // next() must throw NoSuchElementException now         try {             it.next();             fail("NoSuchElementException must be thrown when Iterator is exhausted");         } catch (final NoSuchElementException e) {         }          assertNotNull(it.toString());     }      /**      * Test remove behavior.      */     public void testRemove() {         final Iterator<E> it = makeObject();          if (!supportsRemove()) {             // check for UnsupportedOperationException if not supported             try {                 it.remove();             } catch (final UnsupportedOperationException ex) {}             return;         }          // should throw IllegalStateException before next() called         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {}         verify();          // remove after next should be fine         it.next();         it.remove();          // should throw IllegalStateException for second remove()         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List;  import org.apache.commons.collections4.comparators.ComparableComparator;  /**  * Unit test suite for {@link CollatingIterator}.  *  */ @SuppressWarnings("boxing") public class CollatingIteratorTest extends AbstractIteratorTest<Integer> {      //------------------------------------------------------------ Conventional      public CollatingIteratorTest(final String testName) {         super(testName);     }      //--------------------------------------------------------------- Lifecycle      private Comparator<Integer> comparator = null;     private ArrayList<Integer> evens = null;     private ArrayList<Integer> odds = null;     private ArrayList<Integer> fib = null;      @Override     public void setUp() throws Exception {         super.setUp();         comparator = new ComparableComparator<>();         evens = new ArrayList<>();         odds = new ArrayList<>();         for (int i = 0; i < 20; i++) {             if (0 == i % 2) {                 evens.add(i);             } else {                 odds.add(i);             }         }         fib = new ArrayList<>();         fib.add(1);         fib.add(1);         fib.add(2);         fib.add(3);         fib.add(5);         fib.add(8);         fib.add(13);         fib.add(21);     }      //---------------------------------------------------- TestIterator Methods      @Override     public CollatingIterator<Integer> makeEmptyIterator() {         return new CollatingIterator<>(comparator);     }      @Override     public CollatingIterator<Integer> makeObject() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         iter.addIterator(odds.iterator());         iter.addIterator(fib.iterator());         return iter;     }      //------------------------------------------------------------------- Tests      public void testGetSetComparator() {         final CollatingIterator<Integer> iter = new CollatingIterator<>();         assertNull(iter.getComparator());         iter.setComparator(comparator);         assertSame(comparator, iter.getComparator());         iter.setComparator(null);         assertNull(iter.getComparator());     }      public void testIterateEven() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertEquals(0, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenOdd() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator, evens.iterator(), odds.iterator());         for (int i = 0; i < 20; i++) {             assertTrue(iter.hasNext());             assertEquals(Integer.valueOf(i), iter.next());             assertEquals(i % 2, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateOddEven() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator, odds.iterator(), evens.iterator());         for (int i = 0; i < 20; i++) {             assertTrue(iter.hasNext());             assertEquals(Integer.valueOf(i), iter.next());             assertEquals(i % 2 == 0 ? 1 : 0, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenEven() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         iter.addIterator(evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertEquals(0, iter.getIteratorIndex());             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertEquals(1, iter.getIteratorIndex());         }         assertTrue(!iter.hasNext());     }      public void testIterateFibEvenOdd() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(fib.iterator());         iter.addIterator(evens.iterator());         iter.addIterator(odds.iterator());          assertEquals(Integer.valueOf(0), iter.next());  // even   0         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(1), iter.next());  // odd    1         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(2), iter.next());  // fib    2         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(2), iter.next());  // even   2         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(3), iter.next());  // fib    3         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(3), iter.next());  // odd    3         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(4), iter.next());  // even   4         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(5), iter.next());  // fib    5         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(5), iter.next());  // odd    5         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(6), iter.next());  // even   6         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(7), iter.next());  // odd    7         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(8), iter.next());  // fib    8         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(8), iter.next());  // even   8         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(9), iter.next());  // odd    9         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(10), iter.next()); // even  10         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(11), iter.next()); // odd   11         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(12), iter.next()); // even  12         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(13), iter.next()); // fib   13         assertEquals(0, iter.getIteratorIndex());         assertEquals(Integer.valueOf(13), iter.next()); // odd   13         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(14), iter.next()); // even  14         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(15), iter.next()); // odd   15         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(16), iter.next()); // even  16         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(17), iter.next()); // odd   17         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(18), iter.next()); // even  18         assertEquals(1, iter.getIteratorIndex());         assertEquals(Integer.valueOf(19), iter.next()); // odd   19         assertEquals(2, iter.getIteratorIndex());         assertEquals(Integer.valueOf(21), iter.next()); // fib   21         assertEquals(0, iter.getIteratorIndex());          assertTrue(!iter.hasNext());     }      public void testRemoveFromSingle() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         int expectedSize = evens.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size());     }      public void testRemoveFromDouble() {         final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);         iter.addIterator(evens.iterator());         iter.addIterator(odds.iterator());         int expectedSize = evens.size() + odds.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size() + odds.size());     }      public void testNullComparator() {         final List<Integer> l1 = Arrays.asList(1, 3, 5);         final List<Integer> l2 = Arrays.asList(2, 4, 6);          final CollatingIterator<Integer> collatingIterator1 = new CollatingIterator<>(null, l1.iterator(), l2.iterator());         try {             collatingIterator1.next();         } catch (final NullPointerException e) {             assertTrue(e.getMessage().startsWith("You must invoke setComparator"));         }          int i = 0;         final CollatingIterator<Integer> collatingIterator2 = new CollatingIterator<>(null, l1.iterator(), l2.iterator());         collatingIterator2.setComparator(new ComparableComparator<Integer>());         for ( ; collatingIterator2.hasNext(); i++ ) {             final Integer n = collatingIterator2.next();             assertEquals("wrong order", (int) n, i + 1);         }         assertEquals("wrong size", i, l1.size() + l2.size());     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.ListIterator;  import org.apache.commons.collections4.Unmodifiable;  /**  * Tests the UnmodifiableListIterator.  *  */ public class UnmodifiableListIteratorTest<E> extends AbstractListIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };     protected List<E> testList;      public UnmodifiableListIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public ListIterator<E> makeEmptyIterator() {         return UnmodifiableListIterator.umodifiableListIterator(Collections.<E>emptyList().listIterator());     }      @Override     public ListIterator<E> makeObject() {         return UnmodifiableListIterator.umodifiableListIterator(testList.listIterator());     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsAdd() {         return false;     }      @Override     public boolean supportsSet() {         return false;     }      //-----------------------------------------------------------------------     public void testListIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         ListIterator<E> it = makeObject();         assertSame(it, UnmodifiableListIterator.umodifiableListIterator(it));          it = testList.listIterator();         assertTrue(it != UnmodifiableListIterator.umodifiableListIterator(it));          try {             UnmodifiableListIterator.umodifiableListIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.ListIterator; import java.util.Random;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.PredicateUtils; import org.apache.commons.collections4.list.GrowthList; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * Tests the FilterListIterator class.  *  */ @SuppressWarnings("boxing") public class FilterListIteratorTest {      private ArrayList<Integer> list = null;     private ArrayList<Integer> odds = null;     private ArrayList<Integer> evens = null;     private ArrayList<Integer> threes = null;     private ArrayList<Integer> fours = null;     private ArrayList<Integer> sixes = null;     private Predicate<Integer> truePred = null;     private Predicate<Integer> falsePred = null;     private Predicate<Integer> evenPred = null;     private Predicate<Integer> oddPred = null;     private Predicate<Integer> threePred = null;     private Predicate<Integer> fourPred = null;     private final Random random = new Random();      @Before     public void setUp() {         list = new ArrayList<>();         odds = new ArrayList<>();         evens = new ArrayList<>();         threes = new ArrayList<>();         fours = new ArrayList<>();         sixes = new ArrayList<>();         for (int i = 0; i < 20; i++) {             list.add(Integer.valueOf(i));             if (i % 2 == 0) {                 evens.add(Integer.valueOf(i));             }             if (i % 2 != 0) {                 odds.add(Integer.valueOf(i));             }             if (i % 3 == 0) {                 threes.add(Integer.valueOf(i));             }             if (i % 4 == 0) {                 fours.add(Integer.valueOf(i));             }             if (i % 6 == 0) {                 sixes.add(Integer.valueOf(i));             }         }          truePred = x -> true;          falsePred = x -> true;          evenPred = x -> x % 2 == 0;          oddPred = x -> x % 2 != 0;          threePred = x -> x % 3 == 0;          fourPred = x -> x % 4 == 0;      }      @After     public void tearDown() throws Exception {         list = null;         odds = null;         evens = null;         threes = null;         fours = null;         sixes = null;         truePred = null;         falsePred = null;         evenPred = null;         oddPred = null;         threePred = null;         fourPred = null;     }      @Test     public void testWalkLists() {         // this just confirms that our walkLists method works OK         walkLists(list, list.listIterator());     }      @Test     public void testManual() {         // do this one "by hand" as a sanity check         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);          assertEquals(Integer.valueOf(0), filtered.next());         assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());         assertEquals(Integer.valueOf(9), filtered.next());         assertEquals(Integer.valueOf(12), filtered.next());         assertEquals(Integer.valueOf(15), filtered.next());         assertEquals(Integer.valueOf(18), filtered.next());          assertEquals(Integer.valueOf(18), filtered.previous());         assertEquals(Integer.valueOf(15), filtered.previous());         assertEquals(Integer.valueOf(12), filtered.previous());         assertEquals(Integer.valueOf(9), filtered.previous());         assertEquals(Integer.valueOf(6), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.previous());         assertEquals(Integer.valueOf(0), filtered.previous());          assertTrue(!filtered.hasPrevious());          assertEquals(Integer.valueOf(0), filtered.next());         assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());         assertEquals(Integer.valueOf(9), filtered.next());         assertEquals(Integer.valueOf(12), filtered.next());         assertEquals(Integer.valueOf(15), filtered.next());         assertEquals(Integer.valueOf(18), filtered.next());          assertTrue(!filtered.hasNext());          assertEquals(Integer.valueOf(18), filtered.previous());         assertEquals(Integer.valueOf(15), filtered.previous());         assertEquals(Integer.valueOf(12), filtered.previous());         assertEquals(Integer.valueOf(9), filtered.previous());         assertEquals(Integer.valueOf(6), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.previous());         assertEquals(Integer.valueOf(0), filtered.previous());          assertEquals(Integer.valueOf(0), filtered.next());         assertEquals(Integer.valueOf(0), filtered.previous());         assertEquals(Integer.valueOf(0), filtered.next());          assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());         assertEquals(Integer.valueOf(6), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.previous());         assertEquals(Integer.valueOf(3), filtered.next());         assertEquals(Integer.valueOf(6), filtered.next());          assertEquals(Integer.valueOf(9), filtered.next());         assertEquals(Integer.valueOf(12), filtered.next());         assertEquals(Integer.valueOf(15), filtered.next());         assertEquals(Integer.valueOf(15), filtered.previous());         assertEquals(Integer.valueOf(12), filtered.previous());         assertEquals(Integer.valueOf(9), filtered.previous());     }      @Test     public void testTruePredicate() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);         walkLists(list, filtered);     }      @Test     public void testFalsePredicate() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), falsePred);         walkLists(new ArrayList<Integer>(), filtered);     }      @Test     public void testEvens() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), evenPred);         walkLists(evens, filtered);     }      @Test     public void testOdds() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), oddPred);         walkLists(odds, filtered);     }      @Test     public void testThrees() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);         walkLists(threes, filtered);     }      @Test     public void testFours() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);         walkLists(fours, filtered);     }      @Test     public void testNestedSixes() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(                                         new FilterListIterator<>(list.listIterator(), threePred),                                         evenPred                                       );         walkLists(sixes, filtered);     }      @Test     public void testNestedSixes2() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(                                         new FilterListIterator<>(list.listIterator(), evenPred),                                         threePred                                       );         walkLists(sixes, filtered);     }      @Test     public void testNestedSixes3() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(                                         new FilterListIterator<>(list.listIterator(), threePred),                                         evenPred                                       );         walkLists(sixes, new FilterListIterator<>(filtered, truePred));     }      @Test     public void testNextChangesPrevious() {         {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);             nextNextPrevious(threes.listIterator(), filtered);         }          {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);             nextNextPrevious(list.listIterator(), filtered);         }     }      @Test     public void testPreviousChangesNext() {         {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);             final ListIterator<Integer> expected = threes.listIterator();             walkForward(expected, filtered);             previousPreviousNext(expected, filtered);         }         {             final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);             final ListIterator<Integer> expected = list.listIterator();             walkForward(expected, filtered);             previousPreviousNext(expected, filtered);         }     }      @Test     public void testFailingHasNextBug() {         final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);         final ListIterator<Integer> expected = fours.listIterator();         while (expected.hasNext()) {             expected.next();             filtered.next();         }         assertTrue(filtered.hasPrevious());         assertTrue(!filtered.hasNext());         assertEquals(expected.previous(), filtered.previous());     }      /**      * Test for {@link "https://issues.apache.org/jira/browse/COLLECTIONS-360 COLLECTIONS-360"}      */     @Test     public void testCollections360() throws Throwable {         final Collection<Predicate<Object>> var7 = new GrowthList<>();         final Predicate<Object> var9 = PredicateUtils.anyPredicate(var7);         final FilterListIterator<Object> var13 = new FilterListIterator<>(var9);         Assert.assertFalse(var13.hasNext());         final FilterListIterator<Object> var14 = new FilterListIterator<>(var9);         Assert.assertFalse(var14.hasPrevious());     }      // Utilities      private void walkForward(final ListIterator<?> expected, final ListIterator<?> testing) {         while (expected.hasNext()) {             assertEquals(expected.nextIndex(), testing.nextIndex());             assertEquals(expected.previousIndex(), testing.previousIndex());             assertTrue(testing.hasNext());             assertEquals(expected.next(), testing.next());         }     }      private void walkBackward(final ListIterator<?> expected, final ListIterator<?> testing) {         while (expected.hasPrevious()) {             assertEquals(expected.nextIndex(), testing.nextIndex());             assertEquals(expected.previousIndex(), testing.previousIndex());             assertTrue(testing.hasPrevious());             assertEquals(expected.previous(), testing.previous());         }     }      private void nextNextPrevious(final ListIterator<?> expected, final ListIterator<?> testing) {         // calls to next() should change the value returned by previous()         // even after previous() has been set by a call to hasPrevious()         assertEquals(expected.next(), testing.next());         assertEquals(expected.hasPrevious(), testing.hasPrevious());         final Object expecteda = expected.next();         final Object testinga = testing.next();         assertEquals(expecteda, testinga);         final Object expectedb = expected.previous();         final Object testingb = testing.previous();         assertEquals(expecteda, expectedb);         assertEquals(testinga, testingb);     }      private void previousPreviousNext(final ListIterator<?> expected, final ListIterator<?> testing) {         // calls to previous() should change the value returned by next()         // even after next() has been set by a call to hasNext()         assertEquals(expected.previous(), testing.previous());         assertEquals(expected.hasNext(), testing.hasNext());         final Object expecteda = expected.previous();         final Object testinga = testing.previous();         assertEquals(expecteda, testinga);         final Object expectedb = expected.next();         final Object testingb = testing.next();         assertEquals(expecteda, testingb);         assertEquals(expecteda, expectedb);         assertEquals(testinga, testingb);     }      private <E> void walkLists(final List<E> list, final ListIterator<E> testing) {         final ListIterator<E> expected = list.listIterator();          // walk all the way forward         walkForward(expected, testing);          // walk all the way back         walkBackward(expected, testing);          // forward,back,forward         while (expected.hasNext()) {             assertEquals(expected.nextIndex(), testing.nextIndex());             assertEquals(expected.previousIndex(), testing.previousIndex());             assertTrue(testing.hasNext());             assertEquals(expected.next(), testing.next());             assertTrue(testing.hasPrevious());             assertEquals(expected.previous(), testing.previous());             assertTrue(testing.hasNext());             assertEquals(expected.next(), testing.next());         }          // walk all the way back         walkBackward(expected, testing);          for (int i = 0; i < list.size(); i++) {             // walk forward i             for (int j = 0; j < i; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasNext());                 assertEquals(expected.next(), testing.next());             }             // walk back i/2             for (int j = 0; j < i / 2; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasPrevious());                 assertEquals(expected.previous(), testing.previous());             }             // walk forward i/2             for (int j = 0; j < i / 2; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasNext());                 assertEquals(expected.next(), testing.next());             }             // walk back i             for (int j = 0; j < i; j++) {                 assertEquals(expected.nextIndex(), testing.nextIndex());                 assertEquals(expected.previousIndex(), testing.previousIndex());                 assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test                 assertTrue(testing.hasPrevious());                 assertEquals(expected.previous(), testing.previous());             }         }          // random walk         final StringBuilder walkdescr = new StringBuilder(500);         for (int i = 0; i < 500; i++) {             if (random.nextBoolean()) {                 // step forward                 walkdescr.append("+");                 if (expected.hasNext()) {                     assertEquals(walkdescr.toString(), expected.next(), testing.next());                 }             } else {                 // step backward                 walkdescr.append("-");                 if (expected.hasPrevious()) {                     assertEquals(walkdescr.toString(), expected.previous(), testing.previous());                 }             }             assertEquals(walkdescr.toString(), expected.nextIndex(), testing.nextIndex());             assertEquals(walkdescr.toString(), expected.previousIndex(), testing.previousIndex());         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  /**  * Tests the ArrayIterator to ensure that the next() method will actually  * perform the iteration rather than the hasNext() method.  * The code of this test was supplied by Mauricio S. Moura.  *  */ public class ArrayIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };      public ArrayIteratorTest(final String testName) {         super(testName);     }      @Override     public ArrayIterator<E> makeEmptyIterator() {         return new ArrayIterator<>(new Object[0]);     }      @Override     public ArrayIterator<E> makeObject() {         return new ArrayIterator<>(testArray);     }      @Override     public boolean supportsRemove() {         return false;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final String testValue : testArray) {             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testNullArray() {         try {             new ArrayIterator<>(null);             fail("Constructor should throw a NullPointerException when constructed with a null array");         } catch (final NullPointerException e) {             // expected         }     }      public void testReset() {         final ArrayIterator<E> it = makeObject();         it.next();         it.reset();         assertEquals("One", it.next());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List;  import org.apache.commons.collections4.Unmodifiable;  /**  * Tests the UnmodifiableIterator.  *  */ public class UnmodifiableIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };     protected List<E> testList;      public UnmodifiableIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public Iterator<E> makeEmptyIterator() {         return UnmodifiableIterator.unmodifiableIterator(Collections.<E>emptyList().iterator());     }      @Override     public Iterator<E> makeObject() {         return UnmodifiableIterator.unmodifiableIterator(testList.iterator());     }      @Override     public boolean supportsRemove() {         return false;     }      //-----------------------------------------------------------------------     public void testIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         Iterator<E> it = makeObject();         assertSame(it, UnmodifiableIterator.unmodifiableIterator(it));          it = testList.iterator();         assertTrue(it != UnmodifiableIterator.unmodifiableIterator(it));          try {             UnmodifiableIterator.unmodifiableIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  /**  * A unit test to test the basic functions of {@link SkippingIterator}.  *  */ public class SkippingIteratorTest<E> extends AbstractIteratorTest<E> {      /** Test array of size 7 */     private final String[] testArray = {         "a", "b", "c", "d", "e", "f", "g"     };      private List<E> testList;      public SkippingIteratorTest(final String testName) {         super(testName);     }      @SuppressWarnings("unchecked")     @Override     public void setUp()         throws Exception {         super.setUp();         testList = Arrays.asList((E[]) testArray);     }      @Override     public Iterator<E> makeEmptyIterator() {         return new SkippingIterator<>(Collections.<E>emptyList().iterator(), 0);     }      @Override     public Iterator<E> makeObject() {         return new SkippingIterator<>(new ArrayList<>(testList).iterator(), 1);     }      // ---------------- Tests ---------------------      /**      * Test a decorated iterator bounded such that the first element returned is      * at an index greater its first element, and the last element returned is      * at an index less than its last element.      */     @Test     public void testSkipping() {         final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 2);          assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test a decorated iterator bounded such that the {@code offset} is      * zero, in that the SkippingIterator should return all the same elements      * as its decorated iterator.      */     @Test     public void testSameAsDecorated() {         final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 0);          assertTrue(iter.hasNext());         assertEquals("a", iter.next());         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the {@code offset} passed to the constructor is      * greater than the decorated iterator's size. The SkippingIterator should      * behave as if there are no more elements to return.      */     @Test     public void testOffsetGreaterThanSize() {         final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 10);         assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if a negative {@code offset} is passed to the      * constructor. {@link IllegalArgumentException} is expected.      */     @Test     public void testNegativeOffset() {         try {             new SkippingIterator<>(testList.iterator(), -1);             fail("Expected IllegalArgumentException.");         } catch (final IllegalArgumentException iae) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called without      * {@code next()} being called first.      */     @Test     public void testRemoveWithoutCallingNext() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 1);          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called twice without calling      * {@code next()} in between.      */     @Test     public void testRemoveCalledTwice() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 1);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         iter.remove();          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test removing the first element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveFirst() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 4);          assertTrue(iter.hasNext());         assertEquals("e", iter.next());          iter.remove();         assertFalse(testListCopy.contains("e"));          assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing an element in the middle of the iterator. Verify that the      * element is removed from the underlying collection.      */     @Test     public void testRemoveMiddle() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 3);          assertTrue(iter.hasNext());         assertEquals("d", iter.next());          iter.remove();         assertFalse(testListCopy.contains("d"));          assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing the last element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveLast() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 5);          assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }          iter.remove();         assertFalse(testListCopy.contains("g"));          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the decorated iterator does not support the      * {@code remove()} method and throws an {@link UnsupportedOperationException}.      */     @Test     public void testRemoveUnsupported() {         final Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {             @Override             public void remove() {                 throw new UnsupportedOperationException();             }         };          final Iterator<E> iter = new SkippingIterator<>(mockIterator, 1);         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         try {             iter.remove();             fail("Expected UnsupportedOperationException.");         } catch (final UnsupportedOperationException usoe) { /* Success case */         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList;  import org.apache.commons.collections4.IteratorUtils;  /**  * Unit test suite for {@link ZippingIterator}.  *  */ @SuppressWarnings("boxing") public class ZippingIteratorTest extends AbstractIteratorTest<Integer> {      //------------------------------------------------------------ Conventional      public ZippingIteratorTest(final String testName) {         super(testName);     }      //--------------------------------------------------------------- Lifecycle      private ArrayList<Integer> evens = null;     private ArrayList<Integer> odds = null;     private ArrayList<Integer> fib = null;      @Override     public void setUp() throws Exception {         super.setUp();         evens = new ArrayList<>();         odds = new ArrayList<>();         for (int i = 0; i < 20; i++) {             if (0 == i % 2) {                 evens.add(i);             } else {                 odds.add(i);             }         }         fib = new ArrayList<>();         fib.add(1);         fib.add(1);         fib.add(2);         fib.add(3);         fib.add(5);         fib.add(8);         fib.add(13);         fib.add(21);     }      //---------------------------------------------------- TestIterator Methods      @Override     @SuppressWarnings("unchecked")     public ZippingIterator<Integer> makeEmptyIterator() {         return new ZippingIterator<>(IteratorUtils.<Integer>emptyIterator());     }      @Override     public ZippingIterator<Integer> makeObject() {         return new ZippingIterator<>(evens.iterator(), odds.iterator(), fib.iterator());     }      //------------------------------------------------------------------- Tests      public void testIterateEven() {         @SuppressWarnings("unchecked")         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenOdd() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), odds.iterator());         for (int i = 0; i < 20; i++) {             assertTrue(iter.hasNext());             assertEquals(Integer.valueOf(i), iter.next());         }         assertTrue(!iter.hasNext());     }      public void testIterateOddEven() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(odds.iterator(), evens.iterator());         for (int i = 0, j = 0; i < 20; i++) {             assertTrue(iter.hasNext());             final int val = iter.next();             if (i % 2 == 0) {                 assertEquals(odds.get(j).intValue(), val);             } else {                 assertEquals(evens.get(j).intValue(), val);                 j++;             }         }         assertTrue(!iter.hasNext());     }      public void testIterateEvenEven() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), evens.iterator());         for (final Integer even : evens) {             assertTrue(iter.hasNext());             assertEquals(even, iter.next());             assertTrue(iter.hasNext());             assertEquals(even, iter.next());         }         assertTrue(!iter.hasNext());     }      public void testIterateFibEvenOdd() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(fib.iterator(), evens.iterator(), odds.iterator());          assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(Integer.valueOf(0), iter.next());  // even   0         assertEquals(Integer.valueOf(1), iter.next());  // odd    1         assertEquals(Integer.valueOf(1), iter.next());  // fib    1         assertEquals(Integer.valueOf(2), iter.next());  // even   2         assertEquals(Integer.valueOf(3), iter.next());  // odd    3         assertEquals(Integer.valueOf(2), iter.next());  // fib    2         assertEquals(Integer.valueOf(4), iter.next());  // even   4         assertEquals(Integer.valueOf(5), iter.next());  // odd    5         assertEquals(Integer.valueOf(3), iter.next());  // fib    3         assertEquals(Integer.valueOf(6), iter.next());  // even   6         assertEquals(Integer.valueOf(7), iter.next());  // odd    7         assertEquals(Integer.valueOf(5), iter.next());  // fib    5         assertEquals(Integer.valueOf(8), iter.next());  // even   8         assertEquals(Integer.valueOf(9), iter.next());  // odd    9         assertEquals(Integer.valueOf(8), iter.next());  // fib    8         assertEquals(Integer.valueOf(10), iter.next()); // even  10         assertEquals(Integer.valueOf(11), iter.next()); // odd   11         assertEquals(Integer.valueOf(13), iter.next()); // fib   13         assertEquals(Integer.valueOf(12), iter.next()); // even  12         assertEquals(Integer.valueOf(13), iter.next()); // odd   13         assertEquals(Integer.valueOf(21), iter.next()); // fib   21         assertEquals(Integer.valueOf(14), iter.next()); // even  14         assertEquals(Integer.valueOf(15), iter.next()); // odd   15         assertEquals(Integer.valueOf(16), iter.next()); // even  16         assertEquals(Integer.valueOf(17), iter.next()); // odd   17         assertEquals(Integer.valueOf(18), iter.next()); // even  18         assertEquals(Integer.valueOf(19), iter.next()); // odd   19          assertTrue(!iter.hasNext());     }      public void testRemoveFromSingle() {         @SuppressWarnings("unchecked")         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator());         int expectedSize = evens.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size());     }      public void testRemoveFromDouble() {         final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), odds.iterator());         int expectedSize = evens.size() + odds.size();         while (iter.hasNext()) {             final Object o = iter.next();             final Integer val = (Integer) o;             if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {                 expectedSize--;                 iter.remove();             }         }         assertEquals(expectedSize, evens.size() + odds.size());     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the ListIteratorWrapper to insure that it simulates  * a ListIterator correctly.  *  */ public class ListIteratorWrapperTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<E> list1 = null;      public ListIteratorWrapperTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public void setUp() {         list1 = new ArrayList<>();         list1.add((E) "One");         list1.add((E) "Two");         list1.add((E) "Three");         list1.add((E) "Four");         list1.add((E) "Five");         list1.add((E) "Six");     }      @Override     public ResettableListIterator<E> makeEmptyIterator() {         final ArrayList<E> list = new ArrayList<>();         return new ListIteratorWrapper<>(list.iterator());     }      @Override     public ResettableListIterator<E> makeObject() {         return new ListIteratorWrapper<>(list1.iterator());     }      public void testIterator() {         final ListIterator<E> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it backwards         for (int i = testArray.length - 1; i > -1; --i) {             final Object testValue = testArray[i];             final E iterValue = iter.previous();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          try {             iter.previous();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it forwards again         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }      }      @Override     public void testRemove() {         final ListIterator<E> iter = makeObject();          //initial state:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be initially positioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //establish size:         int sz = list1.size();          //verify initial next() call:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //verify remove():         iter.remove();         assertEquals(--sz, list1.size());         //like we never started iterating:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be repositioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //two consecutive next() calls:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());          //call previous():         assertEquals(list1.get(1), iter.previous());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //dig into cache         assertEquals(list1.get(0), iter.previous());         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper does not support the remove() method while dug into the cache via previous()");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //dig out of cache, first next() maintains current position:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());         //continue traversing underlying iterator with this next() call, and we're out of the hole, so to speak:         assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());          //verify remove() works again:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());      }      public void testReset() {         final ResettableListIterator<E> iter = makeObject();         final E first = iter.next();         final E second = iter.next();          iter.reset();          // after reset, there shouldn't be any previous elements         assertFalse("No previous elements after reset()", iter.hasPrevious());          // after reset, the results should be the same as before         assertEquals("First element should be the same", first, iter.next());         assertEquals("Second element should be the same", second, iter.next());          // after passing the point, where we resetted, continuation should work as expected         for (int i = 2; i < testArray.length; i++) {             final Object testValue = testArray[i];             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Arrays; import java.util.Iterator; import java.util.NoSuchElementException;  import org.junit.Test; import static org.junit.Assert.*;  /**  * Tests the IteratorEnumeration.  *  */ public class IteratorEnumerationTest {      @Test     public void testEnumeration() {         final Iterator<String> iterator = Arrays.asList("a", "b", "c").iterator();         final IteratorEnumeration<String> enumeration = new IteratorEnumeration<>(iterator);          assertEquals(iterator, enumeration.getIterator());          assertTrue(enumeration.hasMoreElements());         assertEquals("a", enumeration.nextElement());         assertEquals("b", enumeration.nextElement());         assertEquals("c", enumeration.nextElement());         assertFalse(enumeration.hasMoreElements());          try {             enumeration.nextElement();             fail("NoSuchElementException expected");         } catch (final NoSuchElementException e) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  /**  * Tests the ObjectArrayListIterator class.  *  */ public class ObjectArrayListIterator2Test<E> extends AbstractListIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three" };      public ObjectArrayListIterator2Test(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeEmptyIterator() {         return new ObjectArrayListIterator<>((E[]) new Object[0]);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeObject() {         return new ObjectArrayListIterator<>((E[]) testArray);     }      public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {         return new ObjectArrayListIterator<>(array);     }      @Override     public boolean supportsAdd() {         return false;     }      @Override     public boolean supportsRemove() {         return false;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the SingletonListIterator.  *  */ public class SingletonListIteratorTest<E> extends AbstractListIteratorTest<E> {      private static final Object testValue = "foo";      public SingletonListIteratorTest(final String testName) {         super(testName);     }      /**      * Returns a SingletonListIterator from which      * the element has already been removed.      */     @Override     public SingletonListIterator<E> makeEmptyIterator() {         final SingletonListIterator<E> iter = makeObject();         iter.next();         iter.remove();         iter.reset();         return iter;     }      @Override     @SuppressWarnings("unchecked")     public SingletonListIterator<E> makeObject() {         return new SingletonListIterator<>((E) testValue);     }      @Override     public boolean supportsAdd() {         return false;     }      @Override     public boolean supportsRemove() {         return true;     }      @Override     public boolean supportsEmptyIterator() {         return true;     }      public void testIterator() {         final ListIterator<E> iter = makeObject();         assertTrue( "Iterator should have next item", iter.hasNext() );         assertTrue( "Iterator should have no previous item", !iter.hasPrevious() );         assertEquals( "Iteration next index", 0, iter.nextIndex() );         assertEquals( "Iteration previous index", -1, iter.previousIndex() );          Object iterValue = iter.next();         assertEquals( "Iteration value is correct", testValue, iterValue );          assertTrue( "Iterator should have no next item", !iter.hasNext() );         assertTrue( "Iterator should have previous item", iter.hasPrevious() );         assertEquals( "Iteration next index", 1, iter.nextIndex() );         assertEquals( "Iteration previous index", 0, iter.previousIndex() );          iterValue = iter.previous();         assertEquals( "Iteration value is correct", testValue, iterValue );          assertTrue( "Iterator should have next item", iter.hasNext() );         assertTrue( "Iterator should have no previous item", !iter.hasPrevious() );         assertEquals( "Iteration next index", 0, iter.nextIndex() );         assertEquals( "Iteration previous index", -1, iter.previousIndex() );          iterValue = iter.next();         assertEquals( "Iteration value is correct", testValue, iterValue );          assertTrue( "Iterator should have no next item", !iter.hasNext() );         assertTrue( "Iterator should have previous item", iter.hasPrevious() );         assertEquals( "Iteration next index", 1, iter.nextIndex() );         assertEquals( "Iteration previous index", 0, iter.previousIndex() );          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }         iter.previous();         try {             iter.previous();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testReset() {         final ResettableListIterator<E> it = makeObject();          assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());          it.reset();          assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         assertEquals(testValue, it.next());         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());          it.reset();         it.reset();          assertEquals(true, it.hasNext());     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  /**  * Tests the UniqueFilterIterator class.  *  */ public class UniqueFilterIteratorTest<E> extends AbstractIteratorTest<E> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<E> list1 = null;      public UniqueFilterIteratorTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public void setUp() {         list1 = new ArrayList<>();         list1.add((E) "One");         list1.add((E) "Two");         list1.add((E) "Three");         list1.add((E) "Two");         list1.add((E) "One");         list1.add((E) "Four");         list1.add((E) "Five");         list1.add((E) "Five");         list1.add((E) "Six");         list1.add((E) "Five");     }      @Override     public UniqueFilterIterator<E> makeEmptyIterator() {         final ArrayList<E> list = new ArrayList<>();         return new UniqueFilterIterator<>(list.iterator());     }      @Override     public UniqueFilterIterator<E> makeObject() {         final Iterator<E> i = list1.iterator();         return new UniqueFilterIterator<>(i);     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final String testValue : testArray) {             final E iterValue = iter.next();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          assertTrue("Iterator should now be empty", ! iter.hasNext() );          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  /**  * A unit test to test the basic functions of {@link BoundedIterator}.  *  */ public class BoundedIteratorTest<E> extends AbstractIteratorTest<E> {      /** Test array of size 7 */     private final String[] testArray = {         "a", "b", "c", "d", "e", "f", "g"     };      private List<E> testList;      public BoundedIteratorTest(final String testName) {         super(testName);     }      @SuppressWarnings("unchecked")     @Override     public void setUp()         throws Exception {         super.setUp();         testList = Arrays.asList((E[]) testArray);     }      @Override     public Iterator<E> makeEmptyIterator() {         return new BoundedIterator<>(Collections.<E>emptyList().iterator(), 0, 10);     }      @Override     public Iterator<E> makeObject() {         return new BoundedIterator<>(new ArrayList<>(testList).iterator(), 1, testList.size() - 1);     }      // ---------------- Tests ---------------------      /**      * Test a decorated iterator bounded such that the first element returned is      * at an index greater its first element, and the last element returned is      * at an index less than its last element.      */     @Test     public void testBounded() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 2, 4);          assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test a decorated iterator bounded such that the {@code offset} is      * zero and the {@code max} is its size, in that the BoundedIterator      * should return all the same elements as its decorated iterator.      */     @Test     public void testSameAsDecorated() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 0,                                                   testList.size());          assertTrue(iter.hasNext());         assertEquals("a", iter.next());         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test a decorated iterator bounded to a {@code max} of 0. The      * BoundedIterator should behave as if there are no more elements to return,      * since it is technically an empty iterator.      */     @Test     public void testEmptyBounded() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 3, 0);         assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if a negative {@code offset} is passed to the      * constructor. {@link IllegalArgumentException} is expected.      */     @Test     public void testNegativeOffset() {         try {             new BoundedIterator<>(testList.iterator(), -1, 4);             fail("Expected IllegalArgumentException.");         } catch (final IllegalArgumentException iae) { /* Success case */         }     }      /**      * Test the case if a negative {@code max} is passed to the      * constructor. {@link IllegalArgumentException} is expected.      */     @Test     public void testNegativeMax() {         try {             new BoundedIterator<>(testList.iterator(), 3, -1);             fail("Expected IllegalArgumentException.");         } catch (final IllegalArgumentException iae) { /* Success case */         }     }      /**      * Test the case if the {@code offset} passed to the constructor is      * greater than the decorated iterator's size. The BoundedIterator should      * behave as if there are no more elements to return.      */     @Test     public void testOffsetGreaterThanSize() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 10, 4);         assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the {@code max} passed to the constructor is      * greater than the size of the decorated iterator. The last element      * returned should be the same as the last element of the decorated      * iterator.      */     @Test     public void testMaxGreaterThanSize() {         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 1, 10);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());         assertTrue(iter.hasNext());         assertEquals("g", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called without      * {@code next()} being called first.      */     @Test     public void testRemoveWithoutCallingNext() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test the {@code remove()} method being called twice without calling      * {@code next()} in between.      */     @Test     public void testRemoveCalledTwice() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         iter.remove();          try {             iter.remove();             fail("Expected IllegalStateException.");         } catch (final IllegalStateException ise) { /* Success case */         }     }      /**      * Test removing the first element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveFirst() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());          iter.remove();         assertFalse(testListCopy.contains("b"));          assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing an element in the middle of the iterator. Verify that the      * element is removed from the underlying collection.      */     @Test     public void testRemoveMiddle() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());          iter.remove();         assertFalse(testListCopy.contains("d"));          assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test removing the last element. Verify that the element is removed from      * the underlying collection.      */     @Test     public void testRemoveLast() {         final List<E> testListCopy = new ArrayList<>(testList);         final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);          assertTrue(iter.hasNext());         assertEquals("b", iter.next());         assertTrue(iter.hasNext());         assertEquals("c", iter.next());         assertTrue(iter.hasNext());         assertEquals("d", iter.next());         assertTrue(iter.hasNext());         assertEquals("e", iter.next());         assertTrue(iter.hasNext());         assertEquals("f", iter.next());          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }          iter.remove();         assertFalse(testListCopy.contains("f"));          assertFalse(iter.hasNext());         try {             iter.next();             fail("Expected NoSuchElementException.");         } catch (final NoSuchElementException nsee) { /* Success case */         }     }      /**      * Test the case if the decorated iterator does not support the      * {@code remove()} method and throws an {@link UnsupportedOperationException}.      */     @Test     public void testRemoveUnsupported() {         final Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {             @Override             public void remove() {                 throw new UnsupportedOperationException();             }         };          final Iterator<E> iter = new BoundedIterator<>(mockIterator, 1, 5);         assertTrue(iter.hasNext());         assertEquals("b", iter.next());         try {             iter.remove();             fail("Expected UnsupportedOperationException.");         } catch (final UnsupportedOperationException usoe) { /* Success case */         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import static org.apache.commons.collections4.functors.TruePredicate.truePredicate;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.NotNullPredicate;  /**  * Test the filter iterator.  *  */ public class FilterIteratorTest<E> extends AbstractIteratorTest<E> {      /** Creates new TestFilterIterator */     public FilterIteratorTest(final String name) {         super(name);     }      private String[] array;     private List<E> list;     private FilterIterator<E> iterator;      /**      * Set up instance variables required by this test case.      */     @Override     public void setUp() {         array = new String[] { "a", "b", "c" };         initIterator();     }      /**      * Tear down instance variables required by this test case.      */     @Override     public void tearDown() throws Exception {         iterator = null;     }      /**      * Returns an full iterator wrapped in a      * FilterIterator that blocks all the elements      *      * @return "empty" FilterIterator      */     @Override     public FilterIterator<E> makeEmptyIterator() {         return makeBlockAllFilter(new ArrayIterator<E>(array));     }      /**      * Returns an array with elements wrapped in a pass-through      * FilterIterator      *      * @return a filtered iterator      */     @Override     @SuppressWarnings("unchecked")     public FilterIterator<E> makeObject() {         list = new ArrayList<>(Arrays.asList((E[]) array));         return makePassThroughFilter(list.iterator());     }      public void testRepeatedHasNext() {         for (int i = 0; i <= array.length; i++) {             assertTrue(iterator.hasNext());         }     }      @SuppressWarnings("unused")     public void testRepeatedNext() {         for (final String element : array) {             iterator.next();         }         verifyNoMoreElements();     }      public void testReturnValues() {         verifyElementsInPredicate(new String[0]);         verifyElementsInPredicate(new String[] { "a" });         verifyElementsInPredicate(new String[] { "b" });         verifyElementsInPredicate(new String[] { "c" });         verifyElementsInPredicate(new String[] { "a", "b" });         verifyElementsInPredicate(new String[] { "a", "c" });         verifyElementsInPredicate(new String[] { "b", "c" });         verifyElementsInPredicate(new String[] { "a", "b", "c" });     }      /**      * Test that when the iterator is changed, the hasNext method returns the      * correct response for the new iterator.      */     @SuppressWarnings("unchecked")     public void testSetIterator() {         final Iterator<E> iter1 = Collections.singleton((E) new Object()).iterator();         final Iterator<E> iter2 = Collections.<E>emptyList().iterator();          final FilterIterator<E> filterIterator = new FilterIterator<>(iter1);         filterIterator.setPredicate(truePredicate());         // this iterator has elements         assertEquals(true, filterIterator.hasNext());          // this iterator has no elements         filterIterator.setIterator(iter2);         assertEquals(false, filterIterator.hasNext());     }      /**      * Test that when the predicate is changed, the hasNext method returns the      * correct response for the new predicate.      */     public void testSetPredicate() {         final Iterator<E> iter = Collections.singleton((E) null).iterator();          final FilterIterator<E> filterIterator = new FilterIterator<>(iter);         filterIterator.setPredicate(truePredicate());         // this predicate matches         assertEquals(true, filterIterator.hasNext());          // this predicate doesn't match         filterIterator.setPredicate(NotNullPredicate.notNullPredicate());         assertEquals(false, filterIterator.hasNext());     }      private void verifyNoMoreElements() {         assertTrue(!iterator.hasNext());         try {             iterator.next();             fail("NoSuchElementException expected");         } catch (final NoSuchElementException e) {             // success         }     }      private void verifyElementsInPredicate(final String[] elements) {         final Predicate<E> pred = x -> {             for (final String element : elements) {                 if (element.equals(x)) {                     return true;                 }             }             return false;         };         initIterator();         iterator.setPredicate(pred);         for (int i = 0; i < elements.length; i++) {             final String s = (String) iterator.next();             assertEquals(elements[i], s);             assertTrue(i == elements.length - 1 ? !iterator.hasNext() : iterator.hasNext());         }         verifyNoMoreElements();          // test removal         initIterator();         iterator.setPredicate(pred);         if (iterator.hasNext()) {             final Object last = iterator.next();             iterator.remove();             assertTrue("Base of FilterIterator still contains removed element.", !list.contains(last));         }     }      private void initIterator() {         iterator = makeObject();     }      /**      * Returns a FilterIterator that does not filter      * any of its elements      *      * @param i      the Iterator to "filter"      * @return "filtered" iterator      */     protected FilterIterator<E> makePassThroughFilter(final Iterator<E> i) {         final Predicate<E> pred = x -> true;         return new FilterIterator<>(i, pred);     }      /**      * Returns a FilterIterator that blocks      * all of its elements      *      * @param i      the Iterator to "filter"      * @return "filtered" iterator      */     protected FilterIterator<E> makeBlockAllFilter(final Iterator<E> i) {         final Predicate<E> pred = x -> false;         return new FilterIterator<>(i, pred);     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.Transformer;  /**  * Testcase.  *  */ public class ObjectGraphIteratorTest extends AbstractIteratorTest<Object> {      protected String[] testArray = { "One", "Two", "Three", "Four", "Five", "Six" };      protected List<String> list1 = null;     protected List<String> list2 = null;     protected List<String> list3 = null;     protected List<Iterator<String>> iteratorList = null;      public ObjectGraphIteratorTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         list1 = new ArrayList<>();         list1.add("One");         list1.add("Two");         list1.add("Three");         list2 = new ArrayList<>();         list2.add("Four");         list3 = new ArrayList<>();         list3.add("Five");         list3.add("Six");         iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());     }      //-----------------------------------------------------------------------     @Override     public ObjectGraphIterator<Object> makeEmptyIterator() {         final ArrayList<Object> list = new ArrayList<>();         return new ObjectGraphIterator<>(list.iterator());     }      @Override     public ObjectGraphIterator<Object> makeObject() {         return new ObjectGraphIterator<>(iteratorList.iterator());     }      //-----------------------------------------------------------------------     public void testIteratorConstructor_null1() {         final Iterator<Object> it = new ObjectGraphIterator<>(null);          assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      public void testIteratorConstructor_null_next() {         final Iterator<Object> it = new ObjectGraphIterator<>(null);         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructor_null_remove() {         final Iterator<Object> it = new ObjectGraphIterator<>(null);         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      //-----------------------------------------------------------------------     public void testIteratorConstructorIteration_Empty() {         final List<Iterator<Object>> iteratorList = new ArrayList<>();         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      public void testIteratorConstructorIteration_Simple() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructorIteration_SimpleNoHasNext() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(testArray[i], it.next());         }         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructorIteration_WithEmptyIterators() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list1.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list2.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list3.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteratorConstructorRemove() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());          for (int i = 0; i < 6; i++) {             assertEquals(testArray[i], it.next());             it.remove();         }         assertEquals(false, it.hasNext());         assertEquals(0, list1.size());         assertEquals(0, list2.size());         assertEquals(0, list3.size());     }      //-----------------------------------------------------------------------     public void testIteration_IteratorOfIterators() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(list1.iterator());         iteratorList.add(list2.iterator());         iteratorList.add(list3.iterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());     }      public void testIteration_IteratorOfIteratorsWithEmptyIterators() {         final List<Iterator<String>> iteratorList = new ArrayList<>();         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list1.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list2.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         iteratorList.add(list3.iterator());         iteratorList.add(IteratorUtils.<String>emptyIterator());         final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);          for (int i = 0; i < 6; i++) {             assertEquals(true, it.hasNext());             assertEquals(testArray[i], it.next());         }         assertEquals(false, it.hasNext());     }      //-----------------------------------------------------------------------     public void testIteration_RootNull() {         final Iterator<Object> it = new ObjectGraphIterator<>(null, null);          assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             it.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      public void testIteration_RootNoTransformer() {         final Forest forest = new Forest();         final Iterator<Object> it = new ObjectGraphIterator<>(forest, null);          assertEquals(true, it.hasNext());         assertSame(forest, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteration_Transformed1() {         final Forest forest = new Forest();         final Leaf l1 = forest.addTree().addBranch().addLeaf();         final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());          assertEquals(true, it.hasNext());         assertSame(l1, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteration_Transformed2() {         final Forest forest = new Forest();         forest.addTree();         forest.addTree();         forest.addTree();         final Branch b1 = forest.getTree(0).addBranch();         final Branch b2 = forest.getTree(0).addBranch();         final Branch b3 = forest.getTree(2).addBranch();         /* Branch b4 = */ forest.getTree(2).addBranch();         final Branch b5 = forest.getTree(2).addBranch();         final Leaf l1 = b1.addLeaf();         final Leaf l2 = b1.addLeaf();         final Leaf l3 = b2.addLeaf();         final Leaf l4 = b3.addLeaf();         final Leaf l5 = b5.addLeaf();          final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());          assertEquals(true, it.hasNext());         assertSame(l1, it.next());         assertEquals(true, it.hasNext());         assertSame(l2, it.next());         assertEquals(true, it.hasNext());         assertSame(l3, it.next());         assertEquals(true, it.hasNext());         assertSame(l4, it.next());         assertEquals(true, it.hasNext());         assertSame(l5, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      public void testIteration_Transformed3() {         final Forest forest = new Forest();         forest.addTree();         forest.addTree();         forest.addTree();         final Branch b1 = forest.getTree(1).addBranch();         final Branch b2 = forest.getTree(1).addBranch();         final Branch b3 = forest.getTree(2).addBranch();         final Branch b4 = forest.getTree(2).addBranch();         /* Branch b5 = */ forest.getTree(2).addBranch();         final Leaf l1 = b1.addLeaf();         final Leaf l2 = b1.addLeaf();         final Leaf l3 = b2.addLeaf();         final Leaf l4 = b3.addLeaf();         final Leaf l5 = b4.addLeaf();          final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());          assertEquals(true, it.hasNext());         assertSame(l1, it.next());         assertEquals(true, it.hasNext());         assertSame(l2, it.next());         assertEquals(true, it.hasNext());         assertSame(l3, it.next());         assertEquals(true, it.hasNext());         assertSame(l4, it.next());         assertEquals(true, it.hasNext());         assertSame(l5, it.next());         assertEquals(false, it.hasNext());         try {             it.next();             fail();         } catch (final NoSuchElementException ex) {         }     }      //-----------------------------------------------------------------------     static class LeafFinder implements Transformer<Object, Object> {         @Override         public Object transform(final Object input) {             if (input instanceof Forest) {                 return ((Forest) input).treeIterator();             }             if (input instanceof Tree) {                 return ((Tree) input).branchIterator();             }             if (input instanceof Branch) {                 return ((Branch) input).leafIterator();             }             if (input instanceof Leaf) {                 return input;             }             throw new ClassCastException();         }     }      //-----------------------------------------------------------------------     static class Forest {         List<Tree> trees = new ArrayList<>();          Tree addTree() {             trees.add(new Tree());             return getTree(trees.size() - 1);         }          Tree getTree(final int index) {             return trees.get(index);         }          Iterator<Tree> treeIterator() {             return trees.iterator();         }     }      static class Tree {         List<Branch> branches = new ArrayList<>();          Branch addBranch() {             branches.add(new Branch());             return getBranch(branches.size() - 1);         }          Branch getBranch(final int index) {             return branches.get(index);         }          Iterator<Branch> branchIterator() {             return branches.iterator();         }     }      static class Branch {         List<Leaf> leaves = new ArrayList<>();          Leaf addLeaf() {             leaves.add(new Leaf());             return getLeaf(leaves.size() - 1);         }          Leaf getLeaf(final int index) {             return leaves.get(index);         }          Iterator<Leaf> leafIterator() {             return leaves.iterator();         }     }      static class Leaf {         String colour;          String getColour() {             return colour;         }          void setColour(final String colour) {             this.colour = colour;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Iterator; import java.util.NoSuchElementException;  /**  * Tests the ArrayIterator with primitive type arrays.  *  */ public class ArrayIterator2Test<E> extends AbstractIteratorTest<E> {      protected int[] testArray = { 2, 4, 6, 8 };      public ArrayIterator2Test(final String testName) {         super(testName);     }      @Override     public ArrayIterator<E> makeEmptyIterator() {         return new ArrayIterator<>(new int[0]);     }      @Override     public ArrayIterator<E> makeObject() {         return new ArrayIterator<>(testArray);     }      public ArrayIterator<E> makeArrayIterator(final Object array) {         return new ArrayIterator<>(array);     }      public ArrayIterator<E> makeArrayIterator(final Object array, final int index) {         return new ArrayIterator<>(array, index);     }      public ArrayIterator<E> makeArrayIterator(final Object array, final int start, final int end) {         return new ArrayIterator<>(array, start, end);     }      @Override     public boolean supportsRemove() {         return false;     }      public void testIterator() {         final Iterator<E> iter = makeObject();         for (final int element : testArray) {             final Integer testValue = Integer.valueOf(element);             final Number iterValue = (Number) iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testIndexedArray() {         Iterator<E> iter = makeArrayIterator(testArray, 2);         int count = 0;         while (iter.hasNext()) {             ++count;             iter.next();         }          assertEquals("the count should be right using ArrayIterator(Object,2) ", count, testArray.length - 2);          iter = makeArrayIterator(testArray, 1, testArray.length - 1);         count = 0;         while (iter.hasNext()) {             ++count;             iter.next();         }          assertEquals(             "the count should be right using ArrayIterator(Object,1," + (testArray.length - 1) + ") ",             count,             testArray.length - 2);          try {             iter = makeArrayIterator(testArray, -1);             fail("new ArrayIterator(Object,-1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, testArray.length + 1);             fail("new ArrayIterator(Object,length+1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, 0, -1);             fail("new ArrayIterator(Object,0,-1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, 0, testArray.length + 1);             fail("new ArrayIterator(Object,0,length+1) should throw an ArrayIndexOutOfBoundsException");         } catch (final ArrayIndexOutOfBoundsException aioobe) {             // expected         }          try {             iter = makeArrayIterator(testArray, 1, 1);             // expected not to fail         } catch (final IllegalArgumentException iae) {             // MODIFIED: an iterator over a zero-length section of array             //  should be perfectly legal behavior             fail("new ArrayIterator(Object,1,1) should NOT throw an IllegalArgumentException");         }          try {             iter = makeArrayIterator(testArray, testArray.length - 1, testArray.length - 2);             fail("new ArrayIterator(Object,length-2,length-1) should throw an IllegalArgumentException");         } catch (final IllegalArgumentException iae) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Set;  /**  * Test class for PermutationIterator.  *  * @since 4.0  */ public class PermutationIteratorTest extends AbstractIteratorTest<List<Character>> {      @SuppressWarnings("boxing") // OK in test code     protected Character[] testArray = { 'A', 'B', 'C' };     protected List<Character> testList;      public PermutationIteratorTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         testList = new ArrayList<>();         testList.addAll(Arrays.asList(testArray));     }      //-----------------------------------------------------------------------      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsEmptyIterator() {         return false;     }      @Override     public PermutationIterator<Character> makeEmptyIterator() {         return new PermutationIterator<>(new ArrayList<Character>());     }      @Override     public PermutationIterator<Character> makeObject() {         return new PermutationIterator<>(testList);     }      //-----------------------------------------------------------------------      @SuppressWarnings("boxing") // OK in test code     public void testPermutationResultSize() {         int factorial = 1;         for (int i = 0; i < 8; i++, factorial*=i) {             final List<Integer> list = new ArrayList<>();             for (int j = 0; j < i; j++) {                 list.add(j);             }             final Iterator<List<Integer>> it = new PermutationIterator<>(list);             int count = 0;             while (it.hasNext()) {                 it.next();                 count++;             }             assertEquals(factorial, count);         }     }      /**      * test checking that all the permutations are returned      */     @SuppressWarnings("boxing") // OK in test code     public void testPermutationExhaustivity() {         final List<Character> perm1 = new ArrayList<>();         final List<Character> perm2 = new ArrayList<>();         final List<Character> perm3 = new ArrayList<>();         final List<Character> perm4 = new ArrayList<>();         final List<Character> perm5 = new ArrayList<>();         final List<Character> perm6 = new ArrayList<>();          perm1.add('A');         perm2.add('A');         perm3.add('B');         perm4.add('B');         perm5.add('C');         perm6.add('C');          perm1.add('B');         perm2.add('C');         perm3.add('A');         perm4.add('C');         perm5.add('A');         perm6.add('B');          perm1.add('C');         perm2.add('B');         perm3.add('C');         perm4.add('A');         perm5.add('B');         perm6.add('A');          final List<List<Character>> results = new ArrayList<>();          final PermutationIterator<Character> it = makeObject();         while (it.hasNext()) {             final List<Character> next = it.next();             results.add(next);         }         //3! permutation for 3 elements         assertEquals(6, results.size());         assertTrue(results.contains(perm1));         assertTrue(results.contains(perm2));         assertTrue(results.contains(perm3));         assertTrue(results.contains(perm4));         assertTrue(results.contains(perm5));         assertTrue(results.contains(perm6));     }      /**      * test checking that all the permutations are returned only once.      */     public void testPermutationUnicity() {         final List<List<Character>> resultsList = new ArrayList<>();         final Set<List<Character>> resultsSet = new HashSet<>();          final PermutationIterator<Character> it = makeObject();         while (it.hasNext()) {             final List<Character> permutation = it.next();             resultsList.add(permutation);             resultsSet.add(permutation);         }         //3! permutation for 3 elements         assertEquals(6, resultsList.size());         assertEquals(6, resultsSet.size());     }      public void testPermutationException() {         final List<List<Character>> resultsList = new ArrayList<>();          final PermutationIterator<Character> it = makeObject();         while (it.hasNext()) {             final List<Character> permutation = it.next();             resultsList.add(permutation);         }         //asking for another permutation should throw an exception         try {             it.next();             fail();         } catch (final NoSuchElementException e) {             // expected         }     }      public void testPermutatorHasMore() {         final PermutationIterator<Character> it = makeObject();         for (int i = 0; i < 6; i++) {             assertTrue(it.hasNext());             it.next();         }         assertFalse(it.hasNext());     }      public void testEmptyCollection() {         final PermutationIterator<Character> it = makeEmptyIterator();         // there is one permutation for an empty set: 0! = 1         assertTrue(it.hasNext());          final List<Character> nextPermutation = it.next();         assertEquals(0, nextPermutation.size());          assertFalse(it.hasNext());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List;  import org.junit.Test;  /**  * Tests the PushbackIterator.  *  */ public class PushbackIteratorTest<E> extends AbstractIteratorTest<E> {      private final String[] testArray = { "a", "b", "c" };      private List<E> testList;      public PushbackIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public Iterator<E> makeEmptyIterator() {         return PushbackIterator.pushbackIterator(Collections.<E>emptyList().iterator());     }      @Override     public PushbackIterator<E> makeObject() {         return PushbackIterator.pushbackIterator(testList.iterator());     }      @Override     public boolean supportsRemove() {         return false;     }      // -----------------------------------------------------------------------      @Test     public void testNormalIteration() {         final PushbackIterator<E> iter = makeObject();         assertEquals("a", iter.next());         assertEquals("b", iter.next());         assertEquals("c", iter.next());         assertFalse(iter.hasNext());     }      @Test     @SuppressWarnings("unchecked")     public void testImmediatePushback() {         final PushbackIterator<E> iter = makeObject();         iter.pushback((E) "x");         assertEquals("x", iter.next());         assertEquals("a", iter.next());         validate(iter, "b", "c");     }      @Test     @SuppressWarnings("unchecked")     public void testDelayedPushback() {         final PushbackIterator<E> iter = makeObject();         assertEquals("a", iter.next());         iter.pushback((E) "x");         assertEquals("x", iter.next());         assertEquals("b", iter.next());         validate(iter, "c");     }      @Test     @SuppressWarnings("unchecked")     public void testMultiplePushback() {         final PushbackIterator<E> iter = makeObject();         assertEquals("a", iter.next());         iter.pushback((E) "x");         iter.pushback((E) "y");         assertEquals("y", iter.next());         assertEquals("x", iter.next());         assertEquals("b", iter.next());         validate(iter, "c");     }      private void validate(final Iterator<E> iter, final Object... items) {         for (final Object x : items) {             assertTrue(iter.hasNext());             assertEquals(x, iter.next());         }         assertFalse(iter.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.Arrays; import java.util.ListIterator; import java.util.NoSuchElementException;  /**  * Tests the ObjectArrayListIterator class.  *  */ public class ObjectArrayListIteratorTest<E> extends ObjectArrayIteratorTest<E> {      public ObjectArrayListIteratorTest(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeEmptyIterator() {         return new ObjectArrayListIterator<>((E[]) new Object[0]);     }      @Override     @SuppressWarnings("unchecked")     public ObjectArrayListIterator<E> makeObject() {         return new ObjectArrayListIterator<>((E[]) testArray);     }      public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {         return new ObjectArrayListIterator<>(array);     }      /**      * Test the basic ListIterator functionality - going backwards using      * {@code previous()}.      */     public void testListIterator() {         final ListIterator<E> iter = makeObject();          // TestArrayIterator#testIterator() has already tested the iterator forward,         //  now we need to test it in reverse          // fast-forward the iterator to the end...         while (iter.hasNext()) {             iter.next();         }          for (int x = testArray.length - 1; x >= 0; x--) {             final Object testValue = testArray[x];             final Object iterValue = iter.previous();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasPrevious());          try {             iter.previous();         } catch (final Exception e) {             assertTrue(                 "NoSuchElementException must be thrown",                 e.getClass().equals(new NoSuchElementException().getClass()));         }      }      /**      * Tests the {@link java.util.ListIterator#set} operation.      */     @SuppressWarnings("unchecked")     public void testListIteratorSet() {         final String[] testData = new String[] { "a", "b", "c" };          final String[] result = new String[] { "0", "1", "2" };          ListIterator<E> iter = makeArrayListIterator((E[]) testData);         int x = 0;          while (iter.hasNext()) {             iter.next();             iter.set((E) Integer.toString(x));             x++;         }          assertTrue("The two arrays should have the same value, i.e. {0,1,2}", Arrays.equals(testData, result));          // a call to set() before a call to next() or previous() should throw an IllegalStateException         iter = makeArrayListIterator((E[]) testArray);          try {             iter.set((E) "should fail");             fail("ListIterator#set should fail if next() or previous() have not yet been called.");         } catch (final IllegalStateException e) {             // expected         } catch (final Throwable t) { // should never happen             fail(t.toString());         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.OrderedMapIterator;  /**  * Abstract class for testing the OrderedMapIterator interface.  * <p>  * This class provides a framework for testing an implementation of MapIterator.  * Concrete subclasses must provide the list iterator to be tested.  * They must also specify certain details of how the list iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractOrderedMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractOrderedMapIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public abstract OrderedMapIterator<K, V> makeEmptyIterator();      @Override     public abstract OrderedMapIterator<K, V> makeObject();      //-----------------------------------------------------------------------     /**      * Test that the empty list iterator contract is correct.      */     @Override     public void testEmptyMapIterator() {         if (!supportsEmptyIterator()) {             return;         }          super.testEmptyMapIterator();          final OrderedMapIterator<K, V> it = makeEmptyIterator();         assertEquals(false, it.hasPrevious());         try {             it.previous();             fail();         } catch (final NoSuchElementException ex) {}     }      //-----------------------------------------------------------------------     /**      * Test that the full list iterator contract is correct.      */     @Override     public void testFullMapIterator() {         if (!supportsFullIterator()) {             return;         }          super.testFullMapIterator();          final OrderedMapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();          assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         final Set<K> set = new HashSet<>();         while (it.hasNext()) {             // getKey             final K key = it.next();             assertSame("it.next() should equals getKey()", key, it.getKey());             assertTrue("Key must be in map",  map.containsKey(key));             assertTrue("Key must be unique", set.add(key));              // getValue             final V value = it.getValue();             if (!isGetStructuralModify()) {                 assertSame("Value must be mapped to key", map.get(key), value);             }             assertTrue("Value must be in map",  map.containsValue(value));              assertEquals(true, it.hasPrevious());              verify();         }         while (it.hasPrevious()) {             // getKey             final Object key = it.previous();             assertSame("it.previous() should equals getKey()", key, it.getKey());             assertTrue("Key must be in map",  map.containsKey(key));             assertTrue("Key must be unique", set.remove(key));              // getValue             final Object value = it.getValue();             if (!isGetStructuralModify()) {                 assertSame("Value must be mapped to key", map.get(key), value);             }             assertTrue("Value must be in map",  map.containsValue(value));              assertEquals(true, it.hasNext());              verify();         }     }      //-----------------------------------------------------------------------     /**      * Test that the iterator order matches the keySet order.      */     public void testMapIteratorOrder() {         if (!supportsFullIterator()) {             return;         }          final OrderedMapIterator<K, V> it = makeObject();         final Map<K, V> map = getMap();          assertEquals("keySet() not consistent", new ArrayList<>(map.keySet()), new ArrayList<>(map.keySet()));          final Iterator<K> it2 = map.keySet().iterator();         assertEquals(true, it.hasNext());         assertEquals(true, it2.hasNext());         final List<K> list = new ArrayList<>();         while (it.hasNext()) {             final K key = it.next();             assertEquals(it2.next(), key);             list.add(key);         }         assertEquals(map.size(), list.size());         while (it.hasPrevious()) {             final K key = it.previous();             assertEquals(list.get(list.size() - 1), key);             list.remove(list.size() - 1);         }         assertEquals(0, list.size());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the ReverseListIterator.  *  */ public class ReverseListIteratorTest<E> extends AbstractListIteratorTest<E> {      protected String[] testArray = { "One", "Two", "Three", "Four" };      public ReverseListIteratorTest(final String testName) {         super(testName);     }      @Override     public ListIterator<E> makeEmptyIterator() {         return new ReverseListIterator<>(new ArrayList<E>());     }      @Override     @SuppressWarnings("unchecked")     public ReverseListIterator<E> makeObject() {         final List<E> list = new ArrayList<>(Arrays.asList((E[]) testArray));         return new ReverseListIterator<>(list);     }      // overrides     //-----------------------------------------------------------------------     @Override     public void testEmptyListIteratorIsIndeedEmpty() {         final ListIterator<E> it = makeEmptyIterator();          assertEquals(false, it.hasNext());         assertEquals(-1, it.nextIndex());  // reversed index         assertEquals(false, it.hasPrevious());         assertEquals(0, it.previousIndex());  // reversed index          // next() should throw a NoSuchElementException         try {             it.next();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }          // previous() should throw a NoSuchElementException         try {             it.previous();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }     }      @Override     public void testWalkForwardAndBack() {         final ArrayList<E> list = new ArrayList<>();         final ListIterator<E> it = makeObject();         while (it.hasNext()) {             list.add(it.next());         }          // check state at end         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());          // this had to be commented out, as there is a bug in the JDK before JDK1.5         // where calling previous at the start of an iterator would push the cursor         // back to an invalid negative value //        try { //            it.next(); //            fail("NoSuchElementException must be thrown from next at end of ListIterator"); //        } catch (NoSuchElementException e) { //        }          // loop back through comparing         for (int i = list.size() - 1; i >= 0; i--) {             assertEquals("" + i, list.size() - i - 2, it.nextIndex());  // reversed index             assertEquals(list.size() - i - 1, it.previousIndex());  // reversed index              final Object obj = list.get(i);             assertEquals(obj, it.previous());         }          // check state at start         assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         try {             it.previous();             fail("NoSuchElementException must be thrown from previous at start of ListIterator");         } catch (final NoSuchElementException e) {         }     }      //-----------------------------------------------------------------------     public void testReverse() {         final ListIterator<E> it = makeObject();         assertEquals(true, it.hasNext());         assertEquals(3, it.nextIndex());         assertEquals(false, it.hasPrevious());         assertEquals(4, it.previousIndex());         assertEquals("Four", it.next());         assertEquals(2, it.nextIndex());         assertEquals(true, it.hasNext());         assertEquals(3, it.previousIndex());         assertEquals(true, it.hasPrevious());         assertEquals("Three", it.next());         assertEquals(true, it.hasNext());         assertEquals(1, it.nextIndex());         assertEquals(true, it.hasPrevious());         assertEquals(2, it.previousIndex());         assertEquals("Two", it.next());         assertEquals(true, it.hasNext());         assertEquals(0, it.nextIndex());         assertEquals(true, it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals("One", it.next());         assertEquals(false, it.hasNext());         assertEquals(-1, it.nextIndex());         assertEquals(true, it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals("One", it.previous());         assertEquals("Two", it.previous());         assertEquals("Three", it.previous());         assertEquals("Four", it.previous());     }      public void testReset() {         final ResettableListIterator<E> it = makeObject();         assertEquals("Four", it.next());         it.reset();         assertEquals("Four", it.next());         it.next();         it.next();         it.reset();         assertEquals("Four", it.next());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.bidimap.DualHashBidiMap;  /**  * Tests the UnmodifiableMapIterator.  *  */ public class UnmodifiableMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {      public UnmodifiableMapIteratorTest(final String testName) {         super(testName);     }      @Override     public MapIterator<K, V> makeEmptyIterator() {         return UnmodifiableMapIterator.unmodifiableMapIterator(new DualHashBidiMap<K, V>().mapIterator());     }      @Override     public MapIterator<K, V> makeObject() {         return UnmodifiableMapIterator.unmodifiableMapIterator(getMap().mapIterator());     }      @Override     @SuppressWarnings("unchecked")     public IterableMap<K, V> getMap() {         final IterableMap<K, V> testMap = new DualHashBidiMap<>();         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     @SuppressWarnings("unchecked")     public Map<K, V> getConfirmedMap() {         final Map<K, V> testMap = new HashMap<>();         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsSetValue() {         return false;     }      //-----------------------------------------------------------------------     public void testMapIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         MapIterator<K, V> it = makeObject();         assertSame(it, UnmodifiableMapIterator.unmodifiableMapIterator(it));          it = getMap().mapIterator();         assertTrue(it != UnmodifiableMapIterator.unmodifiableMapIterator(it));          try {             UnmodifiableMapIterator.unmodifiableMapIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.ListIterator; import java.util.NoSuchElementException;  /**  * Abstract class for testing the ListIterator interface.  * <p>  * This class provides a framework for testing an implementation of ListIterator.  * Concrete subclasses must provide the list iterator to be tested.  * They must also specify certain details of how the list iterator operates by  * overriding the supportsXxx() methods if necessary.  *  * @since 3.0  */ public abstract class AbstractListIteratorTest<E> extends AbstractIteratorTest<E> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractListIteratorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implements the abstract superclass method to return the list iterator.      *      * @return an empty iterator      */     @Override     public abstract ListIterator<E> makeEmptyIterator();      /**      * Implements the abstract superclass method to return the list iterator.      *      * @return a full iterator      */     @Override     public abstract ListIterator<E> makeObject();      /**      * Whether or not we are testing an iterator that supports add().      * Default is true.      *      * @return true if Iterator supports add      */     public boolean supportsAdd() {         return true;     }      /**      * Whether or not we are testing an iterator that supports set().      * Default is true.      *      * @return true if Iterator supports set      */     public boolean supportsSet() {         return true;     }      /**      * The value to be used in the add and set tests.      * Default is null.      */     public E addSetValue() {         return null;     }      //-----------------------------------------------------------------------     /**      * Test that the empty list iterator contract is correct.      */     public void testEmptyListIteratorIsIndeedEmpty() {         if (!supportsEmptyIterator()) {             return;         }          final ListIterator<E> it = makeEmptyIterator();          assertEquals(false, it.hasNext());         assertEquals(0, it.nextIndex());         assertEquals(false, it.hasPrevious());         assertEquals(-1, it.previousIndex());          // next() should throw a NoSuchElementException         try {             it.next();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }          // previous() should throw a NoSuchElementException         try {             it.previous();             fail("NoSuchElementException must be thrown from empty ListIterator");         } catch (final NoSuchElementException e) {         }     }      /**      * Test navigation through the iterator.      */     public void testWalkForwardAndBack() {         final ArrayList<E> list = new ArrayList<>();         final ListIterator<E> it = makeObject();         while (it.hasNext()) {             list.add(it.next());         }          // check state at end         assertEquals(false, it.hasNext());         assertEquals(true, it.hasPrevious());         try {             it.next();             fail("NoSuchElementException must be thrown from next at end of ListIterator");         } catch (final NoSuchElementException e) {         }          // loop back through comparing         for (int i = list.size() - 1; i >= 0; i--) {             assertEquals(i + 1, it.nextIndex());             assertEquals(i, it.previousIndex());              final Object obj = list.get(i);             assertEquals(obj, it.previous());         }          // check state at start         assertEquals(true, it.hasNext());         assertEquals(false, it.hasPrevious());         try {             it.previous();             fail("NoSuchElementException must be thrown from previous at start of ListIterator");         } catch (final NoSuchElementException e) {         }     }      /**      * Test add behavior.      */     public void testAdd() {         ListIterator<E> it = makeObject();          final E addValue = addSetValue();         if (!supportsAdd()) {             // check for UnsupportedOperationException if not supported             try {                 it.add(addValue);                 fail("UnsupportedOperationException must be thrown from add of " + it.getClass().getSimpleName());             } catch (final UnsupportedOperationException ex) {}             return;         }          // add at start should be OK, added should be previous         it = makeObject();         it.add(addValue);         assertEquals(addValue, it.previous());          // add at start should be OK, added should not be next         it = makeObject();         it.add(addValue);         assertTrue(addValue != it.next());          // add in middle and at end should be OK         it = makeObject();         while (it.hasNext()) {             it.next();             it.add(addValue);             // check add OK             assertEquals(addValue, it.previous());             it.next();         }     }      /**      * Test set behavior.      */     public void testSet() {         final ListIterator<E> it = makeObject();          if (!supportsSet()) {             // check for UnsupportedOperationException if not supported             try {                 it.set(addSetValue());                 fail("UnsupportedOperationException must be thrown from set in " + it.getClass().getSimpleName());             } catch (final UnsupportedOperationException ex) {}             return;         }          // should throw IllegalStateException before next() called         try {             it.set(addSetValue());             fail();         } catch (final IllegalStateException ex) {}          // set after next should be fine         it.next();         it.set(addSetValue());          // repeated set calls should be fine         it.set(addSetValue());      }      public void testRemoveThenSet() {         final ListIterator<E> it = makeObject();         if (supportsRemove() && supportsSet()) {             it.next();             it.remove();             try {                 it.set(addSetValue());                 fail("IllegalStateException must be thrown from set after remove");             } catch (final IllegalStateException e) {             }         }     }      public void testAddThenSet() {         final ListIterator<E> it = makeObject();         // add then set         if (supportsAdd() && supportsSet()) {             it.next();             it.add(addSetValue());             try {                 it.set(addSetValue());                 fail("IllegalStateException must be thrown from set after add");             } catch (final IllegalStateException e) {             }         }     }      /**      * Test remove after add behavior.      */     public void testAddThenRemove() {         final ListIterator<E> it = makeObject();          // add then remove         if (supportsAdd() && supportsRemove()) {             it.next();             it.add(addSetValue());             try {                 it.remove();                 fail("IllegalStateException must be thrown from remove after add");             } catch (final IllegalStateException e) {             }         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.ResettableListIterator;  /**  * Tests the ListIteratorWrapper to insure that it behaves as expected when wrapping a ListIterator.  *  */ public class ListIteratorWrapper2Test<E> extends AbstractIteratorTest<E> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<E> list1 = null;      public ListIteratorWrapper2Test(final String testName) {         super(testName);     }      @Override     @SuppressWarnings("unchecked")     public void setUp() {         list1 = new ArrayList<>();         list1.add((E) "One");         list1.add((E) "Two");         list1.add((E) "Three");         list1.add((E) "Four");         list1.add((E) "Five");         list1.add((E) "Six");     }      @Override     public ResettableListIterator<E> makeEmptyIterator() {         final ArrayList<E> list = new ArrayList<>();         return new ListIteratorWrapper<>(list.listIterator());     }      @Override     public ResettableListIterator<E> makeObject() {         return new ListIteratorWrapper<>(list1.listIterator());     }      public void testIterator() {         final ListIterator<E> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it backwards         for (int i = testArray.length - 1; i > -1; --i) {             final Object testValue = testArray[i];             final E iterValue = iter.previous();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          try {             iter.previous();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }          // now, read it forwards again         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }      }      @Override     public void testRemove() {         final ListIterator<E> iter = makeObject();          //initial state:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be initially positioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //establish size:         int sz = list1.size();          //verify initial next() call:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //verify remove():         iter.remove();         assertEquals(--sz, list1.size());         //like we never started iterating:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          try {             iter.remove();             fail("ListIteratorWrapper#remove() should fail; must be repositioned first");         } catch (final IllegalStateException e) {         }          //no change from invalid op:         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //two consecutive next() calls:         assertEquals(list1.get(0), iter.next());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          assertEquals(list1.get(1), iter.next());         assertEquals(1, iter.previousIndex());         assertEquals(2, iter.nextIndex());          //call previous():         assertEquals(list1.get(1), iter.previous());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(0, iter.previousIndex());         assertEquals(1, iter.nextIndex());          //this would dig into cache on a plain Iterator, but forwards directly to wrapped ListIterator:         assertEquals(list1.get(0), iter.previous());         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //here's the proof; remove() still works:         iter.remove();         assertEquals(--sz, list1.size());         assertEquals(-1, iter.previousIndex());         assertEquals(0, iter.nextIndex());          //further testing would be fairly meaningless:     }      public void testReset() {         final ResettableListIterator<E> iter = makeObject();         final E first = iter.next();         final E second = iter.next();          iter.reset();          // after reset, there shouldn't be any previous elements         assertFalse("No previous elements after reset()", iter.hasPrevious());          // after reset, the results should be the same as before         assertEquals("First element should be the same", first, iter.next());         assertEquals("Second element should be the same", second, iter.next());          // after passing the point, where we resetted, continuation should work as expected         for (int i = 2; i < testArray.length; i++) {             final Object testValue = testArray[i];             final E iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Test;  /**  * Tests the PeekingIterator.  */ public class PeekingIteratorTest<E> extends AbstractIteratorTest<E> {      private final String[] testArray = { "a", "b", "c" };      private List<E> testList;      public PeekingIteratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @SuppressWarnings("unchecked")     @Override     protected void setUp() throws Exception {         super.setUp();         testList = new ArrayList<>(Arrays.asList((E[]) testArray));     }      @Override     public Iterator<E> makeEmptyIterator() {         return PeekingIterator.peekingIterator(Collections.<E>emptyList().iterator());     }      @Override     public PeekingIterator<E> makeObject() {         return PeekingIterator.peekingIterator(testList.iterator());     }      @Override     public boolean supportsRemove() {         return true;     }      //-----------------------------------------------------------------------      @Test     public void testEmpty() {         final Iterator<E> it = makeEmptyIterator();         assertFalse(it.hasNext());     }      @Test     @SuppressWarnings("unchecked")     public void testSinglePeek() {         final PeekingIterator<E> it = makeObject();         assertEquals("a", it.peek());         assertEquals("a", it.element());         validate(it, (E[]) testArray);     }      @Test     public void testMultiplePeek() {         final PeekingIterator<E> it = makeObject();         assertEquals("a", it.peek());         assertEquals("a", it.peek());         assertEquals("a", it.next());         assertTrue(it.hasNext());         assertEquals("b", it.peek());         assertEquals("b", it.peek());         assertEquals("b", it.next());         assertTrue(it.hasNext());         assertEquals("c", it.peek());         assertEquals("c", it.peek());         assertEquals("c", it.next());         assertFalse(it.hasNext());     }      @Test     public void testIteratorExhausted() {         final PeekingIterator<E> it = makeObject();         it.next();         it.next();         it.next();         assertFalse(it.hasNext());         assertNull(it.peek());          try {             it.element();             fail();         } catch (final NoSuchElementException e) {             // expected         }     }      @Test     public void testIllegalRemove() {         final PeekingIterator<E> it = makeObject();         it.next();         it.remove(); // supported          assertTrue(it.hasNext());         assertEquals("b", it.peek());          try {             it.remove();             fail();         } catch (final IllegalStateException e) {             // expected         }     }      private void validate(final Iterator<E> iter, final E... items) {         for (final E x : items) {             assertTrue(iter.hasNext());             assertEquals(x, iter.next());         }         assertFalse(iter.hasNext());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.HashMap; import java.util.Map; import java.util.TreeMap;  import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.OrderedMapIterator; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.map.ListOrderedMap;  /**  * Tests the UnmodifiableOrderedMapIterator.  *  */ public class UnmodifiableOrderedMapIteratorTest<K, V> extends AbstractOrderedMapIteratorTest<K, V> {      public UnmodifiableOrderedMapIteratorTest(final String testName) {         super(testName);     }      @Override     public OrderedMapIterator<K, V> makeEmptyIterator() {         return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(                 ListOrderedMap.listOrderedMap(new HashMap<K, V>()).mapIterator());     }      @Override     public OrderedMapIterator<K, V> makeObject() {         return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(getMap().mapIterator());     }      @Override     @SuppressWarnings("unchecked")     public OrderedMap<K, V> getMap() {         final OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     @SuppressWarnings("unchecked")     public Map<K, V> getConfirmedMap() {         final Map<K, V> testMap = new TreeMap<>();         testMap.put((K) "A", (V) "a");         testMap.put((K) "B", (V) "b");         testMap.put((K) "C", (V) "c");         return testMap;     }      @Override     public boolean supportsRemove() {         return false;     }      @Override     public boolean supportsSetValue() {         return false;     }      //-----------------------------------------------------------------------     public void testOrderedMapIterator() {         assertTrue(makeEmptyIterator() instanceof Unmodifiable);     }      public void testDecorateFactory() {         OrderedMapIterator<K, V> it = makeObject();         assertSame(it, UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));          it = getMap().mapIterator();         assertTrue(it != UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));          try {             UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.iterators;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.Predicate;  /**  * Tests the LazyIteratorChain class.  *  */ public class LazyIteratorChainTest extends AbstractIteratorTest<String> {      protected String[] testArray = {         "One", "Two", "Three", "Four", "Five", "Six"     };      protected List<String> list1 = null;     protected List<String> list2 = null;     protected List<String> list3 = null;      public LazyIteratorChainTest(final String testName) {         super(testName);     }      @Override     public void setUp() {         list1 = new ArrayList<>();         list1.add("One");         list1.add("Two");         list1.add("Three");         list2 = new ArrayList<>();         list2.add("Four");         list3 = new ArrayList<>();         list3.add("Five");         list3.add("Six");     }      @Override     public LazyIteratorChain<String> makeEmptyIterator() {         return new LazyIteratorChain<String>() {             @Override             protected Iterator<String> nextIterator(final int count) {                 return null;             }         };     }      @Override     public LazyIteratorChain<String> makeObject() {         final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {             @Override             protected Iterator<String> nextIterator(final int count) {                 switch (count) {                 case 1:                     return list1.iterator();                 case 2:                     return list2.iterator();                 case 3:                     return list3.iterator();                 }                 return null;             }         };          return chain;     }      public void testIterator() {         final Iterator<String> iter = makeObject();         for (final String testValue : testArray) {             final Object iterValue = iter.next();              assertEquals( "Iteration value is correct", testValue, iterValue );         }          assertTrue("Iterator should now be empty", !iter.hasNext());          try {             iter.next();         } catch (final Exception e) {             assertTrue("NoSuchElementException must be thrown",                        e.getClass().equals(new NoSuchElementException().getClass()));         }     }      public void testRemoveFromFilteredIterator() {          final Predicate<Integer> myPredicate = i -> i.compareTo(Integer.valueOf(4)) < 0;          final List<Integer> list1 = new ArrayList<>();         final List<Integer> list2 = new ArrayList<>();          list1.add(Integer.valueOf(1));         list1.add(Integer.valueOf(2));         list2.add(Integer.valueOf(3));         list2.add(Integer.valueOf(4)); // will be ignored by the predicate          final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);         final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);          final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);         while (it.hasNext()) {             it.next();             it.remove();         }         assertEquals(0, list1.size());         assertEquals(1, list2.size());     }      @Override     public void testRemove() {         final Iterator<String> iter = makeObject();          try {             iter.remove();             fail("Calling remove before the first call to next() should throw an exception");         } catch (final IllegalStateException e) {          }          for (final String testValue : testArray) {             final String iterValue = iter.next();              assertEquals("Iteration value is correct", testValue, iterValue);              if (!iterValue.equals("Four")) {                 iter.remove();             }         }          assertTrue("List is empty", list1.size() == 0);         assertTrue("List is empty", list2.size() == 1);         assertTrue("List is empty", list3.size() == 0);     }      public void testFirstIteratorIsEmptyBug() {         final List<String> empty = new ArrayList<>();         final List<String> notEmpty = new ArrayList<>();         notEmpty.add("A");         notEmpty.add("B");         notEmpty.add("C");         final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {             @Override             protected Iterator<String> nextIterator(final int count) {                 switch (count) {                 case 1:                     return empty.iterator();                 case 2:                     return notEmpty.iterator();                 }                 return null;             }         };         assertTrue("should have next", chain.hasNext());         assertEquals("A", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("B", chain.next());         assertTrue("should have next", chain.hasNext());         assertEquals("C", chain.next());         assertTrue("should not have next", !chain.hasNext());     }      public void testEmptyChain() {         final LazyIteratorChain<String> chain = makeEmptyIterator();         assertEquals(false, chain.hasNext());         try {             chain.next();             fail();         } catch (final NoSuchElementException ex) {}         try {             chain.remove();             fail();         } catch (final IllegalStateException ex) {}     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.io.Serializable;  /**  * Abstract test class for {@link java.lang.Object} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject()} method.  * <p>  * If your {@link Object} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link Object} fails.  */ public abstract class AbstractObjectTest extends BulkTest {      /** Current major release for Collections */     public static final int COLLECTIONS_MAJOR_VERSION = 4;      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractObjectTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Implement this method to return the object to test.      *      * @return the object to test      */     public abstract Object makeObject();      /**      * Override this method if a subclass is testing an object      * that cannot serialize an "empty" Collection.      * (e.g. Comparators have no contents)      *      * @return true      */     public boolean supportsEmptyCollections() {         return true;     }      /**      * Override this method if a subclass is testing an object      * that cannot serialize a "full" Collection.      * (e.g. Comparators have no contents)      *      * @return true      */     public boolean supportsFullCollections() {         return true;     }      /**      * Is serialization testing supported.      * Default is true.      */     public boolean isTestSerialization() {         return true;     }      /**      * Returns true to indicate that the collection supports equals() comparisons.      * This implementation returns true;      */     public boolean isEqualsCheckable() {         return true;     }      //-----------------------------------------------------------------------     public void testObjectEqualsSelf() {         final Object obj = makeObject();         assertEquals("A Object should equal itself", obj, obj);     }      public void testEqualsNull() {         final Object obj = makeObject();         assertEquals(false, obj.equals(null)); // make sure this doesn't throw NPE either     }      public void testObjectHashCodeEqualsSelfHashCode() {         final Object obj = makeObject();         assertEquals("hashCode should be repeatable", obj.hashCode(), obj.hashCode());     }      public void testObjectHashCodeEqualsContract() {         final Object obj1 = makeObject();         if (obj1.equals(obj1)) {             assertEquals(                 "[1] When two objects are equal, their hashCodes should be also.",                 obj1.hashCode(), obj1.hashCode());         }         final Object obj2 = makeObject();         if (obj1.equals(obj2)) {             assertEquals(                 "[2] When two objects are equal, their hashCodes should be also.",                 obj1.hashCode(), obj2.hashCode());             assertTrue(                 "When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true",                 obj2.equals(obj1));         }     }      protected Object serializeDeserialize(final Object obj) throws Exception {         final ByteArrayOutputStream buffer = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(buffer);         out.writeObject(obj);         out.close();          final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));         final Object dest = in.readObject();         in.close();          return dest;     }      public void testSerializeDeserializeThenCompare() throws Exception {         final Object obj = makeObject();         if (obj instanceof Serializable && isTestSerialization()) {             final Object dest = serializeDeserialize(obj);             if (isEqualsCheckable()) {                 assertEquals("obj != deserialize(serialize(obj))", obj, dest);             }         }     }      /**      * Sanity check method, makes sure that any Serializable      * class can be serialized and de-serialized in memory,      * using the handy makeObject() method      *      * @throws IOException      * @throws ClassNotFoundException      */     public void testSimpleSerialization() throws Exception {         final Object o = makeObject();         if (o instanceof Serializable && isTestSerialization()) {             final byte[] objekt = writeExternalFormToBytes((Serializable) o);             readExternalFormFromBytes(objekt);         }     }      /**      * Tests serialization by comparing against a previously stored version in SCM.      * If the test object is serializable, confirm that a canonical form exists.      */     public void testCanonicalEmptyCollectionExists() {         if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {             final Object object = makeObject();             if (object instanceof Serializable) {                 final String name = getCanonicalEmptyCollectionName(object);                 assertTrue(                     "Canonical empty collection (" + name + ") is not in SCM",                     new File(name).exists());             }         }     }      /**      * Tests serialization by comparing against a previously stored version in SCM.      * If the test object is serializable, confirm that a canonical form exists.      */     public void testCanonicalFullCollectionExists() {         if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {             final Object object = makeObject();             if (object instanceof Serializable) {                 final String name = getCanonicalFullCollectionName(object);                 assertTrue(                     "Canonical full collection (" + name + ") is not in SCM",                     new File(name).exists());             }         }     }      // protected implementation     //-----------------------------------------------------------------------     /**      * Get the version of Collections that this object tries to      * maintain serialization compatibility with. Defaults to 4, due to      * the package change to collections4 introduced in version 4.      *      * This constant makes it possible for TestMap (and other subclasses,      * if necessary) to automatically check SCM for a versionX copy of a      * Serialized object, so we can make sure that compatibility is maintained.      * See, for example, TestMap.getCanonicalFullMapName(Map map).      * Subclasses can override this variable, indicating compatibility      * with earlier Collections versions.      *      * @return The version, or {@code null} if this object shouldn't be      * tested for compatibility with previous versions.      */     public String getCompatibilityVersion() {         return "4";     }      protected String getCanonicalEmptyCollectionName(final Object object) {         final StringBuilder retval = new StringBuilder();         retval.append(TEST_DATA_PATH);         String colName = object.getClass().getName();         colName = colName.substring(colName.lastIndexOf(".") + 1, colName.length());         retval.append(colName);         retval.append(".emptyCollection.version");         retval.append(getCompatibilityVersion());         retval.append(".obj");         return retval.toString();     }      protected String getCanonicalFullCollectionName(final Object object) {         final StringBuilder retval = new StringBuilder();         retval.append(TEST_DATA_PATH);         String colName = object.getClass().getName();         colName = colName.substring(colName.lastIndexOf(".") + 1, colName.length());         retval.append(colName);         retval.append(".fullCollection.version");         retval.append(getCompatibilityVersion());         retval.append(".obj");         return retval.toString();     }      /**      * Writes a Serializable or Externalizable object as      * a file at the given path.  NOT USEFUL as part      * of a unit test; this is just a utility method      * for creating disk-based objects in SCM that can become      * the basis for compatibility tests using      * readExternalFormFromDisk(String path)      *      * @param o Object to serialize      * @param path path to write the serialized Object      * @throws IOException      */     protected void writeExternalFormToDisk(final Serializable o, final String path) throws IOException {         try (FileOutputStream fileStream = new FileOutputStream(path)) {             writeExternalFormToStream(o, fileStream);         }     }      /**      * Converts a Serializable or Externalizable object to      * bytes.  Useful for in-memory tests of serialization      *      * @param o Object to convert to bytes      * @return serialized form of the Object      * @throws IOException      */     protected byte[] writeExternalFormToBytes(final Serializable o) throws IOException {         final ByteArrayOutputStream byteStream = new ByteArrayOutputStream();         writeExternalFormToStream(o, byteStream);         return byteStream.toByteArray();     }      /**      * Reads a Serialized or Externalized Object from disk.      * Useful for creating compatibility tests between      * different SCM versions of the same class      *      * @param path path to the serialized Object      * @return the Object at the given path      * @throws IOException      * @throws ClassNotFoundException      */     protected Object readExternalFormFromDisk(final String path) throws IOException, ClassNotFoundException {         try (FileInputStream stream = new FileInputStream(path)) {             return readExternalFormFromStream(stream);         }     }      /**      * Read a Serialized or Externalized Object from bytes.      * Useful for verifying serialization in memory.      *      * @param b byte array containing a serialized Object      * @return Object contained in the bytes      * @throws IOException      * @throws ClassNotFoundException      */     protected Object readExternalFormFromBytes(final byte[] b) throws IOException, ClassNotFoundException {         final ByteArrayInputStream stream = new ByteArrayInputStream(b);         return readExternalFormFromStream(stream);     }      protected boolean skipSerializedCanonicalTests() {         return Boolean.getBoolean("org.apache.commons.collections:with-clover");     }      // private implementation     //-----------------------------------------------------------------------     private Object readExternalFormFromStream(final InputStream stream) throws IOException, ClassNotFoundException {         final ObjectInputStream oStream = new ObjectInputStream(stream);         return oStream.readObject();     }      private void writeExternalFormToStream(final Serializable o, final OutputStream stream) throws IOException {         final ObjectOutputStream oStream = new ObjectOutputStream(stream);         oStream.writeObject(o);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import org.junit.Assert; import org.junit.Test;  public class SortedPropertiesFactoryTest extends AbstractPropertiesFactoryTest<SortedProperties> {      public SortedPropertiesFactoryTest(final String fileExtension) {         super(SortedPropertiesFactory.INSTANCE, fileExtension);     }      @Override     @Test     public void testInstance() {         Assert.assertNotNull(SortedPropertiesFactory.INSTANCE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.util.Properties;  import org.junit.Assert; import org.junit.Test;  public class PropertiesFactoryTest extends AbstractPropertiesFactoryTest<Properties> {      public PropertiesFactoryTest(final String fileExtension) {         super(PropertiesFactory.INSTANCE, fileExtension);     }      @Override     @Test     public void testInstance() {         Assert.assertNotNull(PropertiesFactory.INSTANCE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.PrintStream; import java.io.PrintWriter; import java.nio.charset.StandardCharsets; import java.util.HashMap; import java.util.Properties;  import org.apache.commons.io.input.NullReader; import org.apache.commons.lang3.ArrayUtils; import org.junit.Assert; import org.junit.Test;  public class EmptyPropertiesTest {      @Test     public void testClear() {         PropertiesFactory.EMPTY_PROPERTIES.clear();         Assert.assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());     }      @Test     public void testClone() {         // TODO Better test?         PropertiesFactory.EMPTY_PROPERTIES.clone();         Assert.assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());     }      @Test(expected = UnsupportedOperationException.class)     public void testCompute() {         PropertiesFactory.EMPTY_PROPERTIES.compute("key", (k, v) -> "foo");     }      @Test(expected = UnsupportedOperationException.class)     public void testComputeIfAbsent() {         PropertiesFactory.EMPTY_PROPERTIES.computeIfAbsent("key", k -> "foo");     }      @Test(expected = UnsupportedOperationException.class)     public void testComputeIfPresent() {         PropertiesFactory.EMPTY_PROPERTIES.computeIfPresent("key", (k, v) -> "foo");     }      @Test     public void testContains() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.contains("foo"));     }      @Test     public void testContainsKey() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.containsKey("foo"));     }      @Test     public void testContainsValue() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.containsValue("foo"));     }      @Test     public void testElements() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.elements().hasMoreElements());     }      @Test     public void testEntrySet() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.entrySet().isEmpty());     }      @Test     public void testEquals() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.equals(PropertiesFactory.EMPTY_PROPERTIES));         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.equals(new Properties()));         Assert.assertTrue(new Properties().equals(PropertiesFactory.EMPTY_PROPERTIES));         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.equals(null));         final Properties p = new Properties();         p.put("Key", "Value");         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.equals(p));         Assert.assertFalse(p.equals(PropertiesFactory.EMPTY_PROPERTIES));     }      public void testForEach() {         PropertiesFactory.EMPTY_PROPERTIES.forEach((k, v) -> Assert.fail());     }      @Test     public void testGet() {         Assert.assertNull(PropertiesFactory.EMPTY_PROPERTIES.get("foo"));     }      @Test     public void testGetOrDefault() {         Assert.assertEquals("bar", PropertiesFactory.EMPTY_PROPERTIES.getOrDefault("foo", "bar"));     }      @Test     public void testGetProperty() {         Assert.assertNull(PropertiesFactory.EMPTY_PROPERTIES.getProperty("foo"));     }      @Test     public void testGetPropertyDefault() {         Assert.assertEquals("bar", PropertiesFactory.EMPTY_PROPERTIES.getProperty("foo", "bar"));     }      @Test     public void testHashCode() {         Assert.assertEquals(PropertiesFactory.EMPTY_PROPERTIES.hashCode(),             PropertiesFactory.EMPTY_PROPERTIES.hashCode());         // Should be equals?         // Assert.assertEquals(PropertiesFactory.EMPTY_PROPERTIES.hashCode(), new Properties().hashCode());     }      @Test     public void testIsEmpty() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.isEmpty());     }      @Test     public void testKeys() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.keys().hasMoreElements());     }      @Test     public void testKeySet() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.keySet().isEmpty());     }      @Test     public void testListToPrintStream() {         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.list(new PrintStream(actual));         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().list(new PrintStream(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().list(new PrintStream(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testListToPrintWriter() {         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.list(new PrintWriter(actual));         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().list(new PrintWriter(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().list(new PrintWriter(expected));         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test(expected = UnsupportedOperationException.class)     public void testLoadFromXML() throws IOException {         PropertiesFactory.EMPTY_PROPERTIES.loadFromXML(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY));     }      @Test(expected = UnsupportedOperationException.class)     public void testLoadInputStream() throws IOException {         PropertiesFactory.EMPTY_PROPERTIES.load(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY));     }      @Test(expected = UnsupportedOperationException.class)     public void testLoadReader() throws IOException {         try (NullReader reader = new NullReader(0)) {             PropertiesFactory.EMPTY_PROPERTIES.load(reader);         }     }      @Test(expected = UnsupportedOperationException.class)     public void testMerge() {         PropertiesFactory.EMPTY_PROPERTIES.merge("key", "value", (k, v) -> "foo");     }      @Test     public void testPropertyName() {         Assert.assertFalse(PropertiesFactory.EMPTY_PROPERTIES.propertyNames().hasMoreElements());     }      @Test(expected = UnsupportedOperationException.class)     public void testPut() {         PropertiesFactory.EMPTY_PROPERTIES.put("Key", "Value");     }      @Test(expected = UnsupportedOperationException.class)     public void testPutAll() {         PropertiesFactory.EMPTY_PROPERTIES.putAll(new HashMap<>());     }      @Test(expected = UnsupportedOperationException.class)     public void testPutIfAbsent() {         PropertiesFactory.EMPTY_PROPERTIES.putIfAbsent("Key", "Value");     }      @Test     public void testRehash() {         // Can't really test without extending and casting to a currently private class         // PropertiesFactory.EMPTY_PROPERTIES.rehash();     }      @Test(expected = UnsupportedOperationException.class)     public void testRemove() {         PropertiesFactory.EMPTY_PROPERTIES.remove("key", "value");     }      @Test(expected = UnsupportedOperationException.class)     public void testRemoveKey() {         PropertiesFactory.EMPTY_PROPERTIES.remove("key");     }      @Test(expected = UnsupportedOperationException.class)     public void testReplace() {         PropertiesFactory.EMPTY_PROPERTIES.replace("key", "value1");     }      @Test(expected = UnsupportedOperationException.class)     public void testReplaceAll() {         PropertiesFactory.EMPTY_PROPERTIES.replaceAll((k, v) -> "value1");     }      @Test(expected = UnsupportedOperationException.class)     public void testReplaceOldValue() {         PropertiesFactory.EMPTY_PROPERTIES.replace("key", "value1", "value2");     }      @Test     public void testSave() throws IOException {         final String comments = "Hello world!";         // actual         try (ByteArrayOutputStream actual = new ByteArrayOutputStream()) {             try (PrintStream out = new PrintStream(actual)) {                 PropertiesFactory.EMPTY_PROPERTIES.save(out, comments);             }             // expected             try (ByteArrayOutputStream expected = new ByteArrayOutputStream()) {                 try (PrintStream out = new PrintStream(expected)) {                     PropertiesFactory.INSTANCE.createProperties().save(out, comments);                 }                 Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());                 expected.reset();                 try (PrintStream out = new PrintStream(expected)) {                     new Properties().save(out, comments);                 }                 Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());             }         }     }      @Test(expected = UnsupportedOperationException.class)     public void testSetProperty() {         PropertiesFactory.EMPTY_PROPERTIES.setProperty("Key", "Value");     }      @Test     public void testSize() {         Assert.assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());     }      @Test     public void testStoreToOutputStream() throws IOException {         final String comments = "Hello world!";         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.store(new PrintStream(actual), comments);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().store(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().store(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStoreToPrintWriter() throws IOException {         final String comments = "Hello world!";         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.store(new PrintWriter(actual), comments);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().store(new PrintWriter(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().store(new PrintWriter(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStoreToXMLOutputStream() throws IOException {         final String comments = "Hello world!";         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.storeToXML(new PrintStream(actual), comments);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().storeToXML(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().storeToXML(new PrintStream(expected), comments);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStoreToXMLOutputStreamWithEncoding() throws IOException {         final String comments = "Hello world!";         final String encoding = StandardCharsets.UTF_8.name();         // actual         final ByteArrayOutputStream actual = new ByteArrayOutputStream();         PropertiesFactory.EMPTY_PROPERTIES.storeToXML(new PrintStream(actual), comments, encoding);         // expected         final ByteArrayOutputStream expected = new ByteArrayOutputStream();         PropertiesFactory.INSTANCE.createProperties().storeToXML(new PrintStream(expected), comments, encoding);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());         expected.reset();         new Properties().storeToXML(new PrintStream(expected), comments, encoding);         Assert.assertArrayEquals(expected.toByteArray(), actual.toByteArray());     }      @Test     public void testStringPropertyName() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.stringPropertyNames().isEmpty());     }      @Test     public void testToString() {         Assert.assertEquals(new Properties().toString(), PropertiesFactory.EMPTY_PROPERTIES.toString());     }      @Test     public void testValues() {         Assert.assertTrue(PropertiesFactory.EMPTY_PROPERTIES.values().isEmpty());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.util.Enumeration;  import org.junit.Assert; import org.junit.Test;  public class SortedPropertiesTest {      @Test     public void testKeys() {         final SortedProperties sortedProperties = new SortedProperties();         for (char ch = 'Z'; ch >= 'A'; ch--) {             sortedProperties.put(String.valueOf(ch), "Value" + ch);         }         final Enumeration<Object> keys = sortedProperties.keys();         for (char ch = 'A'; ch <= 'Z'; ch++) {             Assert.assertEquals(String.valueOf(ch), keys.nextElement());         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.properties;  import java.io.BufferedReader; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; import java.util.Properties;  import org.apache.commons.collections4.BulkTest; import org.junit.Assert; import org.junit.Assume; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  @RunWith(Parameterized.class) public abstract class AbstractPropertiesFactoryTest<T extends Properties> {      @Parameters(name = "{0}")     public static Object[][] getParameters() {         return new Object[][] { { ".properties" }, { ".xml" } };      }      private final AbstractPropertiesFactory<T> factory;     private final String pathString;     private final String fileExtension;      protected AbstractPropertiesFactoryTest(final AbstractPropertiesFactory<T> factory, final String fileExtension) {         this.factory = factory;         this.fileExtension = fileExtension;         this.pathString = BulkTest.TEST_PROPERTIES_PATH + "test" + fileExtension;     }      private void assertContents(final T properties) {         Assert.assertEquals("value1", properties.getProperty("key1"));         Assert.assertEquals("value2", properties.getProperty("key2"));         Assert.assertEquals("value3", properties.getProperty("key3"));         Assert.assertEquals("value4", properties.getProperty("key4"));         Assert.assertEquals("value5", properties.getProperty("key5"));         Assert.assertEquals("value6", properties.getProperty("key6"));         Assert.assertEquals("value7", properties.getProperty("key7"));         Assert.assertEquals("value8", properties.getProperty("key8"));         Assert.assertEquals("value9", properties.getProperty("key9"));         Assert.assertEquals("value10", properties.getProperty("key10"));         Assert.assertEquals("value11", properties.getProperty("key11"));     }      private boolean isXmlTest() {         return ".xml".equals(fileExtension);     }      @Test     public void testInstance() {         Assert.assertNotNull(PropertiesFactory.INSTANCE);     }      @Test     public void testLoadClassLoaderMissingResource() throws Exception {         Assert.assertNull(factory.load(ClassLoader.getSystemClassLoader(), "missing/test" + fileExtension));     }      @Test     public void testLoadClassLoaderResource() throws Exception {         assertContents(factory.load(ClassLoader.getSystemClassLoader(), "org/apache/commons/collections4/properties/test" + fileExtension));     }      @Test     public void testLoadFile() throws Exception {         assertContents(factory.load(Paths.get(pathString).toFile()));     }      @Test     public void testLoadFileName() throws Exception {         assertContents(factory.load(pathString));     }      @Test     public void testLoadInputStream() throws Exception {         // Can't tell what we are reading         Assume.assumeFalse(isXmlTest());         //         try (FileInputStream inputStream = new FileInputStream(pathString)) {             assertContents(factory.load(inputStream));         }     }      @Test     public void testLoadPath() throws Exception {         assertContents(factory.load(Paths.get(pathString)));     }      @Test     public void testLoadReader() throws Exception {         // Can't tell what we are reading         Assume.assumeFalse(isXmlTest());         //         try (BufferedReader inputStream = Files.newBufferedReader(Paths.get(pathString))) {             assertContents(factory.load(inputStream));         }     }      @Test     public void testLoadUri() throws Exception {         assertContents(factory.load(Paths.get(pathString).toUri()));     }      @Test     public void testLoadUrl() throws Exception {         assertContents(factory.load(Paths.get(pathString).toUri().toURL()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import static org.junit.Assert.assertFalse; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Enumeration; import java.util.Hashtable; import java.util.Iterator; import java.util.List; import java.util.StringTokenizer; import java.util.Vector;  import org.junit.Test;  /**  * Tests EnumerationUtils.  *  */ public class EnumerationUtilsTest {      public static final String TO_LIST_FIXTURE = "this is a test";      @Test     public void getFromEnumeration() throws Exception {         // Enumeration, entry exists         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         Enumeration<String> en = vector.elements();         assertEquals("zero", EnumerationUtils.get(en, 0));         en = vector.elements();         assertEquals("one", EnumerationUtils.get(en, 1));          // Enumerator, non-existent entry         try {             EnumerationUtils.get(en, 3);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertTrue(!en.hasMoreElements());     }      @Test     public void testAsIterableFor() {         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         final Enumeration<String> en = vector.elements();         final Iterator<String> iterator = EnumerationUtils.asIterable(en).iterator();         assertTrue(iterator.hasNext());         assertEquals("zero", iterator.next());         assertTrue(iterator.hasNext());         assertEquals("one", iterator.next());         assertFalse(iterator.hasNext());     }      @Test     public void testAsIterableForNull() {         try {             EnumerationUtils.asIterable((Enumeration) null).iterator().next();             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testToListWithHashtable() {         final Hashtable<String, Integer> expected = new Hashtable<>();         expected.put("one", Integer.valueOf(1));         expected.put("two", Integer.valueOf(2));         expected.put("three", Integer.valueOf(3));         // validate elements.         final List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());         assertEquals(expected.size(), actualEltList.size());         assertTrue(actualEltList.contains(Integer.valueOf(1)));         assertTrue(actualEltList.contains(Integer.valueOf(2)));         assertTrue(actualEltList.contains(Integer.valueOf(3)));         final List<Integer> expectedEltList = new ArrayList<>();         expectedEltList.add(Integer.valueOf(1));         expectedEltList.add(Integer.valueOf(2));         expectedEltList.add(Integer.valueOf(3));         assertTrue(actualEltList.containsAll(expectedEltList));          // validate keys.         final List<String> actualKeyList = EnumerationUtils.toList(expected.keys());         assertEquals(expected.size(), actualEltList.size());         assertTrue(actualKeyList.contains("one"));         assertTrue(actualKeyList.contains("two"));         assertTrue(actualKeyList.contains("three"));         final List<String> expectedKeyList = new ArrayList<>();         expectedKeyList.add("one");         expectedKeyList.add("two");         expectedKeyList.add("three");         assertTrue(actualKeyList.containsAll(expectedKeyList));     }      @Test     public void testToListWithStringTokenizer() {         final List<String> expectedList1 = new ArrayList<>();         final StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);         while (st.hasMoreTokens()) {             expectedList1.add(st.nextToken());         }         final List<String> expectedList2 = new ArrayList<>();         expectedList2.add("this");         expectedList2.add("is");         expectedList2.add("a");         expectedList2.add("test");         final List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));         assertEquals(expectedList1, expectedList2);         assertEquals(expectedList1, actualList);         assertEquals(expectedList2, actualList);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.trie;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Trie; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.map.AbstractSortedMapTest;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the  * {@link UnmodifiableTrie} implementation.  *  * @since 4.0  */ public class UnmodifiableTrieTest<V> extends AbstractSortedMapTest<String, V> {      public UnmodifiableTrieTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableTrieTest.class);     }      //-------------------------------------------------------------------      @Override     public Trie<String, V> makeObject() {         return UnmodifiableTrie.unmodifiableTrie(new PatriciaTrie<V>());     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public Trie<String, V> makeFullMap() {         final Trie<String, V> m = new PatriciaTrie<>();         addSampleMappings(m);         return UnmodifiableTrie.unmodifiableTrie(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Trie<String, V> trie = makeFullMap();         assertSame(trie, UnmodifiableTrie.unmodifiableTrie(trie));          try {             UnmodifiableTrie.unmodifiableTrie(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return null;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableTrie.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableTrie.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.trie;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.map.AbstractOrderedMapTest;  /**  * JUnit test of the OrderedMap interface of a PatriciaTrie.  *  * @since 4.0  */ public class PatriciaTrie2Test<V> extends AbstractOrderedMapTest<String, V> {      public PatriciaTrie2Test(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PatriciaTrie2Test.class);     }      @Override     public OrderedMap<String, V> makeObject() {         return new PatriciaTrie<>();     }      @Override     public boolean isAllowNullKey() {         return false;     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.trie;  import java.util.ArrayList; import java.util.Arrays; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set; import java.util.SortedMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Trie; import org.apache.commons.collections4.map.AbstractSortedMapTest; import org.junit.Assert;  /**  * JUnit tests for the PatriciaTrie.  *  * @since 4.0  */ public class PatriciaTrieTest<V> extends AbstractSortedMapTest<String, V> {      public PatriciaTrieTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PatriciaTrieTest.class);     }      @Override     public SortedMap<String, V> makeObject() {         return new PatriciaTrie<>();     }      @Override     public boolean isAllowNullKey() {         return false;     }      //-----------------------------------------------------------------------      public void testPrefixMap() {         final PatriciaTrie<String> trie = new PatriciaTrie<>();          final String[] keys = new String[]{             "",             "Albert", "Xavier", "XyZ", "Anna", "Alien", "Alberto",             "Alberts", "Allie", "Alliese", "Alabama", "Banane",             "Blabla", "Amber", "Ammun", "Akka", "Akko", "Albertoo",             "Amma"         };          for (final String key : keys) {             trie.put(key, key);         }          SortedMap<String, String> map;         Iterator<String> iterator;         Iterator<Map.Entry<String, String>> entryIterator;         Map.Entry<String, String> entry;          map = trie.prefixMap("Al");         Assert.assertEquals(8, map.size());         Assert.assertEquals("Alabama", map.firstKey());         Assert.assertEquals("Alliese", map.lastKey());         Assert.assertEquals("Albertoo", map.get("Albertoo"));         Assert.assertNotNull(trie.get("Xavier"));         Assert.assertNull(map.get("Xavier"));         Assert.assertNull(trie.get("Alice"));         Assert.assertNull(map.get("Alice"));         iterator = map.values().iterator();         Assert.assertEquals("Alabama", iterator.next());         Assert.assertEquals("Albert", iterator.next());         Assert.assertEquals("Alberto", iterator.next());         Assert.assertEquals("Albertoo", iterator.next());         Assert.assertEquals("Alberts", iterator.next());         Assert.assertEquals("Alien", iterator.next());         Assert.assertEquals("Allie", iterator.next());         Assert.assertEquals("Alliese", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Albert");         iterator = map.keySet().iterator();         Assert.assertEquals("Albert", iterator.next());         Assert.assertEquals("Alberto", iterator.next());         Assert.assertEquals("Albertoo", iterator.next());         Assert.assertEquals("Alberts", iterator.next());         Assert.assertFalse(iterator.hasNext());         Assert.assertEquals(4, map.size());         Assert.assertEquals("Albert", map.firstKey());         Assert.assertEquals("Alberts", map.lastKey());         Assert.assertNull(trie.get("Albertz"));         map.put("Albertz", "Albertz");         Assert.assertEquals("Albertz", trie.get("Albertz"));         Assert.assertEquals(5, map.size());         Assert.assertEquals("Albertz", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Albert", iterator.next());         Assert.assertEquals("Alberto", iterator.next());         Assert.assertEquals("Albertoo", iterator.next());         Assert.assertEquals("Alberts", iterator.next());         Assert.assertEquals("Albertz", iterator.next());         Assert.assertFalse(iterator.hasNext());         Assert.assertEquals("Albertz", map.remove("Albertz"));          map = trie.prefixMap("Alberto");         Assert.assertEquals(2, map.size());         Assert.assertEquals("Alberto", map.firstKey());         Assert.assertEquals("Albertoo", map.lastKey());         entryIterator = map.entrySet().iterator();         entry = entryIterator.next();         Assert.assertEquals("Alberto", entry.getKey());         Assert.assertEquals("Alberto", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoo", entry.getKey());         Assert.assertEquals("Albertoo", entry.getValue());         Assert.assertFalse(entryIterator.hasNext());         trie.put("Albertoad", "Albertoad");         Assert.assertEquals(3, map.size());         Assert.assertEquals("Alberto", map.firstKey());         Assert.assertEquals("Albertoo", map.lastKey());         entryIterator = map.entrySet().iterator();         entry = entryIterator.next();         Assert.assertEquals("Alberto", entry.getKey());         Assert.assertEquals("Alberto", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoad", entry.getKey());         Assert.assertEquals("Albertoad", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoo", entry.getKey());         Assert.assertEquals("Albertoo", entry.getValue());         Assert.assertFalse(entryIterator.hasNext());         Assert.assertEquals("Albertoo", trie.remove("Albertoo"));         Assert.assertEquals("Alberto", map.firstKey());         Assert.assertEquals("Albertoad", map.lastKey());         Assert.assertEquals(2, map.size());         entryIterator = map.entrySet().iterator();         entry = entryIterator.next();         Assert.assertEquals("Alberto", entry.getKey());         Assert.assertEquals("Alberto", entry.getValue());         entry = entryIterator.next();         Assert.assertEquals("Albertoad", entry.getKey());         Assert.assertEquals("Albertoad", entry.getValue());         Assert.assertFalse(entryIterator.hasNext());         Assert.assertEquals("Albertoad", trie.remove("Albertoad"));         trie.put("Albertoo", "Albertoo");          map = trie.prefixMap("X");         Assert.assertEquals(2, map.size());         Assert.assertFalse(map.containsKey("Albert"));         Assert.assertTrue(map.containsKey("Xavier"));         Assert.assertFalse(map.containsKey("Xalan"));         iterator = map.values().iterator();         Assert.assertEquals("Xavier", iterator.next());         Assert.assertEquals("XyZ", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("An");         Assert.assertEquals(1, map.size());         Assert.assertEquals("Anna", map.firstKey());         Assert.assertEquals("Anna", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Anna", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Ban");         Assert.assertEquals(1, map.size());         Assert.assertEquals("Banane", map.firstKey());         Assert.assertEquals("Banane", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Banane", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Am");         Assert.assertFalse(map.isEmpty());         Assert.assertEquals(3, map.size());         Assert.assertEquals("Amber", trie.remove("Amber"));         iterator = map.keySet().iterator();         Assert.assertEquals("Amma", iterator.next());         Assert.assertEquals("Ammun", iterator.next());         Assert.assertFalse(iterator.hasNext());         iterator = map.keySet().iterator();         map.put("Amber", "Amber");         Assert.assertEquals(3, map.size());         try {             iterator.next();             Assert.fail("CME expected");         } catch(final ConcurrentModificationException expected) {}         Assert.assertEquals("Amber", map.firstKey());         Assert.assertEquals("Ammun", map.lastKey());          map = trie.prefixMap("Ak\0");         Assert.assertTrue(map.isEmpty());          map = trie.prefixMap("Ak");         Assert.assertEquals(2, map.size());         Assert.assertEquals("Akka", map.firstKey());         Assert.assertEquals("Akko", map.lastKey());         map.put("Ak", "Ak");         Assert.assertEquals("Ak", map.firstKey());         Assert.assertEquals("Akko", map.lastKey());         Assert.assertEquals(3, map.size());         trie.put("Al", "Al");         Assert.assertEquals(3, map.size());         Assert.assertEquals("Ak", map.remove("Ak"));         Assert.assertEquals("Akka", map.firstKey());         Assert.assertEquals("Akko", map.lastKey());         Assert.assertEquals(2, map.size());         iterator = map.keySet().iterator();         Assert.assertEquals("Akka", iterator.next());         Assert.assertEquals("Akko", iterator.next());         Assert.assertFalse(iterator.hasNext());         Assert.assertEquals("Al", trie.remove("Al"));          map = trie.prefixMap("Akka");         Assert.assertEquals(1, map.size());         Assert.assertEquals("Akka", map.firstKey());         Assert.assertEquals("Akka", map.lastKey());         iterator = map.keySet().iterator();         Assert.assertEquals("Akka", iterator.next());         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Ab");         Assert.assertTrue(map.isEmpty());         Assert.assertEquals(0, map.size());         try {             final Object o = map.firstKey();             Assert.fail("got a first key: " + o);         } catch(final NoSuchElementException nsee) {}         try {             final Object o = map.lastKey();             Assert.fail("got a last key: " + o);         } catch(final NoSuchElementException nsee) {}         iterator = map.values().iterator();         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("Albertooo");         Assert.assertTrue(map.isEmpty());         Assert.assertEquals(0, map.size());         try {             final Object o = map.firstKey();             Assert.fail("got a first key: " + o);         } catch(final NoSuchElementException nsee) {}         try {             final Object o = map.lastKey();             Assert.fail("got a last key: " + o);         } catch(final NoSuchElementException nsee) {}         iterator = map.values().iterator();         Assert.assertFalse(iterator.hasNext());          map = trie.prefixMap("");         Assert.assertSame(trie, map); // stricter than necessary, but a good check          map = trie.prefixMap("\0");         Assert.assertTrue(map.isEmpty());         Assert.assertEquals(0, map.size());         try {             final Object o = map.firstKey();             Assert.fail("got a first key: " + o);         } catch(final NoSuchElementException nsee) {}         try {             final Object o = map.lastKey();             Assert.fail("got a last key: " + o);         } catch(final NoSuchElementException nsee) {}         iterator = map.values().iterator();         Assert.assertFalse(iterator.hasNext());     }      public void testPrefixMapRemoval() {         final PatriciaTrie<String> trie = new PatriciaTrie<>();          final String[] keys = new String[]{             "Albert", "Xavier", "XyZ", "Anna", "Alien", "Alberto",             "Alberts", "Allie", "Alliese", "Alabama", "Banane",             "Blabla", "Amber", "Ammun", "Akka", "Akko", "Albertoo",             "Amma"         };          for (final String key : keys) {             trie.put(key, key);         }          SortedMap<String, String> map = trie.prefixMap("Al");         Assert.assertEquals(8, map.size());         Iterator<String> iter = map.keySet().iterator();         Assert.assertEquals("Alabama", iter.next());         Assert.assertEquals("Albert", iter.next());         Assert.assertEquals("Alberto", iter.next());         Assert.assertEquals("Albertoo", iter.next());         Assert.assertEquals("Alberts", iter.next());         Assert.assertEquals("Alien", iter.next());         iter.remove();         Assert.assertEquals(7, map.size());         Assert.assertEquals("Allie", iter.next());         Assert.assertEquals("Alliese", iter.next());         Assert.assertFalse(iter.hasNext());          map = trie.prefixMap("Ak");         Assert.assertEquals(2, map.size());         iter = map.keySet().iterator();         Assert.assertEquals("Akka", iter.next());         iter.remove();         Assert.assertEquals(1, map.size());         Assert.assertEquals("Akko", iter.next());         if (iter.hasNext()) {             Assert.fail("shouldn't have next (but was: " + iter.next() + ")");         }         Assert.assertFalse(iter.hasNext());     }      public void testPrefixMapSizes() {         // COLLECTIONS-525         final PatriciaTrie<String> aTree = new PatriciaTrie<>();         aTree.put("", "");         aTree.put("", "");         assertTrue(aTree.prefixMap("").containsKey(""));         assertEquals("", aTree.prefixMap("").get(""));         assertFalse(aTree.prefixMap("").isEmpty());         assertEquals(1, aTree.prefixMap("").size());         assertEquals(1, aTree.prefixMap("").keySet().size());         assertEquals(1, aTree.prefixMap("").entrySet().size());         assertEquals(1, aTree.prefixMap("").values().size());          aTree.clear();         aTree.put("", "");         aTree.put("", "");         assertEquals(2, aTree.prefixMap("").keySet().size());         assertEquals(2, aTree.prefixMap("").values().size());     }      public void testPrefixMapSizes2() {         final char u8000 = Character.toChars(32768)[0]; // U+8000 (1000000000000000)         final char char_b = 'b'; // 1100010          final PatriciaTrie<String> trie = new PatriciaTrie<>();         final String prefixString = "" + char_b;         final String longerString = prefixString + u8000;          assertEquals(1, prefixString.length());         assertEquals(2, longerString.length());          assertTrue(longerString.startsWith(prefixString));          trie.put(prefixString, "prefixString");         trie.put(longerString, "longerString");          assertEquals(2, trie.prefixMap(prefixString).size());         assertTrue(trie.prefixMap(prefixString).containsKey(longerString));     }      public void testPrefixMapClear() {         final Trie<String, Integer> trie = new PatriciaTrie<>();         trie.put("Anna", 1);         trie.put("Anael", 2);         trie.put("Analu", 3);         trie.put("Andreas", 4);         trie.put("Andrea", 5);         trie.put("Andres", 6);         trie.put("Anatole", 7);         final SortedMap<String, Integer> prefixMap = trie.prefixMap("And");         assertEquals(new HashSet<>(Arrays.asList("Andrea", "Andreas", "Andres")), prefixMap.keySet());         assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));          prefixMap.clear();         assertTrue(prefixMap.isEmpty());         assertTrue(prefixMap.keySet().isEmpty());         assertTrue(prefixMap.values().isEmpty());         assertEquals(new HashSet<>(Arrays.asList("Anael", "Analu", "Anatole", "Anna")), trie.keySet());         assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));     }      public void testPrefixMapClearNothing() {         final Trie<String, Integer> trie = new PatriciaTrie<>();         final SortedMap<String, Integer> prefixMap = trie.prefixMap("And");         assertEquals(new HashSet<String>(), prefixMap.keySet());         assertEquals(new ArrayList<Integer>(0), new ArrayList<>(prefixMap.values()));          prefixMap.clear();         assertTrue(prefixMap.isEmpty());         assertTrue(prefixMap.keySet().isEmpty());         assertTrue(prefixMap.values().isEmpty());         assertEquals(new HashSet<String>(), trie.keySet());         assertEquals(new ArrayList<Integer>(0), new ArrayList<>(trie.values()));     }      public void testPrefixMapClearUsingRemove() {         final Trie<String, Integer> trie = new PatriciaTrie<>();         trie.put("Anna", 1);         trie.put("Anael", 2);         trie.put("Analu", 3);         trie.put("Andreas", 4);         trie.put("Andrea", 5);         trie.put("Andres", 6);         trie.put("Anatole", 7);         final SortedMap<String, Integer> prefixMap = trie.prefixMap("And");         assertEquals(new HashSet<>(Arrays.asList("Andrea", "Andreas", "Andres")), prefixMap.keySet());         assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));          final Set<String> keys = new HashSet<>(prefixMap.keySet());         for (final String key : keys) {             prefixMap.remove(key);         }         assertTrue(prefixMap.keySet().isEmpty());         assertTrue(prefixMap.values().isEmpty());         assertEquals(new HashSet<>(Arrays.asList("Anael", "Analu", "Anatole", "Anna")), trie.keySet());         assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PatriciaTrie.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PatriciaTrie.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link PredicatedSet} implementation.  *  * @since 3.0  */ public class PredicatedSetTest<E> extends AbstractSetTest<E> {      public PredicatedSetTest(final String testName) {         super(testName);     }   //-------------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected PredicatedSet<E> decorateSet(final Set<E> set, final Predicate<? super E> predicate) {         return PredicatedSet.predicatedSet(set, predicate);     }      @Override     public PredicatedSet<E> makeObject() {         return decorateSet(new HashSet<E>(), truePredicate);     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] {"1", "3", "5", "7", "2", "4", "6"};     }  //--------------------------------------------------------------------      protected Predicate<E> testPredicate =         o -> o instanceof String;      protected PredicatedSet<E> makeTestSet() {         return decorateSet(new HashSet<E>(), testPredicate);     }      public void testGetSet() {         final PredicatedSet<E> set = makeTestSet();         assertTrue("returned set should not be null", set.decorated() != null);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final Set<E> set = makeTestSet();         final Integer i = Integer.valueOf(3);         try {             set.add((E) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !set.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final Set<E> set = makeTestSet();         final Set<E> elements = new HashSet<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) Integer.valueOf(3));         elements.add((E) "four");         try {             set.addAll(elements);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Set shouldn't contain illegal element", !set.contains("one"));         assertTrue("Set shouldn't contain illegal element", !set.contains("two"));         assertTrue("Set shouldn't contain illegal element", !set.contains(Integer.valueOf(3)));         assertTrue("Set shouldn't contain illegal element", !set.contains("four"));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.NavigableSet; import java.util.Set; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractNavigableSetTest} for exercising the  * {@link UnmodifiableNavigableSet} implementation.  *  * @since 4.1  */ public class UnmodifiableNavigableSetTest<E> extends AbstractNavigableSetTest<E> {     protected UnmodifiableNavigableSet<E> set = null;     protected ArrayList<E> array = null;      public UnmodifiableNavigableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableNavigableSetTest.class);     }      //-------------------------------------------------------------------     @Override     public NavigableSet<E> makeObject() {         return UnmodifiableNavigableSet.unmodifiableNavigableSet(new TreeSet<E>());     }      @Override     public UnmodifiableNavigableSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return (UnmodifiableNavigableSet<E>) UnmodifiableNavigableSet.unmodifiableNavigableSet(set);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //--------------------------------------------------------------------     @SuppressWarnings("unchecked")     protected void setupSet() {         set = makeFullCollection();         array = new ArrayList<>();         array.add((E) Integer.valueOf(1));     }      /**      * Verify that base set and subsets are not modifiable      */     @SuppressWarnings("unchecked")     public void testUnmodifiable() {         setupSet();         verifyUnmodifiable(set);         verifyUnmodifiable(set.descendingSet());         verifyUnmodifiable(set.headSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.headSet((E) Integer.valueOf(1), true));         verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1), false));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), (E) Integer.valueOf(3)));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), false, (E) Integer.valueOf(3), false));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), true, (E) Integer.valueOf(3), true));     }      public void testDecorateFactory() {         final NavigableSet<E> set = makeFullCollection();         assertSame(set, UnmodifiableNavigableSet.unmodifiableNavigableSet(set));          try {             UnmodifiableNavigableSet.unmodifiableNavigableSet(null);             fail();         } catch (final NullPointerException ex) {}     }      /**      * Verifies that a set is not modifiable      */     @SuppressWarnings("unchecked")     public void verifyUnmodifiable(final Set<E> set) {         try {             set.add((E) "value");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.addAll(new TreeSet<E>());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.clear();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.remove("x");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.removeAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.retainAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      public void testComparator() {         setupSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableNavigableSet.emptyCollection.version4.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableNavigableSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.IteratorUtils;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link ListOrderedSet} implementation.  *  * @since 3.0  */ public class ListOrderedSetTest<E>     extends AbstractSetTest<E> {      private static final Integer ZERO = Integer.valueOf(0);      private static final Integer ONE = Integer.valueOf(1);      private static final Integer TWO = Integer.valueOf(2);      private static final Integer THREE = Integer.valueOf(3);      public ListOrderedSetTest(final String testName) {         super(testName);     }      @Override     public ListOrderedSet<E> makeObject() {         return ListOrderedSet.listOrderedSet(new HashSet<E>());     }      @SuppressWarnings("unchecked")     protected ListOrderedSet<E> setupSet() {         final ListOrderedSet<E> set = makeObject();          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }         return set;     }      @SuppressWarnings("unchecked")     public void testOrdering() {         final ListOrderedSet<E> set = setupSet();         Iterator<E> it = set.iterator();          for (int i = 0; i < 10; i++) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i += 2) {             assertTrue("Must be able to remove int",                        set.remove(Integer.toString(i)));         }          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong after remove ",                          Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }          assertEquals("Size of set is wrong!", 10, set.size());          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }         for (int i = 0; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }     }      @SuppressWarnings("unchecked")     public void testListAddRemove() {         final ListOrderedSet<E> set = makeObject();         final List<E> view = set.asList();         set.add((E) ZERO);         set.add((E) ONE);         set.add((E) TWO);          assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));         assertEquals(3, view.size());         assertSame(ZERO, view.get(0));         assertSame(ONE, view.get(1));         assertSame(TWO, view.get(2));          assertEquals(0, set.indexOf(ZERO));         assertEquals(1, set.indexOf(ONE));         assertEquals(2, set.indexOf(TWO));          set.remove(1);         assertEquals(2, set.size());         assertSame(ZERO, set.get(0));         assertSame(TWO, set.get(1));         assertEquals(2, view.size());         assertSame(ZERO, view.get(0));         assertSame(TWO, view.get(1));     }      @SuppressWarnings("unchecked")     public void testListAddIndexed() {         final ListOrderedSet<E> set = makeObject();         set.add((E) ZERO);         set.add((E) TWO);          set.add(1, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          set.add(0, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          final List<E> list = new ArrayList<>();         list.add((E) ZERO);         list.add((E) TWO);          set.addAll(0, list);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          list.add(0, (E) THREE); // list = [3,0,2]         set.remove(TWO); //  set = [0,1]         set.addAll(1, list);         assertEquals(4, set.size());         assertSame(ZERO, set.get(0));         assertSame(THREE, set.get(1));         assertSame(TWO, set.get(2));         assertSame(ONE, set.get(3));     }      @SuppressWarnings("unchecked")     public void testListAddReplacing() {         final ListOrderedSet<E> set = makeObject();         final A a = new A();         final B b = new B();         set.add((E) a);         assertEquals(1, set.size());         set.add((E) b); // will match but not replace A as equal         assertEquals(1, set.size());         assertSame(a, set.decorated().iterator().next());         assertSame(a, set.iterator().next());         assertSame(a, set.get(0));         assertSame(a, set.asList().get(0));     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         final List<E> list = new ArrayList<>(10);         final Set<E> set = new HashSet<>(10);         final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(set, list);         for (int i = 0; i < 10; ++i) {             orderedSet.add((E) Integer.valueOf(10 - i - 1));         }          final Collection<E> retained = new ArrayList<>(5);         for (int i = 0; i < 5; ++i) {             retained.add((E) Integer.valueOf(i * 2));         }          assertTrue(orderedSet.retainAll(retained));         assertEquals(5, orderedSet.size());         // insertion order preserved?         assertEquals(Integer.valueOf(8), orderedSet.get(0));         assertEquals(Integer.valueOf(6), orderedSet.get(1));         assertEquals(Integer.valueOf(4), orderedSet.get(2));         assertEquals(Integer.valueOf(2), orderedSet.get(3));         assertEquals(Integer.valueOf(0), orderedSet.get(4));     }      @SuppressWarnings("unchecked")     public void testDuplicates() {         final List<E> list = new ArrayList<>(10);         list.add((E) Integer.valueOf(1));         list.add((E) Integer.valueOf(2));         list.add((E) Integer.valueOf(3));         list.add((E) Integer.valueOf(1));          final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(list);          assertEquals(3, orderedSet.size());         assertEquals(3, IteratorUtils.toArray(orderedSet.iterator()).length);          // insertion order preserved?         assertEquals(Integer.valueOf(1), orderedSet.get(0));         assertEquals(Integer.valueOf(2), orderedSet.get(1));         assertEquals(Integer.valueOf(3), orderedSet.get(2));     }      static class A {          @Override         public boolean equals(final Object obj) {             return obj instanceof A || obj instanceof B;         }          @Override         public int hashCode() {             return 1;         }     }      static class B {          @Override         public boolean equals(final Object obj) {             return obj instanceof A || obj instanceof B;         }          @Override         public int hashCode() {             return 1;         }     }      public void testDecorator() {         try {             ListOrderedSet.listOrderedSet((List<E>) null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet((Set<E>) null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet(null, null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet(new HashSet<E>(), null);             fail();         } catch (final NullPointerException ex) {         }         try {             ListOrderedSet.listOrderedSet(null, new ArrayList<E>());             fail();         } catch (final NullPointerException ex) {         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ListOrderedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/ListOrderedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Iterator; import java.util.SortedSet; import java.util.TreeSet;  import org.apache.commons.collections4.BulkTest;  /**  * Abstract test class for {@link SortedSet} methods and contracts.  * <p>  * To use, subclass and override the {@link #makeObject()}  * method.  You may have to override other protected methods if your  * set is not modifiable, or if your set restricts what kinds of  * elements may be added; see {@link AbstractSetTest} for more details.  *  * @since 3.0  */ public abstract class AbstractSortedSetTest<E> extends AbstractSetTest<E> {      /**      * JUnit constructor.      *      * @param name  name for test      */     public AbstractSortedSetTest(final String name) {         super(name);     }      //-----------------------------------------------------------------------     /**      * Verification extension, will check the order of elements,      * the sets should already be verified equal.      */     @Override     public void verify() {         super.verify();          // Check that iterator returns elements in order and first() and last()         // are consistent         final Iterator<E> colliter = getCollection().iterator();         final Iterator<E> confiter = getConfirmed().iterator();         E first = null;         E last = null;         while (colliter.hasNext()) {             if (first == null) {                 first = colliter.next();                 last = first;             } else {                 last = colliter.next();             }             assertEquals("Element appears to be out of order.", last, confiter.next());         }         if (getCollection().size() > 0) {             assertEquals("Incorrect element returned by first().", first,                 getCollection().first());             assertEquals("Incorrect element returned by last().", last,                 getCollection().last());         }     }      //-----------------------------------------------------------------------     /**      * Overridden because SortedSets don't allow null elements (normally).      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedSet<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedSet<E> makeFullCollection() {         return (SortedSet<E>) super.makeFullCollection();     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link TreeSet} for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public SortedSet<E> makeConfirmedCollection() {         return new TreeSet<>();     }      //-----------------------------------------------------------------------      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (E[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (E[]) elements;     }      //-----------------------------------------------------------------------     /**      * Bulk test {@link SortedSet#subSet(Object, Object)}.  This method runs through all of      * the tests in {@link AbstractSortedSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing a subset.      */     public BulkTest bulkTestSortedSetSubSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestSortedSetSubSet(lobound, hibound);      }      /**      * Bulk test {@link SortedSet#headSet(Object)}.  This method runs through all of      * the tests in {@link AbstractSortedSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing a headset.      */     public BulkTest bulkTestSortedSetHeadSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestSortedSetSubSet(hibound, true);     }      /**      * Bulk test {@link SortedSet#tailSet(Object)}.  This method runs through all of      * the tests in {@link AbstractSortedSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing a tailset.      */     public BulkTest bulkTestSortedSetTailSet() {         final int length = getFullElements().length;         final int lobound = length / 3;         return new TestSortedSetSubSet(lobound, false);     }      public class TestSortedSetSubSet extends AbstractSortedSetTest<E> {          private int m_Type;         private int m_LowBound;         private int m_HighBound;         private E[] m_FullElements;         private E[] m_OtherElements;          @SuppressWarnings("unchecked")         public TestSortedSetSubSet(final int bound, final boolean head) {             super("TestSortedSetSubSet");             if (head) {                 //System.out.println("HEADSET");                 m_Type = TYPE_HEADSET;                 m_HighBound = bound;                 m_FullElements = (E[]) new Object[bound];                 System.arraycopy(AbstractSortedSetTest.this.getFullElements(), 0, m_FullElements, 0, bound);                 m_OtherElements = (E[]) new Object[bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractSortedSetTest.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);                 //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));                 //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));             } else {                 //System.out.println("TAILSET");                 m_Type = TYPE_TAILSET;                 m_LowBound = bound;                 final Object[] allelements = AbstractSortedSetTest.this.getFullElements();                 //System.out.println("bound = "+bound +"::length="+allelements.length);                 m_FullElements = (E[]) new Object[allelements.length - bound];                 System.arraycopy(allelements, bound, m_FullElements, 0, allelements.length - bound);                 m_OtherElements = (E[]) new Object[allelements.length - bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractSortedSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);                 //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));                 //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));                 //resetFull();                 //System.out.println(collection);                 //System.out.println(confirmed);              }          } //type          @SuppressWarnings("unchecked")         public TestSortedSetSubSet(final int lobound, final int hibound) {             super("TestSortedSetSubSet");             //System.out.println("SUBSET");             m_Type = TYPE_SUBSET;             m_LowBound = lobound;             m_HighBound = hibound;             final int length = hibound - lobound;             //System.out.println("Low=" + lobound + "::High=" + hibound + "::Length=" + length);             m_FullElements = (E[]) new Object[length];             System.arraycopy(AbstractSortedSetTest.this.getFullElements(), lobound, m_FullElements, 0, length);             m_OtherElements = (E[]) new Object[length - 1];             System.arraycopy(//src src_pos dst dst_pos length                 AbstractSortedSetTest.this.getOtherElements(), lobound, m_OtherElements, 0, length - 1);              //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));             //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));          }          @Override         public boolean isNullSupported() {             return AbstractSortedSetTest.this.isNullSupported();         }         @Override         public boolean isAddSupported() {             return AbstractSortedSetTest.this.isAddSupported();         }         @Override         public boolean isRemoveSupported() {             return AbstractSortedSetTest.this.isRemoveSupported();         }         @Override         public boolean isFailFastSupported() {             return AbstractSortedSetTest.this.isFailFastSupported();         }          @Override         public E[] getFullElements() {             return m_FullElements;         }         @Override         public E[] getOtherElements() {             return m_OtherElements;         }          private SortedSet<E> getSubSet(final SortedSet<E> set) {             final E[] elements = AbstractSortedSetTest.this.getFullElements();             switch (m_Type) {             case TYPE_SUBSET :                 return set.subSet(elements[m_LowBound], elements[m_HighBound]);             case TYPE_HEADSET :                 return set.headSet(elements[m_HighBound]);             case TYPE_TAILSET :                 return set.tailSet(elements[m_LowBound]);             default :                 return null;             }         }          @Override         public SortedSet<E> makeObject() {             return getSubSet(AbstractSortedSetTest.this.makeObject());         }          @Override         public SortedSet<E> makeFullCollection() {             return getSubSet(AbstractSortedSetTest.this.makeFullCollection());         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public BulkTest bulkTestSortedSetSubSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetHeadSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetTailSet() {             return null;  // prevent infinite recursion         }          static final int TYPE_SUBSET = 0;         static final int TYPE_TAILSET = 1;         static final int TYPE_HEADSET = 2;      }      /**      * {@inheritDoc}      */     @Override     public SortedSet<E> getCollection() {         return (SortedSet<E>) super.getCollection();     }      /**      * {@inheritDoc}      */     @Override     public SortedSet<E> getConfirmed() {         return (SortedSet<E>) super.getConfirmed();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Set;  import org.apache.commons.collections4.map.HashedMap;  /**  * JUnit test.  *  * @since 3.1  */ public class MapBackedSetTest<E> extends AbstractSetTest<E> {      public MapBackedSetTest(final String testName) {         super(testName);     }      @Override     public Set<E> makeObject() {         return MapBackedSet.mapBackedSet(new HashedMap<E, Object>());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/MapBackedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/MapBackedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Collection; import java.util.List; import java.util.Set;  /**  * This class is used in CompositeSetTest. When testing serialization,  * the class has to be separate of CompositeSetTest, else the test  * class also has to be serialized.  */ class EmptySetMutator<E> implements CompositeSet.SetMutator<E> {      /** Serialization version */     private static final long serialVersionUID = 5321193666420238910L;      private final Set<E> contained;      EmptySetMutator(final Set<E> set) {         this.contained = set;     }      @Override     public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing, final Set<E> added, final Collection<E> intersects) {         throw new IllegalArgumentException();     }      @Override     public boolean add(final CompositeSet<E> composite, final List<Set<E>> collections, final E obj) {         return contained.add(obj);     }      @Override     public boolean addAll(final CompositeSet<E> composite, final List<Set<E>> collections, final Collection<? extends E> coll) {         return contained.addAll(coll);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Iterator; import java.util.Set;  import org.apache.commons.collections4.map.LinkedMap;  /**  * JUnit test.  *  * @since 3.1  */ public class MapBackedSet2Test<E> extends AbstractSetTest<E> {      public MapBackedSet2Test(final String testName) {         super(testName);     }      @Override     public Set<E> makeObject() {         return MapBackedSet.mapBackedSet(new LinkedMap<E, Object>());     }      @SuppressWarnings("unchecked")     protected Set<E> setupSet() {         final Set<E> set = makeObject();          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }         return set;     }      @SuppressWarnings("unchecked")     public void testOrdering() {         final Set<E> set = setupSet();         Iterator<E> it = set.iterator();          for (int i = 0; i < 10; i++) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i += 2) {             assertTrue("Must be able to remove int", set.remove(Integer.toString(i)));         }          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong after remove ", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }          assertEquals("Size of set is wrong!", 10, set.size());          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }         for (int i = 0; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }     }      @Override     public void testCanonicalEmptyCollectionExists() {     }      @Override     public void testCanonicalFullCollectionExists() {     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.set.CompositeSet.SetMutator;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link CompositeSet} implementation.  *  * @since 3.0  */ public class CompositeSetTest<E> extends AbstractSetTest<E> {     public CompositeSetTest(final String name) {         super(name);     }      @Override     public CompositeSet<E> makeObject() {         final HashSet<E> contained = new HashSet<>();         final CompositeSet<E> set = new CompositeSet<>(contained);         set.setMutator( new EmptySetMutator<>(contained) );         return set;     }      @SuppressWarnings("unchecked")     public Set<E> buildOne() {         final HashSet<E> set = new HashSet<>();         set.add((E) "1");         set.add((E) "2");         return set;     }      @SuppressWarnings("unchecked")     public Set<E> buildTwo() {         final HashSet<E> set = new HashSet<>();         set.add((E) "3");         set.add((E) "4");         return set;     }      @SuppressWarnings("unchecked")     public void testContains() {         final CompositeSet<E> set = new CompositeSet<>(new Set[]{ buildOne(), buildTwo() });         assertTrue(set.contains("1"));     }      @SuppressWarnings("unchecked")     public void testContainsAll() {         final CompositeSet<E> set = new CompositeSet<>(new Set[]{ buildOne(), buildTwo() });         assertFalse(set.containsAll(null));     }      @SuppressWarnings("unchecked")     public void testRemoveAll() {         final CompositeSet<E> set = new CompositeSet<>(new Set[]{ buildOne(), buildTwo() });         assertFalse(set.removeAll(null));     }      @SuppressWarnings("unchecked")     public void testRemoveUnderlying() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>(new Set[] { one, two });         one.remove("1");         assertFalse(set.contains("1"));          two.remove("3");         assertFalse(set.contains("3"));     }      @SuppressWarnings("unchecked")     public void testRemoveComposited() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>(new Set[] { one, two });         set.remove("1");         assertFalse(one.contains("1"));          set.remove("3");         assertFalse(one.contains("3"));     }      @SuppressWarnings("unchecked")     public void testFailedCollisionResolution() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>(new Set[] { one, two });         set.setMutator(new SetMutator<E>() {             private static final long serialVersionUID = 1L;              @Override             public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing,                 final Set<E> added, final Collection<E> intersects) {                 //noop             }              @Override             public boolean add(final CompositeSet<E> composite,                     final List<Set<E>> collections, final E obj) {                 throw new UnsupportedOperationException();             }              @Override             public boolean addAll(final CompositeSet<E> composite,                     final List<Set<E>> collections, final Collection<? extends E> coll) {                 throw new UnsupportedOperationException();             }         });          final HashSet<E> three = new HashSet<>();         three.add((E) "1");         try {             set.addComposited(three);             fail("IllegalArgumentException should have been thrown");         } catch (final IllegalArgumentException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testAddComposited() {         final Set<E> one = buildOne();         final Set<E> two = buildTwo();         final CompositeSet<E> set = new CompositeSet<>();         set.addComposited(one, two);         set.addComposited((Set<E>) null);         set.addComposited((Set<E>[]) null);         set.addComposited(null, null);         set.addComposited(null, null, null);         final CompositeSet<E> set2 = new CompositeSet<>(buildOne());         set2.addComposited(buildTwo());         assertTrue(set.equals(set2));         final HashSet<E> set3 = new HashSet<>();         set3.add((E) "1");         set3.add((E) "2");         set3.add((E) "3");         final HashSet<E> set4 = new HashSet<>();         set4.add((E) "4");         final CompositeSet<E> set5 = new CompositeSet<>(set3);         set5.addComposited(set4);         assertTrue(set.equals(set5));         try {             set.addComposited(set3);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testAddCompositedCollision() {         final HashSet<E> set1 = new HashSet<>();         set1.add((E) "1");         set1.add((E) "2");         set1.add((E) "3");         final HashSet<E> set2 = new HashSet<>();         set2.add((E) "4");         final CompositeSet<E> set3 = new CompositeSet<>(set1);         try {             set3.addComposited(set1, buildOne());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException ex) {             // expected         }         try {             set3.addComposited(set1, buildOne(), buildTwo());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException ex) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Comparator; import java.util.NavigableSet; import java.util.Set; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractNavigableSetTest} for exercising the  * {@link PredicatedNavigableSet} implementation.  *  * @since 4.1  */ public class PredicatedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {      public PredicatedNavigableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedNavigableSetTest.class);     }      //-------------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      @Override     public NavigableSet<E> makeObject() {         return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<E>(), truePredicate);     }      @Override     public NavigableSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return PredicatedNavigableSet.predicatedNavigableSet(set, truePredicate);     }  //--------------------------------------------------------------------     protected Predicate<E> testPredicate =         o -> o instanceof String && ((String) o).startsWith("A");      protected PredicatedNavigableSet<E> makeTestSet() {         return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<E>(), testPredicate);     }      public void testGetSet() {         final PredicatedNavigableSet<E> set = makeTestSet();         assertTrue("returned set should not be null", set.decorated() != null);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final NavigableSet<E> set = makeTestSet();         final String testString = "B";         try {             set.add((E) testString);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !set.contains(testString));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final NavigableSet<E> set = makeTestSet();         final Set<E> elements = new TreeSet<>();         elements.add((E) "Aone");         elements.add((E) "Atwo");         elements.add((E) "Bthree");         elements.add((E) "Afour");         try {             set.addAll(elements);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Set shouldn't contain illegal element", !set.contains("Aone"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Atwo"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Bthree"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Afour"));     }      public void testComparator() {         final NavigableSet<E> set = makeTestSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedNavigableSet.emptyCollection.version4.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedNavigableSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collections; import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSetTest} for exercising the {@link TransformedSet}  * implementation.  *  * @since 3.0  */ public class TransformedSetTest<E> extends AbstractSetTest<E> {      public TransformedSetTest(final String testName) {         super(testName);     }      @Override     public Set<E> makeConfirmedCollection() {         return new HashSet<>();     }      @Override     public Set<E> makeConfirmedFullCollection() {         return new HashSet<>(Arrays.asList(getFullElements()));     }      @Override     @SuppressWarnings("unchecked")     public Set<E> makeObject() {         return TransformedSet.transformingSet(new HashSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public Set<E> makeFullCollection() {         final Set<E> list = new HashSet<>(Arrays.asList(getFullElements()));         return TransformedSet.transformingSet(list,                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedSet() {         final Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, set.size());         final E[] els = (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < els.length; i++) {             set.add(els[i]);             assertEquals(i + 1, set.size());             assertEquals(true, set.contains(Integer.valueOf((String) els[i])));             assertEquals(false, set.contains(els[i]));         }          assertEquals(false, set.remove(els[0]));         assertEquals(true, set.remove(Integer.valueOf((String) els[0])));      }      public void testTransformedSet_decorateTransform() {         final Set<Object> originalSet = new HashSet<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalSet, els);         final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, set.size());         for (final Object el : els) {             assertEquals(true, set.contains(Integer.valueOf((String) el)));             assertEquals(false, set.contains(el));         }          assertEquals(false, set.remove(els[0]));         assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collections; import java.util.TreeSet; import java.util.Set; import java.util.SortedSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSortedSetTest} for exercising the {@link TransformedSortedSet}  * implementation.  *  * @since 3.0  */ public class TransformedSortedSetTest<E> extends AbstractSortedSetTest<E> {      public TransformedSortedSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedSortedSetTest.class);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public SortedSet<E> makeObject() {         return TransformedSortedSet.transformingSortedSet(new TreeSet<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public SortedSet<E> makeFullCollection() {         final SortedSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testTransformedSet() {         final SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, set.size());         final E[] els = (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < els.length; i++) {             set.add(els[i]);             assertEquals(i + 1, set.size());             assertEquals(true, set.contains(Integer.valueOf((String) els[i])));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      public void testTransformedSet_decorateTransform() {         final Set<Object> originalSet = new TreeSet<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalSet, els);         final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, set.size());         for (final Object el : els) {             assertEquals(true, set.contains(Integer.valueOf((String) el)));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSortedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedSortedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractSortedSetTest} for exercising the  * {@link UnmodifiableSortedSet} implementation.  *  * @since 3.0  */ public class UnmodifiableSortedSetTest<E> extends AbstractSortedSetTest<E> {     protected UnmodifiableSortedSet<E> set = null;     protected ArrayList<E> array = null;      public UnmodifiableSortedSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSortedSetTest.class);     }      //-------------------------------------------------------------------     @Override     public SortedSet<E> makeObject() {         return UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<E>());     }      @Override     public UnmodifiableSortedSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.unmodifiableSortedSet(set);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //--------------------------------------------------------------------     @SuppressWarnings("unchecked")     protected void setupSet() {         set = makeFullCollection();         array = new ArrayList<>();         array.add((E) Integer.valueOf(1));     }      /**      * Verify that base set and subsets are not modifiable      */     @SuppressWarnings("unchecked")     public void testUnmodifiable() {         setupSet();         verifyUnmodifiable(set);         verifyUnmodifiable(set.headSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1)));         verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), (E) Integer.valueOf(3)));     }      public void testDecorateFactory() {         final SortedSet<E> set = makeFullCollection();         assertSame(set, UnmodifiableSortedSet.unmodifiableSortedSet(set));          try {             UnmodifiableSortedSet.unmodifiableSortedSet(null);             fail();         } catch (final NullPointerException ex) {}     }      /**      * Verifies that a set is not modifiable      */     @SuppressWarnings("unchecked")     public void verifyUnmodifiable(final Set<E> set) {         try {             set.add((E) "value");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.addAll(new TreeSet<E>());             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.clear();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.remove("x");             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.removeAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             set.retainAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      public void testComparator() {         setupSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSortedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSortedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Comparator; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractSortedSetTest} for exercising the  * {@link PredicatedSortedSet} implementation.  *  * @since 3.0  */ public class PredicatedSortedSetTest<E> extends AbstractSortedSetTest<E> {      public PredicatedSortedSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedSortedSetTest.class);     }      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      @Override     public SortedSet<E> makeObject() {         return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), truePredicate);     }      @Override     public SortedSet<E> makeFullCollection() {         final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return PredicatedSortedSet.predicatedSortedSet(set, truePredicate);     }      protected Predicate<E> testPredicate =         o -> o instanceof String && ((String) o).startsWith("A");      protected PredicatedSortedSet<E> makeTestSet() {         return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), testPredicate);     }      public void testGetSet() {         final PredicatedSortedSet<E> set = makeTestSet();         assertTrue("returned set should not be null", set.decorated() != null);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final SortedSet<E> set = makeTestSet();         final String testString = "B";         try {             set.add((E) testString);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !set.contains(testString));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final SortedSet<E> set = makeTestSet();         final Set<E> elements = new TreeSet<>();         elements.add((E) "Aone");         elements.add((E) "Atwo");         elements.add((E) "Bthree");         elements.add((E) "Afour");         try {             set.addAll(elements);             fail("Should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Set shouldn't contain illegal element", !set.contains("Aone"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Atwo"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Bthree"));         assertTrue("Set shouldn't contain illegal element", !set.contains("Afour"));     }      public void testComparator() {         final SortedSet<E> set = makeTestSet();         final Comparator<? super E> c = set.comparator();         assertTrue("natural order, so comparator should be null", c == null);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSortedSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedSortedSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Iterator; import java.util.NavigableSet; import java.util.TreeSet;  import org.apache.commons.collections4.BulkTest;  /**  * Abstract test class for {@link NavigableSet} methods and contracts.  * <p>  * To use, subclass and override the {@link #makeObject()}  * method.  You may have to override other protected methods if your  * set is not modifiable, or if your set restricts what kinds of  * elements may be added; see {@link AbstractSetTest} for more details.  *  * @since 4.1  */ public abstract class AbstractNavigableSetTest<E> extends AbstractSortedSetTest<E> {      /**      * JUnit constructor.      *      * @param name  name for test      */     public AbstractNavigableSetTest(final String name) {         super(name);     }      //-----------------------------------------------------------------------     /**      * {@inheritDoc}      */     @Override     public abstract NavigableSet<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public NavigableSet<E> makeFullCollection() {         return (NavigableSet<E>) super.makeFullCollection();     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link TreeSet} for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public NavigableSet<E> makeConfirmedCollection() {         return new TreeSet<>();     }      //-----------------------------------------------------------------------      /**      * Verification extension, will check the order of elements,      * the sets should already be verified equal.      */     @Override     public void verify() {         super.verify();          // Check that descending iterator returns elements in order and higher(), lower(),         // floor() and ceiling() are consistent         final Iterator<E> colliter = getCollection().descendingIterator();         final Iterator<E> confiter = getConfirmed().descendingIterator();         while (colliter.hasNext()) {             final E element = colliter.next();             final E confelement = confiter.next();             assertEquals("Element appears to be out of order.", confelement, element);              assertEquals("Incorrect element returned by higher().", getConfirmed().higher(element),                                                                     getCollection().higher(element));              assertEquals("Incorrect element returned by lower().", getConfirmed().lower(element),                                                                    getCollection().lower(element));              assertEquals("Incorrect element returned by floor().", getConfirmed().floor(element),                                                                    getCollection().floor(element));              assertEquals("Incorrect element returned by ceiling().", getConfirmed().ceiling(element),                                                                      getCollection().ceiling(element));         }     }      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (E[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public E[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (E[]) elements;     }      //-----------------------------------------------------------------------     /**      * Bulk test {@link NavigableSet#subSet(Object, boolean, Object, boolean)}.      * This method runs through all of the tests in {@link AbstractNavigableSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractNavigableSetTest} instance for testing a subset.      */     public BulkTest bulkTestNavigableSetSubSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestNavigableSetSubSet(lobound, hibound, false);     }      /**      * Bulk test {@link NavigableSet#headSet(Object, boolean)}.      * This method runs through all of the tests in {@link AbstractNavigableSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractNavigableSetTest} instance for testing a headset.      */     public BulkTest bulkTestNavigableSetHeadSet() {         final int length = getFullElements().length;          final int lobound = length / 3;         final int hibound = lobound * 2;         return new TestNavigableSetSubSet(hibound, true, true);     }      /**      * Bulk test {@link NavigableSet#tailSet(Object, boolean)}.      * This method runs through all of the tests in {@link AbstractNavigableSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the set and the other collection views are still valid.      *      * @return a {@link AbstractNavigableSetTest} instance for testing a tailset.      */     public BulkTest bulkTestNavigableSetTailSet() {         final int length = getFullElements().length;         final int lobound = length / 3;         return new TestNavigableSetSubSet(lobound, false, false);     }      public class TestNavigableSetSubSet extends AbstractNavigableSetTest<E> {          private int m_Type;         private int m_LowBound;         private int m_HighBound;         private E[] m_FullElements;         private E[] m_OtherElements;         private boolean m_Inclusive;          @SuppressWarnings("unchecked")         public TestNavigableSetSubSet(final int bound, final boolean head, final boolean inclusive) {             super("TestNavigableSetSubSet");             if (head) {                 m_Type = TYPE_HEADSET;                 m_Inclusive = inclusive;                 m_HighBound = bound;                  final int realBound = inclusive ? bound + 1 : bound;                 m_FullElements = (E[]) new Object[realBound];                 System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), 0, m_FullElements, 0, realBound);                 m_OtherElements = (E[]) new Object[bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractNavigableSetTest.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);             } else {                 m_Type = TYPE_TAILSET;                 m_Inclusive = inclusive;                 m_LowBound = bound;                 final Object[] allelements = AbstractNavigableSetTest.this.getFullElements();                 final int realBound = inclusive ? bound : bound + 1;                 m_FullElements = (E[]) new Object[allelements.length - realBound];                 System.arraycopy(allelements, realBound, m_FullElements, 0, allelements.length - realBound);                 m_OtherElements = (E[]) new Object[allelements.length - bound - 1];                 System.arraycopy(//src src_pos dst dst_pos length                     AbstractNavigableSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);             }          } //type          @SuppressWarnings("unchecked")         public TestNavigableSetSubSet(final int lobound, final int hibound, final boolean inclusive) {             super("TestNavigableSetSubSet");             m_Type = TYPE_SUBSET;             m_LowBound = lobound;             m_HighBound = hibound;             m_Inclusive = inclusive;              final int fullLoBound = inclusive ? lobound : lobound + 1;             final int length = hibound - lobound + 1 - (inclusive ? 0 : 2);             m_FullElements = (E[]) new Object[length];             System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, m_FullElements, 0, length);             final int otherLength = hibound - lobound;             m_OtherElements = (E[]) new Object[otherLength - 1];             System.arraycopy(//src src_pos dst dst_pos length                 AbstractNavigableSetTest.this.getOtherElements(), lobound, m_OtherElements, 0, otherLength - 1);         }          @Override         public boolean isNullSupported() {             return AbstractNavigableSetTest.this.isNullSupported();         }         @Override         public boolean isAddSupported() {             return AbstractNavigableSetTest.this.isAddSupported();         }         @Override         public boolean isRemoveSupported() {             return AbstractNavigableSetTest.this.isRemoveSupported();         }         @Override         public boolean isFailFastSupported() {             return AbstractNavigableSetTest.this.isFailFastSupported();         }          @Override         public E[] getFullElements() {             return m_FullElements;         }         @Override         public E[] getOtherElements() {             return m_OtherElements;         }          private NavigableSet<E> getSubSet(final NavigableSet<E> set) {             final E[] elements = AbstractNavigableSetTest.this.getFullElements();             switch (m_Type) {             case TYPE_SUBSET :                 return set.subSet(elements[m_LowBound], m_Inclusive, elements[m_HighBound], m_Inclusive);             case TYPE_HEADSET :                 return set.headSet(elements[m_HighBound], m_Inclusive);             case TYPE_TAILSET :                 return set.tailSet(elements[m_LowBound], m_Inclusive);             default :                 return null;             }         }          @Override         public NavigableSet<E> makeObject() {             return getSubSet(AbstractNavigableSetTest.this.makeObject());         }          @Override         public NavigableSet<E> makeFullCollection() {             return getSubSet(AbstractNavigableSetTest.this.makeFullCollection());         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public BulkTest bulkTestSortedSetSubSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetHeadSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestSortedSetTailSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestNavigableSetSubSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestNavigableSetHeadSet() {             return null;  // prevent infinite recursion         }         @Override         public BulkTest bulkTestNavigableSetTailSet() {             return null;  // prevent infinite recursion         }          static final int TYPE_SUBSET = 0;         static final int TYPE_TAILSET = 1;         static final int TYPE_HEADSET = 2;      }      /**      * {@inheritDoc}      */     @Override     public NavigableSet<E> getCollection() {         return (NavigableSet<E>) super.getCollection();     }      /**      * {@inheritDoc}      */     @Override     public NavigableSet<E> getConfirmed() {         return (NavigableSet<E>) super.getConfirmed();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.HashSet; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractSetTest} for exercising the  * {@link UnmodifiableSet} implementation.  *  * @since 3.0  */ public class UnmodifiableSetTest<E> extends AbstractSetTest<E> {      public UnmodifiableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSetTest.class);     }      //-------------------------------------------------------------------     @Override     public Set<E> makeObject() {         return UnmodifiableSet.unmodifiableSet(new HashSet<E>());     }      @Override     public Set<E> makeFullCollection() {         final HashSet<E> set = new HashSet<>(Arrays.asList(getFullElements()));         return UnmodifiableSet.unmodifiableSet(set);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Set<E> set = makeFullCollection();         assertSame(set, UnmodifiableSet.unmodifiableSet(set));          try {             UnmodifiableSet.unmodifiableSet(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSet.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableSet.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Abstract test class for {@link Set} methods and contracts.  * <p>  * Since {@link Set} doesn't stipulate much new behavior that isn't already  * found in {@link Collection}, this class basically just adds tests for  * {@link Set#equals} and {@link Set#hashCode()} along with an updated  * {@link #verify()} that ensures elements do not appear more than once in the  * set.  * <p>  * To use, subclass and override the {@link #makeObject()}  * method.  You may have to override other protected methods if your  * set is not modifiable, or if your set restricts what kinds of  * elements may be added; see {@link AbstractCollectionTest} for more details.  *  * @since 3.0  */ public abstract class AbstractSetTest<E> extends AbstractCollectionTest<E> {      /**      * JUnit constructor.      *      * @param name  name for test      */     public AbstractSetTest(final String name) {         super(name);     }      //-----------------------------------------------------------------------     /**      * Provides additional verifications for sets.      */     @Override     public void verify() {         super.verify();          assertEquals("Sets should be equal", getConfirmed(), getCollection());         assertEquals("Sets should have equal hashCodes",                      getConfirmed().hashCode(), getCollection().hashCode());         final Collection<E> set = makeConfirmedCollection();         for (final E element : getCollection()) {             assertTrue("Set.iterator should only return unique elements", set.add(element));         }     }      //-----------------------------------------------------------------------     /**      * Set equals method is defined.      */     @Override     public boolean isEqualsCheckable() {         return true;     }      /**      * Returns an empty Set for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public Collection<E> makeConfirmedCollection() {         return new HashSet<>();     }      /**      * Returns a full Set for use in modification testing.      *      * @return a confirmed full collection      */     @Override     public Collection<E> makeConfirmedFullCollection() {         final Collection<E> set = makeConfirmedCollection();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      /**      * Makes an empty set.  The returned set should have no elements.      *      * @return an empty set      */     @Override     public abstract Set<E> makeObject();      /**      * Makes a full set by first creating an empty set and then adding      * all the elements returned by {@link #getFullElements()}.      *      * Override if your set does not support the add operation.      *      * @return a full set      */     @Override     public Set<E> makeFullCollection() {         final Set<E> set = makeObject();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      //-----------------------------------------------------------------------     /**      * Return the {@link AbstractCollectionTest#collection} fixture, but cast as a Set.      */     @Override     public Set<E> getCollection() {         return (Set<E>) super.getCollection();     }      /**      * Return the {@link AbstractCollectionTest#confirmed} fixture, but cast as a Set.      */     @Override     public Set<E> getConfirmed() {         return (Set<E>) super.getConfirmed();     }      //-----------------------------------------------------------------------     /**      * Tests {@link Set#equals(Object)}.      */     @SuppressWarnings("unchecked")     public void testSetEquals() {         resetEmpty();         assertEquals("Empty sets should be equal", getCollection(), getConfirmed());         verify();          final Collection<E> set2 = makeConfirmedCollection();         set2.add((E) "foo");         assertTrue("Empty set shouldn't equal nonempty set", !getCollection().equals(set2));          resetFull();         assertEquals("Full sets should be equal", getCollection(), getConfirmed());         verify();          set2.clear();         set2.addAll(Arrays.asList(getOtherElements()));         assertTrue("Sets with different contents shouldn't be equal", !getCollection().equals(set2));     }      /**      * Tests {@link Set#hashCode()}.      */     public void testSetHashCode() {         resetEmpty();         assertEquals("Empty sets have equal hashCodes",                 getCollection().hashCode(), getConfirmed().hashCode());          resetFull();         assertEquals("Equal sets have equal hashCodes",                 getCollection().hashCode(), getConfirmed().hashCode());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.ArrayList; import java.util.Iterator; import java.util.List;  /**  * Extension of {@link AbstractSetTest} for exercising the {@link ListOrderedSet}  * implementation.  *  * @since 3.1  */ public class ListOrderedSet2Test<E> extends AbstractSetTest<E> {      private static final Integer ZERO = Integer.valueOf(0);     private static final Integer ONE = Integer.valueOf(1);     private static final Integer TWO = Integer.valueOf(2);     private static final Integer THREE = Integer.valueOf(3);      public ListOrderedSet2Test(final String testName) {         super(testName);     }      @Override     public ListOrderedSet<E> makeObject() {         return new ListOrderedSet<>();     }      @SuppressWarnings("unchecked")     protected ListOrderedSet<E> setupSet() {         final ListOrderedSet<E> set = makeObject();          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }         return set;     }      @SuppressWarnings("unchecked")     public void testOrdering() {         final ListOrderedSet<E> set = setupSet();         Iterator<E> it = set.iterator();          for (int i = 0; i < 10; i++) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i += 2) {             assertTrue("Must be able to remove int", set.remove(Integer.toString(i)));         }          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong after remove ", Integer.toString(i), it.next());         }          for (int i = 0; i < 10; i++) {             set.add((E) Integer.toString(i));         }          assertEquals("Size of set is wrong!", 10, set.size());          it = set.iterator();         for (int i = 1; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }         for (int i = 0; i < 10; i += 2) {             assertEquals("Sequence is wrong", Integer.toString(i), it.next());         }     }      @SuppressWarnings("unchecked")     public void testListAddRemove() {         final ListOrderedSet<E> set = makeObject();         final List<E> view = set.asList();         set.add((E) ZERO);         set.add((E) ONE);         set.add((E) TWO);          assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));         assertEquals(3, view.size());         assertSame(ZERO, view.get(0));         assertSame(ONE, view.get(1));         assertSame(TWO, view.get(2));          assertEquals(0, set.indexOf(ZERO));         assertEquals(1, set.indexOf(ONE));         assertEquals(2, set.indexOf(TWO));          set.remove(1);         assertEquals(2, set.size());         assertSame(ZERO, set.get(0));         assertSame(TWO, set.get(1));         assertEquals(2, view.size());         assertSame(ZERO, view.get(0));         assertSame(TWO, view.get(1));     }      @SuppressWarnings("unchecked")     public void testListAddIndexed() {         final ListOrderedSet<E> set = makeObject();         set.add((E) ZERO);         set.add((E) TWO);          set.add(1, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          set.add(0, (E) ONE);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          final List<E> list = new ArrayList<>();         list.add((E) ZERO);         list.add((E) TWO);          set.addAll(0, list);         assertEquals(3, set.size());         assertSame(ZERO, set.get(0));         assertSame(ONE, set.get(1));         assertSame(TWO, set.get(2));          list.add(0, (E) THREE); // list = [3,0,2]         set.remove(TWO);    //  set = [0,1]         set.addAll(1, list);         assertEquals(4, set.size());         assertSame(ZERO, set.get(0));         assertSame(THREE, set.get(1));         assertSame(TWO, set.get(2));         assertSame(ONE, set.get(3));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) collection, "D:/dev/collections/data/test/ListOrderedSet.emptyCollection.version3.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) collection, "D:/dev/collections/data/test/ListOrderedSet.fullCollection.version3.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.set;  import java.util.Arrays; import java.util.Collections; import java.util.NavigableSet; import java.util.TreeSet; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractNavigableSetTest} for exercising the  * {@link TransformedNavigableSet} implementation.  *  * @since 4.1  */ public class TransformedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {      public TransformedNavigableSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedNavigableSetTest.class);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public NavigableSet<E> makeObject() {         return TransformedNavigableSet.transformingNavigableSet(new TreeSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public NavigableSet<E> makeFullCollection() {         final NavigableSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));         return TransformedNavigableSet.transformingNavigableSet(set,                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testTransformedSet() {         final NavigableSet<E> set = TransformedNavigableSet.transformingNavigableSet(new TreeSet<E>(),                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, set.size());         final E[] els = (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < els.length; i++) {             set.add(els[i]);             assertEquals(i + 1, set.size());             assertEquals(true, set.contains(Integer.valueOf((String) els[i])));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      public void testTransformedSet_decorateTransform() {         final Set<Object> originalSet = new TreeSet<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalSet, els);         final Set<?> set = TransformedSet.transformedSet(originalSet,                 TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, set.size());         for (final Object el : els) {             assertEquals(true, set.contains(Integer.valueOf((String) el)));         }          assertEquals(true, set.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedNavigableSet.emptyCollection.version4.1.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedNavigableSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Closure; import org.junit.Assert; import org.junit.Test;  public abstract class AbstractClosureTest {      @Test     public void closureSanityTests() throws Exception {         final Closure<?> closure = generateClosure();         Assert.assertNotNull(closure);     }      /**      * @return a closure for general sanity tests.      */     protected abstract <T> Closure<T> generateClosure(); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import static org.apache.commons.collections4.functors.ComparatorPredicate.*;  import java.util.Comparator;  import org.apache.commons.collections4.Predicate; import org.junit.Test;   public class ComparatorPredicateTest extends AbstractPredicateTest {     private class TestComparator<T extends Comparable<T>> implements Comparator<T> {         @Override         public int compare(final T first, final T second) {             return first.compareTo(second);         }     }      @Test     public void compareEquals() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());         assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));         assertPredicateTrue(p, Integer.valueOf(value.intValue()));         assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareGreater() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);         assertPredicateTrue(p, Integer.valueOf(value.intValue() - 1));         assertPredicateFalse(p, Integer.valueOf(value.intValue()));         assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareLess() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);         assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));         assertPredicateFalse(p, Integer.valueOf(value.intValue()));         assertPredicateTrue(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareGreaterOrEqual() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);         assertPredicateTrue(p, Integer.valueOf(value.intValue() - 1));         assertPredicateTrue(p, Integer.valueOf(value.intValue()));         assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));     }      @Test     public void compareLessOrEqual() {         final Integer value = Integer.valueOf(10);         final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);         assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));         assertPredicateTrue(p, Integer.valueOf(value.intValue()));         assertPredicateTrue(p, Integer.valueOf(value.intValue() + 1));     }      @Override     protected Predicate<?> generatePredicate() {         return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List;  import org.apache.commons.collections4.Predicate; import org.junit.Assert; import org.junit.Test;  /**  * Base class for tests of composite predicates.  *  * @since 3.0  */ public abstract class AbstractCompositePredicateTest<T> extends AbstractMockPredicateTest<T> {      /**      * Creates a new {@code TestCompositePredicate}.      *      * @param testValue the value which the mock predicates should expect to see (may be null).      */     protected AbstractCompositePredicateTest(final T testValue) {         super(testValue);     }      /**      * Creates an instance of the predicate to test.      *      * @param predicates the arguments to {@code getInstance}.      *      * @return a predicate to test.      */     protected abstract Predicate<T> getPredicateInstance(Predicate<? super T>... predicates);      /**      * Creates an instance of the predicate to test.      *      * @param predicates the argument to {@code getInstance}.      *      * @return a predicate to test.      */     protected abstract Predicate<T> getPredicateInstance(Collection<Predicate<T>> predicates);      /**      * Creates an instance of the predicate to test.      *      * @param mockReturnValues the return values for the mock predicates, or null if that mock is not expected      *                         to be called      *      * @return a predicate to test.      */     protected final Predicate<T> getPredicateInstance(final Boolean... mockReturnValues) {         final List<Predicate<T>> predicates = new ArrayList<>();         for (final Boolean returnValue : mockReturnValues) {             predicates.add(createMockPredicate(returnValue));         }         return getPredicateInstance(predicates);     }      /**      * Tests whether {@code getInstance} with a one element array returns the first element in the array.      */     @SuppressWarnings("unchecked")     public void singleElementArrayToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(predicate);         Assert.assertSame("expected argument to be returned by getInstance()", predicate, allPredicate);     }      /**      * Tests that passing a singleton collection to {@code getInstance} returns the single element in the      * collection.      */     public void singletonCollectionToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(                 Collections.<Predicate<T>>singleton(predicate));         Assert.assertSame("expected argument to be returned by getInstance()", predicate, allPredicate);     }      /**      * Tests {@code getInstance} with a null predicate array.      */     @Test(expected = NullPointerException.class)     public final void nullArrayToGetInstance() {         getPredicateInstance((Predicate<T>[]) null);     }      /**      * Tests {@code getInstance} with a single null element in the predicate array.      */     @SuppressWarnings({"unchecked"})     @Test(expected = NullPointerException.class)     public final void nullElementInArrayToGetInstance() {         getPredicateInstance(new Predicate[] { null });     }      /**      * Tests {@code getInstance} with two null elements in the predicate array.      */     @SuppressWarnings({"unchecked"})     @Test(expected = NullPointerException.class)     public final void nullElementsInArrayToGetInstance() {         getPredicateInstance(new Predicate[] { null, null });     }       /**      * Tests {@code getInstance} with a null predicate collection      */     @Test(expected = NullPointerException.class)     public final void nullCollectionToGetInstance() {         getPredicateInstance((Collection<Predicate<T>>) null);     }      /**      * Tests {@code getInstance} with a predicate collection that contains null elements      */     @Test(expected = NullPointerException.class)     public final void nullElementsInCollectionToGetInstance() {         final Collection<Predicate<T>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         getPredicateInstance(coll);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Predicate;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import org.junit.Test;  import java.util.Collections;  /**  * Base class for tests of AnyPredicate, AllPredicate, and OnePredicate.  *  * @since 3.0  */ public abstract class AbstractAnyAllOnePredicateTest<T> extends AbstractCompositePredicateTest<T> {      /**      * Creates a new {@code TestCompositePredicate}.      *      * @param testValue the value which the mock predicates should expect to see (may be null).      */     protected AbstractAnyAllOnePredicateTest(final T testValue) {         super(testValue);     }      /**      * Tests whether {@code getInstance} with a one element array returns the first element in the array.      */     @Override     @SuppressWarnings("unchecked")     @Test     public final void singleElementArrayToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(predicate);         assertSame("expected argument to be returned by getInstance()", predicate, allPredicate);     }      /**      * Tests that passing a singleton collection to {@code getInstance} returns the single element in the      * collection.      */     @Override     @Test     public final void singletonCollectionToGetInstance() {         final Predicate<T> predicate = createMockPredicate(null);         final Predicate<T> allPredicate = getPredicateInstance(                 Collections.<Predicate<T>>singleton(predicate));         assertSame("expected singleton collection member to be returned by getInstance()",                 predicate, allPredicate);     }      /**      * Tests creating composite predicate instances with single predicates and verifies that the composite returns      * the same value as the single predicate does.      */     @SuppressWarnings("boxing")     public final void singleValues() {         assertTrue(getPredicateInstance(true).evaluate(null));         assertFalse(getPredicateInstance(false).evaluate(null));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate; import static org.junit.Assert.assertSame;  import org.apache.commons.collections4.Predicate; import org.junit.Test;  public class NullPredicateTest extends AbstractPredicateTest {     @Test     public void testNullPredicate() {         assertSame(NullPredicate.nullPredicate(), NullPredicate.nullPredicate());         assertPredicateTrue(nullPredicate(), null);     }      @Test     public void ensurePredicateCanBeTypedWithoutWarning() throws Exception {         final Predicate<String> predicate = NullPredicate.nullPredicate();         assertPredicateFalse(predicate, cString);     }      @Override     protected Predicate<?> generatePredicate() {         return nullPredicate();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import java.util.ArrayList; import java.util.List;  import static org.easymock.EasyMock.verify; import static org.easymock.EasyMock.replay; import org.junit.Before; import org.junit.After; import org.apache.commons.collections4.Predicate; import org.easymock.EasyMock;  /**  * Base class for tests of predicates which delegate to other predicates when evaluating an object.  This class  * provides methods to create and verify mock predicates to which to delegate.  *  * @since 3.0  */ public abstract class AbstractMockPredicateTest<T> {     /**      * Mock predicates created by a single test case which need to be verified after the test completes.      */     private List<Predicate<? super T>> mockPredicatesToVerify;      /**      * The value to pass to mocks.      */     private final T testValue;      /**      * Creates a new {@code PredicateTestBase}.      *      * @param testValue the value to pass to mock predicates.      */     protected AbstractMockPredicateTest(final T testValue) {         this.testValue = testValue;     }      /**      * Creates the list of predicates to verify.      */     @Before     public final void createVerifyList() {         mockPredicatesToVerify = new ArrayList<>();     }      /**      * Verifies all the mock predicates created for the test.      */     @After     public final void verifyPredicates() {         for (final Predicate<? super T> predicate : mockPredicatesToVerify) {             verify(predicate);         }     }      /**      * Gets the value which will be passed to the mock predicates.      *      * @return the test value.      */     protected final T getTestValue() {         return testValue;     }      /**      * Creates a single mock predicate.      *      * @param returnValue the return value for the mock predicate, or null if the mock is not expected to be called.      *      * @return a single mock predicate.      */     @SuppressWarnings({"boxing"})     protected final Predicate<T> createMockPredicate(final Boolean returnValue) {         final Predicate<T> mockPredicate = EasyMock.createMock(Predicate.class);         if (returnValue != null) {             EasyMock.expect(mockPredicate.evaluate(testValue)).andReturn(returnValue);         }         replay(mockPredicate);         mockPredicatesToVerify.add(mockPredicate);          return mockPredicate;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate; import static org.junit.Assert.assertSame;  import org.apache.commons.collections4.Predicate; import org.junit.Test;   public class EqualPredicateTest extends AbstractPredicateTest {     private static final EqualsTestObject FALSE_OBJECT = new EqualsTestObject(false);     private static final EqualsTestObject TRUE_OBJECT = new EqualsTestObject(true);      @Override     protected Predicate<Object> generatePredicate() {         return equalPredicate(null);     }      @Test     public void testNullArgumentEqualsNullPredicate() throws Exception {         assertSame(nullPredicate(), equalPredicate(null));     }      @Test     public void objectFactoryUsesEqualsForTest() throws Exception {         final Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);         assertPredicateFalse(predicate, FALSE_OBJECT);         assertPredicateTrue(equalPredicate(TRUE_OBJECT), TRUE_OBJECT);     }      @SuppressWarnings("boxing")     @Test     public void testPredicateTypeCanBeSuperClassOfObject() throws Exception {         final Predicate<Number> predicate = equalPredicate((Number) 4);         assertPredicateTrue(predicate, 4);     }      public static class EqualsTestObject {         private final boolean b;          public EqualsTestObject(final boolean b) {             this.b = b;         }          @Override         public boolean equals(final Object obj) {             return b;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import java.io.IOException;  import org.apache.commons.collections4.Closure; import org.apache.commons.collections4.FunctorException; import org.junit.Assert; import org.junit.Test;  public class CatchAndRethrowClosureTest extends AbstractClosureTest {      private static <T> Closure<T> generateIOExceptionClosure() {         return new CatchAndRethrowClosure<T>() {              @Override             protected void executeAndThrow(final T input) throws IOException  {                 throw new IOException();             }         };     }      private static <T> Closure<T> generateNullPointerExceptionClosure() {         return new CatchAndRethrowClosure<T>() {              @Override             protected void executeAndThrow(final T input) {                 throw new NullPointerException();             }         };     }      private static <T> Closure<T> generateNoExceptionClosure() {         return new CatchAndRethrowClosure<T>() {              @Override             protected void executeAndThrow(final T input) {             }         };     }      @Override     protected <T> Closure<T> generateClosure() {         return generateNoExceptionClosure();     }      @Test     public void testThrowingClosure() {         Closure<Integer> closure = generateNoExceptionClosure();         try {             closure.execute(Integer.valueOf(0));         } catch (final FunctorException ex) {             Assert.fail();         } catch (final RuntimeException ex) {             Assert.fail();         }          closure = generateIOExceptionClosure();         try {             closure.execute(Integer.valueOf(0));             Assert.fail();         } catch (final FunctorException ex) {             Assert.assertTrue(ex.getCause() instanceof IOException);         } catch (final RuntimeException ex) {             Assert.fail();         }          closure = generateNullPointerExceptionClosure();         try {             closure.execute(Integer.valueOf(0));             Assert.fail();         } catch (final FunctorException ex) {             Assert.fail();         } catch (final RuntimeException ex) {             Assert.assertTrue(ex instanceof NullPointerException);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Predicate;  import static org.apache.commons.collections4.functors.AllPredicate.allPredicate; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import org.junit.Test;  import java.util.Collection; import java.util.Collections;  /**  * Tests the org.apache.commons.collections.functors.AllPredicate class.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class AllPredicateTest extends AbstractAnyAllOnePredicateTest<Integer> {      /**      * Creates a new {@code TestAllPredicate}.      */     public AllPredicateTest() {         super(42);     }      /**      * {@inheritDoc}      */     @Override     protected final Predicate<Integer> getPredicateInstance(final Predicate<? super Integer>... predicates) {         return AllPredicate.allPredicate(predicates);     }      /**      * {@inheritDoc}      */     @Override     protected final Predicate<Integer> getPredicateInstance(final Collection<Predicate<Integer>> predicates) {         return AllPredicate.allPredicate(predicates);     }      /**      * Verifies that providing an empty predicate array evaluates to true.      */     @SuppressWarnings({"unchecked"})     @Test     public void emptyArrayToGetInstance() {         assertTrue("empty array not true", getPredicateInstance(new Predicate[] {}).evaluate(null));     }      /**      * Verifies that providing an empty predicate collection evaluates to true.      */     @Test     public void emptyCollectionToGetInstance() {         final Predicate<Integer> allPredicate = getPredicateInstance(                 Collections.<Predicate<Integer>>emptyList());         assertTrue("empty collection not true", allPredicate.evaluate(getTestValue()));     }      /**      * Tests whether a single true predicate evaluates to true.      */     @SuppressWarnings("unchecked")     @Test     public void oneTruePredicate() {         // use the constructor directly, as getInstance() returns the original predicate when passed         // an array of size one.         final Predicate<Integer> predicate = createMockPredicate(true);          assertTrue("single true predicate evaluated to false",                 allPredicate(predicate).evaluate(getTestValue()));     }      /**      * Tests whether a single false predicate evaluates to true.      */     @SuppressWarnings("unchecked")     @Test     public void oneFalsePredicate() {         // use the constructor directly, as getInstance() returns the original predicate when passed         // an array of size one.         final Predicate<Integer> predicate = createMockPredicate(false);         assertFalse("single false predicate evaluated to true",                 allPredicate(predicate).evaluate(getTestValue()));     }      /**      * Tests whether multiple true predicates evaluates to true.      */     @Test     public void allTrue() {         assertTrue("multiple true predicates evaluated to false",                 getPredicateInstance(true, true).evaluate(getTestValue()));         assertTrue("multiple true predicates evaluated to false",                 getPredicateInstance(true, true, true).evaluate(getTestValue()));     }      /**      * Tests whether combining some true and one false evaluates to false.  Also verifies that only the first      * false predicate is actually evaluated      */     @Test     public void trueAndFalseCombined() {         assertFalse("false predicate evaluated to true",                 getPredicateInstance(false, null).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(false, null, null).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(true, false, null).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(true, true, false).evaluate(getTestValue()));         assertFalse("false predicate evaluated to true",                 getPredicateInstance(true, true, false, null).evaluate(getTestValue()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.functors;  import org.apache.commons.collections4.Predicate; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public abstract class AbstractPredicateTest {     protected Object cObject;     protected String cString;     protected Integer cInteger;      @Before     public void initializeTestObjects() throws Exception {         cObject = new Object();         cString = "Hello";         cInteger = Integer.valueOf(6);     }      @Test     public void predicateSanityTests() throws Exception {         final Predicate<?> predicate = generatePredicate();         Assert.assertNotNull(predicate);     }      /**      * @return a predicate for general sanity tests.      */     protected abstract Predicate<?> generatePredicate();      protected <T> void assertPredicateFalse(final Predicate<T> predicate, final T testObject) {         Assert.assertFalse(predicate.evaluate(testObject));     }      protected <T> void assertPredicateTrue(final Predicate<T> predicate, final T testObject) {         Assert.assertTrue(predicate.evaluate(testObject));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.apache.commons.collections4.functors.TruePredicate.INSTANCE; import static org.easymock.EasyMock.createMock; import static org.easymock.EasyMock.expect; import static org.easymock.EasyMock.replay; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.ListIterator; import java.util.Map; import java.util.NoSuchElementException; import java.util.Vector; import java.util.Dictionary; import java.util.Enumeration; import java.util.Set; import java.util.LinkedHashSet;  import org.apache.commons.collections4.iterators.*; import org.apache.commons.collections4.map.EntrySetToMapIteratorAdapter; import org.junit.Before; import org.junit.Test; import org.w3c.dom.Node; import org.w3c.dom.NodeList;  /**  * Tests for IteratorUtils.  */ public class IteratorUtilsTest {      /**      * Collection of {@link Integer}s      */     private List<Integer> collectionA = null;      /**      * Collection of even {@link Integer}s      */     private List<Integer> collectionEven = null;      /**      * Collection of odd {@link Integer}s      */     private List<Integer> collectionOdd = null;      private final Collection<Integer> emptyCollection = new ArrayList<>(1);      private Iterable<Integer> iterableA = null;      /**      * Creates a NodeList containing the specified nodes.      */     private NodeList createNodeList(final Node[] nodes) {         return new NodeList() {             @Override             public int getLength() {                 return nodes.length;             }              @Override             public Node item(final int index) {                 return nodes[index];             }         };     }      /**      * creates an array of four Node instances, mocked by EasyMock.      */     private Node[] createNodes() {         final Node node1 = createMock(Node.class);         final Node node2 = createMock(Node.class);         final Node node3 = createMock(Node.class);         final Node node4 = createMock(Node.class);         replay(node1);         replay(node2);         replay(node3);         replay(node4);          return new Node[] { node1, node2, node3, node4 };     }      /**      * Gets an immutable Iterator operating on the elements ["a", "b", "c", "d"].      */     private Iterator<String> getImmutableIterator() {         final List<String> list = new ArrayList<>();         list.add("a");         list.add("b");         list.add("c");         list.add("d");         return IteratorUtils.unmodifiableIterator(list.iterator());     }      /**      * Gets an immutable ListIterator operating on the elements ["a", "b", "c", "d"].      */     private ListIterator<String> getImmutableListIterator() {         final List<String> list = new ArrayList<>();         list.add("a");         list.add("b");         list.add("c");         list.add("d");         return IteratorUtils.unmodifiableListIterator(list.listIterator());     }      @Before     public void setUp() {         collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);          iterableA = collectionA;          collectionEven = Arrays.asList(2, 4, 6, 8, 10, 12);         collectionOdd = Arrays.asList(1, 3, 5, 7, 9, 11);     }      @Test     public void testArrayIterator() {         final Object[] objArray = { "a", "b", "c" };         ResettableIterator<Object> iterator = IteratorUtils.arrayIterator(objArray);         assertEquals("a", iterator.next());         assertEquals("b", iterator.next());         iterator.reset();         assertEquals("a", iterator.next());          try {             iterator = IteratorUtils.arrayIterator(Integer.valueOf(0));             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator((Object[]) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(objArray, 1);         assertEquals("b", iterator.next());          try {             iterator = IteratorUtils.arrayIterator(objArray, -1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(objArray, 3);         assertFalse(iterator.hasNext());         iterator.reset();          try {             iterator = IteratorUtils.arrayIterator(objArray, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(objArray, 2, 3);         assertEquals("c", iterator.next());          try {             iterator = IteratorUtils.arrayIterator(objArray, 2, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(objArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(objArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          final int[] intArray = { 0, 1, 2 };         iterator = IteratorUtils.arrayIterator(intArray);         assertEquals(0, iterator.next());         assertEquals(1, iterator.next());         iterator.reset();         assertEquals(0, iterator.next());          iterator = IteratorUtils.arrayIterator(intArray, 1);         assertEquals(1, iterator.next());          try {             iterator = IteratorUtils.arrayIterator(intArray, -1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(intArray, 3);         assertFalse(iterator.hasNext());         iterator.reset();          try {             iterator = IteratorUtils.arrayIterator(intArray, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayIterator(intArray, 2, 3);         assertEquals(2, iterator.next());          try {             iterator = IteratorUtils.arrayIterator(intArray, 2, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(intArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayIterator(intArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }     }      @Test     public void testArrayListIterator() {         final Object[] objArray = { "a", "b", "c", "d" };         ResettableListIterator<Object> iterator = IteratorUtils.arrayListIterator(objArray);         assertFalse(iterator.hasPrevious());         assertEquals(-1, iterator.previousIndex());         assertEquals(0, iterator.nextIndex());         assertEquals("a", iterator.next());         assertEquals("a", iterator.previous());         assertEquals("a", iterator.next());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());         assertEquals("b", iterator.next());         assertEquals("c", iterator.next());         assertEquals("d", iterator.next());         assertEquals(4, iterator.nextIndex()); // size of list         assertEquals(3, iterator.previousIndex());          try {             iterator = IteratorUtils.arrayListIterator(Integer.valueOf(0));             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator((Object[]) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(objArray, 1);         assertEquals(-1, iterator.previousIndex());         assertFalse(iterator.hasPrevious());         assertEquals(0, iterator.nextIndex());         assertEquals("b", iterator.next());         assertEquals(0, iterator.previousIndex());          try {             iterator = IteratorUtils.arrayListIterator(objArray, -1);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(objArray, 3);         assertTrue(iterator.hasNext());         try {             iterator.previous();             fail("Expecting NoSuchElementException.");         } catch (final NoSuchElementException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(objArray, 5);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(objArray, 2, 3);         assertEquals("c", iterator.next());          try {             iterator = IteratorUtils.arrayListIterator(objArray, 2, 5);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(objArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(objArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }          final int[] intArray = { 0, 1, 2 };         iterator = IteratorUtils.arrayListIterator(intArray);         assertEquals(iterator.previousIndex(), -1);         assertFalse(iterator.hasPrevious());         assertEquals(0, iterator.nextIndex());         assertEquals(0, iterator.next());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());         assertEquals(1, iterator.next());         assertEquals(1, iterator.previousIndex());         assertEquals(2, iterator.nextIndex());         assertEquals(1, iterator.previous());         assertEquals(1, iterator.next());          iterator = IteratorUtils.arrayListIterator(intArray, 1);         assertEquals(-1, iterator.previousIndex());         assertFalse(iterator.hasPrevious());         assertEquals(0, iterator.nextIndex());         assertEquals(1, iterator.next());         assertEquals(1, iterator.previous());         assertEquals(1, iterator.next());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());         assertEquals(2, iterator.next());         assertEquals(1, iterator.previousIndex());         assertEquals(2, iterator.nextIndex());         assertEquals(2, iterator.previous());         assertEquals(0, iterator.previousIndex());         assertEquals(1, iterator.nextIndex());          try {             iterator = IteratorUtils.arrayListIterator(intArray, -1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(intArray, 3);         assertFalse(iterator.hasNext());          try {             iterator = IteratorUtils.arrayListIterator(intArray, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          iterator = IteratorUtils.arrayListIterator(intArray, 2, 3);         assertFalse(iterator.hasPrevious());         assertEquals(-1, iterator.previousIndex());         assertEquals(2, iterator.next());         assertTrue(iterator.hasPrevious());         assertFalse(iterator.hasNext());          try {             iterator = IteratorUtils.arrayListIterator(intArray, 2, 4);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(intArray, -1, 1);             fail("Expecting IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException ex) {             // expected         }          try {             iterator = IteratorUtils.arrayListIterator(intArray, 2, 1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // expected         }     }      @Test(expected = NullPointerException.class)     public void testAsEnumerationNull() {         IteratorUtils.asEnumeration(null);     }      @Test     public void testAsIterable() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iterator = list.iterator();          final Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);         int expected = 0;         for (final Integer actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         // insure iteration occurred         assertTrue(expected > 0);          // single use iterator         assertFalse("should not be able to iterate twice", IteratorUtils.asIterable(iterator).iterator().hasNext());     }      @Test     public void testAsIterableNull() {         try {             IteratorUtils.asIterable(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test(expected = NullPointerException.class)     public void testAsIterator() {         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         final Enumeration<String> en = vector.elements();         assertTrue("create instance fail", IteratorUtils.asIterator(en) instanceof Iterator);         IteratorUtils.asIterator(null);     }      @Test     public void testAsIteratorNull() {         final Collection coll = new ArrayList();         coll.add("test");         final Vector<String> vector = new Vector<>();         vector.addElement("test");         vector.addElement("one");         final Enumeration<String> en = vector.elements();         assertTrue("create instance fail", IteratorUtils.asIterator(en, coll) instanceof Iterator);         try {             IteratorUtils.asIterator(null, coll);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.asIterator(en, null);         } catch (final NullPointerException npe) {             //         }     }      @Test     public void testAsMultipleIterable() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iterator = list.iterator();          final Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);         int expected = 0;         for (final Integer actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         // insure iteration occurred         assertTrue(expected > 0);          // multiple use iterator         expected = 0;         for (final Integer actual : iterable) {             assertEquals(expected, actual.intValue());             ++expected;         }         // insure iteration occurred         assertTrue(expected > 0);     }      @Test     public void testAsMultipleIterableNull() {         try {             IteratorUtils.asMultipleUseIterable(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testChainedIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.chainedIterator(ie) instanceof Iterator);         final Collection<Iterator<?>> coll = new ArrayList();         assertTrue("create instance fail", IteratorUtils.chainedIterator(coll) instanceof Iterator);      }      /**      * Tests methods collatedIterator(...)      */     @Test     public void testCollatedIterator() {         try {             IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             IteratorUtils.collatedIterator(null, null, collectionEven.iterator());             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          // natural ordering         Iterator<Integer> it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(),                 collectionEven.iterator());          List<Integer> result = IteratorUtils.toList(it);         assertEquals(12, result.size());          final List<Integer> combinedList = new ArrayList<>(collectionOdd);         combinedList.addAll(collectionEven);         Collections.sort(combinedList);          assertEquals(combinedList, result);          it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());         result = IteratorUtils.toList(it);         assertEquals(collectionOdd, result);          final Comparator<Integer> reverseComparator = ComparatorUtils                 .reversedComparator(ComparatorUtils.<Integer>naturalComparator());          Collections.reverse(collectionOdd);         Collections.reverse(collectionEven);         Collections.reverse(combinedList);          it = IteratorUtils.collatedIterator(reverseComparator, collectionOdd.iterator(), collectionEven.iterator());         result = IteratorUtils.toList(it);         assertEquals(combinedList, result);     }      @Test(expected = NullPointerException.class)     public void testCollatedIteratorCollectionNull() {         final Collection<Iterator<?>> coll = new ArrayList<>();         coll.add(collectionOdd.iterator());         // natural ordering         final Iterator<?> it = IteratorUtils.collatedIterator(null, coll);         final List<?> result = IteratorUtils.toList(it);         assertEquals(6, result.size());         IteratorUtils.collatedIterator(null, (Collection<Iterator<?>>) null);     }      @Test(expected = NullPointerException.class)     public void testCollatedIteratorNull() {         final ArrayList arrayList = new ArrayList();         // natural ordering         Iterator<Integer> it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionOdd.iterator(),                 collectionOdd.iterator());          List<Integer> result = IteratorUtils.toList(it);         assertEquals(18, result.size());          it = IteratorUtils.collatedIterator(null, collectionOdd.iterator());         result = IteratorUtils.toList(it);         assertEquals(collectionOdd, result);          final Comparator<Integer> reverseComparator = ComparatorUtils                 .reversedComparator(ComparatorUtils.<Integer>naturalComparator());          Collections.reverse(collectionOdd);          it = IteratorUtils.collatedIterator(reverseComparator, collectionOdd.iterator());         result = IteratorUtils.toList(it);         assertEquals(collectionOdd, result);         IteratorUtils.collatedIterator(null, arrayList.iterator(), arrayList.listIterator(), null);     }      // -----------------------------------------------------------------------     /**      * Test empty iterator      */     @Test     public void testEmptyIterator() {         assertSame(EmptyIterator.INSTANCE, IteratorUtils.EMPTY_ITERATOR);         assertSame(EmptyIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_ITERATOR);         assertTrue(IteratorUtils.EMPTY_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof OrderedIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof MapIterator);         assertFalse(IteratorUtils.EMPTY_ITERATOR.hasNext());         IteratorUtils.EMPTY_ITERATOR.reset();         assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.EMPTY_ITERATOR);         assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.emptyIterator());         try {             IteratorUtils.EMPTY_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty list iterator      */     @Test     public void testEmptyListIterator() {         assertSame(EmptyListIterator.INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);         assertSame(EmptyListIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ListIterator);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableIterator);         assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableListIterator);         assertFalse(IteratorUtils.EMPTY_LIST_ITERATOR instanceof MapIterator);         assertFalse(IteratorUtils.EMPTY_LIST_ITERATOR.hasNext());         assertEquals(0, IteratorUtils.EMPTY_LIST_ITERATOR.nextIndex());         assertEquals(-1, IteratorUtils.EMPTY_LIST_ITERATOR.previousIndex());         IteratorUtils.EMPTY_LIST_ITERATOR.reset();         assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.EMPTY_LIST_ITERATOR);         assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.emptyListIterator());         try {             IteratorUtils.EMPTY_LIST_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_LIST_ITERATOR.previous();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_LIST_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.emptyListIterator().set(null);             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.emptyListIterator().add(null);             fail();         } catch (final UnsupportedOperationException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty map iterator      */     @Test     @SuppressWarnings("unchecked")     public void testEmptyMapIterator() {         assertSame(EmptyMapIterator.INSTANCE, IteratorUtils.EMPTY_MAP_ITERATOR);         assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof MapIterator);         assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedMapIterator);         assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR.hasNext());         ((ResettableIterator<Object>) IteratorUtils.EMPTY_MAP_ITERATOR).reset();         assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.EMPTY_MAP_ITERATOR);         assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.emptyMapIterator());         try {             IteratorUtils.EMPTY_MAP_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.getKey();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.getValue();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_MAP_ITERATOR.setValue(null);             fail();         } catch (final IllegalStateException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty map iterator      */     @Test     @SuppressWarnings("unchecked")     public void testEmptyOrderedIterator() {         assertSame(EmptyOrderedIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_ITERATOR);         assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof OrderedIterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof MapIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR.hasNext());         assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR.hasPrevious());         ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_ITERATOR).reset();         assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.EMPTY_ORDERED_ITERATOR);         assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.emptyOrderedIterator());         try {             IteratorUtils.EMPTY_ORDERED_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_ITERATOR.previous();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }     }      // -----------------------------------------------------------------------     /**      * Test empty map iterator      */     @Test     @SuppressWarnings("unchecked")     public void testEmptyOrderedMapIterator() {         assertSame(EmptyOrderedMapIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof Iterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof MapIterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof OrderedMapIterator);         assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ResettableIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ListIterator);         assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasNext());         assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasPrevious());         ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR).reset();         assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);         assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.emptyOrderedMapIterator());         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.next();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.previous();             fail();         } catch (final NoSuchElementException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.remove();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getKey();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getValue();             fail();         } catch (final IllegalStateException ex) {         }         try {             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.setValue(null);             fail();         } catch (final IllegalStateException ex) {         }     }      @Test     public void testFilteredIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         try {             IteratorUtils.filteredIterator(ie, null);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.filteredIterator(null, null);         } catch (final NullPointerException npe) {             //         }     }      @Test     public void testFilteredListIterator() {         final List arrayList = new ArrayList();         arrayList.add("test");         final Predicate predicate = INSTANCE;         assertTrue("create instance fail",                 IteratorUtils.filteredListIterator(arrayList.listIterator(), predicate) instanceof ListIterator);         try {             IteratorUtils.filteredListIterator(null, predicate);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.filteredListIterator(arrayList.listIterator(), null);         } catch (final NullPointerException npe) {             //         }     }      @Test     public void testFind() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         Integer test = IteratorUtils.find(iterableA.iterator(), testPredicate);         assertEquals(4, (int) test);         testPredicate = equalPredicate((Number) 45);         test = IteratorUtils.find(iterableA.iterator(), testPredicate);         assertNull(test);         assertNull(IteratorUtils.find(null, testPredicate));         try {             assertNull(IteratorUtils.find(iterableA.iterator(), null));             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void testFirstFromIterator() throws Exception {         // Iterator, entry exists         final Iterator<Integer> iterator = iterableA.iterator();         assertEquals(1, (int) IteratorUtils.first(iterator));     }      // -----------------------------------------------------------------------     @Test     public void testForEach() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         IteratorUtils.forEach(col.iterator(), testClosure);         assertTrue(listA.isEmpty() && listB.isEmpty());         try {             IteratorUtils.forEach(col.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IteratorUtils.forEach(null, testClosure);          // null should be OK         col.add(null);         IteratorUtils.forEach(col.iterator(), testClosure);     }      @Test     public void testForEachButLast() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         List<Integer> last = IteratorUtils.forEachButLast(col.iterator(), testClosure);         assertTrue(listA.isEmpty() && !listB.isEmpty());         assertSame(listB, last);          try {             IteratorUtils.forEachButLast(col.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IteratorUtils.forEachButLast(null, testClosure);          // null should be OK         col.add(null);         col.add(null);         last = IteratorUtils.forEachButLast(col.iterator(), testClosure);         assertNull(last);     }      @Test     public void testGetAtIndexFromIterator() throws Exception {         // Iterator, entry exists         Iterator<Integer> iterator = iterableA.iterator();         assertEquals(1, (int) IteratorUtils.get(iterator, 0));         iterator = iterableA.iterator();         assertEquals(2, (int) IteratorUtils.get(iterator, 1));          // Iterator, non-existent entry         try {             IteratorUtils.get(iterator, 10);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertFalse(iterator.hasNext());     }      @Test     public void testGetIterator() {         final Object[] objArray = { "a", "b", "c" };         final Map<String, String> inMap = new HashMap<>();         final Node[] nodes = createNodes();         final NodeList nodeList = createNodeList(nodes);          assertTrue("returns empty iterator when null passed", IteratorUtils.getIterator(null) instanceof EmptyIterator);         assertTrue("returns Iterator when Iterator directly ",                 IteratorUtils.getIterator(iterableA.iterator()) instanceof Iterator);         assertTrue("returns Iterator when iterable passed", IteratorUtils.getIterator(iterableA) instanceof Iterator);         assertTrue("returns ObjectArrayIterator when Object array passed",                 IteratorUtils.getIterator(objArray) instanceof ObjectArrayIterator);         assertTrue("returns Iterator when Map passed", IteratorUtils.getIterator(inMap) instanceof Iterator);         assertTrue("returns NodeListIterator when nodeList passed",                 IteratorUtils.getIterator(nodeList) instanceof NodeListIterator);         assertTrue("returns EnumerationIterator when Enumeration passed",                 IteratorUtils.getIterator(new Vector().elements()) instanceof EnumerationIterator);         final Node node1 = createMock(Node.class);         assertTrue("returns NodeListIterator when nodeList passed",                 IteratorUtils.getIterator(node1) instanceof NodeListIterator);         final Dictionary dic = createMock(Dictionary.class);         assertTrue("returns EnumerationIterator when Dictionary passed",                 IteratorUtils.getIterator(dic) instanceof EnumerationIterator);         final int[] arr = new int[8];         assertTrue("returns ArrayIterator when array passed", IteratorUtils.getIterator(arr) instanceof ArrayIterator);     }      @Test     public void testIndexOf() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         int index = IteratorUtils.indexOf(iterableA.iterator(), testPredicate);         assertEquals(6, index);         testPredicate = equalPredicate((Number) 45);         index = IteratorUtils.indexOf(iterableA.iterator(), testPredicate);         assertEquals(-1, index);         assertEquals(-1, IteratorUtils.indexOf(null, testPredicate));         try {             IteratorUtils.indexOf(iterableA.iterator(), null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test(expected = NullPointerException.class)     public void testLoopingIterator() {         final ArrayList arrayList = new ArrayList();         arrayList.add("test");         final Collection coll = new ArrayList();         coll.add("test");         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.loopingIterator(coll) instanceof ResettableIterator);         IteratorUtils.loopingIterator(null);     }      @Test(expected = NullPointerException.class)     public void testLoopingListIterator() {         final ArrayList arrayList = new ArrayList();         arrayList.add("test");         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.loopingListIterator(arrayList) instanceof ResettableIterator);         IteratorUtils.loopingListIterator(null);     }      /**      * Tests method nodeListIterator(Node)      */     @Test     public void testNodeIterator() {         final Node[] nodes = createNodes();         final NodeList nodeList = createNodeList(nodes);         final Node parentNode = createMock(Node.class);         expect(parentNode.getChildNodes()).andStubReturn(nodeList);         replay(parentNode);          final Iterator<Node> iterator = IteratorUtils.nodeListIterator(parentNode);         int expectedNodeIndex = 0;         for (final Node actual : IteratorUtils.asIterable(iterator)) {             assertEquals(nodes[expectedNodeIndex], actual);             ++expectedNodeIndex;         }          // insure iteration occurred         assertTrue(expectedNodeIndex > 0);          // single use iterator         assertFalse("should not be able to iterate twice", IteratorUtils.asIterable(iterator).iterator().hasNext());          try {             IteratorUtils.nodeListIterator((Node) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      /**      * Tests method nodeListIterator(NodeList)      */     @Test     public void testNodeListIterator() {         final Node[] nodes = createNodes();         final NodeList nodeList = createNodeList(nodes);          final Iterator<Node> iterator = IteratorUtils.nodeListIterator(nodeList);         int expectedNodeIndex = 0;         for (final Node actual : IteratorUtils.asIterable(iterator)) {             assertEquals(nodes[expectedNodeIndex], actual);             ++expectedNodeIndex;         }          // insure iteration occurred         assertTrue(expectedNodeIndex > 0);          // single use iterator         assertFalse("should not be able to iterate twice", IteratorUtils.asIterable(iterator).iterator().hasNext());          try {             IteratorUtils.nodeListIterator((NodeList) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testObjectGraphIterator() {         assertTrue("create instance fail", IteratorUtils.objectGraphIterator(null, null) instanceof Iterator);     }      @Test(expected = NullPointerException.class)     public void testPeekingIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.peekingIterator(ie) instanceof Iterator);         IteratorUtils.peekingIterator(null);      }      @Test(expected = NullPointerException.class)     public void testPushBackIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.pushbackIterator(ie) instanceof Iterator);         IteratorUtils.pushbackIterator(null);     }      @Test     public void testSingletonIterator() {         assertTrue("create instance fail", IteratorUtils.singletonIterator(new Object()) instanceof ResettableIterator);     }      @Test     public void testSingletonListIterator() {         assertTrue("create instance fail", IteratorUtils.singletonListIterator(new Object()) instanceof Iterator);     }      @Test     public void testToArray() {         final List<Object> list = new ArrayList<>();         list.add(Integer.valueOf(1));         list.add("Two");         list.add(null);         final Object[] result = IteratorUtils.toArray(list.iterator());         assertEquals(list, Arrays.asList(result));          try {             IteratorUtils.toArray(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testToArray2() {         final List<String> list = new ArrayList<>();         list.add("One");         list.add("Two");         list.add(null);         final String[] result = IteratorUtils.toArray(list.iterator(), String.class);         assertEquals(list, Arrays.asList(result));          try {             IteratorUtils.toArray(list.iterator(), null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }          try {             IteratorUtils.toArray(null, String.class);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testToList() {         final List<Object> list = new ArrayList<>();         list.add(Integer.valueOf(1));         list.add("Two");         list.add(null);         final List<Object> result = IteratorUtils.toList(list.iterator());         assertEquals(list, result);         // add         try {             IteratorUtils.toList(null, 10);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }          try {             IteratorUtils.toList(list.iterator(), -1);             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {             // success         }      }      @Test     public void testToListIterator() {         final List<Integer> list = new ArrayList<>();         list.add(Integer.valueOf(0));         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         final Iterator<Integer> iterator = list.iterator();          final ListIterator<Integer> liItr = IteratorUtils.toListIterator(iterator);         int expected = 0;         while (liItr.hasNext()) {             assertEquals(expected, liItr.next().intValue());             ++expected;         }     }      @Test     public void testToListIteratorNull() {         try {             IteratorUtils.toListIterator(null);             fail("Expecting NullPointerException");         } catch (final NullPointerException ex) {             // success         }     }      @Test     public void testTransformedIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         try {             IteratorUtils.transformedIterator(ie, null);         } catch (final NullPointerException npe) {             //         }         try {             IteratorUtils.transformedIterator(null, null);         } catch (final NullPointerException npe) {             //         }     }      /**      * Test remove() for an immutable Iterator.      */     @Test     public void testUnmodifiableIteratorImmutability() {         final Iterator<String> iterator = getImmutableIterator();          try {             iterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          iterator.next();          try {             iterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }      }      // -----------------------------------------------------------------------     /**      * Test next() and hasNext() for an immutable Iterator.      */     @Test     public void testUnmodifiableIteratorIteration() {         final Iterator<String> iterator = getImmutableIterator();          assertTrue(iterator.hasNext());          assertEquals("a", iterator.next());          assertTrue(iterator.hasNext());          assertEquals("b", iterator.next());          assertTrue(iterator.hasNext());          assertEquals("c", iterator.next());          assertTrue(iterator.hasNext());          assertEquals("d", iterator.next());          assertFalse(iterator.hasNext());     }      /**      * Test remove() for an immutable ListIterator.      */     @Test     public void testUnmodifiableListIteratorImmutability() {         final ListIterator<String> listIterator = getImmutableListIterator();          try {             listIterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.set("a");             // We shouldn't get to here.             fail("set(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.add("a");             // We shouldn't get to here.             fail("add(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          listIterator.next();          try {             listIterator.remove();             // We shouldn't get to here.             fail("remove() should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.set("a");             // We shouldn't get to here.             fail("set(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }          try {             listIterator.add("a");             // We shouldn't get to here.             fail("add(Object) should throw an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // This is correct; ignore the exception.         }     }      /**      * Test next(), hasNext(), previous() and hasPrevious() for an immutable ListIterator.      */     @Test     public void testUnmodifiableListIteratorIteration() {         final ListIterator<String> listIterator = getImmutableListIterator();          assertFalse(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("a", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("b", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("c", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("d", listIterator.next());          assertTrue(listIterator.hasPrevious());         assertFalse(listIterator.hasNext());          assertEquals("d", listIterator.previous());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("c", listIterator.previous());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("b", listIterator.previous());          assertTrue(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());          assertEquals("a", listIterator.previous());          assertFalse(listIterator.hasPrevious());         assertTrue(listIterator.hasNext());     }      @Test(expected = NullPointerException.class)     public void testUnmodifiableMapIterator() {         final Set<?> set = new LinkedHashSet<>();         final MapIterator ie = new EntrySetToMapIteratorAdapter(set);         assertTrue("create instance fail", IteratorUtils.unmodifiableMapIterator(ie) instanceof MapIterator);         IteratorUtils.unmodifiableMapIterator(null);      }      @Test     public void testZippingIterator() {         final ArrayList arrayList = new ArrayList();         final Iterator ie = arrayList.iterator();         assertTrue("create instance fail", IteratorUtils.zippingIterator(ie, ie, ie) instanceof ZippingIterator);         assertTrue("create instance fail", IteratorUtils.zippingIterator(ie, ie) instanceof ZippingIterator);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Set;  import org.apache.commons.collections4.map.Flat3Map;  /**  * {@code MapPerformanceTest} is designed to perform basic Map performance tests.  *  */ public class MapPerformance {      /** The total number of runs for each test */     private static final int RUNS = 20000000;      /**      * Main method      */     public static void main(final String[] args) {         testAll();     }      private static void testAll() {         final Map<String, String> dummyMap = new DummyMap<>();         final Map<String, String> hashMap = new HashMap<>(); //        hashMap.put("Alpha", "A"); //        hashMap.put("Beta", "B"); //        hashMap.put("Gamma", "C"); //        hashMap.put("Delta", "D");         final Map<String, String> flatMap = new Flat3Map<>(hashMap);         System.out.println(flatMap); //        Map<String, String> unmodHashMap = Collections.unmodifiableMap(new HashMap<String, String>(hashMap)); //        Map fastHashMap = new FastHashMap(hashMap); //        Map<String, String> treeMap = new TreeMap<String, String>(hashMap); //        Map linkedMap = new LinkedHashMap(hashMap); //        Map syncMap = Collections.unmodifiableMap(new HashMap(hashMap)); //        Map bucketMap = new StaticBucketMap(); //        bucketMap.putAll(hashMap); //        Map doubleMap = new DoubleOrderedMap(hashMap);          // dummy is required as the VM seems to hotspot the first call to the         // test method with the given type         test(dummyMap,      "         Dummy ");         test(dummyMap,      "         Dummy ");         test(dummyMap,      "         Dummy ");         test(flatMap,       "         Flat3 ");         test(hashMap,       "       HashMap ");          test(flatMap,       "         Flat3 ");         test(flatMap,       "         Flat3 ");         test(flatMap,       "         Flat3 ");          test(hashMap,       "       HashMap ");         test(hashMap,       "       HashMap ");         test(hashMap,       "       HashMap ");  //        test(treeMap,       "       TreeMap "); //        test(treeMap,       "       TreeMap "); //        test(treeMap,       "       TreeMap ");  //        test(unmodHashMap,  "Unmod(HashMap) "); //        test(unmodHashMap,  "Unmod(HashMap) "); //        test(unmodHashMap,  "Unmod(HashMap) "); // //        test(syncMap,       " Sync(HashMap) "); //        test(syncMap,       " Sync(HashMap) "); //        test(syncMap,       " Sync(HashMap) "); // //        test(fastHashMap,   "   FastHashMap "); //        test(fastHashMap,   "   FastHashMap "); //        test(fastHashMap,   "   FastHashMap "); // //        test(seqMap,        "    SeqHashMap "); //        test(seqMap,        "    SeqHashMap "); //        test(seqMap,        "    SeqHashMap "); // //        test(linkedMap,     " LinkedHashMap "); //        test(linkedMap,     " LinkedHashMap "); //        test(linkedMap,     " LinkedHashMap "); // //        test(bucketMap,     "     BucketMap "); //        test(bucketMap,     "     BucketMap "); //        test(bucketMap,     "     BucketMap "); // //        test(doubleMap,     "     DoubleMap "); //        test(doubleMap,     "     DoubleMap "); //        test(doubleMap,     "     DoubleMap ");     }      private static void test(final Map<String, String> map, final String name) {         long start = 0, end = 0; //        int total = 0;         start = System.currentTimeMillis();         for (int i = RUNS; i > 0; i--) { //            if (map.get("Alpha") != null) total++; //            if (map.get("Beta") != null) total++; //            if (map.get("Gamma") != null) total++;             map.put("Alpha", "A");             map.put("Beta", "B");             map.put("Beta", "C");             map.put("Gamma", "D"); //            map.remove("Gamma"); //            map.remove("Beta"); //            map.remove("Alpha");             map.put("Delta", "E");             map.clear();         }         end = System.currentTimeMillis();         System.out.println(name + (end - start));     }      // ----------------------------------------------------------------------      private static class DummyMap<K, V> implements Map<K, V> {         @Override         public void clear() {         }         @Override         public boolean containsKey(final Object key) {             return false;         }         @Override         public boolean containsValue(final Object value) {             return false;         }         @Override         public Set<Map.Entry<K, V>> entrySet() {             return null;         }         @Override         public V get(final Object key) {             return null;         }         @Override         public boolean isEmpty() {             return false;         }         @Override         public Set<K> keySet() {             return null;         }         @Override         public V put(final K key, final V value) {             return null;         }         @Override         public void putAll(final Map<? extends K, ? extends V> t) {         }         @Override         public V remove(final Object key) {             return null;         }         @Override         public int size() {             return 0;         }         @Override         public Collection<V> values() {             return null;         }     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;  /**  * Extension of {@link AbstractListTest} for exercising the {@link GrowthList}.  *  * @since 3.2  */ public class GrowthListTest<E> extends AbstractListTest<E> {      public GrowthListTest(final String testName) {         super(testName);     }      @Override     public List<E> makeObject() {         return new GrowthList<>();     }      @Override     public List<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return GrowthList.growthList(list);     }      //-----------------------------------------------------------------------     public void testGrowthList() {         final Integer zero = Integer.valueOf(0);         final Integer one = Integer.valueOf(1);         final Integer two = Integer.valueOf(2);         final GrowthList<Integer> grower = new GrowthList(1);         assertEquals(0, grower.size());         grower.add(0, zero);         assertEquals(1, grower.size());         grower.add(1, one);         assertEquals(2, grower.size());         grower.add(2, two);         assertEquals(3, grower.size());     }      //-----------------------------------------------------------------------     public void testGrowthAdd() {         final Integer one = Integer.valueOf(1);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.add(1, one);         assertEquals(2, grower.size());         assertEquals(null, grower.get(0));         assertEquals(one, grower.get(1));     }      public void testGrowthAddAll() {         final Integer one = Integer.valueOf(1);         final Integer two = Integer.valueOf(2);         final Collection<Integer> coll = new ArrayList<>();         coll.add(one);         coll.add(two);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.addAll(1, coll);         assertEquals(3, grower.size());         assertEquals(null, grower.get(0));         assertEquals(one, grower.get(1));         assertEquals(two, grower.get(2));     }      public void testGrowthSet1() {         final Integer one = Integer.valueOf(1);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.set(1, one);         assertEquals(2, grower.size());         assertEquals(null, grower.get(0));         assertEquals(one, grower.get(1));     }      public void testGrowthSet2() {         final Integer one = Integer.valueOf(1);         final GrowthList<Integer> grower = new GrowthList<>();         assertEquals(0, grower.size());         grower.set(0, one);         assertEquals(1, grower.size());         assertEquals(one, grower.get(0));     }      //-----------------------------------------------------------------------     /**      * Override.      */     @Override     public void testListAddByIndexBoundsChecking() {         List<E> list;         final E element = getOtherElements()[0];         try {             list = makeObject();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      * Override.      */     @Override     public void testListAddByIndexBoundsChecking2() {         List<E> list;         final E element = getOtherElements()[0];         try {             list = makeFullCollection();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      * Override.      */     @Override     public void testListSetByIndexBoundsChecking() {         final List<E> list = makeObject();         final E element = getOtherElements()[0];         try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      * Override.      */     @Override     public void testListSetByIndexBoundsChecking2() {         final List<E> list = makeFullCollection();         final E element = getOtherElements()[0];         try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/GrowthList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/GrowthList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.Arrays;  /**  * Test case for {@link AbstractLinkedList}.  *  */ public abstract class AbstractLinkedListTest<E> extends AbstractListTest<E> {      public AbstractLinkedListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testRemoveFirst() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         if (!isRemoveSupported()) {             try {                 list.removeFirst();             } catch (final UnsupportedOperationException ex) {}         }          list.addAll(Arrays.asList((E[]) new String[] { "value1", "value2" }));         assertEquals("value1", list.removeFirst());         checkNodes();         list.addLast((E) "value3");         checkNodes();         assertEquals("value2", list.removeFirst());         assertEquals("value3", list.removeFirst());         checkNodes();         list.addLast((E) "value4");         checkNodes();         assertEquals("value4", list.removeFirst());         checkNodes();     }      @SuppressWarnings("unchecked")     public void testRemoveLast() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         if (!isRemoveSupported()) {             try {                 list.removeLast();             } catch (final UnsupportedOperationException ex) {}         }          list.addAll(Arrays.asList((E[]) new String[] { "value1", "value2" }));         assertEquals("value2", list.removeLast());         list.addFirst((E) "value3");         checkNodes();         assertEquals("value1", list.removeLast());         assertEquals("value3", list.removeLast());         list.addFirst((E) "value4");         checkNodes();         assertEquals("value4", list.removeFirst());     }      @SuppressWarnings("unchecked")     public void testAddNodeAfter() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         if (!isAddSupported()) {             try {                 list.addFirst(null);             } catch (final UnsupportedOperationException ex) {}         }          list.addFirst((E) "value1");         list.addNodeAfter(list.getNode(0, false), (E) "value2");         assertEquals("value1", list.getFirst());         assertEquals("value2", list.getLast());         list.removeFirst();         checkNodes();         list.addNodeAfter(list.getNode(0, false), (E) "value3");         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value3", list.getLast());         list.addNodeAfter(list.getNode(0, false), (E) "value4");         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value3", list.getLast());         assertEquals("value4", list.get(1));         list.addNodeAfter(list.getNode(2, false), (E) "value5");         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value4", list.get(1));         assertEquals("value3", list.get(2));         assertEquals("value5", list.getLast());     }      @SuppressWarnings("unchecked")     public void testRemoveNode() {         resetEmpty();         if (!isAddSupported() || !isRemoveSupported()) {             return;         }         final AbstractLinkedList<E> list = getCollection();          list.addAll(Arrays.asList((E[]) new String[] { "value1", "value2" }));         list.removeNode(list.getNode(0, false));         checkNodes();         assertEquals("value2", list.getFirst());         assertEquals("value2", list.getLast());         list.addFirst((E) "value1");         list.addFirst((E) "value0");         checkNodes();         list.removeNode(list.getNode(1, false));         assertEquals("value0", list.getFirst());         assertEquals("value2", list.getLast());         checkNodes();         list.removeNode(list.getNode(1, false));         assertEquals("value0", list.getFirst());         assertEquals("value0", list.getLast());         checkNodes();     }      @SuppressWarnings("unchecked")     public void testGetNode() {         resetEmpty();         final AbstractLinkedList<E> list = getCollection();         // get marker         assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);         try {             list.getNode(0, false);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }         list.addAll( Arrays.asList((E[]) new String[]{"value1", "value2"}));         checkNodes();         list.addFirst((E) "value0");         checkNodes();         list.removeNode(list.getNode(1, false));         checkNodes();         try {             list.getNode(2, false);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }         try {             list.getNode(-1, false);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }         try {             list.getNode(3, true);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException ex) {             // expected         }     }      protected void checkNodes() {         final AbstractLinkedList<E> list = getCollection();         for (int i = 0; i < list.size; i++) {             assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));             if (i < list.size - 1) {                 assertEquals(list.getNode(i + 1, false).previous,                     list.getNode(i, false));             }         }     }      /**      * {@inheritDoc}      */     @Override     public AbstractLinkedList<E> getCollection() {         return (AbstractLinkedList<E>) super.getCollection();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.Transformer;  import java.time.LocalDateTime; import java.util.ArrayList; import java.util.Arrays; import java.util.List;  public class LazyListTest extends AbstractObjectTest {      public LazyListTest(final String testName) {         super(testName);     }      @Override     public Object makeObject() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         return new LazyList<>(new ArrayList<>(), dateFactory);     }      @Override     public void testSimpleSerialization() {         // Factory and Transformer are not serializable     }      @Override     public void testSerializeDeserializeThenCompare() {         // Factory and Transformer are not serializable     }      @Override     public void testCanonicalEmptyCollectionExists() {         // Factory and Transformer are not serializable     }      @Override     public void testCanonicalFullCollectionExists() {         // Factory and Transformer are not serializable     }      public void testElementCreationWithFactory() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          assertTrue(list.isEmpty());          final LocalDateTime firstElement = list.get(0);         assertNotNull(firstElement);         assertFalse(list.isEmpty());     }      public void testElementCreationWithTransformer() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          assertTrue(list.isEmpty());          final LocalDateTime firstElement = list.get(0);         assertNotNull(firstElement);         assertFalse(list.isEmpty());     }      public void testCreateNullGapsWithFactory() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);     }      public void testCreateNullGapsWithTransformer() {         final List<Integer> hours = Arrays.asList(7, 5, 8, 2);         final Transformer<Integer, LocalDateTime> dateFactory = input -> LocalDateTime.now().withHour(hours.get(input));         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);          final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);     }      public void testGetWithNull() {         final List<Integer> hours = Arrays.asList(7, 5, 8, 2);         final Transformer<Integer, LocalDateTime> transformer = input -> LocalDateTime.now().withHour(hours.get(input));         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), transformer);         LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);         list.remove(3);         list.add(3, null);         fourthElement = list.get(3);         assertNotNull(fourthElement);     }      public void testSubListWitheFactory() {         final Factory<LocalDateTime> dateFactory = LocalDateTime::now;         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);         final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);         testSubList(list);     }      public void testSubListWithTransformer() {         final List<Integer> hours = Arrays.asList(7, 5, 8, 2);         final Transformer<Integer, LocalDateTime> transformer = input -> LocalDateTime.now().withHour(hours.get(input));         final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), transformer);         final LocalDateTime fourthElement = list.get(3);         assertFalse(list.isEmpty());         assertNotNull(fourthElement);         testSubList(list);     }      private void testSubList(final List<LocalDateTime> list) {         List<LocalDateTime> subList = list.subList(1, 3);         assertFalse(subList.isEmpty());         assertNotNull(subList);         assertEquals(2, subList.size());          subList = list.subList(0, 1);         assertFalse(subList.isEmpty());         assertEquals(1, subList.size());          subList = list.subList(1, 1);         assertTrue(subList.isEmpty());          subList = list.subList(0, list.size());         assertFalse(subList.isEmpty());         assertEquals(list.size(), subList.size());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.List;  /**  * Extension of {@link AbstractListTest} for exercising the  * {@link UnmodifiableList} implementation.  *  * @since 3.0  */ public class UnmodifiableListTest<E> extends AbstractListTest<E> {      public UnmodifiableListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public UnmodifiableList<E> makeObject() {         return new UnmodifiableList<>(new ArrayList<E>());     }      @Override     public UnmodifiableList<E> makeFullCollection() {         final ArrayList<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return new UnmodifiableList<>(list);     }      @Override     public boolean isSetSupported() {         return false;     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------     protected UnmodifiableList<E> list;     protected ArrayList<E> array;      @SuppressWarnings("unchecked")     protected void setupList() {         list = makeFullCollection();         array = new ArrayList<>();         array.add((E) Integer.valueOf(1));     }      /**      * Verify that base list and sublists are not modifiable      */     public void testUnmodifiable() {         setupList();         verifyUnmodifiable(list);         verifyUnmodifiable(list.subList(0, 2));     }      public void testDecorateFactory() {         final List<E> list = makeObject();         assertSame(list, UnmodifiableList.unmodifiableList(list));          try {             UnmodifiableList.unmodifiableList(null);             fail();         } catch (final NullPointerException ex) {}     }      @SuppressWarnings("unchecked")     protected void verifyUnmodifiable(final List<E> list) {         try {             list.add(0, (E) Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.add((E) Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.addAll(0, array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.addAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.clear();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.remove(0);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.remove(Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.removeAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.retainAll(array);             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }         try {             list.set(0, (E) Integer.valueOf(0));             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      /**      * Verify that iterator is not modifiable      */     public void testUnmodifiableIterator() {         setupList();         final Iterator<E> iterator = list.iterator();         try {             iterator.next();             iterator.remove();             fail("Expecting UnsupportedOperationException.");         } catch (final UnsupportedOperationException e) {             // expected         }     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests  *  * @since 3.1  */ public class TreeListTest<E> extends AbstractListTest<E> {      public TreeListTest(final String name) {         super(name);     }  //    public static void main(String[] args) { //        junit.textui.TestRunner.run(suite()); //        System.out.println("         add; toArray; iterator; insert; get; indexOf; remove"); //        System.out.print("   TreeList = "); //        benchmark(new TreeList()); //        System.out.print("\n  ArrayList = "); //        benchmark(new java.util.ArrayList()); //        System.out.print("\n LinkedList = "); //        benchmark(new java.util.LinkedList()); //        System.out.print("\n NodeCachingLinkedList = "); //        benchmark(new NodeCachingLinkedList()); //    }      public static Test suite() {         return BulkTest.makeSuite(TreeListTest.class);     }      public static void benchmark(final List<? super Integer> l) {         long start = System.currentTimeMillis();         for (int i = 0; i < 100000; i++) {             l.add(Integer.valueOf(i));         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 200; i++) {             l.toArray();         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 100; i++) {             final java.util.Iterator<? super Integer> it = l.iterator();             while (it.hasNext()) {                 it.next();             }         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 10000; i++) {             final int j = (int) (Math.random() * 100000);             l.add(j, Integer.valueOf(-j));         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 50000; i++) {             final int j = (int) (Math.random() * 110000);             l.get(j);         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 200; i++) {             final int j = (int) (Math.random() * 100000);             l.indexOf(Integer.valueOf(j));         }         System.out.print(System.currentTimeMillis() - start + ";");          start = System.currentTimeMillis();         for (int i = 0; i < 10000; i++) {             final int j = (int) (Math.random() * 100000);             l.remove(j);         }         System.out.print(System.currentTimeMillis() - start + ";");     }      //-----------------------------------------------------------------------     @Override     public TreeList<E> makeObject() {         return new TreeList<>();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testAddMultiple() {         final List<E> l = makeObject();         l.add((E) "hugo");         l.add((E) "erna");         l.add((E) "daniel");         l.add((E) "andres");         l.add((E) "harald");         l.add(0, null);         assertEquals(null, l.get(0));         assertEquals("hugo", l.get(1));         assertEquals("erna", l.get(2));         assertEquals("daniel", l.get(3));         assertEquals("andres", l.get(4));         assertEquals("harald", l.get(5));     }      @SuppressWarnings("unchecked")     public void testRemove() {         final List<E> l = makeObject();         l.add((E) "hugo");         l.add((E) "erna");         l.add((E) "daniel");         l.add((E) "andres");         l.add((E) "harald");         l.add(0, null);         int i = 0;         assertEquals(null, l.get(i++));         assertEquals("hugo", l.get(i++));         assertEquals("erna", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("andres", l.get(i++));         assertEquals("harald", l.get(i++));          l.remove(0);         i = 0;         assertEquals("hugo", l.get(i++));         assertEquals("erna", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("andres", l.get(i++));         assertEquals("harald", l.get(i++));          i = 0;         l.remove(1);         assertEquals("hugo", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("andres", l.get(i++));         assertEquals("harald", l.get(i++));          i = 0;         l.remove(2);         assertEquals("hugo", l.get(i++));         assertEquals("daniel", l.get(i++));         assertEquals("harald", l.get(i++));     }      @SuppressWarnings("unchecked")     public void testInsertBefore() {         final List<E> l = makeObject();         l.add((E) "erna");         l.add(0, (E) "hugo");         assertEquals("hugo", l.get(0));         assertEquals("erna", l.get(1));     }      @SuppressWarnings("unchecked")     public void testIndexOf() {         final List<E> l = makeObject();         l.add((E) "0");         l.add((E) "1");         l.add((E) "2");         l.add((E) "3");         l.add((E) "4");         l.add((E) "5");         l.add((E) "6");         assertEquals(0, l.indexOf("0"));         assertEquals(1, l.indexOf("1"));         assertEquals(2, l.indexOf("2"));         assertEquals(3, l.indexOf("3"));         assertEquals(4, l.indexOf("4"));         assertEquals(5, l.indexOf("5"));         assertEquals(6, l.indexOf("6"));          l.set(1, (E) "0");         assertEquals(0, l.indexOf("0"));          l.set(3, (E) "3");         assertEquals(3, l.indexOf("3"));         l.set(2, (E) "3");         assertEquals(2, l.indexOf("3"));         l.set(1, (E) "3");         assertEquals(1, l.indexOf("3"));         l.set(0, (E) "3");         assertEquals(0, l.indexOf("3"));     }  //    public void testCheck() { //        List l = makeEmptyList(); //        l.add("A1"); //        l.add("A2"); //        l.add("A3"); //        l.add("A4"); //        l.add("A5"); //        l.add("A6"); //    }      public void testBug35258() {         final Object objectToRemove = Integer.valueOf(3);          final List<Integer> treelist = new TreeList<>();         treelist.add(Integer.valueOf(0));         treelist.add(Integer.valueOf(1));         treelist.add(Integer.valueOf(2));         treelist.add(Integer.valueOf(3));         treelist.add(Integer.valueOf(4));          // this cause inconsistence of ListIterator()         treelist.remove(objectToRemove);          final ListIterator<Integer> li = treelist.listIterator();         assertEquals(Integer.valueOf(0), li.next());         assertEquals(Integer.valueOf(0), li.previous());         assertEquals(Integer.valueOf(0), li.next());         assertEquals(Integer.valueOf(1), li.next());         // this caused error in bug 35258         assertEquals(Integer.valueOf(1), li.previous());         assertEquals(Integer.valueOf(1), li.next());         assertEquals(Integer.valueOf(2), li.next());         assertEquals(Integer.valueOf(2), li.previous());         assertEquals(Integer.valueOf(2), li.next());         assertEquals(Integer.valueOf(4), li.next());         assertEquals(Integer.valueOf(4), li.previous());         assertEquals(Integer.valueOf(4), li.next());         assertEquals(false, li.hasNext());     }      public void testBugCollections447() {         final List<String> treeList = new TreeList<>();         treeList.add("A");         treeList.add("B");         treeList.add("C");         treeList.add("D");          final ListIterator<String> li = treeList.listIterator();         assertEquals("A", li.next());         assertEquals("B", li.next());          assertEquals("B", li.previous());          li.remove(); // Deletes "B"          // previous() after remove() should move to         // the element before the one just removed         assertEquals("A", li.previous());     }      @SuppressWarnings("boxing") // OK in test code     public void testIterationOrder() {         // COLLECTIONS-433:         // ensure that the iteration order of elements is correct         // when initializing the TreeList with another collection          for (int size = 1; size < 1000; size++) {             final List<Integer> other = new ArrayList<>(size);             for (int i = 0; i < size; i++) {                 other.add(i);             }             final TreeList<Integer> l = new TreeList<>(other);             final ListIterator<Integer> it = l.listIterator();             int i = 0;             while (it.hasNext()) {                 final Integer val = it.next();                 assertEquals(i++, val.intValue());             }              while (it.hasPrevious()) {                 final Integer val = it.previous();                 assertEquals(--i, val.intValue());             }         }     }      @SuppressWarnings("boxing") // OK in test code     public void testIterationOrderAfterAddAll() {         // COLLECTIONS-433:         // ensure that the iteration order of elements is correct         // when calling addAll on the TreeList          // to simulate different cases in addAll, do different runs where         // the number of elements already in the list and being added by addAll differ          final int size = 1000;         for (int i = 0; i < 100; i++) {             final List<Integer> other = new ArrayList<>(size);             for (int j = i; j < size; j++) {                 other.add(j);             }             final TreeList<Integer> l = new TreeList<>();             for (int j = 0; j < i; j++) {                 l.add(j);             }              l.addAll(other);              final ListIterator<Integer> it = l.listIterator();             int cnt = 0;             while (it.hasNext()) {                 final Integer val = it.next();                 assertEquals(cnt++, val.intValue());             }              while (it.hasPrevious()) {                 final Integer val = it.previous();                 assertEquals(--cnt, val.intValue());             }         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.ListIterator;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractListTest} for exercising the {@link TransformedList}  * implementation.  *  * @since 3.0  */ public class TransformedListTest<E> extends AbstractListTest<E> {      public TransformedListTest(final String testName) {         super(testName);     }      @Override     public List<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public List<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     @SuppressWarnings("unchecked")     public List<E> makeObject() {         return TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public List<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return TransformedList.transformingList(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedList() {         final List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, list.size());         final E[] els = (E[]) new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (int i = 0; i < els.length; i++) {             list.add(els[i]);             assertEquals(i + 1, list.size());             assertEquals(true, list.contains(Integer.valueOf((String) els[i])));             assertEquals(false, list.contains(els[i]));         }          assertEquals(false, list.remove(els[0]));         assertEquals(true, list.remove(Integer.valueOf((String) els[0])));          list.clear();         for (int i = 0; i < els.length; i++) {             list.add(0, els[i]);             assertEquals(i + 1, list.size());             assertEquals(Integer.valueOf((String) els[i]), list.get(0));         }          list.set(0, (E) "22");         assertEquals(Integer.valueOf(22), list.get(0));          final ListIterator<E> it = list.listIterator();         it.next();         it.set((E) "33");         assertEquals(Integer.valueOf(33), list.get(0));         it.add((E) "44");         assertEquals(Integer.valueOf(44), list.get(1));          final List<E> adds = new ArrayList<>();         adds.add((E) "1");         adds.add((E) "2");         list.clear();         list.addAll(adds);         assertEquals(Integer.valueOf(1), list.get(0));         assertEquals(Integer.valueOf(2), list.get(1));          adds.clear();         adds.add((E) "3");         list.addAll(1, adds);         assertEquals(Integer.valueOf(1), list.get(0));         assertEquals(Integer.valueOf(3), list.get(1));         assertEquals(Integer.valueOf(2), list.get(2));     }      public void testTransformedList_decorateTransform() {         final List<Object> originalList = new ArrayList<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (final Object el : els) {             originalList.add(el);         }         final List<?> list = TransformedList.transformedList(originalList, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, list.size());         for (final Object el : els) {             assertEquals(true, list.contains(Integer.valueOf((String) el)));             assertEquals(false, list.contains(el));         }          assertEquals(false, list.remove(els[0]));         assertEquals(true, list.remove(Integer.valueOf((String) els[0])));     }      public void testSubList() {         final List<E> list = makeObject();         List<E> subList = list.subList(0, 0);         assertNotNull(subList);         list.add((E) "zero");         //subList without any element of list         subList = list.subList(0, 0);         assertNotNull(subList);         assertEquals(0, subList.size());          //subList with one element oif list         subList = list.subList(0, 1);         assertEquals(1, subList.size());          final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) "three");         list.addAll(1, elements);         //subList with all elements of list         subList = list.subList(0, list.size());         assertEquals(list.size(), subList.size());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.Arrays; import java.util.LinkedList;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Test class for NodeCachingLinkedList, a performance optimised LinkedList.  *  */ public class NodeCachingLinkedListTest<E> extends AbstractLinkedListTest<E> {      public NodeCachingLinkedListTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(NodeCachingLinkedListTest.class);     }      //-----------------------------------------------------------------------     @Override     public NodeCachingLinkedList<E> makeObject() {         return new NodeCachingLinkedList<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testShrinkCache() {         if (!isRemoveSupported() || !isAddSupported()) {             return;         }         resetEmpty();         final NodeCachingLinkedList<E> list = getCollection();          list.addAll(Arrays.asList((E[]) new String[] { "1", "2", "3", "4" }));         list.removeAllNodes(); // Will dump all 4 elements into cache         list.setMaximumCacheSize(2); // shrink cache         list.addAll(Arrays.asList((E[]) new String[] { "1", "2", "3", "4" }));         checkNodes();         list.removeNode(list.getNode(0, false)); // no room in cache         list.removeNode(list.getNode(0, false));         list.removeNode(list.getNode(0, false));         checkNodes();         list.addAll(Arrays.asList((E[]) new String[] { "1", "2", "3", "4" }));         checkNodes();     }      //-----------------------------------------------------------------------     public static void compareSpeed() {         final NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<>();         final LinkedList<Object> ll = new LinkedList<>();          final Object o1 = new Object();         final Object o2 = new Object();          final int loopCount = 4000000;          long startTime, endTime;          System.out.println("Testing relative execution time of commonly-used methods...");          startTime = System.currentTimeMillis();         for (int x = loopCount; x > 0; x--) {             // unrolled a few times to minimize effect of loop             ll.addFirst(o1);             ll.addLast(o2);             ll.removeFirst();             ll.removeLast();             ll.add(o1);             ll.remove(0);             //             ll.addFirst(o1);             ll.addLast(o2);             ll.removeFirst();             ll.removeLast();             ll.add(o1);             ll.remove(0);             //             ll.addFirst(o1);             ll.addLast(o2);             ll.removeFirst();             ll.removeLast();             ll.add(o1);             ll.remove(0);         }         endTime = System.currentTimeMillis();         System.out.println("Time with LinkedList: " + (endTime - startTime) + " ms");          startTime = System.currentTimeMillis();         for (int x = loopCount; x > 0; x--) {             ncll.addFirst(o1);             ncll.addLast(o2);             ncll.removeFirst();             ncll.removeLast();             ncll.add(o1);             ncll.remove(0);             //             ncll.addFirst(o1);             ncll.addLast(o2);             ncll.removeFirst();             ncll.removeLast();             ncll.add(o1);             ncll.remove(0);             //             ncll.addFirst(o1);             ncll.addLast(o2);             ncll.removeFirst();             ncll.removeLast();             ncll.add(o1);             ncll.remove(0);         }         endTime = System.currentTimeMillis();         System.out.println("Time with NodeCachingLinkedList: " + (endTime - startTime) + " ms");      }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), //           "src/test/resources/data/test/NodeCachingLinkedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), //            "src/test/resources/data/test/NodeCachingLinkedList.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public NodeCachingLinkedList<E> getCollection() {         return (NodeCachingLinkedList<E>) super.getCollection();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.Set;  /**  * JUnit tests.  *  * @since 3.0  */ public class SetUniqueListTest<E> extends AbstractListTest<E> {      class SetUniqueList307 extends SetUniqueList<E> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = 1415013031022962158L;          SetUniqueList307(final List<E> list, final Set<E> set) {             super(list, set);         }     }      boolean extraVerify = true;      public SetUniqueListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         // override to avoid duplicate "One"         return (E[]) new Object[] {             "",             "One",             Integer.valueOf(2),             "Three",             Integer.valueOf(4),             new Double(5),             new Float(6),             "Seven",             "Eight",             "Nine",             Integer.valueOf(10),             new Short((short) 11),             new Long(12),             "Thirteen",             "14",             "15",             new Byte((byte) 16)         };     }      //-----------------------------------------------------------------------     @Override     public List<E> makeObject() {         return new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());     }      @SuppressWarnings("unchecked")     public void testAdd() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          // Duplicate element         final E obj = (E) Integer.valueOf(1);         lset.add(obj);         lset.add(obj);         assertEquals("Duplicate element was added.", 1, lset.size());          // Unique element         lset.add((E) Integer.valueOf(2));         assertEquals("Unique element was not added.", 2, lset.size());     }      @SuppressWarnings("unchecked")     public void testAddAll() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          lset.addAll(             Arrays.asList((E[]) new Integer[] { Integer.valueOf(1), Integer.valueOf(1)}));          assertEquals("Duplicate element was added.", 1, lset.size());     }      @Override     public void testCollectionAddAll() {         // override for set behavior         resetEmpty();         E[] elements = getFullElements();         boolean r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Empty collection should change after addAll", r);         for (final E element : elements) {             assertTrue("Collection should contain added element",                     getCollection().contains(element));         }          resetFull();         final int size = getCollection().size();         elements = getOtherElements();         r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Full collection should change after addAll", r);         for (int i = 0; i < elements.length; i++) {             assertTrue("Full collection should contain added element " + i,                     getCollection().contains(elements[i]));         }         assertEquals("Size should increase after addAll",                 size + elements.length, getCollection().size());     }      @Override     public void testCollectionIteratorRemove() {         try {             extraVerify = false;             super.testCollectionIteratorRemove();         } finally {             extraVerify = true;         }     }     public void testCollections304() {         final List<String> list = new LinkedList<>();         final SetUniqueList<String> decoratedList = SetUniqueList.setUniqueList(list);         final String s1 = "Apple";         final String s2 = "Lemon";         final String s3 = "Orange";         final String s4 = "Strawberry";          decoratedList.add(s1);         decoratedList.add(s2);         decoratedList.add(s3);         assertEquals(3, decoratedList.size());          decoratedList.set(1, s4);         assertEquals(3, decoratedList.size());          decoratedList.add(1, s4);         assertEquals(3, decoratedList.size());          decoratedList.add(1, s2);         assertEquals(4, decoratedList.size());     }      @SuppressWarnings("unchecked")     public void testCollections307() {         List<E> list = new ArrayList<>();         List<E> uniqueList = SetUniqueList.setUniqueList(list);          final String hello = "Hello";         final String world = "World";         uniqueList.add((E) hello);         uniqueList.add((E) world);          List<E> subList = list.subList(0, 0);         List<E> subUniqueList = uniqueList.subList(0, 0);          assertFalse(subList.contains(world)); // passes         assertFalse(subUniqueList.contains(world)); // fails          List<E> worldList = new ArrayList<>();         worldList.add((E) world);         assertFalse(subList.contains("World")); // passes         assertFalse(subUniqueList.contains("World")); // fails          // repeat the test with a different class than HashSet;         // which means subclassing SetUniqueList below         list = new ArrayList<>();         uniqueList = new SetUniqueList307(list, new java.util.TreeSet<E>());          uniqueList.add((E) hello);         uniqueList.add((E) world);          subList = list.subList(0, 0);         subUniqueList = uniqueList.subList(0, 0);          assertFalse(subList.contains(world)); // passes         assertFalse(subUniqueList.contains(world)); // fails          worldList = new ArrayList<>();         worldList.add((E) world);         assertFalse(subList.contains("World")); // passes         assertFalse(subUniqueList.contains("World")); // fails     }      public void testCollections701() {         final SetUniqueList<Object> uniqueList = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());         final Integer obj1 = Integer.valueOf(1);         final Integer obj2 = Integer.valueOf(2);         uniqueList.add(obj1);         uniqueList.add(obj2);         assertEquals(2, uniqueList.size());         uniqueList.add(uniqueList);         assertEquals(3, uniqueList.size());         final List<Object> list = new LinkedList<>();         final SetUniqueList<Object> decoratedList = SetUniqueList.setUniqueList(list);         final String s1 = "Apple";         final String s2 = "Lemon";         final String s3 = "Orange";         final String s4 = "Strawberry";         decoratedList.add(s1);         decoratedList.add(s2);         decoratedList.add(s3);         assertEquals(3, decoratedList.size());         decoratedList.set(1, s4);         assertEquals(3, decoratedList.size());         decoratedList.add(decoratedList);         assertEquals(4, decoratedList.size());     }      //-----------------------------------------------------------------------     public void testFactory() {         final Integer[] array = new Integer[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(1) };         final ArrayList<Integer> list = new ArrayList<>(Arrays.asList(array));         final SetUniqueList<Integer> lset = SetUniqueList.setUniqueList(list);          assertEquals("Duplicate element was added.", 2, lset.size());         assertEquals(Integer.valueOf(1), lset.get(0));         assertEquals(Integer.valueOf(2), lset.get(1));         assertEquals(Integer.valueOf(1), list.get(0));         assertEquals(Integer.valueOf(2), list.get(1));     }      public void testIntCollectionAddAll() {         // make a SetUniqueList with one element         final List<Integer> list = new SetUniqueList<>(new ArrayList<Integer>(), new HashSet<Integer>());         final Integer existingElement = Integer.valueOf(1);         list.add(existingElement);          // add two new unique elements at index 0         final Integer firstNewElement = Integer.valueOf(2);         final Integer secondNewElement = Integer.valueOf(3);         Collection<Integer> collection = Arrays.asList(firstNewElement, secondNewElement);         list.addAll(0, collection);         assertEquals("Unique elements should be added.", 3, list.size());         assertEquals("First new element should be at index 0", firstNewElement, list.get(0));         assertEquals("Second new element should be at index 1", secondNewElement, list.get(1));         assertEquals("Existing element should shift to index 2", existingElement, list.get(2));          // add a duplicate element and a unique element at index 0         final Integer thirdNewElement = Integer.valueOf(4);         collection = Arrays.asList(existingElement, thirdNewElement);         list.addAll(0, collection);         assertEquals("Duplicate element should not be added, unique element should be added.",             4, list.size());         assertEquals("Third new element should be at index 0", thirdNewElement, list.get(0));     }      @SuppressWarnings("unchecked")     public void testListIterator() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          final E obj1 = (E) Integer.valueOf(1);         final E obj2 = (E) Integer.valueOf(2);         lset.add(obj1);         lset.add(obj2);          // Attempts to add a duplicate object         for (final ListIterator<E> it = lset.listIterator(); it.hasNext();) {             it.next();              if (!it.hasNext()) {                 it.add(obj1);                 break;             }         }          assertEquals("Duplicate element was added", 2, lset.size());     }      @Override     public void testListIteratorAdd() {         // override to cope with Set behavior         resetEmpty();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          final E[] elements = getOtherElements();  // changed here         ListIterator<E> iter1 = list1.listIterator();         ListIterator<E> iter2 = list2.listIterator();          for (final E element : elements) {             iter1.add(element);             iter2.add(element);             super.verify();  // changed here         }          resetFull();         iter1 = getCollection().listIterator();         iter2 = getConfirmed().listIterator();         for (final E element : elements) {             iter1.next();             iter2.next();             iter1.add(element);             iter2.add(element);             super.verify();  // changed here         }     }      //-----------------------------------------------------------------------     @Override     public void testListIteratorSet() {         // override to block         resetFull();         final ListIterator<E> it = getCollection().listIterator();         it.next();         try {             it.set(null);             fail();         } catch (final UnsupportedOperationException ex) {}     }      @Override     @SuppressWarnings("unchecked")     public void testListSetByIndex() {         // override for set behavior         resetFull();         final int size = getCollection().size();         getCollection().set(0, (E) new Long(1000));         assertEquals(size, getCollection().size());          getCollection().set(2, (E) new Long(1000));         assertEquals(size - 1, getCollection().size());         assertEquals(new Long(1000), getCollection().get(1));  // set into 2, but shifted down to 1     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         final List<E> list = new ArrayList<>(10);         final SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);         for (int i = 0; i < 10; ++i) {             uniqueList.add((E) Integer.valueOf(i));         }          final Collection<E> retained = new ArrayList<>(5);         for (int i = 0; i < 5; ++i) {             retained.add((E) Integer.valueOf(i * 2));         }          assertTrue(uniqueList.retainAll(retained));         assertEquals(5, uniqueList.size());         assertTrue(uniqueList.contains(Integer.valueOf(0)));         assertTrue(uniqueList.contains(Integer.valueOf(2)));         assertTrue(uniqueList.contains(Integer.valueOf(4)));         assertTrue(uniqueList.contains(Integer.valueOf(6)));         assertTrue(uniqueList.contains(Integer.valueOf(8)));     }      @SuppressWarnings("unchecked")     public void testRetainAllWithInitialList() {         // initialized with empty list         final List<E> list = new ArrayList<>(10);         for (int i = 0; i < 5; ++i) {             list.add((E) Integer.valueOf(i));         }         final SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);         for (int i = 5; i < 10; ++i) {             uniqueList.add((E) Integer.valueOf(i));         }          final Collection<E> retained = new ArrayList<>(5);         for (int i = 0; i < 5; ++i) {             retained.add((E) Integer.valueOf(i * 2));         }          assertTrue(uniqueList.retainAll(retained));         assertEquals(5, uniqueList.size());         assertTrue(uniqueList.contains(Integer.valueOf(0)));         assertTrue(uniqueList.contains(Integer.valueOf(2)));         assertTrue(uniqueList.contains(Integer.valueOf(4)));         assertTrue(uniqueList.contains(Integer.valueOf(6)));         assertTrue(uniqueList.contains(Integer.valueOf(8)));     }      @SuppressWarnings("unchecked")     public void testSet() {         final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<E>(), new HashSet<E>());          // Duplicate element         final E obj1 = (E) Integer.valueOf(1);         final E obj2 = (E) Integer.valueOf(2);         final E obj3 = (E) Integer.valueOf(3);          lset.add(obj1);         lset.add(obj2);         lset.set(0, obj1);         assertEquals(2, lset.size());         assertSame(obj1, lset.get(0));         assertSame(obj2, lset.get(1));          lset.clear();         lset.add(obj1);         lset.add(obj2);         lset.set(0, obj2);         assertEquals(1, lset.size());         assertSame(obj2, lset.get(0));          lset.clear();         lset.add(obj1);         lset.add(obj2);         lset.set(0, obj3);         assertEquals(2, lset.size());         assertSame(obj3, lset.get(0));         assertSame(obj2, lset.get(1));          lset.clear();         lset.add(obj1);         lset.add(obj2);         lset.set(1, obj1);         assertEquals(1, lset.size());         assertSame(obj1, lset.get(0));     }      public void testSetCollections444() {         final SetUniqueList<Integer> lset = new SetUniqueList<>(new ArrayList<Integer>(), new HashSet<Integer>());          // Duplicate element         final Integer obj1 = Integer.valueOf(1);         final Integer obj2 = Integer.valueOf(2);          lset.add(obj1);         lset.add(obj2);         lset.set(0, obj1);         assertEquals(2, lset.size());         assertSame(obj1, lset.get(0));         assertSame(obj2, lset.get(1));          assertTrue(lset.contains(obj1));         assertTrue(lset.contains(obj2));     }      @SuppressWarnings("unchecked")     public void testSetDownwardsInList() {         /*          * Checks the following semantics          * [a,b]          * set(0,b): [b]->a          * So UniqList contains [b] and a is returned          */         final ArrayList<E> l = new ArrayList<>();         final HashSet<E> s = new HashSet<>();         final SetUniqueList<E> ul = new SetUniqueList<>(l, s);          final E a = (E) new Object();         final E b = (E) new Object();         ul.add(a);         ul.add(b);         assertEquals(a, l.get(0));         assertEquals(b, l.get(1));         assertTrue(s.contains(a));         assertTrue(s.contains(b));          assertEquals(a, ul.set(0, b));         assertEquals(1, s.size());         assertEquals(1, l.size());         assertEquals(b, l.get(0));         assertTrue(s.contains(b));         assertFalse(s.contains(a));     }     @SuppressWarnings("unchecked")     public void testSetInBiggerList() {         /*          * Checks the following semantics          * [a,b,c]          * set(0,b): [b,c]->a          * So UniqList contains [b,c] and a is returned          */         final ArrayList<E> l = new ArrayList<>();         final HashSet<E> s = new HashSet<>();         final SetUniqueList<E> ul = new SetUniqueList<>(l, s);          final E a = (E) new Object();         final E b = (E) new Object();         final E c = (E) new Object();          ul.add(a);         ul.add(b);         ul.add(c);         assertEquals(a, l.get(0));         assertEquals(b, l.get(1));         assertEquals(c, l.get(2));         assertTrue(s.contains(a));         assertTrue(s.contains(b));         assertTrue(s.contains(c));          assertEquals(a, ul.set(0, b));         assertEquals(2, s.size());         assertEquals(2, l.size());         assertEquals(b, l.get(0));         assertEquals(c, l.get(1));         assertFalse(s.contains(a));         assertTrue(s.contains(b));         assertTrue(s.contains(c));     }      @SuppressWarnings("unchecked")     public void testSetUpwardsInList() {         /*          * Checks the following semantics          * [a,b,c]          * set(1,a): [a,c]->b          * So UniqList contains [a,c] and b is returned          */         final ArrayList<E> l = new ArrayList<>();         final HashSet<E> s = new HashSet<>();         final SetUniqueList<E> ul = new SetUniqueList<>(l, s);          final E a = (E) "A";         final E b = (E) "B";         final E c = (E) "C";          ul.add(a);         ul.add(b);         ul.add(c);         assertEquals(a, l.get(0));         assertEquals(b, l.get(1));         assertEquals(c, l.get(2));         assertTrue(s.contains(a));         assertTrue(s.contains(b));         assertTrue(s.contains(c));          assertEquals(b, ul.set(1, a));         assertEquals(2, s.size());         assertEquals(2, l.size());         assertEquals(a, l.get(0));         assertEquals(c, l.get(1));         assertTrue(s.contains(a));         assertFalse(s.contains(b));         assertTrue(s.contains(c));     }      public void testSubListIsUnmodifiable() {         resetFull();         final List<E> subList = getCollection().subList(1, 3);         try {             subList.remove(0);             fail("subList should be unmodifiable");         } catch (final UnsupportedOperationException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testUniqueListDoubleInsert() {         final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());         l.add((E) new Object());         l.add((E) new Object());          // duplicate is removed         l.set(0, l.get(1));         assertEquals(1, l.size());          // duplicate should be removed again         l.add(1, l.get(0));         assertEquals(1, l.size());     }      @SuppressWarnings("unchecked")     public void testUniqueListReInsert() {         final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());         l.add((E) new Object());         l.add((E) new Object());          final E a = l.get(0);          // duplicate is removed         l.set(0, l.get(1));         assertEquals(1, l.size());          // old object is added back in         l.add(1, a);         assertEquals(2, l.size());     }      @Override     @SuppressWarnings("unchecked")     public void verify() {         super.verify();          if (extraVerify) {             final int size = getCollection().size();             getCollection().add((E) new Long(1000));             assertEquals(size + 1, getCollection().size());              getCollection().add((E) new Long(1000));             assertEquals(size + 1, getCollection().size());             assertEquals(new Long(1000), getCollection().get(size));              getCollection().remove(size);         }     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SetUniqueList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SetUniqueList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import org.junit.Assert;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  /**  * Extension of {@link AbstractListTest} for exercising the {@link FixedSizeList}  * implementation.  *  * @since 3.0  */ public class FixedSizeListTest<E> extends AbstractListTest<E> {      public FixedSizeListTest(final String testName) {         super(testName);     }      @Override     public List<E> makeObject() {         return FixedSizeList.fixedSizeList(new ArrayList<E>());     }      @Override     public List<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return FixedSizeList.fixedSizeList(list);     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/FixedSizeList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/FixedSizeList.fullCollection.version4.obj"); //    }      public void testListAllowsMutationOfUnderlyingCollection() {          final List<String> decoratedList = new ArrayList<>();         decoratedList.add("item 1");         decoratedList.add("item 2");         //         final FixedSizeList<String> fixedSizeList = FixedSizeList.fixedSizeList(decoratedList);         final int sizeBefore = fixedSizeList.size();         //         final boolean changed = decoratedList.add("New Value");         Assert.assertTrue(changed);         //         Assert.assertEquals("Modifying an the underlying list is allowed",                 sizeBefore + 1, fixedSizeList.size());     }      private FixedSizeList<String> initFixedSizeList() {         final List<String> decoratedList = new ArrayList<>();         decoratedList.add("item 1");         decoratedList.add("item 2");         //         return FixedSizeList.fixedSizeList(decoratedList);     }      public void testAdd() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          try {             fixedSizeList.add(2, "New Value");             fail();         } catch (final UnsupportedOperationException ex) {}     }       public void testAddAll() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          final List<String> addList = new ArrayList<>();         addList.add("item 3");         addList.add("item 4");          try {             fixedSizeList.addAll(2, addList);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testRemove() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          try {             fixedSizeList.remove(1);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testSubList() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          final List<String> subFixedSizeList = fixedSizeList.subList(1, 1);         Assert.assertNotNull(subFixedSizeList);         Assert.assertEquals(0, subFixedSizeList.size());     }      public void testIsFull() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          Assert.assertTrue(fixedSizeList.isFull());     }      public void testMaxSize() {         final FixedSizeList<String> fixedSizeList = initFixedSizeList();          Assert.assertEquals(2, fixedSizeList.maxSize());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Test class.  *  */ public class CursorableLinkedListTest<E> extends AbstractLinkedListTest<E> {     public CursorableLinkedListTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(CursorableLinkedListTest.class);     }      private CursorableLinkedList<E> list;      @Override     public void setUp() {         list = new CursorableLinkedList<>();     }      @Override     public CursorableLinkedList<E> makeObject() {         return new CursorableLinkedList<>();     }      @SuppressWarnings("unchecked")     public void testAdd() {         assertEquals("[]", list.toString());         assertTrue(list.add((E) Integer.valueOf(1)));         assertEquals("[1]", list.toString());         assertTrue(list.add((E) Integer.valueOf(2)));         assertEquals("[1, 2]", list.toString());         assertTrue(list.add((E) Integer.valueOf(3)));         assertEquals("[1, 2, 3]", list.toString());         assertTrue(list.addFirst((E) Integer.valueOf(0)));         assertEquals("[0, 1, 2, 3]", list.toString());         assertTrue(list.addLast((E) Integer.valueOf(4)));         assertEquals("[0, 1, 2, 3, 4]", list.toString());         list.add(0, (E) Integer.valueOf(-2));         assertEquals("[-2, 0, 1, 2, 3, 4]", list.toString());         list.add(1, (E) Integer.valueOf(-1));         assertEquals("[-2, -1, 0, 1, 2, 3, 4]", list.toString());         list.add(7, (E) Integer.valueOf(5));         assertEquals("[-2, -1, 0, 1, 2, 3, 4, 5]", list.toString());          final List<E> list2 = new LinkedList<>();         list2.add((E) "A");         list2.add((E) "B");         list2.add((E) "C");          assertTrue(list.addAll(list2));         assertEquals("[-2, -1, 0, 1, 2, 3, 4, 5, A, B, C]", list.toString());         assertTrue(list.addAll(3, list2));         assertEquals("[-2, -1, 0, A, B, C, 1, 2, 3, 4, 5, A, B, C]", list.toString());     }      @SuppressWarnings("unchecked")     public void testClear() {         assertEquals(0, list.size());         assertTrue(list.isEmpty());         list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());          list.add((E) "element");         assertEquals(1, list.size());         assertTrue(!list.isEmpty());          list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());          list.add((E) "element1");         list.add((E) "element2");         assertEquals(2, list.size());         assertTrue(!list.isEmpty());          list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());          for (int i = 0; i < 1000; i++) {             list.add((E) Integer.valueOf(i));         }         assertEquals(1000, list.size());         assertTrue(!list.isEmpty());          list.clear();         assertEquals(0, list.size());         assertTrue(list.isEmpty());     }      @SuppressWarnings("unchecked")     public void testContains() {         assertTrue(!list.contains("A"));         assertTrue(list.add((E) "A"));         assertTrue(list.contains("A"));         assertTrue(list.add((E) "B"));         assertTrue(list.contains("A"));         assertTrue(list.addFirst((E) "a"));         assertTrue(list.contains("A"));         assertTrue(list.remove("a"));         assertTrue(list.contains("A"));         assertTrue(list.remove("A"));         assertTrue(!list.contains("A"));     }      @SuppressWarnings("unchecked")     public void testContainsAll() {         assertTrue(list.containsAll(list));         final java.util.List<E> list2 = new java.util.LinkedList<>();         assertTrue(list.containsAll(list2));         list2.add((E) "A");         assertTrue(!list.containsAll(list2));         list.add((E) "B");         list.add((E) "A");         assertTrue(list.containsAll(list2));         list2.add((E) "B");         assertTrue(list.containsAll(list2));         list2.add((E) "C");         assertTrue(!list.containsAll(list2));         list.add((E) "C");         assertTrue(list.containsAll(list2));         list2.add((E) "C");         assertTrue(list.containsAll(list2));         assertTrue(list.containsAll(list));     }      @SuppressWarnings("unchecked")     public void testCursorNavigation() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         final CursorableLinkedList.Cursor<E> it = list.cursor();         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("3", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("4", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("5", it.next());         assertTrue(!it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("5", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("4", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("3", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorSet() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> it = list.cursor();         assertEquals("1", it.next());         it.set((E) "a");         assertEquals("a", it.previous());         it.set((E) "A");         assertEquals("A", it.next());         assertEquals("2", it.next());         it.set((E) "B");         assertEquals("3", it.next());         assertEquals("4", it.next());         it.set((E) "D");         assertEquals("5", it.next());         it.set((E) "E");         assertEquals("[A, B, 3, D, E]", list.toString());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorRemove() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> it = list.cursor();         try {             it.remove();             fail();         } catch (final IllegalStateException e) {             // expected         }         assertEquals("1", it.next());         assertEquals("2", it.next());         assertEquals("[1, 2, 3, 4, 5]", list.toString());         it.remove();         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("3", it.next());         assertEquals("3", it.previous());         assertEquals("1", it.previous());         it.remove();         assertEquals("[3, 4, 5]", list.toString());         assertTrue(!it.hasPrevious());         assertEquals("3", it.next());         it.remove();         assertEquals("[4, 5]", list.toString());         try {             it.remove();         } catch (final IllegalStateException e) {             // expected         }         assertEquals("4", it.next());         assertEquals("5", it.next());         it.remove();         assertEquals("[4]", list.toString());         assertEquals("4", it.previous());         it.remove();         assertEquals("[]", list.toString());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorAdd() {         final CursorableLinkedList.Cursor<E> it = list.cursor();         it.add((E) "1");         assertEquals("[1]", list.toString());         it.add((E) "3");         assertEquals("[1, 3]", list.toString());         it.add((E) "5");         assertEquals("[1, 3, 5]", list.toString());         assertEquals("5", it.previous());         it.add((E) "4");         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("4", it.previous());         assertEquals("3", it.previous());         it.add((E) "2");         assertEquals("[1, 2, 3, 4, 5]", list.toString());         it.close();     }      @SuppressWarnings("unchecked")     public void testCursorConcurrentModification() {         // this test verifies that cursors remain valid when the list         // is modified via other means.         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");         list.add((E) "7");         list.add((E) "9");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         final CursorableLinkedList.Cursor<E> c2 = list.cursor();         final Iterator<E> li = list.iterator();          // test cursors remain valid when list modified by std Iterator         // test cursors skip elements removed via ListIterator         assertEquals("1", li.next());         assertEquals("2", li.next());         li.remove();         assertEquals("3", li.next());         assertEquals("1", c1.next());         assertEquals("3", c1.next());         assertEquals("1", c2.next());          // test cursor c1 can remove elements from previously modified list         // test cursor c2 skips elements removed via different cursor         c1.remove();         assertEquals("5", c2.next());         c2.add((E) "6");         assertEquals("5", c1.next());         assertEquals("6", c1.next());         assertEquals("7", c1.next());          // test cursors remain valid when list mod via CursorableLinkedList         // test cursor remains valid when elements inserted into list before         // the current position of the cursor.         list.add(0, (E) "0");          // test cursor remains valid when element inserted immediately after         // current element of a cursor, and the element is seen on the         // next call to the next method of that cursor.         list.add(5, (E) "8");          assertEquals("8", c1.next());         assertEquals("9", c1.next());         c1.add((E) "10");         assertEquals("7", c2.next());         assertEquals("8", c2.next());         assertEquals("9", c2.next());         assertEquals("10", c2.next());          try {             c2.next();             fail();         } catch (final NoSuchElementException nse) {         }          try {             li.next();             fail();         } catch (final ConcurrentModificationException cme) {         }          c1.close(); // not necessary         c2.close(); // not necessary     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexMid() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         final Iterator<E> li = list.iterator();          // test cursors remain valid when list modified by std Iterator         // test cursors skip elements removed via ListIterator         assertEquals("1", li.next());         assertEquals("2", li.next());         li.remove();         assertEquals(0, c1.nextIndex());         assertEquals("1", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("3", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexFirst() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         list.remove(0);         assertEquals(0, c1.nextIndex());         assertEquals("2", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("3", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexAddBefore() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         assertEquals("1", c1.next());         list.add(0, (E) "0");         assertEquals(2, c1.nextIndex());         assertEquals("2", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexAddNext() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         list.add(0, (E) "0");         assertEquals(0, c1.nextIndex());         assertEquals("0", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("1", c1.next());     }      @SuppressWarnings("unchecked")     public void testCursorNextIndexAddAfter() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "5");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();          assertEquals(0, c1.nextIndex());         list.add(1, (E) "0");         assertEquals(0, c1.nextIndex());         assertEquals("1", c1.next());         assertEquals(1, c1.nextIndex());         assertEquals("0", c1.next());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          assertEquals("B", list.remove(1));          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(true, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());          assertEquals("B", list.remove(1));          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals("A", c1.current.value);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         c1.remove();  // works ok         assertEquals("[C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          assertEquals("B", list.remove(1));          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(true, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextNextRemoveIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("C", c1.next());          assertEquals("B", list.remove(1));          assertEquals(false, c1.nextIndexValid);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals("C", c1.current.value);         assertEquals("D", c1.next.value);          assertEquals("[A, C, D]", list.toString());         c1.remove();  // works ok         assertEquals("[A, D]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousRemoveByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          c1.remove();          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextRemoveByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          c1.remove();          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousAddIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          list.add(1, (E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals("B", c1.current.value);         assertEquals("Z", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, Z, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextAddIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());          list.add(1, (E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals("A", c1.current.value);         assertEquals("Z", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         c1.remove();  // works ok         assertEquals("[Z, B, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextAddIndex1ByList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          list.add(1, (E) "Z");          assertEquals(false, c1.nextIndexValid);         assertEquals("B", c1.current.value);         assertEquals("C", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, Z, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousAddByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          c1.add((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(2, c1.nextIndex);         assertEquals(null, c1.current);         assertEquals("B", c1.next.value);          assertEquals("[A, Z, B, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextAddByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          c1.add((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(3, c1.nextIndex);         assertEquals(false, c1.currentRemovedByAnother);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);          assertEquals("[A, B, Z, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextRemoveByListSetByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          list.remove(1);          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals(null, c1.current);         assertEquals("C", c1.next.value);         assertEquals("[A, C]", list.toString());          try {             c1.set((E) "Z");             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextPreviousSetByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());         assertEquals("B", c1.previous());          c1.set((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(1, c1.nextIndex);         assertEquals("Z", c1.current.value);         assertEquals("Z", c1.next.value);          assertEquals("[A, Z, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      @SuppressWarnings("unchecked")     public void testInternalState_CursorNextNextSetByIterator() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");          final CursorableLinkedList.Cursor<E> c1 = list.cursor();         assertEquals("A", c1.next());         assertEquals("B", c1.next());          c1.set((E) "Z");          assertEquals(true, c1.nextIndexValid);         assertEquals(2, c1.nextIndex);         assertEquals("Z", c1.current.value);         assertEquals("C", c1.next.value);          assertEquals("[A, Z, C]", list.toString());         c1.remove();  // works ok         assertEquals("[A, C]", list.toString());         try {             c1.remove();             fail();         } catch (final IllegalStateException ex) {}     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEqualsAndHashCode() {         assertTrue(list.equals(list));         assertEquals(list.hashCode(), list.hashCode());         list.add((E) "A");         assertTrue(list.equals(list));         assertEquals(list.hashCode(), list.hashCode());          final CursorableLinkedList<E> list2 = new CursorableLinkedList<>();         assertTrue(!list.equals(list2));         assertTrue(!list2.equals(list));          final java.util.List<E> list3 = new java.util.LinkedList<>();         assertTrue(!list.equals(list3));         assertTrue(!list3.equals(list));         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list2.hashCode(), list3.hashCode());          list2.add((E) "A");         assertTrue(list.equals(list2));         assertTrue(list2.equals(list));         assertTrue(!list2.equals(list3));         assertTrue(!list3.equals(list2));          list3.add((E) "A");         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list2.hashCode(), list3.hashCode());          list.add((E) "B");         assertTrue(list.equals(list));         assertTrue(!list.equals(list2));         assertTrue(!list2.equals(list));         assertTrue(!list.equals(list3));         assertTrue(!list3.equals(list));          list2.add((E) "B");         list3.add((E) "B");         assertTrue(list.equals(list));         assertTrue(list.equals(list2));         assertTrue(list2.equals(list));         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list2.hashCode(), list3.hashCode());          list.add((E) "C");         list2.add((E) "C");         list3.add((E) "C");         assertTrue(list.equals(list));         assertTrue(list.equals(list2));         assertTrue(list2.equals(list));         assertTrue(list2.equals(list3));         assertTrue(list3.equals(list2));         assertEquals(list.hashCode(), list2.hashCode());         assertEquals(list2.hashCode(), list3.hashCode());          list.add((E) "D");         list2.addFirst((E) "D");         assertTrue(list.equals(list));         assertTrue(!list.equals(list2));         assertTrue(!list2.equals(list));     }      @SuppressWarnings("unchecked")     public void testGet() {         try {             list.get(0);             fail("shouldn't get here");         } catch(final IndexOutOfBoundsException e) {             // expected         }          assertTrue(list.add((E) "A"));         assertEquals("A", list.get(0));         assertTrue(list.add((E) "B"));         assertEquals("A", list.get(0));         assertEquals("B", list.get(1));          try {             list.get(-1);             fail("shouldn't get here");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(2);             fail("shouldn't get here");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testIndexOf() {         assertEquals(-1, list.indexOf("A"));         assertEquals(-1, list.lastIndexOf("A"));         list.add((E) "A");         assertEquals(0, list.indexOf("A"));         assertEquals(0, list.lastIndexOf("A"));         assertEquals(-1, list.indexOf("B"));         assertEquals(-1, list.lastIndexOf("B"));         list.add((E) "B");         assertEquals(0, list.indexOf("A"));         assertEquals(0, list.lastIndexOf("A"));         assertEquals(1, list.indexOf("B"));         assertEquals(1, list.lastIndexOf("B"));         list.addFirst((E) "B");         assertEquals(1, list.indexOf("A"));         assertEquals(1, list.lastIndexOf("A"));         assertEquals(0, list.indexOf("B"));         assertEquals(2, list.lastIndexOf("B"));     }      @SuppressWarnings("unchecked")     public void testIsEmpty() {         assertTrue(list.isEmpty());         list.add((E) "element");         assertTrue(!list.isEmpty());         list.remove("element");         assertTrue(list.isEmpty());         list.add((E) "element");         assertTrue(!list.isEmpty());         list.clear();         assertTrue(list.isEmpty());     }      @SuppressWarnings("unchecked")     public void testIterator() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         Iterator<E> it = list.iterator();         assertTrue(it.hasNext());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertEquals("3", it.next());         assertTrue(it.hasNext());         assertEquals("4", it.next());         assertTrue(it.hasNext());         assertEquals("5", it.next());         assertTrue(!it.hasNext());          it = list.iterator();         assertTrue(it.hasNext());         assertEquals("1", it.next());         it.remove();         assertEquals("[2, 3, 4, 5]", list.toString());         assertTrue(it.hasNext());         assertEquals("2", it.next());         it.remove();         assertEquals("[3, 4, 5]", list.toString());         assertTrue(it.hasNext());         assertEquals("3", it.next());         it.remove();         assertEquals("[4, 5]", list.toString());         assertTrue(it.hasNext());         assertEquals("4", it.next());         it.remove();         assertEquals("[5]", list.toString());         assertTrue(it.hasNext());         assertEquals("5", it.next());         it.remove();         assertEquals("[]", list.toString());         assertTrue(!it.hasNext());     }      @SuppressWarnings("unchecked")     public void testListIteratorNavigation() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         final ListIterator<E> it = list.listIterator();         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals(-1, it.previousIndex());         assertEquals(0, it.nextIndex());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals(-1, it.previousIndex());         assertEquals(0, it.nextIndex());         assertEquals("1", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals(2, it.nextIndex());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("2", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals(2, it.nextIndex());         assertEquals("3", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(2, it.previousIndex());         assertEquals(3, it.nextIndex());         assertEquals("4", it.next());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(3, it.previousIndex());         assertEquals(4, it.nextIndex());         assertEquals("5", it.next());         assertTrue(!it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(4, it.previousIndex());         assertEquals(5, it.nextIndex());         assertEquals("5", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(3, it.previousIndex());         assertEquals(4, it.nextIndex());         assertEquals("4", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(2, it.previousIndex());         assertEquals(3, it.nextIndex());         assertEquals("3", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(1, it.previousIndex());         assertEquals(2, it.nextIndex());         assertEquals("2", it.previous());         assertTrue(it.hasNext());         assertTrue(it.hasPrevious());         assertEquals(0, it.previousIndex());         assertEquals(1, it.nextIndex());         assertEquals("1", it.previous());         assertTrue(it.hasNext());         assertTrue(!it.hasPrevious());         assertEquals(-1, it.previousIndex());         assertEquals(0, it.nextIndex());     }      @Override     @SuppressWarnings("unchecked")     public void testListIteratorSet() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final ListIterator<E> it = list.listIterator();         assertEquals("1", it.next());         it.set((E) "a");         assertEquals("a", it.previous());         it.set((E) "A");         assertEquals("A", it.next());         assertEquals("2", it.next());         it.set((E) "B");         assertEquals("3", it.next());         assertEquals("4", it.next());         it.set((E) "D");         assertEquals("5", it.next());         it.set((E) "E");         assertEquals("[A, B, 3, D, E]", list.toString());     }      @SuppressWarnings("unchecked")     public void testListIteratorRemove() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final ListIterator<E> it = list.listIterator();         try {             it.remove();         } catch(final IllegalStateException e) {             // expected         }         assertEquals("1", it.next());         assertEquals("2", it.next());         assertEquals("[1, 2, 3, 4, 5]", list.toString());         it.remove();         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("3", it.next());         assertEquals("3", it.previous());         assertEquals("1", it.previous());         it.remove();         assertEquals("[3, 4, 5]", list.toString());         assertTrue(!it.hasPrevious());         assertEquals("3", it.next());         it.remove();         assertEquals("[4, 5]", list.toString());         try {             it.remove();         } catch (final IllegalStateException e) {             // expected         }         assertEquals("4", it.next());         assertEquals("5", it.next());         it.remove();         assertEquals("[4]", list.toString());         assertEquals("4", it.previous());         it.remove();         assertEquals("[]", list.toString());     }      @Override     @SuppressWarnings("unchecked")     public void testListIteratorAdd() {         final ListIterator<E> it = list.listIterator();         it.add((E) "1");         assertEquals("[1]", list.toString());         it.add((E) "3");         assertEquals("[1, 3]", list.toString());         it.add((E) "5");         assertEquals("[1, 3, 5]", list.toString());         assertEquals("5", it.previous());         it.add((E) "4");         assertEquals("[1, 3, 4, 5]", list.toString());         assertEquals("4", it.previous());         assertEquals("3", it.previous());         it.add((E) "2");         assertEquals("[1, 2, 3, 4, 5]", list.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveAll() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final HashSet<E> set = new HashSet<>();         set.add((E) "A");         set.add((E) "2");         set.add((E) "C");         set.add((E) "4");         set.add((E) "D");          assertTrue(list.removeAll(set));         assertEquals("[1, 3, 5]", list.toString());         assertTrue(!list.removeAll(set));     }      @SuppressWarnings("unchecked")     public void testRemoveByIndex() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         assertEquals("[1, 2, 3, 4, 5]", list.toString());         assertEquals("1", list.remove(0));         assertEquals("[2, 3, 4, 5]", list.toString());         assertEquals("3", list.remove(1));         assertEquals("[2, 4, 5]", list.toString());         assertEquals("4", list.remove(1));         assertEquals("[2, 5]", list.toString());         assertEquals("5", list.remove(1));         assertEquals("[2]", list.toString());         assertEquals("2", list.remove(0));         assertEquals("[]", list.toString());     }      @SuppressWarnings("unchecked")     public void testRemove() {         list.add((E) "1");         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         assertEquals("[1, 1, 2, 3, 4, 5, 2, 3, 4, 5]", list.toString());         assertTrue(!list.remove("6"));         assertTrue(list.remove("5"));         assertEquals("[1, 1, 2, 3, 4, 2, 3, 4, 5]", list.toString());         assertTrue(list.remove("5"));         assertEquals("[1, 1, 2, 3, 4, 2, 3, 4]", list.toString());         assertTrue(!list.remove("5"));         assertTrue(list.remove("1"));         assertEquals("[1, 2, 3, 4, 2, 3, 4]", list.toString());         assertTrue(list.remove("1"));         assertEquals("[2, 3, 4, 2, 3, 4]", list.toString());         assertTrue(list.remove("2"));         assertEquals("[3, 4, 2, 3, 4]", list.toString());         assertTrue(list.remove("2"));         assertEquals("[3, 4, 3, 4]", list.toString());         assertTrue(list.remove("3"));         assertEquals("[4, 3, 4]", list.toString());         assertTrue(list.remove("3"));         assertEquals("[4, 4]", list.toString());         assertTrue(list.remove("4"));         assertEquals("[4]", list.toString());         assertTrue(list.remove("4"));         assertEquals("[]", list.toString());     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         list.add((E) "1");         list.add((E) "1");         list.add((E) "2");         list.add((E) "2");         list.add((E) "3");         list.add((E) "3");         list.add((E) "4");         list.add((E) "4");         list.add((E) "5");         list.add((E) "5");          final HashSet<E> set = new HashSet<>();         set.add((E) "A");         set.add((E) "2");         set.add((E) "C");         set.add((E) "4");         set.add((E) "D");          assertTrue(list.retainAll(set));         assertEquals("[2, 2, 4, 4]", list.toString());         assertTrue(!list.retainAll(set));     }      @SuppressWarnings("unchecked")     public void testSet() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");         assertEquals("[1, 2, 3, 4, 5]", list.toString());         list.set(0, (E) "A");         assertEquals("[A, 2, 3, 4, 5]", list.toString());         list.set(1, (E) "B");         assertEquals("[A, B, 3, 4, 5]", list.toString());         list.set(2, (E) "C");         assertEquals("[A, B, C, 4, 5]", list.toString());         list.set(3, (E) "D");         assertEquals("[A, B, C, D, 5]", list.toString());         list.set(4, (E) "E");         assertEquals("[A, B, C, D, E]", list.toString());     }      @SuppressWarnings("unchecked")     public void testSubList() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          assertEquals("[A, B, C, D, E]", list.toString());         assertEquals("[A, B, C, D, E]", list.subList(0, 5).toString());         assertEquals("[B, C, D, E]", list.subList(1, 5).toString());         assertEquals("[C, D, E]", list.subList(2, 5).toString());         assertEquals("[D, E]", list.subList(3, 5).toString());         assertEquals("[E]", list.subList(4, 5).toString());         assertEquals("[]", list.subList(5, 5).toString());     }      @SuppressWarnings("unchecked")     public void testSubListAddEnd() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(5, 5);         sublist.add((E) "F");         assertEquals("[A, B, C, D, E, F]", list.toString());         assertEquals("[F]", sublist.toString());         sublist.add((E) "G");         assertEquals("[A, B, C, D, E, F, G]", list.toString());         assertEquals("[F, G]", sublist.toString());     }      @SuppressWarnings("unchecked")     public void testSubListAddBegin() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(0, 0);         sublist.add((E) "a");         assertEquals("[a, A, B, C, D, E]", list.toString());         assertEquals("[a]", sublist.toString());         sublist.add((E) "b");         assertEquals("[a, b, A, B, C, D, E]", list.toString());         assertEquals("[a, b]", sublist.toString());     }      @SuppressWarnings("unchecked")     public void testSubListAddMiddle() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(1, 3);         sublist.add((E) "a");         assertEquals("[A, B, C, a, D, E]", list.toString());         assertEquals("[B, C, a]", sublist.toString());         sublist.add((E) "b");         assertEquals("[A, B, C, a, b, D, E]", list.toString());         assertEquals("[B, C, a, b]", sublist.toString());     }      @SuppressWarnings("unchecked")     public void testSubListRemove() {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final List<E> sublist = list.subList(1, 4);         assertEquals("[B, C, D]", sublist.toString());         assertEquals("[A, B, C, D, E]", list.toString());         sublist.remove("C");         assertEquals("[B, D]", sublist.toString());         assertEquals("[A, B, D, E]", list.toString());         sublist.remove(1);         assertEquals("[B]", sublist.toString());         assertEquals("[A, B, E]", list.toString());         sublist.clear();         assertEquals("[]", sublist.toString());         assertEquals("[A, E]", list.toString());     }      @SuppressWarnings("unchecked")     public void testToArray() {         list.add((E) "1");         list.add((E) "2");         list.add((E) "3");         list.add((E) "4");         list.add((E) "5");          final Object[] elts = list.toArray();         assertEquals("1", elts[0]);         assertEquals("2", elts[1]);         assertEquals("3", elts[2]);         assertEquals("4", elts[3]);         assertEquals("5", elts[4]);         assertEquals(5, elts.length);          final String[] elts2 = list.toArray(new String[0]);         assertEquals("1", elts2[0]);         assertEquals("2", elts2[1]);         assertEquals("3", elts2[2]);         assertEquals("4", elts2[3]);         assertEquals("5", elts2[4]);         assertEquals(5, elts2.length);          final String[] elts3 = new String[5];         assertSame(elts3, list.toArray(elts3));         assertEquals("1", elts3[0]);         assertEquals("2", elts3[1]);         assertEquals("3", elts3[2]);         assertEquals("4", elts3[3]);         assertEquals("5", elts3[4]);         assertEquals(5, elts3.length);          final String[] elts4 = new String[3];         final String[] elts4b = list.toArray(elts4);         assertTrue(elts4 != elts4b);         assertEquals("1", elts4b[0]);         assertEquals("2", elts4b[1]);         assertEquals("3", elts4b[2]);         assertEquals("4", elts4b[3]);         assertEquals("5", elts4b[4]);         assertEquals(5, elts4b.length);     }      @SuppressWarnings("unchecked")     public void testSerialization() throws Exception {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");          final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();         final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);         out.writeObject(list);         out.flush();         out.close();          final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());         final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);         final Object list2 = in.readObject();          assertTrue(list != list2);         assertTrue(list2.equals(list));         assertTrue(list.equals(list2));     }      @SuppressWarnings("unchecked")     public void testSerializationWithOpenCursor() throws Exception {         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         list.add((E) "D");         list.add((E) "E");         final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();         final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);         out.writeObject(list);         out.flush();         out.close();          final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());         final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);         final Object list2 = in.readObject();          assertTrue(list != list2);         assertTrue(list2.equals(list));         assertTrue(list.equals(list2));     }      @SuppressWarnings("unchecked")     public void testLongSerialization() throws Exception {         // recursive serialization will cause a stack         // overflow exception with long lists         for (int i = 0; i < 10000; i++) {             list.add((E) Integer.valueOf(i));         }          final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();         final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);         out.writeObject(list);         out.flush();         out.close();          final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());         final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);         final Object list2 = in.readObject();          assertTrue(list != list2);         assertTrue(list2.equals(list));         assertTrue(list.equals(list2));     }      /**      *  Ignore the serialization tests for sublists and sub-sublists.      *      *  @return an array of sublist serialization test names      */     @Override     public String[] ignoredTests() {         final ArrayList<String> list = new ArrayList<>();         final String prefix = "CursorableLinkedListTest";         final String bulk = ".bulkTestSubList";         final String[] ignored = new String[] {             ".testEmptyListSerialization",             ".testFullListSerialization",             ".testEmptyListCompatibility",             ".testFullListCompatibility",             ".testSimpleSerialization",             ".testCanonicalEmptyCollectionExists",             ".testCanonicalFullCollectionExists",             ".testSerializeDeserializeThenCompare"         };         for (final String element : ignored) {             list.add(prefix + bulk + element);             list.add(prefix + bulk + bulk + element);         }         return list.toArray(new String[0]);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CursorableLinkedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CursorableLinkedList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.io.IOException; import java.io.Serializable; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.AbstractCollection; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.List; import java.util.ListIterator; import java.util.NoSuchElementException;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.iterators.AbstractListIteratorTest;  /**  * Abstract test class for {@link java.util.List} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your {@link List} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link List} fails or override one of the  * protected methods from AbstractCollectionTest.  *  */ public abstract class AbstractListTest<E> extends AbstractCollectionTest<E> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractListTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the <code>set operation.<p>      *  Default implementation returns true.  Override if your collection      *  class does not support set.      */     public boolean isSetSupported() {         return true;     }      //-----------------------------------------------------------------------     /**      *  Verifies that the test list implementation matches the confirmed list      *  implementation.      */     @Override     @SuppressWarnings("unchecked")     public void verify() {         super.verify();          final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          assertEquals("List should equal confirmed", list1, list2);         assertEquals("Confirmed should equal list", list2, list1);          assertEquals("Hash codes should be equal", list1.hashCode(), list2.hashCode());          int i = 0;         final Iterator<E> iterator1 = list1.iterator();         final Iterator<E> iterator2 = list2.iterator();         final E[] array = (E[]) list1.toArray();         while (iterator2.hasNext()) {             assertTrue("List iterator should have next", iterator1.hasNext());             final Object o1 = iterator1.next();             Object o2 = iterator2.next();             assertEquals("Iterator elements should be equal", o1, o2);             o2 = list1.get(i);             assertEquals("get should return correct element", o1, o2);             o2 = array[i];             assertEquals("toArray should have correct element", o1, o2);             i++;         }     }      //-----------------------------------------------------------------------     /**      * List equals method is defined.      */     @Override     public boolean isEqualsCheckable() {         return true;     }      /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedCollection() {         final ArrayList<E> list = new ArrayList<>();         return list;     }      /**      * Returns a full {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      /**      * Returns {@link #makeObject()}.      *      * @return an empty list to be used for testing      */     @Override     public abstract List<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public List<E> makeFullCollection() {         // only works if list supports optional "addAll(Collection)"         final List<E> list = makeObject();         list.addAll(Arrays.asList(getFullElements()));         return list;     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link List}.      *      * @return the collection field as a List      */     @Override     public List<E> getCollection() {         return (List<E>) super.getCollection();     }      /**      * Returns the {@link #confirmed} field cast to a {@link List}.      *      * @return the confirmed field as a List      */     @Override     public List<E> getConfirmed() {         return (List<E>) super.getConfirmed();     }      //-----------------------------------------------------------------------     /**      *  Tests bounds checking for {@link List#add(int, Object)} on an      *  empty list.      */     public void testListAddByIndexBoundsChecking() {         if (!isAddSupported()) {             return;         }          List<E> list;         final E element = getOtherElements()[0];          try {             list = makeObject();             list.add(Integer.MIN_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeObject();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeObject();             list.add(1, element);             fail("List.add should throw IndexOutOfBoundsException [1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeObject();             list.add(Integer.MAX_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests bounds checking for {@link List#add(int, Object)} on a      *  full list.      */     public void testListAddByIndexBoundsChecking2() {         if (!isAddSupported()) {             return;         }          List<E> list;         final E element = getOtherElements()[0];          try {             list = makeFullCollection();             list.add(Integer.MIN_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeFullCollection();             list.add(-1, element);             fail("List.add should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeFullCollection();             list.add(list.size() + 1, element);             fail("List.add should throw IndexOutOfBoundsException [size + 1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list = makeFullCollection();             list.add(Integer.MAX_VALUE, element);             fail("List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests {@link List#add(int,Object)}.      */     public void testListAddByIndex() {         if (!isAddSupported()) {             return;         }          final E element = getOtherElements()[0];         final int max = getFullElements().length;          for (int i = 0; i <= max; i++) {             resetFull();             getCollection().add(i, element);             getConfirmed().add(i, element);             verify();         }     }      /**      *  Tests {@link List#equals(Object)}.      */     public void testListEquals() {         resetEmpty();         List<E> list = getCollection();         assertEquals("Empty lists should be equal", true, list.equals(getConfirmed()));         verify();         assertEquals("Empty list should equal self", true, list.equals(list));         verify();          List<E> list2 = Arrays.asList(getFullElements());         assertEquals("Empty list shouldn't equal full", false, list.equals(list2));         verify();          list2 = Arrays.asList(getOtherElements());         assertEquals("Empty list shouldn't equal other", false, list.equals(list2));         verify();          resetFull();         list = getCollection();         assertEquals("Full lists should be equal", true, list.equals(getConfirmed()));         verify();         assertEquals("Full list should equal self", true, list.equals(list));         verify();          list2 = makeObject();         assertEquals("Full list shouldn't equal empty", false, list.equals(list2));         verify();          list2 = Arrays.asList(getOtherElements());         assertEquals("Full list shouldn't equal other", false, list.equals(list2));         verify();          list2 = Arrays.asList(getFullElements());         if (list2.size() < 2 && isAddSupported()) {             // main list is only size 1, so lets add other elements to get a better list             list.addAll(Arrays.asList(getOtherElements()));             getConfirmed().addAll(Arrays.asList(getOtherElements()));             list2 = new ArrayList<>(list2);             list2.addAll(Arrays.asList(getOtherElements()));         }         if (list2.size() > 1) {             Collections.reverse(list2);             assertEquals(                 "Full list shouldn't equal full list with same elements but different order",                 false, list.equals(list2));             verify();         }          resetFull();         list = getCollection();         assertEquals("List shouldn't equal String", false, list.equals(""));         verify();          final List<E> listForC = Arrays.asList(getFullElements());         final Collection<E> c = new AbstractCollection<E>() {             @Override             public int size() {                 return listForC.size();             }              @Override             public Iterator<E> iterator() {                 return listForC.iterator();             }         };          assertEquals("List shouldn't equal nonlist with same elements in same order", false, list.equals(c));         verify();     }      /**      *  Tests {@link List#hashCode()}.      */     public void testListHashCode() {         resetEmpty();         int hash1 = getCollection().hashCode();         int hash2 = getConfirmed().hashCode();         assertEquals("Empty lists should have equal hashCodes", hash1, hash2);         verify();          resetFull();         hash1 = getCollection().hashCode();         hash2 = getConfirmed().hashCode();         assertEquals("Full lists should have equal hashCodes", hash1, hash2);         verify();     }      /**      *  Tests {@link List#get(int)}.      */     public void testListGetByIndex() {         resetFull();         final List<E> list = getCollection();         final E[] elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             assertEquals("List should contain correct elements", elements[i], list.get(i));             verify();         }     }      /**      *  Tests bounds checking for {@link List#get(int)} on an      *  empty list.      */     public void testListGetByIndexBoundsChecking() {         final List<E> list = makeObject();          try {             list.get(Integer.MIN_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(-1);             fail("List.get should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(0);             fail("List.get should throw IndexOutOfBoundsException [0]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(1);             fail("List.get should throw IndexOutOfBoundsException [1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(Integer.MAX_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests bounds checking for {@link List#get(int)} on a      *  full list.      */     public void testListGetByIndexBoundsChecking2() {         final List<E> list = makeFullCollection();          try {             list.get(Integer.MIN_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(-1);             fail("List.get should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(getFullElements().length);             fail("List.get should throw IndexOutOfBoundsException [size]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.get(Integer.MAX_VALUE);             fail("List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests {@link List#indexOf}.      */     public void testListIndexOf() {         resetFull();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          for (final E element : list2) {             assertEquals("indexOf should return correct result",                     list1.indexOf(element), list2.indexOf(element));             verify();         }          final E[] other = getOtherElements();         for (final E element : other) {             assertEquals("indexOf should return -1 for nonexistent element",                 -1, list1.indexOf(element));             verify();         }     }      /**      *  Tests {@link List#lastIndexOf}.      */     public void testListLastIndexOf() {         resetFull();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          final Iterator<E> iterator = list2.iterator();         while (iterator.hasNext()) {             final E element = iterator.next();             assertEquals("lastIndexOf should return correct result",                 list1.lastIndexOf(element), list2.lastIndexOf(element));             verify();         }          final E[] other = getOtherElements();         for (final E element : other) {             assertEquals("lastIndexOf should return -1 for nonexistent " +                 "element", -1, list1.lastIndexOf(element));             verify();         }     }      /**      *  Tests bounds checking for {@link List#set(int,Object)} on an      *  empty list.      */     public void testListSetByIndexBoundsChecking() {         if (!isSetSupported()) {             return;         }          final List<E> list = makeObject();         final E element = getOtherElements()[0];          try {             list.set(Integer.MIN_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(0, element);             fail("List.set should throw IndexOutOfBoundsException [0]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(1, element);             fail("List.set should throw IndexOutOfBoundsException [1]");         } catch (final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(Integer.MAX_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch (final IndexOutOfBoundsException e) {             // expected         }     }       /**      *  Tests bounds checking for {@link List#set(int,Object)} on a      *  full list.      */     public void testListSetByIndexBoundsChecking2() {         if (!isSetSupported()) {             return;         }          final List<E> list = makeFullCollection();         final E element = getOtherElements()[0];          try {             list.set(Integer.MIN_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException " +                 "[Integer.MIN_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(-1, element);             fail("List.set should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(getFullElements().length, element);             fail("List.set should throw IndexOutOfBoundsException [size]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.set(Integer.MAX_VALUE, element);             fail("List.set should throw IndexOutOfBoundsException " +                 "[Integer.MAX_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }       /**      *  Test {@link List#set(int,Object)}.      */     public void testListSetByIndex() {         if (!isSetSupported()) {             return;         }          resetFull();         final E[] elements = getFullElements();         final E[] other = getOtherElements();          for (int i = 0; i < elements.length; i++) {             final E n = other[i % other.length];             final E v = getCollection().set(i, n);             assertEquals("Set should return correct element", elements[i], v);             getConfirmed().set(i, n);             verify();         }     }      /**      *  If {@link #isSetSupported()} returns false, tests that set operation      *  raises <Code>UnsupportedOperationException.      */     public void testUnsupportedSet() {         if (isSetSupported()) {             return;         }          resetFull();         try {             getCollection().set(0, getFullElements()[0]);             fail("Empty collection should not support set.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();     }      /**      *  Tests bounds checking for {@link List#remove(int)} on an      *  empty list.      */     public void testListRemoveByIndexBoundsChecking() {         if (!isRemoveSupported()) {             return;         }          final List<E> list = makeObject();          try {             list.remove(Integer.MIN_VALUE);             fail("List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(-1);             fail("List.remove should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(0);             fail("List.remove should throw IndexOutOfBoundsException [0]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(1);             fail("List.remove should throw IndexOutOfBoundsException [1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(Integer.MAX_VALUE);             fail("List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }      /**      *  Tests bounds checking for {@link List#remove(int)} on a      *  full list.      */     public void testListRemoveByIndexBoundsChecking2() {         if (!isRemoveSupported()) {             return;         }          final List<E> list = makeFullCollection();          try {             list.remove(Integer.MIN_VALUE);             fail("List.remove should throw IndexOutOfBoundsException " +                 "[Integer.MIN_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(-1);             fail("List.remove should throw IndexOutOfBoundsException [-1]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(getFullElements().length);             fail("List.remove should throw IndexOutOfBoundsException [size]");         } catch(final IndexOutOfBoundsException e) {             // expected         }          try {             list.remove(Integer.MAX_VALUE);             fail("List.remove should throw IndexOutOfBoundsException " +                 "[Integer.MAX_VALUE]");         } catch(final IndexOutOfBoundsException e) {             // expected         }     }       /**      *  Tests {@link List#remove(int)}.      */     public void testListRemoveByIndex() {         if (!isRemoveSupported()) {             return;         }          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             resetFull();             final E o1 = getCollection().remove(i);             final E o2 = getConfirmed().remove(i);             assertEquals("remove should return correct element", o1, o2);             verify();         }     }      /**      *  Tests the read-only bits of {@link List#listIterator()}.      */     public void testListListIterator() {         resetFull();         forwardTest(getCollection().listIterator(), 0);         backwardTest(getCollection().listIterator(), 0);     }      /**      *  Tests the read-only bits of {@link List#listIterator(int)}.      */     public void testListListIteratorByIndex() {         resetFull();         try {             getCollection().listIterator(-1);         } catch (final IndexOutOfBoundsException ex) {}         resetFull();         try {             getCollection().listIterator(getCollection().size() + 1);         } catch (final IndexOutOfBoundsException ex) {}         resetFull();         for (int i = 0; i <= getConfirmed().size(); i++) {             forwardTest(getCollection().listIterator(i), i);             backwardTest(getCollection().listIterator(i), i);         }         resetFull();         for (int i = 0; i <= getConfirmed().size(); i++) {             backwardTest(getCollection().listIterator(i), i);         }     }      //-----------------------------------------------------------------------     /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorPreviousRemoveNext() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         final E two2 = it.previous();         final E one2 = it.previous();         assertEquals(one, one2);         assertEquals(two, two2);         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));          it.remove(); // removed element at index 1 (one)         assertEquals(zero, getCollection().get(0));         assertEquals(two, getCollection().get(1));         final E two3 = it.next();  // do next after remove         assertEquals(two, two3);         assertEquals(getCollection().size() > 2, it.hasNext());         assertEquals(true, it.hasPrevious());     }      /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorPreviousRemovePrevious() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         final E two2 = it.previous();         final E one2 = it.previous();         assertEquals(one, one2);         assertEquals(two, two2);         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));          it.remove(); // removed element at index 1 (one)         assertEquals(zero, getCollection().get(0));         assertEquals(two, getCollection().get(1));         final E zero3 = it.previous();  // do previous after remove         assertEquals(zero, zero3);         assertEquals(false, it.hasPrevious());         assertEquals(getCollection().size() > 2, it.hasNext());     }      /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorNextRemoveNext() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));         final E three = getCollection().get(3);          it.remove(); // removed element at index 2 (two)         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         final E three2 = it.next();  // do next after remove         assertEquals(three, three2);         assertEquals(getCollection().size() > 3, it.hasNext());         assertEquals(true, it.hasPrevious());     }      /**      * Tests remove on list iterator is correct.      */     public void testListListIteratorNextRemovePrevious() {         if (!isRemoveSupported()) {             return;         }         resetFull();         if (getCollection().size() < 4) {             return;         }         final ListIterator<E> it = getCollection().listIterator();         final E zero = it.next();         final E one = it.next();         final E two = it.next();         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         assertEquals(two, getCollection().get(2));          it.remove(); // removed element at index 2 (two)         assertEquals(zero, getCollection().get(0));         assertEquals(one, getCollection().get(1));         final E one2 = it.previous();  // do previous after remove         assertEquals(one, one2);         assertEquals(true, it.hasNext());         assertEquals(true, it.hasPrevious());     }      //-----------------------------------------------------------------------     /**      *  Traverses to the end of the given iterator.      *      *  @param iter  the iterator to traverse      *  @param i     the starting index      */     private void forwardTest(final ListIterator<E> iter, int i) {         final List<E> list = getCollection();         final int max = getFullElements().length;          while (i < max) {             assertTrue("Iterator should have next", iter.hasNext());             assertEquals("Iterator.nextIndex should work",                 i, iter.nextIndex());             assertEquals("Iterator.previousIndex should work",                 i - 1, iter.previousIndex());             final Object o = iter.next();             assertEquals("Iterator returned correct element", list.get(i), o);             i++;         }          assertTrue("Iterator shouldn't have next", !iter.hasNext());         assertEquals("nextIndex should be size", max, iter.nextIndex());         assertEquals("previousIndex should be size - 1", max - 1, iter.previousIndex());          try {             iter.next();             fail("Exhausted iterator should raise NoSuchElement");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      *  Traverses to the beginning of the given iterator.      *      *  @param iter  the iterator to traverse      *  @param i     the starting index      */     private void backwardTest(final ListIterator<E> iter, int i) {         final List<E> list = getCollection();          while (i > 0) {             assertTrue("Iterator should have previous, i:" + i,                 iter.hasPrevious());             assertEquals("Iterator.nextIndex should work, i:" + i,                 i, iter.nextIndex());             assertEquals("Iterator.previousIndex should work, i:" + i,                 i - 1, iter.previousIndex());             final E o = iter.previous();             assertEquals("Iterator returned correct element",                 list.get(i - 1), o);             i--;         }          assertTrue("Iterator shouldn't have previous", !iter.hasPrevious());         final int nextIndex = iter.nextIndex();         assertEquals("nextIndex should be 0", 0, nextIndex);         final int prevIndex = iter.previousIndex();         assertEquals("previousIndex should be -1", -1, prevIndex);          try {             iter.previous();             fail("Exhausted iterator should raise NoSuchElement");         } catch (final NoSuchElementException e) {             // expected         }      }       /**      *  Tests the {@link ListIterator#add(Object)} method of the list      *  iterator.      */     public void testListIteratorAdd() {         if (!isAddSupported()) {             return;         }          resetEmpty();         final List<E> list1 = getCollection();         final List<E> list2 = getConfirmed();          final E[] elements = getFullElements();         ListIterator<E> iter1 = list1.listIterator();         ListIterator<E> iter2 = list2.listIterator();          for (final E element : elements) {             iter1.add(element);             iter2.add(element);             verify();         }          resetFull();         iter1 = getCollection().listIterator();         iter2 = getConfirmed().listIterator();         for (final E element : elements) {             iter1.next();             iter2.next();             iter1.add(element);             iter2.add(element);             verify();         }     }      /**      *  Tests the {@link ListIterator#set(Object)} method of the list      *  iterator.      */     public void testListIteratorSet() {         if (!isSetSupported()) {             return;         }          final E[] elements = getFullElements();          resetFull();         final ListIterator<E> iter1 = getCollection().listIterator();         final ListIterator<E> iter2 = getConfirmed().listIterator();         for (final E element : elements) {             iter1.next();             iter2.next();             iter1.set(element);             iter2.set(element);             verify();         }     }      @SuppressWarnings("unchecked")     public void testEmptyListSerialization() throws IOException, ClassNotFoundException {         final List<E> list = makeObject();         if (!(list instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) list);         final List<E> list2 = (List<E>) readExternalFormFromBytes(object);          assertEquals("Both lists are empty", 0, list.size());         assertEquals("Both lists are empty", 0, list2.size());     }      @SuppressWarnings("unchecked")     public void testFullListSerialization() throws IOException, ClassNotFoundException {         final List<E> list = makeFullCollection();         final int size = getFullElements().length;         if (!(list instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) list);         final List<E> list2 = (List<E>) readExternalFormFromBytes(object);          assertEquals("Both lists are same size", size, list.size());         assertEquals("Both lists are same size", size, list2.size());     }      /**      * Compare the current serialized form of the List      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         List list = makeEmptyList();         if (!(list instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));         */          // test to make sure the canonical form has been preserved         final List<E> list = makeObject();         if (list instanceof Serializable && !skipSerializedCanonicalTests()                 && isTestSerialization()) {             final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));             assertEquals("List is empty", 0, list2.size());             assertEquals(list, list2);         }     }      /**      * Compare the current serialized form of the List      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testFullListCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         List list = makeFullList();         if (!(list instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));         */          // test to make sure the canonical form has been preserved         final List<E> list = makeFullCollection();         if (list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));             if (list2.size() == 4) {                 // old serialized tests                 return;             }             assertEquals("List is the right size", list.size(), list2.size());             assertEquals(list, list2);         }     }      //-----------------------------------------------------------------------     /**      *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.      *  The returned bulk test will run through every {@code TestList}      *  method, <i>including</i> another {@code bulkTestSubList}.      *  Sublists are tested until the size of the sublist is less than 10.      *  Each sublist is 6 elements smaller than its parent list.      *  (By default this means that two rounds of sublists will be tested).      *  The verify() method is overloaded to test that the original list is      *  modified when the sublist is.      */     public BulkTest bulkTestSubList() {         if (getFullElements().length - 6 < 10) {             return null;         }         return new BulkTestSubList<>(this);     }      public static class BulkTestSubList<E> extends AbstractListTest<E> {          private final AbstractListTest<E> outer;          public BulkTestSubList(final AbstractListTest<E> outer) {             super("");             this.outer = outer;         }          @Override         @SuppressWarnings("unchecked")         public E[] getFullElements() {             final List<E> l = Arrays.asList(outer.getFullElements());             return (E[]) l.subList(3, l.size() - 3).toArray();         }          @Override         public E[] getOtherElements() {             return outer.getOtherElements();         }          @Override         public boolean isAddSupported() {             return outer.isAddSupported();         }          @Override         public boolean isSetSupported() {             return outer.isSetSupported();         }          @Override         public boolean isRemoveSupported() {             return outer.isRemoveSupported();         }          @Override         public List<E> makeObject() {             return outer.makeFullCollection().subList(4, 4);         }          @Override         public List<E> makeFullCollection() {             final int size = getFullElements().length;             return outer.makeFullCollection().subList(3, size - 3);         }          @Override         public void resetEmpty() {             outer.resetFull();             this.setCollection(outer.getCollection().subList(4, 4));             this.setConfirmed(outer.getConfirmed().subList(4, 4));         }          @Override         public void resetFull() {             outer.resetFull();             final int size = outer.getConfirmed().size();             this.setCollection(outer.getCollection().subList(3, size - 3));             this.setConfirmed(outer.getConfirmed().subList(3, size - 3));         }          @Override         public void verify() {             super.verify();             outer.verify();         }          @Override         public boolean isTestSerialization() {             return false;         }     }      /**      * Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}      * if elements are added to the original list.      */     public void testListSubListFailFastOnAdd() {         if (!isFailFastSupported()) {             return;         }         if (!isAddSupported()) {             return;         }          resetFull();         final int size = getCollection().size();         List<E> sub = getCollection().subList(1, size);         getCollection().add(getOtherElements()[0]);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().add(0, getOtherElements()[0]);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().addAll(Arrays.asList(getOtherElements()));         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().addAll(0, Arrays.asList(getOtherElements()));         failFastAll(sub);     }      /**      * Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}      * if elements are removed from the original list.      */     public void testListSubListFailFastOnRemove() {         if (!isFailFastSupported()) {             return;         }         if (!isRemoveSupported()) {             return;         }          resetFull();         final int size = getCollection().size();         List<E> sub = getCollection().subList(1, size);         getCollection().remove(0);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().remove(getFullElements()[2]);         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().removeAll(Arrays.asList(getFullElements()));         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().retainAll(Arrays.asList(getOtherElements()));         failFastAll(sub);          resetFull();         sub = getCollection().subList(1, size);         getCollection().clear();         failFastAll(sub);     }      /**      * Invokes all the methods on the given sublist to make sure they raise      * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.      */     protected void failFastAll(final List<E> list) {         final Method[] methods = List.class.getMethods();         for (final Method method : methods) {             failFastMethod(list, method);         }     }      /**      * Invokes the given method on the given sublist to make sure it raises      * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.      *      * Unless the method happens to be the equals() method, in which case      * the test is skipped. There seems to be a bug in      * java.util.AbstractList.subList(int,int).equals(Object) -- it never      * raises a ConcurrentModificationException.      *      * @param list the sublist to test      * @param m the method to invoke      */     protected void failFastMethod(final List<E> list, final Method m) {         if (m.getName().equals("equals")) {             return;         }          final E element = getOtherElements()[0];         final Collection<E> c = Collections.singleton(element);          final Class<?>[] types = m.getParameterTypes();         final Object[] params = new Object[types.length];         for (int i = 0; i < params.length; i++) {             if (types[i] == Integer.TYPE) {                 params[i] = Integer.valueOf(0);             } else if (types[i] == Collection.class) {                 params[i] = c;             } else if (types[i] == Object.class) {                 params[i] = element;             } else if (types[i] == Object[].class) {                 params[i] = new Object[0];             }         }          try {             m.invoke(list, params);             fail(m.getName() + " should raise ConcurrentModification");         } catch (final IllegalAccessException e) {             // impossible         } catch (final InvocationTargetException e) {             final Throwable t = e.getTargetException();             if (t instanceof ConcurrentModificationException) {                 // expected                 return;             }             fail(m.getName() + " raised unexpected " + e);         }     }      // -----------------------------------------------------------------------     public BulkTest bulkTestListIterator() {         return new TestListIterator();     }      public class TestListIterator extends AbstractListIteratorTest<E> {         public TestListIterator() {             super("TestListIterator");         }          @Override         public E addSetValue() {             return AbstractListTest.this.getOtherElements()[0];         }          @Override         public boolean supportsRemove() {             return AbstractListTest.this.isRemoveSupported();         }          @Override         public boolean supportsAdd() {             return AbstractListTest.this.isAddSupported();         }          @Override         public boolean supportsSet() {             return AbstractListTest.this.isSetSupported();         }          @Override         public ListIterator<E> makeEmptyIterator() {             resetEmpty();             return AbstractListTest.this.getCollection().listIterator();         }          @Override         public ListIterator<E> makeObject() {             resetFull();             return AbstractListTest.this.getCollection().listIterator();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  import org.junit.Assert; import org.junit.Test;  /**  * Tests for COLLECTIONS-701.  */ public class Collections701Test {      @Test     public void testArrayList() {         final List<Object> list = new ArrayList<>();         list.add(list);         Assert.assertEquals(1, list.size());         Assert.assertEquals(list, list.get(0));     }      @Test     public void testHashSet() {         final Set<Object> set = new HashSet<>();         set.add(set);         Assert.assertEquals(1, set.size());         Assert.assertEquals(set, set.iterator().next());     }      @Test     public void testSetUniqueList() {         final List<Object> source = new ArrayList<>();         final List<Object> list = SetUniqueList.setUniqueList(source);         list.add(list);         Assert.assertEquals(1, list.size());         Assert.assertEquals(list, list.get(0));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.list;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractListTest} for exercising the  * {@link PredicatedList} implementation.  *  * @since 3.0  */ public class PredicatedListTest<E> extends AbstractListTest<E> {      public PredicatedListTest(final String testName) {         super(testName);     }   //-------------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected List<E> decorateList(final List<E> list, final Predicate<E> predicate) {         return PredicatedList.predicatedList(list, predicate);     }      @Override     public List<E> makeObject() {         return decorateList(new ArrayList<E>(), truePredicate);     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };     }  //--------------------------------------------------------------------      protected Predicate<E> testPredicate =         o -> o instanceof String;      public List<E> makeTestList() {         return decorateList(new ArrayList<E>(), testPredicate);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final List<E> list = makeTestList();         final Integer i = Integer.valueOf(3);         try {             list.add((E) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element", !list.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final List<E> list = makeTestList();         final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) Integer.valueOf(3));         elements.add((E) "four");         try {             list.addAll(0, elements);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("List shouldn't contain illegal element", !list.contains("one"));         assertTrue("List shouldn't contain illegal element", !list.contains("two"));         assertTrue("List shouldn't contain illegal element", !list.contains(Integer.valueOf(3)));         assertTrue("List shouldn't contain illegal element", !list.contains("four"));     }      @SuppressWarnings("unchecked")     public void testIllegalSet() {         final List<E> list = makeTestList();         try {             list.set(0, (E) Integer.valueOf(3));             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testLegalAddAll() {         final List<E> list = makeTestList();         list.add((E) "zero");         final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) "three");         list.addAll(1, elements);         assertTrue("List should contain legal element", list.contains("zero"));         assertTrue("List should contain legal element", list.contains("one"));         assertTrue("List should contain legal element", list.contains("two"));         assertTrue("List should contain legal element", list.contains("three"));     }      public void testSubList() {         final List<E> list = makeTestList();         list.add((E) "zero");         //subList without any element of list         List<E> subList = list.subList(0, 0);         assertNotNull(subList);         assertEquals(0, subList.size());          //subList with one element oif list         subList = list.subList(0, 1);         assertEquals(1, subList.size());          final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) "three");         list.addAll(1, elements);         //subList with all elements of list         subList = list.subList(0, list.size());         assertEquals(list.size(), subList.size());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedList.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedList.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.splitmap;  import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.math.BigInteger; import java.util.HashMap;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.NOPTransformer;  /**  * Tests for {@link TransformedSplitMap}  *  * @since 4.0  */ @SuppressWarnings("boxing") public class TransformedSplitMapTest extends BulkTest {      private final Transformer<Integer, String> intToString = String::valueOf;      private final Transformer<Object, Class<?>> objectToClass = input -> input == null ? null : input.getClass();      private final Transformer<String, Integer> stringToInt = Integer::valueOf;      public TransformedSplitMapTest(final String testName) {         super(testName);     }      // -----------------------------------------------------------------------     public void testTransformedMap() {         final TransformedSplitMap<Integer, String, Object, Class<?>> map = TransformedSplitMap.transformingMap(                 new HashMap<String, Class<?>>(), intToString, objectToClass);          final Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };         final Object[] v = new Object[] { "", new Object(), new HashMap<>(), 0, BigInteger.TEN, null,             new Object[0] };          assertEquals(0, map.size());         for (int i = 0; i < k.length; i++) {             map.put(k[i], v[i]);             assertEquals(i + 1, map.size());             assertTrue(map.containsKey(intToString.transform(k[i])));             assertFalse(map.containsKey(k[i]));             assertTrue(map.containsValue(objectToClass.transform(v[i])));             assertTrue(objectToClass.transform(v[i]) != v[i] ^ map.containsValue(v[i]));             assertEquals(objectToClass.transform(v[i]), map.get(intToString.transform(k[i])));         }          int sz = map.size();         assertEquals(null, map.remove(k[0]));         assertEquals(sz, map.size());         assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));         assertEquals(--sz, map.size());          final TransformedSplitMap<String, String, String, Integer> map2 = TransformedSplitMap.transformingMap(                 new HashMap<String, Integer>(), NOPTransformer.<String>nopTransformer(), stringToInt);         assertEquals(0, map2.size());         for (int i = 0; i < 6; i++) {             map2.put(String.valueOf(i), String.valueOf(i));             assertEquals(i + 1, map2.size());             assertTrue(map2.containsValue(i));             assertFalse(map2.containsValue(String.valueOf(i)));             assertTrue(map2.containsKey(String.valueOf(i)));             assertEquals(i, map2.get(String.valueOf(i)).intValue());         }          int sz2 = map2.size();         assertEquals(Integer.valueOf(0), map2.remove("0"));         assertEquals(--sz2, map2.size());     }      // -----------------------------------------------------------------------      public void testMapIterator() {         final TransformedSplitMap<String, String, String, Integer> map =                 TransformedSplitMap.transformingMap(new HashMap<String, Integer>(),                                                     NOPTransformer.<String>nopTransformer(), stringToInt);         assertEquals(0, map.size());         for (int i = 0; i < 6; i++) {             map.put(String.valueOf(i), String.valueOf(i));         }          for (final MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {             final String k = it.next();             assertEquals(k, it.getKey());             assertEquals(map.get(k), it.getValue());         }     }      public void testEmptyMap() throws IOException, ClassNotFoundException {         final TransformedSplitMap<String, String, String, String> map =                 TransformedSplitMap.transformingMap(new HashMap<String, String>(),                                                     NOPTransformer.<String>nopTransformer(),                                                     NOPTransformer.<String>nopTransformer() );          final ObjectInputStream in =                 new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+"/TransformedSplitMap.emptyCollection.version4.obj" ) );         final Object readObject = in.readObject();         in.close();          final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;         assertTrue( "Map should be empty", readMap.size() == 0 );         assertEquals( map.entrySet(), readMap.entrySet() );     }      public void testFullMap() throws IOException, ClassNotFoundException {         final TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap(                 new HashMap<String, String>(),                 NOPTransformer.<String>nopTransformer(),                 NOPTransformer.<String>nopTransformer() );         map.put( "a", "b" );         map.put( "c", "d" );         map.put( "e", "f" );         map.put( "g", "h" );          final ObjectInputStream in =                 new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+"TransformedSplitMap.fullCollection.version4.obj" ) );         final Object readObject = in.readObject();         in.close();          final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;         assertFalse( "Map should not be empty", readMap.size() == 0 );         assertEquals( map.entrySet(), readMap.entrySet() );     }  //    public void testCreate() throws IOException { //        TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap( //                new HashMap<String, String>(), //                NOPTransformer.<String>nopTransformer(), //                NOPTransformer.<String>nopTransformer() ); // //        ObjectOutputStream out = new ObjectOutputStream( //                new FileOutputStream( "src/test/resources/data/test/TransformedSplitMap.emptyCollection.version4.obj" ) ); //        out.writeObject( map ); // //        map.put( "a", "b" ); //        map.put( "c", "d" ); //        map.put( "e", "f" ); //        map.put( "g", "h" ); // //        out = new ObjectOutputStream( //                new FileOutputStream( "src/test/resources/data/test/TransformedSplitMap.fullCollection.version4.obj" ) ); //        out.writeObject( map ); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.io.FileNotFoundException; import java.io.IOException; import java.io.Serializable; import java.util.Collections; import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.apache.commons.collections4.AbstractObjectTest; import org.junit.Test;  /**  * Abstract test class for testing the Comparator interface.  * <p>  * Concrete subclasses declare the comparator to be tested.  * They also declare certain aspects of the tests.  */ public abstract class AbstractComparatorTest<T> extends AbstractObjectTest {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractComparatorTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------      /**      * Implement this method to return a list of sorted objects.      *      * @return sorted objects      */     public abstract List<T> getComparableObjectsOrdered();      //-----------------------------------------------------------------------     /**      * Implements the abstract superclass method to return the comparator.      *      * @return a full iterator      */     @Override     public abstract Comparator<T> makeObject();      /**      * Overrides superclass to block tests.      */     @Override     public boolean supportsEmptyCollections() {         return false;     }      /**      * Overrides superclass to block tests.      */     @Override     public boolean supportsFullCollections() {         return false;     }      //-----------------------------------------------------------------------     /**      * Reverse the list.      */     protected void reverseObjects(final List<?> list) {         Collections.reverse(list);     }      /**      * Randomize the list.      */     protected void randomizeObjects(final List<?> list) {         Collections.shuffle(list);     }      /**      * Sort the list.      */     protected void sortObjects(final List<T> list, final Comparator<? super T> comparator) {         list.sort(comparator);     }      //-----------------------------------------------------------------------     /**      * Test sorting an empty list      */     @Test     public void testEmptyListSort() {         final List<T> list = new LinkedList<>();         sortObjects(list, makeObject());          final List<T> list2 = new LinkedList<>();          assertEquals("Comparator cannot sort empty lists", list2, list);     }      /**      * Test sorting a reversed list.      */     @Test     public void testReverseListSort() {         final Comparator<T> comparator = makeObject();          final List<T> randomList = getComparableObjectsOrdered();         reverseObjects(randomList);         sortObjects(randomList, comparator);          final List<T> orderedList = getComparableObjectsOrdered();          assertEquals("Comparator did not reorder the List correctly", orderedList, randomList);     }      /**      * Test sorting a random list.      */     @Test     public void testRandomListSort() {         final Comparator<T> comparator = makeObject();          final List<T> randomList = getComparableObjectsOrdered();         randomizeObjects(randomList);         sortObjects(randomList, comparator);          final List<T> orderedList = getComparableObjectsOrdered();          /* debug         Iterator i = randomList.iterator();         while (i.hasNext()) {             System.out.println(i.next());         }         */          assertEquals("Comparator did not reorder the List correctly", orderedList, randomList);     }      /**      * Nearly all Comparators should be Serializable.      */     @Test     public void testComparatorIsSerializable() {         final Comparator<T> comparator = makeObject();         assertTrue("This comparator should be Serializable.",                    comparator instanceof Serializable);     }      public String getCanonicalComparatorName(final Object object) {         final StringBuilder retval = new StringBuilder();         retval.append(TEST_DATA_PATH);         String colName = object.getClass().getName();         colName = colName.substring(colName.lastIndexOf(".") + 1, colName.length());         retval.append(colName);         retval.append(".version");         retval.append(getCompatibilityVersion());         retval.append(".obj");         return retval.toString();     }      /**      * Compare the current serialized form of the Comparator      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     @Test     public void testComparatorCompatibility() throws IOException, ClassNotFoundException {         if (!skipSerializedCanonicalTests()) {             Comparator<T> comparator = null;              // test to make sure the canonical form has been preserved             try {                 comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));             } catch (final FileNotFoundException exception) {                  final boolean autoCreateSerialized = false;                  if (autoCreateSerialized) {                     comparator = makeObject();                     final String fileName = getCanonicalComparatorName(comparator);                     writeExternalFormToDisk((Serializable) comparator, fileName);                     fail("Serialized form could not be found.  A serialized version "                             + "has now been written (and should be added to CVS): " + fileName);                 } else {                     fail("The Serialized form could be located to test serialization "                             + "compatibility: " + exception.getMessage());                 }             }               // make sure the canonical form produces the ordering we currently             // expect             final List<T> randomList = getComparableObjectsOrdered();             reverseObjects(randomList);             sortObjects(randomList, comparator);              final List<T> orderedList = getComparableObjectsOrdered();              assertEquals("Comparator did not reorder the List correctly", orderedList, randomList);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Arrays; import java.util.Comparator; import java.util.LinkedList; import java.util.List; import java.util.Random;  import org.junit.Test;  /**  * Test class for FixedOrderComparator.  *  */ public class FixedOrderComparatorTest extends AbstractComparatorTest<String> {      /**      * Top cities of the world, by population including metro areas.      */     private static final String topCities[] = new String[] {         "Tokyo",         "Mexico City",         "Mumbai",         "Sao Paulo",         "New York",         "Shanghai",         "Lagos",         "Los Angeles",         "Calcutta",         "Buenos Aires"     };      //     // Initialization and busywork     //      public FixedOrderComparatorTest(final String name) {         super(name);     }      //     // Set up and tear down     //      @Override     public Comparator<String> makeObject() {         return new FixedOrderComparator<>(topCities);     }      @Override     public List<String> getComparableObjectsOrdered() {         return Arrays.asList(topCities);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/FixedOrderComparator.version4.obj"); //    }      //     // The tests     //      /**      * Tests that the constructor plus add method compares items properly.      */     @Test     public void testConstructorPlusAdd() {         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>();         for (final String topCity : topCities) {             comparator.add(topCity);         }         final String[] keys = topCities.clone();         assertComparatorYieldsOrder(keys, comparator);     }      /**      * Tests that the array constructor compares items properly.      */     @Test     public void testArrayConstructor() {         final String[] keys = topCities.clone();         final String[] topCitiesForTest = topCities.clone();         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCitiesForTest);         assertComparatorYieldsOrder(keys, comparator);         // test that changing input after constructor has no effect         topCitiesForTest[0] = "Brighton";         assertComparatorYieldsOrder(keys, comparator);     }      /**      * Tests the list constructor.      */     @Test     public void testListConstructor() {         final String[] keys = topCities.clone();         final List<String> topCitiesForTest = new LinkedList<>(Arrays.asList(topCities));         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCitiesForTest);         assertComparatorYieldsOrder(keys, comparator);         // test that changing input after constructor has no effect         topCitiesForTest.set(0, "Brighton");         assertComparatorYieldsOrder(keys, comparator);     }      /**      * Tests addAsEqual method.      */     @Test     public void testAddAsEqual() {         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);         comparator.addAsEqual("New York", "Minneapolis");         assertEquals(0, comparator.compare("New York", "Minneapolis"));         assertEquals(-1, comparator.compare("Tokyo", "Minneapolis"));         assertEquals(1, comparator.compare("Shanghai", "Minneapolis"));     }      /**      * Tests whether or not updates are disabled after a comparison is made.      */     @Test     public void testLock() {         final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);         assertFalse(comparator.isLocked());         comparator.compare("New York", "Tokyo");         assertTrue(comparator.isLocked());         try {             comparator.add("Minneapolis");             fail("Should have thrown an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // success -- ignore         }          try {             comparator.addAsEqual("New York", "Minneapolis");             fail("Should have thrown an UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // success -- ignore         }     }      @Test     public void testUnknownObjectBehavior() {         FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);         try {             comparator.compare("New York", "Minneapolis");             fail("Should have thrown a IllegalArgumentException");         } catch (final IllegalArgumentException e) {             // success-- ignore         }         try {             comparator.compare("Minneapolis", "New York");             fail("Should have thrown a IllegalArgumentException");         } catch (final IllegalArgumentException e) {             // success-- ignore         }         assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());          comparator = new FixedOrderComparator<>(topCities);         comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);         assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());         LinkedList<String> keys = new LinkedList<>(Arrays.asList(topCities));         keys.addFirst("Minneapolis");         assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);          assertEquals(-1, comparator.compare("Minneapolis", "New York"));         assertEquals( 1, comparator.compare("New York", "Minneapolis"));         assertEquals( 0, comparator.compare("Minneapolis", "St Paul"));          comparator = new FixedOrderComparator<>(topCities);         comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);         keys = new LinkedList<>(Arrays.asList(topCities));         keys.add("Minneapolis");         assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);          assertEquals( 1, comparator.compare("Minneapolis", "New York"));         assertEquals(-1, comparator.compare("New York", "Minneapolis"));         assertEquals( 0, comparator.compare("Minneapolis", "St Paul"));      }      //     // Helper methods     //      /** Shuffles the keys and asserts that the comparator sorts them back to      * their original order.      */     private void assertComparatorYieldsOrder(final String[] orderedObjects,                                              final Comparator<String> comparator) {         final String[] keys = orderedObjects.clone();          // shuffle until the order changes.  It's extremely rare that         // this requires more than one shuffle.          boolean isInNewOrder = false;         final Random rand = new Random();         while (keys.length > 1 && !isInNewOrder) {             // shuffle:             for (int i = keys.length-1; i > 0; i--) {                 final String swap = keys[i];                 final int j = rand.nextInt(i+1);                 keys[i] = keys[j];                 keys[j] = swap;             }              // testShuffle             for (int i = 0; i < keys.length; i++) {                 if (!orderedObjects[i].equals(keys[i])) {                     isInNewOrder = true;                     break;                 }             }         }          // The real test:  sort and make sure they come out right.          Arrays.sort(keys, comparator);          for (int i = 0; i < orderedObjects.length; i++) {             assertEquals(orderedObjects[i], keys[i]);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.apache.commons.collections4.ComparatorUtils; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils;  /**  * Test class for TransformingComparator.  *  */ public class TransformingComparatorTest extends AbstractComparatorTest<Integer> {      //     // Initialization and busywork     //      public TransformingComparatorTest(final String name) {         super(name);     }      //     // Set up and tear down     //      @Override     public Comparator<Integer> makeObject() {         final Comparator<String> decorated = new ComparableComparator<>();         return ComparatorUtils.transformedComparator(decorated, TransformerUtils.<Integer>stringValueTransformer());     }      @Override     @SuppressWarnings("boxing") // OK in test code     public List<Integer> getComparableObjectsOrdered() {         final List<Integer> list = new LinkedList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         list.add(5);         return list;     }      public void testEquals() {         final Transformer<String, String> t1 = TransformerUtils.nopTransformer();         final TransformingComparator<String, String> comp1 = new TransformingComparator<>(t1);         final TransformingComparator<String, String> comp2 = new TransformingComparator<>(t1, comp1);          // Checks the contract: equals-hashcode on comp1 and comp2         assertTrue("Contract failed: equals-hashcode",                 comp1.equals(comp2) ? comp1.hashCode() == comp2.hashCode() : true);          // Checks the contract: equals-hashcode on comp1 and comp2         assertTrue("Contract failed: equals-hashcode",                 comp2.equals(comp1) ? comp2.hashCode() == comp1.hashCode() : true);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/TransformingComparator.version4.obj"); //    }      //     // The tests     //  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.io.Serializable; import java.util.Arrays; import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.junit.Test;  /**  * Tests for ComparatorChain.  *  */ public class ComparatorChainTest extends AbstractComparatorTest<ComparatorChainTest.PseudoRow> {      public ComparatorChainTest(final String testName) {         super(testName);     }      @Override     public Comparator<PseudoRow> makeObject() {         final ComparatorChain<PseudoRow> chain = new ComparatorChain<>(new ColumnComparator(0));         chain.addComparator(new ColumnComparator(1), true); // reverse the second column         chain.addComparator(new ColumnComparator(2), false);         return chain;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/ComparatorChain.version4.obj"); //    }      @Test     public void testNoopComparatorChain() {         final ComparatorChain<Integer> chain = new ComparatorChain<>();         final Integer i1 = 4;         final Integer i2 = 6;         chain.addComparator(new ComparableComparator<>());          final int correctValue = i1.compareTo(i2);         assertEquals("Comparison returns the right order", chain.compare(i1, i2), correctValue);     }      @Test     public void testBadNoopComparatorChain() {         final ComparatorChain<Integer> chain = new ComparatorChain<>();         final Integer i1 = 4;         final Integer i2 = 6;         try {             chain.compare(i1, i2);             fail("An exception should be thrown when a chain contains zero comparators.");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testListComparatorChain() {         final List<Comparator<Integer>> list = new LinkedList<>();         list.add(new ComparableComparator<>());         final ComparatorChain<Integer> chain = new ComparatorChain<>(list);         final Integer i1 = 4;         final Integer i2 = 6;          final int correctValue = i1.compareTo(i2);         assertEquals("Comparison returns the right order", chain.compare(i1, i2), correctValue);     }      @Test     public void testBadListComparatorChain() {         final List<Comparator<Integer>> list = new LinkedList<>();         final ComparatorChain<Integer> chain = new ComparatorChain<>(list);         final Integer i1 = 4;         final Integer i2 = 6;         try {             chain.compare(i1, i2);             fail("An exception should be thrown when a chain contains zero comparators.");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testComparatorChainOnMinvaluedCompatator() {         // -1 * Integer.MIN_VALUE is less than 0,         // test that ComparatorChain handles this edge case correctly         final ComparatorChain<Integer> chain = new ComparatorChain<>();         chain.addComparator((a, b) -> {             final int result = a.compareTo(b);             if (result < 0) {                 return Integer.MIN_VALUE;             }             if (result > 0) {                 return Integer.MAX_VALUE;             }             return 0;         }, true);          assertTrue(chain.compare(4, 5) > 0);         assertTrue(chain.compare(5, 4) < 0);         assertEquals(0, chain.compare(4, 4));     }      @Override     public List<PseudoRow> getComparableObjectsOrdered() {         // this is the correct order assuming a         // "0th forward, 1st reverse, 2nd forward" sort         return new LinkedList<>(Arrays.asList(new PseudoRow(1, 2, 3), new PseudoRow(2, 3, 5),                 new PseudoRow(2, 2, 4), new PseudoRow(2, 2, 8), new PseudoRow(3, 1, 0),                 new PseudoRow(4, 4, 4), new PseudoRow(4, 4, 7)));     }      public static class PseudoRow implements Serializable {          /**          * Generated serial version ID.          */         private static final long serialVersionUID = 8085570439751032499L;         public int[] cols = new int[3];          public PseudoRow(final int col1, final int col2, final int col3) {             cols[0] = col1;             cols[1] = col2;             cols[2] = col3;         }          public int getColumn(final int colIndex) {             return cols[colIndex];         }          @Override         public String toString() {             return "[" + cols[0] + "," + cols[1] + "," + cols[2] + "]";         }          @Override         public boolean equals(final Object o) {             if (!(o instanceof PseudoRow)) {                 return false;             }              final PseudoRow row = (PseudoRow) o;              return getColumn(0) == row.getColumn(0) && getColumn(1) == row.getColumn(1) && getColumn(2) == row.getColumn(2);         }     }      public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {         private static final long serialVersionUID = -2284880866328872105L;          protected int colIndex = 0;          public ColumnComparator(final int colIndex) {             this.colIndex = colIndex;         }          @Override         public int compare(final PseudoRow o1, final PseudoRow o2) {             return Integer.compare(o1.getColumn(colIndex), o2.getColumn(colIndex));         }          @Override         public int hashCode() {             return colIndex;         }          @Override         public boolean equals(final Object that) {             return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import junit.framework.Test; import junit.framework.TestSuite;  /**  * Test the NullComparator.  *  */ public abstract class AbstractNullComparatorTest extends AbstractComparatorTest<Integer> {      public AbstractNullComparatorTest(final String testName) {         super(testName);     }      public static Test suite() {         final TestSuite suite = new TestSuite(AbstractNullComparatorTest.class.getName());         suite.addTest(new TestSuite(TestNullComparator1.class));         suite.addTest(new TestSuite(TestNullComparator2.class));         return suite;     }      /**      *  Test the NullComparator with nulls high, using comparable comparator      **/     public static class TestNullComparator1 extends AbstractNullComparatorTest {          public TestNullComparator1(final String testName) {             super(testName);         }          @Override         public Comparator<Integer> makeObject() {             return new NullComparator<>();         }          @Override         public List<Integer> getComparableObjectsOrdered() {             final List<Integer> list = new LinkedList<>();             list.add(Integer.valueOf(1));             list.add(Integer.valueOf(2));             list.add(Integer.valueOf(3));             list.add(Integer.valueOf(4));             list.add(Integer.valueOf(5));             list.add(null);             return list;         }          @Override         public String getCanonicalComparatorName(final Object object) {             return super.getCanonicalComparatorName(object) + "1";         }          @Override         public String getCompatibilityVersion() {             return "4";         }  //        public void testCreate() throws Exception { //            writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/NullComparator.version4.obj1"); //        }      }      /**      *  Test the NullComparator with nulls low using the comparable comparator      **/     public static class TestNullComparator2 extends AbstractNullComparatorTest {          public TestNullComparator2(final String testName) {             super(testName);         }          @Override         public Comparator<Integer> makeObject() {             return new NullComparator<>(false);         }          @Override         public List<Integer> getComparableObjectsOrdered() {             final List<Integer> list = new LinkedList<>();             list.add(null);             list.add(Integer.valueOf(1));             list.add(Integer.valueOf(2));             list.add(Integer.valueOf(3));             list.add(Integer.valueOf(4));             list.add(Integer.valueOf(5));             return list;         }          @Override         public String getCanonicalComparatorName(final Object object) {             return super.getCanonicalComparatorName(object) + "2";         }          @Override         public String getCompatibilityVersion() {             return "4";         }  //        public void testCreate() throws Exception { //            writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/NullComparator.version4.obj2"); //        }      } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Collections; import java.util.Comparator; import java.util.LinkedList; import java.util.List;  import org.junit.Test;  /**  * Tests for ReverseComparator.  *  */ public class ReverseComparatorTest extends AbstractComparatorTest<Integer> {      public ReverseComparatorTest(final String testName) {         super(testName);     }      /**      * For the purposes of this test, return a      * ReverseComparator that wraps the java.util.Collections.reverseOrder()      * Comparator.  The resulting comparator should      * sort according to natural Order.  (Note: we wrap      * a Comparator taken from the JDK so that we can      * save a "canonical" form in SCM.      *      * @return Comparator that returns "natural" order      */     @Override     public Comparator<Integer> makeObject() {         return new ReverseComparator<>(Collections.<Integer>reverseOrder());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/ReverseComparator.version4.obj"); //    }      @Override     public List<Integer> getComparableObjectsOrdered() {         final List<Integer> list = new LinkedList<>();         list.add(Integer.valueOf(1));         list.add(Integer.valueOf(2));         list.add(Integer.valueOf(3));         list.add(Integer.valueOf(4));         list.add(Integer.valueOf(5));         return list;     }      /**      * Override this inherited test since Collections.reverseOrder      * doesn't adhere to the "soft" Comparator contract, and we've      * already "canonized" the comparator returned by makeComparator.      */     @Override     @Test     public void testSerializeDeserializeThenCompare() throws Exception {         final Comparator<?> comp = new ReverseComparator<>(new ComparableComparator<String>());          final ByteArrayOutputStream buffer = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(buffer);         out.writeObject(comp);         out.close();          final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));         final Object dest = in.readObject();         in.close();         assertEquals("obj != deserialize(serialize(obj))", comp, dest);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List;  import org.junit.Test;  import static org.junit.Assert.assertNotEquals;  /**  * Tests for {@link BooleanComparator}.  *  */ @SuppressWarnings("boxing") public class BooleanComparatorTest extends AbstractComparatorTest<Boolean> {      // conventional     // ------------------------------------------------------------------------      public BooleanComparatorTest(final String testName) {         super(testName);     }      // collections testing framework     // ------------------------------------------------------------------------      @Override     public Comparator<Boolean> makeObject() {         return new BooleanComparator();     }      @Override     public List<Boolean> getComparableObjectsOrdered() {         return new ArrayList<>(Arrays.asList(Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.TRUE, Boolean.TRUE,                 true));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/BooleanComparator.version4.obj"); //    }      // tests     // ------------------------------------------------------------------------      @Test     public void testConstructors() {         allTests(false, new BooleanComparator());         allTests(false, new BooleanComparator(false));         allTests(true, new BooleanComparator(true));     }      @Test      public void testStaticFactoryMethods() {         allTests(false, BooleanComparator.getFalseFirstComparator());         allTests(false, BooleanComparator.booleanComparator(false));         allTests(true, BooleanComparator.getTrueFirstComparator());         allTests(true, BooleanComparator.booleanComparator(true));     }      @Test     public void testEqualsCompatibleInstance() {         assertEquals(new BooleanComparator(), new BooleanComparator(false));         assertEquals(new BooleanComparator(false), new BooleanComparator(false));         assertEquals(new BooleanComparator(false), BooleanComparator.getFalseFirstComparator());         assertSame(BooleanComparator.getFalseFirstComparator(), BooleanComparator.booleanComparator(false));          assertEquals(new BooleanComparator(true), new BooleanComparator(true));         assertEquals(new BooleanComparator(true), BooleanComparator.getTrueFirstComparator());         assertSame(BooleanComparator.getTrueFirstComparator(), BooleanComparator.booleanComparator(true));          assertNotEquals(new BooleanComparator(), new BooleanComparator(true));         assertNotEquals(new BooleanComparator(true), new BooleanComparator(false));     }      // utilities     // ------------------------------------------------------------------------      protected void allTests(final boolean trueFirst, final BooleanComparator comp) {         orderIndependentTests(comp);         if (trueFirst) {             trueFirstTests(comp);         } else {             falseFirstTests(comp);         }     }      protected void trueFirstTests(final BooleanComparator comp) {         assertNotNull(comp);         assertEquals(0, comp.compare(true, true));         assertEquals(0, comp.compare(false, false));         assertTrue(comp.compare(false, true) > 0);         assertTrue(comp.compare(true, false) < 0);     }      protected void falseFirstTests(final BooleanComparator comp) {         assertNotNull(comp);         assertEquals(0, comp.compare(true, true));         assertEquals(0, comp.compare(false, false));         assertTrue(comp.compare(false, true) < 0);         assertTrue(comp.compare(true, false) > 0);     }      protected void orderIndependentTests(final BooleanComparator comp) {         nullArgumentTests(comp);     }      protected void nullArgumentTests(final BooleanComparator comp) {         assertNotNull(comp);         try {             comp.compare(null, null);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(Boolean.TRUE, null);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(Boolean.FALSE, null);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(null, Boolean.TRUE);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }         try {             comp.compare(null, Boolean.FALSE);             fail("Expected NullPointerException");         } catch (final NullPointerException e) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.comparators;  import java.util.Comparator; import java.util.LinkedList; import java.util.List;  /**  * Tests for ComparableComparator.  *  *  */ @SuppressWarnings("boxing") public class ComparableComparatorTest extends AbstractComparatorTest<Integer> {      public ComparableComparatorTest(final String testName) {         super(testName);     }      @Override     public Comparator<Integer> makeObject() {         return new ComparableComparator<>();     }      @Override     public List<Integer> getComparableObjectsOrdered() {         final List<Integer> list = new LinkedList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         list.add(5);         return list;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), "src/test/resources/data/test/ComparableComparator.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape;  import java.util.Arrays; import java.util.PrimitiveIterator.OfInt;  /**  * A Hasher implementation to return fixed indexes. Duplicates are allowed.  * The shape is ignored when generating the indexes.  *  * <p><strong>This is not a real hasher and is used for testing only</strong>.  */ class FixedIndexesTestHasher implements Hasher {     /** The shape. */     private final Shape shape;     /** The indexes. */     private final int[] indexes;      /**      * Create an instance.      *      * @param shape the shape      * @param indexes the indexes      */     FixedIndexesTestHasher(final Shape shape, final int... indexes) {         this.shape = shape;         this.indexes = indexes;     }      @Override     public OfInt iterator(final Shape shape) {         if (!this.shape.equals(shape)) {             throw new IllegalArgumentException(                 String.format("shape (%s) does not match internal shape (%s)", shape, this.shape));         }         return Arrays.stream(indexes).iterator();     }      @Override     public HashFunctionIdentity getHashFunctionIdentity() {         return shape.getHashFunctionIdentity();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape;  /**  * Tests for the {@link BitSetBloomFilter}.  */ public class BitSetBloomFilterTest extends AbstractBloomFilterTest {     @Override     protected BitSetBloomFilter createEmptyFilter(final Shape shape) {         return new BitSetBloomFilter(shape);     }      @Override     protected BitSetBloomFilter createFilter(final Hasher hasher, final Shape shape) {         final BitSetBloomFilter testFilter = new BitSetBloomFilter(shape);         testFilter.merge( hasher );         return testFilter;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import java.util.Arrays; import java.util.HashMap; import java.util.Map; import java.util.concurrent.ThreadLocalRandom; import java.util.function.BiPredicate; import java.util.function.Function; import java.util.function.ToIntBiFunction;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.junit.Test;  /**  * Tests for the {@link ArrayCountingBloomFilter}.  */ public class ArrayCountingBloomFilterTest extends AbstractBloomFilterTest {      /**      * Function to convert int arrays to BloomFilters for testing.      */     private final Function<int[], BloomFilter> converter = counts -> {         final BloomFilter testingFilter = new BitSetBloomFilter(shape);         testingFilter.merge(new FixedIndexesTestHasher(shape, counts));         return testingFilter;     };      @Override     protected ArrayCountingBloomFilter createEmptyFilter(final Shape shape) {         return new ArrayCountingBloomFilter(shape);     }      @Override     protected ArrayCountingBloomFilter createFilter(final Hasher hasher, final Shape shape) {         final ArrayCountingBloomFilter result = new ArrayCountingBloomFilter(shape);         result.merge( hasher );         return result;     }      private ArrayCountingBloomFilter createFromCounts(final int[] counts) {         // Use a dummy filter to add the counts to an empty filter         final CountingBloomFilter dummy = new ArrayCountingBloomFilter(shape) {             @Override             public void forEachCount(final BitCountConsumer action) {                 for (int i = 0; i < counts.length; i++) {                     action.accept(i, counts[i]);                 }             }         };         final ArrayCountingBloomFilter bf = new ArrayCountingBloomFilter(shape);         bf.add(dummy);         return bf;     }      /**      * Assert the counts match the expected values. Values are for indices starting      * at 0. Assert the cardinality equals the number of non-zero counts.      *      * @param bf the bloom filter      * @param expected the expected counts      */     private static void assertCounts(final CountingBloomFilter bf, final int[] expected) {         final Map<Integer, Integer> m = new HashMap<>();         bf.forEachCount(m::put);         int zeros = 0;         for (int i = 0; i < expected.length; i++) {             if (m.get(i) == null) {                 assertEquals("Wrong value for " + i, expected[i], 0);                 zeros++;             } else {                 assertEquals("Wrong value for " + i, expected[i], m.get(i).intValue());             }         }         assertEquals(expected.length - zeros, bf.cardinality());     }      /**      * Tests that counts are correct when a hasher with duplicates is used in the      * constructor.      */     @Test     public void constructorTest_Hasher_Duplicates() {         final int[] expected = {0, 1, 1, 0, 0, 1};         // Some indexes with duplicates         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 2, 5);          final ArrayCountingBloomFilter bf = createFilter(hasher, shape);         final long[] lb = bf.getBits();         assertEquals(1, lb.length);         assertEquals(0b100110L, lb[0]);          assertCounts(bf, expected);     }      /**      * Test the contains function with a standard Bloom filter.      * The contains function is tested using a counting Bloom filter in the parent test class.      */     @Test     public void contains_BloomFilter() {         // Some indexes with duplicates         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 5);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);         BitSetBloomFilter testingFilter = new BitSetBloomFilter(shape);         testingFilter.merge( new FixedIndexesTestHasher(shape, 3, 4));         assertFalse(bf.contains(testingFilter));         testingFilter = new BitSetBloomFilter(shape);         testingFilter.merge( new FixedIndexesTestHasher(shape, 2, 5));         assertTrue(bf.contains(testingFilter));     }      /**      * Tests that merge correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void mergeTest_Counts_CountingBloomFilter() {         assertMerge(counts -> createFilter(new FixedIndexesTestHasher(shape, counts), shape),                 BloomFilter::merge);     }      /**      * Tests that merge correctly updates the counts when a BloomFilter is passed.      */     @Test     public void mergeTest_Counts_BloomFilter() {         assertMerge(converter, BloomFilter::merge);     }      /**      * Test that merge correctly updates the counts when a Hasher is passed.      */     @Test     public void mergeTest_Counts_Hasher() {         assertMerge(counts -> new FixedIndexesTestHasher(shape, counts),                 BloomFilter::merge);     }      /**      * Test that merge correctly updates the counts when a Hasher is passed with duplicates.      */     @Test     public void mergeTest_Counts_Hasher_Duplicates() {         assertMerge(counts -> new FixedIndexesTestHasher(shape, createDuplicates(counts)),                 BloomFilter::merge);     }      /**      * Tests that remove correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void removeTest_Counts_CountingBloomFilter() {         assertRemove(counts -> createFilter(new FixedIndexesTestHasher(shape, counts), shape),                 CountingBloomFilter::remove);     }      /**      * Tests that remove correctly updates the counts when a BloomFilter is passed.      */     @Test     public void removeTest_Counts_BloomFilter() {         assertRemove(converter, CountingBloomFilter::remove);     }      /**      * Test that remove correctly updates the counts when a Hasher is passed.      */     @Test     public void removeTest_Counts_Hasher() {         assertRemove(counts -> new FixedIndexesTestHasher(shape, counts),                 CountingBloomFilter::remove);     }      /**      * Test that remove correctly updates the counts when a Hasher is passed with duplicates.      */     @Test     public void removeTest_Counts_Hasher_Duplicates() {         assertRemove(counts -> new FixedIndexesTestHasher(shape, createDuplicates(counts)),                 CountingBloomFilter::remove);     }      /**      * Creates duplicates in the counts.      *      * @param counts the counts      * @return the new counts      */     private static int[] createDuplicates(final int[] counts) {         // Duplicate some values randomly         final int length = counts.length;         final int[] countsWithDuplicates = Arrays.copyOf(counts, 2 * length);         for (int i = length; i < countsWithDuplicates.length; i++) {             // Copy a random value from the counts into the end position             countsWithDuplicates[i] = countsWithDuplicates[ThreadLocalRandom.current().nextInt(i)];         }         return countsWithDuplicates;     }      /**      * Assert a merge operation. The converter should construct a suitable object      * to remove the indices from the provided Bloom filter with the remove operation.      *      * @param <F> the type of the filter      * @param converter the converter      * @param merge the merge operation      */     private <F> void assertMerge(final Function<int[], F> converter,             final BiPredicate<ArrayCountingBloomFilter, F> merge) {         final int[] indexes1 = {   1, 2,    4, 5, 6};         final int[] indexes2 = {         3, 4,    6};         final int[] expected = {0, 1, 1, 1, 2, 1, 2};         assertOperation(indexes1, indexes2, converter, merge, true, expected);     }      /**      * Assert a remove operation. The converter should construct a suitable object      * to remove the indices from the provided Bloom filter with the remove operation.      *      * @param <F> the type of the filter      * @param converter the converter      * @param remove the remove operation      */     private <F> void assertRemove(final Function<int[], F> converter,             final BiPredicate<ArrayCountingBloomFilter, F> remove) {         final int[] indexes1 = {   1, 2,    4, 5, 6};         final int[] indexes2 = {      2,       5, 6};         final int[] expected = {0, 1, 0, 0, 1, 0, 0};         assertOperation(indexes1, indexes2, converter, remove, true, expected);     }      /**      * Assert a counting operation. The first set of indexes is used to create the      * CountingBloomFilter. The second set of indices is passed to the converter to      * construct a suitable object to combine with the counting Bloom filter. The counts      * of the first Bloom filter are checked using the expected counts.      *      * <p>Counts are assumed to map to indexes starting from 0.      *      * @param <F> the type of the filter      * @param indexes1 the first set of indexes      * @param indexes2 the second set of indexes      * @param converter the converter      * @param operation the operation      * @param isValid the expected value for the operation result      * @param expected the expected counts after the operation      */     private <F> void assertOperation(final int[] indexes1, final int[] indexes2,             final Function<int[], F> converter,             final BiPredicate<ArrayCountingBloomFilter, F> operation,             final boolean isValid, final int[] expected) {         final Hasher hasher = new FixedIndexesTestHasher(shape, indexes1);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);         final F filter = converter.apply(indexes2);         final boolean result = operation.test(bf, filter);         assertEquals(isValid, result);         assertEquals(isValid, bf.isValid());         assertCounts(bf, expected);     }      /**      * Tests that merge errors when the counts overflow the maximum integer value.      */     @Test     public void mergeTest_Overflow() {         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 3);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);          final ArrayCountingBloomFilter bf2 = createFromCounts(new int[] {0, 0, Integer.MAX_VALUE});          // Small + 1 = OK         // should not fail as the counts are ignored         assertTrue(bf.merge(bf2));         assertTrue(bf.isValid());         assertCounts(bf, new int[] {0, 1, 2, 1});          // Big + 1 = Overflow         assertTrue(bf2.isValid());         assertFalse(bf2.merge(bf));         assertFalse("Merge should overflow and the filter is invalid", bf2.isValid());          // The counts are not clipped to max. They have simply overflowed.         // Note that this is a merge and the count is only incremented by 1         // and not the actual count at each index. So it is not 2 + Integer.MAX_VALUE.         assertCounts(bf2, new int[] {0, 1, 1 + Integer.MAX_VALUE, 1});     }      /**      * Tests that removal errors when the counts become negative.      */     @Test     public void removeTest_Negative() {         final Hasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 3);         final ArrayCountingBloomFilter bf = createFilter(hasher, shape);          final Hasher hasher2 = new FixedIndexesTestHasher(shape, 2);         final ArrayCountingBloomFilter bf2 = createFilter(hasher2, shape);          // More - Less = OK         bf.remove(bf2);         assertTrue(bf.isValid());         assertCounts(bf, new int[] {0, 1, 0, 1});          // Less - More = Negative         assertTrue(bf2.isValid());         bf2.remove(bf);         assertFalse("Remove should create negative counts and the filter is invalid", bf2.isValid());          // The counts are not clipped to zero. They have been left as negative.         assertCounts(bf2, new int[] {0, -1, 1, -1});     }      /**      * Tests that counts can be added to a new instance.      *      * <p>Note: This test ensures the CountingBloomFilter      * can be created with whatever counts are required for other tests.      */     @Test     public void addTest_NewInstance() {         for (final int[] counts : new int[][] {             { /* empty */},             {0, 0, 1},             {0, 1, 2},             {2, 3, 4},             {66, 77, 0, 99},             {Integer.MAX_VALUE, 42},         }) {             assertCounts(createFromCounts(counts), counts);         }     }      /**      * Test that add correctly ignores an empty CountingBloomFilter.      */     @Test     public void addTest_Empty() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[0],                 CountingBloomFilter::add,                 true,                 new int[] {5, 2, 1});     }      /**      * Test that add correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void addTest_Counts() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[] {0, 6, 4, 1},                 CountingBloomFilter::add,                 true,                 new int[] {5, 8, 5, 1});     }      /**      * Test that add correctly updates the isValid state when a CountingBloomFilter is      * passed and an integer overflow occurs.      */     @Test     public void addTest_Overflow() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[] {0, 6, Integer.MAX_VALUE},                 CountingBloomFilter::add,                 false,                 new int[] {5, 8, 1 + Integer.MAX_VALUE});     }      /**      * Test that subtract correctly ignores an empty CountingBloomFilter.      */     @Test     public void subtractTest_Empty() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[0],                 CountingBloomFilter::subtract,                 true,                 new int[] {5, 2, 1});     }      /**      * Test that subtract correctly updates the counts when a CountingBloomFilter is      * passed.      */     @Test     public void subtractTest_Counts() {         assertCountingOperation(new int[] {5, 9, 1, 1},                 new int[] {0, 2, 1},                 CountingBloomFilter::subtract,                 true,                 new int[] {5, 7, 0, 1});     }      /**      * Test that subtract correctly updates the isValid state when a CountingBloomFilter is      * passed and the counts become negative.      */     @Test     public void subtractTest_Negative() {         assertCountingOperation(new int[] {5, 2, 1},                 new int[] {0, 6, 1},                 CountingBloomFilter::subtract,                 false,                 new int[] {5, -4, 0});     }      /**      * Assert a counting operation. Two CountingBloomFilters are created from the      * two sets of counts. The operation is applied and the counts of the first      * Bloom filter is checked using the expected counts.      *      * <p>Counts are assumed to map to indexes starting from 0.      *      * @param counts1 the first set counts      * @param counts2 the first set counts      * @param operation the operation      * @param isValid the expected value for the operation result      * @param expected the expected counts after the operation      */     private void assertCountingOperation(final int[] counts1, final int[] counts2,             final BiPredicate<ArrayCountingBloomFilter, ArrayCountingBloomFilter> operation,             final boolean isValid, final int[] expected) {         final ArrayCountingBloomFilter bf1 = createFromCounts(counts1);         final ArrayCountingBloomFilter bf2 = createFromCounts(counts2);         final boolean result = operation.test(bf1, bf2);         assertEquals(isValid, result);         assertEquals(isValid, bf1.isValid());         assertCounts(bf1, expected);     }      /**      * Tests that the andCardinality calculation executes correctly when using a      * CountingBloomFilter argument.      */     @Test     public void andCardinalityTest_CountingBloomFilter() {         assertCardinalityOperation(new int[] {1, 1},                 new int[] {1, 1},                 BloomFilter::andCardinality,                 2);         assertCardinalityOperation(new int[] {0, 1, 0, 1, 1, 1, 0, 1, 0},                 new int[] {1, 1, 0, 0, 0, 1},                 BloomFilter::andCardinality,                 2);         assertCardinalityOperation(new int[] {1, 1},                 new int[] {0, 0, 1, 1, 1},                 BloomFilter::andCardinality,                 0);     }      /**      * Tests that the orCardinality calculation executes correctly when using a      * CountingBloomFilter argument.      */     @Test     public void orCardinalityTest_CountingBloomFilter() {         assertCardinalityOperation(new int[] {1, 1},                 new int[] {1, 1},                 BloomFilter::orCardinality,                 2);         assertCardinalityOperation(new int[] {0, 1, 0, 1, 1, 1, 0, 1, 0},                 new int[] {1, 1, 0, 0, 0, 1},                 BloomFilter::orCardinality,                 6);         assertCardinalityOperation(new int[] {1, 1},                 new int[] {0, 0, 1, 1, 1},                 BloomFilter::orCardinality,                 5);     }      /**      * Tests that the xorCardinality calculation executes correctly when using a      * CountingBloomFilter argument.      */     @Test     public void xorCardinalityTest_CountingBloomFilter() {         assertCardinalityOperation(new int[] {1, 1},                 new int[] {1, 1},                 BloomFilter::xorCardinality,                 0);         assertCardinalityOperation(new int[] {0, 1, 0, 1, 1, 1, 0, 1, 0},                 new int[] {1, 1, 0, 0, 0, 1},                 BloomFilter::xorCardinality,                 4);         assertCardinalityOperation(new int[] {1, 1},                 new int[] {0, 0, 1, 1, 1},                 BloomFilter::xorCardinality,                 5);     }      /**      * Assert a cardinality operation. Two CountingBloomFilters are created from the      * two sets of counts. The operation is applied and the counts of the first      * Bloom filter is checked using the expected counts.      *      * <p>Counts are assumed to map to indexes starting from 0.      *      * @param counts1 the first set counts      * @param counts2 the first set counts      * @param operation the operation      * @param expected the expected cardinality      */     private void assertCardinalityOperation(final int[] counts1, final int[] counts2,             final ToIntBiFunction<ArrayCountingBloomFilter, ArrayCountingBloomFilter> operation,             final int expected) {         final ArrayCountingBloomFilter bf1 = createFromCounts(counts1);         final ArrayCountingBloomFilter bf2 = createFromCounts(counts2);         assertEquals(expected, operation.applyAsInt(bf1, bf2));         assertEquals(expected, operation.applyAsInt(bf2, bf1));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic; import org.junit.Assert; import org.junit.Test; import java.nio.charset.StandardCharsets; import java.util.Arrays; import java.util.PrimitiveIterator.OfInt;  /**  * Tests the {@link HasherBloomFilter}.  */ public class HasherBloomFilterTest extends AbstractBloomFilterTest {      /**      * Tests that the constructor works correctly.      */     @Test     public void constructorTest_NonStatic() {         final Shape shape = new Shape(new MD5Cyclic(), 3, 72, 17);         final DynamicHasher hasher = new DynamicHasher.Builder(new MD5Cyclic()).with("Hello", StandardCharsets.UTF_8).build();         final HasherBloomFilter filter = createFilter(hasher, shape);         final long[] lb = filter.getBits();         assertEquals(2, lb.length);         assertEquals(0x6203101001888c44L, lb[0]);         assertEquals(0x60L, lb[1]);     }      @Override     protected AbstractBloomFilter createEmptyFilter(final Shape shape) {         return new HasherBloomFilter(shape);     }      @Override     protected HasherBloomFilter createFilter(final Hasher hasher, final Shape shape) {         return new HasherBloomFilter(hasher, shape);     }      /**      * Test the edge case where the filter is empty and the getBits() function returns a      * zero length array.      */     @Test     public void getBitsTest_Empty() {         final BloomFilter filter = createEmptyFilter(shape);         Assert.assertArrayEquals(new long[0], filter.getBits());     }      /**      * Test the edge case where the filter has only 1 bit in the lowest index and the getBits()      * function returns an array of length 1.      */     @Test     public void getBitsTest_LowestBitOnly() {         final BloomFilter filter = createEmptyFilter(shape);         // Set the lowest bit index only.         filter.merge(new Hasher() {             @Override             public OfInt iterator(final Shape shape) {                 return Arrays.stream(new int[] {0}).iterator();             }              @Override             public HashFunctionIdentity getHashFunctionIdentity() {                 return shape.getHashFunctionIdentity();             }         });         Assert.assertArrayEquals(new long[] {1L}, filter.getBits());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentityImpl; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness; import org.junit.Assert; import org.junit.Test;  import java.util.ArrayList; import java.util.Arrays; import java.util.Set; import java.util.function.IntConsumer; import java.util.stream.Collectors;  /**  * Tests for the {@link IndexFilters}.  */ public class IndexFilterTest {      /**      * The shape of the dummy Bloom filter.      * This is used as an argument to a Hasher that just returns fixed indexes      * so the parameters do not matter.      */     private final Shape shape = new Shape(new HashFunctionIdentityImpl(         "Apache Commons Collections", "Dummy", Signedness.SIGNED, ProcessType.CYCLIC, 0L),         50, 3000, 4);      @Test     public void testApplyThrowsWithNullArguments() {         final FixedIndexesTestHasher hasher = new FixedIndexesTestHasher(shape, 1, 2, 3);         final Shape shape = this.shape;         final ArrayList<Integer> actual = new ArrayList<>();         final IntConsumer consumer = actual::add;          try {             IndexFilters.distinctIndexes(null, shape, consumer);             Assert.fail("null hasher");         } catch (final NullPointerException expected) {             // Ignore         }          try {             IndexFilters.distinctIndexes(hasher, null, consumer);             Assert.fail("null shape");         } catch (final NullPointerException expected) {             // Ignore         }          try {             IndexFilters.distinctIndexes(hasher, shape, null);             Assert.fail("null consumer");         } catch (final NullPointerException expected) {             // Ignore         }          // All OK together         IndexFilters.distinctIndexes(hasher, shape, consumer);     }      @Test     public void testApply() {         assertFilter(1, 4, 6, 7, 9);     }      @Test     public void testApplyWithDuplicates() {         assertFilter(1, 4, 4, 6, 7, 7, 7, 7, 7, 9);     }      private void assertFilter(final int... indexes) {         final FixedIndexesTestHasher hasher = new FixedIndexesTestHasher(shape, indexes);         final Set<Integer> expected = Arrays.stream(indexes).boxed().collect(Collectors.toSet());         final ArrayList<Integer> actual = new ArrayList<>();          IndexFilters.distinctIndexes(hasher, shape, actual::add);          Assert.assertEquals(expected.size(), actual.size());         // Check the array has all the values.         // We do not currently check the order of indexes from the         // hasher.iterator() function.         for (final Integer index : actual) {             Assert.assertTrue(expected.contains(index));         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals; import java.util.List; import java.util.Arrays; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher; import org.junit.Assert; import org.junit.Test;  /**  * Test {@link SetOperations}.  */ public class SetOperationsTest {      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      private final Shape shape = new Shape(testFunction, 3, 72, 17);      @Test     public void testDifferentShapesThrows() {         final List<Integer> lst = Arrays.asList(1, 2);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          final Shape shape2 = new Shape(testFunction, 3, 72, 18);         final List<Integer> lst2 = Arrays.asList(2, 3);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape2);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape2);          try {             SetOperations.cosineDistance(filter1, filter2);             Assert.fail("Expected an IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // Ignore         }     }      /**      * Tests that the Cosine similarity is correctly calculated.      */     @Test     public final void cosineDistanceTest() {         List<Integer> lst = Arrays.asList(1, 2);         Hasher hasher = new StaticHasher(lst.iterator(), shape);         BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(2, 3);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.5, SetOperations.cosineDistance(filter1, filter2), 0.0001);         assertEquals(0.5, SetOperations.cosineDistance(filter2, filter1), 0.0001);          lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         hasher = new StaticHasher(lst.iterator(), shape);         filter1 = new HasherBloomFilter(hasher, shape);          lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.0, SetOperations.cosineDistance(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.cosineDistance(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.514928749927334, SetOperations.cosineDistance(filter1, filter2), 0.000000000000001);         assertEquals(0.514928749927334, SetOperations.cosineDistance(filter2, filter1), 0.000000000000001);     }      /**      * Tests that the Cosine distance is correctly calculated when one or      * both filters are empty      */     @Test     public final void cosineDistanceTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(1.0, SetOperations.cosineDistance(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.cosineDistance(filter2, filter1), 0.0001);         assertEquals(1.0, SetOperations.cosineDistance(filter1, filter3), 0.0001);         assertEquals(1.0, SetOperations.cosineDistance(filter3, filter1), 0.0001);     }      /**      * Tests that the Cosine similarity is correctly calculated.      */     @Test     public final void cosineSimilarityTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(1.0, SetOperations.cosineSimilarity(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.cosineSimilarity(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.485071250072666, SetOperations.cosineSimilarity(filter1, filter2), 0.000000000000001);         assertEquals(0.485071250072666, SetOperations.cosineSimilarity(filter2, filter1), 0.000000000000001);     }      /**      * Tests that the Cosine similarity is correctly calculated when one or      * both filters are empty      */     @Test     public final void cosineSimilarityTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(0.0, SetOperations.cosineSimilarity(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.cosineSimilarity(filter2, filter1), 0.0001);         assertEquals(0.0, SetOperations.cosineSimilarity(filter1, filter3), 0.0001);         assertEquals(0.0, SetOperations.cosineSimilarity(filter3, filter1), 0.0001);     }      /**      * Tests that the intersection size estimate is correctly calculated.      */     @Test     public final void estimateIntersectionSizeTest() {         // build a filter         List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          lst = Arrays.asList(8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,             31, 32, 33, 34, 35, 36, 37, 38, 39, 40);         final Hasher hasher2 = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          final long estimate = SetOperations.estimateIntersectionSize(filter1, filter2);         assertEquals(1, estimate);     }      /**      * Tests that the size estimate is correctly calculated.      */     @Test     public final void estimateSizeTest() {         // build a filter         List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher = new StaticHasher(lst.iterator(), shape);         BloomFilter filter1 = new HasherBloomFilter(hasher, shape);         assertEquals(1, SetOperations.estimateSize(filter1));          // the data provided above do not generate an estimate that is equivalent to the         // actual.         lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);         hasher = new StaticHasher(lst.iterator(), shape);         filter1 = new HasherBloomFilter(hasher, shape);         assertEquals(1, SetOperations.estimateSize(filter1));          lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,             26, 27, 28, 29, 30, 31, 32, 33);         final Hasher hasher2 = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(3, SetOperations.estimateSize(filter2));     }      /**      * Tests that the union size estimate is correctly calculated.      */     @Test     public final void estimateUnionSizeTest() {         // build a filter         List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          lst = Arrays.asList(17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,             40);         final Hasher hasher2 = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          final long estimate = SetOperations.estimateUnionSize(filter1, filter2);         assertEquals(3, estimate);     }      /**      * Tests that the Hamming distance is correctly calculated.      */     @Test     public final void hammingDistanceTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0, SetOperations.hammingDistance(filter1, filter2));         assertEquals(0, SetOperations.hammingDistance(filter2, filter1));          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(17, SetOperations.hammingDistance(filter1, filter2));         assertEquals(17, SetOperations.hammingDistance(filter2, filter1));     }      /**      * Tests that the Jaccard distance is correctly calculated.      */     @Test     public final void jaccardDistanceTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(1.0, SetOperations.jaccardDistance(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.jaccardDistance(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.32, SetOperations.jaccardDistance(filter1, filter2), 0.001);         assertEquals(0.32, SetOperations.jaccardDistance(filter2, filter1), 0.001);     }      /**      * Tests that the Jaccard distance is correctly calculated when one or      * both filters are empty      */     @Test     public final void jaccardDistanceTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(1.0, SetOperations.jaccardDistance(filter1, filter2), 0.0001);         assertEquals(1.0, SetOperations.jaccardDistance(filter2, filter1), 0.0001);         assertEquals(0.0, SetOperations.jaccardDistance(filter1, filter3), 0.0001);         assertEquals(0.0, SetOperations.jaccardDistance(filter3, filter1), 0.0001);     }      /**      * Tests that the Jaccard similarity is correctly calculated.      */     @Test     public final void jaccardSimilarityTest() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter1 = new HasherBloomFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         BloomFilter filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.0, SetOperations.jaccardSimilarity(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.jaccardSimilarity(filter2, filter1), 0.0001);          lst2 = Arrays.asList(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);         hasher2 = new StaticHasher(lst2.iterator(), shape);         filter2 = new HasherBloomFilter(hasher2, shape);          assertEquals(0.68, SetOperations.jaccardSimilarity(filter1, filter2), 0.001);         assertEquals(0.68, SetOperations.jaccardSimilarity(filter2, filter1), 0.001);     }      /**      * Tests that the Jaccard similarity is correctly calculated when one or      * both filters are empty      */     @Test     public final void jaccardSimilarityTest_NoValues() {         final BloomFilter filter1 = new HasherBloomFilter(shape);         final BloomFilter filter2 = new HasherBloomFilter(shape);         // build a filter         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter filter3 = new HasherBloomFilter(hasher, shape);          assertEquals(0.0, SetOperations.jaccardSimilarity(filter1, filter2), 0.0001);         assertEquals(0.0, SetOperations.jaccardSimilarity(filter2, filter1), 0.0001);         assertEquals(1.0, SetOperations.jaccardSimilarity(filter1, filter3), 0.0001);         assertEquals(1.0, SetOperations.jaccardSimilarity(filter3, filter1), 0.0001);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.List; import java.util.PrimitiveIterator.OfInt; import java.util.function.BiFunction; import java.util.function.IntConsumer; import java.util.ArrayList; import java.util.Arrays; import java.util.BitSet;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher; import org.junit.Test;  /**  * Test standard methods in the {@link BloomFilter} interface.  */ public abstract class AbstractBloomFilterTest {      /**      * An implementation of BloomFilter that is used to test merge and cardinality      * operations with a filter type that does not match the type of the filter      * being tested.      */     private static class TestBloomFilter extends AbstractBloomFilter {         /** The bits. */         final BitSet bits;          protected TestBloomFilter(final Shape shape, final BitSet bits) {             super(shape);             this.bits = bits;         }          @Override         public long[] getBits() {             return bits.toLongArray();         }          @Override         public StaticHasher getHasher() {             return new StaticHasher(bits.stream().iterator(), getShape());         }          @Override         public boolean merge(final BloomFilter other) {             throw new UnsupportedOperationException();         }          @Override         public boolean merge(final Hasher hasher) {             throw new UnsupportedOperationException();         }     }      /**      * A HashFunctionIdentity for testing.      */     protected HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /**      * A second HashFunctionIdentity for testing.      */     protected HashFunctionIdentity testFunctionX = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test FunctionX";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 1;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /**      * The shape of the Bloom filters for testing      */     protected Shape shape = new Shape(testFunction, 3, 72, 17);      /**      * Tests that the andCardinality calculations are correct.      */     @Test     public final void andCardinalityTest() {         andCardinalityTest(this::createFilter);     }      /**      * Tests that the andCardinality calculations are correct with a generic BloomFilter.      */     @Test     public final void andCardinalityTest_GenericBloomFilter() {         andCardinalityTest(this::createGenericFilter);     }      /**      * Tests that the andCardinality calculations are correct.      *      * @param filterFactory the factory function to create the filter      */     private void andCardinalityTest(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertEquals(7, bf.andCardinality(bf2));     }      /**      * Tests that the andCardinality calculations are correct when there are more than Long.LENGTH bits.      */     @Test     public final void andCardinalityTest_ExtraLongs() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = createFilter(hasher2, shape);          assertEquals(7, bf.andCardinality(bf2));         assertEquals(7, bf2.andCardinality(bf));     }      /**      * Compare 2 static hashers to verify they have the same bits enabled.      *      * @param hasher1 the first static hasher.      * @param hasher2 the second static hasher.      */     private void assertSameBits(final StaticHasher hasher1, final StaticHasher hasher2) {         final OfInt iter1 = hasher1.iterator(shape);         final OfInt iter2 = hasher2.iterator(shape);          while (iter1.hasNext()) {             assertTrue("Not enough data in second hasher", iter2.hasNext());             assertEquals(iter1.nextInt(), iter2.nextInt());         }         assertFalse("Too much data in second hasher", iter2.hasNext());     }      /**      * Tests that cardinality is correct.      */     @Test     public final void cardinalityTest() {          final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);         assertEquals(17, bf.cardinality());     }      /**      * Tests that creating an empty hasher works as expected.      */     @Test     public final void constructorTest_Empty() {          final BloomFilter bf = createEmptyFilter(shape);         final long[] lb = bf.getBits();         assertEquals(0, lb.length);     }      /**      * Tests that creating a filter with a hasher works as expected.      */     @Test     public final void constructorTest_Hasher() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);         final long[] lb = bf.getBits();         assertEquals(0x1FFFF, lb[0]);         assertEquals(1, lb.length);     }      /**      * Tests that creating a Bloom filter with a Static hasher that has one shape and a      * different specified shape fails.      */     @Test     public final void constructorTest_WrongShape() {         final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);          final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), anotherShape);         try {             createFilter(hasher, shape);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that contains() with a Bloom filter argument returns the proper results.      */     @Test     public final void containsTest_BloomFilter() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(4, 5, 6, 7, 8, 9, 10);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         final BloomFilter bf2 = createFilter(hasher2, shape);         assertTrue(bf.contains(bf2));         assertFalse(bf2.contains(bf));     }      /**      * Tests that contains() fails properly if the other Bloom filter is not of the proper shape.      */     @Test     public final void containsTest_BloomFilter_WrongShape() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);         final Hasher hasher2 = new StaticHasher(lst.iterator(), anotherShape);         final BloomFilter bf2 = createFilter(hasher2, anotherShape);         try {             bf.contains(bf2);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that contains() with a Hasher argument returns the proper results.      */     @Test     public final void containsTest_Hasher() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          List<Integer> lst2 = Arrays.asList(4, 5, 6, 7, 8, 9, 10);         Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         assertTrue(bf.contains(hasher2));          lst2 = Arrays.asList(17, 18, 19, 20);         hasher2 = new StaticHasher(lst2.iterator(), shape);         assertFalse(bf.contains(hasher2));          lst2 = Arrays.asList(10, 11, 12, 17, 18, 19, 20);         hasher2 = new StaticHasher(lst2.iterator(), shape);         assertFalse(bf.contains(hasher2));     }      /**      * Tests that contains() fails properly if the hasher is not of the proper shape.      */     @Test     public final void containsTest_Hasher_WrongShape() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);          final List<Integer> lst2 = Arrays.asList(4, 5, 6, 7, 8, 9, 10);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), anotherShape);         try {             bf.contains(hasher2);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Create an empty version of the BloomFilter implementation we are testing.      *      * @param shape the shape of the filter.      * @return a BloomFilter implementation.      */     protected abstract AbstractBloomFilter createEmptyFilter(Shape shape);      /**      * Create the BloomFilter implementation we are testing.      *      * @param hasher the hasher to use to create the filter.      * @param shape the shape of the filter.      * @return a BloomFilter implementation.      */     protected abstract AbstractBloomFilter createFilter(Hasher hasher, Shape shape);      /**      * Create a generic BloomFilter implementation.      *      * @param hasher the hasher to use to create the filter.      * @param shape the shape of the filter.      * @return a BloomFilter implementation.      */     private AbstractBloomFilter createGenericFilter(final Hasher hasher, final Shape shape) {         final BitSet bits = new BitSet();         hasher.iterator(shape).forEachRemaining((IntConsumer) bits::set);         return new TestBloomFilter(shape, bits);     }      /**      * Tests that getBits() works correctly when multiple long values are returned.      */     @Test     public final void getBitsTest_SpanLong() {         final List<Integer> lst = Arrays.asList(63, 64);         final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);         final long[] lb = bf.getBits();         assertEquals(2, lb.length);         assertEquals(0x8000000000000000L, lb[0]);         assertEquals(0x1, lb[1]);     }      /**      * Tests that the the hasher returned from getHasher() works correctly.      */     @Test     public final void getHasherTest() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);         final BloomFilter bf = createFilter(hasher, shape);          final StaticHasher hasher2 = bf.getHasher();          assertEquals(shape, hasher2.getShape());         assertSameBits(hasher, hasher2);     }      /**      * Tests that isFull() returns the proper values.      */     @Test     public final void isFullTest() {          // create empty filter         AbstractBloomFilter filter = createEmptyFilter(shape);         assertFalse(filter.isFull());          final List<Integer> values = new ArrayList<>(shape.getNumberOfBits());         for (int i = 0; i < shape.getNumberOfBits(); i++) {             values.add(i);         }          StaticHasher hasher2 = new StaticHasher(values.iterator(), shape);         filter = createFilter(hasher2, shape);          assertTrue(filter.isFull());          final int mid = shape.getNumberOfBits() / 2;         values.remove(Integer.valueOf(mid));         hasher2 = new StaticHasher(values.iterator(), shape);         filter = createFilter(hasher2, shape);         assertFalse(filter.isFull());     }      /**      * Tests that merging bloom filters works as expected.      */     @Test     public final void mergeTest_BloomFilter() {         mergeTest_BloomFilter(this::createFilter);     }      /**      * Tests that merging bloom filters works as expected with a generic BloomFilter.      */     @Test     public final void mergeTest_GenericBloomFilter() {         mergeTest_BloomFilter(this::createGenericFilter);     }      /**      * Tests that merging bloom filters works as expected.      *      * @param filterFactory the factory function to create the filter      */     private void mergeTest_BloomFilter(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertTrue("Merge should not fail", bf.merge(bf2));         assertEquals(27, bf.cardinality());     }      /**      * Tests that merging bloom filters with different shapes fails properly      */     @Test     public final void mergeTest_BloomFilter_WrongShape() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);         final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), anotherShape);         final BloomFilter bf2 = createFilter(hasher2, anotherShape);          try {             bf.merge(bf2);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that merging a hasher into a Bloom filter works as expected      */     @Test     public final void mergeTest_Hasher() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          assertTrue("Merge should not fail", bf.merge(hasher2));         assertEquals(27, bf.cardinality());     }      /**      * Tests that merging a static hasher with the wrong shape into a Bloom filter fails as expected      */     @Test     public final void mergeTest_Hasher_WrongShape() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final Shape anotherShape = new Shape(testFunctionX, 3, 72, 17);         final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), anotherShape);          try {             bf.merge(hasher2);             fail("Should throw IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that the orCardinality calculations are correct.      */     @Test     public final void orCardinalityTest() {         orCardinalityTest(this::createFilter);     }      /**      * Tests that the orCardinality calculations are correct with a generic BloomFilter.      */     @Test     public final void orCardinalityTest_GenericBloomFilter() {         orCardinalityTest(this::createGenericFilter);     }      /**      * Tests that the andCardinality calculations are correct.      *      * @param filterFactory the factory function to create the filter      */     private void orCardinalityTest(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final AbstractBloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertEquals(27, bf.orCardinality(bf2));     }      /**      * Tests that the orCardinality calculations are correct when there are more than Long.LENGTH bits.      */     @Test     public final void orCardinalityTest_ExtraLongs() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final AbstractBloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final AbstractBloomFilter bf2 = createFilter(hasher2, shape);          assertEquals(27, bf.orCardinality(bf2));         assertEquals(27, bf2.orCardinality(bf));     }      /**      * Tests that the xorCardinality calculations are correct.      */     @Test     public final void xorCardinalityTest() {         xorCardinalityTest(this::createFilter);     }      /**      * Tests that the xorCardinality calculations are correct with a generic BloomFilter.      */     @Test     public final void xorCardinalityTest_GenericBloomFilter() {         xorCardinalityTest(this::createGenericFilter);     }      /**      * Tests that the andCardinality calculations are correct.      *      * @param filterFactory the factory function to create the filter      */     private void xorCardinalityTest(final BiFunction<Hasher, Shape, BloomFilter> filterFactory) {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);          final BloomFilter bf2 = filterFactory.apply(hasher2, shape);          assertEquals(20, bf.xorCardinality(bf2));     }      /**      * Tests that the xorCardinality calculations are correct when there are more than Long.LENGTH bits.      */     @Test     public final void xorCardinalityTest_ExtraLongs() {         final List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);         final Hasher hasher = new StaticHasher(lst.iterator(), shape);          final BloomFilter bf = createFilter(hasher, shape);          final List<Integer> lst2 = Arrays.asList(11, 12, 13, 14, 15, 16, 17, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69);         final Hasher hasher2 = new StaticHasher(lst2.iterator(), shape);         final BloomFilter bf2 = createFilter(hasher2, shape);          assertEquals(20, bf.xorCardinality(bf2));         assertEquals(20, bf2.xorCardinality(bf));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher.Builder; import org.apache.commons.lang3.NotImplementedException; import org.junit.Assert; import org.junit.Test; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.nio.CharBuffer; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.ArrayList;  /**  * Tests the  * {@link org.apache.commons.collections4.bloomfilter.hasher.Hasher.Builder Hasher.Builder}.  */ public class HasherBuilderTest {      /**      * Simple class to collect byte[] items added to the builder.      */     private static class TestBuilder implements Hasher.Builder {         ArrayList<byte[]> items = new ArrayList<>();          @Override         public Hasher build() {             throw new NotImplementedException("Not required");         }          @Override         public Builder with(final byte[] item) {             items.add(item);             return this;         }     }      /**      * Tests that adding CharSequence items works correctly.      */     @Test     public void withCharSequenceTest() {         final String ascii = "plain";         final String extended = getExtendedString();         for (final String s : new String[] {ascii, extended}) {             for (final Charset cs : new Charset[] {                 StandardCharsets.ISO_8859_1, StandardCharsets.UTF_8, StandardCharsets.UTF_16             }) {                 final TestBuilder builder = new TestBuilder();                 builder.with(s, cs);                 Assert.assertArrayEquals(s.getBytes(cs), builder.items.get(0));             }         }     }      /**      * Tests that adding unencoded CharSequence items works correctly.      */     @Test     public void withUnencodedCharSequenceTest() {         final String ascii = "plain";         final String extended = getExtendedString();         for (final String s : new String[] {ascii, extended}) {             final TestBuilder builder = new TestBuilder();             builder.withUnencoded(s);             final byte[] encoded = builder.items.get(0);             final char[] original = s.toCharArray();             // Should be twice the length             Assert.assertEquals(original.length * 2, encoded.length);             // Should be little endian (lower bits first)             final CharBuffer buffer = ByteBuffer.wrap(encoded)                                                 .order(ByteOrder.LITTLE_ENDIAN).asCharBuffer();             for (int i = 0; i < original.length; i++) {                 Assert.assertEquals(original[i], buffer.get(i));             }         }     }      /**      * Gets a string with non-standard characters.      *      * @return the extended string      */     static String getExtendedString() {         final char[] data = {'e', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ',             // Add some characters that are non standard             // non-ascii             0xCA98,             // UTF-16 surrogate pair             0xD803, 0xDE6D             // Add other cases here ...         };         return String.valueOf(data);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.nio.charset.StandardCharsets; import java.util.NoSuchElementException; import java.util.PrimitiveIterator.OfInt;  import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic; import org.junit.Before; import org.junit.Test;  /**  * {@link DynamicHasher.Builder} tests.  */ public class DynamicHasherBuilderTest {      private DynamicHasher.Builder builder;     private final HashFunction hf = new MD5Cyclic();     private final Shape shape = new Shape(hf, 1, 345, 1);     private final String testString = HasherBuilderTest.getExtendedString();      /**      * Tests that hashing a byte array works as expected.      */     @Test     public void buildTest_byteArray() {         final byte[] bytes = testString.getBytes();         final DynamicHasher hasher = builder.with(bytes).build();         final int expected = (int) Math.floorMod((long) hf.apply(bytes, 0), (long) shape.getNumberOfBits());          final OfInt iter = hasher.iterator(shape);          assertTrue(iter.hasNext());         assertEquals(expected, iter.nextInt());         assertFalse(iter.hasNext());     }      /**      * Tests that an empty hasher works as expected.      */     @Test     public void buildTest_Empty() {         final DynamicHasher hasher = builder.build();          final OfInt iter = hasher.iterator(shape);          assertFalse(iter.hasNext());         try {             iter.nextInt();             fail("Should have thrown NoSuchElementException");         } catch (final NoSuchElementException ignore) {             // do nothing         }     }      /**      * Tests that hashing a string works as expected.      */     @Test     public void buildTest_String() {         final byte[] bytes = testString.getBytes(StandardCharsets.UTF_8);         final DynamicHasher hasher = builder.with(testString, StandardCharsets.UTF_8).build();         final int expected = (int) Math.floorMod((long) hf.apply(bytes, 0), (long) shape.getNumberOfBits());          final OfInt iter = hasher.iterator(shape);          assertTrue(iter.hasNext());         assertEquals(expected, iter.nextInt());         assertFalse(iter.hasNext());     }      /**      * Tests that hashing a string works as expected.      */     @Test     public void buildTest_UnencodedString() {         final byte[] bytes = testString.getBytes(StandardCharsets.UTF_16LE);         final DynamicHasher hasher = builder.withUnencoded(testString).build();         final int expected = (int) Math.floorMod((long) hf.apply(bytes, 0), (long) shape.getNumberOfBits());          final OfInt iter = hasher.iterator(shape);          assertTrue(iter.hasNext());         assertEquals(expected, iter.nextInt());         assertFalse(iter.hasNext());     }      /**      * Tests that build resets the builder.      */     @Test     public void buildResetTest() {         builder.with(new byte[] {123});         final OfInt iter = builder.build().iterator(shape);          assertTrue(iter.hasNext());         iter.next();         assertFalse(iter.hasNext());          // Nothing added since last build so it should be an empty hasher         final OfInt iter2 = builder.build().iterator(shape);         assertFalse(iter2.hasNext());     }      /**      * Sets up the builder for testing.      */     @Before     public void setup() {         builder = new DynamicHasher.Builder(hf);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity; import org.junit.Test;  /**  * Tests the signature of a hash function.  */ public abstract class AbstractHashFunctionTest {      /**      * Test that the signature is properly generated.      */     @Test     public void signatureTest() {         final HashFunction hf = createHashFunction();         final long expected = hf.apply(HashFunctionIdentity.prepareSignatureBuffer(hf), 0);         assertEquals(expected, hf.getSignature());         // Should be repeatable         final long expected2 = hf.apply(HashFunctionIdentity.prepareSignatureBuffer(hf), 0);         assertEquals(expected, expected2);         assertEquals("Apache Commons Collections", hf.getProvider());     }      /**      * Creates the hash function.      *      * @return the hash function      */     protected abstract HashFunction createHashFunction(); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import java.nio.charset.StandardCharsets; import java.util.Arrays; import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Tests that the Objects hash works correctly.  */ public class ObjectsHashIterativeTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final ObjectsHashIterative obj = new ObjectsHashIterative();          final byte[] buffer = "Now is the time for all good men to come to the aid of their country"             .getBytes(StandardCharsets.UTF_8);          long l = obj.apply(buffer, 0);         long prev = 0;         assertEquals(Arrays.deepHashCode(new Object[] {prev, buffer}), l);         for (int i = 1; i <= 5; i++) {             prev += l;             l = obj.apply(buffer, i);             assertEquals(Arrays.deepHashCode(new Object[] {prev, buffer}), l);         }     }      @Override     protected HashFunction createHashFunction() {         return new ObjectsHashIterative();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import java.nio.charset.StandardCharsets; import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Test that the Murmur3 128 x64 hash function works correctly.  */ public class Murmur128x64CyclicTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final Murmur128x64Cyclic murmur = new Murmur128x64Cyclic();          final long l1 = 0xe7eb60dabb386407L;         final long l2 = 0xc3ca49f691f73056L;         final byte[] buffer = "Now is the time for all good men to come to the aid of their country"             .getBytes(StandardCharsets.UTF_8);          long l = murmur.apply(buffer, 0);         assertEquals(l1, l);         l = murmur.apply(buffer, 1);         assertEquals(l1 + l2, l);         l = murmur.apply(buffer, 2);         assertEquals(l1 + l2 + l2, l);     }      @Override     protected HashFunction createHashFunction() {         return new Murmur128x64Cyclic();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import java.nio.charset.StandardCharsets; import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Test that the Murmur3 32 x86 hash function works correctly.  */ public class Murmur32x86IterativeTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final Murmur32x86Iterative murmur = new Murmur32x86Iterative();          final byte[] buffer = "Now is the time for all good men to come to the aid of their country"             .getBytes(StandardCharsets.UTF_8);          long l = murmur.apply(buffer, 0);         assertEquals(82674681, l);         l = murmur.apply(buffer, 1);         assertEquals(-1475490736, l);         l = murmur.apply(buffer, 2);         assertEquals(-1561435247, l);     }      @Override     protected HashFunction createHashFunction() {         return new Murmur32x86Iterative();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher.function;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunction; import org.junit.Test;  /**  * Tests the MD5 cyclic hash function.  */ public class MD5CyclicTest extends AbstractHashFunctionTest {      /**      * Test that the apply function returns the proper values.      */     @Test     public void applyTest() {         final MD5Cyclic md5 = new MD5Cyclic();         final long l1 = 0x8b1a9953c4611296L;         final long l2 = 0xa827abf8c47804d7L;         final byte[] buffer = "Hello".getBytes();          long l = md5.apply(buffer, 0);         assertEquals(l1, l);         l = md5.apply(buffer, 1);         assertEquals(l1 + l2, l);         l = md5.apply(buffer, 2);         assertEquals(l1 + l2 + l2, l);     }      @Override     protected HashFunction createHashFunction() {         return new MD5Cyclic();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness; import org.junit.Test;  /**  * Tests of the {@link HashFunctionValidator}.  */ public class HashFunctionValidatorTest {      /**      * Tests that name is used in the equality check.      */     @Test     public void testName() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl2", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertFalse(HashFunctionValidator.areEqual(impl1, impl2));         assertFalse(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Tests that name is not affected by case.      */     @Test     public void testNameIsCaseInsensitive() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "IMPL1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl2));     }      /**      * Tests that process type is used in the equality check.      */     @Test     public void testProcessType() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.ITERATIVE, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertFalse(HashFunctionValidator.areEqual(impl1, impl2));         assertFalse(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Tests that provider is <strong>not</strong> used in the equality check.      */     @Test     public void testProviderIsNotUsedInEqualityCheck() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite2", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertTrue(HashFunctionValidator.areEqual(impl1, impl2));         assertTrue(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Tests that signedness is used in the equality check.      */     @Test     public void testSignedness() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.UNSIGNED,             ProcessType.CYCLIC, 300L);          assertTrue(HashFunctionValidator.areEqual(impl1, impl1));         assertTrue(HashFunctionValidator.areEqual(impl2, impl2));         assertFalse(HashFunctionValidator.areEqual(impl1, impl2));         assertFalse(HashFunctionValidator.areEqual(impl2, impl1));     }      /**      * Test the check method throws when the two hash functions are not equal.      */     @Test(expected=IllegalArgumentException.class)     public void testCheckThrows() {         final HashFunctionIdentityImpl impl1 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.SIGNED,             ProcessType.CYCLIC, 300L);         final HashFunctionIdentityImpl impl2 = new HashFunctionIdentityImpl("Testing Suite", "impl1", Signedness.UNSIGNED,             ProcessType.CYCLIC, 300L);         HashFunctionValidator.checkAreEqual(impl1, impl2);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Arrays; import java.util.Iterator; import java.util.List; import java.util.PrimitiveIterator.OfInt;  import org.junit.Test;  /**  * Tests the {@link StaticHasher}.  */ public class StaticHasherTest {      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      private final HashFunctionIdentity testFunctionX = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test FunctionX";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      private final Shape shape = new Shape(testFunction, 3, 72, 17);      /**      * Compare 2 static hashers to verify they have the same bits enabled.      *      * @param hasher1 the first static hasher.      * @param hasher2 the second static hasher.      */     private void assertSameBits(final StaticHasher hasher1, final StaticHasher hasher2) {         final OfInt iter1 = hasher1.iterator(shape);         final OfInt iter2 = hasher2.iterator(shape);          while (iter1.hasNext()) {             assertTrue("Not enough data in second hasher", iter2.hasNext());             assertEquals(iter1.nextInt(), iter2.nextInt());         }         assertFalse("Too much data in second hasher", iter2.hasNext());     }      /**      * Tests that passing a hasher other than a StaticHasher to the constructor works as      * expected.      */     @Test     public void testConstructor_Hasher() {         final int[] expected = {1, 3, 5, 7, 9};          final Hasher testHasher = new Hasher() {              @Override             public OfInt iterator(final Shape shape) {                 final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};                 return Arrays.stream(values).iterator();             }              @Override             public HashFunctionIdentity getHashFunctionIdentity() {                 return testFunction;             }         };          final StaticHasher hasher = new StaticHasher(testHasher, shape);         final OfInt iter = hasher.iterator(shape);         for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that passing a hasher other than a StaticHasher and the wrong Shape to the      * constructor throws an IllegalArgumentException.      */     @Test     public void testConstructor_Hasher_WrongShape() {         final Hasher testHasher = new Hasher() {              @Override             public OfInt iterator(final Shape shape) {                 final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};                 return Arrays.stream(values).iterator();             }              @Override             public HashFunctionIdentity getHashFunctionIdentity() {                 return testFunctionX;             }         };          try {             new StaticHasher(testHasher, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Test that the iterator based constructor works correctly and removes duplicates.      */     @Test     public void testConstructor_Iterator() {          final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};         Iterator<Integer> iter = Arrays.stream(values).iterator();         final StaticHasher hasher = new StaticHasher(iter, shape);          assertEquals(5, hasher.size());         assertEquals(shape, hasher.getShape());         // All function properties are equal         assertEquals(testFunction.getName(), hasher.getHashFunctionIdentity().getName());         assertEquals(testFunction.getProcessType(), hasher.getHashFunctionIdentity().getProcessType());         assertEquals(testFunction.getProvider(), hasher.getHashFunctionIdentity().getProvider());         assertEquals(testFunction.getSignedness(), hasher.getHashFunctionIdentity().getSignedness());          iter = hasher.iterator(shape);         int idx = 0;         while (iter.hasNext()) {             assertEquals("Error at idx " + idx, Integer.valueOf(values[idx]), iter.next());             idx++;         }         assertEquals(5, idx);     }      /**      * Tests that if the iterator passed to the constructor contains a value greater than      * or equal to Shape.numberOfBits() an exception is thrown.      */     @Test     public void testConstructor_Iterator_ValueTooBig() {          final int[] values = {shape.getNumberOfBits(), 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         try {             new StaticHasher(iter, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Tests that if the iterator passed to the constructor contains a value less than 0      * (zero) an exception is thrown.      */     @Test     public void testConstructor_Iterator_ValueTooSmall() {          final int[] values = {-1, 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         try {             new StaticHasher(iter, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Tests that the constructor that accepts a static hasher properly builds the hasher.      */     @Test     public void testConstructor_StaticHasher() {         final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         final StaticHasher hasher = new StaticHasher(iter, shape);          final StaticHasher hasher2 = new StaticHasher(hasher, shape);         assertEquals(shape, hasher2.getShape());         assertSameBits(hasher, hasher2);     }      /**      * Tests that calling the constructor with a hasher and the wrong shape throws an      * IllegalArgumentException.      */     @Test     public void testConstructor_StaticHasher_WrongShape() {         final int[] values = {1, 3, 5, 7, 9, 3, 5, 1};         final Iterator<Integer> iter = Arrays.stream(values).iterator();         final StaticHasher hasher = new StaticHasher(iter, new Shape(testFunctionX, 3, 72, 17));          try {             new StaticHasher(hasher, shape);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     }      /**      * Tests that iterator returns the proper values.      */     @Test     public void testGetBits() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);          final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);         assertEquals(17, hasher.size());         final OfInt iter = hasher.iterator(shape);         for (int i = 0; i < 17; i++) {             assertTrue(iter.hasNext());             assertEquals(i, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that iterator does not return duplicates and orders the indices.      */     @Test     public void testGetBits_DuplicateValues() {         final int[] input = {6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7, 69, 59,             49, 39, 13, 3, 65, 55, 45, 35, 25};         final int[] expected = {1, 2, 3, 6, 7, 10, 11, 13, 15, 17, 19, 23, 24, 25, 35, 36, 39, 43, 44, 45, 48, 49, 53, 55, 57,             59, 61, 62, 63, 65, 69, 70};          final StaticHasher hasher = new StaticHasher(Arrays.stream(input).iterator(), shape);          final OfInt iter = hasher.iterator(shape);         for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that gitBits is called with the wrong shape an exception is thrown.      */     @Test     public void testGetBits_WrongShape() {         final List<Integer> lst = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);         final StaticHasher hasher = new StaticHasher(lst.iterator(), shape);          try {             hasher.iterator(new Shape(testFunctionX, 3, 72, 17));             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.junit.Test;  /**  * Tests the HashFunctionIdentity implementation ({@link HashFunctionIdentityImpl})..  */ public class HashFunctionIdentityImplTest {      /**      * Tests a copy constructor of the HashFunctionIdentity.      */     @Test     public void copyConstructorTest() {         final HashFunctionIdentity identity = new HashFunctionIdentity() {              @Override             public String getName() {                 return "NAME";             }              @Override             public ProcessType getProcessType() {                 return ProcessType.CYCLIC;             }              @Override             public String getProvider() {                 return "Provider";             }              @Override             public long getSignature() {                 return -1L;             }              @Override             public Signedness getSignedness() {                 return Signedness.SIGNED;             }          };         final HashFunctionIdentityImpl impl = new HashFunctionIdentityImpl(identity);         assertEquals("NAME", impl.getName());         assertEquals("Provider", impl.getProvider());         assertEquals(Signedness.SIGNED, impl.getSignedness());         assertEquals(ProcessType.CYCLIC, impl.getProcessType());         assertEquals(-1L, impl.getSignature());     }      /**      * Test the constructor from component values.      */     @Test     public void valuesConstructorTest() {         final HashFunctionIdentityImpl impl = new HashFunctionIdentityImpl("Provider", "NAME", Signedness.UNSIGNED,             ProcessType.ITERATIVE, -2L);         assertEquals("NAME", impl.getName());         assertEquals("Provider", impl.getProvider());         assertEquals(Signedness.UNSIGNED, impl.getSignedness());         assertEquals(ProcessType.ITERATIVE, impl.getProcessType());         assertEquals(-2L, impl.getSignature());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.nio.charset.StandardCharsets; import java.util.NoSuchElementException; import java.util.PrimitiveIterator.OfInt;  import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic; import org.junit.Before; import org.junit.Test;  /**  * Tests the {@link DynamicHasher}.  */ public class DynamicHasherTest {     private DynamicHasher.Builder builder;     private Shape shape;      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /**      * Sets up the DynamicHasher.      */     @Before     public void setup() {         builder = new DynamicHasher.Builder(new MD5Cyclic());         shape = new Shape(new MD5Cyclic(), 3, 72, 17);     }      /**      * Tests that the expected bits are returned from hashing.      */     @Test     public void testGetBits() {          final int[] expected = {6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62};          final Hasher hasher = builder.with("Hello", StandardCharsets.UTF_8).build();          final OfInt iter = hasher.iterator(shape);          for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());     }      /**      * Tests that bits from multiple hashes are returned correctly.      */     @Test     public void testGetBits_MultipleHashes() {         final int[] expected = {6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7, 69,             59, 49, 39, 13, 3, 65, 55, 45, 35, 25};          final Hasher hasher = builder.with("Hello", StandardCharsets.UTF_8).with("World", StandardCharsets.UTF_8).build();          final OfInt iter = hasher.iterator(shape);          for (final int element : expected) {             assertTrue(iter.hasNext());             assertEquals(element, iter.nextInt());         }         assertFalse(iter.hasNext());         try {             iter.next();             fail("Should have thrown NoSuchElementException");         } catch (final NoSuchElementException ignore) {             // do nothing         }     }      /**      * Tests that retrieving bits for the wrong shape throws an exception.      */     @Test     public void testGetBits_WrongShape() {          final Hasher hasher = builder.with("Hello", StandardCharsets.UTF_8).build();          try {             hasher.iterator(new Shape(testFunction, 3, 72, 17));             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter.hasher;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotEquals; import static org.junit.Assert.fail;  import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType; import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.Signedness;  import java.util.ArrayList;  import org.junit.Test;  /**  * Tests the {@link Shape} class.  */ public class ShapeTest {      private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {          @Override         public String getName() {             return "Test Function";         }          @Override         public ProcessType getProcessType() {             return ProcessType.CYCLIC;         }          @Override         public String getProvider() {             return "Apache Commons Collection Tests";         }          @Override         public long getSignature() {             return 0;         }          @Override         public Signedness getSignedness() {             return Signedness.SIGNED;         }     };      /*      * values from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=      *      * n = 5      *      * p = 0.100375138 (1 in 10)      *      * m = 24 (3B)      *      * k = 3      */      private final Shape shape = new Shape(testFunction, 5, 0.1);      /**      * Tests that if the number of bits less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_bits_BadNumberOfBitsTest() {         try {             new Shape(testFunction, 5, 0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of hash functions is less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_bits_BadNumberOfHashFunctionsTest() {         try {             new Shape(testFunction, 16, 8);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of items less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_bits_BadNumberOfItemsTest() {         try {             new Shape(testFunction, 0, 24);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of bits is less than 1 an exception is thrown      */     @Test     public void constructor_items_bits_hash_BadNumberOfBitsTest() {         try {             new Shape(testFunction, 5, 0, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of hash functions is less than 1 an exception is thrown.      */     @Test     public void constructor_items_bits_hash_BadNumberOfHashFunctionsTest() {         try {             new Shape(testFunction, 5, 24, 0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of items is less than 1 an exception is thrown.      */     @Test     public void constructor_items_bits_hash_BadNumberOfItemsTest() {         try {             new Shape(testFunction, 0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the calculated probability is greater than or equal to 1 an IllegalArgumentException is thrown      */     @Test     public void constructor_items_bits_hash_BadProbabilityTest() {         try {             new Shape(testFunction, 4000, 8, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that when the number of items, number of bits and number of hash functions is passed the values are      * calculated correctly.      */     @Test     public void constructor_items_bits_hashTest() {         /*          * values from https://hur.st/bloomfilter/?n=5&m=24&k=4          */         final Shape filterConfig = new Shape(testFunction, 5, 24, 4);          assertEquals(24, filterConfig.getNumberOfBits());         assertEquals(4, filterConfig.getNumberOfHashFunctions());         assertEquals(5, filterConfig.getNumberOfItems());         assertEquals(0.102194782, filterConfig.getProbability(), 0.000001);     }      /**      * Tests that the number of items and number of bits is passed the other values are calculated correctly.      */     @Test     public void constructor_items_bitsTest() {         /*          * values from https://hur.st/bloomfilter/?n=5&m=24          */         final Shape filterConfig = new Shape(testFunction, 5, 24);          assertEquals(24, filterConfig.getNumberOfBits());         assertEquals(3, filterConfig.getNumberOfHashFunctions());         assertEquals(5, filterConfig.getNumberOfItems());         assertEquals(0.100375138, filterConfig.getProbability(), 0.000001);     }      /**      * Tests that if the number of items is less than 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_probability_BadNumberOfItemsTest() {         try {             new Shape(testFunction, 0, 1.0 / 10);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that if the probability is less than or equal to 0 or more than or equal to 1 an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_probability_BadProbabilityTest() {         try {             new Shape(testFunction, 10, 0.0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }         try {             new Shape(testFunction, 10, 1.0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }         try {             new Shape(testFunction, 10, Double.NaN);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests that if calculated number of bits is greater than Integer.MAX_VALUE an IllegalArgumentException is thrown.      */     @Test     public void constructor_items_probability_NumberOfBitsOverflowTest() {         try {             new Shape(testFunction, Integer.MAX_VALUE, 1.0 / 10);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // do nothing.         }     }      /**      * Tests the the probability is calculated correctly.      */     @Test     public void constructor_items_probability_Test() {          assertEquals(24, shape.getNumberOfBits());         assertEquals(3, shape.getNumberOfHashFunctions());         assertEquals(5, shape.getNumberOfItems());         assertEquals(0.100375138, shape.getProbability(), 0.000001);     }      /**      * Tests that the constructor with a null name, number of items and size of filter fails.      */     @Test     public void constructor_nm_noName() {         try {             new Shape(null, 5, 72);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that the constructor with a null name, number of items, size of filter, and number of functions fails.      */     @Test     public void constructor_nmk_noName() {         try {             new Shape(null, 5, 72, 17);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that the constructor with a null name, number of items, and probability fails.      */     @Test     public void constructor_np_noName() {         try {             new Shape(null, 5, 0.1);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that the constructor with a null name, probability, size of filter, and number of functions fails.      */     @Test     public void constructor_pmk_noName() {         try {             new Shape(null, 0.1, 72, 17);             fail("Should throw NullPointerException");         } catch (final NullPointerException expected) {             // do nothing         }     }      /**      * Tests that if the number of bits is less than 1 an exception is thrown      */     @Test     public void constructor_probability_bits_hash_BadNumberOfBitsTest() {         try {             new Shape(testFunction, 0.5, 0, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that if the number of functions is less than 1 an exception is thrown      */     @Test     public void constructor_probability_bits_hash_BadNumberOfHashFunctionsTest() {         try {             new Shape(testFunction, 0.5, 24, 0);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests that invalid probability values cause and IllegalArgumentException to be thrown.      */     @Test     public void constructor_probability_bits_hash_BadProbabilityTest() {         // probability should not be 0         try {             new Shape(testFunction, 0.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be = -1         try {             new Shape(testFunction, -1.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be < -1         try {             new Shape(testFunction, -1.5, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be = 1         try {             new Shape(testFunction, 1.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }          // probability should not be > 1         try {             new Shape(testFunction, 2.0, 24, 1);             fail("Should have thrown IllegalArgumentException");         } catch (final IllegalArgumentException expected) {             // expected         }     }      /**      * Tests the calculated values of calling the constructor with the probability, number of bits and number of hash      * functions.      */     @Test     public void constructor_probability_bits_hashTest() {         /*          * values from https://hur.st/bloomfilter/?n=5&p=.1&m=24&k=3          */         final Shape filterConfig = new Shape(testFunction, 0.1, 24, 3);          assertEquals(24, filterConfig.getNumberOfBits());         assertEquals(3, filterConfig.getNumberOfHashFunctions());         assertEquals(5, filterConfig.getNumberOfItems());         assertEquals(0.100375138, filterConfig.getProbability(), 0.000001);     }      /**      * Test equality of shape.      */     @Test     public void equalsTest() {          assertEquals(shape, shape);         assertEquals(shape, new Shape(testFunction, 5, 1.0 / 10));         assertNotEquals(shape, null);         assertNotEquals(shape, new Shape(testFunction, 5, 1.0 / 11));         assertNotEquals(shape, new Shape(testFunction, 4, 1.0 / 10));         // Number of bits does not change equality,         // only the number of bits and the number of hash functions         final int numberOfBits = 10000;         final int numberOfItems = 15;         final int numberOfHashFunctions = 4;         assertEquals(new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions),                      new Shape(testFunction, numberOfItems + 1, numberOfBits, numberOfHashFunctions));         assertNotEquals(new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions),                         new Shape(testFunction, numberOfItems, numberOfBits + 1, numberOfHashFunctions));         assertNotEquals(new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions),                         new Shape(testFunction, numberOfItems, numberOfBits, numberOfHashFunctions + 1));          final HashFunctionIdentity testFunction2 = new HashFunctionIdentity() {              @Override             public String getName() {                 return "Test Function2";             }              @Override             public ProcessType getProcessType() {                 return ProcessType.CYCLIC;             }              @Override             public String getProvider() {                 return "Apache Commons Collection Tests";             }              @Override             public long getSignature() {                 return 0;             }              @Override             public Signedness getSignedness() {                 return Signedness.SIGNED;             }         };          assertNotEquals(shape, new Shape(testFunction2, 4, 1.0 / 10));     }      /**      * Test that hashCode satisfies the contract between {@link Object#hashCode()} and      * {@link Object#equals(Object)}. Equal shapes must have the same hash code.      */     @Test     public void hashCodeTest() {         // Hash function equality is based on process type, signedness and name (case insensitive)         final ArrayList<HashFunctionIdentity> list = new ArrayList<>();         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         // Provider changes         list.add(new HashFunctionIdentityImpl("PROVIDER", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         list.add(new HashFunctionIdentityImpl("Provider2", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         // Name changes         list.add(new HashFunctionIdentityImpl("Provider", "name", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         list.add(new HashFunctionIdentityImpl("Provider", "NAME", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         list.add(new HashFunctionIdentityImpl("Provider", "Other", Signedness.SIGNED, ProcessType.ITERATIVE, 0L));         // Signedness changes         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.UNSIGNED, ProcessType.ITERATIVE, 0L));         // ProcessType changes         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.SIGNED, ProcessType.CYCLIC, 0L));         // Signature changes         list.add(new HashFunctionIdentityImpl("Provider", "Name", Signedness.SIGNED, ProcessType.ITERATIVE, 1L));          // Create shapes that only differ in the hash function.         final int numberOfItems = 30;         final int numberOfBits = 3000;         final int numberOfHashFunctions = 10;         final Shape shape1 = new Shape(list.get(0), numberOfItems, numberOfBits, numberOfHashFunctions);         assertEquals(shape1, shape1);          // Try variations         for (int i = 1; i < list.size(); i++) {             final Shape shape2 = new Shape(list.get(i), numberOfItems, numberOfBits, numberOfHashFunctions);             assertEquals(shape2, shape2);              // Equal shapes must have the same hash code             if (shape1.equals(shape2)) {                 assertEquals(shape1.hashCode(), shape2.hashCode());             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import org.junit.Assert; import org.junit.Test;  import java.util.ArrayList; import java.util.Random; import java.util.concurrent.ThreadLocalRandom;  /**  * Tests for the {@link BloomFilterIndexer}.  */ public class BloomFilterIndexerTest {      @Test(expected = IndexOutOfBoundsException.class)     public void testCheckPositiveThrows() {         BloomFilterIndexer.checkPositive(-1);     }      @Test     public void testGetLongIndex() {         Assert.assertEquals(0, BloomFilterIndexer.getLongIndex(0));          for (final int index : getIndexes()) {             // getLongIndex is expected to identify a block of 64-bits (starting from zero)             Assert.assertEquals(index / Long.SIZE, BloomFilterIndexer.getLongIndex(index));              // Verify the behavior for negatives. It should produce a negative (invalid)             // as a simple trip for incorrect usage.             Assert.assertTrue(BloomFilterIndexer.getLongIndex(-index) < 0);              // If index is not zero then when negated this is what a signed shift             // of 6-bits actually does             Assert.assertEquals(((1 - index) / Long.SIZE) - 1,                     BloomFilterIndexer.getLongIndex(-index));         }     }      @Test     public void testGetLongBit() {         Assert.assertEquals(1L, BloomFilterIndexer.getLongBit(0));          for (final int index : getIndexes()) {             // getLongBit is expected to identify a single bit in a 64-bit block             Assert.assertEquals(1L << (index % Long.SIZE), BloomFilterIndexer.getLongBit(index));              // Verify the behavior for negatives             Assert.assertEquals(1L << (64 - (index & 0x3f)), BloomFilterIndexer.getLongBit(-index));         }     }      /**      * Gets non-zero positive indexes for testing.      *      * @return the indices      */     private static int[] getIndexes() {         final Random rng = ThreadLocalRandom.current();         final ArrayList<Integer> indexes = new ArrayList<>(40);         for (int i = 0; i < 10; i++) {             // random positive numbers             indexes.add(rng.nextInt() >>> 1);             indexes.add(rng.nextInt(23647826));             indexes.add(rng.nextInt(245));         }         // Quickly remove zeros (as these cannot be negated)         indexes.removeIf(i -> i == 0);         // Add edge cases here         indexes.add(1);         indexes.add(2);         indexes.add(63);         indexes.add(64);         indexes.add(Integer.MAX_VALUE);         return indexes.stream().mapToInt(Integer::intValue).toArray();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bloomfilter;  import java.util.BitSet; import java.util.function.IntConsumer;  import org.apache.commons.collections4.bloomfilter.hasher.Hasher; import org.apache.commons.collections4.bloomfilter.hasher.Shape; import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher;  /**  * Test all the default implementations of the BloomFilter in {@link AbstractBloomFilter}.  */ public class DefaultBloomFilterMethodsTest extends AbstractBloomFilterTest {      /**      * A testing class that implements only the abstract methods from BloomFilter.      *      */     private static class BF extends AbstractBloomFilter {          /**          * The bits for this BloomFilter.          */         private final BitSet bitSet;          /**          * Constructs a BitSetBloomFilter from a hasher and a shape.          *          * @param hasher the Hasher to use.          * @param shape the desired shape of the filter.          */         BF(final Hasher hasher, final Shape shape) {             this(shape);             verifyHasher(hasher);             hasher.iterator(shape).forEachRemaining((IntConsumer) bitSet::set);         }          /**          * Constructs an empty BitSetBloomFilter.          *          * @param shape the desired shape of the filter.          */         BF(final Shape shape) {             super(shape);             this.bitSet = new BitSet();         }          @Override         public long[] getBits() {             return bitSet.toLongArray();         }          @Override         public StaticHasher getHasher() {             return new StaticHasher(bitSet.stream().iterator(), getShape());         }          @Override         public boolean merge(final BloomFilter other) {             verifyShape(other);             bitSet.or(BitSet.valueOf(other.getBits()));             return true;         }          @Override         public boolean merge(final Hasher hasher) {             verifyHasher(hasher);             hasher.iterator(getShape()).forEachRemaining((IntConsumer) bitSet::set);             return true;         }     }      @Override     protected AbstractBloomFilter createEmptyFilter(final Shape shape) {         return new BF(shape);     }      @Override     protected AbstractBloomFilter createFilter(final Hasher hasher, final Shape shape) {         return new BF(hasher, shape);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.io.IOException; import java.io.Serializable; import java.util.Date; import java.util.TimeZone;  import org.apache.commons.collections4.functors.ConstantFactory; import org.apache.commons.collections4.functors.ExceptionFactory; import org.junit.Test;  /**  * Tests the org.apache.commons.collections.FactoryUtils class.  *  * @since 3.0  */ public class FactoryUtilsTest {      // exceptionFactory     //------------------------------------------------------------------      @Test     public void testExceptionFactory() {         assertNotNull(FactoryUtils.exceptionFactory());         assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());         try {             FactoryUtils.exceptionFactory().create();         } catch (final FunctorException ex) {             try {                 FactoryUtils.exceptionFactory().create();             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // nullFactory     //------------------------------------------------------------------      @Test     public void testNullFactory() {         final Factory<Object> factory = FactoryUtils.nullFactory();         assertNotNull(factory);         final Object created = factory.create();         assertNull(created);     }      // constantFactory     //------------------------------------------------------------------      @Test     public void testConstantFactoryNull() {         final Factory<Object> factory = FactoryUtils.constantFactory(null);         assertNotNull(factory);         final Object created = factory.create();         assertNull(created);     }      @Test     public void testConstantFactoryConstant() {         final Integer constant = Integer.valueOf(9);         final Factory<Integer> factory = FactoryUtils.constantFactory(constant);         assertNotNull(factory);         final Integer created = factory.create();         assertSame(constant, created);     }      // prototypeFactory     //------------------------------------------------------------------      @Test     public void testPrototypeFactoryNull() {         assertSame(ConstantFactory.NULL_INSTANCE, FactoryUtils.prototypeFactory(null));     }      @Test     public void testPrototypeFactoryPublicCloneMethod() throws Exception {         final Date proto = new Date();         final Factory<Date> factory = FactoryUtils.prototypeFactory(proto);         assertNotNull(factory);         final Date created = factory.create();         assertNotSame(proto, created);         assertEquals(proto, created);     }      @Test     public void testPrototypeFactoryPublicCopyConstructor() throws Exception {         final Mock1 proto = new Mock1(6);         final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);         assertNotNull(factory);         final Object created = factory.create();         assertNotSame(proto, created);         assertEquals(proto, created);     }      @Test     public void testPrototypeFactoryPublicSerialization() throws Exception {         final Integer proto = 9;         final Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);         assertNotNull(factory);         final Integer created = factory.create();         assertNotSame(proto, created);         assertEquals(proto, created);     }      @Test     public void testPrototypeFactoryPublicSerializationError() {         final Mock2 proto = new Mock2(new Object());         final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);         assertNotNull(factory);         try {             factory.create();         } catch (final FunctorException ex) {             assertTrue(ex.getCause() instanceof IOException);             return;         }         fail();     }      @Test     public void testPrototypeFactoryPublicBad() {         final Object proto = new Object();         try {             FactoryUtils.prototypeFactory(proto);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      public static class Mock1 {         private final int iVal;         public Mock1(final int val) {             iVal = val;         }         public Mock1(final Mock1 mock) {             iVal = mock.iVal;         }         @Override         public boolean equals(final Object obj) {             if (obj instanceof Mock1) {                 if (iVal == ((Mock1) obj).iVal) {                     return true;                 }             }             return false;         }         @Override         public int hashCode() { // please Findbugs             return super.hashCode();         }     }      public static class Mock2 implements Serializable {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = 4899282162482588924L;         private final Object iVal;         public Mock2(final Object val) {             iVal = val;         }         @Override         public boolean equals(final Object obj) {             if (obj instanceof Mock2) {                 if (iVal == ((Mock2) obj).iVal) {                     return true;                 }             }             return false;         }         @Override         public int hashCode() { // please Findbugs             return super.hashCode();         }     }      public static class Mock3 {         private static int cCounter = 0;         private final int iVal;         public Mock3() {             iVal = cCounter++;         }         public int getValue() {             return iVal;         }     }      // instantiateFactory     //------------------------------------------------------------------      @Test(expected=NullPointerException.class)     public void instantiateFactoryNull() {         FactoryUtils.instantiateFactory(null);     }      @Test     public void instantiateFactorySimple() {         final Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);         assertNotNull(factory);         Mock3 created = factory.create();         assertEquals(0, created.getValue());         created = factory.create();         assertEquals(1, created.getValue());     }      @Test(expected=IllegalArgumentException.class)     public void instantiateFactoryMismatch() {         FactoryUtils.instantiateFactory(Date.class, null, new Object[] {null});     }      @Test(expected=IllegalArgumentException.class)     public void instantiateFactoryNoConstructor() {         FactoryUtils.instantiateFactory(Date.class, new Class[] {Long.class}, new Object[] {null});     }      @Test     public void instantiateFactoryComplex() {         TimeZone.setDefault(TimeZone.getTimeZone("GMT"));         // 2nd Jan 1970         final Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,             new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},             new Object[] {Integer.valueOf(70), Integer.valueOf(0), Integer.valueOf(2)});         assertNotNull(factory);         final Date created = factory.create();         // long time of 1 day (== 2nd Jan 1970)         assertEquals(new Date(1000 * 60 * 60 * 24), created);     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Factory singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionFactory.INSTANCE,         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization(                     "Singleton pattern broken for " + original.getClass(),                     original             );         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertSame;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;  public final class TestUtils {      private TestUtils() {}      /**      * Asserts that deserialization of the object returns the same object as the      * one that was serialized. Object is first serialized, then deserialized      * and finally check is performed to see if original and deserialized      * object references are the same.      * <p>      * This method is especially good for testing singleton pattern on classes      * that support serialization.      *      * @param msg the identifying message for the {@code AssertionError}.      * @param o object that will be tested.      * @see #assertSameAfterSerialization(Object)      */     public static void assertSameAfterSerialization(final String msg, final Object o) {         try {             // write object to byte buffer             final ByteArrayOutputStream baos = new ByteArrayOutputStream();             final ObjectOutputStream oos = new ObjectOutputStream(baos);             oos.writeObject(o);             oos.close();              // read same object from byte buffer             final InputStream is = new ByteArrayInputStream(baos.toByteArray());             final ObjectInputStream ois = new ObjectInputStream(is);             final Object object = ois.readObject();             ois.close();              // assert that original object and deserialized objects are the same             assertSame(msg, o, object);         } catch (final IOException e) {             // should never happen             throw new RuntimeException(e);         } catch (final ClassNotFoundException e) {             // should never happen             throw new RuntimeException(e);         }     }      /**      * Asserts that deserialization of the object returns the same object as the      * one that was serialized.      * <p>      * Effect of method call is the same as:      * {@code assertSameAfterSerialization(null, o)}.      *      * @param o object that will be tested.      * @see #assertSameAfterSerialization(String, Object)      */     public static void assertSameAfterSerialization(final Object o) {         assertSameAfterSerialization(null, o);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map;  import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.functors.ExceptionTransformer; import org.apache.commons.collections4.functors.FalsePredicate; import org.apache.commons.collections4.functors.NOPTransformer; import org.apache.commons.collections4.functors.StringValueTransformer; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests the TransformerUtils class.  *  * @since 3.0  */ public class TransformerUtilsTest {      private static final Object cObject = new Object();     private static final Object cString = "Hello";     private static final Object cInteger = Integer.valueOf(6);      // exceptionTransformer     //------------------------------------------------------------------      @Test     public void testExceptionTransformer() {         assertNotNull(TransformerUtils.exceptionTransformer());         assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer());         try {             TransformerUtils.exceptionTransformer().transform(null);         } catch (final FunctorException ex) {             try {                 TransformerUtils.exceptionTransformer().transform(cString);             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // nullTransformer     //------------------------------------------------------------------      @Test     public void testNullTransformer() {         assertNotNull(TransformerUtils.nullTransformer());         assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());         assertNull(TransformerUtils.nullTransformer().transform(null));         assertNull(TransformerUtils.nullTransformer().transform(cObject));         assertNull(TransformerUtils.nullTransformer().transform(cString));         assertNull(TransformerUtils.nullTransformer().transform(cInteger));     }      // nopTransformer     //------------------------------------------------------------------      @Test     public void testNopTransformer() {         assertNotNull(TransformerUtils.nullTransformer());         assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());         assertNull(TransformerUtils.nopTransformer().transform(null));         assertEquals(cObject, TransformerUtils.nopTransformer().transform(cObject));         assertEquals(cString, TransformerUtils.nopTransformer().transform(cString));         assertEquals(cInteger, TransformerUtils.nopTransformer().transform(cInteger));     }      // constantTransformer     //------------------------------------------------------------------      @Test     public void testConstantTransformer() {         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(null));         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cObject));         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cString));         assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cInteger));         assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.constantTransformer(null));     }      // cloneTransformer     //------------------------------------------------------------------      @Test     public void testCloneTransformer() {         assertNull(TransformerUtils.cloneTransformer().transform(null));         assertEquals(cString, TransformerUtils.cloneTransformer().transform(cString));         assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));         try {             assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject));         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      // mapTransformer     //------------------------------------------------------------------      @Test     @SuppressWarnings("boxing") // OK in test code     public void testMapTransformer() {         final Map<Object, Integer> map = new HashMap<>();         map.put(null, 0);         map.put(cObject, 1);         map.put(cString, 2);         assertEquals(Integer.valueOf(0), TransformerUtils.mapTransformer(map).transform(null));         assertEquals(Integer.valueOf(1), TransformerUtils.mapTransformer(map).transform(cObject));         assertEquals(Integer.valueOf(2), TransformerUtils.mapTransformer(map).transform(cString));         assertNull(TransformerUtils.mapTransformer(map).transform(cInteger));         assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.mapTransformer(null));     }      // commandTransformer     //------------------------------------------------------------------      @Test     public void testExecutorTransformer() {         assertNull(TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));         assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));         assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));         assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));         try {             TransformerUtils.asTransformer((Closure<Object>) null);         } catch (final NullPointerException ex) {             return;         }         fail();     }      // predicateTransformer     //------------------------------------------------------------------      @Test     public void testPredicateTransformer() {         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(null));         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cObject));         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cString));         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cInteger));         try {             TransformerUtils.asTransformer((Predicate<Object>) null);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      // factoryTransformer     //------------------------------------------------------------------      @Test     public void testFactoryTransformer() {         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(null));         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cObject));         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cString));         assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));         try {             TransformerUtils.asTransformer((Factory<Object>) null);         } catch (final NullPointerException ex) {             return;         }         fail();     }      // chainedTransformer     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testChainedTransformer() {         final Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer("A");         final Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) "B");          assertEquals("A", TransformerUtils.chainedTransformer(b, a).transform(null));         assertEquals("B", TransformerUtils.chainedTransformer(a, b).transform(null));         assertEquals("A", TransformerUtils.chainedTransformer(b, a).transform(null));         Collection<Transformer<Object, Object>> coll = new ArrayList<>();         coll.add(b);         coll.add(a);         assertEquals("A", TransformerUtils.chainedTransformer(coll).transform(null));          assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer());         assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(Collections.<Transformer<Object, Object>>emptyList()));          try {             TransformerUtils.chainedTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.chainedTransformer((Transformer[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.chainedTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             coll = new ArrayList<>();             coll.add(null);             coll.add(null);             TransformerUtils.chainedTransformer(coll);             fail();         } catch (final NullPointerException ex) {}     }      // ifTransformer     //------------------------------------------------------------------      @Test     public void testIfTransformer() {         final Transformer<Object, String> a = TransformerUtils.constantTransformer("A");         final Transformer<Object, String> b = TransformerUtils.constantTransformer("B");         final Transformer<Object, String> c = TransformerUtils.constantTransformer("C");          assertEquals("A", TransformerUtils.ifTransformer(TruePredicate.truePredicate(), a, b).transform(null));         assertEquals("B", TransformerUtils.ifTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));          final Predicate<Integer> lessThanFivePredicate = value -> value < 5;         // if/else tests         assertEquals("A", TransformerUtils.ifTransformer(lessThanFivePredicate, a, b).transform(1));         assertEquals("B", TransformerUtils.ifTransformer(lessThanFivePredicate, a, b).transform(5));          // if tests         final Predicate<String> equalsAPredicate = EqualPredicate.equalPredicate("A");         assertEquals("C", TransformerUtils.ifTransformer(equalsAPredicate, c).transform("A"));         assertEquals("B", TransformerUtils.ifTransformer(equalsAPredicate, c).transform("B"));          try {             TransformerUtils.ifTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.ifTransformer(TruePredicate.truePredicate(), null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.ifTransformer(null, ConstantTransformer.constantTransformer("A"));             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.ifTransformer(null, null, null);             fail();         } catch (final NullPointerException ex) {}     }      // switchTransformer     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testSwitchTransformer() {         final Transformer<String, String> a = TransformerUtils.constantTransformer("A");         final Transformer<String, String> b = TransformerUtils.constantTransformer("B");         final Transformer<String, String> c = TransformerUtils.constantTransformer("C");          assertEquals("A", TransformerUtils.switchTransformer(TruePredicate.truePredicate(), a, b).transform(null));         assertEquals("B", TransformerUtils.switchTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));          assertNull(TransformerUtils.<Object, String>switchTransformer(                 new Predicate[]{EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE")},                 new Transformer[]{a, b}).transform("WELL"));         assertEquals("A", TransformerUtils.switchTransformer(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Transformer[] { a, b }).transform("HELLO"));         assertEquals("B", TransformerUtils.switchTransformer(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Transformer[] { a, b }).transform("THERE"));          assertEquals("C", TransformerUtils.switchTransformer(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Transformer[] { a, b }, c).transform("WELL"));          Map<Predicate<String>, Transformer<String, String>> map = new HashMap<>();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         assertNull(TransformerUtils.switchTransformer(map).transform("WELL"));         assertEquals("A", TransformerUtils.switchTransformer(map).transform("HELLO"));         assertEquals("B", TransformerUtils.switchTransformer(map).transform("THERE"));         map.put(null, c);         assertEquals("C", TransformerUtils.switchTransformer(map).transform("WELL"));          assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]));         assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new HashMap<Predicate<Object>, Transformer<Object, Object>>()));         map = new HashMap<>();         map.put(null, null);         assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(map));          try {             TransformerUtils.switchTransformer(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(null, (Transformer[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.switchTransformer(                     new Predicate[] { TruePredicate.truePredicate() },                     new Transformer[] { a, b });             fail();         } catch (final IllegalArgumentException ex) {}     }      // switchMapTransformer     //------------------------------------------------------------------      @Test     public void testSwitchMapTransformer() {         final Transformer<String, String> a = TransformerUtils.constantTransformer("A");         final Transformer<String, String> b = TransformerUtils.constantTransformer("B");         final Transformer<String, String> c = TransformerUtils.constantTransformer("C");          Map<String, Transformer<String, String>> map = new HashMap<>();         map.put("HELLO", a);         map.put("THERE", b);         assertNull(TransformerUtils.switchMapTransformer(map).transform("WELL"));         assertEquals("A", TransformerUtils.switchMapTransformer(map).transform("HELLO"));         assertEquals("B", TransformerUtils.switchMapTransformer(map).transform("THERE"));         map.put(null, c);         assertEquals("C", TransformerUtils.switchMapTransformer(map).transform("WELL"));          assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(new HashMap<Object, Transformer<Object, Object>>()));         map = new HashMap<>();         map.put(null, null);         assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(map));          try {             TransformerUtils.switchMapTransformer(null);             fail();         } catch (final NullPointerException ex) {}     }      // invokerTransformer     //------------------------------------------------------------------      @Test     public void testInvokerTransformer() {         final List<Object> list = new ArrayList<>();         assertEquals(0, TransformerUtils.invokerTransformer("size").transform(list));         list.add(new Object());         assertEquals(1, TransformerUtils.invokerTransformer("size").transform(list));         assertNull(TransformerUtils.invokerTransformer("size").transform(null));          try {             TransformerUtils.invokerTransformer(null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.invokerTransformer("noSuchMethod").transform(new Object());             fail();         } catch (final FunctorException ex) {}     }      // invokerTransformer2     //------------------------------------------------------------------      @Test     public void testInvokerTransformer2() {         final List<Object> list = new ArrayList<>();         assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer("contains",                 new Class[] { Object.class }, new Object[] { cString }).transform(list));         list.add(cString);         assertEquals(Boolean.TRUE, TransformerUtils.invokerTransformer("contains",                 new Class[] { Object.class }, new Object[] { cString }).transform(list));         assertNull(TransformerUtils.invokerTransformer("contains",                 new Class[]{Object.class}, new Object[]{cString}).transform(null));          try {             TransformerUtils.invokerTransformer(null, null, null);             fail();         } catch (final NullPointerException ex) {}         try {             TransformerUtils.invokerTransformer("noSuchMethod", new Class[] { Object.class },                     new Object[] { cString }).transform(new Object());             fail();         } catch (final FunctorException ex) {}         try {             TransformerUtils.invokerTransformer("badArgs", null, new Object[] { cString });             fail();         } catch (final IllegalArgumentException ex) {}         try {             TransformerUtils.invokerTransformer("badArgs", new Class[] { Object.class }, null);             fail();         } catch (final IllegalArgumentException ex) {}         try {             TransformerUtils.invokerTransformer("badArgs", new Class[] {}, new Object[] { cString });             fail();         } catch (final IllegalArgumentException ex) {}     }      // stringValueTransformer     //------------------------------------------------------------------      @Test     public void testStringValueTransformer() {         assertNotNull( "StringValueTransformer should NEVER return a null value.",             TransformerUtils.stringValueTransformer().transform(null));         assertEquals( "StringValueTransformer should return \"null\" when given a null argument.", "null",             TransformerUtils.stringValueTransformer().transform(null));         assertEquals( "StringValueTransformer should return toString value", "6",             TransformerUtils.stringValueTransformer().transform(6));     }      // instantiateFactory     //------------------------------------------------------------------      @Test     public void testInstantiateTransformerNull() {         try {             TransformerUtils.instantiateTransformer(null, new Object[] { "str" });             fail();         } catch (final IllegalArgumentException ex) {}         try {             TransformerUtils.instantiateTransformer(new Class[] {}, new Object[] { "str" });             fail();         } catch (final IllegalArgumentException ex) {}          Transformer<Class<?>, Object> trans = TransformerUtils.instantiateTransformer(new Class[] { Long.class }, new Object[] { null });         try {             trans.transform(String.class);             fail();         } catch (final FunctorException ex) {}          trans = TransformerUtils.instantiateTransformer();         assertEquals("", trans.transform(String.class));          trans = TransformerUtils.instantiateTransformer(new Class[] { Long.TYPE }, new Object[] {1000L});         assertEquals(new Date(1000L), trans.transform(Date.class));     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Transformer singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionTransformer.INSTANCE,             NOPTransformer.INSTANCE,             StringValueTransformer.stringValueTransformer(),         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization("Singleton pattern broken for " + original.getClass(), original);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Comparator;  import org.junit.Test;  /**  * Tests ComparatorUtils.  *  */ public class ComparatorUtilsTest {     @Test     public void booleanComparator() {         Comparator<Boolean> comp = ComparatorUtils.booleanComparator(true);         assertTrue(comp.compare(Boolean.TRUE, Boolean.FALSE) < 0);         assertEquals(0, comp.compare(Boolean.TRUE, Boolean.TRUE));         assertTrue(comp.compare(Boolean.FALSE, Boolean.TRUE) > 0);          comp = ComparatorUtils.booleanComparator(false);         assertTrue(comp.compare(Boolean.TRUE, Boolean.FALSE) > 0);         assertEquals(0, comp.compare(Boolean.TRUE, Boolean.TRUE));         assertTrue(comp.compare(Boolean.FALSE, Boolean.TRUE) < 0);     }      @Test     public void chainedComparator() {         // simple test: chain 2 natural comparators         final Comparator<Integer> comp = ComparatorUtils.chainedComparator(ComparatorUtils.<Integer>naturalComparator(),                 ComparatorUtils.naturalComparator());         assertTrue(comp.compare(1, 2) < 0);         assertEquals(0, comp.compare(1, 1));         assertTrue(comp.compare(2, 1) > 0);     }      @Test     public void max() {         final Comparator<Integer> reversed =                 ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());          assertEquals(Integer.valueOf(10), ComparatorUtils.max(1, 10, null));         assertEquals(Integer.valueOf(10), ComparatorUtils.max(10, -10, null));          assertEquals(Integer.valueOf(1), ComparatorUtils.max(1, 10, reversed));         assertEquals(Integer.valueOf(-10), ComparatorUtils.max(10, -10, reversed));          try {             ComparatorUtils.max(1, null, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             ComparatorUtils.max(null, 10, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void min() {         final Comparator<Integer> reversed =                 ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());          assertEquals(Integer.valueOf(1), ComparatorUtils.min(1, 10, null));         assertEquals(Integer.valueOf(-10), ComparatorUtils.min(10, -10, null));          assertEquals(Integer.valueOf(10), ComparatorUtils.min(1, 10, reversed));         assertEquals(Integer.valueOf(10), ComparatorUtils.min(10, -10, reversed));          try {             ComparatorUtils.min(1, null, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             ComparatorUtils.min(null, 10, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void nullLowComparator() {         final Comparator<Integer> comp = ComparatorUtils.nullLowComparator(null);         assertTrue(comp.compare(null, 10) < 0);         assertEquals(0, comp.compare(null, null));         assertTrue(comp.compare(10, null) > 0);     }      @Test     public void nullHighComparator() {         final Comparator<Integer> comp = ComparatorUtils.nullHighComparator(null);         assertTrue(comp.compare(null, 10) > 0);         assertEquals(0, comp.compare(null, null));         assertTrue(comp.compare(10, null) < 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.List; import java.util.ListIterator; import java.util.Map; import java.util.HashMap; import java.util.Arrays; import java.util.ArrayList;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.ListValuedMap; import org.apache.commons.collections4.MultiValuedMap;  /**  * Test ArrayListValuedHashMap  *  * @since 4.1  */ public class ArrayListValuedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public ArrayListValuedHashMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ArrayListValuedHashMapTest.class);     }      // -----------------------------------------------------------------------     @Override     public ListValuedMap<K, V> makeObject() {         return new ArrayListValuedHashMap<>();     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testListValuedMapAdd() {         final ListValuedMap<K, V> listMap = makeObject();         assertTrue(listMap.get((K) "whatever") instanceof List);         final List<V> list = listMap.get((K) "A");         list.add((V) "a1");         assertEquals(1, listMap.size());         assertTrue(listMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testListValuedMapAddViaListIterator() {         final ListValuedMap<K, V> listMap = makeObject();         final ListIterator<V> listIt = listMap.get((K) "B").listIterator();         assertFalse(listIt.hasNext());         listIt.add((V) "b1");         listIt.add((V) "b2");         listIt.add((V) "b3");         assertEquals(3, listMap.size());         assertTrue(listMap.containsKey("B"));         // As ListIterator always adds before the current cursor         assertFalse(listIt.hasNext());     }      @SuppressWarnings("unchecked")     public void testListValuedMapRemove() {         final ListValuedMap<K, V> listMap = makeObject();         final List<V> list = listMap.get((K) "A");         list.add((V) "a1");         list.add((V) "a2");         list.add((V) "a3");         assertEquals(3, listMap.size());         assertEquals("a1", list.remove(0));         assertEquals(2, listMap.size());         assertEquals("a2", list.remove(0));         assertEquals(1, listMap.size());         assertEquals("a3", list.remove(0));         assertEquals(0, listMap.size());         assertFalse(listMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testListValuedMapRemoveViaListIterator() {         final ListValuedMap<K, V> listMap = makeObject();         ListIterator<V> listIt = listMap.get((K) "B").listIterator();         listIt.add((V) "b1");         listIt.add((V) "b2");         assertEquals(2, listMap.size());         assertTrue(listMap.containsKey("B"));         listIt = listMap.get((K) "B").listIterator();         while (listIt.hasNext()) {             listIt.next();             listIt.remove();         }         assertFalse(listMap.containsKey("B"));         listIt.add((V) "b1");         listIt.add((V) "b2");         assertTrue(listMap.containsKey("B"));         assertEquals(2, listMap.get((K) "B").size());     }      @SuppressWarnings({ "unchecked", "rawtypes" })     public void testEqualsHashCodeContract() {         final MultiValuedMap map1 = makeObject();         final MultiValuedMap map2 = makeObject();          map1.put("a", "a1");         map1.put("a", "a2");         map2.put("a", "a1");         map2.put("a", "a2");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map2.put("a", "a2");         assertNotSame(map1, map2);         assertNotSame(map1.hashCode(), map2.hashCode());     }      @SuppressWarnings({ "unchecked", "rawtypes" })     public void testListValuedMapEqualsHashCodeContract() {         final ListValuedMap map1 = makeObject();         final ListValuedMap map2 = makeObject();          map1.put("a", "a1");         map1.put("a", "a2");         map2.put("a", "a1");         map2.put("a", "a2");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map1.put("b", "b1");         map1.put("b", "b2");         map2.put("b", "b2");         map2.put("b", "b1");         assertNotSame(map1, map2);         assertNotSame(map1.hashCode(), map2.hashCode());     }      public void testArrayListValuedHashMap() {         ListValuedMap<K, V> listMap;         ListValuedMap<K, V> listMap1;         final Map<K, V> map = new HashMap<>();         final Map<K, V> map1 = new HashMap<>();         map.put((K) "A", (V) "W");         map.put((K) "B", (V) "X");         map.put((K) "C", (V) "F");          listMap = new ArrayListValuedHashMap<>(map);         assertEquals(1, listMap.get((K) "A").size());         assertEquals(1, listMap.get((K) "B").size());         assertEquals(1, listMap.get((K) "C").size());          listMap1 = new ArrayListValuedHashMap<>(map1);         assertEquals("{}", listMap1.toString());     }      public void testTrimToSize(){         final ArrayListValuedHashMap<K, V> listMap = new ArrayListValuedHashMap<>(4);          assertEquals("{}", listMap.toString());         listMap.put((K) "A", (V) "W");         listMap.put((K) "A", (V) "X");         listMap.put((K) "B", (V) "F");         assertEquals(2, listMap.get((K) "A").size());         assertEquals(1, listMap.get((K) "B").size());          listMap.trimToSize();         assertEquals(2, listMap.get((K) "A").size());         assertEquals(1, listMap.get((K) "B").size());     }      public void testWrappedListAdd() {         final ListValuedMap<K, V> listMap = makeObject();         final List<V> listA = listMap.get((K) "A");         listA.add(0, (V) "W");         listA.add(1, (V) "X");         listA.add(2, (V) "F");         assertEquals("{A=[W, X, F]}", listMap.toString());         listMap.get((K) "A").set(1, (V) "Q");         assertEquals("{A=[W, Q, F]}", listMap.toString());     }      public void testWrappedListAddAll() {         final ListValuedMap<K, V> listMap = makeObject();         final List<V> listA = listMap.get((K) "A");         final List<V> list = Arrays.asList((V) "W", (V) "X", (V) "F");         listA.addAll(0, list);         assertEquals("{A=[W, X, F]}", listMap.toString());          final List<V> list1 = Arrays.asList((V) "Q", (V) "Q", (V) "L");         listA.addAll(3, list1);         assertEquals("{A=[W, X, F, Q, Q, L]}", listMap.toString());         assertEquals("W", listMap.get((K) "A").get(0));         assertEquals("X", listMap.get((K) "A").get(1));         assertEquals("F", listMap.get((K) "A").get(2));         assertEquals("Q", listMap.get((K) "A").get(3));         assertEquals("Q", listMap.get((K) "A").get(4));         assertEquals("L", listMap.get((K) "A").get(5));         assertEquals(0, listMap.get((K) "A").indexOf("W"));         assertEquals(2, listMap.get((K) "A").indexOf("F"));         assertEquals(-1, listMap.get((K) "A").indexOf("C"));         assertEquals(3, listMap.get((K) "A").indexOf("Q"));         assertEquals(4, listMap.get((K) "A").lastIndexOf("Q"));         assertEquals(-1, listMap.get((K) "A").lastIndexOf("A"));          final List<V> list2 = new ArrayList<>();         listMap.get((K) "B").addAll(0, list2);         assertEquals("{A=[W, X, F, Q, Q, L]}", listMap.toString());         final List<V> list3 = listMap.get((K) "A").subList(1, 4);         assertEquals(3, list3.size());         assertEquals("Q", list3.get(2));     }      public void testValuesListIteratorMethods(){         final ListValuedMap<K, V> listMap = makeObject();         final List<V> listA = listMap.get((K) "A");         final List<V> list = Arrays.asList((V) "W", (V) "X", (V) "F", (V) "Q", (V) "Q", (V) "F");         listA.addAll(0, list);         final ListIterator<V> it = listMap.get((K) "A").listIterator(1);         assertTrue(it.hasNext());         assertEquals("X", it.next());         assertEquals("F", it.next());         assertTrue(it.hasPrevious());         assertEquals("F", it.previous());         assertEquals(2, it.nextIndex());         assertEquals(1, it.previousIndex());         it.set((V) "Z");         assertEquals("Z", it.next());         assertEquals("Q", it.next());     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/ArrayListValuedHashMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/ArrayListValuedHashMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.SetValuedMap; import org.apache.commons.collections4.bag.AbstractBagTest; import org.apache.commons.collections4.bag.HashBag; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.map.AbstractMapTest; import org.apache.commons.collections4.multiset.AbstractMultiSetTest; import org.apache.commons.collections4.set.AbstractSetTest;  /**  * Abstract test class for {@link MultiValuedMap} contract and methods.  * <p>  * To use, extend this class and implement the {@link #makeObject} method and if  * necessary override the {@link #makeFullMap()} method.  *  * @since 4.1  */ public abstract class AbstractMultiValuedMapTest<K, V> extends AbstractObjectTest {      /** Map created by reset(). */     protected MultiValuedMap<K, V> map;      /** MultiValuedHashMap created by reset(). */     protected MultiValuedMap<K, V> confirmed;      public AbstractMultiValuedMapTest(final String testName) {         super(testName);     }      @Override     public abstract MultiValuedMap<K, V> makeObject();      @Override     public String getCompatibilityVersion() {         return "4.1"; // MultiValuedMap has been added in version 4.1     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} support the {@code put} and      * {@code putAll} operations adding new mappings.      * <p>      * Default implementation returns true. Override if your collection class      * does not support put adding.      */     public boolean isAddSupported() {         return true;     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} support the {@code remove} and      * {@code clear} operations.      * <p>      * Default implementation returns true. Override if your collection class      * does not support removal operations.      */     public boolean isRemoveSupported() {         return true;     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} supports null keys.      * <p>      * Default implementation returns true. Override if your collection class      * does not support null keys.      */     public boolean isAllowNullKey() {         return true;     }      /**      * Returns true if the maps produced by {@link #makeObject()} and      * {@link #makeFullMap()} supports set value.      * <p>      * Default implementation returns false. Override if your collection class      * supports set value.      */     public boolean isHashSetValue() {         return false;     }      @Override     public boolean isTestSerialization() {         return true;     }      /**      * Returns the set of keys in the mappings used to test the map. This method      * must return an array with the same length as {@link #getSampleValues()}      * and all array elements must be different. The default implementation      * constructs a set of String keys, and includes a single null key if      * {@link #isAllowNullKey()} returns {@code true}.      */     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         final Object[] result = new Object[] {             "one", "one", "two", "two",             "three", "three"         };         return (K[]) result;     }      /**      * Returns the set of values in the mappings used to test the map. This      * method must return an array with the same length as      * {@link #getSampleKeys()}. The default implementation constructs a set of      * String values      */     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         final Object[] result = new Object[] {             "uno", "un", "dos", "deux",             "tres", "trois"         };         return (V[]) result;     }      protected MultiValuedMap<K, V> makeFullMap() {         final MultiValuedMap<K, V> map = makeObject();         addSampleMappings(map);         return map;     }      protected void addSampleMappings(final MultiValuedMap<? super K, ? super V> map) {         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         for (int i = 0; i < keys.length; i++) {             map.put(keys[i], values[i]);         }     }      /**      * Override to return a MultiValuedMap other than ArrayListValuedHashMap      * as the confirmed map.      *      * @return a MultiValuedMap that is known to be valid      */     public MultiValuedMap<K, V> makeConfirmedMap() {         return new ArrayListValuedHashMap<>();     }      public MultiValuedMap<K, V> getConfirmed() {         return this.confirmed;     }      public void setConfirmed(final MultiValuedMap<K, V> map) {         this.confirmed = map;     }      public MultiValuedMap<K, V> getMap() {         return this.map;     }      /**      * Resets the {@link #map} and {@link #confirmed} fields to empty.      */     public void resetEmpty() {         this.map = makeObject();         this.confirmed = makeConfirmedMap();     }      /**      * Resets the {@link #map} and {@link #confirmed} fields to full.      */     public void resetFull() {         this.map = makeFullMap();         this.confirmed = makeConfirmedMap();         final K[] k = getSampleKeys();         final V[] v = getSampleValues();         for (int i = 0; i < k.length; i++) {             confirmed.put(k[i], v[i]);         }     }      @SuppressWarnings("unchecked")     public void testNoMappingReturnsEmptyCol() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.get((K) "whatever").isEmpty());     }      public void testMultipleValues() {         final MultiValuedMap<K, V> map = makeFullMap();         @SuppressWarnings("unchecked")         final Collection<V> col = map.get((K) "one");         assertTrue(col.contains("uno"));         assertTrue(col.contains("un"));     }      @SuppressWarnings("unchecked")     public void testGet() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.get((K) "one").contains("uno"));         assertTrue(map.get((K) "one").contains("un"));         assertTrue(map.get((K) "two").contains("dos"));         assertTrue(map.get((K) "two").contains("deux"));         assertTrue(map.get((K) "three").contains("tres"));         assertTrue(map.get((K) "three").contains("trois"));     }      @SuppressWarnings("unchecked")     public void testAddMappingThroughGet(){         if (!isAddSupported()) {             return;         }         resetEmpty();         final MultiValuedMap<K, V> map =  getMap();         final Collection<V> col1 = map.get((K) "one");         final Collection<V> col2 = map.get((K) "one");         assertTrue(col1.isEmpty());         assertTrue(col2.isEmpty());         assertEquals(0, map.size());         col1.add((V) "uno");         col2.add((V) "un");         assertTrue(map.containsKey("one"));         assertTrue(map.containsMapping("one", "uno"));         assertTrue(map.containsMapping("one", "un"));         assertTrue(map.containsValue("uno"));         assertTrue(map.containsValue("un"));         assertTrue(col1.contains("un"));         assertTrue(col2.contains("uno"));     }      public void testRemoveMappingThroughGet() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final MultiValuedMap<K, V> map = getMap();         @SuppressWarnings("unchecked")         Collection<V> col = map.get((K) "one");         assertEquals(2, col.size());         assertEquals(6, map.size());         col.remove("uno");         col.remove("un");         assertFalse(map.containsKey("one"));         assertFalse(map.containsMapping("one", "uno"));         assertFalse(map.containsMapping("one", "un"));         assertFalse(map.containsValue("uno"));         assertFalse(map.containsValue("un"));         assertEquals(4, map.size());         col = map.remove("one");         assertNotNull(col);         assertEquals(0, col.size());     }      public void testRemoveMappingThroughGetIterator() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final MultiValuedMap<K, V> map = getMap();         @SuppressWarnings("unchecked")         final Iterator<V> it = map.get((K) "one").iterator();         while (it.hasNext()) {             it.next();             it.remove();         }         assertFalse(map.containsKey("one"));         assertFalse(map.containsMapping("one", "uno"));         assertFalse(map.containsMapping("one", "un"));         assertFalse(map.containsValue("uno"));         assertFalse(map.containsValue("un"));         assertEquals(4, map.size());         final Collection<V> coll = map.remove("one");         assertNotNull(coll);         assertEquals(0, coll.size());     }      public void testContainsValue() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.containsValue("uno"));         assertTrue(map.containsValue("un"));         assertTrue(map.containsValue("dos"));         assertTrue(map.containsValue("deux"));         assertTrue(map.containsValue("tres"));         assertTrue(map.containsValue("trois"));         assertFalse(map.containsValue("quatro"));     }      public void testKeyContainsValue() {         final MultiValuedMap<K, V> map = makeFullMap();         assertTrue(map.containsMapping("one", "uno"));         assertTrue(map.containsMapping("one", "un"));         assertTrue(map.containsMapping("two", "dos"));         assertTrue(map.containsMapping("two", "deux"));         assertTrue(map.containsMapping("three", "tres"));         assertTrue(map.containsMapping("three", "trois"));         assertFalse(map.containsMapping("four", "quatro"));     }      @SuppressWarnings("unchecked")     public void testValues() {         final MultiValuedMap<K, V> map = makeFullMap();         final HashSet<V> expected = new HashSet<>();         expected.add((V) "uno");         expected.add((V) "dos");         expected.add((V) "tres");         expected.add((V) "un");         expected.add((V) "deux");         expected.add((V) "trois");         final Collection<V> c = map.values();         assertEquals(6, c.size());         assertEquals(expected, new HashSet<>(c));     }  //    public void testKeyedIterator() { //        final MultiValuedMap<K, V> map = makeFullMap(); //        final ArrayList<Object> actual = new ArrayList<Object>(IteratorUtils.toList(map.iterator("one"))); //        final ArrayList<Object> expected = new ArrayList<Object>(Arrays.asList("uno", "un")); //        assertEquals(expected, actual); //    }      @SuppressWarnings("unchecked")     public void testRemoveAllViaValuesIterator() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertTrue(map.get((K) "one").isEmpty());         assertTrue(map.isEmpty());     }      public void testRemoveViaValuesRemove() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         final Collection<V> values = map.values();         values.remove("uno");         values.remove("un");         assertFalse(map.containsKey("one"));         assertEquals(4, map.size());     }      /*public void testRemoveViaGetCollectionRemove() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         Collection<V> values = map.get("one");         values.remove("uno");         values.remove("un");         assertFalse(map.containsKey("one"));         assertEquals(4, map.size());     }*/  //    public void testRemoveAllViaKeyedIterator() { //        if (!isRemoveSupported()) { //            return; //        } //        final MultiValuedMap<K, V> map = makeFullMap(); //        for (final Iterator<?> i = map.iterator("one"); i.hasNext();) { //            i.next(); //            i.remove(); //        } //        assertNull(map.get("one")); //        assertEquals(4, map.size()); //    }      public void testEntriesCollectionIterator() {         final MultiValuedMap<K, V> map = makeFullMap();         final Collection<V> values = new ArrayList<>(map.values());         final Iterator<Map.Entry<K, V>> iterator = map.entries().iterator();         while (iterator.hasNext()) {             final Map.Entry<K, V> entry = iterator.next();             assertTrue(map.containsMapping(entry.getKey(), entry.getValue()));             assertTrue(values.contains(entry.getValue()));             if (isRemoveSupported()) {                 assertTrue(values.remove(entry.getValue()));             }         }         if (isRemoveSupported()) {             assertTrue(values.isEmpty());         }     }      @SuppressWarnings("unchecked")     public void testRemoveAllViaEntriesIterator() {         if (!isRemoveSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeFullMap();         for (final Iterator<?> i = map.entries().iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertTrue(map.get((K) "one").isEmpty());         assertEquals(0, map.size());     }      public void testSize() {         assertEquals(6, makeFullMap().size());     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMapEquals() {         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> one = makeObject();         final Integer value = Integer.valueOf(1);         one.put((K) "One", (V) value);         one.removeMapping("One", value);          final MultiValuedMap<K, V> two = makeObject();         assertEquals(two, one);     }      @SuppressWarnings("unchecked")     public void testSizeWithPutRemove() {         if (!isRemoveSupported() || !isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         assertEquals(0, map.size());         map.put((K) "A", (V) "AA");         assertEquals(1, map.size());         map.put((K) "B", (V) "BA");         assertEquals(2, map.size());         map.put((K) "B", (V) "BB");         assertEquals(3, map.size());         map.put((K) "B", (V) "BC");         assertEquals(4, map.size());         map.remove("A");         assertEquals(3, map.size());         map.removeMapping("B", "BC");         assertEquals(2, map.size());     }      public void testKeySetSize() {         final MultiValuedMap<K, V> map = makeFullMap();         assertEquals(3, map.keySet().size());     }      @SuppressWarnings("unchecked")     public void testSize_Key() {         final MultiValuedMap<K, V> map = makeFullMap();         assertEquals(2, map.get((K) "one").size());         assertEquals(2, map.get((K) "two").size());         assertEquals(2, map.get((K) "three").size());         if (!isAddSupported()) {             return;         }         map.put((K) "A", (V) "AA");         assertEquals(1, map.get((K) "A").size());         //assertEquals(0, map.get("B").size());         map.put((K) "B", (V) "BA");         assertEquals(1, map.get((K) "A").size());         assertEquals(1, map.get((K) "B").size());         map.put((K) "B", (V) "BB");         assertEquals(1, map.get((K) "A").size());         assertEquals(2, map.get((K) "B").size());         map.put((K) "B", (V) "BC");         assertEquals(1, map.get((K) "A").size());         assertEquals(3, map.get((K) "B").size());         if (!isRemoveSupported()) {             return;         }         map.remove("A");         //assertEquals(0, map.get("A").size());         assertEquals(3, map.get((K) "B").size());         map.removeMapping("B", "BC");         //assertEquals(0, map.get("A").size());         assertEquals(2, map.get((K) "B").size());     }  //    @SuppressWarnings("unchecked") //    public void testIterator_Key() { //        final MultiValuedMap<K, V> map = makeFullMap(); //        Iterator<V> it = map.iterator("one"); //        assertEquals(true, it.hasNext()); //        Set<V> values = new HashSet<V>(); //        while (it.hasNext()) { //            values.add(it.next()); //        } //        assertEquals(true, values.contains("un")); //        assertEquals(true, values.contains("uno")); //        assertEquals(false, map.iterator("A").hasNext()); //        assertEquals(false, map.iterator("A").hasNext()); //        if (!isAddSupported()) { //            return; //        } //        map.put((K) "A", (V) "AA"); //        it = map.iterator("A"); //        assertEquals(true, it.hasNext()); //        it.next(); //        assertEquals(false, it.hasNext()); //    }      @SuppressWarnings("unchecked")     public void testContainsValue_Key() {         final MultiValuedMap<K, V> map = makeFullMap();         assertEquals(true, map.containsMapping("one", "uno"));         assertEquals(false, map.containsMapping("two", "2"));         if (!isAddSupported()) {             return;         }         map.put((K) "A", (V) "AA");         assertEquals(true, map.containsMapping("A", "AA"));         assertEquals(false, map.containsMapping("A", "AB"));     }      @SuppressWarnings("unchecked")     public void testPutAll_Map1() {         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> original = makeObject();         original.put((K) "key", (V) "object1");         original.put((K) "key", (V) "object2");          final MultiValuedMap<K, V> test = makeObject();         test.put((K) "keyA", (V) "objectA");         test.put((K) "key", (V) "object0");         test.putAll(original);          try {             final MultiValuedMap<K, V> originalNull = null;             test.putAll(originalNull);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          assertEquals(2, test.keySet().size());         assertEquals(4, test.size());         assertEquals(1, test.get((K) "keyA").size());         assertEquals(3, test.get((K) "key").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_Map2() {         if (!isAddSupported()) {             return;         }         final Map<K, V> original = new HashMap<>();         original.put((K) "keyX", (V) "object1");         original.put((K) "keyY", (V) "object2");          final MultiValuedMap<K, V> test = makeObject();         test.put((K) "keyA", (V) "objectA");         test.put((K) "keyX", (V) "object0");         test.putAll(original);          try {             final Map<K, V> originalNull = null;             test.putAll(originalNull);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          assertEquals(3, test.keySet().size());         assertEquals(4, test.size());         assertEquals(1, test.get((K) "keyA").size());         assertEquals(2, test.get((K) "keyX").size());         assertEquals(1, test.get((K) "keyY").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_KeyIterable() {         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         Collection<V> coll = (Collection<V>) Arrays.asList("X", "Y", "Z");          assertEquals(true, map.putAll((K) "A", coll));         assertEquals(3, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));          try {             map.putAll((K) "A", null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          assertEquals(3, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));          assertEquals(false, map.putAll((K) "A", new ArrayList<V>()));         assertEquals(3, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));          coll = (Collection<V>) Arrays.asList("M");         assertEquals(true, map.putAll((K) "A", coll));         assertEquals(4, map.get((K) "A").size());         assertEquals(true, map.containsMapping("A", "X"));         assertEquals(true, map.containsMapping("A", "Y"));         assertEquals(true, map.containsMapping("A", "Z"));         assertEquals(true, map.containsMapping("A", "M"));     }      @SuppressWarnings("unchecked")     public void testRemove_KeyItem() {         if (!isRemoveSupported() || !isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         map.put((K) "A", (V) "AA");         map.put((K) "A", (V) "AB");         map.put((K) "A", (V) "AC");         assertEquals(false, map.removeMapping("C", "CA"));         assertEquals(false, map.removeMapping("A", "AD"));         assertEquals(true, map.removeMapping("A", "AC"));         assertEquals(true, map.removeMapping("A", "AB"));         assertEquals(true, map.removeMapping("A", "AA"));         //assertEquals(new MultiValuedHashMap<K, V>(), map);     }      public void testToString(){         if (!isAddSupported()) {             return;         }         final MultiValuedMap<K, V> map = makeObject();         map.put((K) "A", (V) "X");         map.put((K) "A", (V) "Y");         map.put((K) "A", (V) "Z");         map.put((K) "B", (V) "U");         map.put((K) "B", (V) "V");         map.put((K) "B", (V) "W");         assertTrue(             "{A=[X, Y, Z], B=[U, V, W]}".equals(map.toString()) ||             "{B=[U, V, W], A=[X, Y, Z]}".equals(map.toString())         );          try {             final MultiValuedMap<K, V> originalNull = null;             map.putAll(originalNull);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }         assertTrue(             "{A=[X, Y, Z], B=[U, V, W]}".equals(map.toString()) ||             "{B=[U, V, W], A=[X, Y, Z]}".equals(map.toString())         );          map.remove("A");         map.remove("B");         assertEquals("{}", map.toString());     }      public void testKeysMultiSet() {         final MultiValuedMap<K, V> map = makeFullMap();         final MultiSet<K> keyMultiSet = map.keys();         assertEquals(2, keyMultiSet.getCount("one"));         assertEquals(2, keyMultiSet.getCount("two"));         assertEquals(2, keyMultiSet.getCount("three"));         assertEquals(0, keyMultiSet.getCount("conut"));         assertEquals(6, keyMultiSet.size());     }      public void testKeysBagIterator() {         final MultiValuedMap<K, V> map = makeFullMap();         final Collection<K> col = new ArrayList<>();         final Iterator<K> it = map.keys().iterator();         while (it.hasNext()) {             col.add(it.next());         }         final Bag<K> bag = new HashBag<>(col);         assertEquals(2, bag.getCount("one"));         assertEquals(2, bag.getCount("two"));         assertEquals(2, bag.getCount("three"));         assertEquals(6, bag.size());     }      @SuppressWarnings("unchecked")     public void testKeysBagContainsAll() {         final MultiValuedMap<K, V> map = makeFullMap();         final MultiSet<K> keyMultiSet = map.keys();         final Collection<K> col = (Collection<K>) Arrays.asList("one", "two", "three", "one", "two", "three");         assertTrue(keyMultiSet.containsAll(col));     }      public void testAsMapGet() {         resetEmpty();         Map<K, Collection<V>> mapCol = getMap().asMap();         assertNull(mapCol.get("one"));         assertEquals(0, mapCol.size());          resetFull();         mapCol = getMap().asMap();         final Collection<V> col = mapCol.get("one");         assertNotNull(col);         assertTrue(col.contains("un"));         assertTrue(col.contains("uno"));     }      public void testAsMapRemove() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final Map<K, Collection<V>> mapCol = getMap().asMap();         mapCol.remove("one");         assertFalse(getMap().containsKey("one"));         assertEquals(4, getMap().size());     }      public void testMapIterator() {         resetEmpty();         MapIterator<K, V> mapIt  = getMap().mapIterator();         assertFalse(mapIt.hasNext());          resetFull();         mapIt = getMap().mapIterator();         while (mapIt.hasNext()) {             final K key = mapIt.next();             final V value = mapIt.getValue();             assertTrue(getMap().containsMapping(key, value));         }     }      public void testMapIteratorRemove() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final MapIterator<K, V> mapIt = getMap().mapIterator();         while (mapIt.hasNext()) {             mapIt.next();             mapIt.remove();         }         assertTrue(getMap().isEmpty());     }      @SuppressWarnings("unchecked")     public void testMapIteratorUnsupportedSet() {         resetFull();         final MapIterator<K, V> mapIt = getMap().mapIterator();         mapIt.next();         try {             mapIt.setValue((V) "some value");             fail();         } catch (final UnsupportedOperationException e) {         }     }      public void testMultiValuedMapIterator() {         final MultiValuedMap<K, V> map = makeFullMap();         final MapIterator<K, V> it = map.mapIterator();          try {             it.getKey();             fail();         } catch (final IllegalStateException ise) {         }         try {             it.getValue();             fail();         } catch (final IllegalStateException ise) {         }         if (isAddSupported()) {             try {                 it.setValue((V) "V");                 fail();             } catch (final IllegalStateException ise) {             }         }          if (!isHashSetValue() && isAddSupported()) {             assertTrue(it.hasNext() );             assertEquals("one", it.next());             assertEquals("one", it.getKey());             assertEquals("uno", it.getValue());             assertEquals("one", it.next());             assertEquals("one", it.getKey());             assertEquals("un", it.getValue());             assertEquals("two", it.next());             assertEquals("two", it.getKey());             assertEquals("dos", it.getValue());             assertEquals("two", it.next());             assertEquals("two", it.getKey());             assertEquals("deux", it.getValue());             assertEquals("three", it.next());             assertEquals("three", it.getKey());             assertEquals("tres", it.getValue());             assertEquals("three", it.next());             assertEquals("three", it.getKey());             assertEquals("trois", it.getValue());             try {                 it.setValue((V) "threetrois");                 fail();             } catch (final UnsupportedOperationException e) {             }         }     }      // -----------------------------------------------------------------------     // Manual serialization testing as this class cannot easily     // extend the AbstractTestMap     // -----------------------------------------------------------------------      public void testEmptyMapCompatibility() throws Exception {         final MultiValuedMap<?, ?> map = makeObject();         final MultiValuedMap<?, ?> map2 =                 (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));         assertEquals("Map is empty", 0, map2.size());     }      @SuppressWarnings({ "rawtypes", "unchecked" })     public void testFullMapCompatibility() throws Exception {         final MultiValuedMap map = makeFullMap();         final MultiValuedMap map2 =                 (MultiValuedMap) readExternalFormFromDisk(getCanonicalFullCollectionName(map));         assertEquals("Map is the right size", map.size(), map2.size());         for (final Object key : map.keySet()) {             assertTrue("Map had inequal elements",                        CollectionUtils.isEqualCollection(map.get(key), map2.get(key)));             if (isRemoveSupported()) {                 map2.remove(key);             }         }         if (isRemoveSupported()) {             assertEquals("Map had extra values", 0, map2.size());         }     }      // Bulk Tests     /**      * Bulk test {@link MultiValuedMap#entries()}. This method runs through all      * of the tests in {@link AbstractCollectionTest}. After modification      * operations, {@link #verify()} is invoked to ensure that the map and the      * other collection views are still valid.      *      * @return a {@link AbstractCollectionTest} instance for testing the map's      *         values collection      */     public BulkTest bulkTestMultiValuedMapEntries() {         return new TestMultiValuedMapEntries();     }      public class TestMultiValuedMapEntries extends AbstractCollectionTest<Entry<K, V>> {         public TestMultiValuedMapEntries() {             super("");         }          @SuppressWarnings("unchecked")         @Override         public Entry<K, V>[] getFullElements() {             return makeFullMap().entries().toArray(new Entry[0]);         }          @Override         public Collection<Entry<K, V>> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().entries();         }          @Override         public Collection<Entry<K, V>> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().entries();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             // Add not supported in entries view             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMultiValuedMapTest.this.resetFull();             setCollection(AbstractMultiValuedMapTest.this.getMap().entries());             TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());         }          @Override         public void resetEmpty() {             AbstractMultiValuedMapTest.this.resetEmpty();             setCollection(AbstractMultiValuedMapTest.this.getMap().entries());             TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());         }          @Override         public Collection<Entry<K, V>> makeConfirmedCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public Collection<Entry<K, V>> makeConfirmedFullCollection() {             // never gets called, reset methods are overridden             return null;         }      }      /**      * Bulk test {@link MultiValuedMap#keySet()}. This method runs through all      * of the tests in {@link AbstractSetTest}. After modification operations,      * {@link #verify()} is invoked to ensure that the map and the other      * collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the map's key set      */     public BulkTest bulkTestMultiValuedMapKeySet() {         return new TestMultiValuedMapKeySet();     }      public class TestMultiValuedMapKeySet extends AbstractSetTest<K> {         public TestMultiValuedMapKeySet() {             super("");         }          @SuppressWarnings("unchecked")         @Override         public K[] getFullElements() {             return (K[]) AbstractMultiValuedMapTest.this.makeFullMap().keySet().toArray();         }          @Override         public Set<K> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().keySet();         }          @Override         public Set<K> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().keySet();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }      }      /**      * Bulk test {@link MultiValuedMap#values()}. This method runs through all      * of the tests in {@link AbstractCollectionTest}. After modification      * operations, {@link #verify()} is invoked to ensure that the map and the      * other collection views are still valid.      *      * @return a {@link AbstractCollectionTest} instance for testing the map's      *         values collection      */     public BulkTest bulkTestMultiValuedMapValues() {         return new TestMultiValuedMapValues();     }      public class TestMultiValuedMapValues extends AbstractCollectionTest<V> {         public TestMultiValuedMapValues() {             super("");         }          @Override         public V[] getFullElements() {             return getSampleValues();         }          @Override         public Collection<V> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().values();         }          @Override         public Collection<V> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().values();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMultiValuedMapTest.this.resetFull();             setCollection(AbstractMultiValuedMapTest.this.getMap().values());             TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());         }          @Override         public void resetEmpty() {             AbstractMultiValuedMapTest.this.resetEmpty();             setCollection(AbstractMultiValuedMapTest.this.getMap().values());             TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());         }          @Override         public Collection<V> makeConfirmedCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public Collection<V> makeConfirmedFullCollection() {             // never gets called, reset methods are overridden             return null;         }      }      /**      * Bulk test {@link MultiValuedMap#keys()}. This method runs through all of      * the tests in {@link AbstractBagTest}. After modification operations,      * {@link #verify()} is invoked to ensure that the map and the other      * collection views are still valid.      *      * @return a {@link AbstractBagTest} instance for testing the map's values      *         collection      */     public BulkTest bulkTestMultiValuedMapKeys() {         return new TestMultiValuedMapKeys();     }      public class TestMultiValuedMapKeys extends AbstractMultiSetTest<K> {          public TestMultiValuedMapKeys() {             super("");         }          @Override         public K[] getFullElements() {             return getSampleKeys();         }          @Override         public MultiSet<K> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().keys();         }          @Override         public MultiSet<K> makeFullCollection() {             return AbstractMultiValuedMapTest.this.makeFullMap().keys();         }          @Override         public boolean isNullSupported() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return false;         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMultiValuedMapTest.this.resetFull();             setCollection(AbstractMultiValuedMapTest.this.getMap().keys());             TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());         }          @Override         public void resetEmpty() {             AbstractMultiValuedMapTest.this.resetEmpty();             setCollection(AbstractMultiValuedMapTest.this.getMap().keys());             TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());         }      }      public BulkTest bulkTestAsMap() {         return new TestMultiValuedMapAsMap();     }      public class TestMultiValuedMapAsMap extends AbstractMapTest<K, Collection<V>> {          public TestMultiValuedMapAsMap() {             super("");         }          @Override         public Map<K, Collection<V>> makeObject() {             return AbstractMultiValuedMapTest.this.makeObject().asMap();         }          @Override         public Map<K, Collection<V>> makeFullMap() {             return AbstractMultiValuedMapTest.this.makeFullMap().asMap();         }          @Override         @SuppressWarnings("unchecked")         public K[] getSampleKeys() {             final K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();             final Object[] finalKeys = new Object[3];             for (int i = 0; i < 3; i++) {                 finalKeys[i] = samplekeys[i * 2];             }             return (K[]) finalKeys;         }          @Override         @SuppressWarnings("unchecked")         public Collection<V>[] getSampleValues() {             // Calling getMap() instead of makeObject() would make more sense, but due to concurrency             // issues, this may lead to intermittent issues. See COLLECTIONS-661. A better solution             // would be to re-design the tests, or add a boolean method to the parent.             final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;             final V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();             final Collection<V>[] colArr = new Collection[3];             for (int i = 0; i < 3; i++) {                 final Collection<V> coll = Arrays.asList(sampleValues[i*2], sampleValues[i*2 + 1]);                 colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;             }             return colArr;         }          @Override         @SuppressWarnings("unchecked")         public Collection<V>[] getNewSampleValues() {             // See comment in getSampleValues() to understand why we are calling makeObject() and not             // getMap(). See COLLECTIONS-661 for more.             final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;             final Object[] sampleValues = { "ein", "ek", "zwei", "duey", "drei", "teen" };             final Collection<V>[] colArr = new Collection[3];             for (int i = 0; i < 3; i++) {                 final Collection<V> coll = Arrays.asList((V) sampleValues[i * 2], (V) sampleValues[i * 2 + 1]);                 colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;             }             return colArr;         }          @Override         public boolean isAllowNullKey() {             return AbstractMultiValuedMapTest.this.isAllowNullKey();         }          @Override         public boolean isPutAddSupported() {             return false;         }          @Override         public boolean isPutChangeSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiValuedMapTest.this.isRemoveSupported();         }          @Override         public boolean areEqualElementsDistinguishable() {             // work-around for a problem with the EntrySet: the entries contain             // the wrapped collection, which will be automatically cleared             // when the associated key is removed from the map as the collection             // is not cached atm.             return true;         }          @Override         public boolean isTestSerialization() {             return false;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.Collection;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Tests for TransformedMultiValuedMap  *  * @since 4.1  */ public class TransformedMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public TransformedMultiValuedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedMultiValuedMapTest.class);     }      // -----------------------------------------------------------------------     @Override     public MultiValuedMap<K, V> makeObject() {         return TransformedMultiValuedMap.transformingMap(new ArrayListValuedHashMap<K, V>(),                 TransformerUtils.<K>nopTransformer(), TransformerUtils.<V>nopTransformer());     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testKeyTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          final MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(                 new ArrayListValuedHashMap<K, V>(),                 (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,                 null);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsKey(els[i]));             assertEquals(true, map.containsValue(els[i]));             assertEquals(true, map.get((K) Integer.valueOf((String) els[i])).contains(els[i]));         }          final Collection<V> coll = map.remove(els[0]);         assertNotNull(coll);         assertEquals(0, coll.size());         assertEquals(true, map.remove(Integer.valueOf((String) els[0])).contains(els[0]));     }      @SuppressWarnings("unchecked")     public void testValueTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          final MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(                 new ArrayListValuedHashMap<K, V>(), null,                 (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsValue(els[i]));             assertEquals(true, map.containsKey(els[i]));             assertEquals(true, map.get((K) els[i]).contains(Integer.valueOf((String) els[i])));         }         assertEquals(true, map.remove(els[0]).contains(Integer.valueOf((String) els[0])));     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testFactory_Decorate() {         final MultiValuedMap<K, V> base = new ArrayListValuedHashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final MultiValuedMap<K, V> trans = TransformedMultiValuedMap                 .transformingMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(true, trans.get((K) "A").contains("1"));         assertEquals(true, trans.get((K) "B").contains("2"));         assertEquals(true, trans.get((K) "C").contains("3"));         trans.put((K) "D", (V) "4");         assertEquals(true, trans.get((K) "D").contains(Integer.valueOf(4)));     }      @SuppressWarnings("unchecked")     public void testFactory_decorateTransform() {         final MultiValuedMap<K, V> base = new ArrayListValuedHashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final MultiValuedMap<K, V> trans = TransformedMultiValuedMap                 .transformedMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(true, trans.get((K) "A").contains(Integer.valueOf(1)));         assertEquals(true, trans.get((K) "B").contains(Integer.valueOf(2)));         assertEquals(true, trans.get((K) "C").contains(Integer.valueOf(3)));         trans.put((K) "D", (V) "4");         assertEquals(true, trans.get((K) "D").contains(Integer.valueOf(4)));          final MultiValuedMap<K, V> baseMap = new ArrayListValuedHashMap<>();         final MultiValuedMap<K, V> transMap = TransformedMultiValuedMap                 .transformedMap(                         baseMap,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, transMap.size());         transMap.put((K) "D", (V) "4");         assertEquals(1, transMap.size());         assertEquals(true, transMap.get((K) "D").contains(Integer.valueOf(4)));     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/TransformedMultiValuedMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/TransformedMultiValuedMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.Set; import java.util.Map; import java.util.Map.Entry; import java.util.HashMap; import java.util.Arrays; import java.util.Collection; import java.util.Iterator;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.Unmodifiable;  /**  * Tests for UnmodifiableMultiValuedMap  *  * @since 4.1  */ public class UnmodifiableMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public UnmodifiableMultiValuedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableMultiValuedMapTest.class);     }      /**      * Assert the given map contains all added values after it was initialized      * with makeFullMap(). See COLLECTIONS-769.      * @param map the MultiValuedMap<K, V> to check      */     private void assertMapContainsAllValues(final MultiValuedMap<K, V> map) {         assertEquals("[uno, un]", map.get((K) "one").toString());         assertEquals("[dos, deux]", map.get((K) "two").toString());         assertEquals("[tres, trois]", map.get((K) "three").toString());     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public MultiValuedMap<K, V> makeObject() {         return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(                 new ArrayListValuedHashMap<K, V>());     }      @Override     protected MultiValuedMap<K, V> makeFullMap() {         final MultiValuedMap<K, V> map = new ArrayListValuedHashMap<>();         addSampleMappings(map);         return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);     }      // -----------------------------------------------------------------------     public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final MultiValuedMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(map));     }      public void testDecoratorFactoryNullMap() {         try {             UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(null);             fail("map must not be null");         } catch (final NullPointerException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testAddException() {         final MultiValuedMap<K, V> map = makeObject();         try {             map.put((K) "one", (V) "uno");             fail();         } catch (final UnsupportedOperationException e) {         }     }      public void testRemoveException() {         final MultiValuedMap<K, V> map = makeFullMap();         try {             map.remove("one");             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support remove() method             // UnmodifiableMultiValuedMap does not support change         }         this.assertMapContainsAllValues(map);     }      public void testRemoveMappingException() {         final MultiValuedMap<K, V> map = makeFullMap();         try {             map.removeMapping("one", "uno");             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support removeMapping() method             // UnmodifiableMultiValuedMap does not support change         }         this.assertMapContainsAllValues(map);     }      public void testClearException() {         final MultiValuedMap<K, V> map = makeFullMap();         try {             map.clear();             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support clear() method             // UnmodifiableMultiValuedMap does not support change         }         this.assertMapContainsAllValues(map);     }      public void testPutAllException() {         final MultiValuedMap<K, V> map = makeObject();         final MultiValuedMap<K, V> original = new ArrayListValuedHashMap<>();         final Map<K, V> originalMap = new HashMap<>();         final Collection<V> coll = (Collection<V>) Arrays.asList("X", "Y", "Z");         original.put((K) "key", (V) "object1");         original.put((K) "key", (V) "object2");         originalMap.put((K) "keyX", (V) "object1");         originalMap.put((K) "keyY", (V) "object2");          try {             map.putAll(original);             fail();         } catch (final UnsupportedOperationException e) {             // expected, not support putAll() method             // UnmodifiableMultiValuedMap does not support change         }         assertEquals("{}", map.toString());          try {             map.putAll(originalMap);             fail();         } catch (final UnsupportedOperationException e) {             // expected         }         assertEquals("{}", map.toString());          try {             map.putAll((K) "A", coll);             fail();         } catch (final UnsupportedOperationException e) {             // expected         }         assertEquals("{}", map.toString());     }      @SuppressWarnings("unchecked")     public void testUnmodifiableEntries() {         resetFull();         final Collection<Entry<K, V>> entries = getMap().entries();         try {             entries.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<Entry<K, V>> it = entries.iterator();         final Entry<K, V> entry = it.next();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }          try {             entry.setValue((V) "three");             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableMapIterator() {         resetFull();         final MapIterator<K, V> mapIt = getMap().mapIterator();         try {             mapIt.remove();             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapIt.setValue((V) "three");             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableKeySet() {         resetFull();         final Set<K> keySet = getMap().keySet();         try {             keySet.add((K) "four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keySet.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keySet.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<K> it = keySet.iterator();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableValues() {         resetFull();         final Collection<V> values = getMap().values();         try {             values.add((V) "four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             values.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             values.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<V> it = values.iterator();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableAsMap() {         resetFull();         final Map<K, Collection<V>> mapCol = getMap().asMap();         try {             mapCol.put((K) "four", (Collection<V>) Arrays.asList("four"));             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapCol.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapCol.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          try {             mapCol.clear();             fail();         } catch (final UnsupportedOperationException e) {         }     }      @SuppressWarnings("unchecked")     public void testUnmodifiableKeys() {         resetFull();         final MultiSet<K> keys = getMap().keys();         try {             keys.add((K) "four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keys.remove("four");             fail();         } catch (final UnsupportedOperationException e) {         }          try {             keys.clear();             fail();         } catch (final UnsupportedOperationException e) {         }          final Iterator<K> it = keys.iterator();         try {             it.remove();             fail();         } catch (final UnsupportedOperationException e) {         }     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/UnmodifiableMultiValuedMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/UnmodifiableMultiValuedMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multimap;  import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiValuedMap; import org.apache.commons.collections4.SetValuedMap;  /**  * Test HashSetValuedHashMap  *  * @since 4.1  */ public class HashSetValuedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {      public HashSetValuedHashMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashSetValuedHashMapTest.class);     }      // -----------------------------------------------------------------------     @Override     public SetValuedMap<K, V> makeObject() {         return new HashSetValuedHashMap<>();     }      @Override     public MultiValuedMap<K, V> makeConfirmedMap() {         return new HashSetValuedHashMap<>();     }      @Override     public boolean isHashSetValue() {         return true;     }      // -----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testSetValuedMapAdd() {         final SetValuedMap<K, V> setMap = makeObject();         assertTrue(setMap.get((K) "whatever") instanceof Set);          final Set<V> set = setMap.get((K) "A");         assertTrue(set.add((V) "a1"));         assertTrue(set.add((V) "a2"));         assertFalse(set.add((V) "a1"));         assertEquals(2, setMap.size());         assertTrue(setMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testSetValuedMapRemove() {         final SetValuedMap<K, V> setMap = makeObject();         assertTrue(setMap.get((K) "whatever") instanceof Set);          final Set<V> set = setMap.get((K) "A");         assertTrue(set.add((V) "a1"));         assertTrue(set.add((V) "a2"));         assertFalse(set.add((V) "a1"));         assertEquals(2, setMap.size());         assertTrue(setMap.containsKey("A"));          assertTrue(set.remove("a1"));         assertTrue(set.remove("a2"));         assertFalse(set.remove("a1"));          assertEquals(0, setMap.size());         assertFalse(setMap.containsKey("A"));     }      @SuppressWarnings("unchecked")     public void testSetValuedMapRemoveViaIterator() {         final SetValuedMap<K, V> setMap = makeObject();         assertTrue(setMap.get((K) "whatever") instanceof Set);          final Set<V> set = setMap.get((K) "A");         set.add((V) "a1");         set.add((V) "a2");         set.add((V) "a1");          final Iterator<V> it = set.iterator();         while (it.hasNext()) {             it.next();             it.remove();         }         assertEquals(0, setMap.size());         assertFalse(setMap.containsKey("A"));     }      @SuppressWarnings({ "unchecked", "rawtypes" })     public void testSetValuedMapEqualsHashCodeContract() {         final SetValuedMap map1 = makeObject();         final SetValuedMap map2 = makeObject();          map1.put("a", "a1");         map1.put("a", "a2");         map2.put("a", "a2");         map2.put("a", "a1");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map2.put("a", "a2");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map2.put("a", "a3");         assertNotSame(map1, map2);         assertNotSame(map1.hashCode(), map2.hashCode());     }      public void testHashSetValueHashMap() {         final SetValuedMap<K, V> setMap = new HashSetValuedHashMap<>(4);         assertEquals(0, setMap.get((K) "whatever").size());          final Set<V> set = setMap.get((K) "A");         set.add((V) "W");         set.add((V) "X");         set.add((V) "F");         assertEquals(3, setMap.get((K) "A").size());     }      public void testHashSetValueHashMap_1() {         final MultiValuedMap<K, V> map = new ArrayListValuedHashMap<>();         SetValuedMap<K, V> map1;         final SetValuedMap<K, V> map2 = makeObject();         SetValuedMap<K, V> map3;          map.put((K) "A", (V) "W");         map.put((K) "A", (V) "X");         map.put((K) "A", (V) "F");         map1 = new HashSetValuedHashMap<>(map);         assertEquals(3, map1.get((K) "A").size());         map2.put((K) "A", (V) "X");         map2.put((K) "A", (V) "F");         map2.put((K) "A", (V) "W");         assertEquals(map1, map2);         assertEquals(map1.hashCode(), map2.hashCode());          map.remove("A");         map3 = new HashSetValuedHashMap<>(map);         assertEquals("{}", map3.toString());     }      public void testHashSetValuedHashMap_2(){         final Map<K, V> map = new HashMap<>();         SetValuedMap<K, V> map1;         SetValuedMap<K, V> map2;          map.put((K) "A", (V) "W");         map.put((K) "B", (V) "X");         map.put((K) "C", (V) "F");         map1 = new HashSetValuedHashMap<>(map);         assertEquals(1, map1.get((K) "A").size());          map.remove("A");         map.remove("B");         map.remove("C");         map2 = new HashSetValuedHashMap<>(map);         assertEquals("{}", map2.toString());     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/HashSetValuedHashMap.emptyCollection.version4.1.obj"); //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/HashSetValuedHashMap.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.functors.ExceptionClosure; import org.apache.commons.collections4.functors.FalsePredicate; import org.apache.commons.collections4.functors.NOPClosure; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests the ClosureUtils class.  *  * @since 3.0  */ public class ClosureUtilsTest {      private static final Object cString = "Hello";      static class MockClosure<T> implements Closure<T> {         int count = 0;          @Override         public void execute(final T object) {             count++;         }          public void reset() {             count = 0;         }     }      static class MockTransformer<T> implements Transformer<T, T> {         int count = 0;          @Override         public T transform(final T object) {             count++;             return object;         }     }      // exceptionClosure     //------------------------------------------------------------------      @Test     public void testExceptionClosure() {         assertNotNull(ClosureUtils.exceptionClosure());         assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());         try {             ClosureUtils.exceptionClosure().execute(null);         } catch (final FunctorException ex) {             try {                 ClosureUtils.exceptionClosure().execute(cString);             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // nopClosure     //------------------------------------------------------------------      @Test     public void testNopClosure() {         final StringBuilder buf = new StringBuilder("Hello");         ClosureUtils.nopClosure().execute(null);         assertEquals("Hello", buf.toString());         ClosureUtils.nopClosure().execute("Hello");         assertEquals("Hello", buf.toString());     }      // invokeClosure     //------------------------------------------------------------------      @Test     public void testInvokeClosure() {         StringBuffer buf = new StringBuffer("Hello"); // Only StringBuffer has setLength() method         ClosureUtils.invokerClosure("reverse").execute(buf);         assertEquals("olleH", buf.toString());         buf = new StringBuffer("Hello");         ClosureUtils.invokerClosure("setLength", new Class[] {Integer.TYPE}, new Object[] {Integer.valueOf(2)}).execute(buf);         assertEquals("He", buf.toString());     }      // forClosure     //------------------------------------------------------------------      @Test     public void testForClosure() {         final MockClosure<Object> cmd = new MockClosure<>();         ClosureUtils.forClosure(5, cmd).execute(null);         assertEquals(5, cmd.count);         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure<>()));         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(-1, new MockClosure<>()));         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(1, null));         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(3, null));         assertSame(cmd, ClosureUtils.forClosure(1, cmd));     }      // whileClosure     //------------------------------------------------------------------      @Test     public void testWhileClosure() {         MockClosure<Object> cmd = new MockClosure<>();         ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), cmd).execute(null);         assertEquals(0, cmd.count);          cmd = new MockClosure<>();         ClosureUtils.whileClosure(PredicateUtils.uniquePredicate(), cmd).execute(null);         assertEquals(1, cmd.count);          try {             ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.whileClosure(null, null);             fail();         } catch (final NullPointerException ex) {}     }      // doWhileClosure     //------------------------------------------------------------------      @Test     public void testDoWhileClosure() {         MockClosure<Object> cmd = new MockClosure<>();         ClosureUtils.doWhileClosure(cmd, FalsePredicate.falsePredicate()).execute(null);         assertEquals(1, cmd.count);          cmd = new MockClosure<>();         ClosureUtils.doWhileClosure(cmd, PredicateUtils.uniquePredicate()).execute(null);         assertEquals(2, cmd.count);          try {             ClosureUtils.doWhileClosure(null, null);             fail();         } catch (final NullPointerException ex) {}     }      // chainedClosure     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testChainedClosure() {         MockClosure<Object> a = new MockClosure<>();         MockClosure<Object> b = new MockClosure<>();         ClosureUtils.chainedClosure(a, b).execute(null);         assertEquals(1, a.count);         assertEquals(1, b.count);          a = new MockClosure<>();         b = new MockClosure<>();         ClosureUtils.<Object>chainedClosure(a, b, a).execute(null);         assertEquals(2, a.count);         assertEquals(1, b.count);          a = new MockClosure<>();         b = new MockClosure<>();         Collection<Closure<Object>> coll = new ArrayList<>();         coll.add(b);         coll.add(a);         coll.add(b);         ClosureUtils.<Object>chainedClosure(coll).execute(null);         assertEquals(1, a.count);         assertEquals(2, b.count);          assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure());         assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(Collections.<Closure<Object>>emptyList()));          try {             ClosureUtils.chainedClosure(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<Object>chainedClosure((Closure[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<Object>chainedClosure(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             coll = new ArrayList<>();             coll.add(null);             coll.add(null);             ClosureUtils.chainedClosure(coll);             fail();         } catch (final NullPointerException ex) {}     }      // ifClosure     //------------------------------------------------------------------      @Test     public void testIfClosure() {         MockClosure<Object> a = new MockClosure<>();         MockClosure<Object> b;         ClosureUtils.ifClosure(TruePredicate.truePredicate(), a).execute(null);         assertEquals(1, a.count);          a = new MockClosure<>();         ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a).execute(null);         assertEquals(0, a.count);          a = new MockClosure<>();         b = new MockClosure<>();         ClosureUtils.ifClosure(TruePredicate.<Object>truePredicate(), a, b).execute(null);         assertEquals(1, a.count);         assertEquals(0, b.count);          a = new MockClosure<>();         b = new MockClosure<>();         ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a, b).execute(null);         assertEquals(0, a.count);         assertEquals(1, b.count);     }      // switchClosure     //------------------------------------------------------------------      @Test     @SuppressWarnings("unchecked")     public void testSwitchClosure() {         final MockClosure<String> a = new MockClosure<>();         final MockClosure<String> b = new MockClosure<>();         ClosureUtils.<String>switchClosure(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Closure[] { a, b }).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         ClosureUtils.<String>switchClosure(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Closure[] { a, b }).execute("HELLO");         assertEquals(1, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         final MockClosure<String> c = new MockClosure<>();         ClosureUtils.<String>switchClosure(             new Predicate[] { EqualPredicate.equalPredicate("HELLO"), EqualPredicate.equalPredicate("THERE") },             new Closure[] { a, b }, c).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);         assertEquals(1, c.count);          a.reset();         b.reset();         final Map<Predicate<String>, Closure<String>> map = new HashMap<>();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         ClosureUtils.<String>switchClosure(map).execute(null);         assertEquals(0, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         map.clear();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         ClosureUtils.switchClosure(map).execute("THERE");         assertEquals(0, a.count);         assertEquals(1, b.count);          a.reset();         b.reset();         c.reset();         map.clear();         map.put(EqualPredicate.equalPredicate("HELLO"), a);         map.put(EqualPredicate.equalPredicate("THERE"), b);         map.put(null, c);         ClosureUtils.switchClosure(map).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);         assertEquals(1, c.count);          assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new Predicate[0], new Closure[0]));         assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new HashMap<Predicate<String>, Closure<String>>()));         map.clear();         map.put(null, null);         assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchClosure(map));          try {             ClosureUtils.switchClosure(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2]);             fail();         } catch (final NullPointerException ex) {}         try {             ClosureUtils.<String>switchClosure(                     new Predicate[] { TruePredicate.<String>truePredicate() },                     new Closure[] { a, b });             fail();         } catch (final IllegalArgumentException ex) {}     }      // switchMapClosure     //------------------------------------------------------------------      @Test     public void testSwitchMapClosure() {         final MockClosure<String> a = new MockClosure<>();         final MockClosure<String> b = new MockClosure<>();         final Map<String, Closure<String>> map = new HashMap<>();         map.put("HELLO", a);         map.put("THERE", b);         ClosureUtils.switchMapClosure(map).execute(null);         assertEquals(0, a.count);         assertEquals(0, b.count);          a.reset();         b.reset();         map.clear();         map.put("HELLO", a);         map.put("THERE", b);         ClosureUtils.switchMapClosure(map).execute("THERE");         assertEquals(0, a.count);         assertEquals(1, b.count);          a.reset();         b.reset();         map.clear();         final MockClosure<String> c = new MockClosure<>();         map.put("HELLO", a);         map.put("THERE", b);         map.put(null, c);         ClosureUtils.switchMapClosure(map).execute("WELL");         assertEquals(0, a.count);         assertEquals(0, b.count);         assertEquals(1, c.count);          assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchMapClosure(new HashMap<String, Closure<String>>()));          try {             ClosureUtils.switchMapClosure(null);             fail();         } catch (final NullPointerException ex) {}     }      // asClosure     //------------------------------------------------------------------      @Test     public void testTransformerClosure() {         final MockTransformer<Object> mock = new MockTransformer<>();         final Closure<Object> closure = ClosureUtils.asClosure(mock);         closure.execute(null);         assertEquals(1, mock.count);         closure.execute(null);         assertEquals(2, mock.count);          assertEquals(ClosureUtils.nopClosure(), ClosureUtils.asClosure(null));     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Closure singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionClosure.INSTANCE,             NOPClosure.INSTANCE,         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization(                     "Singleton pattern broken for " + original.getClass(),                     original             );         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class DualTreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualTreeBidiMapTest.class);     }      public DualTreeBidiMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public DualTreeBidiMap<K, V> makeObject() {         return new DualTreeBidiMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         final String recursiveTest = "DualTreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap";         return new String[] { recursiveTest };     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.Map; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.OrderedBidiMap; import org.apache.commons.collections4.Unmodifiable;  /**  * JUnit tests.  *  */ public class UnmodifiableOrderedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableOrderedBidiMapTest.class);     }      public UnmodifiableOrderedBidiMapTest(final String testName) {         super(testName);     }      @Override     public OrderedBidiMap<K, V> makeObject() {         return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(new TreeBidiMap<K, V>());     }      @Override     public OrderedBidiMap<K, V> makeFullMap() {         final OrderedBidiMap<K, V> bidi = new TreeBidiMap<>();         addSampleMappings(bidi);         return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);     }      @Override     public Map<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] {"UnmodifiableOrderedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final OrderedBidiMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(map));          try {             UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(null);             fail();         } catch (final NullPointerException ex) {}     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.SortedMap; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBidiMap; import org.apache.commons.collections4.Unmodifiable;  /**  * JUnit tests.  *  */ public class UnmodifiableSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSortedBidiMapTest.class);     }      public UnmodifiableSortedBidiMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public SortedBidiMap<K, V> makeObject() {         return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(new DualTreeBidiMap<K, V>());     }      @Override     public SortedBidiMap<K, V> makeFullMap() {         final SortedBidiMap<K, V> bidi = new DualTreeBidiMap<>();         addSampleMappings(bidi);         return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);     }      @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      @Override     public String[] ignoredTests() {         // Override to prevent infinite recursion of tests.         return new String[] {"UnmodifiableSortedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      //-----------------------------------------------------------------------     @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final SortedBidiMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(map));          try {             UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class DualLinkedHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualLinkedHashBidiMapTest.class);     }      public DualLinkedHashBidiMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public DualLinkedHashBidiMap<K, V> makeObject() {         return new DualLinkedHashBidiMap<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] { "DualLinkedHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap" };     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualLinkedHashBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualLinkedHashBidiMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.SortedMap; import java.util.TreeMap;  import org.apache.commons.collections4.OrderedBidiMap;  /**  * Test class for AbstractOrderedBidiMapDecorator.  *  * @param <K> the type of the keys in this map  * @param <V> the type of the values in this map  */ public class AbstractOrderedBidiMapDecoratorTest<K, V>         extends AbstractOrderedBidiMapTest<K, V> {      public AbstractOrderedBidiMapDecoratorTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public OrderedBidiMap<K, V> makeObject() {         return new TestOrderedBidiMap<>();     }      @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isSetValueSupported() {         return true;     }      /**      * Simple class to actually test.      */     private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {          private TestOrderedBidiMap<V, K> inverse = null;          TestOrderedBidiMap() {             super(new DualTreeBidiMap<K, V>());         }          TestOrderedBidiMap(final OrderedBidiMap<K, V> map) {             super(map);         }          @Override         public OrderedBidiMap<V, K> inverseBidiMap() {             if (inverse == null) {                 inverse = new TestOrderedBidiMap<>(decorated().inverseBidiMap());                 inverse.inverse = this;             }             return inverse;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.OrderedBidiMap; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;  /**  * Abstract test class for {@link OrderedBidiMap} methods and contracts.  *  */ public abstract class AbstractOrderedBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public AbstractOrderedBidiMapTest(final String testName) {         super(testName);     }      public AbstractOrderedBidiMapTest() {     }      //-----------------------------------------------------------------------     public void testFirstKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = getMap();         try {             bidi.firstKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         bidi = getMap();         final K confirmedFirst = confirmed.keySet().iterator().next();         assertEquals(confirmedFirst, bidi.firstKey());     }      public void testLastKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = getMap();         try {             bidi.lastKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         bidi = getMap();         K confirmedLast = null;         for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {             confirmedLast = it.next();         }         assertEquals(confirmedLast, bidi.lastKey());     }      //-----------------------------------------------------------------------     public void testNextKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = (OrderedBidiMap<K, V>) map;         assertEquals(null, bidi.nextKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, bidi.nextKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.nextKey(null));         }          resetFull();         bidi = (OrderedBidiMap<K, V>) map;         final Iterator<K> it = confirmed.keySet().iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, bidi.nextKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, bidi.nextKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 bidi.nextKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.nextKey(null));         }     }      public void testPreviousKey() {         resetEmpty();         OrderedBidiMap<K, V> bidi = getMap();         assertEquals(null, bidi.previousKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, bidi.previousKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.previousKey(null));         }          resetFull();         bidi = getMap();         final List<K> list = new ArrayList<>(confirmed.keySet());         Collections.reverse(list);         final Iterator<K> it = list.iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, bidi.previousKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, bidi.previousKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 bidi.previousKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, bidi.previousKey(null));         }     }      //-----------------------------------------------------------------------     public BulkTest bulkTestOrderedMapIterator() {         return new TestBidiOrderedMapIterator();     }      /**      * {@inheritDoc}      */     @Override     public OrderedBidiMap<K, V> getMap() {         return (OrderedBidiMap<K, V>) super.getMap();     }      public class TestBidiOrderedMapIterator extends AbstractMapIteratorTest<K, V> {         public TestBidiOrderedMapIterator() {             super("TestBidiOrderedMapIterator");         }          @Override         public V[] addSetValues() {             return AbstractOrderedBidiMapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return AbstractOrderedBidiMapTest.this.isRemoveSupported();         }          @Override         public boolean supportsSetValue() {             return AbstractOrderedBidiMapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractOrderedBidiMapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return AbstractOrderedBidiMapTest.this.getMap().mapIterator();         }          @Override         public Map<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedBidiMapTest.this.map;         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedBidiMapTest.this.confirmed;         }          @Override         public void verify() {             super.verify();             AbstractOrderedBidiMapTest.this.verify();         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Collections; import java.util.Comparator; import java.util.Iterator; import java.util.List; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBidiMap; import org.apache.commons.collections4.comparators.ComparableComparator; import org.apache.commons.collections4.comparators.ReverseComparator;  /**  * JUnit tests.  *  */ @SuppressWarnings("boxing") public class DualTreeBidiMap2Test<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualTreeBidiMap2Test.class);     }      public DualTreeBidiMap2Test(final String testName) {         super(testName);     }      @Override     public DualTreeBidiMap<K, V> makeObject() {         return new DualTreeBidiMap<>(                 new ReverseComparator<>(ComparableComparator.<K>comparableComparator()),                 new ReverseComparator<>(ComparableComparator.<V>comparableComparator()));     }      @Override     public TreeMap<K, V> makeConfirmedMap() {         return new TreeMap<>(new ReverseComparator<>(ComparableComparator.<K>comparableComparator()));     }      public void testComparator() {         resetEmpty();         final SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;         assertNotNull(bidi.comparator());         assertTrue(bidi.comparator() instanceof ReverseComparator);     }      public void testComparator2() {         final DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<>(                 String.CASE_INSENSITIVE_ORDER, null);         dtbm.put("two", 0);         dtbm.put("one", 1);         assertEquals("one", dtbm.firstKey());         assertEquals("two", dtbm.lastKey());      }      public void testSerializeDeserializeCheckComparator() throws Exception {         final SortedBidiMap<?, ?> obj = makeObject();         if (obj instanceof Serializable && isTestSerialization()) {             final ByteArrayOutputStream buffer = new ByteArrayOutputStream();             final ObjectOutputStream out = new ObjectOutputStream(buffer);             out.writeObject(obj);             out.close();              final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));             final Object dest = in.readObject();             in.close();              final SortedBidiMap<?, ?> bidi = (SortedBidiMap<?, ?>) dest;             assertNotNull(obj.comparator());             assertNotNull(bidi.comparator());             assertTrue(bidi.comparator() instanceof ReverseComparator);         }     }      private static class IntegerComparator implements Comparator<Integer>, Serializable{         private static final long serialVersionUID = 1L;         @Override         public int compare(final Integer o1, final Integer o2) {             return o1.compareTo(o2);         }     }      public void testCollections364() throws Exception {         final DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<>(                 String.CASE_INSENSITIVE_ORDER, new IntegerComparator());         final ByteArrayOutputStream buffer = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(buffer);         out.writeObject(original);         out.close();          final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));         @SuppressWarnings("unchecked")         final DualTreeBidiMap<String, Integer> deserialized = (DualTreeBidiMap<String, Integer>) in.readObject();         in.close();          assertNotNull(original.comparator());         assertNotNull(deserialized.comparator());         assertEquals(original.comparator().getClass(), deserialized.comparator().getClass());         assertEquals(original.valueComparator().getClass(), deserialized.valueComparator().getClass());     }      public void testSortOrder() throws Exception {         final SortedBidiMap<K, V> sm = makeFullMap();          // Sort by the comparator used in the makeEmptyBidiMap() method         List<K> newSortedKeys = getAsList(getSampleKeys());         Collections.sort(newSortedKeys, new ReverseComparator<>(ComparableComparator.<K>comparableComparator()));         newSortedKeys = Collections.unmodifiableList(newSortedKeys);          final Iterator<K> mapIter = sm.keySet().iterator();         final Iterator<K> expectedIter = newSortedKeys.iterator();         while (expectedIter.hasNext()) {             final K expectedKey = expectedIter.next();             final K mapKey = mapIter.next();             assertNotNull("key in sorted list may not be null", expectedKey);             assertNotNull("key in map may not be null", mapKey);             assertEquals("key from sorted list and map must be equal", expectedKey, mapKey);         }     }      @Override     public String getCompatibilityVersion() {         return "4.Test2";     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         final String recursiveTest = "DualTreeBidiMap2Test.bulkTestInverseMap.bulkTestInverseMap";         return new String[] { recursiveTest };     }   //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.Test2.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.Test2.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class DualHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(DualHashBidiMapTest.class);     }      public DualHashBidiMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public DualHashBidiMap<K, V> makeObject() {         return new DualHashBidiMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] { "DualHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap" };     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualHashBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/DualHashBidiMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.HashMap; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BidiMap; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Unmodifiable;  /**  * JUnit tests.  *  */ public class UnmodifiableBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableBidiMapTest.class);     }      public UnmodifiableBidiMapTest(final String testName) {         super(testName);     }      @Override     public BidiMap<K, V> makeObject() {         return UnmodifiableBidiMap.unmodifiableBidiMap(new DualHashBidiMap<K, V>());     }      @Override     public BidiMap<K, V> makeFullMap() {         final BidiMap<K, V> bidi = new DualHashBidiMap<>();         addSampleMappings(bidi);         return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);     }      @Override     public Map<K, V> makeConfirmedMap() {         return new HashMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] {"UnmodifiableBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final BidiMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableBidiMap.unmodifiableBidiMap(map));          try {             UnmodifiableBidiMap.unmodifiableBidiMap(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import java.util.SortedMap; import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBidiMap; import org.apache.commons.collections4.map.AbstractSortedMapTest;  /**  * Abstract test class for {@link SortedBidiMap} methods and contracts.  *  */ public abstract class AbstractSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {      protected List<K> sortedKeys;     protected List<V> sortedValues = new ArrayList<>();     protected SortedSet<V> sortedNewValues = new TreeSet<>();      public AbstractSortedBidiMapTest(final String testName) {         super(testName);         sortedKeys = getAsList(getSampleKeys());         Collections.sort(sortedKeys);         sortedKeys = Collections.unmodifiableList(sortedKeys);          final Map<K, V> map = new TreeMap<>();         addSampleMappings(map);          sortedValues.addAll(map.values());         sortedValues = Collections.unmodifiableList(sortedValues);          sortedNewValues.addAll(getAsList(getNewSampleValues()));     }  //    public AbstractTestSortedBidiMap() { //        super(); //        sortedKeys.addAll(Arrays.asList(getSampleValues())); //        Collections.sort(sortedKeys); //        sortedKeys = Collections.unmodifiableList(sortedKeys); // //        Map map = new TreeMap(); //        for (int i = 0; i < getSampleKeys().length; i++) { //            map.put(getSampleValues()[i], getSampleKeys()[i]); //        } //        sortedValues.addAll(map.values()); //        sortedValues = Collections.unmodifiableList(sortedValues); // //        sortedNewValues.addAll(Arrays.asList(getNewSampleValues())); //    }      //-----------------------------------------------------------------------     @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedBidiMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedBidiMap<K, V> makeFullMap() {         return (SortedBidiMap<K, V>) super.makeFullMap();     }      @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      //-----------------------------------------------------------------------     //-----------------------------------------------------------------------     public void testBidiHeadMapContains() {         // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K toKey = it.next();         final K second = it.next();         final V firstValue = sm.get(first);         final V secondValue = sm.get(second);          final SortedMap<K, V> head = sm.headMap(toKey);         assertEquals(1, head.size());         assertTrue(sm.containsKey(first));         assertTrue(head.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertTrue(head.containsValue(firstValue));         assertTrue(sm.containsKey(second));         assertFalse(head.containsKey(second));         assertTrue(sm.containsValue(secondValue));         assertFalse(head.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiClearByHeadMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final V firstValue = sm.get(first);         final V secondValue = sm.get(second);         final V toKeyValue = sm.get(toKey);          final SortedMap<K, V> sub = sm.headMap(toKey);         final int size = sm.size();         assertEquals(2, sub.size());         sub.clear();         assertEquals(0, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());          assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));          assertTrue(sm.containsKey(toKey));         assertTrue(sm.containsValue(toKeyValue));         assertTrue(sm.inverseBidiMap().containsKey(toKeyValue));         assertTrue(sm.inverseBidiMap().containsValue(toKey));         assertFalse(sub.containsKey(toKey));         assertFalse(sub.containsValue(toKeyValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByHeadMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.headMap(toKey);         assertEquals(2, sub.size());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));          final V firstValue = sub.remove(first);         assertEquals(1, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          final V secondValue = sub.remove(second);         assertEquals(0, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByHeadMapEntrySet() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.headMap(toKey);         final Set<Map.Entry<K, V>> set = sub.entrySet();         assertEquals(2, sub.size());         assertEquals(2, set.size());          final Iterator<Map.Entry<K, V>> it2 = set.iterator();         final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());         final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(set.contains(firstEntry));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(set.contains(secondEntry));          set.remove(firstEntry);         assertEquals(1, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(firstEntry.getKey()));         assertFalse(sm.containsValue(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));         assertFalse(sub.containsKey(firstEntry.getKey()));         assertFalse(sub.containsValue(firstEntry.getValue()));         assertFalse(set.contains(firstEntry));          set.remove(secondEntry);         assertEquals(0, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(secondEntry.getKey()));         assertFalse(sm.containsValue(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));         assertFalse(sub.containsKey(secondEntry.getKey()));         assertFalse(sub.containsValue(secondEntry.getValue()));         assertFalse(set.contains(secondEntry));     }      //-----------------------------------------------------------------------     //-----------------------------------------------------------------------     public void testBidiTailMapContains() {         // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K fromKey = it.next();         final K second = it.next();         final V firstValue = sm.get(first);         final V fromKeyValue = sm.get(fromKey);         final V secondValue = sm.get(second);          final SortedMap<K, V> sub = sm.tailMap(fromKey);         assertEquals(sm.size() - 1, sub.size());         assertTrue(sm.containsKey(first));         assertFalse(sub.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertFalse(sub.containsValue(firstValue));         assertTrue(sm.containsKey(fromKey));         assertTrue(sub.containsKey(fromKey));         assertTrue(sm.containsValue(fromKeyValue));         assertTrue(sub.containsValue(fromKeyValue));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(sm.containsValue(secondValue));         assertTrue(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiClearByTailMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K first = it.next();         final K fromKey = it.next();         final K second = it.next();          final V firstValue = sm.get(first);         final V fromKeyValue = sm.get(fromKey);         final V secondValue = sm.get(second);          final SortedMap<K, V> sub = sm.tailMap(fromKey);         final int size = sm.size();         assertEquals(size - 3, sub.size());         sub.clear();         assertEquals(0, sub.size());         assertEquals(3, sm.size());         assertEquals(3, sm.inverseBidiMap().size());          assertTrue(sm.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertTrue(sm.inverseBidiMap().containsKey(firstValue));         assertTrue(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          assertFalse(sm.containsKey(fromKey));         assertFalse(sm.containsValue(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsKey(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsValue(fromKey));         assertFalse(sub.containsKey(fromKey));         assertFalse(sub.containsValue(fromKeyValue));          assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByTailMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.tailMap(fromKey);         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));          final Object firstValue = sub.remove(first);         assertEquals(size - 3, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          final Object secondValue = sub.remove(second);         assertEquals(size - 4, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByTailMapEntrySet() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.tailMap(fromKey);         final Set<Map.Entry<K, V>> set = sub.entrySet();         final Iterator<Map.Entry<K, V>> it2 = set.iterator();         it2.next();         final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());         final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(set.contains(firstEntry));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(set.contains(secondEntry));          set.remove(firstEntry);         assertEquals(size - 3, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(firstEntry.getKey()));         assertFalse(sm.containsValue(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));         assertFalse(sub.containsKey(firstEntry.getKey()));         assertFalse(sub.containsValue(firstEntry.getValue()));         assertFalse(set.contains(firstEntry));          set.remove(secondEntry);         assertEquals(size - 4, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(secondEntry.getKey()));         assertFalse(sm.containsValue(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));         assertFalse(sub.containsKey(secondEntry.getKey()));         assertFalse(sub.containsValue(secondEntry.getValue()));         assertFalse(set.contains(secondEntry));     }      //-----------------------------------------------------------------------     //-----------------------------------------------------------------------     public void testBidiSubMapContains() {         // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         final K first = it.next();         final K fromKey = it.next();         final K second = it.next();         final K toKey = it.next();         final K third = it.next();         final V firstValue = sm.get(first);         final V fromKeyValue = sm.get(fromKey);         final V secondValue = sm.get(second);         final V thirdValue = sm.get(third);          final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         assertEquals(2, sub.size());         assertTrue(sm.containsKey(first));         assertFalse(sub.containsKey(first));         assertTrue(sm.containsValue(firstValue));         assertFalse(sub.containsValue(firstValue));         assertTrue(sm.containsKey(fromKey));         assertTrue(sub.containsKey(fromKey));         assertTrue(sm.containsValue(fromKeyValue));         assertTrue(sub.containsValue(fromKeyValue));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(sm.containsValue(secondValue));         assertTrue(sub.containsValue(secondValue));         assertTrue(sm.containsKey(third));         assertFalse(sub.containsKey(third));         assertTrue(sm.containsValue(thirdValue));         assertFalse(sub.containsValue(thirdValue));     }      //-----------------------------------------------------------------------     public void testBidiClearBySubMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final V fromKeyValue = sm.get(fromKey);         final V firstValue = sm.get(first);         final V secondValue = sm.get(second);         final V toKeyValue = sm.get(toKey);          final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         final int size = sm.size();         assertEquals(3, sub.size());         sub.clear();         assertEquals(0, sub.size());         assertEquals(size - 3, sm.size());         assertEquals(size - 3, sm.inverseBidiMap().size());          assertFalse(sm.containsKey(fromKey));         assertFalse(sm.containsValue(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsKey(fromKeyValue));         assertFalse(sm.inverseBidiMap().containsValue(fromKey));         assertFalse(sub.containsKey(fromKey));         assertFalse(sub.containsValue(fromKeyValue));          assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));          assertTrue(sm.containsKey(toKey));         assertTrue(sm.containsValue(toKeyValue));         assertTrue(sm.inverseBidiMap().containsKey(toKeyValue));         assertTrue(sm.inverseBidiMap().containsValue(toKey));         assertFalse(sub.containsKey(toKey));         assertFalse(sub.containsValue(toKeyValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveBySubMap() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));          final V firstValue = sub.remove(first);         assertEquals(2, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(first));         assertFalse(sm.containsValue(firstValue));         assertFalse(sm.inverseBidiMap().containsKey(firstValue));         assertFalse(sm.inverseBidiMap().containsValue(first));         assertFalse(sub.containsKey(first));         assertFalse(sub.containsValue(firstValue));          final V secondValue = sub.remove(second);         assertEquals(1, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(second));         assertFalse(sm.containsValue(secondValue));         assertFalse(sm.inverseBidiMap().containsKey(secondValue));         assertFalse(sm.inverseBidiMap().containsValue(second));         assertFalse(sub.containsKey(second));         assertFalse(sub.containsValue(secondValue));     }      //-----------------------------------------------------------------------     public void testBidiRemoveBySubMapEntrySet() {         if (!isRemoveSupported()) {             return;         }          // extra test as other tests get complex         final SortedBidiMap<K, V> sm = makeFullMap();         final Iterator<K> it = sm.keySet().iterator();         it.next();         it.next();         final K fromKey = it.next();         final K first = it.next();         final K second = it.next();         final K toKey = it.next();          final int size = sm.size();         final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);         final Set<Map.Entry<K, V>> set = sub.entrySet();         assertEquals(3, set.size());         final Iterator<Map.Entry<K, V>> it2 = set.iterator();         it2.next();         final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());         final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());         assertTrue(sm.containsKey(first));         assertTrue(sub.containsKey(first));         assertTrue(set.contains(firstEntry));         assertTrue(sm.containsKey(second));         assertTrue(sub.containsKey(second));         assertTrue(set.contains(secondEntry));          set.remove(firstEntry);         assertEquals(2, sub.size());         assertEquals(size - 1, sm.size());         assertEquals(size - 1, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(firstEntry.getKey()));         assertFalse(sm.containsValue(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));         assertFalse(sub.containsKey(firstEntry.getKey()));         assertFalse(sub.containsValue(firstEntry.getValue()));         assertFalse(set.contains(firstEntry));          set.remove(secondEntry);         assertEquals(1, sub.size());         assertEquals(size - 2, sm.size());         assertEquals(size - 2, sm.inverseBidiMap().size());         assertFalse(sm.containsKey(secondEntry.getKey()));         assertFalse(sm.containsValue(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));         assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));         assertFalse(sub.containsKey(secondEntry.getKey()));         assertFalse(sub.containsValue(secondEntry.getValue()));         assertFalse(set.contains(secondEntry));     }      //-----------------------------------------------------------------------     public BulkTest bulkTestHeadMap() {         return new AbstractSortedMapTest.TestHeadMap<>(this);     }      public BulkTest bulkTestTailMap() {         return new AbstractSortedMapTest.TestTailMap<>(this);     }      public BulkTest bulkTestSubMap() {         return new AbstractSortedMapTest.TestSubMap<>(this);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.TreeMap;  import junit.framework.Test; import org.apache.commons.collections4.BidiMap; import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class TreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(TreeBidiMapTest.class);     }      public TreeBidiMapTest(final String testName) {         super(testName);     }      @Override     public BidiMap<K, V> makeObject() {         return new TreeBidiMap<>();     }      @Override     public TreeMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      /**      * Override to prevent infinite recursion of tests.      */     @Override     public String[] ignoredTests() {         return new String[] {"TreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap"};     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public boolean isSetValueSupported() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/TreeBidiMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/TreeBidiMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bidimap;  import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;  import org.apache.commons.collections4.BidiMap; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest; import org.apache.commons.collections4.map.AbstractIterableMapTest;  /**  * Abstract test class for {@link BidiMap} methods and contracts.  *  */ public abstract class AbstractBidiMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public AbstractBidiMapTest(final String testName) {         super(testName);     }      public AbstractBidiMapTest() {         super("Inverse");     }      //-----------------------------------------------------------------------     /**      * Override to create a full {@code BidiMap} other than the default.      *      * @return a full {@code BidiMap} implementation.      */     @Override     public BidiMap<K, V> makeFullMap() {         return (BidiMap<K, V>) super.makeFullMap();     }      /**      * Override to return the empty BidiMap.      */     @Override     public abstract BidiMap<K, V> makeObject();      /**      * Override to indicate to AbstractTestMap this is a BidiMap.      */     @Override     public boolean isAllowDuplicateValues() {         return false;     }      /**      * Override as DualHashBidiMap didn't exist until version 3.      */     @Override     public String getCompatibilityVersion() {         return "4";     }      // BidiPut     //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testBidiPut() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }          final BidiMap<K, V> map = makeObject();         final BidiMap<V, K> inverse = map.inverseBidiMap();         assertEquals(0, map.size());         assertEquals(map.size(), inverse.size());          map.put((K) "A", (V) "B");         assertEquals(1, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("B", map.get("A"));         assertEquals("A", inverse.get("B"));          map.put((K) "A", (V) "C");         assertEquals(1, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("C", map.get("A"));         assertEquals("A", inverse.get("C"));          map.put((K) "B", (V) "C");         assertEquals(1, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("C", map.get("B"));         assertEquals("B", inverse.get("C"));          map.put((K) "E", (V) "F");         assertEquals(2, map.size());         assertEquals(map.size(), inverse.size());         assertEquals("F", map.get("E"));         assertEquals("E", inverse.get("F"));     }      /**      * Verifies that {@link #map} is still equal to {@link #confirmed}.      * <p>      * This implementation checks the inverse map as well.      */     @Override     public void verify() {         verifyInverse();         super.verify();     }      public void verifyInverse() {         assertEquals(map.size(), ((BidiMap<K, V>) map).inverseBidiMap().size());         final Map<K, V> map1 = new HashMap<>(map);         final Map<V, K> map2 = new HashMap<>(((BidiMap<K, V>) map).inverseBidiMap());         final Set<K> keys1 = map1.keySet();         final Set<V> keys2 = map2.keySet();         final Collection<V> values1 = map1.values();         final Collection<K> values2 = map2.values();         assertTrue(keys1.containsAll(values2));         assertTrue(values2.containsAll(keys1));         assertTrue(values1.containsAll(keys2));         assertTrue(keys2.containsAll(values1));     }      // testGetKey     //-----------------------------------------------------------------------     public void testBidiGetKey() {         doTestGetKey(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);     }      public void testBidiGetKeyInverse() {         doTestGetKey(             makeFullMap().inverseBidiMap(),             getSampleValues()[0],             getSampleKeys()[0]);     }      private void doTestGetKey(final BidiMap<?, ?> map, final Object key, final Object value) {         assertEquals("Value not found for key.", value, map.get(key));         assertEquals("Key not found for value.", key, map.getKey(value));     }      // testInverse     //-----------------------------------------------------------------------     public void testBidiInverse() {         final BidiMap<K, V> map = makeFullMap();         final BidiMap<V, K> inverseMap = map.inverseBidiMap();          assertSame(             "Inverse of inverse is not equal to original.",             map,             inverseMap.inverseBidiMap());          assertEquals(             "Value not found for key.",             getSampleKeys()[0],             inverseMap.get(getSampleValues()[0]));          assertEquals(             "Key not found for value.",             getSampleValues()[0],             inverseMap.getKey(getSampleKeys()[0]));     }      //-----------------------------------------------------------------------     public void testBidiModifyEntrySet() {         if (!isSetValueSupported()) {             return;         }          modifyEntrySet(makeFullMap());         modifyEntrySet(makeFullMap().inverseBidiMap());     }      @SuppressWarnings("unchecked")     private <T> void modifyEntrySet(final BidiMap<?, T> map) {         // Gets first entry         final Map.Entry<?, T> entry = map.entrySet().iterator().next();          // Gets key and value         final Object key = entry.getKey();         final Object oldValue = entry.getValue();          // Sets new value         final Object newValue = "newValue";         entry.setValue((T) newValue);          assertEquals(             "Modifying entrySet did not affect underlying Map.",             newValue,             map.get(key));          assertNull(             "Modifying entrySet did not affect inverse Map.",             map.getKey(oldValue));     }      //-----------------------------------------------------------------------     public void testBidiClear() {         if (!isRemoveSupported()) {             try {                 makeFullMap().clear();                 fail();             } catch(final UnsupportedOperationException ex) {}             return;         }          BidiMap<?, ?> map = makeFullMap();         map.clear();         assertTrue("Map was not cleared.", map.isEmpty());         assertTrue("Inverse map was not cleared.", map.inverseBidiMap().isEmpty());          // Tests clear on inverse         map = makeFullMap().inverseBidiMap();         map.clear();         assertTrue("Map was not cleared.", map.isEmpty());         assertTrue("Inverse map was not cleared.", map.inverseBidiMap().isEmpty());      }      //-----------------------------------------------------------------------     public void testBidiRemove() {         if (!isRemoveSupported()) {             try {                 makeFullMap().remove(getSampleKeys()[0]);                 fail();             } catch(final UnsupportedOperationException ex) {}             try {                 makeFullMap().removeValue(getSampleValues()[0]);                 fail();             } catch(final UnsupportedOperationException ex) {}             return;         }          remove(makeFullMap(), getSampleKeys()[0]);         remove(makeFullMap().inverseBidiMap(), getSampleValues()[0]);          removeValue(makeFullMap(), getSampleValues()[0]);         removeValue(makeFullMap().inverseBidiMap(), getSampleKeys()[0]);          assertNull(makeFullMap().removeValue("NotPresent"));     }      private void remove(final BidiMap<?, ?> map, final Object key) {         final Object value = map.remove(key);         assertFalse("Key was not removed.", map.containsKey(key));         assertNull("Value was not removed.", map.getKey(value));     }      private void removeValue(final BidiMap<?, ?> map, final Object value) {         final Object key = map.removeValue(value);         assertFalse("Key was not removed.", map.containsKey(key));         assertNull("Value was not removed.", map.getKey(value));     }      //-----------------------------------------------------------------------     public void testBidiKeySetValuesOrder() {         resetFull();         final Iterator<K> keys = map.keySet().iterator();         final Iterator<V> values = map.values().iterator();         while (keys.hasNext() && values.hasNext()) {             final K key = keys.next();             final V value = values.next();             assertSame(map.get(key), value);         }         assertFalse(keys.hasNext());         assertFalse(values.hasNext());     }      //-----------------------------------------------------------------------     public void testBidiRemoveByKeySet() {         if (!isRemoveSupported()) {             return;         }          removeByKeySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);         removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);     }      private void removeByKeySet(final BidiMap<?, ?> map, final Object key, final Object value) {         map.keySet().remove(key);          assertFalse("Key was not removed.", map.containsKey(key));         assertFalse("Value was not removed.", map.containsValue(value));          assertFalse("Key was not removed from inverse map.", map.inverseBidiMap().containsValue(key));         assertFalse("Value was not removed from inverse map.", map.inverseBidiMap().containsKey(value));     }      //-----------------------------------------------------------------------     public void testBidiRemoveByEntrySet() {         if (!isRemoveSupported()) {             return;         }          removeByEntrySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);         removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);     }      private void removeByEntrySet(final BidiMap<?, ?> map, final Object key, final Object value) {         final Map<Object, Object> temp = new HashMap<>();         temp.put(key, value);         map.entrySet().remove(temp.entrySet().iterator().next());          assertFalse("Key was not removed.", map.containsKey(key));         assertFalse("Value was not removed.", map.containsValue(value));          assertFalse("Key was not removed from inverse map.", map.inverseBidiMap().containsValue(key));         assertFalse("Value was not removed from inverse map.", map.inverseBidiMap().containsKey(value));     }      /**      * {@inheritDoc}      */     @Override     public BidiMap<K, V> getMap() {         return (BidiMap<K, V>) super.getMap();     }      //-----------------------------------------------------------------------     @Override     public BulkTest bulkTestMapEntrySet() {         return new TestBidiMapEntrySet();     }      public class TestBidiMapEntrySet extends TestMapEntrySet {         public TestBidiMapEntrySet() {         }         public void testMapEntrySetIteratorEntrySetValueCrossCheck() {             final K key1 = getSampleKeys()[0];             final K key2 = getSampleKeys()[1];             final V newValue1 = getNewSampleValues()[0];             final V newValue2 = getNewSampleValues()[1];              resetFull();             // explicitly get entries as sample values/keys are connected for some maps             // such as BeanMap             Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry1 = getEntry(it, key1);             it = TestBidiMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry2 = getEntry(it, key2);             Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);             itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);             TestBidiMapEntrySet.this.verify();              if (!isSetValueSupported()) {                 try {                     entry1.setValue(newValue1);                 } catch (final UnsupportedOperationException ex) {                 }                 return;             }              // these checked in superclass             entry1.setValue(newValue1);             entryConfirmed1.setValue(newValue1);             entry2.setValue(newValue2);             entryConfirmed2.setValue(newValue2);              // at this point             // key1=newValue1, key2=newValue2             try {                 entry2.setValue(newValue1);  // should remove key1             } catch (final IllegalArgumentException ex) {                 return;  // simplest way of dealing with tricky situation             }             entryConfirmed2.setValue(newValue1);             AbstractBidiMapTest.this.getConfirmed().remove(key1);             assertEquals(newValue1, entry2.getValue());             assertTrue(AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));             assertTrue(AbstractBidiMapTest.this.getMap().containsValue(newValue1));             assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));             assertFalse(AbstractBidiMapTest.this.getMap().containsKey(key1));             assertFalse(AbstractBidiMapTest.this.getMap().containsValue(newValue2));             TestBidiMapEntrySet.this.verify();              // check for ConcurrentModification             it.next();  // if you fail here, maybe you should be throwing an IAE, see above             if (isRemoveSupported()) {                 it.remove();             }         }     }      public BulkTest bulkTestInverseMap() {         return new TestInverseBidiMap(this);     }      public class TestInverseBidiMap extends AbstractBidiMapTest<V, K> {         final AbstractBidiMapTest<K, V> main;          public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main) {             this.main = main;         }          @Override         public BidiMap<V, K> makeObject() {             return main.makeObject().inverseBidiMap();         }          @Override         public BidiMap<V, K> makeFullMap() {             return main.makeFullMap().inverseBidiMap();         }          @Override         public V[] getSampleKeys() {             return main.getSampleValues();         }         @Override         public K[] getSampleValues() {             return main.getSampleKeys();         }          @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion();         }          @Override         public boolean isAllowNullKey() {             return main.isAllowNullKey();         }          @Override         public boolean isAllowNullValue() {             return main.isAllowNullValue();         }          @Override         public boolean isPutAddSupported() {             return main.isPutAddSupported();         }          @Override         public boolean isPutChangeSupported() {             return main.isPutChangeSupported();         }          @Override         public boolean isSetValueSupported() {             return main.isSetValueSupported();         }          @Override         public boolean isRemoveSupported() {             return main.isRemoveSupported();         }      }      //-----------------------------------------------------------------------     public BulkTest bulkTestBidiMapIterator() {         return new TestBidiMapIterator();     }      public class TestBidiMapIterator extends AbstractMapIteratorTest<K, V> {         public TestBidiMapIterator() {             super("TestBidiMapIterator");         }          @Override         public V[] addSetValues() {             return AbstractBidiMapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return AbstractBidiMapTest.this.isRemoveSupported();         }          @Override         public boolean supportsSetValue() {             return AbstractBidiMapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractBidiMapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return AbstractBidiMapTest.this.getMap().mapIterator();         }          @Override         public BidiMap<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractBidiMapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractBidiMapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             AbstractBidiMapTest.this.verify();         }     }      //-----------------------------------------------------------------------     public void testBidiMapIteratorSet() {         final V newValue1 = getOtherValues()[0];         final V newValue2 = getOtherValues()[1];          resetFull();         final BidiMap<K, V> bidi = getMap();         final MapIterator<K, V> it = bidi.mapIterator();         assertTrue(it.hasNext());         final K key1 = it.next();          if (!isSetValueSupported()) {             try {                 it.setValue(newValue1);                 fail();             } catch (final UnsupportedOperationException ex) {             }             return;         }          it.setValue(newValue1);         confirmed.put(key1, newValue1);         assertSame(key1, it.getKey());         assertSame(newValue1, it.getValue());         assertTrue(bidi.containsKey(key1));         assertTrue(bidi.containsValue(newValue1));         assertEquals(newValue1, bidi.get(key1));         verify();          it.setValue(newValue1);  // same value - should be OK         confirmed.put(key1, newValue1);         assertSame(key1, it.getKey());         assertSame(newValue1, it.getValue());         assertTrue(bidi.containsKey(key1));         assertTrue(bidi.containsValue(newValue1));         assertEquals(newValue1, bidi.get(key1));         verify();          final K key2 = it.next();         it.setValue(newValue2);         confirmed.put(key2, newValue2);         assertSame(key2, it.getKey());         assertSame(newValue2, it.getValue());         assertTrue(bidi.containsKey(key2));         assertTrue(bidi.containsValue(newValue2));         assertEquals(newValue2, bidi.get(key2));         verify();          // at this point         // key1=newValue1, key2=newValue2         try {             it.setValue(newValue1);  // should remove key1             fail();         } catch (final IllegalArgumentException ex) {             return;  // simplest way of dealing with tricky situation         }         confirmed.put(key2, newValue1);         AbstractBidiMapTest.this.getConfirmed().remove(key1);         assertEquals(newValue1, it.getValue());         assertTrue(bidi.containsKey(it.getKey()));         assertTrue(bidi.containsValue(newValue1));         assertEquals(newValue1, bidi.get(it.getKey()));         assertFalse(bidi.containsKey(key1));         assertFalse(bidi.containsValue(newValue2));         verify();          // check for ConcurrentModification         it.next();  // if you fail here, maybe you should be throwing an IAE, see above         if (isRemoveSupported()) {             it.remove();         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.Enumeration; import java.util.HashMap; import java.util.HashSet; import java.util.Hashtable; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Queue; import java.util.Set; import java.util.SortedMap; import java.util.TreeMap; import java.util.Vector;  import org.apache.commons.collections4.bag.HashBag; import org.apache.commons.collections4.collection.PredicatedCollection; import org.apache.commons.collections4.collection.SynchronizedCollection; import org.apache.commons.collections4.collection.TransformedCollection; import org.apache.commons.collections4.collection.UnmodifiableCollection; import org.apache.commons.collections4.functors.DefaultEquator; import org.apache.commons.collections4.queue.CircularFifoQueue; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Tests for CollectionUtils.  *  */ @SuppressWarnings("boxing") public class CollectionUtilsTest extends MockTestCase {      /**      * Collection of {@link Integer}s      */     private List<Integer> collectionA = null;      /**      * Collection of {@link Long}s      */     private List<Long> collectionB = null;      /**      * Collection of {@link Integer}s that are equivalent to the Longs in      * collectionB.      */     private Collection<Integer> collectionC = null;      /**      * Sorted Collection of {@link Integer}s      */     private Collection<Integer> collectionD = null;      /**      * Sorted Collection of {@link Integer}s      */     private Collection<Integer> collectionE = null;      /**      * Collection of {@link Integer}s, bound as {@link Number}s      */     private Collection<Number> collectionA2 = null;      /**      * Collection of {@link Long}s, bound as {@link Number}s      */     private Collection<Number> collectionB2 = null;      /**      * Collection of {@link Integer}s (cast as {@link Number}s) that are      * equivalent to the Longs in collectionB.      */     private Collection<Number> collectionC2 = null;      private Iterable<Integer> iterableA = null;      private Iterable<Long> iterableB = null;      private Iterable<Integer> iterableC = null;      private Iterable<Number> iterableA2 = null;      private Iterable<Number> iterableB2 = null;      private final Collection<Integer> emptyCollection = new ArrayList<>(1);      @Before     public void setUp() {         collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionB = new LinkedList<>();         collectionB.add(5L);         collectionB.add(4L);         collectionB.add(4L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);          collectionC = new ArrayList<>();         for (final Long l : collectionB) {             collectionC.add(l.intValue());         }          iterableA = collectionA;         iterableB = collectionB;         iterableC = collectionC;         collectionA2 = new ArrayList<>(collectionA);         collectionB2 = new LinkedList<>(collectionB);         collectionC2 = new LinkedList<>(collectionC);         iterableA2 = collectionA2;         iterableB2 = collectionB2;          collectionD = new ArrayList<>();         collectionD.add(1);         collectionD.add(3);         collectionD.add(3);         collectionD.add(3);         collectionD.add(5);         collectionD.add(7);         collectionD.add(7);         collectionD.add(10);          collectionE = new ArrayList<>();         collectionE.add(2);         collectionE.add(4);         collectionE.add(4);         collectionE.add(5);         collectionE.add(6);         collectionE.add(6);         collectionE.add(9);     }      @Test     public void getCardinalityMap() {         final Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);         assertEquals(1, (int) freqA.get(1));         assertEquals(2, (int) freqA.get(2));         assertEquals(3, (int) freqA.get(3));         assertEquals(4, (int) freqA.get(4));         assertNull(freqA.get(5));          final Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);         assertNull(freqB.get(1L));         assertEquals(4, (int) freqB.get(2L));         assertEquals(3, (int) freqB.get(3L));         assertEquals(2, (int) freqB.get(4L));         assertEquals(1, (int) freqB.get(5L));     }      @Test(expected = NullPointerException.class)     public void testGetCardinalityMapNull() {         CollectionUtils.getCardinalityMap(null);     }      @Test     @Deprecated     public void cardinality() {         assertEquals(1, CollectionUtils.cardinality(1, iterableA));         assertEquals(2, CollectionUtils.cardinality(2, iterableA));         assertEquals(3, CollectionUtils.cardinality(3, iterableA));         assertEquals(4, CollectionUtils.cardinality(4, iterableA));         assertEquals(0, CollectionUtils.cardinality(5, iterableA));          assertEquals(0, CollectionUtils.cardinality(1L, iterableB));         assertEquals(4, CollectionUtils.cardinality(2L, iterableB));         assertEquals(3, CollectionUtils.cardinality(3L, iterableB));         assertEquals(2, CollectionUtils.cardinality(4L, iterableB));         assertEquals(1, CollectionUtils.cardinality(5L, iterableB));          // Ensure that generic bounds accept valid parameters, but return         // expected results         // e.g. no longs in the "int" Iterable<Number>, and vice versa.         assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));         assertEquals(0, CollectionUtils.cardinality(2, iterableB2));          final Set<String> set = new HashSet<>();         set.add("A");         set.add("C");         set.add("E");         set.add("E");         assertEquals(1, CollectionUtils.cardinality("A", set));         assertEquals(0, CollectionUtils.cardinality("B", set));         assertEquals(1, CollectionUtils.cardinality("C", set));         assertEquals(0, CollectionUtils.cardinality("D", set));         assertEquals(1, CollectionUtils.cardinality("E", set));          final Bag<String> bag = new HashBag<>();         bag.add("A", 3);         bag.add("C");         bag.add("E");         bag.add("E");         assertEquals(3, CollectionUtils.cardinality("A", bag));         assertEquals(0, CollectionUtils.cardinality("B", bag));         assertEquals(1, CollectionUtils.cardinality("C", bag));         assertEquals(0, CollectionUtils.cardinality("D", bag));         assertEquals(2, CollectionUtils.cardinality("E", bag));     }      @Test     @Deprecated     public void cardinalityOfNull() {         final List<String> list = new ArrayList<>();         assertEquals(0, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertNull(freq.get(null));         }         list.add("A");         assertEquals(0, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertNull(freq.get(null));         }         list.add(null);         assertEquals(1, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(1), freq.get(null));         }         list.add("B");         assertEquals(1, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(1), freq.get(null));         }         list.add(null);         assertEquals(2, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(2), freq.get(null));         }         list.add("B");         assertEquals(2, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(2), freq.get(null));         }         list.add(null);         assertEquals(3, CollectionUtils.cardinality(null, list));         {             final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);             assertEquals(Integer.valueOf(3), freq.get(null));         }     }      @Test     public void containsAll() {         final Collection<String> empty = new ArrayList<>(0);         final Collection<String> one = new ArrayList<>(1);         one.add("1");         final Collection<String> two = new ArrayList<>(1);         two.add("2");         final Collection<String> three = new ArrayList<>(1);         three.add("3");         final Collection<String> odds = new ArrayList<>(2);         odds.add("1");         odds.add("3");         final Collection<String> multiples = new ArrayList<>(3);         multiples.add("1");         multiples.add("3");         multiples.add("1");          assertFalse("containsAll({1},{1,3}) should return false.", CollectionUtils.containsAll(one, odds));         assertTrue("containsAll({1,3},{1}) should return true.", CollectionUtils.containsAll(odds, one));         assertFalse("containsAll({3},{1,3}) should return false.", CollectionUtils.containsAll(three, odds));         assertTrue("containsAll({1,3},{3}) should return true.", CollectionUtils.containsAll(odds, three));         assertTrue("containsAll({2},{2}) should return true.", CollectionUtils.containsAll(two, two));         assertTrue("containsAll({1,3},{1,3}) should return true.", CollectionUtils.containsAll(odds, odds));          assertFalse("containsAll({2},{1,3}) should return false.", CollectionUtils.containsAll(two, odds));         assertFalse("containsAll({1,3},{2}) should return false.", CollectionUtils.containsAll(odds, two));         assertFalse("containsAll({1},{3}) should return false.", CollectionUtils.containsAll(one, three));         assertFalse("containsAll({3},{1}) should return false.", CollectionUtils.containsAll(three, one));         assertTrue("containsAll({1,3},{}) should return true.", CollectionUtils.containsAll(odds, empty));         assertFalse("containsAll({},{1,3}) should return false.", CollectionUtils.containsAll(empty, odds));         assertTrue("containsAll({},{}) should return true.", CollectionUtils.containsAll(empty, empty));          assertTrue("containsAll({1,3},{1,3,1}) should return true.", CollectionUtils.containsAll(odds, multiples));         assertTrue("containsAll({1,3,1},{1,3,1}) should return true.", CollectionUtils.containsAll(odds, odds));     }      @Test     public void containsAnyInCollection() {         final Collection<String> empty = new ArrayList<>(0);         final Collection<String> one = new ArrayList<>(1);         one.add("1");         final Collection<String> two = new ArrayList<>(1);         two.add("2");         final Collection<String> three = new ArrayList<>(1);         three.add("3");         final Collection<String> odds = new ArrayList<>(2);         odds.add("1");         odds.add("3");          assertTrue("containsAny({1},{1,3}) should return true.", CollectionUtils.containsAny(one, odds));         assertTrue("containsAny({1,3},{1}) should return true.", CollectionUtils.containsAny(odds, one));         assertTrue("containsAny({3},{1,3}) should return true.", CollectionUtils.containsAny(three, odds));         assertTrue("containsAny({1,3},{3}) should return true.", CollectionUtils.containsAny(odds, three));         assertTrue("containsAny({2},{2}) should return true.", CollectionUtils.containsAny(two, two));         assertTrue("containsAny({1,3},{1,3}) should return true.", CollectionUtils.containsAny(odds, odds));          assertFalse("containsAny({2},{1,3}) should return false.", CollectionUtils.containsAny(two, odds));         assertFalse("containsAny({1,3},{2}) should return false.", CollectionUtils.containsAny(odds, two));         assertFalse("containsAny({1},{3}) should return false.", CollectionUtils.containsAny(one, three));         assertFalse("containsAny({3},{1}) should return false.", CollectionUtils.containsAny(three, one));         assertFalse("containsAny({1,3},{}) should return false.", CollectionUtils.containsAny(odds, empty));         assertFalse("containsAny({},{1,3}) should return false.", CollectionUtils.containsAny(empty, odds));         assertFalse("containsAny({},{}) should return false.", CollectionUtils.containsAny(empty, empty));     }      @Test(expected = NullPointerException.class)     public void testContainsAnyNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.containsAny(null, list);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final Collection<String> list2 = null;         CollectionUtils.containsAny(list, list2);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyNullColl3() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final String[] array = null;         CollectionUtils.containsAny(list, array);     }      @Test     public void containsAnyInArray() {         final Collection<String> empty = new ArrayList<>(0);         final String[] emptyArr = {};         final Collection<String> one = new ArrayList<>(1);         one.add("1");         final String[] oneArr = {"1"};         final Collection<String> two = new ArrayList<>(1);         two.add("2");         final String[] twoArr = {"2"};         final Collection<String> three = new ArrayList<>(1);         three.add("3");         final String[] threeArr = {"3"};         final Collection<String> odds = new ArrayList<>(2);         odds.add("1");         odds.add("3");         final String[] oddsArr = {"1", "3"};          assertTrue("containsAny({1},{1,3}) should return true.", CollectionUtils.containsAny(one, oddsArr));         assertTrue("containsAny({1,3},{1}) should return true.", CollectionUtils.containsAny(odds, oneArr));         assertTrue("containsAny({3},{1,3}) should return true.", CollectionUtils.containsAny(three, oddsArr));         assertTrue("containsAny({1,3},{3}) should return true.", CollectionUtils.containsAny(odds, threeArr));         assertTrue("containsAny({2},{2}) should return true.", CollectionUtils.containsAny(two, twoArr));         assertTrue("containsAny({1,3},{1,3}) should return true.", CollectionUtils.containsAny(odds, oddsArr));          assertFalse("containsAny({2},{1,3}) should return false.", CollectionUtils.containsAny(two, oddsArr));         assertFalse("containsAny({1,3},{2}) should return false.", CollectionUtils.containsAny(odds, twoArr));         assertFalse("containsAny({1},{3}) should return false.", CollectionUtils.containsAny(one, threeArr));         assertFalse("containsAny({3},{1}) should return false.", CollectionUtils.containsAny(three, oneArr));         assertFalse("containsAny({1,3},{}) should return false.", CollectionUtils.containsAny(odds, emptyArr));         assertFalse("containsAny({},{1,3}) should return false.", CollectionUtils.containsAny(empty, oddsArr));         assertFalse("containsAny({},{}) should return false.", CollectionUtils.containsAny(empty, emptyArr));     }      @Test(expected = NullPointerException.class)     public void testContainsAnyInArrayNullColl1() {         final String[] oneArr = {"1"};         CollectionUtils.containsAny(null, oneArr);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyInArrayNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final Collection<String> list2 = null;         CollectionUtils.containsAny(list, list2);     }      @Test(expected = NullPointerException.class)     public void testContainsAnyInArrayNullArray() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         final String[] array = null;         CollectionUtils.containsAny(list, array);     }      @Test     public void union() {         final Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq.get(1));         assertEquals(Integer.valueOf(4), freq.get(2));         assertEquals(Integer.valueOf(3), freq.get(3));         assertEquals(Integer.valueOf(4), freq.get(4));         assertEquals(Integer.valueOf(1), freq.get(5));          final Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertEquals(Integer.valueOf(1), freq2.get(1));         assertEquals(Integer.valueOf(4), freq2.get(2));         assertEquals(Integer.valueOf(3), freq2.get(3));         assertEquals(Integer.valueOf(4), freq2.get(4));         assertEquals(Integer.valueOf(1), freq2.get(5));     }      @Test(expected = NullPointerException.class)     public void testUnionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.union(null, list);     }      @Test(expected = NullPointerException.class)     public void testUnionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.union(list, null);     }      @Test     public void intersection() {         final Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertNull(freq.get(1));         assertEquals(Integer.valueOf(2), freq.get(2));         assertEquals(Integer.valueOf(3), freq.get(3));         assertEquals(Integer.valueOf(2), freq.get(4));         assertNull(freq.get(5));          final Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertNull(freq2.get(1));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertEquals(Integer.valueOf(3), freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(4));         assertNull(freq2.get(5));     }      @Test(expected = NullPointerException.class)     public void testIntersectionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.intersection(null, list);     }      @Test(expected = NullPointerException.class)     public void testIntersectionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.intersection(list, null);     }      @Test     public void disjunction() {         final Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq.get(1));         assertEquals(Integer.valueOf(2), freq.get(2));         assertNull(freq.get(3));         assertEquals(Integer.valueOf(2), freq.get(4));         assertEquals(Integer.valueOf(1), freq.get(5));          final Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertEquals(Integer.valueOf(1), freq2.get(1));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertNull(freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(4));         assertEquals(Integer.valueOf(1), freq2.get(5));     }      @Test(expected = NullPointerException.class)     public void testDisjunctionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.disjunction(null, list);     }      @Test(expected = NullPointerException.class)     public void testDisjunctionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.disjunction(list, null);     }      @Test     public void testDisjunctionAsUnionMinusIntersection() {         final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);         final Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);         final Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);         assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));     }      @Test     public void testDisjunctionAsSymmetricDifference() {         final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);         final Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);         final Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);         assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));     }      @Test     public void testSubtract() {         final Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);         final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq.get(1));         assertNull(freq.get(2));         assertNull(freq.get(3));         assertEquals(Integer.valueOf(2), freq.get(4));         assertNull(freq.get(5));          final Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);         assertEquals(Integer.valueOf(1), freq2.get(5));         assertNull(freq2.get(4));         assertNull(freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertNull(freq2.get(1));     }      @Test(expected = NullPointerException.class)     public void testSubtractNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.subtract(null, list);     }      @Test(expected = NullPointerException.class)     public void testSubtractNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.subtract(list, null);     }      @Test     public void testSubtractWithPredicate() {         // greater than 3         final Predicate<Number> predicate = n -> n.longValue() > 3L;          final Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);         assertEquals(Integer.valueOf(1), freq2.get(1));         assertEquals(Integer.valueOf(2), freq2.get(2));         assertEquals(Integer.valueOf(3), freq2.get(3));         assertEquals(Integer.valueOf(2), freq2.get(4));         assertNull(freq2.get(5));     }      @Test     public void testIsSubCollectionOfSelf() {         assertTrue(CollectionUtils.isSubCollection(collectionA, collectionA));         assertTrue(CollectionUtils.isSubCollection(collectionB, collectionB));     }      @Test     public void testIsSubCollection() {         assertFalse(CollectionUtils.isSubCollection(collectionA, collectionC));         assertFalse(CollectionUtils.isSubCollection(collectionC, collectionA));     }      @Test     public void testIsSubCollection2() {         final Collection<Integer> c = new ArrayList<>();         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(1);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(2);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(2);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(3);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(3);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(3);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertFalse(CollectionUtils.isSubCollection(collectionA, c));         c.add(4);         assertTrue(CollectionUtils.isSubCollection(c, collectionA));         assertTrue(CollectionUtils.isSubCollection(collectionA, c));         c.add(5);         assertFalse(CollectionUtils.isSubCollection(c, collectionA));         assertTrue(CollectionUtils.isSubCollection(collectionA, c));     }      @Test(expected = NullPointerException.class)     public void testIsSubCollectionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isSubCollection(null, list);     }      @Test(expected = NullPointerException.class)     public void testIsSubCollectionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isSubCollection(list, null);     }      @Test     public void testIsEqualCollectionToSelf() {         assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA));         assertTrue(CollectionUtils.isEqualCollection(collectionB, collectionB));     }      @Test     public void testIsEqualCollection() {         assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionC));         assertFalse(CollectionUtils.isEqualCollection(collectionC, collectionA));     }      @Test     public void testIsEqualCollectionReturnsFalse() {         final List<Integer> b = new ArrayList<>(collectionA);         // remove an extra '2', and add a 5.  This will increase the size of the cardinality         b.remove(1);         b.add(5);         assertFalse(CollectionUtils.isEqualCollection(collectionA, b));         assertFalse(CollectionUtils.isEqualCollection(b, collectionA));     }      @Test     public void testIsEqualCollection2() {         final Collection<String> a = new ArrayList<>();         final Collection<String> b = new ArrayList<>();         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));         a.add("1");         assertFalse(CollectionUtils.isEqualCollection(a, b));         assertFalse(CollectionUtils.isEqualCollection(b, a));         b.add("1");         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));         a.add("2");         assertFalse(CollectionUtils.isEqualCollection(a, b));         assertFalse(CollectionUtils.isEqualCollection(b, a));         b.add("2");         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));         a.add("1");         assertFalse(CollectionUtils.isEqualCollection(a, b));         assertFalse(CollectionUtils.isEqualCollection(b, a));         b.add("1");         assertTrue(CollectionUtils.isEqualCollection(a, b));         assertTrue(CollectionUtils.isEqualCollection(b, a));     }      @Test     public void testIsEqualCollectionEquator() {         final Collection<Integer> collB = CollectionUtils.collect(collectionB, TRANSFORM_TO_INTEGER);          // odd / even equator         final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();             }         };          assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA, e));         assertTrue(CollectionUtils.isEqualCollection(collectionA, collB, e));         assertTrue(CollectionUtils.isEqualCollection(collB, collectionA, e));          final Equator<Number> defaultEquator = DefaultEquator.defaultEquator();         assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionB, defaultEquator));         assertFalse(CollectionUtils.isEqualCollection(collectionA, collB, defaultEquator));     }      @Test(expected=NullPointerException.class)     public void testIsEqualCollectionNullEquator() {         CollectionUtils.isEqualCollection(collectionA, collectionA, null);     }      @Test     public void testHashCode() {         final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1 % 2 == 0 ^ o2 % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o == null ? 0 : Objects.hashCode(o);             }         };          assertEquals(collectionA.hashCode(), CollectionUtils.hashCode(collectionA, e));     }      @Test     public void testHashCodeNullCollection() {         final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1 % 2 == 0 ^ o2 % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o == null ? 0 : Objects.hashCode(o);             }         };          final Collection<Integer> collection = null;         assertEquals(0, CollectionUtils.hashCode(collection, e));     }      @Test(expected=NullPointerException.class)     public void testHashCodeNullEquator() {         CollectionUtils.hashCode(collectionB, null);     }      @Test(expected = NullPointerException.class)     public void testIsEqualCollectionNullColl1() {         final Collection<Integer> list = new ArrayList<>(1);         list.add(1);          final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();             }         };          CollectionUtils.isEqualCollection(null, list, e);     }      @Test(expected = NullPointerException.class)     public void testIsEqualCollectionNullColl2() {         final Collection<Integer> list = new ArrayList<>(1);         list.add(1);          final Equator<Integer> e = new Equator<Integer>() {             @Override             public boolean equate(final Integer o1, final Integer o2) {                 if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {                     return false;                 }                 return true;             }              @Override             public int hash(final Integer o) {                 return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();             }         };          CollectionUtils.isEqualCollection(list, null, e);     }      @Test     public void testIsProperSubCollection() {         final Collection<String> a = new ArrayList<>();         final Collection<String> b = new ArrayList<>();         assertFalse(CollectionUtils.isProperSubCollection(a, b));         b.add("1");         assertTrue(CollectionUtils.isProperSubCollection(a, b));         assertFalse(CollectionUtils.isProperSubCollection(b, a));         assertFalse(CollectionUtils.isProperSubCollection(b, b));         assertFalse(CollectionUtils.isProperSubCollection(a, a));         a.add("1");         a.add("2");         b.add("2");         assertFalse(CollectionUtils.isProperSubCollection(b, a));         assertFalse(CollectionUtils.isProperSubCollection(a, b));         a.add("1");         assertTrue(CollectionUtils.isProperSubCollection(b, a));         assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.intersection(collectionA, collectionC), collectionA));         assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.subtract(a, b), a));         assertFalse(CollectionUtils.isProperSubCollection(a, CollectionUtils.subtract(a, b)));     }      @Test(expected = NullPointerException.class)     public void testIsProperSubCollectionNullColl1() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isProperSubCollection(null, list);     }      @Test(expected = NullPointerException.class)     public void testIsProperSubCollectionNullColl2() {         final Collection<String> list = new ArrayList<>(1);         list.add("1");         CollectionUtils.isProperSubCollection(list, null);     }      @Test     @Deprecated     public void find() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         Integer test = CollectionUtils.find(collectionA, testPredicate);         assertEquals(4, (int) test);         testPredicate = equalPredicate((Number) 45);         test = CollectionUtils.find(collectionA, testPredicate);         assertNull(test);         assertNull(CollectionUtils.find(null, testPredicate));         assertNull(CollectionUtils.find(collectionA, null));     }      @Test     @Deprecated     public void forAllDoCollection() {         final Closure<Collection<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<Collection<Integer>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionC);         Closure<Collection<Integer>> resultClosure = CollectionUtils.forAllDo(col, testClosure);         assertSame(testClosure, resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         // fix for various java 1.6 versions: keep the cast         resultClosure = CollectionUtils.forAllDo(col, (Closure<Collection<Integer>>) null);         assertNull(resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         resultClosure = CollectionUtils.forAllDo((Collection<Collection<Integer>>) null, testClosure);         col.add(null);         // null should be OK         CollectionUtils.forAllDo(col, testClosure);     }      @Test     @Deprecated     public void forAllDoIterator() {         final Closure<Collection<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<Collection<Integer>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionC);         Closure<Collection<Integer>> resultClosure = CollectionUtils.forAllDo(col.iterator(), testClosure);         assertSame(testClosure, resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         // fix for various java 1.6 versions: keep the cast         resultClosure = CollectionUtils.forAllDo(col.iterator(), (Closure<Collection<Integer>>) null);         assertNull(resultClosure);         assertTrue(collectionA.isEmpty() && collectionC.isEmpty());         resultClosure = CollectionUtils.forAllDo((Iterator<Collection<Integer>>) null, testClosure);         col.add(null);         // null should be OK         CollectionUtils.forAllDo(col.iterator(), testClosure);     }      @Test(expected = FunctorException.class)     @Deprecated     public void forAllDoFailure() {         final Closure<String> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<String> col = new ArrayList<>();         col.add("x");         CollectionUtils.forAllDo(col, testClosure);     }      @Test     @Deprecated     public void forAllButLastDoCollection() {         final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<? extends Number>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionB);         List<? extends Number> lastElement = CollectionUtils.forAllButLastDo(col, testClosure);         assertSame(lastElement, collectionB);         assertTrue(collectionA.isEmpty() && !collectionB.isEmpty());          col.clear();         col.add(collectionB);         lastElement = CollectionUtils.forAllButLastDo(col, testClosure);         assertSame(lastElement, collectionB);         assertFalse(collectionB.isEmpty());          col.clear();         lastElement = CollectionUtils.forAllButLastDo(col, testClosure);         assertNull(lastElement);          final Collection<String> strings = Arrays.asList("a", "b", "c");         final StringBuffer result = new StringBuffer();         result.append(CollectionUtils.forAllButLastDo(strings, (Closure<String>) input -> result.append(input+";")));         assertEquals("a;b;c", result.toString());          final Collection<String> oneString = Arrays.asList("a");         final StringBuffer resultOne = new StringBuffer();         resultOne.append(CollectionUtils.forAllButLastDo(oneString, (Closure<String>) input -> resultOne.append(input+";")));         assertEquals("a", resultOne.toString());         assertNull(CollectionUtils.forAllButLastDo(strings, (Closure<String>) null)); // do not remove cast         assertNull(CollectionUtils.forAllButLastDo((Collection<String>) null, (Closure<String>) null)); // do not remove cast     }      @Test     @Deprecated     public void forAllButLastDoIterator() {         final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<? extends Number>> col = new ArrayList<>();         col.add(collectionA);         col.add(collectionB);         final List<? extends Number> lastElement = CollectionUtils.forAllButLastDo(col.iterator(), testClosure);         assertSame(lastElement, collectionB);         assertTrue(collectionA.isEmpty() && !collectionB.isEmpty());          assertNull(CollectionUtils.forAllButLastDo(col.iterator(), (Closure<List<? extends Number>>) null));         assertNull(CollectionUtils.forAllButLastDo((Iterator<String>) null, (Closure<String>) null)); // do not remove cast     }      @Test     public void getFromMap() {         // Unordered map, entries exist         final Map<String, String> expected = new HashMap<>();         expected.put("zeroKey", "zero");         expected.put("oneKey", "one");          final Map<String, String> found = new HashMap<>();         Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);         found.put(entry.getKey(), entry.getValue());         entry = CollectionUtils.get(expected, 1);         found.put(entry.getKey(), entry.getValue());         assertEquals(expected, found);          // Map index out of range         try {             CollectionUtils.get(expected, 2);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         try {             CollectionUtils.get(expected, -2);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }          // Sorted map, entries exist, should respect order         final SortedMap<String, String> map = new TreeMap<>();         map.put("zeroKey", "zero");         map.put("oneKey", "one");         Map.Entry<String, String> test = CollectionUtils.get(map, 1);         assertEquals("zeroKey", test.getKey());         assertEquals("zero", test.getValue());         test = CollectionUtils.get(map, 0);         assertEquals("oneKey", test.getKey());         assertEquals("one", test.getValue());     }      /**      * Tests that {@link List}s are handled correctly - e.g. using      * {@link List#get(int)}.      */     @Test(expected=IndexOutOfBoundsException.class)     public void getFromList() throws Exception {         // List, entry exists         final List<String> list = createMock(List.class);         expect(list.get(0)).andReturn("zero");         expect(list.get(1)).andReturn("one");         replay();         final String string = CollectionUtils.get(list, 0);         assertEquals("zero", string);         assertEquals("one", CollectionUtils.get(list, 1));         // list, non-existent entry -- IndexOutOfBoundsException         CollectionUtils.get(new ArrayList<>(), 2);     }      @Test     @Deprecated     public void getFromIterator() throws Exception {         // Iterator, entry exists         Iterator<Integer> iterator = iterableA.iterator();         assertEquals(1, (int) CollectionUtils.get(iterator, 0));         iterator = iterableA.iterator();         assertEquals(2, (int) CollectionUtils.get(iterator, 1));          // Iterator, non-existent entry         try {             CollectionUtils.get(iterator, 10);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertFalse(iterator.hasNext());     }      @Test     @Deprecated     public void getFromEnumeration() throws Exception {         // Enumeration, entry exists         final Vector<String> vector = new Vector<>();         vector.addElement("zero");         vector.addElement("one");         Enumeration<String> en = vector.elements();         assertEquals("zero", CollectionUtils.get(en, 0));         en = vector.elements();         assertEquals("one", CollectionUtils.get(en, 1));          // Enumerator, non-existent entry         try {             CollectionUtils.get(en, 3);             fail("Expecting IndexOutOfBoundsException.");         } catch (final IndexOutOfBoundsException e) {             // expected         }         assertFalse(en.hasMoreElements());     }      @Test(expected = IndexOutOfBoundsException.class)     @Deprecated     public void getFromIterable() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         assertEquals("element", CollectionUtils.get(bag, 0));          // Collection, non-existent entry         CollectionUtils.get(bag, 1);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getFromObjectArray() throws Exception {         // Object array, entry exists         final Object[] objArray = new Object[2];         objArray[0] = "zero";         objArray[1] = "one";         assertEquals("zero", CollectionUtils.get(objArray, 0));         assertEquals("one", CollectionUtils.get(objArray, 1));          // Object array, non-existent entry --         // ArrayIndexOutOfBoundsException         CollectionUtils.get(objArray, 2);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getFromPrimitiveArray() throws Exception {         // Primitive array, entry exists         final int[] array = new int[2];         array[0] = 10;         array[1] = 20;         assertEquals(10, CollectionUtils.get(array, 0));         assertEquals(20, CollectionUtils.get(array, 1));          // Object array, non-existent entry --         // ArrayIndexOutOfBoundsException         CollectionUtils.get(array, 2);     }      @Test(expected = IllegalArgumentException.class)     public void getFromObject() throws Exception {         // Invalid object         final Object obj = new Object();         CollectionUtils.get(obj, 0);     }      // -----------------------------------------------------------------------     @Test     public void testSize_List() {         List<String> list = null;         assertEquals(0, CollectionUtils.size(list));         list = new ArrayList<>();         assertEquals(0, CollectionUtils.size(list));         list.add("a");         assertEquals(1, CollectionUtils.size(list));         list.add("b");         assertEquals(2, CollectionUtils.size(list));     }      @Test     public void testSize_Map() {         final Map<String, String> map = new HashMap<>();         assertEquals(0, CollectionUtils.size(map));         map.put("1", "a");         assertEquals(1, CollectionUtils.size(map));         map.put("2", "b");         assertEquals(2, CollectionUtils.size(map));     }      @Test     public void testSize_Array() {         final Object[] objectArray = new Object[0];         assertEquals(0, CollectionUtils.size(objectArray));          final String[] stringArray = new String[3];         assertEquals(3, CollectionUtils.size(stringArray));         stringArray[0] = "a";         stringArray[1] = "b";         stringArray[2] = "c";         assertEquals(3, CollectionUtils.size(stringArray));     }      @Test     public void testSize_PrimitiveArray() {         final int[] intArray = new int[0];         assertEquals(0, CollectionUtils.size(intArray));          final double[] doubleArray = new double[3];         assertEquals(3, CollectionUtils.size(doubleArray));         doubleArray[0] = 0.0d;         doubleArray[1] = 1.0d;         doubleArray[2] = 2.5d;         assertEquals(3, CollectionUtils.size(doubleArray));     }      @Test     public void testSize_Enumeration() {         final Vector<String> list = new Vector<>();         assertEquals(0, CollectionUtils.size(list.elements()));         list.add("a");         assertEquals(1, CollectionUtils.size(list.elements()));         list.add("b");         assertEquals(2, CollectionUtils.size(list.elements()));     }      @Test     public void testSize_Iterator() {         final List<String> list = new ArrayList<>();         assertEquals(0, CollectionUtils.size(list.iterator()));         list.add("a");         assertEquals(1, CollectionUtils.size(list.iterator()));         list.add("b");         assertEquals(2, CollectionUtils.size(list.iterator()));     }      @Test(expected=IllegalArgumentException.class)     public void testSize_Other() {         CollectionUtils.size("not a list");     }      // -----------------------------------------------------------------------     @Test     public void testSizeIsEmpty_Null() {         assertTrue(CollectionUtils.sizeIsEmpty(null));     }      @Test     public void testSizeIsEmpty_List() {         final List<String> list = new ArrayList<>();         assertTrue(CollectionUtils.sizeIsEmpty(list));         list.add("a");         assertFalse(CollectionUtils.sizeIsEmpty(list));     }      @Test     public void testSizeIsEmpty_Map() {         final Map<String, String> map = new HashMap<>();         assertEquals(true, CollectionUtils.sizeIsEmpty(map));         map.put("1", "a");         assertEquals(false, CollectionUtils.sizeIsEmpty(map));     }      @Test     public void testSizeIsEmpty_Array() {         final Object[] objectArray = new Object[0];         assertTrue(CollectionUtils.sizeIsEmpty(objectArray));          final String[] stringArray = new String[3];         assertFalse(CollectionUtils.sizeIsEmpty(stringArray));         stringArray[0] = "a";         stringArray[1] = "b";         stringArray[2] = "c";         assertFalse(CollectionUtils.sizeIsEmpty(stringArray));     }      @Test     public void testSizeIsEmpty_PrimitiveArray() {         final int[] intArray = new int[0];         assertTrue(CollectionUtils.sizeIsEmpty(intArray));          final double[] doubleArray = new double[3];         assertFalse(CollectionUtils.sizeIsEmpty(doubleArray));         doubleArray[0] = 0.0d;         doubleArray[1] = 1.0d;         doubleArray[2] = 2.5d;         assertFalse(CollectionUtils.sizeIsEmpty(doubleArray));     }      @Test     public void testSizeIsEmpty_Enumeration() {         final Vector<String> list = new Vector<>();         assertTrue(CollectionUtils.sizeIsEmpty(list.elements()));         list.add("a");         assertFalse(CollectionUtils.sizeIsEmpty(list.elements()));         final Enumeration<String> en = list.elements();         en.nextElement();         assertTrue(CollectionUtils.sizeIsEmpty(en));     }      @Test     public void testSizeIsEmpty_Iterator() {         final List<String> list = new ArrayList<>();         assertTrue(CollectionUtils.sizeIsEmpty(list.iterator()));         list.add("a");         assertFalse(CollectionUtils.sizeIsEmpty(list.iterator()));         final Iterator<String> it = list.iterator();         it.next();         assertTrue(CollectionUtils.sizeIsEmpty(it));     }      @Test     public void testSizeIsEmpty_Other() {         try {             CollectionUtils.sizeIsEmpty("not a list");             fail("Expecting IllegalArgumentException");         } catch (final IllegalArgumentException ex) {         }     }      // -----------------------------------------------------------------------     @Test     public void testIsEmptyWithEmptyCollection() {         assertTrue(CollectionUtils.isEmpty(new ArrayList<>()));     }      @Test     public void testIsEmptyWithNonEmptyCollection() {         assertFalse(CollectionUtils.isEmpty(Collections.singletonList("item")));     }      @Test     public void testIsEmptyWithNull() {         assertTrue(CollectionUtils.isEmpty(null));     }      @Test     public void testIsNotEmptyWithEmptyCollection() {         assertFalse(CollectionUtils.isNotEmpty(new ArrayList<>()));     }      @Test     public void testIsNotEmptyWithNonEmptyCollection() {         assertTrue(CollectionUtils.isNotEmpty(Collections.singletonList("item")));     }      @Test     public void testIsNotEmptyWithNull() {         assertFalse(CollectionUtils.isNotEmpty(null));     }      // -----------------------------------------------------------------------     private static Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;  //Up to here     @Test     public void filter() {         final List<Integer> ints = new ArrayList<>();         ints.add(1);         ints.add(2);         ints.add(3);         ints.add(3);         final Iterable<Integer> iterable = ints;         assertTrue(CollectionUtils.filter(iterable, EQUALS_TWO));         assertEquals(1, ints.size());         assertEquals(2, (int) ints.get(0));     }      @Test     public void filterNullParameters() throws Exception {         final List<Long> longs = Collections.nCopies(4, 10L);         assertFalse(CollectionUtils.filter(longs, null));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filter(null, EQUALS_TWO));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filter(null, null));         assertEquals(4, longs.size());     }      @Test     public void filterInverse() {         final List<Integer> ints = new ArrayList<>();         ints.add(1);         ints.add(2);         ints.add(3);         ints.add(3);         final Iterable<Integer> iterable = ints;         assertTrue(CollectionUtils.filterInverse(iterable, EQUALS_TWO));         assertEquals(3, ints.size());         assertEquals(1, (int) ints.get(0));         assertEquals(3, (int) ints.get(1));         assertEquals(3, (int) ints.get(2));     }      @Test     public void filterInverseNullParameters() throws Exception {         final List<Long> longs = Collections.nCopies(4, 10L);         assertFalse(CollectionUtils.filterInverse(longs, null));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filterInverse(null, EQUALS_TWO));         assertEquals(4, longs.size());         assertFalse(CollectionUtils.filterInverse(null, null));         assertEquals(4, longs.size());     }      @Test     @Deprecated     public void countMatches() {         assertEquals(4, CollectionUtils.countMatches(iterableB, EQUALS_TWO));         assertEquals(0, CollectionUtils.countMatches(iterableA, null));         assertEquals(0, CollectionUtils.countMatches(null, EQUALS_TWO));         assertEquals(0, CollectionUtils.countMatches(null, null));     }      @Test     @Deprecated     public void exists() {         final List<Integer> list = new ArrayList<>();         assertFalse(CollectionUtils.exists(null, null));         assertFalse(CollectionUtils.exists(list, null));         assertFalse(CollectionUtils.exists(null, EQUALS_TWO));         assertFalse(CollectionUtils.exists(list, EQUALS_TWO));         list.add(1);         list.add(3);         list.add(4);         assertFalse(CollectionUtils.exists(list, EQUALS_TWO));          list.add(2);         assertTrue(CollectionUtils.exists(list, EQUALS_TWO));     }      @Test     public void select() {         final List<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         // Ensure that the collection is the input type or a super type         final Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);         final Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(1, output1.size());         assertEquals(2, output2.iterator().next());     }      @Test     public void selectWithOutputCollections() {         final List<Integer> input = new ArrayList<>();         input.add(1);         input.add(2);         input.add(3);         input.add(4);          final List<Integer> output = new ArrayList<>();         final List<Integer> rejected = new ArrayList<>();          CollectionUtils.select(input, EQUALS_TWO, output, rejected);          // output contains 2         assertEquals(1, output.size());         assertEquals(2, CollectionUtils.extractSingleton(output).intValue());          // rejected contains 1, 3, and 4         final Integer[] expected = {1, 3, 4};         Assert.assertArrayEquals(expected, rejected.toArray());          output.clear();         rejected.clear();         CollectionUtils.select((List<Integer>) null, EQUALS_TWO, output, rejected);         assertTrue(output.isEmpty());         assertTrue(rejected.isEmpty());     }      @Test     public void selectRejected() {         final List<Long> list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         list.add(4L);         final Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);         final Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output2));         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(3, output1.size());         assertTrue(output1.contains(1L));         assertTrue(output1.contains(3L));         assertTrue(output1.contains(4L));     }      @Test     public void collect() {         final Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);         Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);         assertTrue(collection.size() == collectionA.size());         assertCollectResult(collection);          ArrayList<Number> list;         list = CollectionUtils.collect(collectionA, transformer, new ArrayList<Number>());         assertTrue(list.size() == collectionA.size());         assertCollectResult(list);          Iterator<Integer> iterator = null;         list = CollectionUtils.collect(iterator, transformer, new ArrayList<Number>());          iterator = iterableA.iterator();         list = CollectionUtils.collect(iterator, transformer, list);         assertTrue(collection.size() == collectionA.size());         assertCollectResult(collection);          iterator = collectionA.iterator();         collection = CollectionUtils.<Integer, Number>collect(iterator, transformer);         assertTrue(collection.size() == collectionA.size());         assertTrue(collection.contains(2L) && !collection.contains(1));         collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);         assertTrue(collection.size() == 0);          final int size = collectionA.size();         collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);         assertTrue(collectionA.size() == size && collectionA.contains(1));         CollectionUtils.collect(collectionB, null, collectionA);         assertTrue(collectionA.size() == size && collectionA.contains(1));      }      private void assertCollectResult(final Collection<Number> collection) {         assertTrue(collectionA.contains(1) && !collectionA.contains(2L));         assertTrue(collection.contains(2L) && !collection.contains(1));     }      Transformer<Object, Integer> TRANSFORM_TO_INTEGER = input -> Integer.valueOf(((Long) input).intValue());      @Test     public void transform1() {         List<Number> list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         CollectionUtils.transform(list, TRANSFORM_TO_INTEGER);         assertEquals(3, list.size());         assertEquals(1, list.get(0));         assertEquals(2, list.get(1));         assertEquals(3, list.get(2));          list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         CollectionUtils.transform(null, TRANSFORM_TO_INTEGER);         assertEquals(3, list.size());         CollectionUtils.transform(list, null);         assertEquals(3, list.size());         CollectionUtils.transform(null, null);         assertEquals(3, list.size());     }      @Test     public void transform2() {         final Set<Number> set = new HashSet<>();         set.add(1L);         set.add(2L);         set.add(3L);         CollectionUtils.transform(set, input -> 4);         assertEquals(1, set.size());         assertEquals(4, set.iterator().next());     }      // -----------------------------------------------------------------------     @Test     public void addIgnoreNull() {         final Set<String> set = new HashSet<>();         set.add("1");         set.add("2");         set.add("3");         assertFalse(CollectionUtils.addIgnoreNull(set, null));         assertEquals(3, set.size());         assertFalse(CollectionUtils.addIgnoreNull(set, "1"));         assertEquals(3, set.size());         assertTrue(CollectionUtils.addIgnoreNull(set, "4"));         assertEquals(4, set.size());         assertTrue(set.contains("4"));     }      @Test(expected = NullPointerException.class)     public void testAddIgnoreNullNullColl() {         CollectionUtils.addIgnoreNull(null, "1");     }      // -----------------------------------------------------------------------     @Test     public void predicatedCollection() {         final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);         final Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), predicate);         assertTrue("returned object should be a PredicatedCollection", collection instanceof PredicatedCollection);     }      @Test(expected = NullPointerException.class)     public void testPredicatedCollectionNullColl() {         final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);         CollectionUtils.predicatedCollection(null, predicate);     }      @Test(expected = NullPointerException.class)     public void testPredicatedCollectionNullPredicate() {         final Collection<Integer> list = new ArrayList<>();         CollectionUtils.predicatedCollection(list, null);     }      @Test     public void isFull() {         final Set<String> set = new HashSet<>();         set.add("1");         set.add("2");         set.add("3");         assertFalse(CollectionUtils.isFull(set));          final CircularFifoQueue<String> buf = new CircularFifoQueue<>(set);         assertFalse(CollectionUtils.isFull(buf));         buf.remove("2");         assertFalse(CollectionUtils.isFull(buf));         buf.add("2");         assertFalse(CollectionUtils.isFull(buf));     }      @Test(expected = NullPointerException.class)     public void testIsFullNullColl() {         CollectionUtils.isFull(null);     }      @Test     public void isEmpty() {         assertFalse(CollectionUtils.isNotEmpty(null));         assertTrue(CollectionUtils.isNotEmpty(collectionA));     }      @Test     public void maxSize() {         final Set<String> set = new HashSet<>();         set.add("1");         set.add("2");         set.add("3");         assertEquals(-1, CollectionUtils.maxSize(set));          final Queue<String> buf = new CircularFifoQueue<>(set);         assertEquals(3, CollectionUtils.maxSize(buf));         buf.remove("2");         assertEquals(3, CollectionUtils.maxSize(buf));         buf.add("2");         assertEquals(3, CollectionUtils.maxSize(buf));     }      @Test(expected = NullPointerException.class)     public void testMaxSizeNullColl() {         CollectionUtils.maxSize(null);     }      @Test     public void intersectionUsesMethodEquals() {         // Let elta and eltb be objects...         final Integer elta = 17;         final Integer eltb = 17;          // ...which are the same (==)         assertSame(elta, eltb);          // Let cola and colb be collections...         final Collection<Number> cola = new ArrayList<>();         final Collection<Integer> colb = new ArrayList<>();          // ...which contain elta and eltb,         // respectively.         cola.add(elta);         colb.add(eltb);          // Then the intersection of the two         // should contain one element.         final Collection<Number> intersection = CollectionUtils.intersection(cola, colb);         assertEquals(1, intersection.size());          // In practice, this element will be the same (==) as elta         // or eltb, although this isn't strictly part of the         // contract.         final Object eltc = intersection.iterator().next();         assertTrue(eltc == elta && eltc == eltb);          // In any event, this element remains equal,         // to both elta and eltb.         assertEquals(elta, eltc);         assertEquals(eltc, elta);         assertEquals(eltb, eltc);         assertEquals(eltc, eltb);     }      // -----------------------------------------------------------------------     //Up to here     @Test     public void testRetainAll() {         final List<String> base = new ArrayList<>();         base.add("A");         base.add("B");         base.add("C");         final List<Object> sub = new ArrayList<>();         sub.add("A");         sub.add("C");         sub.add("X");          final Collection<String> result = CollectionUtils.retainAll(base, sub);         assertEquals(2, result.size());         assertTrue(result.contains("A"));         assertFalse(result.contains("B"));         assertTrue(result.contains("C"));         assertEquals(3, base.size());         assertTrue(base.contains("A"));         assertTrue(base.contains("B"));         assertTrue(base.contains("C"));         assertEquals(3, sub.size());         assertTrue(sub.contains("A"));         assertTrue(sub.contains("C"));         assertTrue(sub.contains("X"));     }      @Test(expected = NullPointerException.class)     public void testRetainAllNullBaseColl() {         final List<Object> sub = new ArrayList<>();         sub.add("A");         CollectionUtils.retainAll(null, sub);     }      @Test(expected = NullPointerException.class)     public void testRetainAllNullSubColl() {         final List<String> base = new ArrayList<>();         base.add("A");         CollectionUtils.retainAll(base, null);     }      @Test     public void testRemoveRange() {         final List<Integer> list = new ArrayList<>();         list.add(1);         Collection<Integer> result = CollectionUtils.removeRange(list, 0, 0);         assertEquals(1, list.size());         assertEquals(0, result.size());          list.add(2);         list.add(3);         result = CollectionUtils.removeRange(list, 1, 3);         assertEquals(1, list.size());         assertEquals(1, (int) list.get(0));         assertEquals(2, result.size());         assertTrue(result.contains(2));         assertTrue(result.contains(3));     }      @Test(expected=NullPointerException.class)     public void testRemoveRangeNull() {         final Collection<Integer> list = null;         CollectionUtils.removeRange(list, 0, 0);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveRangeStartIndexNegative() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeRange(list, -1, 1);     }      @Test(expected=IllegalArgumentException.class)     public void testRemoveRangeEndIndexNegative() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeRange(list, 0, -1);     }      @Test(expected=IllegalArgumentException.class)     public void testRemoveRangeEndLowStart() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         CollectionUtils.removeRange(list, 1, 0);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveRangeWrongEndIndex() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeRange(list, 0, 2);     }      @Test     public void testRemoveCount() {         final List<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);          Collection<Integer> result = CollectionUtils.removeCount(list, 0, 0);         assertEquals(4, list.size());         assertEquals(0, result.size());          result = CollectionUtils.removeCount(list, 0, 1);         assertEquals(3, list.size());         assertEquals(2, (int) list.get(0));         assertEquals(1, result.size());         assertTrue(result.contains(1));          list.add(5);         list.add(6);         result = CollectionUtils.removeCount(list, 1, 3);          assertEquals(2, list.size());         assertEquals(2, (int) list.get(0));         assertEquals(6, (int) list.get(1));         assertEquals(3, result.size());         assertTrue(result.contains(3));         assertTrue(result.contains(4));         assertTrue(result.contains(5));     }      @Test(expected=NullPointerException.class)     public void testRemoveCountWithNull() {         final Collection<Integer> list = null;         CollectionUtils.removeCount(list, 0, 1);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveCountStartNegative() {         final Collection<Integer> list = new ArrayList<>();         CollectionUtils.removeCount(list, -1, 1);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveCountNegative() {         final Collection<Integer> list = new ArrayList<>();         CollectionUtils.removeCount(list, 0, -1);     }      @Test(expected=IndexOutOfBoundsException.class)     public void testRemoveCountWrongCount() {         final Collection<Integer> list = new ArrayList<>();         list.add(1);         CollectionUtils.removeCount(list, 0, 2);     }      @Test     public void testRemoveAll() {         final List<String> base = new ArrayList<>();         base.add("A");         base.add("B");         base.add("C");         final List<String> sub = new ArrayList<>();         sub.add("A");         sub.add("C");         sub.add("X");          final Collection<String> result = CollectionUtils.removeAll(base, sub);         assertEquals(1, result.size());         assertFalse(result.contains("A"));         assertTrue(result.contains("B"));         assertFalse(result.contains("C"));         assertEquals(3, base.size());         assertTrue(base.contains("A"));         assertTrue(base.contains("B"));         assertTrue(base.contains("C"));         assertEquals(3, sub.size());         assertTrue(sub.contains("A"));         assertTrue(sub.contains("C"));         assertTrue(sub.contains("X"));     }      @Test(expected = NullPointerException.class)     public void testRemoveAllNullBaseColl() {         final List<String> sub = new ArrayList<>();         sub.add("A");         CollectionUtils.removeAll(null, sub);     }      @Test(expected = NullPointerException.class)     public void testRemoveAllNullSubColl() {         final List<String> base = new ArrayList<>();         base.add("A");         CollectionUtils.removeAll(base, null);     }      // -----------------------------------------------------------------------     @Test     public void testTransformedCollection() {         final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();         final Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<>(), transformer);         assertTrue("returned object should be a TransformedCollection", collection instanceof TransformedCollection);     }      @Test(expected = NullPointerException.class)     public void testTransformingCollectionNullColl() {         final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();         CollectionUtils.transformingCollection(null, transformer);     }      @Test(expected = NullPointerException.class)     public void testTransformingCollectionNullTransformer() {         final List<String> list = new ArrayList<>();         CollectionUtils.transformingCollection(list, null);     }      @Test     public void testTransformedCollection_2() {         final List<Object> list = new ArrayList<>();         list.add("1");         list.add("2");         list.add("3");         final Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);         assertTrue(result.contains("1")); // untransformed         assertTrue(result.contains("2")); // untransformed         assertTrue(result.contains("3")); // untransformed     }      @Test     @Deprecated     public void testSynchronizedCollection() {         final Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<>());         assertTrue("Returned object should be a SynchronizedCollection.", col instanceof SynchronizedCollection);         try {             CollectionUtils.synchronizedCollection(null);             fail("Expecting NullPointerException for null collection.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     @Deprecated     public void testUnmodifiableCollection() {         final Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<>());         assertTrue("Returned object should be a UnmodifiableCollection.", col instanceof UnmodifiableCollection);         try {             CollectionUtils.unmodifiableCollection(null);             fail("Expecting NullPointerException for null collection.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void emptyCollection() throws Exception {         final Collection<Number> coll = CollectionUtils.emptyCollection();         assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);     }      @Test     public void emptyIfNull() {         assertTrue(CollectionUtils.emptyIfNull(null).isEmpty());         final Collection<Object> collection = new ArrayList<>();         assertSame(collection, CollectionUtils.emptyIfNull(collection));     }      /**      * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.      * Specifically, it uses mocks to ensure that if the passed in      * {@link Iterable} is a {@link Collection} then      * {@link Collection#addAll(Collection)} is called instead of iterating.      */     @Test     public void addAllForIterable() {         final Collection<Integer> inputCollection = createMock(Collection.class);         final Iterable<Integer> inputIterable = inputCollection;         final Iterable<Long> iterable = createMock(Iterable.class);         final Iterator<Long> iterator = createMock(Iterator.class);         final Collection<Number> c = createMock(Collection.class);          expect(iterable.iterator()).andReturn(iterator);         next(iterator, 1L);         next(iterator, 2L);         next(iterator, 3L);         expect(iterator.hasNext()).andReturn(false);         expect(c.add(1L)).andReturn(true);         expect(c.add(2L)).andReturn(true);         expect(c.add(3L)).andReturn(true);         // Check that the collection is added using         // Collection.addAll(Collection)         expect(c.addAll(inputCollection)).andReturn(true);          // Ensure the method returns false if nothing is added         expect(iterable.iterator()).andReturn(iterator);         next(iterator, 1L);         expect(iterator.hasNext()).andReturn(false);         expect(c.add(1L)).andReturn(false);         expect(c.addAll(inputCollection)).andReturn(false);          replay();         assertTrue(CollectionUtils.addAll(c, iterable));         assertTrue(CollectionUtils.addAll(c, inputIterable));          assertFalse(CollectionUtils.addAll(c, iterable));         assertFalse(CollectionUtils.addAll(c, inputIterable));         verify();     }      @Test     public void addAllForEnumeration() {         final Hashtable<Integer, Integer> h = new Hashtable<>();         h.put(5, 5);         final Enumeration<? extends Integer> enumeration = h.keys();         CollectionUtils.addAll(collectionA, enumeration);         assertTrue(collectionA.contains(5));     }      @Test     public void addAllForElements() {         CollectionUtils.addAll(collectionA, 5);         assertTrue(collectionA.contains(5));     }      @Test(expected = NullPointerException.class)     public void testaddAllNullColl1() {         final List<Integer> list = new ArrayList<>();         CollectionUtils.addAll(null, list);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl2() {         final List<Integer> list = new ArrayList<>();         final Iterable<Integer> list2 = null;         CollectionUtils.addAll(list, list2);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl3() {         final List<Integer> list = new ArrayList<>();         final Iterator<Integer> list2 = null;         CollectionUtils.addAll(list, list2);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl4() {         final List<Integer> list = new ArrayList<>();         final Enumeration<Integer> enumArray = null;         CollectionUtils.addAll(list, enumArray);     }      @Test(expected = NullPointerException.class)     public void testAddAllNullColl5() {         final List<Integer> list = new ArrayList<>();         final Integer[] array = null;         CollectionUtils.addAll(list, array);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getNegative() {         CollectionUtils.get((Object) collectionA, -3);     }      @Test(expected = IndexOutOfBoundsException.class)     public void getPositiveOutOfBounds() {         CollectionUtils.get((Object) collectionA.iterator(), 30);     }      @Test(expected = IllegalArgumentException.class)     public void get1() {         CollectionUtils.get((Object) null, 0);     }      @Test     public void get() {         assertEquals(2, CollectionUtils.get((Object) collectionA, 2));         assertEquals(2, CollectionUtils.get((Object) collectionA.iterator(), 2));         final Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);         assertEquals(map.entrySet().iterator().next(), CollectionUtils.get((Object) map, 0));     }      @Test     public void getIterator() {         final Iterator<Integer> it = collectionA.iterator();         assertEquals(Integer.valueOf(2), CollectionUtils.get((Object) it, 2));         assertTrue(it.hasNext());         assertEquals(Integer.valueOf(4), CollectionUtils.get((Object) it, 6));         assertFalse(it.hasNext());     }      @Test     public void getEnumeration() {         final Vector<Integer> vectorA = new Vector<>(collectionA);         final Enumeration<Integer> e = vectorA.elements();         assertEquals(Integer.valueOf(2), CollectionUtils.get(e, 2));         assertTrue(e.hasMoreElements());         assertEquals(Integer.valueOf(4), CollectionUtils.get(e, 6));         assertFalse(e.hasMoreElements());     }      @Test     public void reverse() {         CollectionUtils.reverseArray(new Object[] {});         final Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);         CollectionUtils.reverseArray(a);         // assume our implementation is correct if it returns the same order as the Java function         Collections.reverse(collectionA);         assertEquals(collectionA, Arrays.asList(a));     }      @Test(expected = NullPointerException.class)     public void testReverseArrayNull() {         CollectionUtils.reverseArray(null);     }      @Test     public void extractSingleton() {         ArrayList<String> coll = null;         try {             CollectionUtils.extractSingleton(coll);             fail("expected NullPointerException from extractSingleton(null)");         } catch (final NullPointerException e) {         }         coll = new ArrayList<>();         try {             CollectionUtils.extractSingleton(coll);             fail("expected IllegalArgumentException from extractSingleton(empty)");         } catch (final IllegalArgumentException e) {         }         coll.add("foo");         assertEquals("foo", CollectionUtils.extractSingleton(coll));         coll.add("bar");         try {             CollectionUtils.extractSingleton(coll);             fail("expected IllegalArgumentException from extractSingleton(size == 2)");         } catch (final IllegalArgumentException e) {         }     }      /**      * Records the next object returned for a mock iterator      */     private <T> void next(final Iterator<T> iterator, final T t) {         expect(iterator.hasNext()).andReturn(true);         expect(iterator.next()).andReturn(t);     }      @Test(expected=NullPointerException.class)     public void collateException0() {         CollectionUtils.collate(null, collectionC);     }      @Test(expected=NullPointerException.class)     public void collateException1() {         CollectionUtils.collate(collectionA, null);     }      @Test(expected=NullPointerException.class)     public void collateException2() {         CollectionUtils.collate(collectionA, collectionC, null);     }      @Test     public void testCollate() {         List<Integer> result = CollectionUtils.collate(emptyCollection, emptyCollection);         assertEquals("Merge empty with empty", 0, result.size());          result = CollectionUtils.collate(collectionA, emptyCollection);         assertEquals("Merge empty with non-empty", collectionA, result);          List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE);         List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD);         assertEquals("Merge two lists 1", result1, result2);          final List<Integer> combinedList = new ArrayList<>(collectionD);         combinedList.addAll(collectionE);         Collections.sort(combinedList);          assertEquals("Merge two lists 2", combinedList, result2);          final Comparator<Integer> reverseComparator =                 ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());          result = CollectionUtils.collate(emptyCollection, emptyCollection, reverseComparator);         assertEquals("Comparator Merge empty with empty", 0, result.size());          Collections.reverse((List<Integer>) collectionD);         Collections.reverse((List<Integer>) collectionE);         Collections.reverse(combinedList);          result1 = CollectionUtils.collate(collectionD, collectionE, reverseComparator);         result2 = CollectionUtils.collate(collectionE, collectionD, reverseComparator);         assertEquals("Comparator Merge two lists 1", result1, result2);         assertEquals("Comparator Merge two lists 2", combinedList, result2);     }      @Test     public void testCollateIgnoreDuplicates() {         final List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE, false);         final List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD, false);         assertEquals("Merge two lists 1 - ignore duplicates", result1, result2);          final Set<Integer> combinedSet = new HashSet<>(collectionD);         combinedSet.addAll(collectionE);         final List<Integer> combinedList = new ArrayList<>(combinedSet);         Collections.sort(combinedList);          assertEquals("Merge two lists 2 - ignore duplicates", combinedList, result2);     }      @Test(expected=NullPointerException.class)     public void testPermutationsWithNullCollection() {         CollectionUtils.permutations(null);     }      @Test     public void testPermutations() {         final List<Integer> sample = collectionA.subList(0, 5);         final Collection<List<Integer>> permutations = CollectionUtils.permutations(sample);          // result size = n!         final int collSize = sample.size();         int factorial = 1;         for (int i = 1; i <= collSize; i++) {             factorial *= i;         }         assertEquals(factorial, permutations.size());     }      @Test     @Deprecated     public void testMatchesAll() {         assertFalse(CollectionUtils.matchesAll(null, null));         assertFalse(CollectionUtils.matchesAll(collectionA, null));          final Predicate<Integer> lessThanFive = object -> object < 5;         assertTrue(CollectionUtils.matchesAll(collectionA, lessThanFive));          final Predicate<Integer> lessThanFour = object -> object < 4;         assertFalse(CollectionUtils.matchesAll(collectionA, lessThanFour));          assertTrue(CollectionUtils.matchesAll(null, lessThanFour));         assertTrue(CollectionUtils.matchesAll(emptyCollection, lessThanFour));     }      @Test     public void testRemoveAllWithEquator() {         final List<String> base = new ArrayList<>();         base.add("AC");         base.add("BB");         base.add("CA");          final List<String> remove = new ArrayList<>();         remove.add("AA");         remove.add("CX");         remove.add("XZ");          // use an equator which compares the second letter only         final Collection<String> result = CollectionUtils.removeAll(base, remove, new Equator<String>() {              @Override             public boolean equate(final String o1, final String o2) {                 return o1.charAt(1) == o2.charAt(1);             }              @Override             public int hash(final String o) {                 return o.charAt(1);             }         });          assertEquals(2, result.size());         assertTrue(result.contains("AC"));         assertTrue(result.contains("BB"));         assertFalse(result.contains("CA"));         assertEquals(3, base.size());         assertTrue(base.contains("AC"));         assertTrue(base.contains("BB"));         assertTrue(base.contains("CA"));         assertEquals(3, remove.size());         assertTrue(remove.contains("AA"));         assertTrue(remove.contains("CX"));         assertTrue(remove.contains("XZ"));          try {             CollectionUtils.removeAll(null, null, DefaultEquator.defaultEquator());             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want          try {             CollectionUtils.removeAll(base, remove, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want     }      @Test     public void testRetainAllWithEquator() {         final List<String> base = new ArrayList<>();         base.add("AC");         base.add("BB");         base.add("CA");          final List<String> retain = new ArrayList<>();         retain.add("AA");         retain.add("CX");         retain.add("XZ");          // use an equator which compares the second letter only         final Collection<String> result = CollectionUtils.retainAll(base, retain, new Equator<String>() {              @Override             public boolean equate(final String o1, final String o2) {                 return o1.charAt(1) == o2.charAt(1);             }              @Override             public int hash(final String o) {                 return o.charAt(1);             }         });         assertEquals(1, result.size());         assertTrue(result.contains("CA"));         assertFalse(result.contains("BB"));         assertFalse(result.contains("AC"));          assertEquals(3, base.size());         assertTrue(base.contains("AC"));         assertTrue(base.contains("BB"));         assertTrue(base.contains("CA"));          assertEquals(3, retain.size());         assertTrue(retain.contains("AA"));         assertTrue(retain.contains("CX"));         assertTrue(retain.contains("XZ"));          try {             CollectionUtils.retainAll(null, null, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want          try {             CollectionUtils.retainAll(base, retain, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.List;  import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.list.PredicatedList; import org.junit.Before; import org.junit.Test;  /**  * Tests for ListUtils.  *  */ public class ListUtilsTest {      private static final String a = "a";     private static final String b = "b";     private static final String c = "c";     private static final String d = "d";     private static final String e = "e";     private static final String x = "x";      private String[] fullArray;     private List<String> fullList;      @Before     public void setUp() {         fullArray = new String[]{a, b, c, d, e};         fullList = new ArrayList<>(Arrays.asList(fullArray));     }      /**      * Tests intersecting a non-empty list with an empty list.      */     @Test     public void testIntersectNonEmptyWithEmptyList() {         final List<String> empty = Collections.<String>emptyList();         assertTrue("result not empty", ListUtils.intersection(empty, fullList).isEmpty());     }      /**      * Tests intersecting a non-empty list with an empty list.      */     @Test     public void testIntersectEmptyWithEmptyList() {         final List<?> empty = Collections.EMPTY_LIST;         assertTrue("result not empty", ListUtils.intersection(empty, empty).isEmpty());     }      /**      * Tests intersecting a non-empty list with an subset of itself.      */     @Test     public void testIntersectNonEmptySubset() {         // create a copy         final List<String> other = new ArrayList<>(fullList);          // remove a few items         assertNotNull(other.remove(0));         assertNotNull(other.remove(1));          // make sure the intersection is equal to the copy         assertEquals(other, ListUtils.intersection(fullList, other));     }      /**      * Tests intersecting a non-empty list with an subset of itself.      */     @Test     public void testIntersectListWithNoOverlapAndDifferentTypes() {         @SuppressWarnings("boxing")         final List<Integer> other = Arrays.asList(1, 23);         assertTrue(ListUtils.intersection(fullList, other).isEmpty());     }      /**      * Tests intersecting a non-empty list with itself.      */     @Test     public void testIntersectListWithSelf() {         assertEquals(fullList, ListUtils.intersection(fullList, fullList));     }      /**      * Tests intersecting two lists in different orders.      */     @Test     public void testIntersectionOrderInsensitivity() {         final List<String> one = new ArrayList<>();         final List<String> two = new ArrayList<>();         one.add("a");         one.add("b");         two.add("a");         two.add("a");         two.add("b");         two.add("b");         assertEquals(ListUtils.intersection(one, two), ListUtils.intersection(two, one));     }      @Test     public void testPredicatedList() {         final Predicate<Object> predicate = o -> o instanceof String;         final List<Object> list = ListUtils.predicatedList(new ArrayList<>(), predicate);         assertTrue("returned object should be a PredicatedList", list instanceof PredicatedList);         try {             ListUtils.predicatedList(new ArrayList<>(), null);             fail("Expecting IllegalArgumentException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }         try {             ListUtils.predicatedList(null, predicate);             fail("Expecting IllegalArgumentException for null list.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testLazyFactoryList() {         final List<Integer> list = ListUtils.lazyList(new ArrayList<Integer>(), new Factory<Integer>() {              private int index;              @Override             public Integer create() {                 index++;                 return Integer.valueOf(index);             }         });          assertNotNull(list.get(5));         assertEquals(6, list.size());          assertNotNull(list.get(5));         assertEquals(6, list.size());     }      @Test     public void testLazyTransformerList() {         final List<Integer> offsets = Arrays.asList(3, 5, 1, 5, 3, 6);         final List<Integer> list = ListUtils.lazyList(new ArrayList<>(), new Transformer<Integer, Integer>() {              private int index;              @Override             public Integer transform(final Integer input) {                 return offsets.get(input) + index++;             }          });          assertNotNull(list.get(5));         assertEquals(6, list.size());          assertNotNull(list.get(5));         assertEquals(6, list.size());     }      @Test     public void testEmptyIfNull() {         assertTrue(ListUtils.emptyIfNull(null).isEmpty());          final List<Long> list = new ArrayList<>();         assertSame(list, ListUtils.emptyIfNull(list));     }      @Test     public void testDefaultIfNull() {         assertTrue(ListUtils.defaultIfNull(null, Collections.emptyList()).isEmpty());          final List<Long> list = new ArrayList<>();         assertSame(list, ListUtils.defaultIfNull(list, Collections.<Long>emptyList()));     }      @Test     public void testEquals() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final List<String> a = new ArrayList<>( data );         final List<String> b = new ArrayList<>( data );          assertEquals(a, b);         assertTrue(ListUtils.isEqualList(a, b));         a.clear();         assertFalse(ListUtils.isEqualList(a, b));         assertFalse(ListUtils.isEqualList(a, null));         assertFalse(ListUtils.isEqualList(null, b));         assertTrue(ListUtils.isEqualList(null, null));     }      @Test     public void testHashCode() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final List<String> a = new ArrayList<>(data);         final List<String> b = new ArrayList<>(data);          assertEquals(a.hashCode(), b.hashCode());         assertEquals(a.hashCode(), ListUtils.hashCodeForList(a));         assertEquals(b.hashCode(), ListUtils.hashCodeForList(b));         assertEquals(ListUtils.hashCodeForList(a), ListUtils.hashCodeForList(b));         a.clear();         assertNotEquals(ListUtils.hashCodeForList(a), ListUtils.hashCodeForList(b));         assertEquals(0, ListUtils.hashCodeForList(null));     }      @Test     public void testRetainAll() {         final List<String> sub = new ArrayList<>();         sub.add(a);         sub.add(b);         sub.add(x);          final List<String> retained = ListUtils.retainAll(fullList, sub);         assertEquals(2, retained.size());         sub.remove(x);         assertEquals(retained, sub);         fullList.retainAll(sub);         assertEquals(retained, fullList);          try {             ListUtils.retainAll(null, null);             fail("expecting NullPointerException");         } catch(final NullPointerException npe){} // this is what we want     }      @Test     public void testRemoveAll() {         final List<String> sub = new ArrayList<>();         sub.add(a);         sub.add(b);         sub.add(x);          final List<String> remainder = ListUtils.removeAll(fullList, sub);         assertEquals(3, remainder.size());         fullList.removeAll(sub);         assertEquals(remainder, fullList);          try {             ListUtils.removeAll(null, null);             fail("expecting NullPointerException");         } catch(final NullPointerException npe) {} // this is what we want     }      @Test     public void testSubtract() {         final List<String> list = new ArrayList<>();         list.add(a);         list.add(b);         list.add(a);         list.add(x);          final List<String> sub = new ArrayList<>();         sub.add(a);          final List<String> result = ListUtils.subtract(list, sub);         assertEquals(3, result.size());          final List<String> expected = new ArrayList<>();         expected.add(b);         expected.add(a);         expected.add(x);          assertEquals(expected, result);          try {             ListUtils.subtract(list, null);             fail("expecting NullPointerException");         } catch(final NullPointerException npe) {} // this is what we want     }      @Test     public void testSubtractNullElement() {         final List<String> list = new ArrayList<>();         list.add(a);         list.add(null);         list.add(null);         list.add(x);          final List<String> sub = new ArrayList<>();         sub.add(null);          final List<String> result = ListUtils.subtract(list, sub);         assertEquals(3, result.size());          final List<String> expected = new ArrayList<>();         expected.add(a);         expected.add(null);         expected.add(x);          assertEquals(expected, result);     }      /**      * Tests the {@code indexOf} method in {@code ListUtils} class..      */     @Test     public void testIndexOf() {         Predicate<String> testPredicate = EqualPredicate.equalPredicate("d");         int index = ListUtils.indexOf(fullList, testPredicate);         assertEquals(d, fullList.get(index));          testPredicate = EqualPredicate.equalPredicate("de");         index = ListUtils.indexOf(fullList, testPredicate);         assertEquals(index, -1);          assertEquals(ListUtils.indexOf(null, testPredicate), -1);         assertEquals(ListUtils.indexOf(fullList, null), -1);     }      @Test     @SuppressWarnings("boxing") // OK in test code     public void testLongestCommonSubsequence() {          try {             ListUtils.longestCommonSubsequence((List<?>) null, null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence(Arrays.asList('A'), null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence(null, Arrays.asList('A'));             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          @SuppressWarnings("unchecked")         List<Character> lcs = ListUtils.longestCommonSubsequence(Collections.EMPTY_LIST, Collections.EMPTY_LIST);         assertEquals(0, lcs.size());          final List<Character> list1 = Arrays.asList('B', 'A', 'N', 'A', 'N', 'A');         final List<Character> list2 = Arrays.asList('A', 'N', 'A', 'N', 'A', 'S');         lcs = ListUtils.longestCommonSubsequence(list1, list2);          List<Character> expected = Arrays.asList('A', 'N', 'A', 'N', 'A');         assertEquals(expected, lcs);          final List<Character> list3 = Arrays.asList('A', 'T', 'A', 'N', 'A');         lcs = ListUtils.longestCommonSubsequence(list1, list3);          expected = Arrays.asList('A', 'A', 'N', 'A');         assertEquals(expected, lcs);          final List<Character> listZorro = Arrays.asList('Z', 'O', 'R', 'R', 'O');         lcs = ListUtils.longestCommonSubsequence(list1, listZorro);          assertTrue(lcs.isEmpty());     }      @Test     public void testLongestCommonSubsequenceWithString() {          try {             ListUtils.longestCommonSubsequence((String) null, null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence("A", null);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.longestCommonSubsequence(null, "A");             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          String lcs = ListUtils.longestCommonSubsequence("", "");         assertEquals(0, lcs.length());          final String banana = "BANANA";         final String ananas = "ANANAS";         lcs = ListUtils.longestCommonSubsequence(banana, ananas);          assertEquals("ANANA", lcs);          final String atana = "ATANA";         lcs = ListUtils.longestCommonSubsequence(banana, atana);          assertEquals("AANA", lcs);          final String zorro = "ZORRO";         lcs = ListUtils.longestCommonSubsequence(banana, zorro);          assertEquals(0, lcs.length());     }      @Test     @SuppressWarnings("boxing") // OK in test code     public void testPartition() {         final List<Integer> strings = new ArrayList<>();         for (int i = 0; i <= 6; i++) {             strings.add(i);         }          final List<List<Integer>> partition = ListUtils.partition(strings, 3);          assertNotNull(partition);         assertEquals(3, partition.size());         assertEquals(1, partition.get(2).size());          try {             ListUtils.partition(null, 3);             fail("failed to check for null argument");         } catch (final NullPointerException e) {}          try {             ListUtils.partition(strings, 0);             fail("failed to check for size argument");         } catch (final IllegalArgumentException e) {}          try {             ListUtils.partition(strings, -10);             fail("failed to check for size argument");         } catch (final IllegalArgumentException e) {}          final List<List<Integer>> partitionMax = ListUtils.partition(strings, Integer.MAX_VALUE);         assertEquals(1, partitionMax.size());         assertEquals(strings.size(), partitionMax.get(0).size());         assertEquals(strings, partitionMax.get(0));     }      private static Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;      @Test     @SuppressWarnings("boxing") // OK in test code     public void testSelect() {         final List<Integer> list = new ArrayList<>();         list.add(1);         list.add(2);         list.add(3);         list.add(4);         // Ensure that the collection is the input type or a super type         final List<Integer> output1 = ListUtils.select(list, EQUALS_TWO);         final List<Number> output2 = ListUtils.<Number>select(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(1, output1.size());         assertEquals(2, output2.iterator().next());     }      @Test     @SuppressWarnings("boxing") // OK in test code     public void testSelectRejected() {         final List<Long> list = new ArrayList<>();         list.add(1L);         list.add(2L);         list.add(3L);         list.add(4L);         final List<Long> output1 = ListUtils.selectRejected(list, EQUALS_TWO);         final List<? extends Number> output2 = ListUtils.selectRejected(list, EQUALS_TWO);         final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());         assertTrue(CollectionUtils.isEqualCollection(output1, output2));         assertTrue(CollectionUtils.isEqualCollection(output1, output3));         assertEquals(4, list.size());         assertEquals(3, output1.size());         assertTrue(output1.contains(1L));         assertTrue(output1.contains(3L));         assertTrue(output1.contains(4L));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.functors.NOPTransformer; import org.apache.commons.collections4.map.HashedMap; import org.apache.commons.collections4.splitmap.TransformedSplitMap; import org.junit.Before; import org.junit.Test;  /**  * Tests for {@link TransformedSplitMap}  *  * @since 4.0  */ @SuppressWarnings("boxing") public class SplitMapUtilsTest {     private Map<String, Integer> backingMap;     private TransformedSplitMap<String, String, String, Integer> transformedMap;      private final Transformer<String, Integer> stringToInt = Integer::valueOf;      @Before     public void setUp() throws Exception {         backingMap = new HashMap<>();         transformedMap = TransformedSplitMap.transformingMap(backingMap, NOPTransformer.<String>nopTransformer(),                 stringToInt);         for (int i = 0; i < 10; i++) {             transformedMap.put(String.valueOf(i), String.valueOf(i));         }     }      // -----------------------------------------------------------------------      @Test     public void testReadableMap() {         final IterableMap<String, Integer> map = SplitMapUtils.readableMap(transformedMap);          // basic         for (int i = 0; i < 10; i++) {             assertFalse(map.containsValue(String.valueOf(i)));             assertEquals(i, map.get(String.valueOf(i)).intValue());         }          // mapIterator         final MapIterator<String, Integer> it = map.mapIterator();         while (it.hasNext()) {             final String k = it.next();             assertEquals(k, it.getKey());             assertEquals(Integer.valueOf(k), it.getValue());         }          // unmodifiable         assertTrue(map instanceof Unmodifiable);          // check individual operations         int sz = map.size();          attemptPutOperation(() -> map.clear());          assertEquals(sz, map.size());          attemptPutOperation(() -> map.put("foo", 100));          final HashMap<String, Integer> m = new HashMap<>();         m.put("foo", 100);         m.put("bar", 200);         m.put("baz", 300);         attemptPutOperation(() -> map.putAll(m));          // equals, hashcode         final IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);         assertEquals(other, map);         assertEquals(other.hashCode(), map.hashCode());          // remove         for (int i = 0; i < 10; i++) {             assertEquals(i, map.remove(String.valueOf(i)).intValue());             assertEquals(--sz, map.size());         }         assertTrue(map.isEmpty());         assertSame(map, SplitMapUtils.readableMap(map));     }      @Test     public void testAlreadyReadableMap() {         final HashedMap<String, Integer> hashedMap = new HashedMap<>();         assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));     }      @Test     @SuppressWarnings("unchecked")     public void testWritableMap() {         final Map<String, String> map = SplitMapUtils.writableMap(transformedMap);         attemptGetOperation(() -> map.get(null));         attemptGetOperation(() -> map.entrySet());         attemptGetOperation(() -> map.keySet());         attemptGetOperation(() -> map.values());         attemptGetOperation(() -> map.size());         attemptGetOperation(() -> map.isEmpty());         attemptGetOperation(() -> map.containsKey(null));         attemptGetOperation(() -> map.containsValue(null));         attemptGetOperation(() -> map.remove(null));          // equals, hashcode         final Map<String, String> other = SplitMapUtils.writableMap(transformedMap);         assertEquals(other, map);         assertEquals(other.hashCode(), map.hashCode());          // put         int sz = backingMap.size();         assertFalse(backingMap.containsKey("foo"));         map.put("new", "66");         assertEquals(++sz, backingMap.size());          // putall         final Map<String, String> more = new HashMap<>();         more.put("foo", "77");         more.put("bar", "88");         more.put("baz", "99");         map.putAll(more);         assertEquals(sz + more.size(), backingMap.size());          // clear         map.clear();         assertTrue(backingMap.isEmpty());         assertSame(map, SplitMapUtils.writableMap((Put<String, String>) map));     }      @Test     public void testAlreadyWritableMap() {         final HashedMap<String, String> hashedMap = new HashedMap<>();         assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));     }      private void attemptGetOperation(final Runnable r) {         attemptMapOperation("Put exposed as writable Map must not allow Get operations", r);     }      private void attemptPutOperation(final Runnable r) {         attemptMapOperation("Get exposed as writable Map must not allow Put operations", r);     }      private void attemptMapOperation(final String s, final Runnable r) {         try {             r.run();             fail(s);         } catch (final UnsupportedOperationException e) {         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.junit;  import java.util.Locale;  import org.junit.rules.TestRule; import org.junit.runner.Description; import org.junit.runners.model.Statement;  /**  * Sets the default {@code Locale} to the given locale for the duration of the test.  */ public class SetDefaultLocaleTestRule implements TestRule {      private final Locale locale;      public SetDefaultLocaleTestRule(final Locale locale) {         this.locale = locale;     }      @Override     public Statement apply(final Statement base, final Description description) {         return new Statement() {             @Override             public void evaluate() throws Throwable {                 final Locale savedLocale = Locale.getDefault();                 Locale.setDefault(getLocale());                 try {                     base.evaluate();                 } finally {                     Locale.setDefault(savedLocale);                 }             }         };     }      public Locale getLocale() {         return locale;     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.junit;  import java.io.Serializable; import java.util.Comparator;  public final class ObjectToStringComparator implements Comparator<Object>, Serializable {      private static final long serialVersionUID = 1L;      @Override     public int compare(final Object o1, final Object o2) {         if (o1 == null && o2 == null) {             return 0;         }         if (o1 == null) {             return 1;         }         if (o2 == null) {             return -1;         }         return o1.toString().compareTo(o2.toString());     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.collections4.junit;  import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.Locale;  import org.apache.commons.lang3.reflect.FieldUtils; import org.junit.Rule; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  @RunWith(Parameterized.class) public abstract class AbstractAvailableLocalesTest {  //    public static List<Object[]> combine(final Object[] objects, final List<Locale> locales) { //        final List<Object[]> result = new ArrayList<>(objects.length * locales.size()); //        Arrays.stream(objects).forEachOrdered(object -> locales.stream().forEachOrdered(locale -> result.add(new Object[] { object, locale }))); //        return result; //    } // //    public static List<Object[]> combine(final Object[] objects, final Locale[] locales) { //        final List<Object[]> result = new ArrayList<>(objects.length * locales.length); //        Arrays.stream(objects).forEachOrdered(object -> Arrays.stream(locales).forEachOrdered(locale -> result.add(new Object[] { object, locale }))); //        return result; //    }  //    public static List<Object[]> combineAvailableLocales(final Object[] objects) { //        return combine(objects, getSortedAvailableLocales()); //    } // //    public static List<Object[]> combineDeclaredLocales(final Object[] objects) { //        return combine(objects, getSortedDeclaredLocales()); //    }      @Parameters(name = "{0}")     public static Locale[] getSortedAvailableLocales() {         final Locale[] availableLocales = Locale.getAvailableLocales();         Arrays.sort(availableLocales, new ObjectToStringComparator());         return availableLocales;     }      public static List<Locale> getSortedDeclaredLocales() {         final Field[] allFields = FieldUtils.getAllFields(Locale.class);         final List<Locale> availableLocales = new ArrayList<>(allFields.length);         for (final Field field : allFields) {             final int modifiers = field.getModifiers();             if (field.getType() == Locale.class && Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {                 try {                     availableLocales.add((Locale) field.get(Locale.class));                 } catch (IllegalArgumentException | IllegalAccessException e) {                     throw new IllegalStateException("Field " + field, e);                 }             }         }         Collections.sort(availableLocales, new ObjectToStringComparator());         return availableLocales;     }      private final Locale locale;      @Rule     public final SetDefaultLocaleTestRule rule;      public AbstractAvailableLocalesTest(final Locale locale)  {         this.locale = locale;         this.rule = new SetDefaultLocaleTestRule(locale);     }      public Locale getLocale() {         return locale;     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link SynchronizedCollection} implementation.  *  * @since 3.1  */ public class SynchronizedCollectionTest<E> extends AbstractCollectionTest<E> {      public SynchronizedCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<E> makeObject() {         return SynchronizedCollection.synchronizedCollection(new ArrayList<E>());     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SynchronizedCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/SynchronizedCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link PredicatedCollection} implementation.  *  * @since 3.0  */ public class PredicatedCollectionTest<E> extends AbstractCollectionTest<E> {      public PredicatedCollectionTest(final String name) {         super(name);     }     //------------------------------------------------------------------------     protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected Collection<E> decorateCollection(                 final Collection<E> collection, final Predicate<E> predicate) {         return PredicatedCollection.predicatedCollection(collection, predicate);     }      @Override     public Collection<E> makeObject() {         return decorateCollection(new ArrayList<E>(), truePredicate);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] { "1", "3", "5", "7", "2", "4", "6" };     }      @Override     public Collection<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return decorateCollection(list, truePredicate);     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      //-----------------------------------------------------------------------     protected Predicate<E> testPredicate =         o -> o instanceof String;      public Collection<E> makeTestCollection() {         return decorateCollection(new ArrayList<E>(), testPredicate);     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final Collection<E> c = makeTestCollection();         final Integer i = 3;         try {             c.add((E) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertFalse("Collection shouldn't contain illegal element", c.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalAddAll() {         final Collection<E> c = makeTestCollection();         final List<E> elements = new ArrayList<>();         elements.add((E) "one");         elements.add((E) "two");         elements.add((E) Integer.valueOf(3));         elements.add((E) "four");         try {             c.addAll(elements);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertFalse("Collection shouldn't contain illegal element", c.contains("one"));         assertFalse("Collection shouldn't contain illegal element", c.contains("two"));         assertFalse("Collection shouldn't contain illegal element", c.contains(3));         assertFalse("Collection shouldn't contain illegal element", c.contains("four"));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;  import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableCollection} implementation.  *  * @since 3.0  */ public class UnmodifiableCollectionTest<E> extends AbstractCollectionTest<E> {      public UnmodifiableCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<E> makeObject() {         return UnmodifiableCollection.unmodifiableCollection(new ArrayList<E>());     }      @Override     public Collection<E> makeFullCollection() {         final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));         return UnmodifiableCollection.unmodifiableCollection(list);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Collection<E> coll = makeFullCollection();         assertSame(coll, UnmodifiableCollection.unmodifiableCollection(coll));          try {             UnmodifiableCollection.unmodifiableCollection(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.function.Predicate;  import org.junit.Assert;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link CompositeCollection} implementation.  *  * @since 3.0  */ public class CompositeCollectionTest<E> extends AbstractCollectionTest<E> {      protected CompositeCollection<E> c;      protected Collection<E> one;      protected Collection<E> two;      public CompositeCollectionTest(final String name) {         super(name);     }      @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     @SuppressWarnings("unchecked")     public E[] getFullElements() {         return (E[]) new Object[] { "1", "2", "3", "4" };     }      //-----------------------------------------------------------------------------     /**      * Run stock collection tests without Mutator, so turn off add, remove      */     @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public Collection<E> makeConfirmedCollection() {         return new HashSet<>();     }      //--------------------------------------------------------------------------      /**      * Full collection should look like a collection with 4 elements      */     @Override     public Collection<E> makeConfirmedFullCollection() {         return new HashSet<>(Arrays.asList(getFullElements()));     }     /**      * Full collection consists of 4 collections, each with one element      */     @Override     public Collection<E> makeFullCollection() {         final CompositeCollection<E> compositeCollection = new CompositeCollection<>();         final E[] elements = getFullElements();         for (final E element : elements) {             final Collection<E> summand = new HashSet<>();             summand.add(element);             compositeCollection.addComposited(summand);         }         return compositeCollection;     }     /**      * Empty collection is empty composite      */     @Override     public Collection<E> makeObject() {         return new CompositeCollection<>();     }      @SuppressWarnings("serial")     protected void setUpMutatorTest() {         setUpTest();         c.setMutator(new CompositeCollection.CollectionMutator<E>() {              @Override             public boolean add(final CompositeCollection<E> composite, final List<Collection<E>> collections, final E obj) {                 for (final Collection<E> coll : collections) {                     coll.add(obj);                 }                 return true;             }              @Override             public boolean addAll(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Collection<? extends E> coll) {                 for (final Collection<E> collection : collections) {                     collection.addAll(coll);                 }                 return true;             }              @Override             public boolean remove(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Object obj) {                 for (final Collection<E> collection : collections) {                     collection.remove(obj);                 }                 return true;             }         });     }      protected void setUpTest() {         c = new CompositeCollection<>();         one = new HashSet<>();         two = new HashSet<>();     }      @SuppressWarnings({ "unchecked", "serial" })     public void testAddAllMutator() {         setUpTest();         c.setMutator(new CompositeCollection.CollectionMutator<E>() {             @Override             public boolean add(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final E obj) {                 for (final Collection<E> collection : collections) {                     collection.add(obj);                 }                 return true;             }              @Override             public boolean addAll(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Collection<? extends E> coll) {                 for (final Collection<E> collection : collections) {                     collection.addAll(coll);                 }                 return true;             }              @Override             public boolean remove(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Object obj) {                 return false;             }         });          c.addComposited(one);         two.add((E) "foo");         c.addAll(two);         assertTrue(c.contains("foo"));         assertTrue(one.contains("foo"));     }      @SuppressWarnings("unchecked")     public void testAddAllToCollection() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one, two);         final Collection<E> toCollection = new HashSet<>(c);         assertTrue(toCollection.containsAll(c));         assertEquals(c.size(), toCollection.size());     }      @SuppressWarnings({ "unchecked", "serial" })     public void testAddMutator() {         setUpTest();         c.setMutator(new CompositeCollection.CollectionMutator<E>() {             @Override             public boolean add(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final E obj) {                 for (final Collection<E> collection : collections) {                     collection.add(obj);                 }                 return true;             }              @Override             public boolean addAll(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Collection<? extends E> coll) {                 for (final Collection<E> collection : collections) {                     collection.addAll(coll);                 }                 return true;             }              @Override             public boolean remove(final CompositeCollection<E> composite,                     final List<Collection<E>> collections, final Object obj) {                 return false;             }         });          c.addComposited(one);         c.add((E) "foo");         assertTrue(c.contains("foo"));         assertTrue(one.contains("foo"));     }       @SuppressWarnings("unchecked")     public void testClear() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one, two);         c.clear();         assertTrue(one.isEmpty());         assertTrue(two.isEmpty());         assertTrue(c.isEmpty());     }      @SuppressWarnings("unchecked")     public void testContainsAll() {         setUpTest();         one.add((E) "1");         two.add((E) "1");         c.addComposited(one);         assertTrue(c.containsAll(two));         assertFalse(c.containsAll(null));     }      public void testAddNullList() {         final ArrayList<String> nullList = null;         final CompositeCollection<String> cc = new CompositeCollection<>();         cc.addComposited(nullList);         Assert.assertEquals(0, cc.size());     }      public void testAddNullLists2Args() {         final ArrayList<String> nullList = null;         final CompositeCollection<String> cc = new CompositeCollection<>();         cc.addComposited(nullList, nullList);         Assert.assertEquals(0, cc.size());     }      public void testAddNullListsVarArgs() {         final ArrayList<String> nullList = null;         final CompositeCollection<String> cc = new CompositeCollection<>();         cc.addComposited(nullList, nullList, nullList);         Assert.assertEquals(0, cc.size());     }      @SuppressWarnings("unchecked")     public void testIsEmpty() {         setUpTest();         assertTrue(c.isEmpty());         final HashSet<E> empty = new HashSet<>();         c.addComposited(empty);         assertTrue(c.isEmpty());         empty.add((E) "a");         assertFalse(c.isEmpty());     }      @SuppressWarnings("unchecked")     public void testIterator() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one);         c.addComposited(two);         final Iterator<E> i = c.iterator();         E next = i.next();         assertTrue(c.contains(next));         assertTrue(one.contains(next));         next = i.next();         i.remove();         assertFalse(c.contains(next));         assertFalse(two.contains(next));     }      @SuppressWarnings("unchecked")     public void testMultipleCollectionsSize() {         setUpTest();         final HashSet<E> set = new HashSet<>();         set.add((E) "a");         set.add((E) "b");         c.addComposited(set);         final HashSet<E> other = new HashSet<>();         other.add((E) "c");         c.addComposited(other);         assertEquals(set.size() + other.size(), c.size());     }      @SuppressWarnings("unchecked")     public void testRemove() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         c.addComposited(one, two);         c.remove("1");         assertFalse(c.contains("1"));         assertFalse(one.contains("1"));         assertFalse(two.contains("1"));     }      @SuppressWarnings("unchecked")     public void testRemoveAll() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         // need separate list to remove, as otherwise one clears itself         final Collection<E> removing = new ArrayList<>(one);         c.addComposited(one, two);         c.removeAll(removing);         assertTrue(!c.contains("1"));         assertTrue(!one.contains("1"));         assertTrue(!two.contains("1"));         c.removeAll(null);         assertFalse(c.contains("1"));         assertFalse(one.contains("1"));         assertFalse(two.contains("1"));     }      /**      * @since 4.4      */     @SuppressWarnings("unchecked")     public void testRemoveIf() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         // need separate list to remove, as otherwise one clears itself         final Predicate<E> predicate = e -> e == "1";         c.addComposited(one, two);         c.removeIf(predicate);         assertTrue(!c.contains("1"));         assertTrue(!one.contains("1"));         assertTrue(!two.contains("1"));         c.removeIf(null);         assertTrue(!c.contains("1"));         assertTrue(!one.contains("1"));         assertTrue(!two.contains("1"));     }      @SuppressWarnings("unchecked")     public void testRemoveComposited() {         setUpMutatorTest();         one.add((E) "1");         two.add((E) "2");         two.add((E) "1");         c.addComposited(one, two);         c.removeComposited(one);         assertTrue(c.contains("1"));         assertEquals(2, c.size());     }      @SuppressWarnings("unchecked")     public void testRetainAll() {         setUpTest();         one.add((E) "1");         one.add((E) "2");         two.add((E) "1");         c.addComposited(one);         c.retainAll(two);         assertFalse(c.contains("2"));         assertFalse(one.contains("2"));         assertTrue(c.contains("1"));         assertTrue(one.contains("1"));         c.retainAll(null);         assertFalse(c.contains("2"));         assertFalse(one.contains("2"));         assertTrue(c.contains("1"));         assertTrue(one.contains("1"));     }      @SuppressWarnings("unchecked")     public void testSize() {         setUpTest();         final HashSet<E> set = new HashSet<>();         set.add((E) "a");         set.add((E) "b");         c.addComposited(set);         assertEquals(set.size(), c.size());     }      @SuppressWarnings("unchecked")     public void testToCollection() {         setUpTest();         one.add((E) "1");         two.add((E) "2");         c.addComposited(one, two);         final Collection<E> foo = c.toCollection();         assertTrue(foo.containsAll(c));         assertEquals(c.size(), foo.size());         one.add((E) "3");         assertFalse(foo.containsAll(c));     }      /**      * Override testUnsupportedRemove, since the default impl expects removeAll,      * retainAll and iterator().remove to throw      */     @Override     public void testUnsupportedRemove() {         resetFull();         try {             getCollection().remove(null);             fail("remove should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CompositeCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.Queue; import java.util.Set;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.Predicate; import org.junit.Assert; import org.junit.Test;  /**  * Tests the PredicatedCollection.Builder class.  *  * @since 4.1  */ public class PredicatedCollectionBuilderTest {      /**      * Verify that passing the Predicate means ending up in the buffer.      */     @Test     public void addPass() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.add("test");         Assert.assertEquals(builder.createPredicatedList().size(), 1);     }      /**      * Verify that failing the Predicate means NOT ending up in the buffer.      */     @Test     public void addFail() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.add((String) null);         Assert.assertTrue(builder.createPredicatedList().isEmpty());          Assert.assertEquals(1, builder.rejectedElements().size());     }      /**      * Verify that only items that pass the Predicate end up in the buffer.      */     @Test     public void addAllPass() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.addAll(Arrays.asList("test1", null, "test2"));         Assert.assertEquals(builder.createPredicatedList().size(), 2);     }      @Test     public void createPredicatedCollectionWithNotNullPredicate() {         final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();         builder.add("test1");         builder.add((String) null);          final List<String> predicatedList = builder.createPredicatedList();         checkPredicatedCollection1(predicatedList);          final Set<String> predicatedSet = builder.createPredicatedSet();         checkPredicatedCollection1(predicatedSet);          final Bag<String> predicatedBag = builder.createPredicatedBag();         checkPredicatedCollection1(predicatedBag);          final Queue<String> predicatedQueue = builder.createPredicatedQueue();         checkPredicatedCollection1(predicatedQueue);     }      private void checkPredicatedCollection1(final Collection<String> collection) {         Assert.assertEquals(1, collection.size());          collection.add("test2");         Assert.assertEquals(2, collection.size());          try {             collection.add(null);             Assert.fail("Expecting IllegalArgumentException for failing predicate!");         } catch (final IllegalArgumentException iae) {             // expected         }     }      @Test     public void createPredicatedCollectionWithPredicate() {         final OddPredicate p = new OddPredicate();         final PredicatedCollection.Builder<Integer> builder = PredicatedCollection.builder(p);          builder.add(1);         builder.add(2);         builder.add(3);          final List<Integer> predicatedList = builder.createPredicatedList();         checkPredicatedCollection2(predicatedList);          final Set<Integer> predicatedSet = builder.createPredicatedSet();         checkPredicatedCollection2(predicatedSet);          final Bag<Integer> predicatedBag = builder.createPredicatedBag();         checkPredicatedCollection2(predicatedBag);          final Queue<Integer> predicatedQueue = builder.createPredicatedQueue();         checkPredicatedCollection2(predicatedQueue);     }      private void checkPredicatedCollection2(final Collection<Integer> collection) {         Assert.assertEquals(2, collection.size());          try {             collection.add(4);             Assert.fail("Expecting IllegalArgumentException for failing predicate!");         } catch (final IllegalArgumentException iae) {         }         Assert.assertEquals(2, collection.size());          collection.add(5);         Assert.assertEquals(3, collection.size());     }      private static class OddPredicate implements Predicate<Integer> {         @Override         public boolean evaluate(final Integer value) {             return value % 2 == 1;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.ConcurrentModificationException; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.Objects; import java.util.function.Predicate;  import org.apache.commons.collections4.AbstractObjectTest;  /**  * Abstract test class for {@link java.util.Collection} methods and contracts.  * <p>  * You should create a concrete subclass of this class to test any custom  * {@link Collection} implementation.  At minimum, you'll have to  * implement the @{@link #makeObject()}, {@link #makeConfirmedCollection()}  * and {@link #makeConfirmedFullCollection()} methods.  * You might want to override some of the additional public methods as well:  * <p>  * <b>Element Population Methods</b>  * <p>  * Override these if your collection restricts what kind of elements are  * allowed (for instance, if {@code null} is not permitted):  * <ul>  * <li>{@link #getFullElements()}  * <li>{@link #getOtherElements()}  * </ul>  * <p>  * <b>Supported Operation Methods</b>  * <p>  * Override these if your collection doesn't support certain operations:  * <ul>  * <li>{@link #isAddSupported()}  * <li>{@link #isRemoveSupported()}  * <li>{@link #areEqualElementsDistinguishable()}  * <li>{@link #isNullSupported()}  * <li>{@link #isFailFastSupported()}  * </ul>  * <p>  * <b>Fixture Methods</b>  * <p>  * Fixtures are used to verify that the operation results in correct state  * for the collection.  Basically, the operation is performed against your  * collection implementation, and an identical operation is performed against a  * <i>confirmed</i> collection implementation.  A confirmed collection  * implementation is something like {@code java.util.ArrayList}, which is  * known to conform exactly to its collection interface's contract.  After the  * operation takes place on both your collection implementation and the  * confirmed collection implementation, the two collections are compared to see  * if their state is identical.  The comparison is usually much more involved  * than a simple {@code equals} test.  This verification is used to ensure  * proper modifications are made along with ensuring that the collection does  * not change when read-only modifications are made.  * <p>  * The {@link #collection} field holds an instance of your collection  * implementation; the {@link #confirmed} field holds an instance of the  * confirmed collection implementation.  The {@link #resetEmpty()} and  * {@link #resetFull()} methods set these fields to empty or full collections,  * so that tests can proceed from a known state.  * <p>  * After a modification operation to both {@link #collection} and  * {@link #confirmed}, the {@link #verify()} method is invoked to compare  * the results.  You may want to override {@link #verify()} to perform  * additional verifications.  For instance, when testing the collection  * views of a map, {@link org.apache.commons.collections4.map.AbstractMapTest AbstractTestMap}  * would override {@link #verify()} to make  * sure the map is changed after the collection view is changed.  * <p>  * If you're extending this class directly, you will have to provide  * implementations for the following:  * <ul>  * <li>{@link #makeConfirmedCollection()}  * <li>{@link #makeConfirmedFullCollection()}  * </ul>  * <p>  * Those methods should provide a confirmed collection implementation  * that's compatible with your collection implementation.  * <p>  * If you're extending {@link org.apache.commons.collections4.list.AbstractListTest AbstractListTest},  * {@link org.apache.commons.collections4.set.AbstractSetTest AbstractTestSet},  * or {@link org.apache.commons.collections4.bag.AbstractBagTest AbstractBagTest},  * you probably don't have to worry about the  * above methods, because those three classes already override the methods  * to provide standard JDK confirmed collections.<P>  * <p>  * <b>Other notes</b>  * <p>  * If your {@link Collection} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link Collection} fails.  *  */ public abstract class AbstractCollectionTest<E> extends AbstractObjectTest {      //     // NOTE:     //     // Collection doesn't define any semantics for equals, and recommends you     // use reference-based default behavior of Object.equals.  (And a test for     // that already exists in AbstractTestObject).  Tests for equality of lists, sets     // and bags will have to be written in test subclasses.  Thus, there is no     // tests on Collection.equals nor any for Collection.hashCode.     //      // These fields are used by reset() and verify(), and any test     // method that tests a modification.      /**      *  A collection instance that will be used for testing.      */     private Collection<E> collection;      /**      *  Confirmed collection.  This is an instance of a collection that is      *  confirmed to conform exactly to the java.util.Collection contract.      *  Modification operations are tested by performing a mod on your      *  collection, performing the exact same mod on an equivalent confirmed      *  collection, and then calling verify() to make sure your collection      *  still matches the confirmed collection.      */     private Collection<E> confirmed;      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Specifies whether equal elements in the collection are, in fact,      *  distinguishable with information not readily available.  That is, if a      *  particular value is to be removed from the collection, then there is      *  one and only one value that can be removed, even if there are other      *  elements which are equal to it.      *      *  <P>In most collection cases, elements are not distinguishable (equal is      *  equal), thus this method defaults to return false.  In some cases,      *  however, they are.  For example, the collection returned from the map's      *  values() collection view are backed by the map, so while there may be      *  two values that are equal, their associated keys are not.  Since the      *  keys are distinguishable, the values are.      *      *  <P>This flag is used to skip some verifications for iterator.remove()      *  where it is impossible to perform an equivalent modification on the      *  confirmed collection because it is not possible to determine which      *  value in the confirmed collection to actually remove.  Tests that      *  override the default (i.e. where equal elements are distinguishable),      *  should provide additional tests on iterator.remove() to make sure the      *  proper elements are removed when remove() is called on the iterator.      **/     public boolean areEqualElementsDistinguishable() {         return false;     }      /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the {@code add} and {@code addAll}      *  operations.<P>      *  Default implementation returns true.  Override if your collection      *  class does not support add or addAll.      */     public boolean isAddSupported() {         return true;     }      /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the {@code remove}, {@code removeAll},      *  {@code retainAll}, {@code clear} and      *  {@code iterator().remove()} methods.      *  Default implementation returns true.  Override if your collection      *  class does not support removal operations.      */     public boolean isRemoveSupported() {         return true;     }      /**      * Returns true to indicate that the collection supports holding null.      * The default implementation returns true;      */     public boolean isNullSupported() {         return true;     }      /**      * Returns true to indicate that the collection supports fail fast iterators.      * The default implementation returns true;      */     public boolean isFailFastSupported() {         return false;     }      /**      * Returns true to indicate that the collection supports equals() comparisons.      * This implementation returns false;      */     @Override     public boolean isEqualsCheckable() {         return false;     }      //-----------------------------------------------------------------------     /**      *  Verifies that {@link #collection} and {@link #confirmed} have      *  identical state.      */     public void verify() {         final int confirmedSize = getConfirmed().size();         assertEquals("Collection size should match confirmed collection's", confirmedSize,                 getCollection().size());         assertEquals("Collection isEmpty() result should match confirmed collection's",                 getConfirmed().isEmpty(), getCollection().isEmpty());          // verify the collections are the same by attempting to match each         // object in the collection and confirmed collection.  To account for         // duplicates and differing orders, each confirmed element is copied         // into an array and a flag is maintained for each element to determine         // whether it has been matched once and only once.  If all elements in         // the confirmed collection are matched once and only once and there         // aren't any elements left to be matched in the collection,         // verification is a success.          // copy each collection value into an array         final Object[] confirmedValues = new Object[confirmedSize];          Iterator<E> iter;          iter = getConfirmed().iterator();         int pos = 0;         while (iter.hasNext()) {             confirmedValues[pos++] = iter.next();         }          // allocate an array of boolean flags for tracking values that have         // been matched once and only once.         final boolean[] matched = new boolean[confirmedSize];          // now iterate through the values of the collection and try to match         // the value with one in the confirmed array.         iter = getCollection().iterator();         while (iter.hasNext()) {             final Object o = iter.next();             boolean match = false;             for (int i = 0; i < confirmedSize; i++) {                 if (matched[i]) {                     // skip values already matched                     continue;                 }                 if (Objects.equals(o, confirmedValues[i])) {                     // values matched                     matched[i] = true;                     match = true;                     break;                 }             }             // no match found!             if (!match) {                 fail("Collection should not contain a value that the "                         + "confirmed collection does not have: " + o + "\nTest: " + getCollection()                         + "\nReal: " + getConfirmed());             }         }          // make sure there aren't any unmatched values         for (int i = 0; i < confirmedSize; i++) {             if (!matched[i]) {                 // the collection didn't match all the confirmed values                 fail("Collection should contain all values that are in the confirmed collection"                         + "\nTest: " + getCollection() + "\nReal: " + getConfirmed());             }         }     }      //-----------------------------------------------------------------------     /**      *  Resets the {@link #collection} and {@link #confirmed} fields to empty      *  collections.  Invoke this method before performing a modification      *  test.      */     public void resetEmpty() {         this.setCollection(makeObject());         this.setConfirmed(makeConfirmedCollection());     }      /**      *  Resets the {@link #collection} and {@link #confirmed} fields to full      *  collections.  Invoke this method before performing a modification      *  test.      */     public void resetFull() {         this.setCollection(makeFullCollection());         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      *  Returns a confirmed empty collection.      *  For instance, an {@link java.util.ArrayList} for lists or a      *  {@link java.util.HashSet} for sets.      *      *  @return a confirmed empty collection      */     public abstract Collection<E> makeConfirmedCollection();      /**      *  Returns a confirmed full collection.      *  For instance, an {@link java.util.ArrayList} for lists or a      *  {@link java.util.HashSet} for sets.  The returned collection      *  should contain the elements returned by {@link #getFullElements()}.      *      *  @return a confirmed full collection      */     public abstract Collection<E> makeConfirmedFullCollection();      /**      * Return a new, empty {@link Collection} to be used for testing.      */     @Override     public abstract Collection<E> makeObject();      /**      *  Returns a full collection to be used for testing.  The collection      *  returned by this method should contain every element returned by      *  {@link #getFullElements()}.  The default implementation, in fact,      *  simply invokes {@code addAll} on an empty collection with      *  the results of {@link #getFullElements()}.  Override this default      *  if your collection doesn't support addAll.      */     public Collection<E> makeFullCollection() {         final Collection<E> c = makeObject();         c.addAll(Arrays.asList(getFullElements()));         return c;     }      /**      * Creates a new Map Entry that is independent of the first and the map.      */     public Map.Entry<E, E> cloneMapEntry(final Map.Entry<E, E> entry) {         final HashMap<E, E> map = new HashMap<>();         map.put(entry.getKey(), entry.getValue());         return map.entrySet().iterator().next();     }      //-----------------------------------------------------------------------     /**      *  Returns an array of objects that are contained in a collection      *  produced by {@link #makeFullCollection()}.  Every element in the      *  returned array <I>must</I> be an element in a full collection.<P>      *  The default implementation returns a heterogenous array of      *  objects with some duplicates. null is added if allowed.      *  Override if you require specific testing elements.  Note that if you      *  override {@link #makeFullCollection()}, you <I>must</I> override      *  this method to reflect the contents of a full collection.      */     @SuppressWarnings("unchecked")     public E[] getFullElements() {         if (isNullSupported()) {             final ArrayList<E> list = new ArrayList<>(Arrays.asList(getFullNonNullElements()));             list.add(4, null);             return (E[]) list.toArray();         }         return getFullNonNullElements().clone();     }      /**      *  Returns an array of elements that are <I>not</I> contained in a      *  full collection.  Every element in the returned array must      *  not exist in a collection returned by {@link #makeFullCollection()}.      *  The default implementation returns a heterogenous array of elements      *  without null.  Note that some of the tests add these elements      *  to an empty or full collection, so if your collection restricts      *  certain kinds of elements, you should override this method.      */     public E[] getOtherElements() {         return getOtherNonNullElements();     }      //-----------------------------------------------------------------------     /**      *  Returns a list of elements suitable for return by      *  {@link #getFullElements()}.  The array returned by this method      *  does not include null, but does include a variety of objects      *  of different types.  Override getFullElements to return      *  the results of this method if your collection does not support      *  the null element.      */     @SuppressWarnings("unchecked")     public E[] getFullNonNullElements() {         return (E[]) new Object[] {             "",             "One",             Integer.valueOf(2),             "Three",             Integer.valueOf(4),             "One",             new Double(5),             new Float(6),             "Seven",             "Eight",             "Nine",             Integer.valueOf(10),             new Short((short) 11),             new Long(12),             "Thirteen",             "14",             "15",             new Byte((byte) 16)         };     }      /**      *  Returns the default list of objects returned by      *  {@link #getOtherElements()}.  Includes many objects      *  of different types.      */     @SuppressWarnings("unchecked")     public E[] getOtherNonNullElements() {         return (E[]) new Object[] {             Integer.valueOf(0),             new Float(0),             new Double(0),             "Zero",             new Short((short) 0),             new Byte((byte) 0),             new Long(0),             new Character('\u0000'),             "0"         };     }      /**      *  Returns a list of string elements suitable for return by      *  {@link #getFullElements()}.  Override getFullElements to return      *  the results of this method if your collection does not support      *  heterogenous elements or the null element.      */     public Object[] getFullNonNullStringElements() {         return new Object[] {             "If", "the", "dull", "substance", "of", "my", "flesh", "were",             "thought", "Injurious", "distance", "could", "not", "stop", "my", "way",         };     }      /**      *  Returns a list of string elements suitable for return by      *  {@link #getOtherElements()}.  Override getOtherElements to return      *  the results of this method if your collection does not support      *  heterogenous elements or the null element.      */     public Object[] getOtherNonNullStringElements() {         return new Object[] {             "For", "then", "despite", /* of */"space", "I", "would", "be",             "brought", "From", "limits", "far", "remote", "where", "thou", "dost", "stay"         };     }      // Tests     //-----------------------------------------------------------------------     /**      *  Tests {@link Collection#add(Object)}.      */     public void testCollectionAdd() {         if (!isAddSupported()) {             return;         }          final E[] elements = getFullElements();         for (final E element : elements) {             resetEmpty();             final boolean r = getCollection().add(element);             getConfirmed().add(element);             verify();             assertTrue("Empty collection changed after add", r);             assertEquals("Collection size is 1 after first add", 1, getCollection().size());         }          resetEmpty();         int size = 0;         for (final E element : elements) {             final boolean r = getCollection().add(element);             getConfirmed().add(element);             verify();             if (r) {                 size++;             }             assertEquals("Collection size should grow after add", size, getCollection().size());             assertTrue("Collection should contain added element", getCollection().contains(element));         }     }      /**      *  Tests {@link Collection#addAll(Collection)}.      */     public void testCollectionAddAll() {         if (!isAddSupported()) {             return;         }          resetEmpty();         E[] elements = getFullElements();         boolean r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Empty collection should change after addAll", r);         for (final E element : elements) {             assertTrue("Collection should contain added element", getCollection().contains(element));         }          resetFull();         int size = getCollection().size();         elements = getOtherElements();         r = getCollection().addAll(Arrays.asList(elements));         getConfirmed().addAll(Arrays.asList(elements));         verify();         assertTrue("Full collection should change after addAll", r);         for (final E element : elements) {             assertTrue("Full collection should contain added element",                     getCollection().contains(element));         }         assertEquals("Size should increase after addAll", size + elements.length, getCollection().size());          resetFull();         size = getCollection().size();         r = getCollection().addAll(Arrays.asList(getFullElements()));         getConfirmed().addAll(Arrays.asList(getFullElements()));         verify();         if (r) {             assertTrue("Size should increase if addAll returns true", size < getCollection().size());         } else {             assertEquals("Size should not change if addAll returns false", size, getCollection().size());         }     }      /**      *  If {@link #isAddSupported()} returns false, tests that add operations      *  raise <code>UnsupportedOperationException.      */     public void testUnsupportedAdd() {         if (isAddSupported()) {             return;         }          resetEmpty();         try {             getCollection().add(getFullNonNullElements()[0]);             fail("Empty collection should not support add.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();          try {             getCollection().addAll(Arrays.asList(getFullElements()));             fail("Empty collection should not support addAll.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();          resetFull();         try {             getCollection().add(getFullNonNullElements()[0]);             fail("Full collection should not support add.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();          try {             getCollection().addAll(Arrays.asList(getOtherElements()));             fail("Full collection should not support addAll.");         } catch (final UnsupportedOperationException e) {             // expected         }         // make sure things didn't change even if the expected exception was         // thrown.         verify();     }      /**      *  Test {@link Collection#clear()}.      */     public void testCollectionClear() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         getCollection().clear(); // just to make sure it doesn't raise anything         verify();          resetFull();         getCollection().clear();         getConfirmed().clear();         verify();     }      /**      *  Tests {@link Collection#contains(Object)}.      */     public void testCollectionContains() {         Object[] elements;          resetEmpty();         elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             assertFalse("Empty collection shouldn't contain element[" + i + "]", getCollection().contains(elements[i]));         }         // make sure calls to "contains" don't change anything         verify();          elements = getOtherElements();         for (int i = 0; i < elements.length; i++) {             assertFalse("Empty collection shouldn't contain element[" + i + "]", getCollection().contains(elements[i]));         }         // make sure calls to "contains" don't change anything         verify();          resetFull();         elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             assertTrue("Full collection should contain element[" + i + "]",                     getCollection().contains(elements[i]));         }         // make sure calls to "contains" don't change anything         verify();          resetFull();         elements = getOtherElements();         for (final Object element : elements) {             assertFalse("Full collection shouldn't contain element", getCollection().contains(element));         }     }      /**      *  Tests {@link Collection#containsAll(Collection)}.      */     public void testCollectionContainsAll() {         resetEmpty();         Collection<E> col = new HashSet<>();         assertTrue("Every Collection should contain all elements of an " +                 "empty Collection.", getCollection().containsAll(col));         col.addAll(Arrays.asList(getOtherElements()));         assertFalse("Empty Collection shouldn't contain all elements of " +                 "a non-empty Collection.", getCollection().containsAll(col));         // make sure calls to "containsAll" don't change anything         verify();          resetFull();         assertFalse("Full collection shouldn't contain other elements", getCollection().containsAll(col));          col.clear();         col.addAll(Arrays.asList(getFullElements()));         assertTrue("Full collection should containAll full elements",                 getCollection().containsAll(col));         // make sure calls to "containsAll" don't change anything         verify();          final int min = getFullElements().length < 4 ? 0 : 2;         final int max = getFullElements().length == 1 ? 1 :                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;         col = Arrays.asList(getFullElements()).subList(min, max);         assertTrue("Full collection should containAll partial full elements",                 getCollection().containsAll(col));         assertTrue("Full collection should containAll itself", getCollection().containsAll(getCollection()));         // make sure calls to "containsAll" don't change anything         verify();          col = new ArrayList<>(Arrays.asList(getFullElements()));         col.addAll(Arrays.asList(getFullElements()));         assertTrue("Full collection should containAll duplicate full elements",                 getCollection().containsAll(col));          // make sure calls to "containsAll" don't change anything         verify();     }      /**      *  Tests {@link Collection#isEmpty()}.      */     public void testCollectionIsEmpty() {         resetEmpty();         assertTrue("New Collection should be empty.", getCollection().isEmpty());         // make sure calls to "isEmpty() don't change anything         verify();          resetFull();         assertFalse("Full collection shouldn't be empty", getCollection().isEmpty());         // make sure calls to "isEmpty() don't change anything         verify();     }      /**      *  Tests the read-only functionality of {@link Collection#iterator()}.      */     public void testCollectionIterator() {         resetEmpty();         Iterator<E> it1 = getCollection().iterator();         assertFalse("Iterator for empty Collection shouldn't have next.", it1.hasNext());         try {             it1.next();             fail("Iterator at end of Collection should throw "                     + "NoSuchElementException when next is called.");         } catch (final NoSuchElementException e) {             // expected         }         // make sure nothing has changed after non-modification         verify();          resetFull();         it1 = getCollection().iterator();         for (final E element : getCollection()) {             assertTrue("Iterator for full collection should haveNext", it1.hasNext());             it1.next();         }         assertFalse("Iterator should be finished", it1.hasNext());          final ArrayList<E> list = new ArrayList<>();         it1 = getCollection().iterator();         for (int i = 0; i < getCollection().size(); i++) {             final E next = it1.next();             assertTrue("Collection should contain element returned by its iterator",                     getCollection().contains(next));             list.add(next);         }         try {             it1.next();             fail("iterator.next() should raise NoSuchElementException after it finishes");         } catch (final NoSuchElementException e) {             // expected         }         // make sure nothing has changed after non-modification         verify();     }      /**      *  Tests removals from {@link Collection#iterator()}.      */     @SuppressWarnings("unchecked")     public void testCollectionIteratorRemove() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().iterator().remove();             fail("New iterator.remove should raise IllegalState");         } catch (final IllegalStateException e) {             // expected         }         verify();          try {             final Iterator<E> iter = getCollection().iterator();             iter.hasNext();             iter.remove();             fail("New iterator.remove should raise IllegalState even after hasNext");         } catch (final IllegalStateException e) {             // expected         }         verify();          resetFull();         int size = getCollection().size();         Iterator<E> iter = getCollection().iterator();         while (iter.hasNext()) {             Object o = iter.next();             // TreeMap reuses the Map Entry, so the verify below fails             // Clone it here if necessary             if (o instanceof Map.Entry) {                 o = cloneMapEntry((Map.Entry<E, E>) o);             }             iter.remove();              // if the elements aren't distinguishable, we can just remove a             // matching element from the confirmed collection and verify             // contents are still the same.  Otherwise, we don't have the             // ability to distinguish the elements and determine which to             // remove from the confirmed collection (in which case, we don't             // verify because we don't know how).             //             // see areEqualElementsDistinguishable()             if (!areEqualElementsDistinguishable()) {                 getConfirmed().remove(o);                 verify();             }              size--;             assertEquals("Collection should shrink by one after iterator.remove", size,                     getCollection().size());         }         assertTrue("Collection should be empty after iterator purge", getCollection().isEmpty());          resetFull();         iter = getCollection().iterator();         iter.next();         iter.remove();         try {             iter.remove();             fail("Second iter.remove should raise IllegalState");         } catch (final IllegalStateException e) {             // expected         }     }      /**      *  Tests {@link Collection#remove(Object)}.      */     public void testCollectionRemove() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         final E[] elements = getFullElements();         for (final E element : elements) {             assertTrue("Shouldn't remove nonexistent element", !getCollection().remove(element));             verify();         }          final E[] other = getOtherElements();          resetFull();         for (final E element : other) {             assertFalse("Shouldn't remove nonexistent other element", getCollection().remove(element));             verify();         }          final int size = getCollection().size();         for (final E element : elements) {             resetFull();             assertTrue("Collection should remove extant element: " + element,                     getCollection().remove(element));              // if the elements aren't distinguishable, we can just remove a             // matching element from the confirmed collection and verify             // contents are still the same.  Otherwise, we don't have the             // ability to distinguish the elements and determine which to             // remove from the confirmed collection (in which case, we don't             // verify because we don't know how).             //             // see areEqualElementsDistinguishable()             if (!areEqualElementsDistinguishable()) {                 getConfirmed().remove(element);                 verify();             }              assertEquals("Collection should shrink after remove", size - 1, getCollection().size());         }     }      /**      *  Tests {@link Collection#removeAll(Collection)}.      */     public void testCollectionRemoveAll() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         assertTrue("Empty collection removeAll should return false for empty input",                 !getCollection().removeAll(Collections.EMPTY_SET));         verify();          assertTrue("Empty collection removeAll should return false for nonempty input",                    !getCollection().removeAll(new ArrayList<>(getCollection())));         verify();          resetFull();         assertFalse("Full collection removeAll should return false for empty input", getCollection().removeAll(Collections.EMPTY_SET));         verify();          assertFalse("Full collection removeAll should return false for other elements", getCollection().removeAll(Arrays.asList(getOtherElements())));         verify();          assertTrue("Full collection removeAll should return true for full elements",                 getCollection().removeAll(new HashSet<>(getCollection())));         getConfirmed().removeAll(new HashSet<>(getConfirmed()));         verify();          resetFull();         final int size = getCollection().size();         final int min = getFullElements().length < 4 ? 0 : 2;         final int max = getFullElements().length == 1 ? 1 :                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;         final Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);         assertTrue("Full collection removeAll should work", getCollection().removeAll(all));         getConfirmed().removeAll(all);         verify();          assertTrue("Collection should shrink after removeAll", getCollection().size() < size);         for (final E element : all) {             assertFalse("Collection shouldn't contain removed element", getCollection().contains(element));         }     }      /**      *  Tests {@link Collection#removeIf(Predicate)}.      * @since 4.4      */     public void testCollectionRemoveIf() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         assertFalse("Empty collection removeIf should return false for a predicate that returns only false", getCollection().removeIf(e -> false));         verify();          assertFalse("Empty collection removeIf should return false for a predicate that returns only true", getCollection().removeIf(e -> true));         verify();          resetFull();         assertFalse("Full collection removeIf should return false for a predicate that returns only false", getCollection().removeIf(e -> false));         verify();          assertTrue("Full collection removeIf should return true for a predicate that returns only true",                 getCollection().removeIf(e -> true));         getConfirmed().removeIf(e -> true);         verify();          resetFull();         final List<E> elements = Arrays.asList(getFullElements());          final int mid = getFullElements().length / 2;         final E target = elements.get(mid);          final int size = getCollection().size();         final int targetCount = Collections.frequency(elements, target);          final Predicate<E> filter = e -> target.equals(e);          assertTrue("Full collection removeIf should work", getCollection().removeIf(filter));         getConfirmed().removeIf(filter);         verify();          assertEquals("Collection should shrink after removeIf", getCollection().size(), size - targetCount);         assertFalse("Collection shouldn't contain removed element", getCollection().contains(target));     }      /**      *  Tests {@link Collection#retainAll(Collection)}.      */     public void testCollectionRetainAll() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();         final List<E> elements = Arrays.asList(getFullElements());         final List<E> other = Arrays.asList(getOtherElements());          assertFalse("Empty retainAll() should return false", getCollection().retainAll(Collections.EMPTY_SET));         verify();          assertFalse("Empty retainAll() should return false", getCollection().retainAll(elements));         verify();          resetFull();         assertTrue("Collection should change from retainAll empty",                 getCollection().retainAll(Collections.EMPTY_SET));         getConfirmed().retainAll(Collections.EMPTY_SET);         verify();          resetFull();         assertTrue("Collection changed from retainAll other", getCollection().retainAll(other));         getConfirmed().retainAll(other);         verify();          resetFull();         int size = getCollection().size();         assertFalse("Collection shouldn't change from retainAll elements", getCollection().retainAll(elements));         verify();         assertEquals("Collection size shouldn't change", size, getCollection().size());          if (getFullElements().length > 1) {             resetFull();             size = getCollection().size();             final int min = getFullElements().length < 4 ? 0 : 2;             final int max = getFullElements().length <= 5 ? getFullElements().length - 1 : 5;             assertTrue("Collection should changed by partial retainAll",                     getCollection().retainAll(elements.subList(min, max)));             getConfirmed().retainAll(elements.subList(min, max));             verify();              for (final E element : getCollection()) {                 assertTrue("Collection only contains retained element", elements.subList(min, max).contains(element));             }         }          resetFull();         final HashSet<E> set = new HashSet<>(elements);         size = getCollection().size();         assertFalse("Collection shouldn't change from retainAll without " +                 "duplicate elements", getCollection().retainAll(set));         verify();         assertEquals("Collection size didn't change from nonduplicate " +                      "retainAll", size, getCollection().size());     }      /**      *  Tests {@link Collection#size()}.      */     public void testCollectionSize() {         resetEmpty();         assertEquals("Size of new Collection is 0.", 0, getCollection().size());          resetFull();         assertTrue("Size of full collection should be greater than zero", getCollection().size() > 0);     }      /**      *  Tests {@link Collection#toArray()}.      */     public void testCollectionToArray() {         resetEmpty();         assertEquals("Empty Collection should return empty array for toArray",                      0, getCollection().toArray().length);          resetFull();         final Object[] array = getCollection().toArray();         assertEquals("Full collection toArray should be same size as collection",                 array.length, getCollection().size());         final Object[] confirmedArray = getConfirmed().toArray();         assertEquals("length of array from confirmed collection should "                 + "match the length of the collection's array", confirmedArray.length, array.length);         final boolean[] matched = new boolean[array.length];          for (int i = 0; i < array.length; i++) {             assertTrue("Collection should contain element in toArray",                     getCollection().contains(array[i]));              boolean match = false;             // find a match in the confirmed array             for (int j = 0; j < array.length; j++) {                 // skip already matched                 if (matched[j]) {                     continue;                 }                 if (Objects.equals(array[i], confirmedArray[j])) {                     matched[j] = true;                     match = true;                     break;                 }             }             if (!match) {                 fail("element " + i + " in returned array should be found "                         + "in the confirmed collection's array");             }         }         for (final boolean element : matched) {             assertTrue("Collection should return all its elements in " + "toArray", element);         }     }      /**      *  Tests {@link Collection#toArray(Object[])}.      */     public void testCollectionToArray2() {         resetEmpty();         Object[] a = new Object[] { new Object(), null, null };         Object[] array = getCollection().toArray(a);         assertEquals("Given array shouldn't shrink", array, a);         assertNull("Last element should be set to null", a[0]);         verify();          resetFull();         try {             array = getCollection().toArray(new Void[0]);             fail("toArray(new Void[0]) should raise ArrayStore");         } catch (final ArrayStoreException e) {             // expected         }         verify();          try {             // Casting to Object[] allows compilation on Java 11.             array = getCollection().toArray((Object[]) null);             fail("toArray(null) should raise NPE");         } catch (final NullPointerException e) {             // expected         }         verify();          array = getCollection().toArray(new Object[0]);         a = getCollection().toArray();         assertEquals("toArrays should be equal",                      Arrays.asList(array), Arrays.asList(a));          // Figure out if they're all the same class         // TODO: It'd be nicer to detect a common superclass         final HashSet<Class<?>> classes = new HashSet<>();         for (final Object element : array) {             classes.add(element == null ? null : element.getClass());         }         if (classes.size() > 1) {             return;         }          Class<?> cl = classes.iterator().next();         if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet             cl = Map.Entry.class;         }         a = (Object[]) Array.newInstance(cl, 0);         array = getCollection().toArray(a);         assertEquals("toArray(Object[]) should return correct array type",                 a.getClass(), array.getClass());         assertEquals("type-specific toArrays should be equal",                 Arrays.asList(array),                 Arrays.asList(getCollection().toArray()));         verify();     }      /**      *  Tests {@code toString} on a collection.      */     public void testCollectionToString() {         resetEmpty();         assertNotNull("toString shouldn't return null", getCollection().toString());          resetFull();         assertNotNull("toString shouldn't return null", getCollection().toString());     }      /**      *  If isRemoveSupported() returns false, tests to see that remove      *  operations raise an UnsupportedOperationException.      */     public void testUnsupportedRemove() {         if (isRemoveSupported()) {             return;         }          resetEmpty();         try {             getCollection().clear();             fail("clear should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().remove(null);             fail("remove should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().removeIf(e -> true);             fail("removeIf should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().removeAll(null);             fail("removeAll should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          try {             getCollection().retainAll(null);             fail("retainAll should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();          resetFull();         try {             final Iterator<E> iterator = getCollection().iterator();             iterator.next();             iterator.remove();             fail("iterator.remove should raise UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {             // expected         }         verify();      }      /**      *  Tests that the collection's iterator is fail-fast.      */     public void testCollectionIteratorFailFast() {         if (!isFailFastSupported()) {             return;         }          if (isAddSupported()) {             resetFull();             try {                 final Iterator<E> iter = getCollection().iterator();                 final E o = getOtherElements()[0];                 getCollection().add(o);                 getConfirmed().add(o);                 iter.next();                 fail("next after add should raise ConcurrentModification");             } catch (final ConcurrentModificationException e) {                 // expected             }             verify();              resetFull();             try {                 final Iterator<E> iter = getCollection().iterator();                 getCollection().addAll(Arrays.asList(getOtherElements()));                 getConfirmed().addAll(Arrays.asList(getOtherElements()));                 iter.next();                 fail("next after addAll should raise ConcurrentModification");             } catch (final ConcurrentModificationException e) {                 // expected             }             verify();         }          if (!isRemoveSupported()) {             return;         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             getCollection().clear();             iter.next();             fail("next after clear should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         } catch (final NoSuchElementException e) {             // (also legal given spec)         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             getCollection().remove(getFullElements()[0]);             iter.next();             fail("next after remove should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             getCollection().removeIf(e -> false);             iter.next();             fail("next after removeIf should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             final List<E> sublist = Arrays.asList(getFullElements()).subList(2, 5);             getCollection().removeAll(sublist);             iter.next();             fail("next after removeAll should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }          resetFull();         try {             final Iterator<E> iter = getCollection().iterator();             final List<E> sublist = Arrays.asList(getFullElements()).subList(2, 5);             getCollection().retainAll(sublist);             iter.next();             fail("next after retainAll should raise ConcurrentModification");         } catch (final ConcurrentModificationException e) {             // expected         }     }      @Override     public void testSerializeDeserializeThenCompare() throws Exception {         Object obj = makeObject();         if (obj instanceof Serializable && isTestSerialization()) {             final ByteArrayOutputStream buffer = new ByteArrayOutputStream();             final ObjectOutputStream out = new ObjectOutputStream(buffer);             out.writeObject(obj);             out.close();              final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));             final Object dest = in.readObject();             in.close();             if (isEqualsCheckable()) {                 assertEquals("obj != deserialize(serialize(obj)) - EMPTY Collection", obj, dest);             }         }         obj = makeFullCollection();         if (obj instanceof Serializable && isTestSerialization()) {             final ByteArrayOutputStream buffer = new ByteArrayOutputStream();             final ObjectOutputStream out = new ObjectOutputStream(buffer);             out.writeObject(obj);             out.close();              final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));             final Object dest = in.readObject();             in.close();             if (isEqualsCheckable()) {                 assertEquals("obj != deserialize(serialize(obj)) - FULL Collection", obj, dest);             }         }     }      public Collection<E> getCollection() {         return collection;     }      /**      * Set the collection.      * @param collection the Collection<E> to set      */     public void setCollection(final Collection<E> collection) {         this.collection = collection;     }      public Collection<E> getConfirmed() {         return confirmed;     }      /**      * Set the confirmed.      * @param confirmed the Collection<E> to set      */     public void setConfirmed(final Collection<E> confirmed) {         this.confirmed = confirmed;     }      /**      * Handle the optional exceptions declared by {@link Collection#contains(Object)}      * @param coll      * @param element      */     protected static void assertNotCollectionContains(final Collection<?> coll, final Object element) {         try {             assertFalse(coll.contains(element));         } catch (final ClassCastException e) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     }      /**      * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}      * @param coll      * @param sub      */     protected static void assertNotCollectionContainsAll(final Collection<?> coll, final Collection<?> sub) {         try {             assertFalse(coll.containsAll(sub));         } catch (final ClassCastException cce) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     }      /**      * Handle optional exceptions of {@link Collection#remove(Object)}      * @param coll      * @param element      */     protected static void assertNotRemoveFromCollection(final Collection<?> coll, final Object element) {         try {             assertFalse(coll.remove(element));         } catch (final ClassCastException cce) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     }      /**      * Handle optional exceptions of {@link Collection#removeAll(Collection)}      * @param coll      * @param sub      */     protected static void assertNotRemoveAllFromCollection(final Collection<?> coll, final Collection<?> sub) {         try {             assertFalse(coll.removeAll(sub));         } catch (final ClassCastException cce) {             //apparently not         } catch (final NullPointerException e) {             //apparently not         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.List;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils;  /**  * Extension of {@link AbstractCollectionTest} for exercising the {@link TransformedCollection}  * implementation.  *  * @since 3.0  */ public class TransformedCollectionTest extends AbstractCollectionTest<Object> {      private static class StringToInteger implements Transformer<Object, Object> {         @Override         public Object transform(final Object input) {             return Integer.valueOf((String) input);         }     }      private static class ToLowerCase implements Transformer<Object, Object> {         @Override         public Object transform(final Object input) {             return ((String) input).toLowerCase();         }     }      public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();     public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();     public static final Transformer<Object, Object> TO_LOWER_CASE_TRANSFORMER = new ToLowerCase();      public TransformedCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<Object> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<Object> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public Collection<Object> makeObject() {         return TransformedCollection.transformingCollection(new ArrayList<>(), NOOP_TRANSFORMER);     }      @Override     public Collection<Object> makeFullCollection() {         final List<Object> list = new ArrayList<>(Arrays.asList(getFullElements()));         return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     @Override     public Object[] getFullElements() {         return new Object[] {"1", "3", "5", "7", "2", "4", "6"};     }      @Override     public Object[] getOtherElements() {         return new Object[] {"9", "88", "678", "87", "98", "78", "99"};     }      //-----------------------------------------------------------------------     public void testTransformedCollection() {         final Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<>(), STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, coll.size());         final Object[] elements = getFullElements();         for (int i = 0; i < elements.length; i++) {             coll.add(elements[i]);             assertEquals(i + 1, coll.size());             assertTrue(coll.contains(Integer.valueOf((String) elements[i])));             assertFalse(coll.contains(elements[i]));         }          assertTrue(coll.remove(Integer.valueOf((String) elements[0])));     }      public void testTransformedCollection_decorateTransform() {         final Collection<Object> originalCollection = new ArrayList<>();         final Object[] elements = getFullElements();         Collections.addAll(originalCollection, elements);         final Collection<Object> collection = TransformedCollection.transformedCollection(originalCollection, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(elements.length, collection.size());         for (final Object element : elements) {             assertTrue(collection.contains(Integer.valueOf((String) element)));             assertFalse(collection.contains(element));         }          assertFalse(collection.remove(elements[0]));         assertTrue(collection.remove(Integer.valueOf((String) elements[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedCollection.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedCollection.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.BoundedCollection; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.list.FixedSizeList;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableBoundedCollection} implementation.  *  */ public class UnmodifiableBoundedCollectionTest<E> extends AbstractCollectionTest<E> {      public UnmodifiableBoundedCollectionTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Collection<E> makeObject() {         final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<E>());         return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);     }      @Override     public BoundedCollection<E> makeFullCollection() {         final E[] allElements = getFullElements();         final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<>(Arrays.asList(allElements)));         return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     protected boolean skipSerializedCanonicalTests() {         return true;     }      @Override     public String getCompatibilityVersion() {         return "4";     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final BoundedCollection<E> coll = makeFullCollection();         assertSame(coll, UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll));          try {             UnmodifiableBoundedCollection.unmodifiableBoundedCollection(null);             fail();         } catch (final NullPointerException ex) {}     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.collection;  import static java.util.Arrays.asList;  import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.Transformer;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link IndexedCollection} implementation.  *  * @since 4.0  */ @SuppressWarnings("boxing") public class IndexedCollectionTest extends AbstractCollectionTest<String> {      public IndexedCollectionTest(final String name) {         super(name);     }     //------------------------------------------------------------------------      protected Collection<String> decorateCollection(final Collection<String> collection) {         return IndexedCollection.nonUniqueIndexedCollection(collection, new IntegerTransformer());     }      protected IndexedCollection<Integer, String> decorateUniqueCollection(final Collection<String> collection) {         return IndexedCollection.uniqueIndexedCollection(collection, new IntegerTransformer());     }      private static final class IntegerTransformer implements Transformer<String, Integer>, Serializable {         private static final long serialVersionUID = 809439581555072949L;          @Override         public Integer transform(final String input) {             return Integer.valueOf(input);         }     }      @Override     public Collection<String> makeObject() {         return decorateCollection(new ArrayList<String>());     }      @Override     public Collection<String> makeConfirmedCollection() {         return new ArrayList<>();     }      @Override     public String[] getFullElements() {         return new String[] { "1", "3", "5", "7", "2", "4", "6" };     }      @Override     public String[] getOtherElements() {         return new String[] {"9", "88", "678", "87", "98", "78", "99"};     }      @Override     public Collection<String> makeFullCollection() {         return decorateCollection(new ArrayList<>(Arrays.asList(getFullElements())));     }      @Override     public Collection<String> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      public Collection<String> makeTestCollection() {         return decorateCollection(new ArrayList<String>());     }      public Collection<String> makeUniqueTestCollection() {         return decorateUniqueCollection(new ArrayList<String>());     }      @Override     protected boolean skipSerializedCanonicalTests() {         // FIXME: support canonical tests         return true;     }      //------------------------------------------------------------------------      public void testAddedObjectsCanBeRetrievedByKey() throws Exception {         final Collection<String> coll = makeTestCollection();         coll.add("12");         coll.add("16");         coll.add("1");         coll.addAll(asList("2", "3", "4"));          @SuppressWarnings("unchecked")         final IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;         assertEquals("12", indexed.get(12));         assertEquals("16", indexed.get(16));         assertEquals("1", indexed.get(1));         assertEquals("2", indexed.get(2));         assertEquals("3", indexed.get(3));         assertEquals("4", indexed.get(4));     }      public void testEnsureDuplicateObjectsCauseException() throws Exception {         final Collection<String> coll = makeUniqueTestCollection();          coll.add("1");         try {             coll.add("1");             fail();         } catch (final IllegalArgumentException e) {             // expected         }     }      public void testDecoratedCollectionIsIndexedOnCreation() throws Exception {         final Collection<String> original = makeFullCollection();         final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);          assertEquals("1", indexed.get(1));         assertEquals("2", indexed.get(2));         assertEquals("3", indexed.get(3));     }      public void testReindexUpdatesIndexWhenDecoratedCollectionIsModifiedSeparately() throws Exception {         final Collection<String> original = new ArrayList<>();         final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);          original.add("1");         original.add("2");         original.add("3");          assertNull(indexed.get(1));         assertNull(indexed.get(2));         assertNull(indexed.get(3));          indexed.reindex();          assertEquals("1", indexed.get(1));         assertEquals("2", indexed.get(2));         assertEquals("3", indexed.get(3));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import org.apache.commons.collections4.trie.PatriciaTrie; import org.apache.commons.collections4.trie.UnmodifiableTrie; import org.junit.Test;  /**  * Tests for TrieUtils factory methods.  *  */ public class TrieUtilsTest {      //----------------------------------------------------------------------      @Test     public void testUnmodifiableTrie() {         final Trie<String, Object> trie = TrieUtils.unmodifiableTrie(new PatriciaTrie<>());         assertTrue("Returned object should be an UnmodifiableTrie.",             trie instanceof UnmodifiableTrie);         try {             TrieUtils.unmodifiableTrie(null);             fail("Expecting NullPointerException for null trie.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableTrie shall not be decorated", trie, TrieUtils.unmodifiableTrie(trie));     }  }   
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.NullPredicate.*; import static org.apache.commons.collections4.functors.TruePredicate.*; import static org.junit.Assert.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map;  import org.apache.commons.collections4.functors.AbstractPredicateTest; import org.apache.commons.collections4.functors.AllPredicate; import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.functors.ExceptionPredicate; import org.apache.commons.collections4.functors.FalsePredicate; import org.apache.commons.collections4.functors.NotNullPredicate; import org.apache.commons.collections4.functors.NullPredicate; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests the PredicateUtils class.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class PredicateUtilsTest extends AbstractPredicateTest {      // exceptionPredicate     //------------------------------------------------------------------      @Test     public void testExceptionPredicate() {         assertNotNull(PredicateUtils.exceptionPredicate());         assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());         try {             PredicateUtils.exceptionPredicate().evaluate(null);         } catch (final FunctorException ex) {             try {                 PredicateUtils.exceptionPredicate().evaluate(cString);             } catch (final FunctorException ex2) {                 return;             }         }         fail();     }      // notNullPredicate     //------------------------------------------------------------------      @Test     public void testIsNotNullPredicate() {         assertNotNull(PredicateUtils.notNullPredicate());         assertSame(PredicateUtils.notNullPredicate(), PredicateUtils.notNullPredicate());         assertFalse(PredicateUtils.notNullPredicate().evaluate(null));         assertTrue(PredicateUtils.notNullPredicate().evaluate(cObject));         assertTrue(PredicateUtils.notNullPredicate().evaluate(cString));         assertTrue(PredicateUtils.notNullPredicate().evaluate(cInteger));     }      // identityPredicate     //------------------------------------------------------------------      @Test     public void testIdentityPredicate() {         assertSame(nullPredicate(), PredicateUtils.identityPredicate(null));         assertNotNull(PredicateUtils.identityPredicate(6));         assertFalse(PredicateUtils.identityPredicate(6).evaluate(null));         assertFalse(PredicateUtils.<Object>identityPredicate(6).evaluate(cObject));         assertFalse(PredicateUtils.<Object>identityPredicate(6).evaluate(cString));         assertTrue(PredicateUtils.identityPredicate(6).evaluate(cInteger)); // Cannot use valueOf here         assertTrue(PredicateUtils.identityPredicate(cInteger).evaluate(cInteger));     }      // truePredicate     //------------------------------------------------------------------      @Test     public void testTruePredicate() {         assertNotNull(TruePredicate.truePredicate());         assertSame(TruePredicate.truePredicate(), TruePredicate.truePredicate());         assertTrue(truePredicate().evaluate(null));         assertTrue(truePredicate().evaluate(cObject));         assertTrue(truePredicate().evaluate(cString));         assertTrue(truePredicate().evaluate(cInteger));     }      // falsePredicate     //------------------------------------------------------------------      @Test     public void testFalsePredicate() {         assertNotNull(FalsePredicate.falsePredicate());         assertSame(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate());         assertFalse(FalsePredicate.falsePredicate().evaluate(null));         assertFalse(FalsePredicate.falsePredicate().evaluate(cObject));         assertFalse(FalsePredicate.falsePredicate().evaluate(cString));         assertFalse(FalsePredicate.falsePredicate().evaluate(cInteger));     }      // notPredicate     //------------------------------------------------------------------      @Test     public void testNotPredicate() {         assertNotNull(PredicateUtils.notPredicate(TruePredicate.truePredicate()));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(null));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cObject));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cString));         assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cInteger));     }      @Test(expected=NullPointerException.class)     public void testNotPredicateEx() {         PredicateUtils.notPredicate(null);     }      // andPredicate     //------------------------------------------------------------------      @Test     public void testAndPredicate() {         assertTrue(PredicateUtils.andPredicate(truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.andPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertFalse(PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testAndPredicateEx() {         PredicateUtils.andPredicate(null, null);     }      // allPredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testAllPredicate() {         assertPredicateTrue(AllPredicate.allPredicate(), null);         assertTrue(AllPredicate.allPredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertFalse(AllPredicate.allPredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(AllPredicate.allPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(AllPredicate.allPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertFalse(AllPredicate.allPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateFalse(AllPredicate.allPredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateTrue(AllPredicate.allPredicate(coll), null);         coll.clear();         assertPredicateTrue(AllPredicate.allPredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx1() {         AllPredicate.allPredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testAllPredicateEx2() {         AllPredicate.<Object>allPredicate(new Predicate[] { null });     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx3() {         AllPredicate.allPredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx4() {         AllPredicate.allPredicate((Collection<Predicate<Object>>) null);     }      @Test     public void testAllPredicateEx5() {         AllPredicate.allPredicate(Collections.emptyList());     }      @Test(expected=NullPointerException.class)     public void testAllPredicateEx6() {         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         AllPredicate.allPredicate(coll);     }      // orPredicate     //------------------------------------------------------------------      @Test     public void testOrPredicate() {         assertTrue(PredicateUtils.orPredicate(truePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.orPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testOrPredicateEx() {         PredicateUtils.orPredicate(null, null);     }      // anyPredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testAnyPredicate() {         assertPredicateFalse(PredicateUtils.anyPredicate(), null);          assertTrue(PredicateUtils.anyPredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.anyPredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.anyPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.anyPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertFalse(PredicateUtils.anyPredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateFalse(PredicateUtils.anyPredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateTrue(PredicateUtils.anyPredicate(coll), null);         coll.clear();         assertPredicateFalse(PredicateUtils.anyPredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx1() {         PredicateUtils.anyPredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testAnyPredicateEx2() {         PredicateUtils.anyPredicate(new Predicate[] {null});     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx3() {         PredicateUtils.anyPredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx4() {         PredicateUtils.anyPredicate((Collection<Predicate<Object>>) null);     }      @Test     public void testAnyPredicateEx5() {         PredicateUtils.anyPredicate(Collections.emptyList());     }      @Test(expected=NullPointerException.class)     public void testAnyPredicateEx6() {         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         PredicateUtils.anyPredicate(coll);     }      // eitherPredicate     //------------------------------------------------------------------      @Test     public void testEitherPredicate() {         assertFalse(PredicateUtils.eitherPredicate(truePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.eitherPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testEitherPredicateEx() {         PredicateUtils.eitherPredicate(null, null);     }      // onePredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testOnePredicate() {         assertPredicateFalse(PredicateUtils.onePredicate((Predicate<Object>[]) new Predicate[] {}), null);         assertFalse(PredicateUtils.onePredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.onePredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.onePredicate(truePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertTrue(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertTrue(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateFalse(PredicateUtils.onePredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateTrue(PredicateUtils.onePredicate(coll), null);         coll.clear();         assertPredicateFalse(PredicateUtils.onePredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx1() {         PredicateUtils.onePredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testOnePredicateEx2() {         PredicateUtils.onePredicate(new Predicate[] {null});     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx3() {         PredicateUtils.onePredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx4() {         PredicateUtils.onePredicate((Collection<Predicate<Object>>) null);     }      @SuppressWarnings("unchecked")     @Test     public void testOnePredicateEx5() {         PredicateUtils.onePredicate(Collections.EMPTY_LIST);     }      @Test(expected=NullPointerException.class)     public void testOnePredicateEx6() {         PredicateUtils.onePredicate(Arrays.asList(null, null));     }      // neitherPredicate     //------------------------------------------------------------------      @Test     public void testNeitherPredicate() {         assertFalse(PredicateUtils.neitherPredicate(truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.neitherPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         assertFalse(PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));     }      @Test(expected=NullPointerException.class)     public void testNeitherPredicateEx() {         PredicateUtils.neitherPredicate(null, null);     }      // nonePredicate     //------------------------------------------------------------------      @SuppressWarnings("unchecked")     @Test     public void testNonePredicate() {         assertPredicateTrue(PredicateUtils.nonePredicate(), null);         assertFalse(PredicateUtils.nonePredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.nonePredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertFalse(PredicateUtils.nonePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));         assertTrue(PredicateUtils.nonePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(TruePredicate.truePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(TruePredicate.truePredicate());         assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         coll.add(FalsePredicate.falsePredicate());         assertTrue(PredicateUtils.nonePredicate(coll).evaluate(null));         coll.clear();         coll.add(FalsePredicate.falsePredicate());         assertPredicateTrue(PredicateUtils.nonePredicate(coll), null);         coll.clear();         coll.add(TruePredicate.truePredicate());         assertPredicateFalse(PredicateUtils.nonePredicate(coll), null);         coll.clear();         assertPredicateTrue(PredicateUtils.nonePredicate(coll), null);     }      @Test(expected=NullPointerException.class)     public void testNonePredicateEx1() {         PredicateUtils.nonePredicate((Predicate<Object>[]) null);     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testNonePredicateEx2() {         PredicateUtils.nonePredicate(new Predicate[] {null});     }      @SuppressWarnings("unchecked")     @Test(expected=NullPointerException.class)     public void testNonePredicateEx3() {         PredicateUtils.nonePredicate(null, null);     }      @Test(expected=NullPointerException.class)     public void testNonePredicateEx4() {         PredicateUtils.nonePredicate((Collection<Predicate<Object>>) null);     }      @Test     public void testNonePredicateEx5() {         PredicateUtils.nonePredicate(Collections.emptyList());     }      @Test(expected=NullPointerException.class)     public void testNonePredicateEx6() {         final Collection<Predicate<Object>> coll = new ArrayList<>();         coll.add(null);         coll.add(null);         PredicateUtils.nonePredicate(coll);     }      // instanceofPredicate     //------------------------------------------------------------------      @Test     public void testInstanceOfPredicate() {         assertNotNull(PredicateUtils.instanceofPredicate(String.class));         assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(null));         assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(cObject));         assertTrue(PredicateUtils.instanceofPredicate(String.class).evaluate(cString));         assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(cInteger));     }      // uniquePredicate     //------------------------------------------------------------------      @Test     public void testUniquePredicate() {         final Predicate<Object> p = PredicateUtils.uniquePredicate();         assertTrue(p.evaluate(new Object()));         assertTrue(p.evaluate(new Object()));         assertTrue(p.evaluate(new Object()));         assertTrue(p.evaluate(cString));         assertFalse(p.evaluate(cString));         assertFalse(p.evaluate(cString));     }      // asPredicate(Transformer)     //------------------------------------------------------------------      @Test     public void testAsPredicateTransformer() {         assertFalse(PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(false));         assertTrue(PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(true));     }      @Test(expected=NullPointerException.class)     public void testAsPredicateTransformerEx1() {         PredicateUtils.asPredicate(null);     }      @Test(expected=FunctorException.class)     public void testAsPredicateTransformerEx2() {         PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(null);     }      // invokerPredicate     //------------------------------------------------------------------      @Test     public void testInvokerPredicate() {         final List<Object> list = new ArrayList<>();         assertTrue(PredicateUtils.invokerPredicate("isEmpty").evaluate(list));         list.add(new Object());         assertFalse(PredicateUtils.invokerPredicate("isEmpty").evaluate(list));     }      @Test(expected=NullPointerException.class)     public void testInvokerPredicateEx1() {         PredicateUtils.invokerPredicate(null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicateEx2() {         PredicateUtils.invokerPredicate("isEmpty").evaluate(null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicateEx3() {         PredicateUtils.invokerPredicate("noSuchMethod").evaluate(new Object());     }      // invokerPredicate2     //------------------------------------------------------------------      @Test     public void testInvokerPredicate2() {         final List<String> list = new ArrayList<>();         assertFalse(PredicateUtils.invokerPredicate(                 "contains", new Class[]{Object.class}, new Object[]{cString}).evaluate(list));         list.add(cString);         assertTrue(PredicateUtils.invokerPredicate(                 "contains", new Class[]{Object.class}, new Object[]{cString}).evaluate(list));     }      @Test(expected=NullPointerException.class)     public void testInvokerPredicate2Ex1() {         PredicateUtils.invokerPredicate(null, null, null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicate2Ex2() {         PredicateUtils.invokerPredicate("contains", new Class[] {Object.class}, new Object[] {cString}).evaluate(null);     }      @Test(expected=FunctorException.class)     public void testInvokerPredicate2Ex3() {         PredicateUtils.invokerPredicate(                 "noSuchMethod", new Class[] {Object.class}, new Object[] {cString}).evaluate(new Object());     }      // nullIsException     //------------------------------------------------------------------      @Test(expected=FunctorException.class)     public void testNullIsExceptionPredicate() {         assertTrue(PredicateUtils.nullIsExceptionPredicate(truePredicate()).evaluate(new Object()));         PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(null);     }      @Test(expected=NullPointerException.class)     public void testNullIsExceptionPredicateEx1() {         PredicateUtils.nullIsExceptionPredicate(null);     }      // nullIsTrue     //------------------------------------------------------------------      @Test     public void testNullIsTruePredicate() {         assertTrue(PredicateUtils.nullIsTruePredicate(truePredicate()).evaluate(null));         assertTrue(PredicateUtils.nullIsTruePredicate(truePredicate()).evaluate(new Object()));         assertFalse(PredicateUtils.nullIsTruePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));     }      @Test(expected=NullPointerException.class)     public void testNullIsTruePredicateEx1() {         PredicateUtils.nullIsTruePredicate(null);     }      // nullIsFalse     //------------------------------------------------------------------      @Test     public void testNullIsFalsePredicate() {         assertFalse(PredicateUtils.nullIsFalsePredicate(truePredicate()).evaluate(null));         assertTrue(PredicateUtils.nullIsFalsePredicate(truePredicate()).evaluate(new Object()));         assertFalse(PredicateUtils.nullIsFalsePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));     }      @Test(expected=NullPointerException.class)     public void testNullIsFalsePredicateEx1() {         PredicateUtils.nullIsFalsePredicate(null);     }      // transformed     //------------------------------------------------------------------      @Test     public void testTransformedPredicate() {         assertTrue(PredicateUtils.transformedPredicate(                 TransformerUtils.nopTransformer(),                 truePredicate()).evaluate(new Object()));          final Map<Object, Object> map = new HashMap<>();         map.put(Boolean.TRUE, "Hello");         final Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);         final Predicate<Object> p = EqualPredicate.<Object>equalPredicate("Hello");         assertFalse(PredicateUtils.transformedPredicate(t, p).evaluate(null));         assertTrue(PredicateUtils.transformedPredicate(t, p).evaluate(Boolean.TRUE));         try {             PredicateUtils.transformedPredicate(null, null);             fail();         } catch (final NullPointerException ex) {}     }      // misc tests     //------------------------------------------------------------------      /**      * Test that all Predicate singletons hold singleton pattern in      * serialization/deserialization process.      */     @Test     public void testSingletonPatternInSerialization() {         final Object[] singletons = new Object[] {             ExceptionPredicate.INSTANCE,             FalsePredicate.INSTANCE,             NotNullPredicate.INSTANCE,             NullPredicate.INSTANCE,             TruePredicate.INSTANCE         };          for (final Object original : singletons) {             TestUtils.assertSameAfterSerialization(                     "Singleton pattern broken for " + original.getClass(),                     original             );         }     }      @Override     protected Predicate<?> generatePredicate() {         return truePredicate();  //Just return something to satisfy super class.     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Set;  import org.apache.commons.collections4.SetUtils.SetView; import org.apache.commons.collections4.set.PredicatedSet; import org.junit.Before; import org.junit.Test;  /**  * Tests for SetUtils.  *  */ public class SetUtilsTest {      private Set<Integer> setA;     private Set<Integer> setB;      @Test     public void difference() {         final SetView<Integer> set = SetUtils.difference(setA, setB);         assertEquals(2, set.size());         assertTrue(set.contains(1));         assertTrue(set.contains(2));         for (final Integer i : setB) {             assertFalse(set.contains(i));         }          final Set<Integer> set2 = SetUtils.difference(setA, SetUtils.<Integer>emptySet());         assertEquals(setA, set2);          try {             SetUtils.difference(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.difference(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void disjunction() {         final SetView<Integer> set = SetUtils.disjunction(setA, setB);         assertEquals(4, set.size());         assertTrue(set.contains(1));         assertTrue(set.contains(2));         assertTrue(set.contains(6));         assertTrue(set.contains(7));         assertFalse(set.contains(3));         assertFalse(set.contains(4));         assertFalse(set.contains(5));          final Set<Integer> set2 = SetUtils.disjunction(setA, SetUtils.<Integer>emptySet());         assertEquals(setA, set2);          try {             SetUtils.disjunction(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.disjunction(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void intersection() {         final SetView<Integer> set = SetUtils.intersection(setA, setB);         assertEquals(3, set.size());         assertTrue(set.contains(3));         assertTrue(set.contains(4));         assertTrue(set.contains(5));         assertFalse(set.contains(1));         assertFalse(set.contains(2));         assertFalse(set.contains(6));         assertFalse(set.contains(7));          final Set<Integer> set2 = SetUtils.intersection(setA, SetUtils.<Integer>emptySet());         assertEquals(SetUtils.<Integer>emptySet(), set2);          try {             SetUtils.intersection(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.intersection(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Before     public void setUp() {         setA = new HashSet<>();         setA.add(1);         setA.add(2);         setA.add(3);         setA.add(4);         setA.add(5);          setB = new HashSet<>();         setB.add(3);         setB.add(4);         setB.add(5);         setB.add(6);         setB.add(7);     }      @Test     public void testEmptyIfNull() {         assertTrue(SetUtils.emptyIfNull(null).isEmpty());          final Set<Long> set = new HashSet<>();         assertSame(set, SetUtils.emptyIfNull(set));     }      @Test     public void testEquals() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final Set<String> a = new HashSet<>(data);         final Set<String> b = new HashSet<>(data);          assertEquals(a, b);         assertTrue(SetUtils.isEqualSet(a, b));         a.clear();         assertFalse(SetUtils.isEqualSet(a, b));         assertFalse(SetUtils.isEqualSet(a, null));         assertFalse(SetUtils.isEqualSet(null, b));         assertTrue(SetUtils.isEqualSet(null, null));     }      @Test     public void testHashCode() {         final Collection<String> data = Arrays.asList("a", "b", "c");          final Set<String> a = new HashSet<>(data);         final Set<String> b = new HashSet<>(data);          assertEquals(a.hashCode(), b.hashCode());         assertEquals(a.hashCode(), SetUtils.hashCodeForSet(a));         assertEquals(b.hashCode(), SetUtils.hashCodeForSet(b));         assertEquals(SetUtils.hashCodeForSet(a), SetUtils.hashCodeForSet(b));         a.clear();         assertNotEquals(SetUtils.hashCodeForSet(a), SetUtils.hashCodeForSet(b));         assertEquals(0, SetUtils.hashCodeForSet(null));     }      @Test     public void testHashSet() {         final Set<?> set1 = SetUtils.unmodifiableSet();         assertTrue("set is empty", set1.isEmpty());          final Set<Integer> set2 = SetUtils.hashSet(1, 2, 2, 3);         assertEquals("set has 3 elements", 3, set2.size());         assertTrue("set contains 1", set2.contains(1));         assertTrue("set contains 2", set2.contains(2));         assertTrue("set contains 3", set2.contains(3));          final Set<String> set3 = SetUtils.hashSet("1", "2", "2", "3");         assertEquals("set has 3 elements", 3, set3.size());         assertTrue("set contains 1", set3.contains("1"));         assertTrue("set contains 2", set3.contains("2"));         assertTrue("set contains 3", set3.contains("3"));          final Set<?> set4 = SetUtils.hashSet(null, null);         assertEquals("set has 1 element", 1, set4.size());         assertTrue("set contains null", set4.contains(null));          final Set<?> set5 = SetUtils.hashSet((Object[]) null);         assertNull("set is null", set5);     }      @Test     public void testNewIdentityHashSet() {         final Set<String> set = SetUtils.newIdentityHashSet();         final String a = new String("a");         set.add(a);         set.add(new String("b"));         set.add(a);          assertEquals(2, set.size());          set.add(new String("a"));         assertEquals(3, set.size());          set.remove(a);         assertEquals(2, set.size());     }      @Test     public void testpredicatedSet() {         final Predicate<Object> predicate = o -> o instanceof String;         final Set<Object> set = SetUtils.predicatedSet(new HashSet<>(), predicate);         assertTrue("returned object should be a PredicatedSet", set instanceof PredicatedSet);         try {             SetUtils.predicatedSet(new HashSet<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }         try {             SetUtils.predicatedSet(null, predicate);             fail("Expecting NullPointerException for null set.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableSet() {         final Set<?> set1 = SetUtils.unmodifiableSet();         assertTrue("set is empty", set1.isEmpty());          final Set<Integer> set2 = SetUtils.unmodifiableSet(1, 2, 2, 3);         assertEquals("set has 3 elements", 3, set2.size());         assertTrue("set contains 1", set2.contains(1));         assertTrue("set contains 2", set2.contains(2));         assertTrue("set contains 3", set2.contains(3));          final Set<String> set3 = SetUtils.unmodifiableSet("1", "2", "2", "3");         assertEquals("set has 3 elements", 3, set3.size());         assertTrue("set contains 1", set3.contains("1"));         assertTrue("set contains 2", set3.contains("2"));         assertTrue("set contains 3", set3.contains("3"));          final Set<?> set4 = SetUtils.unmodifiableSet(null, null);         assertEquals("set has 1 element", 1, set4.size());         assertTrue("set contains null", set4.contains(null));          final Set<?> set5 = SetUtils.unmodifiableSet((Object[]) null);         assertNull("set is null", set5);     }      @Test     public void testUnmodifiableSetWrap() {         final Set<Integer> set1 = SetUtils.unmodifiableSet(1, 2, 2, 3);         final Set<Integer> set2 = SetUtils.unmodifiableSet(set1);         assertSame(set1, set2);     }      @Test     public void union() {         final SetView<Integer> set = SetUtils.union(setA, setB);         assertEquals(7, set.size());         assertTrue(set.containsAll(setA));         assertTrue(set.containsAll(setB));          final Set<Integer> set2 = SetUtils.union(setA, SetUtils.<Integer>emptySet());         assertEquals(setA, set2);          try {             SetUtils.union(setA, null);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          try {             SetUtils.union(null, setA);             fail("Expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBag;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link TreeBag}  * implementation.  *  */ public class TreeBagTest<T> extends AbstractSortedBagTest<T> {      public TreeBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TreeBagTest.class);     }      //-----------------------------------------------------------------------      @Override     public SortedBag<T> makeObject() {         return new TreeBag<>();     }      @SuppressWarnings("unchecked")     public SortedBag<T> setupBag() {         final SortedBag<T> bag = makeObject();         bag.add((T) "C");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "D");         return bag;     }      public void testCollections265() {         final Bag<Object> bag = new TreeBag<>();         try {             bag.add(new Object());             fail("IllegalArgumentException expected");         } catch(final IllegalArgumentException iae) {             // expected;         }     }      public void testCollections555() {         final Bag<Object> bag = new TreeBag<>();         try {             bag.add(null);             fail("NullPointerException expected");         } catch(final NullPointerException npe) {             // expected;         }          final Bag<String> bag2 = new TreeBag<>(String::compareTo);         try {             // jdk bug: adding null to an empty TreeMap works             // thus ensure that the bag is not empty before adding null             bag2.add("a");             bag2.add(null);             fail("NullPointerException expected");         } catch(final NullPointerException npe) {             // expected;         }     }      public void testOrdering() {         final Bag<T> bag = setupBag();         assertEquals("Should get elements in correct order", "A", bag.toArray()[0]);         assertEquals("Should get elements in correct order", "B", bag.toArray()[1]);         assertEquals("Should get elements in correct order", "C", bag.toArray()[2]);         assertEquals("Should get first key", "A", ((SortedBag<T>) bag).first());         assertEquals("Should get last key", "D", ((SortedBag<T>) bag).last());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TreeBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TreeBag.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link HashBag}  * implementation.  *  */ public class HashBagTest<T> extends AbstractBagTest<T> {      public HashBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashBagTest.class);     }      //-----------------------------------------------------------------------      @Override     public Bag<T> makeObject() {         return new HashBag<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/HashBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/HashBag.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link PredicatedBag}  * implementation.  *  * @since 3.0  */ public class PredicatedBagTest<T> extends AbstractBagTest<T> {      public PredicatedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedBagTest.class);     }      //--------------------------------------------------------------------------      protected Predicate<T> stringPredicate() {         return o -> o instanceof String;     }      protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();      protected Bag<T> decorateBag(final HashBag<T> bag, final Predicate<T> predicate) {         return PredicatedBag.predicatedBag(bag, predicate);     }      @Override     public Bag<T> makeObject() {         return decorateBag(new HashBag<T>(), truePredicate);     }      protected Bag<T> makeTestBag() {         return decorateBag(new HashBag<T>(), stringPredicate());     }      //--------------------------------------------------------------------------      @SuppressWarnings("unchecked")     public void testlegalAddRemove() {         final Bag<T> bag = makeTestBag();         assertEquals(0, bag.size());         final T[] els = (T[]) new Object[] { "1", "3", "5", "7", "2", "4", "1" };         for (int i = 0; i < els.length; i++) {             bag.add(els[i]);             assertEquals(i + 1, bag.size());             assertTrue(bag.contains(els[i]));         }         Set<T> set = bag.uniqueSet();         assertTrue("Unique set contains the first element", set.contains(els[0]));         assertTrue(bag.remove(els[0]));         set = bag.uniqueSet();         assertFalse("Unique set now does not contain the first element", set.contains(els[0]));     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final Bag<T> bag = makeTestBag();         final Integer i = 3;         try {             bag.add((T) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertFalse("Collection shouldn't contain illegal element", bag.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalDecorate() {         final HashBag<Object> elements = new HashBag<>();         elements.add("one");         elements.add("two");         elements.add(3);         elements.add("four");         try {             decorateBag((HashBag<T>) elements, stringPredicate());             fail("Bag contains an element that should fail the predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         try {             decorateBag(new HashBag<T>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException e) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Test class for {@link CollectionBag}.  * <p>  * Note: This test is mainly for serialization support, the CollectionBag decorator  * is extensively used and tested in AbstractBagTest.  *  * @since 4.0  */ public class CollectionBagTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public CollectionBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------      @Override     public Bag<T> makeObject() {         return CollectionBag.collectionBag(new HashBag<T>());     }      /**      * Returns an empty List for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public Collection<T> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full Set for use in modification testing.      *      * @return a confirmed full collection      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> set = makeConfirmedCollection();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionBag.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionBag.fullCollection.version4.obj"); //    }      //-----------------------------------------------------------------------      /**      * Compares the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeObject();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));             assertTrue("Bag is empty", bag2.isEmpty());             assertEquals(bag, bag2);         }     }      /**      * Compares the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testFullBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = (Bag<T>) makeFullCollection();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));             assertEquals("Bag is the right size", bag.size(), bag2.size());             assertEquals(bag, bag2);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link TransformedBag}  * implementation.  *  * @since 3.0  */ public class TransformedBagTest<T> extends AbstractBagTest<T> {      public TransformedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedBagTest.class);     }      //-----------------------------------------------------------------------      @Override     @SuppressWarnings("unchecked")     public Bag<T> makeObject() {         return TransformedBag.transformingBag(new HashBag<T>(),                 (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedBag() {         //T had better be Object!         final Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(),                 (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertTrue(bag.isEmpty());         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (int i = 0; i < els.length; i++) {             bag.add((T) els[i]);             assertEquals(i + 1, bag.size());             assertTrue(bag.contains(Integer.valueOf((String) els[i])));             assertFalse(bag.contains(els[i]));         }          assertFalse(bag.remove(els[0]));         assertTrue(bag.remove(Integer.valueOf((String) els[0])));     }      @SuppressWarnings("unchecked")     public void testTransformedBag_decorateTransform() {         final Bag<T> originalBag = new HashBag<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (final Object el : els) {             originalBag.add((T) el);         }         final Bag<T> bag = TransformedBag.transformedBag(originalBag,                 (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, bag.size());         for (final Object el : els) {             assertTrue(bag.contains(Integer.valueOf((String) el)));             assertFalse(bag.contains(el));         }          assertFalse(bag.remove(els[0]));         assertTrue(bag.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Arrays;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableSortedBag} implementation.  *  * @since 4.0  */ public class UnmodifiableSortedBagTest<E> extends AbstractSortedBagTest<E> {      public UnmodifiableSortedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableSortedBagTest.class);     }      //-----------------------------------------------------------------------     @Override     public SortedBag<E> makeObject() {         return UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<E>());     }      @Override     public SortedBag<E> makeFullCollection() {         final SortedBag<E> bag = new TreeBag<>();         bag.addAll(Arrays.asList(getFullElements()));         return UnmodifiableSortedBag.unmodifiableSortedBag(bag);     }      @Override     public SortedBag<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final SortedBag<E> queue = makeFullCollection();         assertSame(queue, UnmodifiableSortedBag.unmodifiableSortedBag(queue));          try {             UnmodifiableSortedBag.unmodifiableSortedBag(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        SortedBag<E> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableSortedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableSortedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Test class for {@link CollectionSortedBag}.  * <p>  * Note: This test is mainly for serialization support, the CollectionSortedBag decorator  * is extensively used and tested in AbstractSortedBagTest.  *  * @since 4.0  */ public class CollectionSortedBagTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public CollectionSortedBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------      /**      * Overridden because SortedBags don't allow null elements (normally).      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      @Override     public Bag<T> makeObject() {         return CollectionSortedBag.collectionSortedBag(new TreeBag<T>());     }      /**      * Returns an empty List for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public Collection<T> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full Set for use in modification testing.      *      * @return a confirmed full collection      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> set = makeConfirmedCollection();         set.addAll(Arrays.asList(getFullElements()));         return set;     }      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (T[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (T[]) elements;     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionSortedBag.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CollectionSortedBag.fullCollection.version4.obj"); //    }      //-----------------------------------------------------------------------      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeObject();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));             assertEquals("Bag is empty", 0, bag2.size());             assertEquals(bag, bag2);         }     }      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testFullBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final SortedBag<T> bag = (SortedBag<T>) makeFullCollection();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final SortedBag<?> bag2 = (SortedBag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));             assertEquals("Bag is the right size", bag.size(), bag2.size());             assertEquals(bag, bag2);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Comparator;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractSortedBagTest} for exercising the {@link PredicatedSortedBag}  * implementation.  *  * @since 3.0  */ public class PredicatedSortedBagTest<T> extends AbstractSortedBagTest<T> {      private final SortedBag<T> nullBag = null;      public PredicatedSortedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedSortedBagTest.class);     }      //--------------------------------------------------------------------------      protected Predicate<T> stringPredicate() {         return o -> o instanceof String;     }      protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();      protected SortedBag<T> decorateBag(final SortedBag<T> bag, final Predicate<T> predicate) {         return PredicatedSortedBag.predicatedSortedBag(bag, predicate);     }      @Override     public SortedBag<T> makeObject() {         return decorateBag(new TreeBag<T>(), truePredicate);     }      protected SortedBag<T> makeTestBag() {         return decorateBag(new TreeBag<T>(), stringPredicate());     }      //--------------------------------------------------------------------------      public void testDecorate() {         final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());         ((PredicatedSortedBag<T>) bag).decorated();         try {             decorateBag(new TreeBag<T>(), null);             fail("Expecting NullPointerException for null predicate");         } catch (final NullPointerException e) {}         try {             decorateBag(nullBag, stringPredicate());             fail("Expecting NullPointerException for null bag");         } catch (final NullPointerException e) {}     }      @SuppressWarnings("unchecked")     public void testSortOrder() {         final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());         final String one = "one";         final String two = "two";         final String three = "three";         bag.add((T) one);         bag.add((T) two);         bag.add((T) three);         assertEquals("first element", bag.first(), one);         assertEquals("last element", bag.last(), two);         final Comparator<? super T> c = bag.comparator();         assertNull("natural order, so comparator should be null", c);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedSortedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/PredicatedSortedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Arrays;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableBag} implementation.  *  * @since 4.0  */ public class UnmodifiableBagTest<E> extends AbstractBagTest<E> {      public UnmodifiableBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableBagTest.class);     }      //-----------------------------------------------------------------------     @Override     public Bag<E> makeObject() {         return UnmodifiableBag.unmodifiableBag(new HashBag<E>());     }      @Override     public Bag<E> makeFullCollection() {         final Bag<E> bag = new HashBag<>();         bag.addAll(Arrays.asList(getFullElements()));         return UnmodifiableBag.unmodifiableBag(bag);     }      @Override     public Bag<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Bag<E> queue = makeFullCollection();         assertSame(queue, UnmodifiableBag.unmodifiableBag(queue));          try {             UnmodifiableBag.unmodifiableBag(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<E> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/UnmodifiableBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.set.AbstractSetTest;  import static org.junit.Assert.assertNotEquals;  /**  * Abstract test class for {@link org.apache.commons.collections4.Bag Bag} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your bag fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your bag fails.  * <p>  * <b>Note:</b> The Bag interface does not conform to the Collection interface  * so the generic collection tests from AbstractCollectionTest would normally fail.  * As a work-around since 4.0, a CollectionBag decorator can be used  * to make any Bag implementation comply to the Collection contract.  * <p>  * This abstract test class does wrap the concrete bag implementation  * with such a decorator, see the overridden {@link #resetEmpty()} and  * {@link #resetFull()} methods.  * <p>  * In addition to the generic collection tests (prefix testCollection) inherited  * from AbstractCollectionTest, there are test methods that test the "normal" Bag  * interface (prefix testBag). For Bag specific tests use the {@link #makeObject()} and  * {@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull(),  * otherwise the collection will be wrapped by a {@link CollectionBag} decorator.  *  */ public abstract class AbstractBagTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<T> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full collection.      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> coll = makeConfirmedCollection();         coll.addAll(Arrays.asList(getFullElements()));         return coll;     }      /**      * Return a new, empty bag to used for testing.      *      * @return the bag to be tested      */     @Override     public abstract Bag<T> makeObject();      /**      * {@inheritDoc}      */     @Override     public Bag<T> makeFullCollection() {         final Bag<T> bag = makeObject();         bag.addAll(Arrays.asList(getFullElements()));         return bag;     }      //-----------------------------------------------------------------------      @Override     public void resetEmpty() {         this.setCollection(CollectionBag.collectionBag(makeObject()));         this.setConfirmed(makeConfirmedCollection());     }      @Override     public void resetFull() {         this.setCollection(CollectionBag.collectionBag(makeFullCollection()));         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link Bag}.      *      * @return the collection field as a Bag      */     @Override     public Bag<T> getCollection() {         return (Bag<T>) super.getCollection();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testBagAdd() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         assertTrue("Should contain 'A'", bag.contains("A"));         assertEquals("Should have count of 1", 1, bag.getCount("A"));         bag.add((T) "A");         assertTrue("Should contain 'A'", bag.contains("A"));         assertEquals("Should have count of 2", 2, bag.getCount("A"));         bag.add((T) "B");         assertTrue(bag.contains("A"));         assertTrue(bag.contains("B"));     }      @SuppressWarnings("unchecked")     public void testBagEqualsSelf() {         final Bag<T> bag = makeObject();         assertEquals(bag, bag);          if (!isAddSupported()) {             return;         }          bag.add((T) "elt");         assertEquals(bag, bag);         bag.add((T) "elt"); // again         assertEquals(bag, bag);         bag.add((T) "elt2");         assertEquals(bag, bag);     }      @SuppressWarnings("unchecked")     public void testBagRemove() {         if (!isRemoveSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         assertEquals("Should have count of 1", 1, bag.getCount("A"));         bag.remove("A");         assertEquals("Should have count of 0", 0, bag.getCount("A"));         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "A");         assertEquals("Should have count of 4", 4, bag.getCount("A"));         bag.remove("A", 0);         assertEquals("Should have count of 4", 4, bag.getCount("A"));         bag.remove("A", 2);         assertEquals("Should have count of 2", 2, bag.getCount("A"));         bag.remove("A");         assertEquals("Should have count of 0", 0, bag.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testBagRemoveAll() {         if (!isRemoveSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A", 2);         assertEquals("Should have count of 2", 2, bag.getCount("A"));         bag.add((T) "B");         bag.add((T) "C");         assertEquals("Should have count of 4", 4, bag.size());         final List<String> delete = new ArrayList<>();         delete.add("A");         delete.add("B");         bag.removeAll(delete);         assertEquals("Should have count of 1", 1, bag.getCount("A"));         assertEquals("Should have count of 0", 0, bag.getCount("B"));         assertEquals("Should have count of 1", 1, bag.getCount("C"));         assertEquals("Should have count of 2", 2, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagContains() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();          assertFalse("Bag does not have at least 1 'A'", bag.contains("A"));         assertFalse("Bag does not have at least 1 'B'", bag.contains("B"));          bag.add((T) "A");  // bag 1A         assertTrue("Bag has at least 1 'A'", bag.contains("A"));         assertFalse("Bag does not have at least 1 'B'", bag.contains("B"));          bag.add((T) "A");  // bag 2A         assertTrue("Bag has at least 1 'A'", bag.contains("A"));         assertFalse("Bag does not have at least 1 'B'", bag.contains("B"));          bag.add((T) "B");  // bag 2A,1B         assertTrue("Bag has at least 1 'A'", bag.contains("A"));         assertTrue("Bag has at least 1 'B'", bag.contains("B"));     }      @SuppressWarnings("unchecked")     public void testBagContainsAll() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final List<String> known = new ArrayList<>();         final List<String> known1A = new ArrayList<>();         known1A.add("A");         final List<String> known2A = new ArrayList<>();         known2A.add("A");         known2A.add("A");         final List<String> known1B = new ArrayList<>();         known1B.add("B");         final List<String> known1A1B = new ArrayList<>();         known1A1B.add("A");         known1A1B.add("B");          assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertFalse("Bag does not containsAll of 1 'A'", bag.containsAll(known1A));         assertFalse("Bag does not containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "A");  // bag 1A         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertFalse("Bag does not containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "A");  // bag 2A         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertTrue("Bag containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "A");  // bag 3A         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertTrue("Bag containsAll of 2 'A'", bag.containsAll(known2A));         assertFalse("Bag does not containsAll of 1 'B'", bag.containsAll(known1B));         assertFalse("Bag does not containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));          bag.add((T) "B");  // bag 3A1B         assertTrue("Bag containsAll of empty", bag.containsAll(known));         assertTrue("Bag containsAll of 1 'A'", bag.containsAll(known1A));         assertTrue("Bag containsAll of 2 'A'", bag.containsAll(known2A));         assertTrue("Bag containsAll of 1 'B'", bag.containsAll(known1B));         assertTrue("Bag containsAll of 1 'A' 1 'B'", bag.containsAll(known1A1B));     }      @SuppressWarnings("unchecked")     public void testBagSize() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         assertEquals("Should have 0 total items", 0, bag.size());         bag.add((T) "A");         assertEquals("Should have 1 total items", 1, bag.size());         bag.add((T) "A");         assertEquals("Should have 2 total items", 2, bag.size());         bag.add((T) "A");         assertEquals("Should have 3 total items", 3, bag.size());         bag.add((T) "B");         assertEquals("Should have 4 total items", 4, bag.size());         bag.add((T) "B");         assertEquals("Should have 5 total items", 5, bag.size());         bag.remove("A", 2);         assertEquals("Should have 1 'A'", 1, bag.getCount("A"));         assertEquals("Should have 3 total items", 3, bag.size());         bag.remove("B");         assertEquals("Should have 1 total item", 1, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagRetainAll() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         final List<String> retains = new ArrayList<>();         retains.add("B");         retains.add("C");         bag.retainAll(retains);         assertEquals("Should have 2 total items", 2, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagIterator() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         assertEquals("Bag should have 3 items", 3, bag.size());         final Iterator<T> i = bag.iterator();          boolean foundA = false;         while (i.hasNext()) {             final String element = (String) i.next();             // ignore the first A, remove the second via Iterator.remove()             if (element.equals("A")) {                 if (!foundA) {                     foundA = true;                 } else {                     i.remove();                 }             }         }          assertTrue("Bag should still contain 'A'", bag.contains("A"));         assertEquals("Bag should have 2 items", 2, bag.size());         assertEquals("Bag should have 1 'A'", 1, bag.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testBagIteratorFail() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         final Iterator<T> it = bag.iterator();         it.next();         bag.remove("A");         try {             it.next();             fail("Should throw ConcurrentModificationException");         } catch (final ConcurrentModificationException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testBagIteratorFailNoMore() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         final Iterator<T> it = bag.iterator();         it.next();         it.next();         it.next();         try {             it.next();             fail("Should throw NoSuchElementException");         } catch (final NoSuchElementException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testBagIteratorFailDoubleRemove() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         final Iterator<T> it = bag.iterator();         it.next();         it.next();         assertEquals(3, bag.size());         it.remove();         assertEquals(2, bag.size());         try {             it.remove();             fail("Should throw IllegalStateException");         } catch (final IllegalStateException ex) {             // expected         }         assertEquals(2, bag.size());         it.next();         it.remove();         assertEquals(1, bag.size());     }      @SuppressWarnings("unchecked")     public void testBagIteratorRemoveProtectsInvariants() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         assertEquals(2, bag.size());         final Iterator<T> it = bag.iterator();         assertEquals("A", it.next());         assertTrue(it.hasNext());         it.remove();         assertEquals(1, bag.size());         assertTrue(it.hasNext());         assertEquals("A", it.next());         assertFalse(it.hasNext());         it.remove();         assertEquals(0, bag.size());         assertFalse(it.hasNext());          final Iterator<T> it2 = bag.iterator();         assertFalse(it2.hasNext());     }      @SuppressWarnings("unchecked")     public void testBagToArray() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         final Object[] array = bag.toArray();         int a = 0, b = 0, c = 0;         for (final Object element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      @SuppressWarnings("unchecked")     public void testBagToArrayPopulate() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         final String[] array = bag.toArray(new String[0]);         int a = 0, b = 0, c = 0;         for (final String element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testBagEquals() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final Bag<T> bag2 = makeObject();         assertEquals(bag, bag2);         bag.add((T) "A");         assertNotEquals(bag, bag2);         bag2.add((T) "A");         assertEquals(bag, bag2);         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         bag2.add((T) "A");         bag2.add((T) "B");         bag2.add((T) "B");         bag2.add((T) "C");         assertEquals(bag, bag2);     }      @SuppressWarnings("unchecked")     public void testBagEqualsHashBag() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final Bag<T> bag2 = new HashBag<>();         assertEquals(bag, bag2);         bag.add((T) "A");         assertNotEquals(bag, bag2);         bag2.add((T) "A");         assertEquals(bag, bag2);         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         bag2.add((T) "A");         bag2.add((T) "B");         bag2.add((T) "B");         bag2.add((T) "C");         assertEquals(bag, bag2);     }      @SuppressWarnings("unchecked")     public void testBagHashCode() {         if (!isAddSupported()) {             return;         }          final Bag<T> bag = makeObject();         final Bag<T> bag2 = makeObject();         assertEquals(0, bag.hashCode());         assertEquals(0, bag2.hashCode());         assertEquals(bag.hashCode(), bag2.hashCode());         bag.add((T) "A");         bag.add((T) "A");         bag.add((T) "B");         bag.add((T) "B");         bag.add((T) "C");         bag2.add((T) "A");         bag2.add((T) "A");         bag2.add((T) "B");         bag2.add((T) "B");         bag2.add((T) "C");         assertEquals(bag.hashCode(), bag2.hashCode());          int total = 0;         total += "A".hashCode() ^ 2;         total += "B".hashCode() ^ 2;         total += "C".hashCode() ^ 1;         assertEquals(total, bag.hashCode());         assertEquals(total, bag2.hashCode());     }      //-----------------------------------------------------------------------      /**      * Bulk test {@link Bag#uniqueSet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the bag and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the bag's unique set      */     public BulkTest bulkTestBagUniqueSet() {         return new TestBagUniqueSet();     }      public class TestBagUniqueSet extends AbstractSetTest<T> {         public TestBagUniqueSet() {             super("");         }          @Override         public T[] getFullElements() {             return AbstractBagTest.this.getFullElements();         }          @Override         public T[] getOtherElements() {             return AbstractBagTest.this.getOtherElements();         }          @Override         public Set<T> makeObject() {             return AbstractBagTest.this.makeObject().uniqueSet();         }          @Override         public Set<T> makeFullCollection() {             return AbstractBagTest.this.makeFullCollection().uniqueSet();         }          @Override         public boolean isNullSupported() {             return AbstractBagTest.this.isNullSupported();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return false;         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetEmpty() {             AbstractBagTest.this.resetEmpty();             TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());             TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));         }          @Override         public void resetFull() {             AbstractBagTest.this.resetFull();             TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());             TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));         }          @Override         public void verify() {             super.verify();         }     }      //-----------------------------------------------------------------------      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeObject();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));             assertTrue("Bag is empty", bag2.isEmpty());             assertEquals(bag, bag2);         }     }      /**      * Compare the current serialized form of the Bag      * against the canonical version in SCM.      */     public void testFullBagCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final Bag<T> bag = makeFullCollection();         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));             assertEquals("Bag is the right size", bag.size(), bag2.size());             assertEquals(bag, bag2);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import java.util.Iterator;  import org.apache.commons.collections4.SortedBag;  /**  * Abstract test class for  * {@link org.apache.commons.collections4.SortedBag SortedBag}  * methods and contracts.  *  * @since 3.0  */ public abstract class AbstractSortedBagTest<T> extends AbstractBagTest<T> {      public AbstractSortedBagTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Verification extension, will check the order of elements,      * the sets should already be verified equal.      */     @Override     public void verify() {         super.verify();          // Check that iterator returns elements in order and first() and last()         // are consistent         final Iterator<T> colliter = getCollection().iterator();         final Iterator<T> confiter = getConfirmed().iterator();         T first = null;         T last = null;         while (colliter.hasNext()) {             if (first == null) {                 first = colliter.next();                 last = first;             } else {                 last = colliter.next();             }             assertEquals("Element appears to be out of order.", last, confiter.next());         }         if (getCollection().size() > 0) {             assertEquals("Incorrect element returned by first().", first,                 getCollection().first());             assertEquals("Incorrect element returned by last().", last,                 getCollection().last());         }     }      //-----------------------------------------------------------------------     /**      * Overridden because SortedBags don't allow null elements (normally).      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedBag<T> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedBag<T> makeFullCollection() {         return (SortedBag<T>) super.makeFullCollection();     }      /**      * Returns an empty {@link TreeBag} for use in modification testing.      *      * @return a confirmed empty collection      */     @Override     public SortedBag<T> makeConfirmedCollection() {         return new TreeBag<>();     }      //-----------------------------------------------------------------------      @Override     public void resetEmpty() {         this.setCollection(CollectionSortedBag.collectionSortedBag(makeObject()));         this.setConfirmed(makeConfirmedCollection());     }      @Override     public void resetFull() {         this.setCollection(CollectionSortedBag.collectionSortedBag(makeFullCollection()));         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getFullNonNullElements() {         final Object[] elements = new Object[30];          for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 1);         }         return (T[]) elements;     }      /**      * Override to return comparable objects.      */     @Override     @SuppressWarnings("unchecked")     public T[] getOtherNonNullElements() {         final Object[] elements = new Object[30];         for (int i = 0; i < 30; i++) {             elements[i] = Integer.valueOf(i + i + 2);         }         return (T[]) elements;     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link SortedBag}.      *      * @return the collection field as a SortedBag      */     @Override     public SortedBag<T> getCollection() {         return (SortedBag<T>) super.getCollection();     }      //-----------------------------------------------------------------------      // TODO: Add the SortedBag tests! } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.SortedBag; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSortedBagTest} for exercising the {@link TransformedSortedBag}  * implementation.  *  * @since 3.0  */ public class TransformedSortedBagTest<T> extends AbstractSortedBagTest<T> {      public TransformedSortedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedSortedBagTest.class);     }      //-----------------------------------------------------------------------      @Override     @SuppressWarnings("unchecked")     public SortedBag<T> makeObject() {         return TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @SuppressWarnings("unchecked")     public void testTransformedBag() {         final SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, bag.size());         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (int i = 0; i < els.length; i++) {             bag.add((T) els[i]);             assertEquals(i + 1, bag.size());             assertTrue(bag.contains(Integer.valueOf((String) els[i])));         }          assertTrue(bag.remove(Integer.valueOf((String) els[0])));      }      public void testTransformedBag_decorateTransform() {         final TreeBag<T> originalBag = new TreeBag<>();         final Object[] els = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         for (final Object el : els) {             originalBag.add((T) el);         }         final SortedBag<T> bag = TransformedSortedBag.transformedSortedBag(originalBag, (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(els.length, bag.size());         for (final Object el : els) {             assertTrue(bag.contains(Integer.valueOf((String) el)));         }          assertTrue(bag.remove(Integer.valueOf((String) els[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedSortedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/TransformedSortedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.bag;  import junit.framework.Test;  import org.apache.commons.collections4.Bag; import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractBagTest} for exercising the {@link SynchronizedBag}  * implementation.  *  * @since 4.0  */ public class SynchronizedBagTest<T> extends AbstractBagTest<T> {      public SynchronizedBagTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(SynchronizedBagTest.class);     }      //-----------------------------------------------------------------------      @Override     public Bag<T> makeObject() {         return SynchronizedBag.synchronizedBag(new HashBag<T>());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        Bag<T> bag = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/SynchronizedBag.emptyCollection.version4.obj"); //        bag = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) bag, "src/test/resources/data/test/SynchronizedBag.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link SynchronizedMultiSet} implementation.  *  * @since 4.1  */ public class SynchronizedMultiSetTest<T> extends AbstractMultiSetTest<T> {      public SynchronizedMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(SynchronizedMultiSetTest.class);     }      //-----------------------------------------------------------------------      @Override     public MultiSet<T> makeObject() {         return SynchronizedMultiSet.synchronizedMultiSet(new HashMultiSet<T>());     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<T> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/SynchronizedMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/SynchronizedMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link PredicatedMultiSet} implementation.  *  * @since 4.1  */ public class PredicatedMultiSetTest<T> extends AbstractMultiSetTest<T> {      public PredicatedMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(PredicatedMultiSetTest.class);     }      //--------------------------------------------------------------------------      protected Predicate<T> stringPredicate() {         return o -> o instanceof String;     }      protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();      protected MultiSet<T> decorateMultiSet(final HashMultiSet<T> multiset, final Predicate<T> predicate) {         return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);     }      @Override     public MultiSet<T> makeObject() {         return decorateMultiSet(new HashMultiSet<T>(), truePredicate);     }      protected MultiSet<T> makeTestMultiSet() {         return decorateMultiSet(new HashMultiSet<T>(), stringPredicate());     }      //--------------------------------------------------------------------------      @SuppressWarnings("unchecked")     public void testLegalAddRemove() {         final MultiSet<T> multiset = makeTestMultiSet();         assertEquals(0, multiset.size());         final T[] els = (T[]) new Object[] { "1", "3", "5", "7", "2", "4", "1" };         for (int i = 0; i < els.length; i++) {             multiset.add(els[i]);             assertEquals(i + 1, multiset.size());             assertEquals(true, multiset.contains(els[i]));         }         Set<T> set = ((PredicatedMultiSet<T>) multiset).uniqueSet();         assertTrue("Unique set contains the first element", set.contains(els[0]));         assertEquals(true, multiset.remove(els[0]));         set = ((PredicatedMultiSet<T>) multiset).uniqueSet();         assertTrue("Unique set does not contain anymore the first element",             set.contains(els[0]));     }      @SuppressWarnings("unchecked")     public void testIllegalAdd() {         final MultiSet<T> multiset = makeTestMultiSet();         final Integer i = Integer.valueOf(3);         try {             multiset.add((T) i);             fail("Integer should fail string predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         assertTrue("Collection shouldn't contain illegal element",                    !multiset.contains(i));     }      @SuppressWarnings("unchecked")     public void testIllegalDecorate() {         final HashMultiSet<Object> elements = new HashMultiSet<>();         elements.add("one");         elements.add("two");         elements.add(Integer.valueOf(3));         elements.add("four");         try {             decorateMultiSet((HashMultiSet<T>) elements, stringPredicate());             fail("MultiSet contains an element that should fail the predicate.");         } catch (final IllegalArgumentException e) {             // expected         }         try {             decorateMultiSet(new HashMultiSet<T>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException e) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<T> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/PredicatedMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/PredicatedMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link HashMultiSet} implementation.  *  * @since 4.1  */ public class HashMultiSetTest<T> extends AbstractMultiSetTest<T> {      public HashMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashMultiSetTest.class);     }      //-----------------------------------------------------------------------      @Override     public MultiSet<T> makeObject() {         return new HashMultiSet<>();     }      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<T> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/HashMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/HashMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.ConcurrentModificationException; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Set;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.set.AbstractSetTest;  /**  * Abstract test class for {@link org.apache.commons.collections4.MultiSet MultiSet}  * methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your multiset fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your multiset fails.  * <p>  * This abstract test class does wrap the concrete multiset implementation  * with such a decorator, see the overridden {@link #resetEmpty()} and  * {@link #resetFull()} methods.  * <p>  * In addition to the generic collection tests (prefix testCollection) inherited  * from AbstractCollectionTest, there are test methods that test the "normal" MultiSet  * interface (prefix testMultiSet). For MultiSet specific tests use the {@link #makeObject()} and  * {@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull().  *  * @since 4.1  */ public abstract class AbstractMultiSetTest<T> extends AbstractCollectionTest<T> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractMultiSetTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<T> makeConfirmedCollection() {         final ArrayList<T> list = new ArrayList<>();         return list;     }      /**      * Returns a full collection.      */     @Override     public Collection<T> makeConfirmedFullCollection() {         final Collection<T> coll = makeConfirmedCollection();         coll.addAll(Arrays.asList(getFullElements()));         return coll;     }      /**      * Return a new, empty multiset to used for testing.      *      * @return the multiset to be tested      */     @Override     public abstract MultiSet<T> makeObject();      /**      * {@inheritDoc}      */     @Override     public MultiSet<T> makeFullCollection() {         final MultiSet<T> multiset = makeObject();         multiset.addAll(Arrays.asList(getFullElements()));         return multiset;     }      //-----------------------------------------------------------------------      @Override     public void resetEmpty() {         this.setCollection(makeObject());         this.setConfirmed(makeConfirmedCollection());     }      @Override     public void resetFull() {         this.setCollection(makeFullCollection());         this.setConfirmed(makeConfirmedFullCollection());     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link MultiSet}.      *      * @return the collection field as a MultiSet      */     @Override     public MultiSet<T> getCollection() {         return (MultiSet<T>) super.getCollection();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMultiSetAdd() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         assertTrue("Should contain 'A'", multiset.contains("A"));         assertEquals("Should have count of 1", 1, multiset.getCount("A"));         multiset.add((T) "A");         assertTrue("Should contain 'A'", multiset.contains("A"));         assertEquals("Should have count of 2", 2, multiset.getCount("A"));         multiset.add((T) "B");         assertTrue(multiset.contains("A"));         assertTrue(multiset.contains("B"));     }      @SuppressWarnings("unchecked")     public void testMultiSetEqualsSelf() {         final MultiSet<T> multiset = makeObject();         assertTrue(multiset.equals(multiset));          if (!isAddSupported()) {             return;         }          multiset.add((T) "elt");         assertTrue(multiset.equals(multiset));         multiset.add((T) "elt"); // again         assertTrue(multiset.equals(multiset));         multiset.add((T) "elt2");         assertTrue(multiset.equals(multiset));     }      @SuppressWarnings("unchecked")     public void testMultiSetRemove() {         if (!isRemoveSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         assertEquals("Should have count of 1", 1, multiset.getCount("A"));         multiset.remove("A");         assertEquals("Should have count of 0", 0, multiset.getCount("A"));         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "A");         assertEquals("Should have count of 4", 4, multiset.getCount("A"));         multiset.remove("A", 0);         assertEquals("Should have count of 4", 4, multiset.getCount("A"));         multiset.remove("A", 2);         assertEquals("Should have count of 2", 2, multiset.getCount("A"));         multiset.remove("A");         assertEquals("Should have count of 1", 1, multiset.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testMultiSetRemoveAll() {         if (!isRemoveSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A", 2);         assertEquals("Should have count of 2", 2, multiset.getCount("A"));         multiset.add((T) "B");         multiset.add((T) "C");         assertEquals("Should have count of 4", 4, multiset.size());         final List<String> delete = new ArrayList<>();         delete.add("A");         delete.add("B");         multiset.removeAll(delete);         assertEquals("Should have count of 0", 0, multiset.getCount("A"));         assertEquals("Should have count of 0", 0, multiset.getCount("B"));         assertEquals("Should have count of 1", 1, multiset.getCount("C"));         assertEquals("Should have count of 1", 1, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetContains() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();          assertEquals("MultiSet does not have at least 1 'A'", false, multiset.contains("A"));         assertEquals("MultiSet does not have at least 1 'B'", false, multiset.contains("B"));          multiset.add((T) "A");  // multiset 1A         assertEquals("MultiSet has at least 1 'A'", true, multiset.contains("A"));         assertEquals("MultiSet does not have at least 1 'B'", false, multiset.contains("B"));          multiset.add((T) "A");  // multiset 2A         assertEquals("MultiSet has at least 1 'A'", true, multiset.contains("A"));         assertEquals("MultiSet does not have at least 1 'B'", false, multiset.contains("B"));          multiset.add((T) "B");  // multiset 2A,1B         assertEquals("MultiSet has at least 1 'A'", true, multiset.contains("A"));         assertEquals("MultiSet has at least 1 'B'", true, multiset.contains("B"));     }      @SuppressWarnings("unchecked")     public void testMultiSetContainsAll() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final List<String> known = new ArrayList<>();         final List<String> known1A = new ArrayList<>();         known1A.add("A");         final List<String> known2A = new ArrayList<>();         known2A.add("A");         known2A.add("A");         final List<String> known1B = new ArrayList<>();         known1B.add("B");         final List<String> known1A1B = new ArrayList<>();         known1A1B.add("A");         known1A1B.add("B");          assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet does not containsAll of 1 'A'", false, multiset.containsAll(known1A));         assertEquals("MultiSet does not containsAll of 2 'A'", false, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "A");  // multiset 1A         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet does not containsAll 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "A");  // multiset 2A         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet containsAll of 2 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "A");  // multiset 3A         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet containsAll of 2 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet does not containsAll of 1 'B'", false, multiset.containsAll(known1B));         assertEquals("MultiSet does not containsAll of 1 'A' 1 'B'", false, multiset.containsAll(known1A1B));          multiset.add((T) "B");  // multiset 3A1B         assertEquals("MultiSet containsAll of empty", true, multiset.containsAll(known));         assertEquals("MultiSet containsAll of 1 'A'", true, multiset.containsAll(known1A));         assertEquals("MultiSet containsAll of 2 'A'", true, multiset.containsAll(known2A));         assertEquals("MultiSet containsAll of 1 'B'", true, multiset.containsAll(known1B));         assertEquals("MultiSet containsAll of 1 'A' 1 'B'", true, multiset.containsAll(known1A1B));     }      @SuppressWarnings("unchecked")     public void testMultiSetSize() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         assertEquals("Should have 0 total items", 0, multiset.size());         multiset.add((T) "A");         assertEquals("Should have 1 total items", 1, multiset.size());         multiset.add((T) "A");         assertEquals("Should have 2 total items", 2, multiset.size());         multiset.add((T) "A");         assertEquals("Should have 3 total items", 3, multiset.size());         multiset.add((T) "B");         assertEquals("Should have 4 total items", 4, multiset.size());         multiset.add((T) "B");         assertEquals("Should have 5 total items", 5, multiset.size());         multiset.remove("A", 2);         assertEquals("Should have 1 'A'", 1, multiset.getCount("A"));         assertEquals("Should have 3 total items", 3, multiset.size());         multiset.remove("B");         assertEquals("Should have 2 total item", 2, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetRetainAll() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         final List<String> retains = new ArrayList<>();         retains.add("B");         retains.add("C");         multiset.retainAll(retains);         assertEquals("Should have 3 total items", 3, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetIterator() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         assertEquals("MultiSet should have 3 items", 3, multiset.size());         final Iterator<T> i = multiset.iterator();          boolean foundA = false;         while (i.hasNext()) {             final String element = (String) i.next();             // ignore the first A, remove the second via Iterator.remove()             if (element.equals("A")) {                 if (!foundA) {                     foundA = true;                 } else {                     i.remove();                 }             }         }          assertTrue("MultiSet should still contain 'A'", multiset.contains("A"));         assertEquals("MultiSet should have 2 items", 2, multiset.size());         assertEquals("MultiSet should have 1 'A'", 1, multiset.getCount("A"));     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorFail() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         final Iterator<T> it = multiset.iterator();         it.next();         multiset.remove("A");         try {             it.next();             fail("Should throw ConcurrentModificationException");         } catch (final ConcurrentModificationException e) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorFailNoMore() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         final Iterator<T> it = multiset.iterator();         it.next();         it.next();         it.next();         try {             it.next();             fail("Should throw NoSuchElementException");         } catch (final NoSuchElementException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorFailDoubleRemove() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         final Iterator<T> it = multiset.iterator();         it.next();         it.next();         assertEquals(3, multiset.size());         it.remove();         assertEquals(2, multiset.size());         try {             it.remove();             fail("Should throw IllegalStateException");         } catch (final IllegalStateException ex) {             // expected         }         assertEquals(2, multiset.size());         it.next();         it.remove();         assertEquals(1, multiset.size());     }      @SuppressWarnings("unchecked")     public void testMultiSetIteratorRemoveProtectsInvariants() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         assertEquals(2, multiset.size());         final Iterator<T> it = multiset.iterator();         assertEquals("A", it.next());         assertEquals(true, it.hasNext());         it.remove();         assertEquals(1, multiset.size());         assertEquals(true, it.hasNext());         assertEquals("A", it.next());         assertEquals(false, it.hasNext());         it.remove();         assertEquals(0, multiset.size());         assertEquals(false, it.hasNext());          final Iterator<T> it2 = multiset.iterator();         assertEquals(false, it2.hasNext());     }      @SuppressWarnings("unchecked")     public void testMultiSetEntrySetUpdatedToZero() {         if (!isAddSupported()) {             return;         }         final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         final MultiSet.Entry<T> entry = multiset.entrySet().iterator().next();         assertEquals(2, entry.getCount());         multiset.remove("A");         assertEquals(1, entry.getCount());         multiset.remove("A");         assertEquals(0, entry.getCount());     }      @SuppressWarnings("unchecked")     public void testMultiSetToArray() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         final Object[] array = multiset.toArray();         int a = 0, b = 0, c = 0;         for (final Object element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      @SuppressWarnings("unchecked")     public void testMultiSetToArrayPopulate() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         final String[] array = multiset.toArray(new String[0]);         int a = 0, b = 0, c = 0;         for (final String element : array) {             a += element.equals("A") ? 1 : 0;             b += element.equals("B") ? 1 : 0;             c += element.equals("C") ? 1 : 0;         }         assertEquals(2, a);         assertEquals(2, b);         assertEquals(1, c);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMultiSetEquals() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final MultiSet<T> multiset2 = makeObject();         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         assertEquals(false, multiset.equals(multiset2));         multiset2.add((T) "A");         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         multiset2.add((T) "A");         multiset2.add((T) "B");         multiset2.add((T) "B");         multiset2.add((T) "C");         assertEquals(true, multiset.equals(multiset2));     }      @SuppressWarnings("unchecked")     public void testMultiSetEqualsHashMultiSet() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final MultiSet<T> multiset2 = new HashMultiSet<>();         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         assertEquals(false, multiset.equals(multiset2));         multiset2.add((T) "A");         assertEquals(true, multiset.equals(multiset2));         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         multiset2.add((T) "A");         multiset2.add((T) "B");         multiset2.add((T) "B");         multiset2.add((T) "C");         assertEquals(true, multiset.equals(multiset2));     }      @SuppressWarnings("unchecked")     public void testMultiSetHashCode() {         if (!isAddSupported()) {             return;         }          final MultiSet<T> multiset = makeObject();         final MultiSet<T> multiset2 = makeObject();         assertEquals(0, multiset.hashCode());         assertEquals(0, multiset2.hashCode());         assertEquals(multiset.hashCode(), multiset2.hashCode());         multiset.add((T) "A");         multiset.add((T) "A");         multiset.add((T) "B");         multiset.add((T) "B");         multiset.add((T) "C");         multiset2.add((T) "A");         multiset2.add((T) "A");         multiset2.add((T) "B");         multiset2.add((T) "B");         multiset2.add((T) "C");         assertEquals(multiset.hashCode(), multiset2.hashCode());          int total = 0;         total += "A".hashCode() ^ 2;         total += "B".hashCode() ^ 2;         total += "C".hashCode() ^ 1;         assertEquals(total, multiset.hashCode());         assertEquals(total, multiset2.hashCode());     }      //-----------------------------------------------------------------------      /**      * Bulk test {@link MultiSet#uniqueSet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the multiset and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the multiset's unique set      */     public BulkTest bulkTestMultiSetUniqueSet() {         return new TestMultiSetUniqueSet();     }      public class TestMultiSetUniqueSet extends AbstractSetTest<T> {         public TestMultiSetUniqueSet() {             super("");         }          @Override         public T[] getFullElements() {             return AbstractMultiSetTest.this.getFullElements();         }          @Override         public T[] getOtherElements() {             return AbstractMultiSetTest.this.getOtherElements();         }          @Override         public Set<T> makeObject() {             return AbstractMultiSetTest.this.makeObject().uniqueSet();         }          @Override         public Set<T> makeFullCollection() {             return AbstractMultiSetTest.this.makeFullCollection().uniqueSet();         }          @Override         public boolean isNullSupported() {             return AbstractMultiSetTest.this.isNullSupported();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMultiSetTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetEmpty() {             AbstractMultiSetTest.this.resetEmpty();             TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());             TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));         }          @Override         public void resetFull() {             AbstractMultiSetTest.this.resetFull();             TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());             TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));         }          @Override         public void verify() {             super.verify();         }     }      //-----------------------------------------------------------------------      /**      * Compare the current serialized form of the MultiSet      * against the canonical version in SCM.      */     public void testEmptyMultiSetCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final MultiSet<T> multiset = makeObject();         if (multiset instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final MultiSet<?> multiset2 = (MultiSet<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(multiset));             assertTrue("MultiSet is empty", multiset2.size() == 0);             assertEquals(multiset, multiset2);         }     }      /**      * Compare the current serialized form of the MultiSet      * against the canonical version in SCM.      */     public void testFullMultiSetCompatibility() throws IOException, ClassNotFoundException {         // test to make sure the canonical form has been preserved         final MultiSet<T> multiset = makeFullCollection();         if (multiset instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final MultiSet<?> multiset2 = (MultiSet<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(multiset));             assertEquals("MultiSet is the right size", multiset.size(), multiset2.size());             assertEquals(multiset, multiset2);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.multiset;  import java.util.Arrays;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MultiSet; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractMultiSetTest} for exercising the  * {@link UnmodifiableMultiSet} implementation.  *  * @since 4.1  */ public class UnmodifiableMultiSetTest<E> extends AbstractMultiSetTest<E> {      public UnmodifiableMultiSetTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(UnmodifiableMultiSetTest.class);     }      //-----------------------------------------------------------------------     @Override     public MultiSet<E> makeObject() {         return UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<E>());     }      @Override     public MultiSet<E> makeFullCollection() {         final MultiSet<E> multiset = new HashMultiSet<>();         multiset.addAll(Arrays.asList(getFullElements()));         return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);     }      @Override     public MultiSet<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final MultiSet<E> multiset = makeFullCollection();         assertSame(multiset, UnmodifiableMultiSet.unmodifiableMultiSet(multiset));          try {             UnmodifiableMultiSet.unmodifiableMultiSet(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      public void testAdd() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         try {             unmodifiableMultiSet.add((E) "One", 1);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testRemove() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         try {             unmodifiableMultiSet.remove("One", 1);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testSetCount() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         try {             unmodifiableMultiSet.setCount((E) "One", 2);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testEntrySet() {         final MultiSet<E> multiset = makeFullCollection();         final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);         assertSame( unmodifiableMultiSet.entrySet().size(), multiset.entrySet().size());     }     //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4.1";     }  //    public void testCreate() throws Exception { //        MultiSet<E> multiset = makeObject(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/UnmodifiableMultiSet.emptyCollection.version4.1.obj"); //        multiset = makeFullCollection(); //        writeExternalFormToDisk((java.io.Serializable) multiset, "src/test/resources/data/test/UnmodifiableMultiSet.fullCollection.version4.1.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.BulkTest; import org.junit.Ignore;  import junit.framework.Test;  /**  * Extension of {@link AbstractQueueTest} for exercising the {@link SynchronizedQueue} implementation.  *  * @since 4.2  */ public class SynchronizedQueueTest<T> extends AbstractQueueTest<T> {      public static Test suite() {         return BulkTest.makeSuite(SynchronizedQueueTest.class);     }      public SynchronizedQueueTest(final String testName) {         super(testName);     }      // -----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4.2";     }      @Override     public Queue<T> makeObject() {         return SynchronizedQueue.synchronizedQueue(new LinkedList<T>());     }      @Ignore("Run once")     public void testCreate() throws Exception {         Queue<T> queue = makeObject();         writeExternalFormToDisk((java.io.Serializable) queue,             BulkTest.TEST_DATA_PATH + "SynchronizedQueue.emptyCollection.version4.2.obj");         queue = makeFullCollection();         writeExternalFormToDisk((java.io.Serializable) queue,             BulkTest.TEST_DATA_PATH + "SynchronizedQueue.fullCollection.version4.2.obj");     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.Arrays; import java.util.Collections; import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link TransformedQueue} implementation.  *  * @since 4.0  */ public class TransformedQueueTest<E> extends AbstractQueueTest<E> {      public TransformedQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Queue<E> makeConfirmedCollection() {         return new LinkedList<>();     }      @Override     public Queue<E> makeConfirmedFullCollection() {         return new LinkedList<>(Arrays.asList(getFullElements()));     }      @Override     @SuppressWarnings("unchecked")     public Queue<E> makeObject() {         return TransformedQueue.transformingQueue(new LinkedList<E>(),                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      @Override     @SuppressWarnings("unchecked")     public Queue<E> makeFullCollection() {         final Queue<E> list = new LinkedList<>(Arrays.asList(getFullElements()));         return TransformedQueue.transformingQueue(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);     }      //-----------------------------------------------------------------------     public void testTransformedQueue() {         final Queue<Object> queue = TransformedQueue.transformingQueue(new LinkedList<>(),                 TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, queue.size());         final Object[] elements = new Object[] { "1", "3", "5", "7", "2", "4", "6" };         for (int i = 0; i < elements.length; i++) {             queue.add(elements[i]);             assertEquals(i + 1, queue.size());             assertEquals(true, queue.contains(Integer.valueOf((String) elements[i])));             assertEquals(false, queue.contains(elements[i]));         }          assertEquals(false, queue.remove(elements[0]));         assertEquals(true, queue.remove(Integer.valueOf((String) elements[0])));      }      @SuppressWarnings({ "rawtypes", "unchecked" })     public void testTransformedQueue_decorateTransform() {         final Queue originalQueue = new LinkedList();         final Object[] elements = new Object[] {"1", "3", "5", "7", "2", "4", "6"};         Collections.addAll(originalQueue, elements);         final Queue<?> queue = TransformedQueue.transformedQueue(originalQueue,                 TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(elements.length, queue.size());         for (final Object el : elements) {             assertEquals(true, queue.contains(Integer.valueOf((String) el)));             assertEquals(false, queue.contains(el));         }          assertEquals(false, queue.remove(elements[0]));         assertEquals(true, queue.remove(Integer.valueOf((String) elements[0])));     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //  public void testCreate() throws Exception { //      resetEmpty(); //      writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedQueue.emptyCollection.version4.obj"); //      resetFull(); //      writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/TransformedQueue.fullCollection.version4.obj"); //  }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException; import java.util.Queue;  /**  * Test cases for CircularFifoQueue.  *  * @since 4.0  */ public class CircularFifoQueueTest<E> extends AbstractQueueTest<E> {      public CircularFifoQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Runs through the regular verifications, but also verifies that      *  the buffer contains the same elements in the same sequence as the      *  list.      */     @Override     public void verify() {         super.verify();         final Iterator<E> iterator1 = getCollection().iterator();         for (final E e : getConfirmed()) {             assertTrue(iterator1.hasNext());             final Object o1 = iterator1.next();             final Object o2 = e;             assertEquals(o1, o2);         }     }      //-----------------------------------------------------------------------     /**      * Overridden because CircularFifoQueue doesn't allow null elements.      * @return false      */     @Override     public boolean isNullSupported() {         return false;     }      /**      * Overridden because CircularFifoQueue isn't fail fast.      * @return false      */     @Override     public boolean isFailFastSupported() {         return false;     }      //-----------------------------------------------------------------------     /**      * Returns an empty ArrayList.      *      * @return an empty ArrayList      */     @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full ArrayList.      *      * @return a full ArrayList      */     @Override     public Collection<E> makeConfirmedFullCollection() {         final Collection<E> c = makeConfirmedCollection();         c.addAll(java.util.Arrays.asList(getFullElements()));         return c;     }      /**      * Returns an empty CircularFifoQueue that won't overflow.      *      * @return an empty CircularFifoQueue      */     @Override     public Queue<E> makeObject() {         return new CircularFifoQueue<>(100);     }      //-----------------------------------------------------------------------     /**      * Tests that the removal operation actually removes the first element.      */     @SuppressWarnings("unchecked")     public void testCircularFifoQueueCircular() {         final List<E> list = new ArrayList<>();         list.add((E) "A");         list.add((E) "B");         list.add((E) "C");         final Queue<E> queue = new CircularFifoQueue<>(list);          assertEquals(true, queue.contains("A"));         assertEquals(true, queue.contains("B"));         assertEquals(true, queue.contains("C"));          queue.add((E) "D");          assertEquals(false, queue.contains("A"));         assertEquals(true, queue.contains("B"));         assertEquals(true, queue.contains("C"));         assertEquals(true, queue.contains("D"));          assertEquals("B", queue.peek());         assertEquals("B", queue.remove());         assertEquals("C", queue.remove());         assertEquals("D", queue.remove());     }      /**      * Tests that the removal operation actually removes the first element.      */     public void testCircularFifoQueueRemove() {         resetFull();         final int size = getConfirmed().size();         for (int i = 0; i < size; i++) {             final Object o1 = getCollection().remove();             final Object o2 = ((List<?>) getConfirmed()).remove(0);             assertEquals("Removed objects should be equal", o1, o2);             verify();         }          try {             getCollection().remove();             fail("Empty queue should raise Underflow.");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      * Tests that the constructor correctly throws an exception.      */     public void testConstructorException1() {         try {             new CircularFifoQueue<E>(0);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      /**      * Tests that the constructor correctly throws an exception.      */     public void testConstructorException2() {         try {             new CircularFifoQueue<E>(-20);         } catch (final IllegalArgumentException ex) {             return;         }         fail();     }      /**      * Tests that the constructor correctly throws an exception.      */     public void testConstructorException3() {         try {             new CircularFifoQueue<E>(null);         } catch (final NullPointerException ex) {             return;         }         fail();     }      @SuppressWarnings("unchecked")     public void testRemoveError1() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");          assertEquals("[1, 2, 3, 4, 5]", fifo.toString());          fifo.remove("3");         assertEquals("[1, 2, 4, 5]", fifo.toString());          fifo.remove("4");         assertEquals("[1, 2, 5]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError2() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");         fifo.add((E) "6");          assertEquals(5, fifo.size());         assertEquals("[2, 3, 4, 5, 6]", fifo.toString());          fifo.remove("3");         assertEquals("[2, 4, 5, 6]", fifo.toString());          fifo.remove("4");         assertEquals("[2, 5, 6]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError3() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");          assertEquals("[1, 2, 3, 4, 5]", fifo.toString());          fifo.remove("3");         assertEquals("[1, 2, 4, 5]", fifo.toString());          fifo.add((E) "6");         fifo.add((E) "7");         assertEquals("[2, 4, 5, 6, 7]", fifo.toString());          fifo.remove("4");         assertEquals("[2, 5, 6, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError4() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("4");  // remove element in middle of array, after start         assertEquals("[3, 5, 6, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError5() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("5");  // remove element at last pos in array         assertEquals("[3, 4, 6, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError6() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("6");  // remove element at position zero in array         assertEquals("[3, 4, 5, 7]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError7() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2          assertEquals("[3, 4, 5, 6, 7]", fifo.toString());          fifo.remove("7");  // remove element at position one in array         assertEquals("[3, 4, 5, 6]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError8() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2         fifo.add((E) "8");  // end=3          assertEquals("[4, 5, 6, 7, 8]", fifo.toString());          fifo.remove("7");  // remove element at position one in array, need to shift 8         assertEquals("[4, 5, 6, 8]", fifo.toString());     }      @SuppressWarnings("unchecked")     public void testRemoveError9() throws Exception {         // based on bug 33071         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");  // end=0         fifo.add((E) "6");  // end=1         fifo.add((E) "7");  // end=2         fifo.add((E) "8");  // end=3          assertEquals("[4, 5, 6, 7, 8]", fifo.toString());          fifo.remove("8");  // remove element at position two in array         assertEquals("[4, 5, 6, 7]", fifo.toString());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testRepeatedSerialization() throws Exception {         // bug 31433         final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);         b.add((E) "a");         assertEquals(1, b.size());         assertEquals(true, b.contains("a"));          ByteArrayOutputStream bos = new ByteArrayOutputStream();         new ObjectOutputStream(bos).writeObject(b);          final CircularFifoQueue<E> b2 = (CircularFifoQueue<E>) new ObjectInputStream(             new ByteArrayInputStream(bos.toByteArray())).readObject();          assertEquals(1, b2.size());         assertEquals(true, b2.contains("a"));         b2.add((E) "b");         assertEquals(2, b2.size());         assertEquals(true, b2.contains("a"));         assertEquals(true, b2.contains("b"));          bos = new ByteArrayOutputStream();         new ObjectOutputStream(bos).writeObject(b2);          final CircularFifoQueue<E> b3 = (CircularFifoQueue<E>) new ObjectInputStream(             new ByteArrayInputStream(bos.toByteArray())).readObject();          assertEquals(2, b3.size());         assertEquals(true, b3.contains("a"));         assertEquals(true, b3.contains("b"));         b3.add((E) "c");         assertEquals(2, b3.size());         assertEquals(true, b3.contains("b"));         assertEquals(true, b3.contains("c"));     }      public void testGetIndex() {         resetFull();          final CircularFifoQueue<E> queue = getCollection();         final List<E> confirmed = (List<E>) getConfirmed();         for (int i = 0; i < confirmed.size(); i++) {             assertEquals(confirmed.get(i), queue.get(i));         }          // remove the first two elements and check again         queue.remove();         queue.remove();          for (int i = 0; i < queue.size(); i++) {             assertEquals(confirmed.get(i + 2), queue.get(i));         }     }      public void testAddNull() {         final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);         try {             b.add(null);             fail();         } catch (final NullPointerException ex) {             return;         }         fail();     }      public void testDefaultSizeAndGetError1() {         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();         assertEquals(32, fifo.maxSize());         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");         assertEquals(5, fifo.size());         try {             fifo.get(5);         } catch (final NoSuchElementException ex) {             return;         }         fail();     }      public void testDefaultSizeAndGetError2() {         final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();         assertEquals(32, fifo.maxSize());         fifo.add((E) "1");         fifo.add((E) "2");         fifo.add((E) "3");         fifo.add((E) "4");         fifo.add((E) "5");         assertEquals(5, fifo.size());         try {             fifo.get(-2);         } catch (final NoSuchElementException ex) {             return;         }         fail();     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CircularFifoQueue.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/CircularFifoQueue.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public CircularFifoQueue<E> getCollection() {         return (CircularFifoQueue<E>) super.getCollection();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Extension of {@link AbstractCollectionTest} for exercising the  * {@link UnmodifiableQueue} implementation.  *  * @since 4.0  */ public class UnmodifiableQueueTest<E> extends AbstractQueueTest<E> {      public UnmodifiableQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public Queue<E> makeObject() {         return UnmodifiableQueue.unmodifiableQueue(new LinkedList<E>());     }      @Override     public Queue<E> makeFullCollection() {         final Queue<E> queue = new LinkedList<>(Arrays.asList(getFullElements()));         return UnmodifiableQueue.unmodifiableQueue(queue);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new LinkedList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         return new LinkedList<>(Arrays.asList(getFullElements()));     }      @Override     public Queue<E> getCollection() {         return super.getCollection();     }      @Override     public boolean isAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public boolean isNullSupported() {         return false;     }      //-----------------------------------------------------------------------     @Override     public void testQueueRemove() {         resetEmpty();         try {             getCollection().remove();             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullCollection() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Queue<E> queue = makeFullCollection();         assertSame(queue, UnmodifiableQueue.unmodifiableQueue(queue));          try {             UnmodifiableQueue.unmodifiableQueue(null);             fail();         } catch (final NullPointerException ex) {}     }      public void testOffer() {         final Queue<E> queue = makeFullCollection();         final E e = null;         try {             queue.offer(e);             fail();         } catch (final UnsupportedOperationException ex) {}     }      public void testPoll() {         final Queue<E> queue = makeFullCollection();         try {             queue.poll();             fail();         } catch (final UnsupportedOperationException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableQueue.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/UnmodifiableQueue.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedList; import java.util.List; import java.util.Queue;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.collection.PredicatedCollectionTest; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link PredicatedCollectionTest} for exercising the  * {@link PredicatedQueue} implementation.  *  * @since 4.0  */ public class PredicatedQueueTest<E> extends AbstractQueueTest<E> {      public PredicatedQueueTest(final String testName) {         super(testName);     }      //---------------------------------------------------------------      protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();      protected Queue<E> decorateCollection(final Queue<E> queue, final Predicate<E> predicate) {         return PredicatedQueue.predicatedQueue(queue, predicate);     }      @Override     public Queue<E> makeObject() {         return decorateCollection(new LinkedList<E>(), truePredicate);     }      @Override     public Queue<E> makeFullCollection() {         final Queue<E> queue = new LinkedList<>(Arrays.asList(getFullElements()));         return decorateCollection(queue, truePredicate);     }      @Override     public Collection<E> makeConfirmedCollection() {         return new LinkedList<>();     }      @Override     public Collection<E> makeConfirmedFullCollection() {         final List<E> list = new LinkedList<>(Arrays.asList(getFullElements()));         return list;     }      //------------------------------------------------------------      protected Predicate<E> testPredicate = o -> o instanceof String;      public Queue<E> makeTestQueue() {         return decorateCollection(new LinkedList<E>(), testPredicate);     }      @SuppressWarnings("unchecked")     public void testGet() {         final Queue<E> queue = makeTestQueue();          assertNull(queue.peek());          queue.add((E) "one");         queue.add((E) "two");         queue.add((E) "three");         assertEquals("Queue get", "one", queue.peek());     }      @SuppressWarnings("unchecked")     public void testRemove() {         final Queue<E> queue = makeTestQueue();         queue.add((E) "one");         assertEquals("Queue get", "one", queue.poll());         assertNull(queue.peek());     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedQueue.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) getCollection(), "src/test/resources/data/test/PredicatedQueue.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.queue;  import java.io.IOException; import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue;  import org.apache.commons.collections4.collection.AbstractCollectionTest;  /**  * Abstract test class for {@link java.util.Queue} methods and contracts.  * <p>  * To use, simply extend this class, and implement  * the {@link #makeObject} method.  * <p>  * If your {@link Queue} fails one of these tests by design,  * you may still use this base set of cases.  Simply override the  * test case (method) your {@link Queue} fails or override one of the  * protected methods from AbstractCollectionTest.  *  * @since 4.0  */ public abstract class AbstractQueueTest<E> extends AbstractCollectionTest<E> {      /**      * JUnit constructor.      *      * @param testName  the test class name      */     public AbstractQueueTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      *  Returns true if the collections produced by      *  {@link #makeObject()} and {@link #makeFullCollection()}      *  support the <code>set operation.<p>      *  Default implementation returns true.  Override if your collection      *  class does not support set.      */     public boolean isSetSupported() {         return true;     }      //-----------------------------------------------------------------------     /**      *  Verifies that the test queue implementation matches the confirmed queue      *  implementation.      */     @Override     public void verify() {         super.verify();         final Iterator<E> iterator1 = getCollection().iterator();         for (final E e : getConfirmed()) {             assertTrue(iterator1.hasNext());             final Object o1 = iterator1.next();             final Object o2 = e;             assertEquals(o1, o2);         }     }      //-----------------------------------------------------------------------     /**      * Returns an empty {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedCollection() {         return new ArrayList<>();     }      /**      * Returns a full {@link ArrayList}.      */     @Override     public Collection<E> makeConfirmedFullCollection() {         return new ArrayList<>(Arrays.asList(getFullElements()));     }      /**      * Returns {@link #makeObject()}.      *      * @return an empty queue to be used for testing      */     @Override     public abstract Queue<E> makeObject();      /**      * {@inheritDoc}      */     @Override     public Queue<E> makeFullCollection() {         // only works if queue supports optional "addAll(Collection)"         final Queue<E> queue = makeObject();         queue.addAll(Arrays.asList(getFullElements()));         return queue;     }      //-----------------------------------------------------------------------     /**      * Returns the {@link #collection} field cast to a {@link Queue}.      *      * @return the collection field as a Queue      */     @Override     public Queue<E> getCollection() {         return (Queue<E>) super.getCollection();     }      //-----------------------------------------------------------------------     /**      *  Tests {@link Queue#offer(Object)}.      */     public void testQueueOffer() {         if (!isAddSupported()) {             return;         }          final E[] elements = getFullElements();         for (final E element : elements) {             resetEmpty();             final boolean r = getCollection().offer(element);             getConfirmed().add(element);             verify();             assertTrue("Empty queue changed after add", r);             assertEquals("Queue size is 1 after first add", 1, getCollection().size());         }          resetEmpty();         int size = 0;         for (final E element : elements) {             final boolean r = getCollection().offer(element);             getConfirmed().add(element);             verify();             if (r) {                 size++;             }             assertEquals("Queue size should grow after add", size, getCollection().size());             assertTrue("Queue should contain added element", getCollection().contains(element));         }     }      /**      *  Tests {@link Queue#element()}.      */     public void testQueueElement() {         resetEmpty();          try {             getCollection().element();             fail("Queue.element should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }          resetFull();          assertTrue(getConfirmed().contains(getCollection().element()));          if (!isRemoveSupported()) {             return;         }          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             final E element = getCollection().element();              if (!isNullSupported()) {                 assertNotNull(element);             }              assertTrue(getConfirmed().contains(element));              getCollection().remove(element);             getConfirmed().remove(element);              verify();         }          try {             getCollection().element();             fail("Queue.element should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      *  Tests {@link Queue#peek()}.      */     public void testQueuePeek() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();          E element = getCollection().peek();         assertNull(element);          resetFull();          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             element = getCollection().peek();              if (!isNullSupported()) {                 assertNotNull(element);             }              assertTrue(getConfirmed().contains(element));              getCollection().remove(element);             getConfirmed().remove(element);              verify();         }          element = getCollection().peek();         assertNull(element);     }      /**      *  Tests {@link Queue#remove()}.      */     public void testQueueRemove() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();          try {             getCollection().remove();             fail("Queue.remove should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }          resetFull();          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             final E element = getCollection().remove();             final boolean success = getConfirmed().remove(element);             assertTrue("remove should return correct element", success);             verify();         }          try {             getCollection().element();             fail("Queue.remove should throw NoSuchElementException");         } catch (final NoSuchElementException e) {             // expected         }     }      /**      *  Tests {@link Queue#poll()}.      */     public void testQueuePoll() {         if (!isRemoveSupported()) {             return;         }          resetEmpty();          E element = getCollection().poll();         assertNull(element);          resetFull();          final int max = getFullElements().length;         for (int i = 0; i < max; i++) {             element = getCollection().poll();             final boolean success = getConfirmed().remove(element);             assertTrue("poll should return correct element", success);             verify();         }          element = getCollection().poll();         assertNull(element);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEmptyQueueSerialization() throws IOException, ClassNotFoundException {         final Queue<E> queue = makeObject();         if (!(queue instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) queue);         final Queue<E> queue2 = (Queue<E>) readExternalFormFromBytes(object);          assertEquals("Both queues are empty", 0, queue.size());         assertEquals("Both queues are empty", 0, queue2.size());     }      @SuppressWarnings("unchecked")     public void testFullQueueSerialization() throws IOException, ClassNotFoundException {         final Queue<E> queue = makeFullCollection();         final int size = getFullElements().length;         if (!(queue instanceof Serializable && isTestSerialization())) {             return;         }          final byte[] object = writeExternalFormToBytes((Serializable) queue);         final Queue<E> queue2 = (Queue<E>) readExternalFormFromBytes(object);          assertEquals("Both queues are same size", size, queue.size());         assertEquals("Both queues are same size", size, queue2.size());     }      /**      * Compare the current serialized form of the Queue      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testEmptyQueueCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         Queue queue = makeEmptyQueue();         if (!(queue instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) queue, getCanonicalEmptyCollectionName(queue));         */          // test to make sure the canonical form has been preserved         final Queue<E> queue = makeObject();         if (queue instanceof Serializable && !skipSerializedCanonicalTests()                 && isTestSerialization()) {             final Queue<E> queue2 = (Queue<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(queue));             assertEquals("Queue is empty", 0, queue2.size());         }     }      /**      * Compare the current serialized form of the Queue      * against the canonical version in SCM.      */     @SuppressWarnings("unchecked")     public void testFullQueueCompatibility() throws IOException, ClassNotFoundException {         /*          * Create canonical objects with this code         Queue queue = makeFullQueue();         if (!(queue instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) queue, getCanonicalFullCollectionName(queue));         */          // test to make sure the canonical form has been preserved         final Queue<E> queue = makeFullCollection();         if (queue instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             final Queue<E> queue2 = (Queue<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(queue));             assertEquals("Queues are not the right size", queue.size(), queue2.size());         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.multimap.ArrayListValuedHashMap; import org.junit.Test;  /**  * Tests for MultiMapUtils  *  * @since 4.1  */ public class MultiMapUtilsTest {      @Test     @SuppressWarnings({ "unchecked", "rawtypes" })     public void testEmptyUnmodifiableMultiValuedMap() {         final MultiValuedMap map = MultiMapUtils.EMPTY_MULTI_VALUED_MAP;         assertTrue(map.isEmpty());         try {             map.put("key", "value");             fail("Should throw UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testTypeSafeEmptyMultiValuedMap() {         final MultiValuedMap<String, String> map = MultiMapUtils.<String, String>emptyMultiValuedMap();         assertTrue(map.isEmpty());         try {             map.put("key", "value");             fail("Should throw UnsupportedOperationException");         } catch (final UnsupportedOperationException e) {         }     }      @Test     public void testEmptyIfNull() {         assertTrue(MultiMapUtils.emptyIfNull(null).isEmpty());          final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         map.put("item", "value");         assertFalse(MultiMapUtils.emptyIfNull(map).isEmpty());     }      @Test     public void testIsEmptyWithEmptyMap() {         assertTrue(MultiMapUtils.isEmpty(new ArrayListValuedHashMap<>()));     }      @Test     public void testIsEmptyWithNonEmptyMap() {         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         map.put("item", "value");         assertFalse(MultiMapUtils.isEmpty(map));     }      @Test     public void testIsEmptyWithNull() {         assertTrue(MultiMapUtils.isEmpty(null));     }      @Test     public void testGetCollection() {         assertNull(MultiMapUtils.getCollection(null, "key1"));          final String[] values = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);         }          final Collection<String> col = MultiMapUtils.getCollection(map, "key1");         assertEquals(Arrays.asList(values), col);     }      @Test     public void testGetValuesAsList() {         assertNull(MultiMapUtils.getValuesAsList(null, "key1"));          final String[] values = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);         }          final List<String> list = MultiMapUtils.getValuesAsList(map, "key1");         assertEquals(Arrays.asList(values), list);     }      @Test     public void testGetValuesAsSet() {         assertNull(MultiMapUtils.getValuesAsList(null, "key1"));          final String[] values = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);             map.put("key1", val);         }          final Set<String> set = MultiMapUtils.getValuesAsSet(map, "key1");         assertEquals(new HashSet<>(Arrays.asList(values)), set);     }      @Test     public void testGetValuesAsBag() {         assertNull(MultiMapUtils.getValuesAsBag(null, "key1"));          final String values[] = { "v1", "v2", "v3" };         final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();         for (final String val : values) {             map.put("key1", val);             map.put("key1", val);         }          final Bag<String> bag = MultiMapUtils.getValuesAsBag(map, "key1");         assertEquals(6, bag.size());         for (final String val : values) {             assertTrue(bag.contains(val));             assertEquals(2, bag.getCount(val));         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.fail; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.io.ByteArrayOutputStream; import java.io.PrintStream; import java.text.DecimalFormat; import java.text.NumberFormat; import java.util.AbstractMap; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.ListResourceBundle; import java.util.Map; import java.util.Properties; import java.util.ResourceBundle; import java.util.Set; import java.util.SortedMap; import java.util.TreeMap; import org.apache.commons.collections4.collection.TransformedCollectionTest; import org.apache.commons.collections4.keyvalue.DefaultKeyValue; import org.apache.commons.collections4.keyvalue.DefaultMapEntry; import org.apache.commons.collections4.map.HashedMap; import org.apache.commons.collections4.map.LazyMap; import org.apache.commons.collections4.map.MultiValueMap; import org.apache.commons.collections4.map.PredicatedMap; import org.junit.jupiter.api.Test;  /**  * Tests for MapUtils.  */ @SuppressWarnings("boxing") public class MapUtilsTest {     private static final String THREE = "Three";     private static final String TWO = "Two";      public Predicate<Object> getPredicate() {         return o -> o instanceof String;     }      @Test     public void testPredicatedMap() {         final Predicate<Object> p = getPredicate();         final Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<>(), p, p);         assertTrue(map instanceof PredicatedMap);         try {             MapUtils.predicatedMap(null, p, p);             fail("Expecting NullPointerException for null map.");         } catch (final NullPointerException e) {             // expected         }     }      @Test     public void testLazyMapFactory() {         final Factory<Integer> factory = FactoryUtils.constantFactory(Integer.valueOf(5));         Map<Object, Object> map = MapUtils.lazyMap(new HashMap<>(), factory);         assertTrue(map instanceof LazyMap);         try {             MapUtils.lazyMap(new HashMap<>(), (Factory<Object>) null);             fail("Expecting NullPointerException for null factory");         } catch (final NullPointerException e) {             // expected         }         try {             MapUtils.lazyMap((Map<Object, Object>) null, factory);             fail("Expecting NullPointerException for null map");         } catch (final NullPointerException e) {             // expected         }         final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);         map = MapUtils.lazyMap(new HashMap<>(), transformer);         assertTrue(map instanceof LazyMap);         try {             MapUtils.lazyMap(new HashMap<>(), (Transformer<Object, Object>) null);             fail("Expecting NullPointerException for null transformer");         } catch (final NullPointerException e) {             // expected         }         try {             MapUtils.lazyMap((Map<Object, Object>) null, transformer);             fail("Expecting NullPointerException for null map");         } catch (final NullPointerException e) {             // expected         }     }      @Test     public void testLazyMapTransformer() {         final Map<Object, Object> map = MapUtils.lazyMap(new HashMap<>(), (Transformer<Object, Object>) mapKey -> {             if (mapKey instanceof String) {                 return Integer.valueOf((String) mapKey);             }             return null;         });          assertEquals(0, map.size());         final Integer i1 = (Integer) map.get("5");         assertEquals(Integer.valueOf(5), i1);         assertEquals(1, map.size());         final Integer i2 = (Integer) map.get(new String(new char[] {'5'}));         assertEquals(Integer.valueOf(5), i2);         assertEquals(1, map.size());         assertSame(i1, i2);     }      @Test     public void testInvertMap() {         final Map<String, String> in = new HashMap<>(5, 1);         in.put("1", "A");         in.put("2", "B");         in.put("3", "C");         in.put("4", "D");         in.put("5", "E");          final Set<String> inKeySet = new HashSet<>(in.keySet());         final Set<String> inValSet = new HashSet<>(in.values());          final Map<String, String> out = MapUtils.invertMap(in);          final Set<String> outKeySet = new HashSet<>(out.keySet());         final Set<String> outValSet = new HashSet<>(out.values());          assertEquals(inKeySet, outValSet);         assertEquals(inValSet, outKeySet);          assertEquals("1", out.get("A"));         assertEquals("2", out.get("B"));         assertEquals("3", out.get("C"));         assertEquals("4", out.get("D"));         assertEquals("5", out.get("E"));     }      @Test     public void testInvertEmptyMap() {         final Map<String, String> emptyMap = new HashMap<>();         final Map<String, String> resultMap = MapUtils.invertMap(emptyMap);         assertEquals(emptyMap, resultMap);     }      @Test     public void testInvertMapNull() {         final Map<String, String> nullMap = null;         final Exception exception = assertThrows(NullPointerException.class, () -> {             MapUtils.invertMap(nullMap);         });         final String actualMessage = exception.getMessage();         assertTrue(actualMessage.contains("map"));     }      @Test     public void testPutAll_Map_array() {         try {             MapUtils.putAll(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             MapUtils.putAll(null, new Object[0]);             fail();         } catch (final NullPointerException ex) {}          Map<String, String> test = MapUtils.putAll(new HashMap<String, String>(), new String[0]);         assertEquals(0, test.size());          // sub array         test = MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 {"GREEN", "#00FF00"},                 {"BLUE", "#0000FF"}         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          try {             MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 null,                 {"BLUE", "#0000FF"}             });             fail();         } catch (final IllegalArgumentException ex) {}          try {             MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 {"GREEN"},                 {"BLUE", "#0000FF"}             });             fail();         } catch (final IllegalArgumentException ex) {}          try {             MapUtils.putAll(new HashMap<String, String>(), new String[][] {                 {"RED", "#FF0000"},                 {},                 {"BLUE", "#0000FF"}             });             fail();         } catch (final IllegalArgumentException ex) {}          // flat array         test = MapUtils.putAll(new HashMap<String, String>(), new String[] {             "RED", "#FF0000",             "GREEN", "#00FF00",             "BLUE", "#0000FF"         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          test = MapUtils.putAll(new HashMap<String, String>(), new String[] {             "RED", "#FF0000",             "GREEN", "#00FF00",             "BLUE", "#0000FF",             "PURPLE" // ignored         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          test = MapUtils.putAll(new HashMap<String, String>(), null);         assertEquals(0, test.size());          // map entry         test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {             new DefaultMapEntry<>("RED", "#FF0000"),             new DefaultMapEntry<>("GREEN", "#00FF00"),             new DefaultMapEntry<>("BLUE", "#0000FF")         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());          // key value         test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {             new DefaultKeyValue<>("RED", "#FF0000"),             new DefaultKeyValue<>("GREEN", "#00FF00"),             new DefaultKeyValue<>("BLUE", "#0000FF")         });         assertTrue(test.containsKey("RED"));         assertEquals("#FF0000", test.get("RED"));         assertTrue(test.containsKey("GREEN"));         assertEquals("#00FF00", test.get("GREEN"));         assertTrue(test.containsKey("BLUE"));         assertEquals("#0000FF", test.get("BLUE"));         assertEquals(3, test.size());     }      @Test     public void testConvertResourceBundle() {         final Map<String, String> in = new HashMap<>(5, 1);         in.put("1", "A");         in.put("2", "B");         in.put("3", "C");         in.put("4", "D");         in.put("5", "E");          final ResourceBundle b = new ListResourceBundle() {             @Override             public Object[][] getContents() {                 final Object[][] contents = new Object[in.size()][2];                 final Iterator<String> i = in.keySet().iterator();                 int n = 0;                 while (i.hasNext()) {                     final Object key = i.next();                     final Object val = in.get(key);                     contents[n][0] = key;                     contents[n][1] = val;                     ++n;                 }                 return contents;             }         };          final Map<String, Object> out = MapUtils.toMap(b);          assertEquals(in, out);     }      @Test     public void testDebugAndVerbosePrintCasting() {         final Map<Integer, String> inner = new HashMap<>(2, 1);         inner.put(2, "B");         inner.put(3, "C");          final Map<Integer, Object> outer = new HashMap<>(2, 1);         outer.put(0, inner);         outer.put(1, "A");          final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          try {             MapUtils.debugPrint(outPrint, "Print Map", outer);         } catch (final ClassCastException e) {             fail("No Casting should be occurring!");         }     }      @Test     public void testDebugAndVerbosePrintNullMap() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         outPrint.println(LABEL + " = " + String.valueOf((Object) null));         final String EXPECTED_OUT = out.toString();          out.reset();          MapUtils.debugPrint(outPrint, LABEL, null);         assertEquals(EXPECTED_OUT, out.toString());          out.reset();          MapUtils.verbosePrint(outPrint, LABEL, null);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullLabel() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Integer, String> map = new TreeMap<>(); // treeMap guarantees order across JDKs for test         map.put(2, "B");         map.put(3, "C");         map.put(4, null);          outPrint.println("{");         outPrint.println(INDENT + "2 = B");         outPrint.println(INDENT + "3 = C");         outPrint.println(INDENT + "4 = null");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullLabel() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Integer, String> map = new TreeMap<>(); // treeMap guarantees order across JDKs for test         map.put(2, "B");         map.put(3, "C");         map.put(4, null);          outPrint.println("{");         outPrint.println(INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + "3 = C " + String.class.getName());         outPrint.println(INDENT + "4 = null");         outPrint.println("} " + TreeMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullLabelAndMap() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          outPrint.println("null");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, null);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullLabelAndMap() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          outPrint.println("null");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, null);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullStream() {         try {             MapUtils.verbosePrint(null, "Map", new HashMap<>());             fail("Should generate NullPointerException");         } catch (final NullPointerException expected) {         }     }      @Test     public void testDebugPrintNullStream() {         try {             MapUtils.debugPrint(null, "Map", new HashMap<>());             fail("Should generate NullPointerException");         } catch (final NullPointerException expected) {         }     }      @Test     public void testDebugPrintNullKey() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, String> map = new HashMap<>();         map.put(null, "A");          outPrint.println("{");         outPrint.println(INDENT + "null = A " + String.class.getName());         outPrint.println("} " + HashMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullKey() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, String> map = new HashMap<>();         map.put(null, "A");          outPrint.println("{");         outPrint.println(INDENT + "null = A");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullKeyToMap1() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Map<?, ?>> map = new HashMap<>();         map.put(null, map);          outPrint.println("{");         outPrint.println(INDENT + "null = (this Map) " + HashMap.class.getName());         outPrint.println("} " + HashMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullKeyToMap1() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Map<?, ?>> map = new HashMap<>();         map.put(null, map);          outPrint.println("{");         outPrint.println(INDENT + "null = (this Map)");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintNullKeyToMap2() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Object> map = new HashMap<>();         final Map<Object, Object> map2= new HashMap<>();         map.put(null, map2);         map2.put("2", "B");          outPrint.println("{");         outPrint.println(INDENT + "null = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + "} " + HashMap.class.getName());         outPrint.println("} " + HashMap.class.getName());         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.debugPrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintNullKeyToMap2() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String INDENT = "    ";          final Map<Object, Object> map = new HashMap<>();         final Map<Object, Object> map2 = new HashMap<>();         map.put(null, map2);         map2.put("2", "B");          outPrint.println("{");         outPrint.println(INDENT + "null = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B");         outPrint.println(INDENT + "}");         outPrint.println("}");         final String EXPECTED_OUT = out.toString();         out.reset();          MapUtils.verbosePrint(outPrint, null, map);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrint() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A");         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B");         outPrint.println(INDENT + INDENT + "3 = C");         outPrint.println(INDENT + "}");         outPrint.println(INDENT + "7 = (this Map)");         outPrint.println("}");          final String EXPECTED_OUT = out.toString();          out.reset();          final Map<Integer, String> inner = new TreeMap<>(); // treeMap guarantees order across JDKs for test         inner.put(2, "B");         inner.put(3, "C");          final Map<Integer, Object> outer = new TreeMap<>();         outer.put(1, inner);         outer.put(0, "A");         outer.put(7, outer);          MapUtils.verbosePrint(outPrint, "Print Map", outer);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrint() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A " + String.class.getName());         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + INDENT + "3 = C " + String.class.getName());         outPrint.println(INDENT + "} " + TreeMap.class.getName());         outPrint.println(INDENT + "7 = (this Map) " + TreeMap.class.getName());         outPrint.println("} " + TreeMap.class.getName());          final String EXPECTED_OUT = out.toString();          out.reset();          final Map<Integer, String> inner = new TreeMap<>(); // treeMap guarantees order across JDKs for test         inner.put(2, "B");         inner.put(3, "C");          final Map<Integer, Object> outer = new TreeMap<>();         outer.put(1, inner);         outer.put(0, "A");         outer.put(7, outer);          MapUtils.debugPrint(outPrint, "Print Map", outer);         assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testVerbosePrintSelfReference() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          final Map<Integer, Object> grandfather = new TreeMap<>(); // treeMap guarantees order across JDKs for test         final Map<Integer, Object> father = new TreeMap<>();         final Map<Integer, Object> son    = new TreeMap<>();          grandfather.put(0, "A");         grandfather.put(1, father);          father.put(2, "B");         father.put(3, grandfather);         father.put(4, son);          son.put(5, "C");         son.put(6, grandfather);         son.put(7, father);          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A");         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B");         outPrint.println(INDENT + INDENT + "3 = (ancestor[0] Map)");         outPrint.println(INDENT + INDENT + "4 = ");         outPrint.println(INDENT + INDENT + "{");         outPrint.println(INDENT + INDENT + INDENT + "5 = C");         outPrint.println(INDENT + INDENT + INDENT + "6 = (ancestor[1] Map)");         outPrint.println(INDENT + INDENT + INDENT + "7 = (ancestor[0] Map)");         outPrint.println(INDENT + INDENT + "}");         outPrint.println(INDENT + "}");         outPrint.println("}");          final String EXPECTED_OUT = out.toString();          out.reset();         MapUtils.verbosePrint(outPrint, "Print Map", grandfather);          assertEquals(EXPECTED_OUT, out.toString());     }      @Test     public void testDebugPrintSelfReference() {         final ByteArrayOutputStream out = new ByteArrayOutputStream();         final PrintStream outPrint = new PrintStream(out);          final String LABEL = "Print Map";         final String INDENT = "    ";          final Map<Integer, Object> grandfather = new TreeMap<>(); // treeMap guarantees order across JDKs for test         final Map<Integer, Object> father = new TreeMap<>();         final Map<Integer, Object> son    = new TreeMap<>();          grandfather.put(0, "A");         grandfather.put(1, father);          father.put(2, "B");         father.put(3, grandfather);         father.put(4, son);          son.put(5, "C");         son.put(6, grandfather);         son.put(7, father);          outPrint.println(LABEL + " = ");         outPrint.println("{");         outPrint.println(INDENT + "0 = A " + String.class.getName());         outPrint.println(INDENT + "1 = ");         outPrint.println(INDENT + "{");         outPrint.println(INDENT + INDENT + "2 = B " + String.class.getName());         outPrint.println(INDENT + INDENT + "3 = (ancestor[0] Map) " + TreeMap.class.getName());         outPrint.println(INDENT + INDENT + "4 = ");         outPrint.println(INDENT + INDENT + "{");         outPrint.println(INDENT + INDENT + INDENT + "5 = C " + String.class.getName());         outPrint.println(INDENT + INDENT + INDENT + "6 = (ancestor[1] Map) " + TreeMap.class.getName());         outPrint.println(INDENT + INDENT + INDENT + "7 = (ancestor[0] Map) " + TreeMap.class.getName());         outPrint.println(INDENT + INDENT + "} " + TreeMap.class.getName());         outPrint.println(INDENT + "} " + TreeMap.class.getName());         outPrint.println("} " + TreeMap.class.getName());          final String EXPECTED_OUT = out.toString();          out.reset();         MapUtils.debugPrint(outPrint, "Print Map", grandfather);          assertEquals(EXPECTED_OUT, out.toString());     }      //-----------------------------------------------------------------------      @Test     public void testEmptyIfNull() {         assertTrue(MapUtils.emptyIfNull(null).isEmpty());          final Map<Long, Long> map = new HashMap<>();         assertSame(map, MapUtils.emptyIfNull(map));     }      @Test     public void testIsEmptyWithEmptyMap() {         final Map<Object, Object> map = new HashMap<>();         assertTrue(MapUtils.isEmpty(map));     }      @Test     public void testIsEmptyWithNonEmptyMap() {         final Map<String, String> map = new HashMap<>();         map.put("item", "value");         assertFalse(MapUtils.isEmpty(map));     }      @Test     public void testIsEmptyWithNull() {         final Map<Object, Object> map = null;         assertTrue(MapUtils.isEmpty(map));     }      @Test     public void testIsNotEmptyWithEmptyMap() {         final Map<Object, Object> map = new HashMap<>();         assertFalse(MapUtils.isNotEmpty(map));     }      @Test     public void testIsNotEmptyWithNonEmptyMap() {         final Map<String, String> map = new HashMap<>();         map.put("item", "value");         assertTrue(MapUtils.isNotEmpty(map));     }      @Test     public void testIsNotEmptyWithNull() {         final Map<Object, Object> map = null;         assertFalse(MapUtils.isNotEmpty(map));     }      @Test     public void testPopulateMap() {         // Setup Test Data         final List<String> list = new ArrayList<>();         list.add("1");         list.add("3");         list.add("5");         list.add("7");         list.add("2");         list.add("4");         list.add("6");          // Now test key transform population         Map<Object, Object> map = new HashMap<>();         MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(list.size(), map.size());          for (final String element : list) {             assertTrue(map.containsKey(Integer.valueOf(element)));             assertFalse(map.containsKey(element));             assertTrue(map.containsValue(element));             assertEquals(element, map.get(Integer.valueOf(element)));         }          // Now test both Key-Value transform population         map = new HashMap<>();         MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);          assertEquals(list.size(), map.size());         for (final String element : list) {             assertTrue(map.containsKey(Integer.valueOf(element)));             assertFalse(map.containsKey(element));             assertTrue(map.containsValue(Integer.valueOf(element)));             assertEquals(Integer.valueOf(element), map.get(Integer.valueOf(element)));         }     }      /**      * Test class for populateMap(MultiMap).      */     static class X implements Comparable<X> {         int key;         String name;          X(final int key, final String name) {             this.key = key;             this.name = name;         }          @Override         public int compareTo(final X o) {             return key - o.key | name.compareTo(o.name);         }     }      @Test     public void testPopulateMultiMap() {         // Setup Test Data         final List<X> list = new ArrayList<>();         list.add(new X(1, "x1"));         list.add(new X(2, "x2"));         list.add(new X(2, "x3"));         list.add(new X(5, "x4"));         list.add(new X(5, "x5"));          // Now test key transform population         final MultiValueMap<Integer, X> map = MultiValueMap.multiValueMap(new TreeMap<Integer, Collection<X>>());         MapUtils.populateMap(map, list, (Transformer<X, Integer>) input -> input.key, TransformerUtils.<X>nopTransformer());         assertEquals(list.size(), map.totalSize());          for (final X element : list) {             assertTrue(map.containsKey(element.key));             assertTrue(map.containsValue(element));         }     }      @Test     public void testIterableMap() {         try {             MapUtils.iterableMap(null);             fail("Should throw NullPointerException");         } catch (final NullPointerException e) {         }         final HashMap<String, String> map = new HashMap<>();         map.put("foo", "foov");         map.put("bar", "barv");         map.put("baz", "bazv");         final IterableMap<String, String> iMap = MapUtils.iterableMap(map);         assertEquals(map, iMap);         assertNotSame(map, iMap);         final HashedMap<String, String> hMap = new HashedMap<>(map);         assertSame(hMap, MapUtils.iterableMap(hMap));     }      @Test     public void testIterableSortedMap() {         try {             MapUtils.iterableSortedMap(null);             fail("Should throw NullPointerException");         } catch (final NullPointerException e) {         }         final TreeMap<String, String> map = new TreeMap<>();         map.put("foo", "foov");         map.put("bar", "barv");         map.put("baz", "bazv");         final IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);         assertEquals(map, iMap);         assertNotSame(map, iMap);         assertSame(iMap, MapUtils.iterableMap(iMap));     }      @Test     public void testLazyMap() {         final Map<String, Integer> lazyMap = MapUtils.lazyMap(new HashMap<>(), () -> 1);         lazyMap.put(TWO, 2);          assertEquals(Integer.valueOf(2), lazyMap.get(TWO));         assertEquals(Integer.valueOf(1), lazyMap.get(THREE));     }      @Test     public void testLazySortedMapFactory() {         final SortedMap<String, Integer> lazySortedMap = MapUtils.lazySortedMap(new TreeMap<>(), () -> 1);         lazySortedMap.put(TWO, 2);          assertEquals(Integer.valueOf(2), lazySortedMap.get(TWO));         assertEquals(Integer.valueOf(1), lazySortedMap.get(THREE));          final Set<Map.Entry<String, Integer>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(THREE, 1));         entrySet.add(new AbstractMap.SimpleEntry<>(TWO, 2));          assertEquals(entrySet, lazySortedMap.entrySet());     }      @Test     public void testLazySortedMapTransformer() {         final SortedMap<String, Integer> lazySortedMap = MapUtils.lazySortedMap(new TreeMap<>(), s -> 1);         lazySortedMap.put(TWO, 2);          assertEquals(Integer.valueOf(2), lazySortedMap.get(TWO));         assertEquals(Integer.valueOf(1), lazySortedMap.get(THREE));          final Set<Map.Entry<String, Integer>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(THREE, 1));         entrySet.add(new AbstractMap.SimpleEntry<>(TWO, 2));          assertEquals(entrySet, lazySortedMap.entrySet());     }      @Test     public void testSize0() {         assertEquals(0, MapUtils.size(new HashMap<>()));     }      @Test     public void testSizeNull() {         assertEquals(0, MapUtils.size(null));     }      @Test     public void testSize() {         final HashMap<Object, Object> map = new HashMap<>();         map.put("A", "1");         map.put("B", "2");         assertEquals(2, MapUtils.size(map));     }      @Test     public void testToProperties() {         final Map<String, String> in = new HashMap<>();         in.put("key1", "A");         in.put("key2", "B");         in.put("key3", "C");          final Properties out =  MapUtils.toProperties(in);          assertEquals(in.get("key1"), out.get("key1"));         assertEquals(in.get("key2"), out.get("key2"));         assertEquals(in.get("key3"), out.get("key3"));     }      @Test     public void testToPropertiesEmpty() {         final Map<String, String> in = null;         final Properties out =  MapUtils.toProperties(in);          assertEquals(out.size(), 0);     }      @Test     public void testTransformedMap() {         final Map<Long, Long> map = new HashMap<>();          final Map<Long, Long> transformedMap = MapUtils.transformedMap(map, i -> i + 1, i -> i + 10);         transformedMap.put(1L, 100L);          final Set<Map.Entry<Long, Long>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(2L, 110L));          assertEquals(entrySet, transformedMap.entrySet());     }      @Test     public void testTransformedSortedMap() {         final SortedMap<Long, Long> sortedMap = new TreeMap<>();          final SortedMap<Long, Long> transformedSortedMap = MapUtils.transformedSortedMap(sortedMap, i -> i + 1, i -> i + 10);         transformedSortedMap.put(2L, 200L);         transformedSortedMap.put(1L, 100L);          final Set<Map.Entry<Long, Long>> entrySet = new HashSet<>();         entrySet.add(new AbstractMap.SimpleEntry<>(2L, 110L));         entrySet.add(new AbstractMap.SimpleEntry<>(3L, 210L));          assertEquals(entrySet, transformedSortedMap.entrySet());     }      @Test     public void testUnmodifiableMap() {         final Exception exception = assertThrows(UnsupportedOperationException.class, () -> {             MapUtils.unmodifiableMap(new HashMap<>()).clear();         });     }      @Test     public void testUnmodifiableSortedMap() {         final Exception exception = assertThrows(UnsupportedOperationException.class, () -> {             MapUtils.unmodifiableSortedMap(new TreeMap<>()).clear();         });     }      @Test     public void testFixedSizeMap() {         final Exception exception = assertThrows(IllegalArgumentException.class, () -> {             MapUtils.fixedSizeMap(new HashMap<>()).put(new Object(), new Object());         });     }      @Test     public void testFixedSizeSortedMap() {         final Exception exception = assertThrows(IllegalArgumentException.class, () -> {             MapUtils.fixedSizeSortedMap(new TreeMap<Long, Long>()).put(1L, 1L);         });     }      @Test     public void testGetNumberValueWithInvalidString() {         final Map<String, String> map = new HashMap<>();         map.put("key", "one");          assertNull(MapUtils.getNumber(map, "key"));     }      @Test     public void testGetDoubleValue() {         final Map<String, Double> in = new HashMap<>();         in.put("key", 2.0);          assertEquals(2.0, MapUtils.getDoubleValue(in, "key", 0.0), 0);         assertEquals(2.0, MapUtils.getDoubleValue(in, "key"), 0);         assertEquals(1.0, MapUtils.getDoubleValue(in, "noKey", 1.0), 0);         assertEquals(5.0, MapUtils.getDoubleValue(in, "noKey", key -> 5.0D), 0);          assertEquals(0, MapUtils.getDoubleValue(in, "noKey"), 0);         assertEquals(2.0, MapUtils.getDouble(in, "key", 0.0), 0);         assertEquals(1.0, MapUtils.getDouble(in, "noKey", 1.0), 0);         assertEquals(1.0, MapUtils.getDouble(in, "noKey", key -> 1.0), 0);           final Map<String, String> inStr = new HashMap<>();         final char decimalSeparator = getDecimalSeparator();         inStr.put("str1", "2" + decimalSeparator + "0");          assertEquals(MapUtils.getDoubleValue(inStr, "str1", 0.0), 2.0, 0);     }      @Test     public void testGetFloatValue() {         final Map<String, Float> in = new HashMap<>();         in.put("key", 2.0f);          assertEquals(2.0, MapUtils.getFloatValue(in, "key", 0.0f), 0);         assertEquals(2.0, MapUtils.getFloatValue(in, "key"), 0);         assertEquals(1.0, MapUtils.getFloatValue(in, "noKey", 1.0f), 0);         assertEquals(1.0, MapUtils.getFloatValue(in, "noKey", key -> 1.0F), 0);         assertEquals(0, MapUtils.getFloatValue(in, "noKey"), 0);         assertEquals(2.0, MapUtils.getFloat(in, "key", 0.0f), 0);         assertEquals(1.0, MapUtils.getFloat(in, "noKey", 1.0f), 0);         assertEquals(1.0, MapUtils.getFloat(in, "noKey", key -> 1.0F), 0);          final Map<String, String> inStr = new HashMap<>();         final char decimalSeparator = getDecimalSeparator();         inStr.put("str1", "2" + decimalSeparator + "0");          assertEquals(MapUtils.getFloatValue(inStr, "str1", 0.0f), 2.0, 0);     }      @Test     public void testGetLongValue() {         final Map<String, Long> in = new HashMap<>();         in.put("key", 2L);          assertEquals(2.0, MapUtils.getLongValue(in, "key", 0L), 0);         assertEquals(2.0, MapUtils.getLongValue(in, "key"), 0);         assertEquals(1, MapUtils.getLongValue(in, "noKey", 1L), 0);         assertEquals(1, MapUtils.getLongValue(in, "noKey", key -> 1L), 0);         assertEquals(0, MapUtils.getLongValue(in, "noKey"), 0);         assertEquals(2.0, MapUtils.getLong(in, "key", 0L), 0);         assertEquals(1, MapUtils.getLong(in, "noKey", 1L), 0);         assertEquals(1, MapUtils.getLong(in, "noKey", key -> 1L), 0);          final Map<String, Number> in1 = new HashMap<>();         in1.put("key", 2);          assertEquals(Long.valueOf(2), MapUtils.getLong(in1, "key"));          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "2");          assertEquals(MapUtils.getLongValue(inStr, "str1", 0L), 2, 0);         assertEquals(MapUtils.getLong(inStr, "str1", 1L), 2, 0);      }      @Test     public void testGetIntValue() {         final Map<String, Integer> in = new HashMap<>();         in.put("key", 2);          assertEquals(2, MapUtils.getIntValue(in, "key", 0), 0);         assertEquals(2, MapUtils.getIntValue(in, "key"), 0);         assertEquals(0, MapUtils.getIntValue(in, "noKey", 0), 0);         assertEquals(0, MapUtils.getIntValue(in, "noKey", key -> 0), 0);         assertEquals(0, MapUtils.getIntValue(in, "noKey"), 0);         assertEquals(2, MapUtils.getInteger(in, "key", 0), 0);         assertEquals(0, MapUtils.getInteger(in, "noKey", 0), 0);         assertEquals(0, MapUtils.getInteger(in, "noKey", key -> 0), 0);          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "2");          assertEquals(MapUtils.getIntValue(inStr, "str1", 0), 2, 0);     }      @Test     public void testGetShortValue() {         final Map<String, Short> in = new HashMap<>();         final short val = 10;         in.put("key", val);          assertEquals(val, MapUtils.getShortValue(in, "key", val), 0);         assertEquals(val, MapUtils.getShortValue(in, "key"), 0);         assertEquals(val, MapUtils.getShortValue(in, "noKey", val), 0);         assertEquals(val, MapUtils.getShortValue(in, "noKey", key -> val), 0);         assertEquals(0, MapUtils.getShortValue(in, "noKey"), 0);         assertEquals(val, MapUtils.getShort(in, "key", val), 0);         assertEquals(val, MapUtils.getShort(in, "noKey", val), 0);         assertEquals(val, MapUtils.getShort(in, "noKey", key -> val), 0);          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "10");          assertEquals(MapUtils.getShortValue(inStr, "str1", val), val, 0);     }      @Test     public void testGetByteValue() {         final Map<String, Byte> in = new HashMap<>();         final byte val = 100;         in.put("key", val);          assertEquals(val, MapUtils.getByteValue(in, "key", val), 0);         assertEquals(val, MapUtils.getByteValue(in, "key"), 0);         assertEquals(val, MapUtils.getByteValue(in, "noKey", val), 0);         assertEquals(val, MapUtils.getByteValue(in, "noKey", key -> ((byte) 100)), 0);         assertEquals(0, MapUtils.getByteValue(in, "noKey"), 0);         assertEquals(val, MapUtils.getByte(in, "key", val), 0);         assertEquals(val, MapUtils.getByte(in, "noKey", val), 0);         assertEquals(val, MapUtils.getByte(in, "noKey", key -> val), 0);           final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "100");          assertEquals(MapUtils.getByteValue(inStr, "str1", val), val, 0);     }      @Test     public void testGetNumber() {         final Map<String, Number> in = new HashMap<>();         final Number val = 1000;         in.put("key", val);          assertEquals(val.intValue(), MapUtils.getNumber(in, "key", val).intValue(), 0);         assertEquals(val.intValue(), MapUtils.getNumber(in, "noKey", val).intValue(), 0);         assertEquals(val.intValue(), MapUtils.getNumber(in, "noKey", key -> {             if (true) {                 return val;             } else {                 return null;             }         }).intValue(), 0);      }      @Test     public void testGetString() {         final Map<String, String> in = new HashMap<>();         in.put("key", "str");          assertEquals("str", MapUtils.getString(in, "key", "default"));         assertEquals("str", MapUtils.getString(in, "key"));         assertNull(MapUtils.getString(null, "key"));         assertEquals("default", MapUtils.getString(in, "noKey", "default"));         assertEquals("default", MapUtils.getString(in, "noKey", key -> {             if ("noKey".equals(key)) {                 return "default";             } else {                 return "";             }         }));         assertEquals("default", MapUtils.getString(null, "noKey", "default"));     }      @Test     public void testGetObject() {         final Map<String, Object> in = new HashMap<>();         in.put("key", "str");          assertEquals("str", MapUtils.getObject(in, "key", "default"));         assertEquals("str", MapUtils.getObject(in, "key"));         assertNull(MapUtils.getObject(null, "key"));         assertEquals("default", MapUtils.getObject(in, "noKey", "default"));         assertEquals("default", MapUtils.getObject(null, "noKey", "default"));     }      @Test     public void testGetBooleanValue() {         final Map<String, Object> in = new HashMap<>();         in.put("key", true);         in.put("keyNumberTrue", 1);         in.put("keyNumberFalse", 0);         in.put("keyUnmapped", new Object());          assertFalse(MapUtils.getBooleanValue(null, "keyString", null));         assertFalse(MapUtils.getBooleanValue(in, null, null));         assertFalse(MapUtils.getBooleanValue(null, null, null));         assertTrue(MapUtils.getBooleanValue(in, "key", true));         assertTrue(MapUtils.getBooleanValue(in, "key"));         assertTrue(MapUtils.getBooleanValue(in, "noKey", true));         assertTrue(MapUtils.getBooleanValue(in, "noKey", key -> true));         assertFalse(MapUtils.getBooleanValue(in, "noKey"));         assertTrue(MapUtils.getBoolean(in, "key", true));         assertTrue(MapUtils.getBoolean(in, "noKey", true));         assertTrue(MapUtils.getBoolean(in, "noKey", key -> {             if (System.currentTimeMillis() > 0) {                 return true;             }             return false;         }));         assertNull(MapUtils.getBoolean(in, "noKey", key -> null));         assertFalse(MapUtils.getBooleanValue(in, "noKey", key -> null));         assertNull(MapUtils.getBoolean(null, "noKey"));         // Values are Numbers         assertFalse(MapUtils.getBoolean(in, "keyNumberFalse"));         assertTrue(MapUtils.getBoolean(in, "keyNumberTrue"));         assertNull(MapUtils.getBoolean(in, "keyString"));         assertNull(MapUtils.getBoolean(null, "keyString"));         assertNull(MapUtils.getBoolean(in, null));         assertNull(MapUtils.getBoolean(null, null));          final Map<String, String> inStr = new HashMap<>();         inStr.put("str1", "true");          assertTrue(MapUtils.getBooleanValue(inStr, "str1", true));         assertTrue(MapUtils.getBoolean(inStr, "str1", true));     }      @Test     public void testGetMap() {         final Map<String, Map<String, String>> in = new HashMap<>();         final Map<String, String> valMap = new HashMap<>();         valMap.put("key1", "value1");         in.put("key1", valMap);         final Map<?, ?> outValue =  MapUtils.getMap(in, "key1", (Map<?, ?>) null);          assertEquals("value1", outValue.get("key1"));         assertNull(outValue.get("key2"));         assertNull(MapUtils.getMap(in, "key2", (Map<?, ?>) null));         assertNull(MapUtils.getMap(null, "key2", (Map<?, ?>) null));     }      @Test     public void testSafeAddToMap() {          final Map<String, Object> inMap = new HashMap<>();          MapUtils.safeAddToMap(inMap, "key1", "value1");         MapUtils.safeAddToMap(inMap, "key2", null);         assertEquals("value1", inMap.get("key1"));         assertEquals("", inMap.get("key2"));     }      @Test     public void testOrderedMap() {         final Map<String, String> inMap = new HashMap<>();         inMap.put("key1", "value1");         inMap.put("key2", "value2");         final Map<String, String> map = MapUtils.orderedMap(inMap);         assertTrue(map instanceof OrderedMap);     }      private char getDecimalSeparator() {         final NumberFormat numberFormat = NumberFormat.getInstance();         if (numberFormat instanceof DecimalFormat) {             return ((DecimalFormat) numberFormat).getDecimalFormatSymbols().getDecimalSeparator();         }         return '.';     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.sequence;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Random;  import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class SequencesComparatorTest {      private List<String> before;     private List<String> after;     private int[]        length;      @Test     public void testLength() {         for (int i = 0; i < before.size(); ++i) {             final SequencesComparator<Character> comparator =                     new SequencesComparator<>(sequence(before.get(i)),                             sequence(after.get(i)));             Assert.assertEquals(length[i], comparator.getScript().getModifications());         }     }      @Test     public void testExecution() {         final ExecutionVisitor<Character> ev = new ExecutionVisitor<>();         for (int i = 0; i < before.size(); ++i) {             ev.setList(sequence(before.get(i)));             new SequencesComparator<>(sequence(before.get(i)),                     sequence(after.get(i))).getScript().visit(ev);             Assert.assertEquals(after.get(i), ev.getString());         }     }      @Test     public void testMinimal() {         final String[] shadokAlph = new String[] {             "GA",             "BU",             "ZO",             "MEU"         };         final List<String> sentenceBefore = new ArrayList<>();         final List<String> sentenceAfter  = new ArrayList<>();         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[2]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[1]);         sentenceBefore.add(shadokAlph[3]);         sentenceBefore.add(shadokAlph[0]);         sentenceBefore.add(shadokAlph[3]);          final Random random = new Random(4564634237452342L);          for (int nbCom = 0; nbCom <= 40; nbCom+=5) {             sentenceAfter.clear();             sentenceAfter.addAll(sentenceBefore);             for (int i = 0; i<nbCom; i++) {                 if (random.nextInt(2) == 0) {                     sentenceAfter.add(random.nextInt(sentenceAfter.size() + 1),                                       shadokAlph[random.nextInt(4)]);                 } else {                     sentenceAfter.remove(random.nextInt(sentenceAfter.size()));                 }             }              final SequencesComparator<String> comparator =                     new SequencesComparator<>(sentenceBefore, sentenceAfter);             Assert.assertTrue(comparator.getScript().getModifications() <= nbCom);         }     }      @Test     public void testShadok() {         final int lgMax = 5;         final String[] shadokAlph = new String[] {             "GA",             "BU",             "ZO",             "MEU"         };         List<List<String>> shadokSentences = new ArrayList<>();         for (int lg=0; lg<lgMax; ++lg) {             final List<List<String>> newTab = new ArrayList<>();             newTab.add(new ArrayList<String>());             for (final String element : shadokAlph) {                 for (final List<String> sentence : shadokSentences) {                     final List<String> newSentence = new ArrayList<>(sentence);                     newSentence.add(element);                     newTab.add(newSentence);                 }             }             shadokSentences = newTab;         }          final ExecutionVisitor<String> ev = new ExecutionVisitor<>();          for (final List<String> element : shadokSentences) {             for (final List<String> shadokSentence : shadokSentences) {                 ev.setList(element);                 new SequencesComparator<>(element,                         shadokSentence).getScript().visit(ev);                  final StringBuilder concat = new StringBuilder();                 for (final String s : shadokSentence) {                     concat.append(s);                 }                 Assert.assertEquals(concat.toString(), ev.getString());             }         }     }      private List<Character> sequence(final String string) {         final List<Character> list = new ArrayList<>();         for (int i = 0; i < string.length(); ++i) {             list.add(new Character(string.charAt(i)));         }         return list;     }      private class ExecutionVisitor<T> implements CommandVisitor<T> {          private List<T> v;         private int index;          public void setList(final List<T> array) {             v = new ArrayList<>(array);             index = 0;         }          @Override         public void visitInsertCommand(final T object) {             v.add(index++, object);         }          @Override         public void visitKeepCommand(final T object) {             ++index;         }          @Override         public void visitDeleteCommand(final T object) {             v.remove(index);         }          public String getString() {             final StringBuilder buffer = new StringBuilder();             for (final T c : v) {                 buffer.append(c);             }             return buffer.toString();         }      }      @Before     public void setUp() {          before = Arrays.asList(             "bottle",             "nematode knowledge",             "",             "aa",             "prefixed string",             "ABCABBA",             "glop glop",             "coq",             "spider-man");          after = Arrays.asList(             "noodle",             "empty bottle",             "",             "C",             "prefix",             "CBABAC",             "pas glop pas glop",             "ane",             "klingon");          length = new int[] {             6,             16,             0,             3,             9,             5,             8,             6,             13         };      }      @After     public void tearDown() {         before = null;         after  = null;         length = null;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.ArrayList;  import org.apache.commons.collections4.list.AbstractListTest;  /**  * Abstract test class for ArrayList.  *  */ public abstract class AbstractArrayListTest<E> extends AbstractListTest<E> {      public AbstractArrayListTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public abstract ArrayList<E> makeObject();      //-----------------------------------------------------------------------     public void testNewArrayList() {         final ArrayList<E> list = makeObject();         assertTrue("New list is empty", list.isEmpty());         assertEquals("New list has size zero", 0, list.size());          try {             list.get(1);             fail("get(int i) should have thrown IndexOutOfBoundsException");         } catch (final IndexOutOfBoundsException e) {             // Expected result         }     }      @SuppressWarnings("unchecked")     public void testSearch() {         final ArrayList<E> list = makeObject();         list.add((E) "First Item");         list.add((E) "Last Item");         assertEquals("First item is 'First Item'", "First Item", list.get(0));         assertEquals("Last Item is 'Last Item'", "Last Item", list.get(1));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail;  import java.util.Arrays;  import org.apache.commons.collections4.multiset.HashMultiSet; import org.junit.Before; import org.junit.Test;  /**  * Tests for MultiSetUtils.  * @since 4.2  */ public class MultiSetUtilsTest {      private String[] fullArray;     private MultiSet<String> multiSet;      @Before     public void setUp() {         fullArray = new String[]{             "a", "a", "b", "c", "d", "d", "d"         };         multiSet = new HashMultiSet<>(Arrays.asList(fullArray));     }      /**      * Tests {@link MultiSetUtils#emptyMultiSet()}.      */     @Test     public void testEmptyMultiSet() {         final MultiSet<Integer> empty = MultiSetUtils.emptyMultiSet();         assertEquals(0, empty.size());         try {             empty.add(55);             fail("Empty multi set must be read-only");         } catch (final UnsupportedOperationException e) {         }     }      /**      * Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}.      */     @Test     public void testUnmodifiableMultiSet() {         final MultiSet<String> unmodifiable = MultiSetUtils.unmodifiableMultiSet(multiSet);         assertEquals(multiSet, unmodifiable);          try {             unmodifiable.add("a");             fail("Empty multi set must be read-only");         } catch (final UnsupportedOperationException e) {         }          try {             MultiSetUtils.unmodifiableMultiSet(null);             fail("Expecting NPE");         } catch (final NullPointerException e) {         }     }      /**      * Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}.      */     @Test     public void testSynchronizedMultiSet() {         final MultiSet<String> synced = MultiSetUtils.synchronizedMultiSet(multiSet);         assertEquals(multiSet, synced);         synced.add("a"); // ensure adding works     }      /**      * Tests {@link MultiSetUtils#predicatedMultiSet(org.apache.commons.collections4.MultiSet, org.apache.commons.collections4.Predicate)}.      */     @Test     public void testPredicatedMultiSet() {         final Predicate<String> predicate = object -> object.length() == 1;         final MultiSet<String> predicated = MultiSetUtils.predicatedMultiSet(multiSet, predicate);         assertEquals(multiSet.size(), predicated.size());         assertEquals(multiSet.getCount("a"), predicated.getCount("a"));          try {             MultiSetUtils.predicatedMultiSet(null, predicate);             fail("Expecting NPE");         } catch (final NullPointerException e) {         }          try {             MultiSetUtils.predicatedMultiSet(multiSet, null);             fail("Expecting NPE");         } catch (final NullPointerException e) {         }          try {             MultiSetUtils.predicatedMultiSet(multiSet, object -> object.equals("a"));             fail("Predicate is violated for all elements not being 'a'");         } catch (final IllegalArgumentException iae) {         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.Set;  import org.apache.commons.collections4.bag.HashBag; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Tests for IterableUtils.  *  * @since 4.1  */ public class IterableUtilsTest {      /**      * Iterable of {@link Integer}s      */     private Iterable<Integer> iterableA = null;      /**      * Iterable of {@link Long}s      */     private Iterable<Long> iterableB = null;      /**      * An empty Iterable.      */     private Iterable<Integer> emptyIterable = null;      @Before     public void setUp() {         final Collection<Integer> collectionA = new ArrayList<>();         collectionA.add(1);         collectionA.add(2);         collectionA.add(2);         collectionA.add(3);         collectionA.add(3);         collectionA.add(3);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         collectionA.add(4);         iterableA = collectionA;          final Collection<Long> collectionB = new LinkedList<>();         collectionB.add(5L);         collectionB.add(4L);         collectionB.add(4L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(3L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         collectionB.add(2L);         iterableB = collectionB;          emptyIterable = Collections.emptyList();     }      private static Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;      private static Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;      // -----------------------------------------------------------------------     @Test     public void forEach() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         IterableUtils.forEach(col, testClosure);         assertTrue(listA.isEmpty() && listB.isEmpty());         try {             IterableUtils.forEach(col, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IterableUtils.forEach(null, testClosure);          // null should be OK         col.add(null);         IterableUtils.forEach(col, testClosure);     }      @Test(expected = FunctorException.class)     public void forEachFailure() {         final Closure<String> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<String> col = new ArrayList<>();         col.add("x");         IterableUtils.forEach(col, testClosure);     }      @Test     public void forEachButLast() {         final List<Integer> listA = new ArrayList<>();         listA.add(1);          final List<Integer> listB = new ArrayList<>();         listB.add(2);          final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure("clear");         final Collection<List<Integer>> col = new ArrayList<>();         col.add(listA);         col.add(listB);         List<Integer> last = IterableUtils.forEachButLast(col, testClosure);         assertTrue(listA.isEmpty() && !listB.isEmpty());         assertSame(listB, last);          try {             IterableUtils.forEachButLast(col, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }          IterableUtils.forEachButLast(null, testClosure);          // null should be OK         col.add(null);         col.add(null);         last = IterableUtils.forEachButLast(col, testClosure);         assertNull(last);     }      @Test     public void containsWithEquator() {         final List<String> base = new ArrayList<>();         base.add("AC");         base.add("BB");         base.add("CA");          final Equator<String> secondLetterEquator = new Equator<String>() {              @Override             public boolean equate(final String o1, final String o2) {                 return o1.charAt(1) == o2.charAt(1);             }              @Override             public int hash(final String o) {                 return o.charAt(1);             }          };          assertFalse(base.contains("CC"));         assertTrue(IterableUtils.contains(base, "AC", secondLetterEquator));         assertTrue(IterableUtils.contains(base, "CC", secondLetterEquator));         assertFalse(IterableUtils.contains(base, "CX", secondLetterEquator));         assertFalse(IterableUtils.contains(null, null, secondLetterEquator));          try {             IterableUtils.contains(base, "AC", null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {         } // this is what we want     }      @Test     public void frequency() {         // null iterable test         assertEquals(0, IterableUtils.frequency(null, 1));          assertEquals(1, IterableUtils.frequency(iterableA, 1));         assertEquals(2, IterableUtils.frequency(iterableA, 2));         assertEquals(3, IterableUtils.frequency(iterableA, 3));         assertEquals(4, IterableUtils.frequency(iterableA, 4));         assertEquals(0, IterableUtils.frequency(iterableA, 5));          assertEquals(0, IterableUtils.frequency(iterableB, 1L));         assertEquals(4, IterableUtils.frequency(iterableB, 2L));         assertEquals(3, IterableUtils.frequency(iterableB, 3L));         assertEquals(2, IterableUtils.frequency(iterableB, 4L));         assertEquals(1, IterableUtils.frequency(iterableB, 5L));          // Ensure that generic bounds accept valid parameters, but return         // expected results         // e.g. no longs in the "int" Iterable<Number>, and vice versa.         final Iterable<Number> iterableIntAsNumber = Arrays.<Number>asList(1, 2, 3, 4, 5);         final Iterable<Number> iterableLongAsNumber = Arrays.<Number>asList(1L, 2L, 3L, 4L, 5L);         assertEquals(0, IterableUtils.frequency(iterableIntAsNumber, 2L));         assertEquals(0, IterableUtils.frequency(iterableLongAsNumber, 2));          final Set<String> set = new HashSet<>();         set.add("A");         set.add("C");         set.add("E");         set.add("E");         assertEquals(1, IterableUtils.frequency(set, "A"));         assertEquals(0, IterableUtils.frequency(set, "B"));         assertEquals(1, IterableUtils.frequency(set, "C"));         assertEquals(0, IterableUtils.frequency(set, "D"));         assertEquals(1, IterableUtils.frequency(set, "E"));          final Bag<String> bag = new HashBag<>();         bag.add("A", 3);         bag.add("C");         bag.add("E");         bag.add("E");         assertEquals(3, IterableUtils.frequency(bag, "A"));         assertEquals(0, IterableUtils.frequency(bag, "B"));         assertEquals(1, IterableUtils.frequency(bag, "C"));         assertEquals(0, IterableUtils.frequency(bag, "D"));         assertEquals(2, IterableUtils.frequency(bag, "E"));     }      @Test     public void frequencyOfNull() {         final List<String> list = new ArrayList<>();         assertEquals(0, IterableUtils.frequency(list, null));         list.add("A");         assertEquals(0, IterableUtils.frequency(list, null));         list.add(null);         assertEquals(1, IterableUtils.frequency(list, null));         list.add("B");         assertEquals(1, IterableUtils.frequency(list, null));         list.add(null);         assertEquals(2, IterableUtils.frequency(list, null));         list.add("B");         assertEquals(2, IterableUtils.frequency(list, null));         list.add(null);         assertEquals(3, IterableUtils.frequency(list, null));     }      @Test     public void find() {         Predicate<Number> testPredicate = equalPredicate(4);         Integer test = IterableUtils.find(iterableA, testPredicate);         assertEquals(4, (int) test);         testPredicate = equalPredicate(45);         test = IterableUtils.find(iterableA, testPredicate);         assertNull(test);         assertNull(IterableUtils.find(null, testPredicate));         try {             IterableUtils.find(iterableA, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void indexOf() {         Predicate<Number> testPredicate = equalPredicate((Number) 4);         int index = IterableUtils.indexOf(iterableA, testPredicate);         assertEquals(6, index);         testPredicate = equalPredicate((Number) 45);         index = IterableUtils.indexOf(iterableA, testPredicate);         assertEquals(-1, index);         assertEquals(-1, IterableUtils.indexOf(null, testPredicate));         try {             IterableUtils.indexOf(iterableA, null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void countMatches() {         assertEquals(4, IterableUtils.countMatches(iterableB, EQUALS_TWO));         assertEquals(0, IterableUtils.countMatches(null, EQUALS_TWO));          try {             assertEquals(0, IterableUtils.countMatches(iterableA, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          try {             assertEquals(0, IterableUtils.countMatches(null, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void matchesAny() {         final List<Integer> list = new ArrayList<>();          try {             assertFalse(IterableUtils.matchesAny(null, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          try {             assertFalse(IterableUtils.matchesAny(list, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          assertFalse(IterableUtils.matchesAny(null, EQUALS_TWO));         assertFalse(IterableUtils.matchesAny(list, EQUALS_TWO));         list.add(1);         list.add(3);         list.add(4);         assertFalse(IterableUtils.matchesAny(list, EQUALS_TWO));          list.add(2);         assertTrue(IterableUtils.matchesAny(list, EQUALS_TWO));     }      @Test     public void matchesAll() {         try {             assertFalse(IterableUtils.matchesAll(null, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          try {             assertFalse(IterableUtils.matchesAll(iterableA, null));             fail("predicate must not be null");         } catch (final NullPointerException ex) {             // expected         }          final Predicate<Integer> lessThanFive = object -> object < 5;         assertTrue(IterableUtils.matchesAll(iterableA, lessThanFive));          final Predicate<Integer> lessThanFour = object -> object < 4;         assertFalse(IterableUtils.matchesAll(iterableA, lessThanFour));          assertTrue(IterableUtils.matchesAll(null, lessThanFour));         assertTrue(IterableUtils.matchesAll(emptyIterable, lessThanFour));     }      public void getFromIterable() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         assertEquals("element", IterableUtils.get(bag, 0));     }      @Test(expected = IndexOutOfBoundsException.class)     public void getFromIterableIndexOutOfBoundsException() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         // Collection, non-existent entry         IterableUtils.get(bag, 1);     }      public void firstFromIterable() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         bag.add("element", 1);         assertEquals("element", IterableUtils.first(bag));     }      @Test(expected = IndexOutOfBoundsException.class)     public void firstFromIterableIndexOutOfBoundsException() throws Exception {         // Collection, entry exists         final Bag<String> bag = new HashBag<>();         // Collection, non-existent entry         IterableUtils.first(bag);     }      @SuppressWarnings("unchecked")     @Test     public void partition() {         final List<Integer> input = new ArrayList<>();         input.add(1);         input.add(2);         input.add(3);         input.add(4);         List<List<Integer>> partitions = IterableUtils.partition(input, EQUALS_TWO);         assertEquals(2, partitions.size());          // first partition contains 2         Collection<Integer> partition = partitions.get(0);         assertEquals(1, partition.size());         assertEquals(2, CollectionUtils.extractSingleton(partition).intValue());          // second partition contains 1, 3, and 4         final Integer[] expected = {1, 3, 4};         partition = partitions.get(1);         Assert.assertArrayEquals(expected, partition.toArray());          partitions = IterableUtils.partition((List<Integer>) null, EQUALS_TWO);         assertEquals(2, partitions.size());         assertTrue(partitions.get(0).isEmpty());         assertTrue(partitions.get(1).isEmpty());          partitions = IterableUtils.partition(input);         assertEquals(1, partitions.size());         assertEquals(input, partitions.get(0));          try {             IterableUtils.partition(input, (Predicate<Integer>) null);             fail("expecting NullPointerException");         } catch (final NullPointerException npe) {             // expected         }     }      @SuppressWarnings("unchecked")     @Test     public void partitionMultiplePredicates() {         final List<Integer> input = new ArrayList<>();         input.add(1);         input.add(2);         input.add(3);         input.add(4);         final List<List<Integer>> partitions = IterableUtils.partition(input, EQUALS_TWO, EVEN);          // first partition contains 2         Collection<Integer> partition = partitions.get(0);         assertEquals(1, partition.size());         assertEquals(2, partition.iterator().next().intValue());          // second partition contains 4         partition = partitions.get(1);         assertEquals(1, partition.size());         assertEquals(4, partition.iterator().next().intValue());          // third partition contains 1 and 3         final Integer[] expected = {1, 3};         partition = partitions.get(2);         Assert.assertArrayEquals(expected, partition.toArray());          try {             IterableUtils.partition(input, EQUALS_TWO, null);         } catch (final NullPointerException npe) {             // expected         }     }      @Test     public void testToString() {         String result = IterableUtils.toString(iterableA);         assertEquals("[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]", result);          result = IterableUtils.toString(new ArrayList<Integer>());         assertEquals("[]", result);          result = IterableUtils.toString(null);         assertEquals("[]", result);          result = IterableUtils.toString(iterableA, input -> Integer.toString(input * 2));         assertEquals("[2, 4, 4, 6, 6, 6, 8, 8, 8, 8]", result);          result = IterableUtils.toString(new ArrayList<Integer>(), input -> {             fail("not supposed to reach here");             return "";         });         assertEquals("[]", result);          result = IterableUtils.toString(null, input -> {             fail("not supposed to reach here");             return "";         });         assertEquals("[]", result);     }      @Test     public void testToStringDelimiter() {          final Transformer<Integer, String> transformer = input -> Integer.toString(input * 2);          String result = IterableUtils.toString(iterableA, transformer, "", "", "");         assertEquals("2446668888", result);          result = IterableUtils.toString(iterableA, transformer, ",", "", "");         assertEquals("2,4,4,6,6,6,8,8,8,8", result);          result = IterableUtils.toString(iterableA, transformer, "", "[", "]");         assertEquals("[2446668888]", result);          result = IterableUtils.toString(iterableA, transformer, ",", "[", "]");         assertEquals("[2,4,4,6,6,6,8,8,8,8]", result);          result = IterableUtils.toString(iterableA, transformer, ",", "[[", "]]");         assertEquals("[[2,4,4,6,6,6,8,8,8,8]]", result);          result = IterableUtils.toString(iterableA, transformer, ",,", "[", "]");         assertEquals("[2,,4,,4,,6,,6,,6,,8,,8,,8,,8]", result);          result = IterableUtils.toString(iterableA, transformer, ",,", "((", "))");         assertEquals("((2,,4,,4,,6,,6,,6,,8,,8,,8,,8))", result);          result = IterableUtils.toString(new ArrayList<Integer>(), transformer, "", "(", ")");         assertEquals("()", result);          result = IterableUtils.toString(new ArrayList<Integer>(), transformer, "", "", "");         assertEquals("", result);     }      @Test     public void testToStringWithNullArguments() {         final String result = IterableUtils.toString(null, input -> {             fail("not supposed to reach here");             return "";         }, "", "(", ")");         assertEquals("()", result);          try {             IterableUtils.toString(new ArrayList<Integer>(), null, "", "(", ")");             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          try {             IterableUtils.toString(new ArrayList<Integer>(), input -> {                 fail("not supposed to reach here");                 return "";             }, null, "(", ")");             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          try {             IterableUtils.toString(new ArrayList<Integer>(), input -> {                 fail("not supposed to reach here");                 return "";             }, "", null, ")");             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }          try {             IterableUtils.toString(new ArrayList<Integer>(), input -> {                 fail("not supposed to reach here");                 return "";             }, "", "(", null);             fail("expecting NullPointerException");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void size() {         assertEquals(0, IterableUtils.size(null));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import java.util.LinkedList; import java.util.Queue;  import org.apache.commons.collections4.functors.TruePredicate; import org.apache.commons.collections4.queue.PredicatedQueue; import org.apache.commons.collections4.queue.SynchronizedQueue; import org.apache.commons.collections4.queue.TransformedQueue; import org.apache.commons.collections4.queue.UnmodifiableQueue; import org.junit.Test;  /**  * Tests for QueueUtils factory methods.  *  */ public class QueueUtilsTest {      protected Predicate<Object> truePredicate = TruePredicate.truePredicate();     protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();      // ----------------------------------------------------------------------      @Test     public void testSynchronizedQueue() {         final Queue<Object> queue = QueueUtils.synchronizedQueue(new LinkedList<>());         assertTrue("Returned object should be a SynchronizedQueue.", queue instanceof SynchronizedQueue);         try {             QueueUtils.synchronizedQueue(null);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableQueue() {         final Queue<Object> queue = QueueUtils.unmodifiableQueue(new LinkedList<>());         assertTrue("Returned object should be an UnmodifiableQueue.", queue instanceof UnmodifiableQueue);         try {             QueueUtils.unmodifiableQueue(null);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableQueue shall not be decorated", queue, QueueUtils.unmodifiableQueue(queue));     }      @Test     public void testPredicatedQueue() {         final Queue<Object> queue = QueueUtils.predicatedQueue(new LinkedList<>(), truePredicate);         assertTrue("Returned object should be a PredicatedQueue.", queue instanceof PredicatedQueue);         try {             QueueUtils.predicatedQueue(null, truePredicate);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }         try {             QueueUtils.predicatedQueue(new LinkedList<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testTransformedQueue() {         final Queue<Object> queue = QueueUtils.transformingQueue(new LinkedList<>(), nopTransformer);         assertTrue("Returned object should be an TransformedQueue.", queue instanceof TransformedQueue);         try {             QueueUtils.transformingQueue(null, nopTransformer);             fail("Expecting NullPointerException for null queue.");         } catch (final NullPointerException ex) {             // expected         }         try {             QueueUtils.transformingQueue(new LinkedList<>(), null);             fail("Expecting NullPointerException for null transformer.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testEmptyQueue() {         final Queue<Object> queue = QueueUtils.emptyQueue();         assertTrue("Returned object should be an UnmodifiableQueue.", queue instanceof UnmodifiableQueue);         assertTrue("Returned queue is not empty.", queue.isEmpty());          try {             queue.add(new Object());             fail("Expecting UnsupportedOperationException for empty queue.");         } catch (final UnsupportedOperationException ex) {             // expected         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import static org.junit.Assert.*;  import org.apache.commons.collections4.bag.HashBag; import org.apache.commons.collections4.bag.PredicatedBag; import org.apache.commons.collections4.bag.PredicatedSortedBag; import org.apache.commons.collections4.bag.SynchronizedBag; import org.apache.commons.collections4.bag.SynchronizedSortedBag; import org.apache.commons.collections4.bag.TransformedBag; import org.apache.commons.collections4.bag.TransformedSortedBag; import org.apache.commons.collections4.bag.TreeBag; import org.apache.commons.collections4.bag.UnmodifiableBag; import org.apache.commons.collections4.bag.UnmodifiableSortedBag; import org.apache.commons.collections4.functors.TruePredicate; import org.junit.Test;  /**  * Tests for BagUtils factory methods.  *  */ public class BagUtilsTest {      protected Predicate<Object> truePredicate = TruePredicate.truePredicate();     protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();      //----------------------------------------------------------------------      @Test     public void testSynchronizedBag() {         final Bag<Object> bag = BagUtils.synchronizedBag(new HashBag<>());         assertTrue("Returned object should be a SynchronizedBag.",             bag instanceof SynchronizedBag);         try {             BagUtils.synchronizedBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableBag() {         final Bag<Object> bag = BagUtils.unmodifiableBag(new HashBag<>());         assertTrue("Returned object should be an UnmodifiableBag.",             bag instanceof UnmodifiableBag);         try {             BagUtils.unmodifiableBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableBag shall not be decorated", bag, BagUtils.unmodifiableBag(bag));     }      @Test     public void testPredicatedBag() {         final Bag<Object> bag = BagUtils.predicatedBag(new HashBag<>(), truePredicate);         assertTrue("Returned object should be a PredicatedBag.",             bag instanceof PredicatedBag);         try {             BagUtils.predicatedBag(null, truePredicate);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.predicatedBag(new HashBag<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testTransformedBag() {         final Bag<Object> bag = BagUtils.transformingBag(new HashBag<>(), nopTransformer);         assertTrue("Returned object should be an TransformedBag.",             bag instanceof TransformedBag);         try {             BagUtils.transformingBag(null, nopTransformer);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.transformingBag(new HashBag<>(), null);             fail("Expecting NullPointerException for null transformer.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testSynchronizedSortedBag() {         final Bag<Object> bag = BagUtils.synchronizedSortedBag(new TreeBag<>());         assertTrue("Returned object should be a SynchronizedSortedBag.",             bag instanceof SynchronizedSortedBag);         try {             BagUtils.synchronizedSortedBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testUnmodifiableSortedBag() {         final SortedBag<Object> bag = BagUtils.unmodifiableSortedBag(new TreeBag<>());         assertTrue("Returned object should be an UnmodifiableSortedBag.",             bag instanceof UnmodifiableSortedBag);         try {             BagUtils.unmodifiableSortedBag(null);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }          assertSame("UnmodifiableSortedBag shall not be decorated", bag, BagUtils.unmodifiableSortedBag(bag));     }      @Test     public void testPredicatedSortedBag() {         final Bag<Object> bag = BagUtils.predicatedSortedBag(new TreeBag<>(), truePredicate);         assertTrue("Returned object should be a PredicatedSortedBag.",             bag instanceof PredicatedSortedBag);         try {             BagUtils.predicatedSortedBag(null, truePredicate);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.predicatedSortedBag(new TreeBag<>(), null);             fail("Expecting NullPointerException for null predicate.");         } catch (final NullPointerException ex) {             // expected         }     }      @Test     public void testTransformedSortedBag() {         final Bag<Object> bag = BagUtils.transformingSortedBag(new TreeBag<>(), nopTransformer);         assertTrue("Returned object should be an TransformedSortedBag",             bag instanceof TransformedSortedBag);         try {             BagUtils.transformingSortedBag(null, nopTransformer);             fail("Expecting NullPointerException for null bag.");         } catch (final NullPointerException ex) {             // expected         }         try {             BagUtils.transformingSortedBag(new TreeBag<>(), null);             fail("Expecting NullPointerException for null transformer.");         } catch (final NullPointerException ex) {             // expected         }     } }   
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4;  import java.util.ArrayList; import java.util.List; import java.util.ListIterator;  import org.easymock.EasyMock; import org.easymock.IExpectationSetters;  /**  * Provides utilities for making mock-based tests.  Most notable is the generic "type-safe"  * {@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods  * that call the respective methods on all created mock objects.  */ public abstract class MockTestCase {     private final List<Object> mockObjects = new ArrayList<>();      @SuppressWarnings("unchecked")     protected <T> T createMock(final Class<?> name) {         final T mock = (T) EasyMock.createMock(name);         return registerMock(mock);     }      private <T> T registerMock(final T mock) {         mockObjects.add(mock);         return mock;     }      protected <T> IExpectationSetters<T> expect(final T t) {         return EasyMock.expect(t);     }      protected final void replay() {         for (final Object o : mockObjects) {             EasyMock.replay(o);         }     }      protected final void verify() {         for (final ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {             try {                 EasyMock.verify(i.next());             } catch (final AssertionError e) {                 throw new AssertionError(i.previousIndex() + 1 + ""                         + e.getMessage());             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Comparator; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.SortedMap; import java.util.TreeMap; import java.util.concurrent.ConcurrentSkipListMap;  import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link PredicatedMapTest} for exercising the  * {@link PredicatedSortedMap} implementation.  *  * @since 3.0  */ public class PredicatedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      private class ReverseStringComparator implements Comparator<K> {         @Override         public int compare(final K arg0, final K arg1) {             return ((String) arg1).compareTo((String) arg0);         }     }      protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();      protected static final Predicate<Object> testPredicate = o -> o instanceof String;      protected final Comparator<K> reverseStringComparator = new ReverseStringComparator();      public PredicatedSortedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     protected SortedMap<K, V> decorateMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,         final Predicate<? super V> valuePredicate) {         return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);     }      @Override     public SortedMap<K, V> makeObject() {         return decorateMap(new TreeMap<K, V>(), truePredicate, truePredicate);     }      public SortedMap<K, V> makeTestMap() {         return decorateMap(new TreeMap<K, V>(), testPredicate, testPredicate);     }      public SortedMap<K, V> makeTestMapWithComparator() {         return decorateMap(new ConcurrentSkipListMap<K, V>(reverseStringComparator), testPredicate, testPredicate);     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      @Override     public boolean isAllowNullKey() {         return false;     }      // from TestPredicatedMap     //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEntrySet() {         SortedMap<K, V> map = makeTestMap();         assertTrue("returned entryset should not be null",             map.entrySet() != null);         map = decorateMap(new TreeMap<K, V>(), null, null);         map.put((K) "oneKey", (V) "oneValue");         assertTrue("returned entryset should contain one entry",             map.entrySet().size() == 1);         map = decorateMap(map, null, null);     }      @SuppressWarnings("unchecked")     public void testPut() {         final Map<K, V> map = makeTestMap();         try {             map.put((K) "Hi", (V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          try {             map.put((K) Integer.valueOf(3), (V) "Hi");             fail("Illegal key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          assertTrue(!map.containsKey(Integer.valueOf(3)));         assertTrue(!map.containsValue(Integer.valueOf(3)));          final Map<K, V> map2 = new HashMap<>();         map2.put((K) "A", (V) "a");         map2.put((K) "B", (V) "b");         map2.put((K) "C", (V) "c");         map2.put((K) "c", (V) Integer.valueOf(3));          try {             map.putAll(map2);             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "E", (V) "e");         Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();         try {             final Map.Entry<K, V> entry = iterator.next();             entry.setValue((V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "F", (V) "f");         iterator = map.entrySet().iterator();         final Map.Entry<K, V> entry = iterator.next();         entry.setValue((V) "x");      }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testSortOrder() {         final SortedMap<K, V> map = makeTestMap();         map.put((K) "A",  (V) "a");         map.put((K) "B", (V) "b");         try {             map.put(null, (V) "c");             fail("Null key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         map.put((K) "C", (V) "c");         try {             map.put((K) "D", null);             fail("Null value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         assertEquals("First key should be A", "A", map.firstKey());         assertEquals("Last key should be C", "C", map.lastKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap((K) "B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap((K) "C").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap((K) "A", (K) "C").lastKey());          final Comparator<? super K> c = map.comparator();         assertTrue("natural order, so comparator should be null",             c == null);     }      @SuppressWarnings("unchecked")     public void testReverseSortOrder() {         final SortedMap<K, V> map = makeTestMapWithComparator();         map.put((K) "A",  (V) "a");         map.put((K) "B", (V) "b");         try {             map.put(null, (V) "c");             fail("Null key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         map.put((K) "C", (V) "c");         try {             map.put((K) "D", null);             fail("Null value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }         assertEquals("Last key should be A", "A", map.lastKey());         assertEquals("First key should be C", "C", map.firstKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap((K) "B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap((K) "A").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap((K) "C", (K) "A").lastKey());          final Comparator<? super K> c = map.comparator();         assertTrue("reverse order, so comparator should be reverseStringComparator",             c == reverseStringComparator);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedSortedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Map;  /**  * A {@code Map} implementation that matches keys and values based  * on {@code ==} not {@code equals()}.  * <p>  * <strong>This map will violate the detail of various Map and map view contracts.</strong>  * As a general rule, don't compare this map to other maps. In particular, you can't  * use decorators like {@link ListOrderedMap} on it, which silently assume that these  * contracts are fulfilled.  * <p>  * <strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>  * If you wish to use this map from multiple threads concurrently, you must use  * appropriate synchronization. The simplest approach is to wrap this map  * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw  * exceptions when accessed by concurrent threads without synchronization.  * <p>  * From 4.0, this class is replaced by java.util.IdentityHashMap but kept as a  * test-class because it is still used by the ReferenceIdentityMapTest.  *  * @param <K> the type of the keys in this map  * @param <V> the type of the values in this map  * @since 3.0  */ public class IdentityMap<K, V>         extends AbstractHashedMap<K, V> implements Serializable, Cloneable {      /** Serialisation version */     private static final long serialVersionUID = 2028493495224302329L;      /**      * Constructs a new empty map with default size and load factor.      */     public IdentityMap() {         super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);     }      /**      * Constructs a new, empty map with the specified initial capacity.      *      * @param initialCapacity  the initial capacity      * @throws IllegalArgumentException if the initial capacity is negative      */     public IdentityMap(final int initialCapacity) {         super(initialCapacity);     }      /**      * Constructs a new, empty map with the specified initial capacity and      * load factor.      *      * @param initialCapacity  the initial capacity      * @param loadFactor  the load factor      * @throws IllegalArgumentException if the initial capacity is negative      * @throws IllegalArgumentException if the load factor is less than zero      */     public IdentityMap(final int initialCapacity, final float loadFactor) {         super(initialCapacity, loadFactor);     }      /**      * Constructor copying elements from another map.      *      * @param map  the map to copy      * @throws NullPointerException if the map is null      */     public IdentityMap(final Map<K, V> map) {         super(map);     }      //-----------------------------------------------------------------------     /**      * Gets the hash code for the key specified.      * This implementation uses the identity hash code.      *      * @param key  the key to get a hash code for      * @return the hash code      */     @Override     protected int hash(final Object key) {         return System.identityHashCode(key);     }      /**      * Compares two keys for equals.      * This implementation uses {@code ==}.      *      * @param key1  the first key to compare      * @param key2  the second key to compare      * @return true if equal by identity      */     @Override     protected boolean isEqualKey(final Object key1, final Object key2) {         return key1 == key2;     }      /**      * Compares two values for equals.      * This implementation uses {@code ==}.      *      * @param value1  the first value to compare      * @param value2  the second value to compare      * @return true if equal by identity      */     @Override     protected boolean isEqualValue(final Object value1, final Object value2) {         return value1 == value2;     }      /**      * Creates an entry to store the data.      * This implementation creates an IdentityEntry instance.      *      * @param next  the next entry in sequence      * @param hashCode  the hash code to use      * @param key  the key to store      * @param value  the value to store      * @return the newly created entry      */     @Override     protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,                                               final K key, final V value) {         return new IdentityEntry<>(next, hashCode, key, value);     }      //-----------------------------------------------------------------------     /**      * HashEntry      */     protected static class IdentityEntry<K, V> extends HashEntry<K, V> {          protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {             super(next, hashCode, key, value);         }          @Override         public boolean equals(final Object obj) {             if (obj == this) {                 return true;             }             if (!(obj instanceof Entry)) {                 return false;             }             final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;             return                 getKey() == other.getKey() &&                 getValue() == other.getValue();         }          @Override         public int hashCode() {             return System.identityHashCode(getKey()) ^                    System.identityHashCode(getValue());         }     }      //-----------------------------------------------------------------------     /**      * Clones the map without cloning the keys or values.      *      * @return a shallow clone      */     @Override     public IdentityMap<K, V> clone() {         return (IdentityMap<K, V>) super.clone();     }      /**      * Write the map out using a custom routine.      */     private void writeObject(final ObjectOutputStream out) throws IOException {         out.defaultWriteObject();         doWriteObject(out);     }      /**      * Read the map in using a custom routine.      */     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {         in.defaultReadObject();         doReadObject(in);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Iterator; import java.util.Map;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.functors.TruePredicate;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link PredicatedMap} implementation.  *  * @since 3.0  */ public class PredicatedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();      protected static final Predicate<Object> testPredicate = o -> o instanceof String;      public PredicatedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     protected IterableMap<K, V> decorateMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,         final Predicate<? super V> valuePredicate) {         return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);     }      @Override     public IterableMap<K, V> makeObject() {         return decorateMap(new HashMap<K, V>(), truePredicate, truePredicate);     }      public IterableMap<K, V> makeTestMap() {         return decorateMap(new HashMap<K, V>(), testPredicate, testPredicate);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEntrySet() {         Map<K, V> map = makeTestMap();         assertTrue("returned entryset should not be null",             map.entrySet() != null);         map = decorateMap(new HashMap<K, V>(), null, null);         map.put((K) "oneKey", (V) "oneValue");         assertTrue("returned entryset should contain one entry",             map.entrySet().size() == 1);         map = decorateMap(map, null, null);     }      @SuppressWarnings("unchecked")     public void testPut() {         final Map<K, V> map = makeTestMap();         try {             map.put((K) "Hi", (V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          try {             map.put((K) Integer.valueOf(3), (V) "Hi");             fail("Illegal key should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          assertTrue(!map.containsKey(Integer.valueOf(3)));         assertTrue(!map.containsValue(Integer.valueOf(3)));          final Map<K, V> map2 = new HashMap<>();         map2.put((K) "A", (V) "a");         map2.put((K) "B", (V) "b");         map2.put((K) "C", (V) "c");         map2.put((K) "c", (V) Integer.valueOf(3));          try {             map.putAll(map2);             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "E", (V) "e");         Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();         try {             final Map.Entry<K, V> entry = iterator.next();             entry.setValue((V) Integer.valueOf(3));             fail("Illegal value should raise IllegalArgument");         } catch (final IllegalArgumentException e) {             // expected         }          map.put((K) "F", (V) "f");         iterator = map.entrySet().iterator();         final Map.Entry<K, V> entry = iterator.next();         entry.setValue((V) "x");      }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/PredicatedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link UnmodifiableMap} implementation.  *  * @since 3.0  */ public class UnmodifiableMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public UnmodifiableMapTest(final String testName) {         super(testName);     }      //-------------------------------------------------------------------      @Override     public IterableMap<K, V> makeObject() {         return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(new HashMap<K, V>());     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public IterableMap<K, V> makeFullMap() {         final Map<K, V> m = new HashMap<>();         addSampleMappings(m);         return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final Map<K, V> map = makeFullMap();         assertSame(map, UnmodifiableMap.unmodifiableMap(map));          try {             UnmodifiableMap.unmodifiableMap(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.ResettableIterator; import org.apache.commons.collections4.list.AbstractListTest;  /**  * JUnit tests.  *  */ public class LinkedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public LinkedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(LinkedMapTest.class);     }      @Override     public LinkedMap<K, V> makeObject() {         return new LinkedMap<>();     }      /**      * {@inheritDoc}      */     @Override     public LinkedMap<K, V> makeFullMap() {         return (LinkedMap<K, V>) super.makeFullMap();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testReset() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         ((ResettableIterator<K>) ordered.mapIterator()).reset();          resetFull();         ordered = getMap();         final List<K> list = new ArrayList<>(ordered.keySet());         final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();         assertSame(list.get(0), it.next());         assertSame(list.get(1), it.next());         it.reset();         assertSame(list.get(0), it.next());     }      //-----------------------------------------------------------------------     public void testInsertionOrder() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> keyIter;         Iterator<V> valueIter;          resetEmpty();         map.put(keys[0], values[0]);         map.put(keys[1], values[1]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[0], valueIter.next());         assertSame(values[1], valueIter.next());          // no change to order         map.put(keys[1], values[1]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[0], valueIter.next());         assertSame(values[1], valueIter.next());          // no change to order         map.put(keys[1], values[2]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[0], valueIter.next());         assertSame(values[2], valueIter.next());          // no change to order         map.put(keys[0], values[3]);         keyIter = map.keySet().iterator();         assertSame(keys[0], keyIter.next());         assertSame(keys[1], keyIter.next());         valueIter = map.values().iterator();         assertSame(values[3], valueIter.next());         assertSame(values[2], valueIter.next());     }      //-----------------------------------------------------------------------     public void testGetByIndex() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         try {             lm.get(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.get(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lm = getMap();         try {             lm.get(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.get(lm.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {             assertSame(it.next(), lm.get(i));         }     }      public void testGetValueByIndex() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         try {             lm.getValue(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lm = getMap();         try {             lm.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.getValue(lm.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {             it.next();             assertSame(it.getValue(), lm.getValue(i));         }     }      public void testIndexOf() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         assertEquals(-1, lm.indexOf(getOtherKeys()));          resetFull();         lm = getMap();         final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             assertEquals(i, lm.indexOf(list.get(i)));         }     }      public void testRemoveByIndex() {         resetEmpty();         LinkedMap<K, V> lm = getMap();         try {             lm.remove(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lm = getMap();         try {             lm.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lm.remove(lm.size());         } catch (final IndexOutOfBoundsException ex) {}          final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             final Object key = list.get(i);             final Object value = lm.get(key);             assertEquals(value, lm.remove(i));             list.remove(i);             assertEquals(false, lm.containsKey(key));         }     }      public BulkTest bulkTestListView() {         return new TestListView();     }      public class TestListView extends AbstractListTest<K> {          TestListView() {             super("TestListView");         }          @Override         public List<K> makeObject() {             return LinkedMapTest.this.makeObject().asList();         }          @Override         public List<K> makeFullCollection() {             return LinkedMapTest.this.makeFullMap().asList();         }          @Override         public K[] getFullElements() {             return LinkedMapTest.this.getSampleKeys();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return false;         }         @Override         public boolean isSetSupported() {             return false;         }         @Override         public boolean isNullSupported() {             return LinkedMapTest.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      @SuppressWarnings("unchecked")     public void testClone() {         final LinkedMap<K, V> map = new LinkedMap<>(10);         map.put((K) "1", (V) "1");         final Map<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LinkedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LinkedMap.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public LinkedMap<K, V> getMap() {         return (LinkedMap<K, V>) super.getMap();     }      /**      * Test for <a href="https://issues.apache.org/jira/browse/COLLECTIONS-323">COLLECTIONS-323</a>.      */     public void testInitialCapacityZero() {         final LinkedMap<String, String> map = new LinkedMap<>(0);         assertEquals(1, map.data.length);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Tests for the {@link CaseInsensitiveMap} implementation.  *  */ public class CaseInsensitiveMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public static Test suite() {         return BulkTest.makeSuite(CaseInsensitiveMapTest.class);     }      public CaseInsensitiveMapTest(final String testName) {         super(testName);     }      @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     public CaseInsensitiveMap<K, V> makeObject() {         return new CaseInsensitiveMap<>();     }      @SuppressWarnings("unchecked")     public void testCaseInsensitive() {         final Map<K, V> map = makeObject();         map.put((K) "One", (V) "One");         map.put((K) "Two", (V) "Two");         assertEquals("One", map.get("one"));         assertEquals("One", map.get("oNe"));         map.put((K) "two", (V) "Three");         assertEquals("Three", map.get("Two"));     }      @SuppressWarnings("unchecked")     public void testClone() {         final CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<>(10);         map.put((K) "1", (V) "1");         final CaseInsensitiveMap<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }      /**      * Test for <a href="https://issues.apache.org/jira/browse/COLLECTIONS-323">COLLECTIONS-323</a>.      */     public void testInitialCapacityZero() {         final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<>(0);         assertEquals(1, map.data.length);     }      // COLLECTIONS-294     public void testLocaleIndependence() {         final Locale orig = Locale.getDefault();          final Locale[] locales = { Locale.ENGLISH, new Locale("tr", "", ""), Locale.getDefault() };          final String[][] data = {             { "i", "I" },             { "\u03C2", "\u03C3" },             { "\u03A3", "\u03C2" },             { "\u03A3", "\u03C3" },         };          try {             for (final Locale locale : locales) {                 Locale.setDefault(locale);                 for (int j = 0; j < data.length; j++) {                     assertTrue("Test data corrupt: " + j, data[j][0].equalsIgnoreCase(data[j][1]));                     final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<>();                     map.put(data[j][0], "value");                     assertEquals(Locale.getDefault() + ": " + j, "value", map.get(data[j][1]));                 }             }         } finally {             Locale.setDefault(orig);         }     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CaseInsensitiveMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CaseInsensitiveMap.fullCollection.version4.obj"); //    }      @SuppressWarnings("unchecked")     public void testNullHandling() {         final Map<K, V> map = makeObject();         map.put((K) "One", (V) "One");         map.put((K) "Two", (V) "Two");         map.put(null, (V) "Three");         assertEquals("Three", map.get(null));         map.put(null, (V) "Four");         assertEquals("Four", map.get(null));         final Set<K> keys = map.keySet();         assertTrue(keys.contains("one"));         assertTrue(keys.contains("two"));         assertTrue(keys.contains(null));         assertEquals(3, keys.size());     }      public void testPutAll() {         final Map<Object, String> map = new HashMap<>();         map.put("One", "One");         map.put("Two", "Two");         map.put("one", "Three");         map.put(null, "Four");         map.put(Integer.valueOf(20), "Five");         final Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<>(map);         assertEquals(4, caseInsensitiveMap.size()); // ones collapsed         final Set<Object> keys = caseInsensitiveMap.keySet();         assertTrue(keys.contains("one"));         assertTrue(keys.contains("two"));         assertTrue(keys.contains(null));         assertTrue(keys.contains(Integer.toString(20)));         assertEquals(4, keys.size());         assertTrue(!caseInsensitiveMap.containsValue("One")             || !caseInsensitiveMap.containsValue("Three")); // ones collapsed         assertEquals("Four", caseInsensitiveMap.get(null));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map; import java.util.Set;  import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractMapTest} for exercising the {@link TransformedMap}  * implementation.  *  * @since 3.0  */ public class TransformedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public TransformedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public IterableMap<K, V> makeObject() {         return TransformedMap.transformingMap(new HashMap<K, V>(), TransformerUtils.<K>nopTransformer(),                 TransformerUtils.<V>nopTransformer());     }      //-----------------------------------------------------------------------     @SuppressWarnings({ "unchecked", "rawtypes" })     public void testTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          Map<K, V> map = TransformedMap                 .transformingMap(                         new HashMap<K, V>(),                         (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,                         null);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsKey(els[i]));             assertEquals(true, map.containsValue(els[i]));             assertEquals(els[i], map.get(Integer.valueOf((String) els[i])));         }          assertEquals(null, map.remove(els[0]));         assertEquals(els[0], map.remove(Integer.valueOf((String) els[0])));          map = TransformedMap.transformingMap(new HashMap(), null,                                              // cast needed for eclipse compiler                                              (Transformer) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsValue(els[i]));             assertEquals(true, map.containsKey(els[i]));             assertEquals(Integer.valueOf((String) els[i]), map.get(els[i]));         }          assertEquals(Integer.valueOf((String) els[0]), map.remove(els[0]));          final Set<Map.Entry<K, V>> entrySet = map.entrySet();         final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);         array[0].setValue((V) "66");         assertEquals(Integer.valueOf(66), array[0].getValue());         assertEquals(Integer.valueOf(66), map.get(array[0].getKey()));          final Map.Entry<K, V> entry = entrySet.iterator().next();         entry.setValue((V) "88");         assertEquals(Integer.valueOf(88), entry.getValue());         assertEquals(Integer.valueOf(88), map.get(entry.getKey()));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testFactory_Decorate() {         final Map<K, V> base = new HashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final Map<K, V> trans = TransformedMap                 .transformingMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals("1", trans.get("A"));         assertEquals("2", trans.get("B"));         assertEquals("3", trans.get("C"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("D"));     }      @SuppressWarnings("unchecked")     public void testFactory_decorateTransform() {         final Map<K, V> base = new HashMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final Map<K, V> trans = TransformedMap                 .transformedMap(                         base,                         (Transformer<? super K, ? extends K>) TransformedCollectionTest.TO_LOWER_CASE_TRANSFORMER,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(Integer.valueOf(1), trans.get("a"));         assertEquals(Integer.valueOf(2), trans.get("b"));         assertEquals(Integer.valueOf(3), trans.get("c"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("d"));     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import static org.apache.commons.collections4.map.LazyMap.lazyMap;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.FactoryUtils; import org.apache.commons.collections4.Transformer; import org.junit.Test;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link LazyMap} implementation.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class LazyMapTest<K, V> extends AbstractIterableMapTest<K, V> {      private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);      public LazyMapTest(final String testName) {         super(testName);     }      @Override     public LazyMap<K, V> makeObject() {         return lazyMap(new HashMap<K, V>(), FactoryUtils.<V>nullFactory());     }      //-----------------------------------------------------------------------     @Override     public void testMapGet() {         //TODO eliminate need for this via superclass - see svn history.     }      @Test     public void mapGetWithFactory() {         Map<Integer, Number> map = lazyMap(new HashMap<Integer, Number>(), oneFactory);         assertEquals(0, map.size());         final Number i1 = map.get("Five");         assertEquals(1, i1);         assertEquals(1, map.size());         final Number i2 = map.get(new String(new char[] {'F', 'i', 'v', 'e'}));         assertEquals(1, i2);         assertEquals(1, map.size());         assertSame(i1, i2);          map = lazyMap(new HashMap<Integer, Number>(), FactoryUtils.<Long>nullFactory());         final Object o = map.get("Five");         assertEquals(null, o);         assertEquals(1, map.size());     }      @Test     public void mapGetWithTransformer() {         final Transformer<Number, Integer> intConverter = Number::intValue;         final Map<Long, Number> map = lazyMap(new HashMap<Long, Number>(), intConverter);         assertEquals(0, map.size());         final Number i1 = map.get(123L);         assertEquals(123, i1);         assertEquals(1, map.size());     }       @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazyMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazyMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.List;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.list.AbstractListTest;  /**  * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}  * implementation.  *  * @since 3.1  */ public class ListOrderedMap2Test<K, V> extends AbstractOrderedMapTest<K, V> {      public ListOrderedMap2Test(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ListOrderedMap2Test.class);     }      @Override     public ListOrderedMap<K, V> makeObject() {         return new ListOrderedMap<>();     }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> makeFullMap() {         return (ListOrderedMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     public void testGetByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.get(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             assertSame(it.next(), lom.get(i));         }     }      public void testGetValueByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.getValue(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             it.next();             assertSame(it.getValue(), lom.getValue(i));         }     }      public void testIndexOf() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         assertEquals(-1, lom.indexOf(getOtherKeys()));          resetFull();         lom = getMap();         final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             assertEquals(i, lom.indexOf(list.get(i)));         }     }      public void testRemoveByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.remove(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             final Object key = list.get(i);             final Object value = lom.get(key);             assertEquals(value, lom.remove(i));             list.remove(i);             assertEquals(false, lom.containsKey(key));         }     }      public BulkTest bulkTestListView() {         return new TestListView();     }      public class TestListView extends AbstractListTest<K> {          TestListView() {             super("TestListView");         }          @Override         public List<K> makeObject() {             return ListOrderedMap2Test.this.makeObject().asList();         }          @Override         public List<K> makeFullCollection() {             return ListOrderedMap2Test.this.makeFullMap().asList();         }          @Override         public K[] getFullElements() {             return ListOrderedMap2Test.this.getSampleKeys();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return false;         }         @Override         public boolean isSetSupported() {             return false;         }         @Override         public boolean isNullSupported() {             return ListOrderedMap2Test.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> getMap() {         return (ListOrderedMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.FactoryUtils; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.functors.ConstantFactory;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link DefaultedMap} implementation.  *  * @since 3.2  */ public class DefaultedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();     protected final Transformer<K, V> nullTransformer = TransformerUtils.<K, V>nullTransformer();      public DefaultedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     @Override     public IterableMap<K, V> makeObject() {         return DefaultedMap.defaultedMap(new HashMap<K, V>(), nullFactory);     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public void testMapGet() {         final Map<K, V> map = new DefaultedMap<>((V) "NULL");          assertEquals(0, map.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));     }      @SuppressWarnings("unchecked")     public void testMapGet2() {         final HashMap<K, V> base = new HashMap<>();         final Map<K, V> map = DefaultedMap.defaultedMap(base, (V) "NULL");          assertEquals(0, map.size());         assertEquals(0, base.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(1, base.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));     }      @SuppressWarnings("unchecked")     public void testMapGet3() {         final HashMap<K, V> base = new HashMap<>();         final Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) "NULL"));          assertEquals(0, map.size());         assertEquals(0, base.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(1, base.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));     }      @SuppressWarnings("unchecked")     public void testMapGet4() {         final HashMap<K, V> base = new HashMap<>();         final Map<K, V> map = DefaultedMap.defaultedMap(base, (Transformer<K, V>) input -> {             if (input instanceof String) {                 return (V) "NULL";             }             return (V) "NULL_OBJECT";         });          assertEquals(0, map.size());         assertEquals(0, base.size());         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));         assertEquals("NULL_OBJECT", map.get(Integer.valueOf(0)));          map.put((K) "Key", (V) "Value");         assertEquals(1, map.size());         assertEquals(1, base.size());         assertEquals(true, map.containsKey("Key"));         assertEquals("Value", map.get("Key"));         assertEquals(false, map.containsKey("NotInMap"));         assertEquals("NULL", map.get("NotInMap"));         assertEquals("NULL_OBJECT", map.get(Integer.valueOf(0)));     }      public void testFactoryMethods() {         final HashMap<K, V> base = new HashMap<>();          try {             DefaultedMap.defaultedMap(null, (V) "DEFAULT_VALUE");             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap((Map<K, V>) null, nullFactory);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap(base, (Factory<V>) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap((Map<K, V>) null, nullTransformer);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }          try {             DefaultedMap.defaultedMap(base, (Transformer<K, V>) null);             fail("Expecting NullPointerException");         } catch (final NullPointerException e) {             // Expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/DefaultedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/DefaultedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.keyvalue.MultiKey;  /**  * JUnit tests.  *  */ public class MultiKeyMapTest<K, V> extends AbstractIterableMapTest<MultiKey<? extends K>, V> {      static final Integer I1 = Integer.valueOf(1);     static final Integer I2 = Integer.valueOf(2);     static final Integer I3 = Integer.valueOf(3);     static final Integer I4 = Integer.valueOf(4);     static final Integer I5 = Integer.valueOf(5);     static final Integer I6 = Integer.valueOf(6);     static final Integer I7 = Integer.valueOf(7);     static final Integer I8 = Integer.valueOf(8);      public MultiKeyMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(MultiKeyMapTest.class);     }      @Override     public MultiKeyMap<K, V> makeObject() {         return new MultiKeyMap<>();     }      @Override     public MultiKey<K>[] getSampleKeys() {         return getMultiKeyKeys();     }      @SuppressWarnings("unchecked")     private MultiKey<K>[] getMultiKeyKeys() {         return new MultiKey[] {             new MultiKey<>(I1, I2),             new MultiKey<>(I2, I3),             new MultiKey<>(I3, I4),             new MultiKey<>(I1, I1, I2),             new MultiKey<>(I2, I3, I4),             new MultiKey<>(I3, I7, I6),             new MultiKey<>(I1, I1, I2, I3),             new MultiKey<>(I2, I4, I5, I6),             new MultiKey<>(I3, I6, I7, I8),             new MultiKey<>(I1, I1, I2, I3, I4),             new MultiKey<>(I2, I3, I4, I5, I6),             new MultiKey<>(I3, I5, I6, I7, I8),         };     }      @Override     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         return (V[]) new Object[] {             "2A", "2B", "2C",             "3D", "3E", "3F",             "4G", "4H", "4I",             "5J", "5K", "5L",         };     }      @Override     @SuppressWarnings("unchecked")     public V[] getNewSampleValues() {         return (V[]) new Object[] {             "1a", "1b", "1c",             "2d", "2e", "2f",             "3g", "3h", "3i",             "4j", "4k", "4l",         };     }      @Override     @SuppressWarnings("unchecked")     public MultiKey<K>[] getOtherKeys() {         return new MultiKey[] {             new MultiKey<>(I1, I7),             new MultiKey<>(I1, I8),             new MultiKey<>(I2, I4),             new MultiKey<>(I2, I5),         };     }      @Override     public boolean isAllowNullKey() {         return false;     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testNullHandling() {         resetFull();         assertEquals(null, map.get(null));         assertEquals(false, map.containsKey(null));         assertEquals(false, map.containsValue(null));         assertEquals(null, map.remove(null));         assertEquals(false, map.entrySet().contains(null));         assertEquals(false, map.keySet().contains(null));         assertEquals(false, map.values().contains(null));         try {             map.put(null, null);             fail();         } catch (final NullPointerException ex) {}         assertEquals(null, map.put(new MultiKey<K>(null, null), null));         try {             map.put(null, (V) new Object());             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------     public void testMultiKeyGet() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         final MultiKey<K>[] keys = getMultiKeyKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             final MultiKey<K> key = keys[i];             final V value = values[i];              switch (key.size()) {             case 2:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));                 assertEquals(null, multimap.get(null, key.getKey(1)));                 assertEquals(null, multimap.get(key.getKey(0), null));                 assertEquals(null, multimap.get(null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null, null));                 break;             case 3:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2)));                 assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));                 assertEquals(null, multimap.get(null, null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, null));                 break;             case 4:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(null, multimap.get(null, null, null, null));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 break;             case 5:                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 assertEquals(null, multimap.get(null, null, null, null, null));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyContainsKey() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         final MultiKey<K>[] keys = getMultiKeyKeys();          for (final MultiKey<K> key : keys) {             switch (key.size()) {             case 2:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null));                 assertEquals(false, multimap.containsKey(null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null, null));                 break;             case 3:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));                 assertEquals(false, multimap.containsKey(null, null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, null));                 break;             case 4:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(false, multimap.containsKey(null, null, null, null));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 break;             case 5:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 assertEquals(false, multimap.containsKey(null, null, null, null, null));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyPut() {         final MultiKey<K>[] keys = getMultiKeyKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             final MultiKeyMap<K, V> multimap = new MultiKeyMap<>();              final MultiKey<K> key = keys[i];             final V value = values[i];              switch (key.size()) {             case 2:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 break;             case 3:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 break;             case 4:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 break;             case 5:                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), value));                 assertEquals(1, multimap.size());                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(true, multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));                 assertEquals(1, multimap.size());                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyPutWithNullKey() {         final MultiKeyMap<String, String> map = new MultiKeyMap<>();         map.put("a", null, "value1");         map.put("b", null, "value2");         map.put("c", null, "value3");         map.put("a", "z",  "value4");         map.put("a", null, "value5");         map.put(null, "a", "value6");         map.put(null, null, "value7");          assertEquals(6, map.size());         assertEquals("value5", map.get("a", null));         assertEquals("value4", map.get("a", "z"));         assertEquals("value6", map.get(null, "a"));     }      public void testMultiKeyRemove() {         final MultiKey<K>[] keys = getMultiKeyKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             resetFull();             final MultiKeyMap<K, V> multimap = getMap();             final int size = multimap.size();              final MultiKey<K> key = keys[i];             final V value = values[i];              switch (key.size()) {             case 2:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));                 break;             case 3:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));                 break;             case 4:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));                 break;             case 5:                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(size - 1, multimap.size());                 assertEquals(null, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));                 break;             default:                 fail("Invalid key size");             }         }     }      public void testMultiKeyRemoveAll1() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I1);         assertEquals(8, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I1.equals(key.getKey(0)));         }     }      public void testMultiKeyRemoveAll2() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I2, I3);         assertEquals(9, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));         }     }      public void testMultiKeyRemoveAll3() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I1, I1, I2);         assertEquals(9, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));         }     }      public void testMultiKeyRemoveAll4() {         resetFull();         final MultiKeyMap<K, V> multimap = getMap();         assertEquals(12, multimap.size());          multimap.removeAll(I1, I1, I2, I3);         assertEquals(10, multimap.size());         for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {             final MultiKey<? extends K> key = it.next();             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));         }     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testClone() {         final MultiKeyMap<K, V> map = new MultiKeyMap<>();         map.put(new MultiKey<>((K) I1, (K) I2), (V) "1-2");         final Map<MultiKey<? extends K>, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get(new MultiKey<>((K) I1, (K) I2)), cloned.get(new MultiKey<>((K) I1, (K) I2)));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testLRUMultiKeyMap() {         final MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));         map.put((K) I1, (K) I2, (V) "1-2");         map.put((K) I1, (K) I3, (V) "1-1");         assertEquals(2, map.size());         map.put((K) I1, (K) I4, (V) "1-4");         assertEquals(2, map.size());         assertEquals(true, map.containsKey(I1, I3));         assertEquals(true, map.containsKey(I1, I4));         assertEquals(false, map.containsKey(I1, I2));          final MultiKeyMap<K, V> cloned = map.clone();         assertEquals(2, map.size());         assertEquals(true, cloned.containsKey(I1, I3));         assertEquals(true, cloned.containsKey(I1, I4));         assertEquals(false, cloned.containsKey(I1, I2));         cloned.put((K) I1, (K) I5, (V) "1-5");         assertEquals(2, cloned.size());         assertEquals(true, cloned.containsKey(I1, I4));         assertEquals(true, cloned.containsKey(I1, I5));     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/MultiKeyMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/MultiKeyMap.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public MultiKeyMap<K, V> getMap() {         return (MultiKeyMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.Map;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.IteratorUtils; import org.apache.commons.collections4.MultiMap;  /**  * TestMultiValueMap.  *  * @since 3.2  */ @Deprecated public class MultiValueMapTest<K, V> extends AbstractObjectTest {      public MultiValueMapTest(final String testName) {         super(testName);     }      public void testNoMappingReturnsNull() {         final MultiValueMap<K, V> map = createTestMap();         assertNull(map.get("whatever"));     }      @SuppressWarnings("unchecked")     public void testValueCollectionType() {         final MultiValueMap<K, V> map = createTestMap(LinkedList.class);         assertTrue(map.get("one") instanceof LinkedList);     }      @SuppressWarnings("unchecked")     public void testMultipleValues() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         final HashSet<V> expected = new HashSet<>();         expected.add((V) "uno");         expected.add((V) "un");         assertEquals(expected, map.get("one"));     }      @SuppressWarnings("unchecked")     public void testContainsValue() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         assertTrue(map.containsValue("uno"));         assertTrue(map.containsValue("un"));         assertTrue(map.containsValue("dos"));         assertTrue(map.containsValue("deux"));         assertTrue(map.containsValue("tres"));         assertTrue(map.containsValue("trois"));         assertFalse(map.containsValue("quatro"));     }      @SuppressWarnings("unchecked")     public void testKeyContainsValue() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         assertTrue(map.containsValue("one", "uno"));         assertTrue(map.containsValue("one", "un"));         assertTrue(map.containsValue("two", "dos"));         assertTrue(map.containsValue("two", "deux"));         assertTrue(map.containsValue("three", "tres"));         assertTrue(map.containsValue("three", "trois"));         assertFalse(map.containsValue("four", "quatro"));     }      @SuppressWarnings("unchecked")     public void testValues() {         final MultiValueMap<K, V> map = createTestMap(HashSet.class);         final HashSet<V> expected = new HashSet<>();         expected.add((V) "uno");         expected.add((V) "dos");         expected.add((V) "tres");         expected.add((V) "un");         expected.add((V) "deux");         expected.add((V) "trois");         final Collection<Object> c = map.values();         assertEquals(6, c.size());         assertEquals(expected, new HashSet<>(c));     }      @SuppressWarnings("unchecked")     private MultiValueMap<K, V> createTestMap() {         return createTestMap(ArrayList.class);     }      @SuppressWarnings("unchecked")     private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(final Class<C> collectionClass) {         final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);         map.put((K) "one", (V) "uno");         map.put((K) "one", (V) "un");         map.put((K) "two", (V) "dos");         map.put((K) "two", (V) "deux");         map.put((K) "three", (V) "tres");         map.put((K) "three", (V) "trois");         return map;     }      public void testKeyedIterator() {         final MultiValueMap<K, V> map = createTestMap();         final ArrayList<Object> actual = new ArrayList<>(IteratorUtils.toList(map.iterator("one")));         final ArrayList<Object> expected = new ArrayList<>(Arrays.asList("uno", "un"));         assertEquals(expected, actual);     }      public void testRemoveAllViaIterator() {         final MultiValueMap<K, V> map = createTestMap();         for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertNull(map.get("one"));         assertTrue(map.isEmpty());     }      public void testRemoveAllViaKeyedIterator() {         final MultiValueMap<K, V> map = createTestMap();         for (final Iterator<?> i = map.iterator("one"); i.hasNext();) {             i.next();             i.remove();         }         assertNull(map.get("one"));         assertEquals(4, map.totalSize());     }      public void testIterator() {         final MultiValueMap<K, V> map = createTestMap();         @SuppressWarnings("unchecked")         final Collection<V> values = new ArrayList<>((Collection<V>) map.values());         final Iterator<Map.Entry<K, V>> iterator = map.iterator();         while (iterator.hasNext()) {             final Map.Entry<K, V> entry = iterator.next();             assertTrue(map.containsValue(entry.getKey(), entry.getValue()));             assertTrue(values.contains(entry.getValue()));             assertTrue(values.remove(entry.getValue()));         }         assertTrue(values.isEmpty());     }      public void testRemoveAllViaEntryIterator() {         final MultiValueMap<K, V> map = createTestMap();         for (final Iterator<?> i = map.iterator(); i.hasNext();) {             i.next();             i.remove();         }         assertNull(map.get("one"));         assertEquals(0, map.totalSize());     }      public void testTotalSizeA() {         assertEquals(6, createTestMap().totalSize());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMapEquals() {         final MultiValueMap<K, V> one = new MultiValueMap<>();         final Integer value = Integer.valueOf(1);         one.put((K) "One", value);         one.removeMapping("One", value);          final MultiValueMap<K, V> two = new MultiValueMap<>();         assertEquals(two, one);     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testGetCollection() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         map.put((K) "A", "AA");         assertSame(map.get("A"), map.getCollection("A"));     }      @SuppressWarnings("unchecked")     public void testTotalSize() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(0, map.totalSize());         map.put((K) "A", "AA");         assertEquals(1, map.totalSize());         map.put((K) "B", "BA");         assertEquals(2, map.totalSize());         map.put((K) "B", "BB");         assertEquals(3, map.totalSize());         map.put((K) "B", "BC");         assertEquals(4, map.totalSize());         map.remove("A");         assertEquals(3, map.totalSize());         map.removeMapping("B", "BC");         assertEquals(2, map.totalSize());     }      @SuppressWarnings("unchecked")     public void testSize() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(0, map.size());         map.put((K) "A", "AA");         assertEquals(1, map.size());         map.put((K) "B", "BA");         assertEquals(2, map.size());         map.put((K) "B", "BB");         assertEquals(2, map.size());         map.put((K) "B", "BC");         assertEquals(2, map.size());         map.remove("A");         assertEquals(1, map.size());         map.removeMapping("B", "BC");         assertEquals(1, map.size());     }      @SuppressWarnings("unchecked")     public void testSize_Key() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(0, map.size("A"));         assertEquals(0, map.size("B"));         map.put((K) "A", "AA");         assertEquals(1, map.size("A"));         assertEquals(0, map.size("B"));         map.put((K) "B", "BA");         assertEquals(1, map.size("A"));         assertEquals(1, map.size("B"));         map.put((K) "B", "BB");         assertEquals(1, map.size("A"));         assertEquals(2, map.size("B"));         map.put((K) "B", "BC");         assertEquals(1, map.size("A"));         assertEquals(3, map.size("B"));         map.remove("A");         assertEquals(0, map.size("A"));         assertEquals(3, map.size("B"));         map.removeMapping("B", "BC");         assertEquals(0, map.size("A"));         assertEquals(2, map.size("B"));     }      @SuppressWarnings("unchecked")     public void testIterator_Key() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(false, map.iterator("A").hasNext());         map.put((K) "A", "AA");         final Iterator<?> it = map.iterator("A");         assertEquals(true, it.hasNext());         it.next();         assertEquals(false, it.hasNext());     }      @SuppressWarnings("unchecked")     public void testContainsValue_Key() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         assertEquals(false, map.containsValue("A", "AA"));         assertEquals(false, map.containsValue("B", "BB"));         map.put((K) "A", "AA");         assertEquals(true, map.containsValue("A", "AA"));         assertEquals(false, map.containsValue("A", "AB"));     }      @SuppressWarnings("unchecked")     public void testPutWithList() {         @SuppressWarnings("rawtypes")         final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);         assertEquals("a", test.put((K) "A", "a"));         assertEquals("b", test.put((K) "A", "b"));         assertEquals(1, test.size());         assertEquals(2, test.size("A"));         assertEquals(2, test.totalSize());     }      @SuppressWarnings("unchecked")     public void testPutWithSet() {         @SuppressWarnings("rawtypes")         final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);         assertEquals("a", test.put((K) "A", "a"));         assertEquals("b", test.put((K) "A", "b"));         assertEquals(null, test.put((K) "A", "a"));         assertEquals(1, test.size());         assertEquals(2, test.size("A"));         assertEquals(2, test.totalSize());     }      @SuppressWarnings("unchecked")     public void testPutAll_Map1() {         final MultiMap<K, V> original = new MultiValueMap<>();         original.put((K) "key", "object1");         original.put((K) "key", "object2");          final MultiValueMap<K, V> test = new MultiValueMap<>();         test.put((K) "keyA", "objectA");         test.put((K) "key", "object0");         test.putAll(original);          assertEquals(2, test.size());         assertEquals(4, test.totalSize());         assertEquals(1, test.getCollection("keyA").size());         assertEquals(3, test.getCollection("key").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_Map2() {         final Map<K, V> original = new HashMap<>();         original.put((K) "keyX", (V) "object1");         original.put((K) "keyY", (V) "object2");          final MultiValueMap<K, V> test = new MultiValueMap<>();         test.put((K) "keyA", "objectA");         test.put((K) "keyX", "object0");         test.putAll(original);          assertEquals(3, test.size());         assertEquals(4, test.totalSize());         assertEquals(1, test.getCollection("keyA").size());         assertEquals(2, test.getCollection("keyX").size());         assertEquals(1, test.getCollection("keyY").size());         assertEquals(true, test.containsValue("objectA"));         assertEquals(true, test.containsValue("object0"));         assertEquals(true, test.containsValue("object1"));         assertEquals(true, test.containsValue("object2"));     }      @SuppressWarnings("unchecked")     public void testPutAll_KeyCollection() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         Collection<V> coll = (Collection<V>) Arrays.asList("X", "Y", "Z");          assertEquals(true, map.putAll((K) "A", coll));         assertEquals(3, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));          assertEquals(false, map.putAll((K) "A", null));         assertEquals(3, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));          assertEquals(false, map.putAll((K) "A", new ArrayList<V>()));         assertEquals(3, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));          coll = (Collection<V>) Arrays.asList("M");         assertEquals(true, map.putAll((K) "A", coll));         assertEquals(4, map.size("A"));         assertEquals(true, map.containsValue("A", "X"));         assertEquals(true, map.containsValue("A", "Y"));         assertEquals(true, map.containsValue("A", "Z"));         assertEquals(true, map.containsValue("A", "M"));     }      @SuppressWarnings("unchecked")     public void testRemove_KeyItem() {         final MultiValueMap<K, V> map = new MultiValueMap<>();         map.put((K) "A", "AA");         map.put((K) "A", "AB");         map.put((K) "A", "AC");         assertEquals(false, map.removeMapping("C", "CA"));         assertEquals(false, map.removeMapping("A", "AD"));         assertEquals(true, map.removeMapping("A", "AC"));         assertEquals(true, map.removeMapping("A", "AB"));         assertEquals(true, map.removeMapping("A", "AA"));         assertEquals(new MultiValueMap<K, V>(), map);     }      public void testUnsafeDeSerialization() throws Exception {         final MultiValueMap map1 = MultiValueMap.multiValueMap(new HashMap(), ArrayList.class);         byte[] bytes = serialize(map1);         Object result = deserialize(bytes);         assertEquals(map1, result);          final MultiValueMap map2 = MultiValueMap.multiValueMap(new HashMap(), (Class) String.class);         bytes = serialize(map2);         try {             result = deserialize(bytes);             fail("unsafe clazz accepted when de-serializing MultiValueMap");         } catch (final UnsupportedOperationException ex) {             // expected         }     }      private byte[] serialize(final Object object) throws IOException {         final ByteArrayOutputStream baos = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(baos);          oos.writeObject(object);         oos.close();          return baos.toByteArray();     }      private Object deserialize(final byte[] data) throws IOException, ClassNotFoundException {         final ByteArrayInputStream bais = new ByteArrayInputStream(data);         final ObjectInputStream iis = new ObjectInputStream(bais);          return iis.readObject();     }      //-----------------------------------------------------------------------     // Manual serialization testing as this class cannot easily     // extend the AbstractTestMap     //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }      @Override     public Object makeObject() {         @SuppressWarnings("unchecked")         final Map<String, String> m = makeEmptyMap();         m.put("a", "1");         m.put("a", "1b");         m.put("b", "2");         m.put("c", "3");         m.put("c", "3b");         m.put("d", "4");         return m;     }      @SuppressWarnings("rawtypes")     private Map makeEmptyMap() {         return new MultiValueMap();     }      public void testEmptyMapCompatibility() throws Exception {         final Map<?, ?> map = makeEmptyMap();         final Map<?, ?> map2 = (Map<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));         assertEquals("Map is empty", 0, map2.size());     }     public void testFullMapCompatibility() throws Exception {         final Map<?, ?> map = (Map<?, ?>) makeObject();         final Map<?, ?> map2 = (Map<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));         assertEquals("Map is the right size", map.size(), map2.size());         for (final Object key : map.keySet()) {             assertEquals( "Map had inequal elements", map.get(key), map2.get(key) );             map2.remove(key);         }         assertEquals("Map had extra values", 0, map2.size());     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk( //            (java.io.Serializable) makeEmptyMap(), //            "src/test/resources/data/test/MultiValueMap.emptyCollection.version4.obj"); // //        writeExternalFormToDisk( //            (java.io.Serializable) makeObject(), //            "src/test/resources/data/test/MultiValueMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.ResettableIterator;  /**  * JUnit tests.  *  */ public class LRUMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public LRUMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(LRUMapTest.class);     }      @Override     public LRUMap<K, V> makeObject() {         return new LRUMap<>();     }      /**      * {@inheritDoc}      */     @Override     public LRUMap<K, V> makeFullMap() {         return (LRUMap<K, V>) super.makeFullMap();     }      @Override     public boolean isGetStructuralModify() {         return true;     }      /**      * {@inheritDoc}      */     @Override     public LRUMap<K, V> getMap() {         return (LRUMap<K, V>) super.getMap();     }      //-----------------------------------------------------------------------     public void testCtors() {         try {             new LRUMap<K, V>(0);             fail("maxSize must be positive");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(-1, 12, 0.75f, false);             fail("maxSize must be positive");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, -1);             fail("initialSize must not be negative");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, 12);             fail("initialSize must not be larger than maxSize");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, -1, 0.75f, false);             fail("initialSize must not be negative");         } catch(final IllegalArgumentException ex) {             // expected         }          try {             new LRUMap<K, V>(10, 12, 0.75f, false);             fail("initialSize must not be larger than maxSize");         } catch(final IllegalArgumentException ex) {             // expected         }     }      public void testLRU() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> kit;         Iterator<V> vit;          final LRUMap<K, V> map = new LRUMap<>(2);         assertEquals(0, map.size());         assertEquals(false, map.isFull());         assertEquals(2, map.maxSize());          map.put(keys[0], values[0]);         assertEquals(1, map.size());         assertEquals(false, map.isFull());         assertEquals(2, map.maxSize());          map.put(keys[1], values[1]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          map.put(keys[2], values[2]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[2], kit.next());         vit = map.values().iterator();         assertSame(values[1], vit.next());         assertSame(values[2], vit.next());          map.put(keys[2], values[0]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[2], kit.next());         vit = map.values().iterator();         assertSame(values[1], vit.next());         assertSame(values[0], vit.next());          map.put(keys[1], values[3]);         assertEquals(2, map.size());         assertEquals(true, map.isFull());         assertEquals(2, map.maxSize());         kit = map.keySet().iterator();         assertSame(keys[2], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[3], vit.next());     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testReset() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         ((ResettableIterator<K>) ordered.mapIterator()).reset();          resetFull();         ordered = getMap();         final List<K> list = new ArrayList<>(ordered.keySet());         final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();         assertSame(list.get(0), it.next());         assertSame(list.get(1), it.next());         it.reset();         assertSame(list.get(0), it.next());     }      //-----------------------------------------------------------------------     public void testAccessOrder() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> kit;         Iterator<V> vit;          resetEmpty();         map.put(keys[0], values[0]);         map.put(keys[1], values[1]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         map.put(keys[1], values[1]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         map.put(keys[1], values[2]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[2], vit.next());          // change to order         map.put(keys[0], values[3]);         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = map.values().iterator();         assertSame(values[2], vit.next());         assertSame(values[3], vit.next());          // change to order         map.get(keys[1]);         kit = map.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = map.values().iterator();         assertSame(values[3], vit.next());         assertSame(values[2], vit.next());          // change to order         map.get(keys[0]);         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = map.values().iterator();         assertSame(values[2], vit.next());         assertSame(values[3], vit.next());          // no change to order         map.get(keys[0]);         kit = map.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = map.values().iterator();         assertSame(values[2], vit.next());         assertSame(values[3], vit.next());     }      public void testAccessOrder2() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         Iterator<K> kit;         Iterator<V> vit;          resetEmpty();         final LRUMap<K, V> lruMap = (LRUMap<K, V>) map;          lruMap.put(keys[0], values[0]);         lruMap.put(keys[1], values[1]);         kit = lruMap.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = lruMap.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         lruMap.put(keys[1], values[1]);         kit = lruMap.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = lruMap.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // no change to order         lruMap.get(keys[1], false);         kit = lruMap.keySet().iterator();         assertSame(keys[0], kit.next());         assertSame(keys[1], kit.next());         vit = lruMap.values().iterator();         assertSame(values[0], vit.next());         assertSame(values[1], vit.next());          // change to order         lruMap.get(keys[0], true);         kit = lruMap.keySet().iterator();         assertSame(keys[1], kit.next());         assertSame(keys[0], kit.next());         vit = lruMap.values().iterator();         assertSame(values[1], vit.next());         assertSame(values[0], vit.next());     }      @SuppressWarnings("unchecked")     public void testClone() {         final LRUMap<K, V> map = new LRUMap<>(10);         map.put((K) "1", (V) "1");         final Map<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }      @SuppressWarnings("unchecked")     public void testRemoveLRU() {         final MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<>(2);         assertNull(map.entry);         map.put((K) "A", "a");         assertNull(map.entry);         map.put((K) "B", "b");         assertNull(map.entry);         map.put((K) "C", "c");  // removes oldest, which is A=a         assertNotNull(map.entry);         assertEquals("A", map.key);         assertEquals("a", map.value);         assertEquals("C", map.entry.getKey());  // entry is reused         assertEquals("c", map.entry.getValue());  // entry is reused         assertEquals(false, map.containsKey("A"));         assertEquals(true, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = -2126883654452042477L;         LinkEntry<K, V> entry;         K key;         V value;          MockLRUMapSubclass(final int size) {             super(size);         }          @Override         protected boolean removeLRU(final LinkEntry<K, V> entry) {             this.entry = entry;             this.key = entry.getKey();             this.value = entry.getValue();             return true;         }     }      @SuppressWarnings("unchecked")     public void testRemoveLRUBlocksRemove() {         final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<>(2, false);         assertEquals(0, map.size());         map.put((K) "A", (V) "a");         assertEquals(1, map.size());         map.put((K) "B", (V) "b");         assertEquals(2, map.size());         map.put((K) "C", (V) "c");  // should remove oldest, which is A=a, but this is blocked         assertEquals(3, map.size());         assertEquals(2, map.maxSize());         assertEquals(true, map.containsKey("A"));         assertEquals(true, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      @SuppressWarnings("unchecked")     public void testRemoveLRUBlocksRemoveScan() {         final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<>(2, true);         assertEquals(0, map.size());         map.put((K) "A", (V) "a");         assertEquals(1, map.size());         map.put((K) "B", (V) "b");         assertEquals(2, map.size());         map.put((K) "C", (V) "c");  // should remove oldest, which is A=a, but this is blocked         assertEquals(3, map.size());         assertEquals(2, map.maxSize());         assertEquals(true, map.containsKey("A"));         assertEquals(true, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = 6278917461128992945L;          MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove) {             super(size, scanUntilRemove);         }          @Override         protected boolean removeLRU(final LinkEntry<K, V> entry) {             return false;         }     }      @SuppressWarnings("unchecked")     public void testRemoveLRUFirstBlocksRemove() {         final MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<>(2);         assertEquals(0, map.size());         map.put((K) "A", (V) "a");         assertEquals(1, map.size());         map.put((K) "B", (V) "b");         assertEquals(2, map.size());         map.put((K) "C", (V) "c");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b         assertEquals(2, map.size());         assertEquals(2, map.maxSize());         assertEquals(true, map.containsKey("A"));         assertEquals(false, map.containsKey("B"));         assertEquals(true, map.containsKey("C"));     }      static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {         /**          * Generated serial version ID.          */         private static final long serialVersionUID = -6939790801702973428L;          MockLRUMapSubclassFirstBlocksRemove(final int size) {             super(size, true);         }          @Override         protected boolean removeLRU(final LinkEntry<K, V> entry) {             if ("a".equals(entry.getValue())) {                 return false;             }             return true;         }     }      //-----------------------------------------------------------------------     static class SingleHashCode {         private final String code;         SingleHashCode(final String code) {             this.code = code;         }         @Override         public int hashCode() {             // always return the same hashcode             // that way, it will end up in the same bucket             return 12;         }         @Override         public String toString() {             return "SingleHashCode:" + code;         }     }      @SuppressWarnings("unchecked")     public void testInternalState_Buckets() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final SingleHashCode one = new SingleHashCode("1");         final SingleHashCode two = new SingleHashCode("2");         final SingleHashCode three = new SingleHashCode("3");         final SingleHashCode four = new SingleHashCode("4");         final SingleHashCode five = new SingleHashCode("5");         final SingleHashCode six = new SingleHashCode("6");          final LRUMap<K, V> map = new LRUMap<>(3, 1.0f);         final int hashIndex = map.hashIndex(map.hash(one), 4);         map.put((K) one, (V) "A");         map.put((K) two, (V) "B");         map.put((K) three, (V) "C");          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(one, map.header.after.key);  // LRU         assertEquals(two, map.header.after.after.key);         assertEquals(three, map.header.after.after.after.key);  // MRU         assertEquals(three, map.data[hashIndex].key);         assertEquals(two, map.data[hashIndex].next.key);         assertEquals(one, map.data[hashIndex].next.next.key);          map.put((K) four, (V) "D");  // reuses last in next list          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(two, map.header.after.key);  // LRU         assertEquals(three, map.header.after.after.key);         assertEquals(four, map.header.after.after.after.key);  // MRU         assertEquals(four, map.data[hashIndex].key);         assertEquals(three, map.data[hashIndex].next.key);         assertEquals(two, map.data[hashIndex].next.next.key);          map.get(three);          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(two, map.header.after.key);  // LRU         assertEquals(four, map.header.after.after.key);         assertEquals(three, map.header.after.after.after.key);  // MRU         assertEquals(four, map.data[hashIndex].key);         assertEquals(three, map.data[hashIndex].next.key);         assertEquals(two, map.data[hashIndex].next.next.key);          map.put((K) five, (V) "E");  // reuses last in next list          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(four, map.header.after.key);  // LRU         assertEquals(three, map.header.after.after.key);         assertEquals(five, map.header.after.after.after.key);  // MRU         assertEquals(five, map.data[hashIndex].key);         assertEquals(four, map.data[hashIndex].next.key);         assertEquals(three, map.data[hashIndex].next.next.key);          map.get(three);         map.get(five);          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(four, map.header.after.key);  // LRU         assertEquals(three, map.header.after.after.key);         assertEquals(five, map.header.after.after.after.key);  // MRU         assertEquals(five, map.data[hashIndex].key);         assertEquals(four, map.data[hashIndex].next.key);         assertEquals(three, map.data[hashIndex].next.next.key);          map.put((K) six, (V) "F");  // reuses middle in next list          assertEquals(4, map.data.length);         assertEquals(3, map.size);         assertEquals(null, map.header.next);         assertEquals(three, map.header.after.key);  // LRU         assertEquals(five, map.header.after.after.key);         assertEquals(six, map.header.after.after.after.key);  // MRU         assertEquals(six, map.data[hashIndex].key);         assertEquals(five, map.data[hashIndex].next.key);         assertEquals(three, map.data[hashIndex].next.next.key);     }      @SuppressWarnings("unchecked")     public void testInternalState_getEntry_int() {         if (!isPutAddSupported() || !isPutChangeSupported()) {             return;         }         final SingleHashCode one = new SingleHashCode("1");         final SingleHashCode two = new SingleHashCode("2");         final SingleHashCode three = new SingleHashCode("3");          final LRUMap<K, V> map = new LRUMap<>(3, 1.0f);         map.put((K) one, (V) "A");         map.put((K) two, (V) "B");         map.put((K) three, (V) "C");          assertEquals(one, map.getEntry(0).key);         assertEquals(two, map.getEntry(1).key);         assertEquals(three, map.getEntry(2).key);         try {             map.getEntry(-1);             fail();         } catch (final IndexOutOfBoundsException ex) {}         try {             map.getEntry(3);             fail();         } catch (final IndexOutOfBoundsException ex) {}     }      public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {          final LRUMap<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {                                 iter.next();                                 if (iter.getValue() == this) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {          final Map<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final Iterator<Map.Entry<Object, Thread>> iter = map.entrySet().iterator(); iter.hasNext();) {                                 final Map.Entry<Object, Thread> entry = iter.next();                                 if (entry.getValue() == this) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      public void testSynchronizedRemoveFromKeySet() throws InterruptedException {          final Map<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {                                 final String name = (String) iter.next();                                 if (name.substring(0, name.indexOf('[')).equals(getName())) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      public void testSynchronizedRemoveFromValues() throws InterruptedException {          final Map<Object, Thread> map = new LRUMap<>(10000);          final Map<Throwable, String> exceptions = new HashMap<>();         final ThreadGroup tg = new ThreadGroup(getName()) {             @Override             public void uncaughtException(final Thread t, final Throwable e) {                 exceptions.put(e, t.getName());                 super.uncaughtException(t, e);             }         };          final int[] counter = new int[1];         counter[0] = 0;         final Thread[] threads = new Thread[50];         for (int i = 0; i < threads.length; ++i) {             threads[i] = new Thread(tg, "JUnit Thread " + i) {                  @Override                 public void run() {                     int i = 0;                     try {                         synchronized (this) {                             notifyAll();                             wait();                         }                         final Thread thread = Thread.currentThread();                         while (i < 1000  && !interrupted()) {                             synchronized (map) {                                 map.put(thread.getName() + "[" + ++i + "]", thread);                             }                         }                         synchronized (map) {                             for (final Iterator<Thread> iter = map.values().iterator(); iter.hasNext();) {                                 if (iter.next() == this) {                                     iter.remove();                                 }                             }                         }                     } catch (final InterruptedException e) {                         fail("Unexpected InterruptedException");                     }                     if (i > 0) {                         synchronized (counter) {                             counter[0]++;                         }                     }                 }              };         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.start();                 thread.wait();             }         }          for (final Thread thread : threads) {             synchronized (thread) {                 thread.notifyAll();             }         }          Thread.sleep(1000);          for (final Thread thread : threads) {             thread.interrupt();         }         for (final Thread thread : threads) {             synchronized (thread) {                 thread.join();             }         }          assertEquals("Exceptions have been thrown: " + exceptions, 0, exceptions.size());         assertTrue("Each thread should have put at least 1 element into the map, but only "                 + counter[0] + " did succeed", counter[0] >= threads.length);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LRUMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/LRUMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.SortedMap; import java.util.TreeMap;  import org.apache.commons.collections4.BulkTest;  /**  * Abstract test class for {@link java.util.SortedMap} methods and contracts.  *  */ public abstract class AbstractSortedMapTest<K, V> extends AbstractMapTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractSortedMapTest(final String testName) {         super(testName);     }      //-----------------------------------------------------------------------     /**      * Can't sort null keys.      *      * @return false      */     @Override     public boolean isAllowNullKey() {         return false;     }      /**      * SortedMap uses TreeMap as its known comparison.      *      * @return a map that is known to be valid      */     @Override     public SortedMap<K, V> makeConfirmedMap() {         return new TreeMap<>();     }      //-----------------------------------------------------------------------     public void testComparator() { //        SortedMap<K, V> sm = makeFullMap();         // no tests I can think of     }      /**      * {@inheritDoc}      */     @Override     public abstract SortedMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public SortedMap<K, V> makeFullMap() {         return (SortedMap<K, V>) super.makeFullMap();     }      public void testFirstKey() {         final SortedMap<K, V> sm = makeFullMap();         assertSame(sm.keySet().iterator().next(), sm.firstKey());     }      public void testLastKey() {         final SortedMap<K, V> sm = makeFullMap();         K obj = null;         for (final K k : sm.keySet()) {             obj = k;         }         assertSame(obj, sm.lastKey());     }      //-----------------------------------------------------------------------     public BulkTest bulkTestHeadMap() {         return new TestHeadMap<>(this);     }      public BulkTest bulkTestTailMap() {         return new TestTailMap<>(this);     }      public BulkTest bulkTestSubMap() {         return new TestSubMap<>(this);     }      public abstract static class TestViewMap<K, V> extends AbstractSortedMapTest<K, V> {         protected final AbstractMapTest<K, V> main;         protected final List<K> subSortedKeys = new ArrayList<>();         protected final List<V> subSortedValues = new ArrayList<>();         protected final List<V> subSortedNewValues = new ArrayList<>();          public TestViewMap(final String name, final AbstractMapTest<K, V> main) {             super(name);             this.main = main;         }         @Override         public void resetEmpty() {             // needed to init verify correctly             main.resetEmpty();             super.resetEmpty();         }         @Override         public void resetFull() {             // needed to init verify correctly             main.resetFull();             super.resetFull();         }         @Override         public void verify() {             // cross verify changes on view with changes on main map             super.verify();             main.verify();         }         @Override         public BulkTest bulkTestHeadMap() {             return null;  // block infinite recursion         }         @Override         public BulkTest bulkTestTailMap() {             return null;  // block infinite recursion         }         @Override         public BulkTest bulkTestSubMap() {             return null;  // block infinite recursion         }          @Override         @SuppressWarnings("unchecked")         public K[] getSampleKeys() {             return (K[]) subSortedKeys.toArray();         }         @Override         @SuppressWarnings("unchecked")         public V[] getSampleValues() {             return (V[]) subSortedValues.toArray();         }         @Override         @SuppressWarnings("unchecked")         public V[] getNewSampleValues() {             return (V[]) subSortedNewValues.toArray();         }          @Override         public boolean isAllowNullKey() {             return main.isAllowNullKey();         }         @Override         public boolean isAllowNullValue() {             return main.isAllowNullValue();         }         @Override         public boolean isPutAddSupported() {             return main.isPutAddSupported();         }         @Override         public boolean isPutChangeSupported() {             return main.isPutChangeSupported();         }         @Override         public boolean isRemoveSupported() {             return main.isRemoveSupported();         }         @Override         public boolean isTestSerialization() {             return false;         } //        public void testSimpleSerialization() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testSimpleSerialization(); //        } //        public void testSerializeDeserializeThenCompare() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testSerializeDeserializeThenCompare(); //        } //        public void testEmptyMapCompatibility() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testEmptyMapCompatibility(); //        } //        public void testFullMapCompatibility() throws Exception { //            if (main.isSubMapViewsSerializable() == false) return; //            super.testFullMapCompatibility(); //        }     }      public static class TestHeadMap<K, V> extends TestViewMap<K, V> {         static final int SUBSIZE = 6;         final K toKey;          public TestHeadMap(final AbstractMapTest<K, V> main) {             super("SortedMap.HeadMap", main);             final Map<K, V> sm = main.makeFullMap();             for (final Entry<K, V> entry : sm.entrySet()) {                 this.subSortedKeys.add(entry.getKey());                 this.subSortedValues.add(entry.getValue());             }             this.toKey = this.subSortedKeys.get(SUBSIZE);             this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();             this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();             this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));         }         @Override         public SortedMap<K, V> makeObject() {             // done this way so toKey is correctly set in the returned map             return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);         }         @Override         public SortedMap<K, V> makeFullMap() {             return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);         }         public void testHeadMapOutOfRange() {             if (!isPutAddSupported()) {                 return;             }             resetEmpty();             try {                 getMap().put(toKey, subSortedValues.get(0));                 fail();             } catch (final IllegalArgumentException ex) {}             verify();         }         @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion() + ".HeadMapView";         }  //        public void testCreate() throws Exception { //            Map map = makeEmptyMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.HeadMapView.obj"); //            map = makeFullMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj"); //        }     }      public static class TestTailMap<K, V> extends TestViewMap<K, V> {         static final int SUBSIZE = 6;         final K fromKey;         final K invalidKey;          public TestTailMap(final AbstractMapTest<K, V> main) {             super("SortedMap.TailMap", main);             final Map<K, V> sm = main.makeFullMap();             for (final Entry<K, V> entry : sm.entrySet()) {                 this.subSortedKeys.add(entry.getKey());                 this.subSortedValues.add(entry.getValue());             }             this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);             this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);             this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();             this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();             this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));         }         @Override         public SortedMap<K, V> makeObject() {             // done this way so toKey is correctly set in the returned map             return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);         }         @Override         public SortedMap<K, V> makeFullMap() {             return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);         }         public void testTailMapOutOfRange() {             if (!isPutAddSupported()) {                 return;             }             resetEmpty();             try {                 getMap().put(invalidKey, subSortedValues.get(0));                 fail();             } catch (final IllegalArgumentException ex) {}             verify();         }         @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion() + ".TailMapView";         }  //        public void testCreate() throws Exception { //            Map map = makeEmptyMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.TailMapView.obj"); //            map = makeFullMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj"); //        }     }      public static class TestSubMap<K, V> extends TestViewMap<K, V> {         static final int SUBSIZE = 3;         final K fromKey;         final K toKey;          public TestSubMap(final AbstractMapTest<K, V> main) {             super("SortedMap.SubMap", main);             final Map<K, V> sm = main.makeFullMap();             for (final Entry<K, V> entry : sm.entrySet()) {                 this.subSortedKeys.add(entry.getKey());                 this.subSortedValues.add(entry.getValue());             }             this.fromKey = this.subSortedKeys.get(SUBSIZE);             this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);              this.subSortedKeys.subList(0, SUBSIZE).clear();             this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();              this.subSortedValues.subList(0, SUBSIZE).clear();             this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();              this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(                 SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));         }          @Override         public SortedMap<K, V> makeObject() {             // done this way so toKey is correctly set in the returned map             return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);         }         @Override         public SortedMap<K, V> makeFullMap() {             return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);         }         public void testSubMapOutOfRange() {             if (!isPutAddSupported()) {                 return;             }             resetEmpty();             try {                 getMap().put(toKey, subSortedValues.get(0));                 fail();             } catch (final IllegalArgumentException ex) {}             verify();         }         @Override         public String getCompatibilityVersion() {             return main.getCompatibilityVersion() + ".SubMapView";         }  //        public void testCreate() throws Exception { //            Map map = makeEmptyMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.SubMapView.obj"); //            map = makeFullMap(); //            writeExternalFormToDisk( //                (java.io.Serializable) map, //                "D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj"); //        }     }      /**      * {@inheritDoc}      */     @Override     public SortedMap<K, V> getMap() {         return (SortedMap<K, V>) super.getMap();     }      /**      * {@inheritDoc}      */     @Override     public SortedMap<K, V> getConfirmed() {         return (SortedMap<K, V>) super.getConfirmed();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap;  import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractOrderedMapTest} for exercising the  * {@link UnmodifiableOrderedMap} implementation.  *  * @since 3.0  */ public class UnmodifiableOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public UnmodifiableOrderedMapTest(final String testName) {         super(testName);     }      //-------------------------------------------------------------------      @Override     public OrderedMap<K, V> makeObject() {         return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public OrderedMap<K, V> makeFullMap() {         final OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());         addSampleMappings(m);         return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final OrderedMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));          try {             UnmodifiableOrderedMap.unmodifiableOrderedMap(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableOrderedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableOrderedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map; import java.util.Set; import java.util.SortedMap; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.apache.commons.collections4.collection.TransformedCollectionTest;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the {@link TransformedSortedMap}  * implementation.  *  * @since 3.0  */ public class TransformedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      public TransformedSortedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(TransformedSortedMapTest.class);     }      @Override     public String[] ignoredTests() {         return null;     }      //-----------------------------------------------------------------------     @Override     @SuppressWarnings("unchecked")     public SortedMap<K, V> makeObject() {         return TransformedSortedMap.transformingSortedMap(new TreeMap<K, V>(),                 (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),                 (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testTransformedMap() {         final Object[] els = new Object[] { "1", "3", "5", "7", "2", "4", "6" };          SortedMap<K, V> map = TransformedSortedMap                 .transformingSortedMap(                         new TreeMap<K, V>(),                         (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,                         null);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));             try {                 map.containsKey(els[i]);                 fail();             } catch (final ClassCastException ex) {}             assertEquals(true, map.containsValue(els[i]));             assertEquals(els[i], map.get(Integer.valueOf((String) els[i])));         }          try {             map.remove(els[0]);             fail();         } catch (final ClassCastException ex) {}         assertEquals(els[0], map.remove(Integer.valueOf((String) els[0])));          map = TransformedSortedMap                 .transformingSortedMap(                         new TreeMap<K, V>(),                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(0, map.size());         for (int i = 0; i < els.length; i++) {             map.put((K) els[i], (V) els[i]);             assertEquals(i + 1, map.size());             assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));             assertEquals(false, map.containsValue(els[i]));             assertEquals(true, map.containsKey(els[i]));             assertEquals(Integer.valueOf((String) els[i]), map.get(els[i]));         }          assertEquals(Integer.valueOf((String) els[0]), map.remove(els[0]));          final Set<Map.Entry<K, V>> entrySet = map.entrySet();         final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);         array[0].setValue((V) "66");         assertEquals(Integer.valueOf(66), array[0].getValue());         assertEquals(Integer.valueOf(66), map.get(array[0].getKey()));          final Map.Entry<K, V> entry = entrySet.iterator().next();         entry.setValue((V) "88");         assertEquals(Integer.valueOf(88), entry.getValue());         assertEquals(Integer.valueOf(88), map.get(entry.getKey()));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testFactory_Decorate() {         final SortedMap<K, V> base = new TreeMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final SortedMap<K, V> trans = TransformedSortedMap                 .transformingSortedMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals("1", trans.get("A"));         assertEquals("2", trans.get("B"));         assertEquals("3", trans.get("C"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("D"));     }      @SuppressWarnings("unchecked")     public void testFactory_decorateTransform() {         final SortedMap<K, V> base = new TreeMap<>();         base.put((K) "A", (V) "1");         base.put((K) "B", (V) "2");         base.put((K) "C", (V) "3");          final SortedMap<K, V> trans = TransformedSortedMap                 .transformedSortedMap(                         base,                         null,                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);         assertEquals(3, trans.size());         assertEquals(Integer.valueOf(1), trans.get("A"));         assertEquals(Integer.valueOf(2), trans.get("B"));         assertEquals(Integer.valueOf(3), trans.get("C"));         trans.put((K) "D", (V) "4");         assertEquals(Integer.valueOf(4), trans.get("D"));     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/TransformedSortedMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.list.AbstractListTest;  /**  * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}  * implementation.  *  * @since 3.0  */ public class ListOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      public ListOrderedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ListOrderedMapTest.class);     }      @Override     public ListOrderedMap<K, V> makeObject() {         return ListOrderedMap.listOrderedMap(new HashMap<K, V>());     }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> makeFullMap() {         return (ListOrderedMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     public void testGetByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.get(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.get(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.get(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             assertSame(it.next(), lom.get(i));         }     }      public void testGetValueByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.getValue(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.getValue(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.getValue(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          int i = 0;         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {             it.next();             assertSame(it.getValue(), lom.getValue(i));         }     }      public void testIndexOf() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         assertEquals(-1, lom.indexOf(getOtherKeys()));          resetFull();         lom = getMap();         final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             assertEquals(i, lom.indexOf(list.get(i)));         }     }      @SuppressWarnings("unchecked")     public void testSetValueByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.setValue(0, (V) "");         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.setValue(-1, (V) "");         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.setValue(-1, (V) "");         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.setValue(lom.size(), (V) "");         } catch (final IndexOutOfBoundsException ex) {}          for (int i = 0; i < lom.size(); i++) {             final V value = lom.getValue(i);             final Object input = Integer.valueOf(i);             assertEquals(value, lom.setValue(i, (V) input));             assertEquals(input, lom.getValue(i));         }     }      public void testRemoveByIndex() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();         try {             lom.remove(0);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}          resetFull();         lom = getMap();         try {             lom.remove(-1);         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.remove(lom.size());         } catch (final IndexOutOfBoundsException ex) {}          final List<K> list = new ArrayList<>();         for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {             list.add(it.next());         }         for (int i = 0; i < list.size(); i++) {             final Object key = list.get(i);             final Object value = lom.get(key);             assertEquals(value, lom.remove(i));             list.remove(i);             assertEquals(false, lom.containsKey(key));         }     }      @SuppressWarnings("unchecked")     public void testPut_intObjectObject() {         resetEmpty();         ListOrderedMap<K, V> lom = getMap();          try {             lom.put(1, (K) "testInsert1", (V) "testInsert1v");             fail("should not be able to insert at pos 1 in empty Map");         } catch (final IndexOutOfBoundsException ex) {}         try {             lom.put(-1, (K) "testInsert-1", (V) "testInsert-1v");             fail("should not be able to insert at pos -1 in empty Map");         } catch (final IndexOutOfBoundsException ex) {}          // put where key doesn't exist         lom.put(0, (K) "testInsert1", (V) "testInsert1v");         assertEquals("testInsert1v", lom.getValue(0));          lom.put((K) "testInsertPut", (V) "testInsertPutv");         assertEquals("testInsert1v", lom.getValue(0));         assertEquals("testInsertPutv", lom.getValue(1));          lom.put(0, (K) "testInsert0", (V) "testInsert0v");         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("testInsert1v", lom.getValue(1));         assertEquals("testInsertPutv", lom.getValue(2));          lom.put(3, (K) "testInsert3", (V) "testInsert3v");         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("testInsert1v", lom.getValue(1));         assertEquals("testInsertPutv", lom.getValue(2));         assertEquals("testInsert3v", lom.getValue(3));          // put in a full map         resetFull();         lom = getMap();         final ListOrderedMap<K, V> lom2 = new ListOrderedMap<>();         lom2.putAll(lom);          lom2.put(0, (K) "testInsert0", (V) "testInsert0v");         assertEquals("testInsert0v", lom2.getValue(0));         for (int i = 0; i < lom.size(); i++) {             assertEquals(lom2.getValue(i + 1), lom.getValue(i));         }          // put where key does exist         final Integer i1 = Integer.valueOf(1);         final Integer i1b = Integer.valueOf(1);         final Integer i2 = Integer.valueOf(2);         final Integer i3 = Integer.valueOf(3);          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(0, (K) i1, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("One", lom.getValue(0));         assertSame(i1, lom.get(0));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(0, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("One", lom.getValue(0));         assertEquals("2", lom.getValue(1));         assertEquals("3", lom.getValue(2));         assertSame(i1b, lom.get(0));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(1, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("One", lom.getValue(0));         assertEquals("2", lom.getValue(1));         assertEquals("3", lom.getValue(2));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(2, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("2", lom.getValue(0));         assertEquals("One", lom.getValue(1));         assertEquals("3", lom.getValue(2));          resetEmpty();         lom = getMap();         lom.put((K) i1, (V) "1");         lom.put((K) i2, (V) "2");         lom.put((K) i3, (V) "3");         lom.put(3, (K) i1b, (V) "One");         assertEquals(3, lom.size());         assertEquals(3, lom.map.size());         assertEquals(3, lom.keyList().size());         assertEquals("2", lom.getValue(0));         assertEquals("3", lom.getValue(1));         assertEquals("One", lom.getValue(2));     }      public void testPutAllWithIndex() {         resetEmpty();         @SuppressWarnings("unchecked")         final ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;          // Create Initial Data         lom.put("testInsert0", "testInsert0v");         lom.put("testInsert1", "testInsert1v");         lom.put("testInsert2", "testInsert2v");         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("testInsert1v", lom.getValue(1));         assertEquals("testInsert2v", lom.getValue(2));          // Create New Test Map and Add using putAll(int, Object, Object)         final Map<String, String> values = new ListOrderedMap<>();         values.put("NewInsert0", "NewInsert0v");         values.put("NewInsert1", "NewInsert1v");         lom.putAll(1, values);          // Perform Asserts         assertEquals("testInsert0v", lom.getValue(0));         assertEquals("NewInsert0v", lom.getValue(1));         assertEquals("NewInsert1v", lom.getValue(2));         assertEquals("testInsert1v", lom.getValue(3));         assertEquals("testInsert2v", lom.getValue(4));     }      @SuppressWarnings("unchecked")     public void testPutAllWithIndexBug441() {         // see COLLECTIONS-441         resetEmpty();         final ListOrderedMap<K, V> lom = getMap();          final int size = 5;         for (int i = 0; i < size; i++) {             lom.put((K) Integer.valueOf(i), (V) Boolean.TRUE);         }          final Map<K, V> map = new TreeMap<>();         for (int i = 0; i < size; i++) {             map.put((K) Integer.valueOf(i), (V) Boolean.FALSE);         }          lom.putAll(3, map);          final List<K> orderedList = lom.asList();         for (int i = 0; i < size; i++) {             assertEquals(Integer.valueOf(i), orderedList.get(i));         }     }      //-----------------------------------------------------------------------     public void testValueList_getByIndex() {         resetFull();         final ListOrderedMap<K, V> lom = getMap();         for (int i = 0; i < lom.size(); i++) {             final V expected = lom.getValue(i);             assertEquals(expected, lom.valueList().get(i));         }     }      @SuppressWarnings("unchecked")     public void testValueList_setByIndex() {         resetFull();         final ListOrderedMap<K, V> lom = getMap();         for (int i = 0; i < lom.size(); i++) {             final Object input = Integer.valueOf(i);             final V expected = lom.getValue(i);             assertEquals(expected, lom.valueList().set(i, (V) input));             assertEquals(input, lom.getValue(i));             assertEquals(input, lom.valueList().get(i));         }     }      public void testValueList_removeByIndex() {         resetFull();         final ListOrderedMap<K, V> lom = getMap();         while (lom.size() > 1) {             final V expected = lom.getValue(1);             assertEquals(expected, lom.valueList().remove(1));         }     }      public void testCOLLECTIONS_474_nullValues () {         final Object key1 = new Object();         final Object key2 = new Object();         final HashMap<Object, Object> hmap = new HashMap<>();         hmap.put(key1, null);         hmap.put(key2, null);         assertEquals("Should have two elements", 2, hmap.size());         final ListOrderedMap<Object, Object> listMap = new ListOrderedMap<>();         listMap.put(key1, null);         listMap.put(key2, null);         assertEquals("Should have two elements", 2, listMap.size());         listMap.putAll(2, hmap);     }      public void testCOLLECTIONS_474_nonNullValues () {         final Object key1 = new Object();         final Object key2 = new Object();         final HashMap<Object, Object> hmap = new HashMap<>();         hmap.put(key1, "1");         hmap.put(key2, "2");         assertEquals("Should have two elements", 2, hmap.size());         final ListOrderedMap<Object, Object> listMap = new ListOrderedMap<>();         listMap.put(key1, "3");         listMap.put(key2, "4");         assertEquals("Should have two elements", 2, listMap.size());         listMap.putAll(2, hmap);     }      //-----------------------------------------------------------------------     public BulkTest bulkTestKeyListView() {         return new TestKeyListView();     }      public BulkTest bulkTestValueListView() {         return new TestValueListView();     }      //-----------------------------------------------------------------------     public class TestKeyListView extends AbstractListTest<K> {         TestKeyListView() {             super("TestKeyListView");         }          @Override         public List<K> makeObject() {             return ListOrderedMapTest.this.makeObject().keyList();         }         @Override         public List<K> makeFullCollection() {             return ListOrderedMapTest.this.makeFullMap().keyList();         }          @Override         public K[] getFullElements() {             return ListOrderedMapTest.this.getSampleKeys();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return false;         }         @Override         public boolean isSetSupported() {             return false;         }         @Override         public boolean isNullSupported() {             return ListOrderedMapTest.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      //-----------------------------------------------------------------------     public class TestValueListView extends AbstractListTest<V> {         TestValueListView() {             super("TestValueListView");         }          @Override         public List<V> makeObject() {             return ListOrderedMapTest.this.makeObject().valueList();         }         @Override         public List<V> makeFullCollection() {             return ListOrderedMapTest.this.makeFullMap().valueList();         }          @Override         public V[] getFullElements() {             return ListOrderedMapTest.this.getSampleValues();         }         @Override         public boolean isAddSupported() {             return false;         }         @Override         public boolean isRemoveSupported() {             return true;         }         @Override         public boolean isSetSupported() {             return true;         }         @Override         public boolean isNullSupported() {             return ListOrderedMapTest.this.isAllowNullKey();         }         @Override         public boolean isTestSerialization() {             return false;         }     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ListOrderedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ListOrderedMap.fullCollection.version4.obj"); //    }      /**      * {@inheritDoc}      */     @Override     public ListOrderedMap<K, V> getMap() {         return (ListOrderedMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map; import java.util.HashMap; import java.util.Collection;  /**  * Extension of {@link AbstractMapTest} for exercising the  * {@link CompositeMap} implementation.  *  * @since 3.0  */ public class CompositeMapTest<K, V> extends AbstractIterableMapTest<K, V> {     /** used as a flag in MapMutator tests */     private boolean pass = false;      public CompositeMapTest(final String testName) {         super(testName);     }      @Override     public void setUp() throws Exception {         super.setUp();         this.pass = false;     }      @Override     public CompositeMap<K, V> makeObject() {         final CompositeMap<K, V> map = new CompositeMap<>();         map.addComposited(new HashMap<K, V>());         map.setMutator( new EmptyMapMutator<K, V>() );         return map;     }      @SuppressWarnings("unchecked")     private Map<K, V> buildOne() {         final HashMap<K, V> map = new HashMap<>();         map.put((K) "1", (V) "one");         map.put((K) "2", (V) "two");         return map;     }      @SuppressWarnings("unchecked")     public Map<K, V> buildTwo() {         final HashMap<K, V> map = new HashMap<>();         map.put((K) "3", (V) "three");         map.put((K) "4", (V) "four");         return map;     }      public void testGet() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         assertEquals("one", map.get("1"));         assertEquals("four", map.get("4"));     }      @SuppressWarnings("unchecked")     public void testAddComposited() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));         try {             map.addComposited(three);             fail("Expecting IllegalArgumentException.");         } catch (final IllegalArgumentException ex) {             // expected         }     }      @SuppressWarnings("unchecked")     public void testRemoveComposited() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));          map.removeComposited(three);         assertFalse(map.containsKey("5"));          map.removeComposited(buildOne());         assertFalse(map.containsKey("2"));      }      @SuppressWarnings("unchecked")     public void testRemoveFromUnderlying() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));          //Now remove "5"         three.remove("5");         assertFalse(map.containsKey("5"));     }      @SuppressWarnings("unchecked")     public void testRemoveFromComposited() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());         final HashMap<K, V> three = new HashMap<>();         three.put((K) "5", (V) "five");         map.addComposited(null);         map.addComposited(three);         assertTrue(map.containsKey("5"));          //Now remove "5"         map.remove("5");         assertFalse(three.containsKey("5"));     }      public void testResolveCollision() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),             new CompositeMap.MapMutator<K, V>() {                 private static final long serialVersionUID = 1L;                  @Override                 public void resolveCollision(final CompositeMap<K, V> composite,                     final Map<K, V> existing,                     final Map<K, V> added,                     final Collection<K> intersect) {                     pass = true;                 }                  @Override                 public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,                     final V value) {                     throw new UnsupportedOperationException();                 }                  @Override                 public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {                     throw new UnsupportedOperationException();                 }             });          map.addComposited(buildOne());         assertTrue(pass);     }      @SuppressWarnings("unchecked")     public void testPut() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),             new CompositeMap.MapMutator<K, V>() {                 private static final long serialVersionUID = 1L;                 @Override                 public void resolveCollision(final CompositeMap<K, V> composite,                     final Map<K, V> existing,                     final Map<K, V> added,                     final Collection<K> intersect) {                     throw new UnsupportedOperationException();                 }                  @Override                 public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,                     final V value) {                     pass = true;                     return (V) "foo";                 }                  @Override                 public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {                     throw new UnsupportedOperationException();                 }             });          map.put((K) "willy", (V) "wonka");         assertTrue(pass);     }      public void testPutAll() {         final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),             new CompositeMap.MapMutator<K, V>() {                 private static final long serialVersionUID = 1L;                 @Override                 public void resolveCollision(final CompositeMap<K, V> composite,                     final Map<K, V> existing,                     final Map<K, V> added,                     final Collection<K> intersect) {                     throw new UnsupportedOperationException();                 }                  @Override                 public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,                     final V value) {                     throw new UnsupportedOperationException();                 }                  @Override                 public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {                     pass = true;                 }             });          map.putAll(null);         assertTrue(pass);     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CompositeMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/CompositeMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.Serializable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set;  import org.apache.commons.collections4.AbstractObjectTest; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.collections4.collection.AbstractCollectionTest; import org.apache.commons.collections4.keyvalue.DefaultMapEntry; import org.apache.commons.collections4.set.AbstractSetTest;  /**  * Abstract test class for {@link java.util.Map} methods and contracts.  * <p>  * The forces at work here are similar to those in {@link AbstractCollectionTest}.  * If your class implements the full Map interface, including optional  * operations, simply extend this class, and implement the  * {@link #makeObject()} method.  * <p>  * On the other hand, if your map implementation is weird, you may have to  * override one or more of the other protected methods.  They're described  * below.  * <p>  * <b>Entry Population Methods</b>  * <p>  * Override these methods if your map requires special entries:  *  * <ul>  * <li>{@link #getSampleKeys()}  * <li>{@link #getSampleValues()}  * <li>{@link #getNewSampleValues()}  * <li>{@link #getOtherKeys()}  * <li>{@link #getOtherValues()}  * </ul>  *  * <b>Supported Operation Methods</b>  * <p>  * Override these methods if your map doesn't support certain operations:  *  * <ul>  * <li> {@link #isPutAddSupported()}  * <li> {@link #isPutChangeSupported()}  * <li> {@link #isSetValueSupported()}  * <li> {@link #isRemoveSupported()}  * <li> {@link #isGetStructuralModify()}  * <li> {@link #isAllowDuplicateValues()}  * <li> {@link #isAllowNullKey()}  * <li> {@link #isAllowNullValue()}  * </ul>  *  * <b>Fixture Methods</b>  * <p>  * For tests on modification operations (puts and removes), fixtures are used  * to verify that that operation results in correct state for the map and its  * collection views.  Basically, the modification is performed against your  * map implementation, and an identical modification is performed against  * a <I>confirmed</I> map implementation.  A confirmed map implementation is  * something like <Code>java.util.HashMap</Code>, which is known to conform  * exactly to the {@link Map} contract.  After the modification takes place  * on both your map implementation and the confirmed map implementation, the  * two maps are compared to see if their state is identical.  The comparison  * also compares the collection views to make sure they're still the same.<P>  *  * The upshot of all that is that <I>any</I> test that modifies the map in  * <I>any</I> way will verify that <I>all</I> of the map's state is still  * correct, including the state of its collection views.  So for instance  * if a key is removed by the map's key set's iterator, then the entry set  * is checked to make sure the key/value pair no longer appears.<P>  *  * The {@link #map} field holds an instance of your collection implementation.  * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold  * that map's collection views.  And the {@link #confirmed} field holds  * an instance of the confirmed collection implementation.  The  * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to  * empty or full maps, so that tests can proceed from a known state.<P>  *  * After a modification operation to both {@link #map} and {@link #confirmed},  * the {@link #verify()} method is invoked to compare the results.  The  * {@link #verify} method calls separate methods to verify the map and its three  * collection views ({@link #verifyMap}, {@link #verifyEntrySet},  * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override  * one of the verification methods to perform additional verifications.  For  * instance, TestDoubleOrderedMap would want override its  * {@link #verifyValues()} method to verify that the values are unique and in  * ascending order.<P>  *  * <b>Other Notes</b>  * <p>  * If your {@link Map} fails one of these tests by design, you may still use  * this base set of cases.  Simply override the test case (method) your map  * fails and/or the methods that define the assumptions used by the test  * cases.  For example, if your map does not allow duplicate values, override  * {@link #isAllowDuplicateValues()} and have it return {@code false}  *  */ public abstract class AbstractMapTest<K, V> extends AbstractObjectTest {      /**      * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString      * This avoids nulls for JDK1.2      */     private static final boolean JDK12;     static {         final String str = System.getProperty("java.version");         JDK12 = str.startsWith("1.2");     }      // These instance variables are initialized with the reset method.     // Tests for map methods that alter the map (put, putAll, remove)     // first call reset() to create the map and its views; then perform     // the modification on the map; perform the same modification on the     // confirmed; and then call verify() to ensure that the map is equal     // to the confirmed, that the already-constructed collection views     // are still equal to the confirmed's collection views.      /** Map created by reset(). */     protected Map<K, V> map;      /** Entry set of map created by reset(). */     protected Set<Map.Entry<K, V>> entrySet;      /** Key set of map created by reset(). */     protected Set<K> keySet;      /** Values collection of map created by reset(). */     protected Collection<V> values;      /** HashMap created by reset(). */     protected Map<K, V> confirmed;      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractMapTest(final String testName) {         super(testName);     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code put} and {@code putAll} operations      * adding new mappings.      * <p>      * Default implementation returns true.      * Override if your collection class does not support put adding.      */     public boolean isPutAddSupported() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code put} and {@code putAll} operations      * changing existing mappings.      * <p>      * Default implementation returns true.      * Override if your collection class does not support put changing.      */     public boolean isPutChangeSupported() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code setValue} operation on entrySet entries.      * <p>      * Default implementation returns isPutChangeSupported().      * Override if your collection class does not support setValue but does      * support put changing.      */     public boolean isSetValueSupported() {         return isPutChangeSupported();     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * support the {@code remove} and {@code clear} operations.      * <p>      * Default implementation returns true.      * Override if your collection class does not support removal operations.      */     public boolean isRemoveSupported() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * can cause structural modification on a get(). The example is LRUMap.      * <p>      * Default implementation returns false.      * Override if your map class structurally modifies on get.      */     public boolean isGetStructuralModify() {         return false;     }      /**      * Returns whether the sub map views of SortedMap are serializable.      * If the class being tested is based around a TreeMap then you should      * override and return false as TreeMap has a bug in deserialization.      *      * @return false      */     public boolean isSubMapViewsSerializable() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * supports null keys.      * <p>      * Default implementation returns true.      * Override if your collection class does not support null keys.      */     public boolean isAllowNullKey() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * supports null values.      * <p>      * Default implementation returns true.      * Override if your collection class does not support null values.      */     public boolean isAllowNullValue() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * supports duplicate values.      * <p>      * Default implementation returns true.      * Override if your collection class does not support duplicate values.      */     public boolean isAllowDuplicateValues() {         return true;     }      /**      * Returns true if the maps produced by      * {@link #makeObject()} and {@link #makeFullMap()}      * provide fail-fast behavior on their various iterators.      * <p>      * Default implementation returns true.      * Override if your collection class does not support fast failure.      */     public boolean isFailFastExpected() {         return true;     }      public boolean areEqualElementsDistinguishable() {         return false;     }      /**      *  Returns the set of keys in the mappings used to test the map.  This      *  method must return an array with the same length as {@link      *  #getSampleValues()} and all array elements must be different. The      *  default implementation constructs a set of String keys, and includes a      *  single null key if {@link #isAllowNullKey()} returns {@code true}.      */     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         final Object[] result = new Object[] {             "blah", "foo", "bar", "baz", "tmp", "gosh", "golly", "gee",             "hello", "goodbye", "we'll", "see", "you", "all", "again",             "key",             "key2",             isAllowNullKey() && !JDK12 ? null : "nonnullkey"         };         return (K[]) result;     }      @SuppressWarnings("unchecked")     public K[] getOtherKeys() {         return (K[]) getOtherNonNullStringElements();     }      @SuppressWarnings("unchecked")     public V[] getOtherValues() {         return (V[]) getOtherNonNullStringElements();     }      @SuppressWarnings("unchecked")     protected <E> List<E> getAsList(final Object[] o) {         final ArrayList<E> result = new ArrayList<>();         for (final Object element : o) {             result.add((E) element);         }         return result;     }      /**      * Returns a list of string elements suitable for return by      * {@link #getOtherKeys()} or {@link #getOtherValues}.      *      * <p>Override getOtherElements to return the results of this method if your      * collection does not support heterogenous elements or the null element.      * </p>      */     public Object[] getOtherNonNullStringElements() {         return new Object[] {             "For", "then", "despite", /* of */"space", "I", "would", "be", "brought",             "From", "limits", "far", "remote", "where", "thou", "dost", "stay"         };     }      /**      * Returns the set of values in the mappings used to test the map.  This      * method must return an array with the same length as      * {@link #getSampleKeys()}.  The default implementation constructs a set of      * String values and includes a single null value if      * {@link #isAllowNullValue()} returns {@code true}, and includes      * two values that are the same if {@link #isAllowDuplicateValues()} returns      * {@code true}.      */     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         final Object[] result = new Object[] {             "blahv", "foov", "barv", "bazv", "tmpv", "goshv", "gollyv", "geev",             "hellov", "goodbyev", "we'llv", "seev", "youv", "allv", "againv",             isAllowNullValue() && !JDK12 ? null : "nonnullvalue",             "value",             isAllowDuplicateValues() ? "value" : "value2",         };         return (V[]) result;     }      /**      * Returns a the set of values that can be used to replace the values      * returned from {@link #getSampleValues()}.  This method must return an      * array with the same length as {@link #getSampleValues()}.  The values      * returned from this method should not be the same as those returned from      * {@link #getSampleValues()}.  The default implementation constructs a      * set of String values and includes a single null value if      * {@link #isAllowNullValue()} returns {@code true}, and includes two values      * that are the same if {@link #isAllowDuplicateValues()} returns      * {@code true}.      */     @SuppressWarnings("unchecked")     public V[] getNewSampleValues() {         final Object[] result = new Object[] {             isAllowNullValue() && !JDK12 && isAllowDuplicateValues() ? null : "newnonnullvalue",             "newvalue",             isAllowDuplicateValues() ? "newvalue" : "newvalue2",             "newblahv", "newfoov", "newbarv", "newbazv", "newtmpv", "newgoshv",             "newgollyv", "newgeev", "newhellov", "newgoodbyev", "newwe'llv",             "newseev", "newyouv", "newallv", "newagainv",         };         return (V[]) result;     }      /**      *  Helper method to add all the mappings described by      * {@link #getSampleKeys()} and {@link #getSampleValues()}.      */     public void addSampleMappings(final Map<? super K, ? super V> m) {          final K[] keys = getSampleKeys();         final V[] values = getSampleValues();          for (int i = 0; i < keys.length; i++) {             try {                 m.put(keys[i], values[i]);             } catch (final NullPointerException exception) {                 assertTrue("NullPointerException only allowed to be thrown " +                            "if either the key or value is null.",                            keys[i] == null || values[i] == null);                  assertTrue("NullPointerException on null key, but " +                            "isAllowNullKey is not overridden to return false.",                            keys[i] == null || !isAllowNullKey());                  assertTrue("NullPointerException on null value, but " +                            "isAllowNullValue is not overridden to return false.",                            values[i] == null || !isAllowNullValue());                  assertTrue("Unknown reason for NullPointer.", false);             }         }         assertEquals("size must reflect number of mappings added.",                      keys.length, m.size());     }      //-----------------------------------------------------------------------     /**      * Return a new, empty {@link Map} to be used for testing.      *      * @return the map to be tested      */     @Override     public abstract Map<K, V> makeObject();      /**      * Return a new, populated map.  The mappings in the map should match the      * keys and values returned from {@link #getSampleKeys()} and      * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()      * and calls {@link #addSampleMappings} to add all the mappings to the      * map.      *      * @return the map to be tested      */     public Map<K, V> makeFullMap() {         final Map<K, V> m = makeObject();         addSampleMappings(m);         return m;     }      /**      * Override to return a map other than HashMap as the confirmed map.      *      * @return a map that is known to be valid      */     public Map<K, V> makeConfirmedMap() {         return new HashMap<>();     }      /**      * Creates a new Map Entry that is independent of the first and the map.      */     public static <K, V> Map.Entry<K, V> cloneMapEntry(final Map.Entry<K, V> entry) {         final HashMap<K, V> map = new HashMap<>();         map.put(entry.getKey(), entry.getValue());         return map.entrySet().iterator().next();     }      /**      * Gets the compatibility version, needed for package access.      */     @Override     public String getCompatibilityVersion() {         return super.getCompatibilityVersion();     }      //-----------------------------------------------------------------------     /**      * Test to ensure the test setup is working properly.  This method checks      * to ensure that the getSampleKeys and getSampleValues methods are      * returning results that look appropriate.  That is, they both return a      * non-null array of equal length.  The keys array must not have any      * duplicate values, and may only contain a (single) null key if      * isNullKeySupported() returns true.  The values array must only have a null      * value if useNullValue() is true and may only have duplicate values if      * isAllowDuplicateValues() returns true.      */     public void testSampleMappings() {         final Object[] keys = getSampleKeys();         final Object[] values = getSampleValues();         final Object[] newValues = getNewSampleValues();          assertNotNull("failure in test: Must have keys returned from " +                  "getSampleKeys.", keys);          assertNotNull("failure in test: Must have values returned from " +                  "getSampleValues.", values);          // verify keys and values have equivalent lengths (in case getSampleX are         // overridden)         assertEquals("failure in test: not the same number of sample " +                    "keys and values.",  keys.length, values.length);          assertEquals("failure in test: not the same number of values and new values.",                    values.length, newValues.length);          // verify there aren't duplicate keys, and check values         for (int i = 0; i < keys.length - 1; i++) {             for (int j = i + 1; j < keys.length; j++) {                 assertTrue("failure in test: duplicate null keys.",                         keys[i] != null || keys[j] != null);                 assertTrue(                         "failure in test: duplicate non-null key.",                         keys[i] == null || keys[j] == null || !keys[i].equals(keys[j]) && !keys[j]                                 .equals(keys[i]));             }             assertTrue("failure in test: found null key, but isNullKeySupported " + "is false.",                     keys[i] != null || isAllowNullKey());             assertTrue(                     "failure in test: found null value, but isNullValueSupported " + "is false.",                     values[i] != null || isAllowNullValue());             assertTrue("failure in test: found null new value, but isNullValueSupported "                     + "is false.", newValues[i] != null || isAllowNullValue());             assertTrue("failure in test: values should not be the same as new value",                     values[i] != newValues[i]                             && (values[i] == null || !values[i].equals(newValues[i])));         }     }      // tests begin here.  Each test adds a little bit of tested functionality.     // Many methods assume previous methods passed.  That is, they do not     // exhaustively recheck things that have already been checked in a previous     // test methods.      /**      * Test to ensure that makeEmptyMap and makeFull returns a new non-null      * map with each invocation.      */     public void testMakeMap() {         final Map<K, V> em = makeObject();         assertTrue("failure in test: makeEmptyMap must return a non-null map.",                    em != null);          final Map<K, V> em2 = makeObject();         assertTrue("failure in test: makeEmptyMap must return a non-null map.",                    em != null);          assertTrue("failure in test: makeEmptyMap must return a new map " +                    "with each invocation.", em != em2);          final Map<K, V> fm = makeFullMap();         assertTrue("failure in test: makeFullMap must return a non-null map.",                    fm != null);          final Map<K, V> fm2 = makeFullMap();         assertTrue("failure in test: makeFullMap must return a non-null map.",                    fm != null);          assertTrue("failure in test: makeFullMap must return a new map " +                    "with each invocation.", fm != fm2);     }      /**      * Tests Map.isEmpty()      */     public void testMapIsEmpty() {         resetEmpty();         assertEquals("Map.isEmpty() should return true with an empty map",                      true, getMap().isEmpty());         verify();          resetFull();         assertEquals("Map.isEmpty() should return false with a non-empty map",                      false, getMap().isEmpty());         verify();     }      /**      * Tests Map.size()      */     public void testMapSize() {         resetEmpty();         assertEquals("Map.size() should be 0 with an empty map",                      0, getMap().size());         verify();          resetFull();         assertEquals("Map.size() should equal the number of entries " +                      "in the map", getSampleKeys().length, getMap().size());         verify();     }      /**      * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}      * can add and remove elements}, then {@link Map#size()} and      * {@link Map#isEmpty()} are used to ensure that map has no elements after      * a call to clear.  If the map does not support adding and removing      * elements, this method checks to ensure clear throws an      * UnsupportedOperationException.      */     public void testMapClear() {         if (!isRemoveSupported()) {             try {                 resetFull();                 getMap().clear();                 fail("Expected UnsupportedOperationException on clear");             } catch (final UnsupportedOperationException ex) {}             return;         }          resetEmpty();         getMap().clear();         getConfirmed().clear();         verify();          resetFull();         getMap().clear();         getConfirmed().clear();         verify();     }      /**      * Tests Map.containsKey(Object) by verifying it returns false for all      * sample keys on a map created using an empty map and returns true for      * all sample keys returned on a full map.      */     public void testMapContainsKey() {         final Object[] keys = getSampleKeys();          resetEmpty();         for (final Object key : keys) {             assertTrue("Map must not contain key when map is empty",                     !getMap().containsKey(key));         }         verify();          resetFull();         for (final Object key : keys) {             assertTrue("Map must contain key for a mapping in the map. " +                        "Missing: " + key, getMap().containsKey(key));         }         verify();     }      /**      * Tests Map.containsValue(Object) by verifying it returns false for all      * sample values on an empty map and returns true for all sample values on      * a full map.      */     public void testMapContainsValue() {         final Object[] values = getSampleValues();          resetEmpty();         for (final Object value : values) {             assertTrue("Empty map must not contain value",                        !getMap().containsValue(value));         }         verify();          resetFull();         for (final Object value : values) {             assertTrue("Map must contain value for a mapping in the map.",                     getMap().containsValue(value));         }         verify();     }       /**      * Tests Map.equals(Object)      */     public void testMapEquals() {         resetEmpty();         assertTrue("Empty maps unequal.", getMap().equals(confirmed));         verify();          resetFull();         assertTrue("Full maps unequal.", getMap().equals(confirmed));         verify();          resetFull();         // modify the HashMap created from the full map and make sure this         // change results in map.equals() to return false.         final Iterator<K> iter = confirmed.keySet().iterator();         iter.next();         iter.remove();         assertTrue("Different maps equal.", !getMap().equals(confirmed));          resetFull();         assertTrue("equals(null) returned true.", !getMap().equals(null));         assertTrue("equals(new Object()) returned true.",                    !getMap().equals(new Object()));         verify();     }      /**      * Tests Map.get(Object)      */     public void testMapGet() {         resetEmpty();          final Object[] keys = getSampleKeys();         final Object[] values = getSampleValues();          for (final Object key : keys) {             assertTrue("Empty map.get() should return null.",                     getMap().get(key) == null);         }         verify();          resetFull();         for (int i = 0; i < keys.length; i++) {             assertEquals("Full map.get() should return value from mapping.",                          values[i], getMap().get(keys[i]));         }     }      /**      * Tests Map.hashCode()      */     public void testMapHashCode() {         resetEmpty();         assertTrue("Empty maps have different hashCodes.",                 getMap().hashCode() == confirmed.hashCode());          resetFull();         assertTrue("Equal maps have different hashCodes.",                 getMap().hashCode() == confirmed.hashCode());     }      /**      * Tests Map.toString().  Since the format of the string returned by the      * toString() method is not defined in the Map interface, there is no      * common way to test the results of the toString() method.  Therefore,      * it is encouraged that Map implementations override this test with one      * that checks the format matches any format defined in its API.  This      * default implementation just verifies that the toString() method does      * not return null.      */     public void testMapToString() {         resetEmpty();         assertTrue("Empty map toString() should not return null",                 getMap().toString() != null);         verify();          resetFull();         assertTrue("Empty map toString() should not return null",                 getMap().toString() != null);         verify();     }      /**      * Compare the current serialized form of the Map      * against the canonical version in SCM.      */     public void testEmptyMapCompatibility() throws Exception {         /*          * Create canonical objects with this code         Map map = makeEmptyMap();         if (!(map instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));         */          // test to make sure the canonical form has been preserved         final Map<K, V> map = makeObject();         if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             @SuppressWarnings("unchecked")             final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));             assertEquals("Map is empty", 0, map2.size());         }     }      /**      * Compare the current serialized form of the Map      * against the canonical version in SCM.      */     public void testFullMapCompatibility() throws Exception {         /*          * Create canonical objects with this code         Map map = makeFullMap();         if (!(map instanceof Serializable)) return;          writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));         */          // test to make sure the canonical form has been preserved         final Map<K, V> map = makeFullMap();         if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {             @SuppressWarnings("unchecked")             final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));             assertEquals("Map is the right size", getSampleKeys().length, map2.size());         }     }      /**      * Tests Map.put(Object, Object)      */     public void testMapPut() {         resetEmpty();         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         final V[] newValues = getNewSampleValues();          if (isPutAddSupported()) {             for (int i = 0; i < keys.length; i++) {                 final Object o = getMap().put(keys[i], values[i]);                 getConfirmed().put(keys[i], values[i]);                 verify();                 assertTrue("First map.put should return null", o == null);                 assertTrue("Map should contain key after put",                         getMap().containsKey(keys[i]));                 assertTrue("Map should contain value after put",                         getMap().containsValue(values[i]));             }             if (isPutChangeSupported()) {                 for (int i = 0; i < keys.length; i++) {                     final Object o = getMap().put(keys[i], newValues[i]);                     getConfirmed().put(keys[i], newValues[i]);                     verify();                     assertEquals("Map.put should return previous value when changed", values[i], o);                     assertTrue("Map should still contain key after put when changed",                             getMap().containsKey(keys[i]));                     assertTrue("Map should contain new value after put when changed",                             getMap().containsValue(newValues[i]));                      // if duplicates are allowed, we're not guaranteed that the value                     // no longer exists, so don't try checking that.                     if (!isAllowDuplicateValues()) {                         assertTrue("Map should not contain old value after put when changed",                                 !getMap().containsValue(values[i]));                     }                 }             } else {                 try {                     // two possible exception here, either valid                     getMap().put(keys[0], newValues[0]);                     fail("Expected IllegalArgumentException or UnsupportedOperationException on put (change)");                 } catch (final IllegalArgumentException ex) {                 } catch (final UnsupportedOperationException ex) {}             }          } else if (isPutChangeSupported()) {             resetEmpty();             try {                 getMap().put(keys[0], values[0]);                 fail("Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size");             } catch (final IllegalArgumentException ex) {             } catch (final UnsupportedOperationException ex) {             }              resetFull();             int i = 0;             for (final Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {                 final K  key = it.next();                 final V o = getMap().put(key, newValues[i]);                 final V value = getConfirmed().put(key, newValues[i]);                 verify();                 assertEquals("Map.put should return previous value when changed", value, o);                 assertTrue("Map should still contain key after put when changed", getMap()                         .containsKey(key));                 assertTrue("Map should contain new value after put when changed", getMap()                         .containsValue(newValues[i]));                  // if duplicates are allowed, we're not guaranteed that the value                 // no longer exists, so don't try checking that.                 if (!isAllowDuplicateValues()) {                     assertTrue("Map should not contain old value after put when changed",                         !getMap().containsValue(values[i]));                 }             }         } else {             try {                 getMap().put(keys[0], values[0]);                 fail("Expected UnsupportedOperationException on put (add)");             } catch (final UnsupportedOperationException ex) {}         }     }      /**      * Tests Map.put(null, value)      */     public void testMapPutNullKey() {         resetFull();         final V[] values = getSampleValues();          if (isPutAddSupported()) {             if (isAllowNullKey()) {                 getMap().put(null, values[0]);             } else {                 try {                     getMap().put(null, values[0]);                     fail("put(null, value) should throw NPE/IAE");                 } catch (final NullPointerException ex) {                 } catch (final IllegalArgumentException ex) {}             }         }     }      /**      * Tests Map.put(null, value)      */     public void testMapPutNullValue() {         resetFull();         final K[] keys = getSampleKeys();          if (isPutAddSupported()) {             if (isAllowNullValue()) {                 getMap().put(keys[0], null);             } else {                 try {                     getMap().put(keys[0], null);                     fail("put(key, null) should throw NPE/IAE");                 } catch (final NullPointerException ex) {                 } catch (final IllegalArgumentException ex) {}             }         }     }      /**      * Tests Map.putAll(map)      */     public void testMapPutAll() {         if (!isPutAddSupported()) {             if (!isPutChangeSupported()) {                 final Map<K, V> temp = makeFullMap();                 resetEmpty();                 try {                     getMap().putAll(temp);                     fail("Expected UnsupportedOperationException on putAll");                 } catch (final UnsupportedOperationException ex) {}             }             return;         }          // check putAll OK adding empty map to empty map         resetEmpty();         assertEquals(0, getMap().size());         getMap().putAll(new HashMap<K, V>());         assertEquals(0, getMap().size());          // check putAll OK adding empty map to non-empty map         resetFull();         final int size = getMap().size();         getMap().putAll(new HashMap<K, V>());         assertEquals(size, getMap().size());          // check putAll OK adding non-empty map to empty map         resetEmpty();         Map<K, V> m2 = makeFullMap();         getMap().putAll(m2);         getConfirmed().putAll(m2);         verify();          // check putAll OK adding non-empty JDK map to empty map         resetEmpty();         m2 = makeConfirmedMap();         final K[] keys = getSampleKeys();         final V[] values = getSampleValues();         for (int i = 0; i < keys.length; i++) {             m2.put(keys[i], values[i]);         }         getMap().putAll(m2);         getConfirmed().putAll(m2);         verify();          // check putAll OK adding non-empty JDK map to non-empty map         resetEmpty();         m2 = makeConfirmedMap();         getMap().put(keys[0], values[0]);         getConfirmed().put(keys[0], values[0]);         verify();         for (int i = 1; i < keys.length; i++) {             m2.put(keys[i], values[i]);         }         getMap().putAll(m2);         getConfirmed().putAll(m2);         verify();     }      /**      * Tests Map.remove(Object)      */     public void testMapRemove() {         if (!isRemoveSupported()) {             try {                 resetFull();                 getMap().remove(getMap().keySet().iterator().next());                 fail("Expected UnsupportedOperationException on remove");             } catch (final UnsupportedOperationException ex) {}             return;         }          resetEmpty();          final Object[] keys = getSampleKeys();         final Object[] values = getSampleValues();         for (final Object key : keys) {             final Object o = getMap().remove(key);             assertTrue("First map.remove should return null", o == null);         }         verify();          resetFull();          for (int i = 0; i < keys.length; i++) {             final Object o = getMap().remove(keys[i]);             getConfirmed().remove(keys[i]);             verify();              assertEquals("map.remove with valid key should return value",                          values[i], o);         }          final Object[] other = getOtherKeys();          resetFull();         final int size = getMap().size();         for (final Object element : other) {             final Object o = getMap().remove(element);             assertNull("map.remove for nonexistent key should return null", o);             assertEquals("map.remove for nonexistent key should not " +                          "shrink map", size, getMap().size());         }         verify();     }      //-----------------------------------------------------------------------     /**      * Tests that the {@link Map#values} collection is backed by      * the underlying map for clear().      */     public void testValuesClearChangesMap() {         if (!isRemoveSupported()) {             return;         }          // clear values, reflected in map         resetFull();         Collection<V> values = getMap().values();         assertTrue(getMap().size() > 0);         assertTrue(values.size() > 0);         values.clear();         assertTrue(getMap().size() == 0);         assertTrue(values.size() == 0);          // clear map, reflected in values         resetFull();         values = getMap().values();         assertTrue(getMap().size() > 0);         assertTrue(values.size() > 0);         getMap().clear();         assertTrue(getMap().size() == 0);         assertTrue(values.size() == 0);     }      /**      * Tests that the {@link Map#keySet} collection is backed by      * the underlying map for clear().      */     public void testKeySetClearChangesMap() {         if (!isRemoveSupported()) {             return;         }          // clear values, reflected in map         resetFull();         Set<K> keySet = getMap().keySet();         assertTrue(getMap().size() > 0);         assertTrue(keySet.size() > 0);         keySet.clear();         assertTrue(getMap().size() == 0);         assertTrue(keySet.size() == 0);          // clear map, reflected in values         resetFull();         keySet = getMap().keySet();         assertTrue(getMap().size() > 0);         assertTrue(keySet.size() > 0);         getMap().clear();         assertTrue(getMap().size() == 0);         assertTrue(keySet.size() == 0);     }      /**      * Tests that the {@link Map#entrySet()} collection is backed by      * the underlying map for clear().      */     public void testEntrySetClearChangesMap() {         if (!isRemoveSupported()) {             return;         }          // clear values, reflected in map         resetFull();         Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         assertTrue(getMap().size() > 0);         assertTrue(entrySet.size() > 0);         entrySet.clear();         assertTrue(getMap().size() == 0);         assertTrue(entrySet.size() == 0);          // clear map, reflected in values         resetFull();         entrySet = getMap().entrySet();         assertTrue(getMap().size() > 0);         assertTrue(entrySet.size() > 0);         getMap().clear();         assertTrue(getMap().size() == 0);         assertTrue(entrySet.size() == 0);     }      //-----------------------------------------------------------------------     public void testEntrySetContains1() {         resetFull();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         assertEquals(true, entrySet.contains(entry));     }      public void testEntrySetContains2() {         resetFull();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final Map.Entry<K, V> test = cloneMapEntry(entry);         assertEquals(true, entrySet.contains(test));     }      @SuppressWarnings("unchecked")     public void testEntrySetContains3() {         resetFull();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final HashMap<K, V> temp = new HashMap<>();         temp.put(entry.getKey(), (V) "A VERY DIFFERENT VALUE");         final Map.Entry<K, V> test = temp.entrySet().iterator().next();         assertEquals(false, entrySet.contains(test));     }      public void testEntrySetRemove1() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final int size = getMap().size();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final K key = entry.getKey();          assertEquals(true, entrySet.remove(entry));         assertEquals(false, getMap().containsKey(key));         assertEquals(size - 1, getMap().size());     }      public void testEntrySetRemove2() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final int size = getMap().size();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final K key = entry.getKey();         final Map.Entry<K, V> test = cloneMapEntry(entry);          assertEquals(true, entrySet.remove(test));         assertEquals(false, getMap().containsKey(key));         assertEquals(size - 1, getMap().size());     }      @SuppressWarnings("unchecked")     public void testEntrySetRemove3() {         if (!isRemoveSupported()) {             return;         }         resetFull();         final int size = getMap().size();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final Map.Entry<K, V> entry = entrySet.iterator().next();         final K key = entry.getKey();         final HashMap<K, V> temp = new HashMap<>();         temp.put(entry.getKey(), (V) "A VERY DIFFERENT VALUE");         final Map.Entry<K, V> test = temp.entrySet().iterator().next();          assertEquals(false, entrySet.remove(test));         assertEquals(true, getMap().containsKey(key));         assertEquals(size, getMap().size());     }      //-----------------------------------------------------------------------     /**      * Tests that the {@link Map#values} collection is backed by      * the underlying map by removing from the values collection      * and testing if the value was removed from the map.      * <p>      * We should really test the "vice versa" case--that values removed      * from the map are removed from the values collection--also,      * but that's a more difficult test to construct (lacking a      * "removeValue" method.)      * </p>      * <p>      * See bug <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=9573">      * 9573</a>.      * </p>      */     public void testValuesRemoveChangesMap() {         resetFull();         final V[] sampleValues = getSampleValues();         final Collection<V> values = getMap().values();         for (final V sampleValue : sampleValues) {             if (map.containsValue(sampleValue)) {                 int j = 0;  // loop counter prevents infinite loops when remove is broken                 while (values.contains(sampleValue) && j < 10000) {                     try {                         values.remove(sampleValue);                     } catch (final UnsupportedOperationException e) {                         // if values.remove is unsupported, just skip this test                         return;                     }                     j++;                 }                 assertTrue("values().remove(obj) is broken", j < 10000);                 assertTrue(                     "Value should have been removed from the underlying map.",                     !getMap().containsValue(sampleValue));             }         }     }      /**      * Tests values.removeAll.      */     public void testValuesRemoveAll() {         resetFull();         final Collection<V> values = getMap().values();         final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());         if (!values.equals(sampleValuesAsList)) {             return;         }         try {             assertFalse(values.removeAll(Collections.<V>emptySet()));         } catch (final UnsupportedOperationException e) {             // if values.removeAll is unsupported, just skip this test             return;         }         assertEquals(sampleValuesAsList.size(), getMap().size());         try {             assertTrue(values.removeAll(sampleValuesAsList));         } catch (final UnsupportedOperationException e) {             // if values.removeAll is unsupported, just skip this test             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Test values.retainAll.      */     public void testValuesRetainAll() {         resetFull();         final Collection<V> values = getMap().values();         final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());         if (!values.equals(sampleValuesAsList)) {             return;         }         try {             assertFalse(values.retainAll(sampleValuesAsList));         } catch (final UnsupportedOperationException e) {             // if values.retainAll is unsupported, just skip this test             return;         }         assertEquals(sampleValuesAsList.size(), getMap().size());         try {             assertTrue(values.retainAll(Collections.<V>emptySet()));         } catch (final UnsupportedOperationException e) {             // if values.retainAll is unsupported, just skip this test             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Verifies that values.iterator.remove changes the underlying map.      */     @SuppressWarnings("boxing") // OK in test code     public void testValuesIteratorRemoveChangesMap() {         resetFull();         final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());         final Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);         final Collection<V> values = getMap().values();         for (final Iterator<V> iter = values.iterator(); iter.hasNext();) {             final V value = iter.next();             Integer count = cardinality.get(value);             if (count == null) {                 return;             }             try {                 iter.remove();                 cardinality.put(value, --count);             } catch (final UnsupportedOperationException e) {                 // if values.iterator.remove is unsupported, just skip this test                 return;             }             final boolean expected = count > 0;             final StringBuilder msg = new StringBuilder("Value should ");             msg.append(expected ? "yet " : "no longer ");             msg.append("be present in the underlying map");             assertEquals(msg.toString(), expected, getMap().containsValue(value));         }         assertTrue(getMap().isEmpty());     }      /**      * Tests that the {@link Map#keySet} set is backed by      * the underlying map by removing from the keySet set      * and testing if the key was removed from the map.      */     public void testKeySetRemoveChangesMap() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final Set<K> keys = getMap().keySet();         for (final K sampleKey : sampleKeys) {             try {                 keys.remove(sampleKey);             } catch (final UnsupportedOperationException e) {                 // if key.remove is unsupported, just skip this test                 return;             }             assertTrue(                 "Key should have been removed from the underlying map.",                 !getMap().containsKey(sampleKey));         }     }      /**      * Test keySet.removeAll.      */     public void testKeySetRemoveAll() {         resetFull();         final Set<K> keys = getMap().keySet();         final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());         if (!keys.equals(sampleKeysAsList)) {             return;         }         try {             assertFalse(keys.removeAll(Collections.<K>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeysAsList, keys);         try {             assertTrue(keys.removeAll(sampleKeysAsList));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Test keySet.retainAll.      */     public void testKeySetRetainAll() {         resetFull();         final Set<K> keys = getMap().keySet();         final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());         if (!keys.equals(sampleKeysAsList)) {             return;         }         try {             assertFalse(keys.retainAll(sampleKeysAsList));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeysAsList, keys);         try {             assertTrue(keys.retainAll(Collections.<K>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Verify that keySet.iterator.remove changes the underlying map.      */     public void testKeySetIteratorRemoveChangesMap() {         resetFull();         for (final Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {             final K key = iter.next();             try {                 iter.remove();             } catch (final UnsupportedOperationException e) {                 return;             }             assertFalse(getMap().containsKey(key));         }     }      /**      * Tests that the {@link Map#entrySet} set is backed by      * the underlying map by removing from the entrySet set      * and testing if the entry was removed from the map.      */     public void testEntrySetRemoveChangesMap() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final V[] sampleValues = getSampleValues();         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         for (int i = 0; i < sampleKeys.length; i++) {             try {                 entrySet.remove(new DefaultMapEntry<>(sampleKeys[i], sampleValues[i]));             } catch (final UnsupportedOperationException e) {                 // if entrySet removal is unsupported, just skip this test                 return;             }             assertTrue(                     "Entry should have been removed from the underlying map.",                     !getMap().containsKey(sampleKeys[i]));         }     }      /**      * Test entrySet.removeAll.      */     public void testEntrySetRemoveAll() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final V[] sampleValues = getSampleValues();         //verify map looks as expected:         for (int i = 0; i < sampleKeys.length; i++) {             if (!getMap().containsKey(sampleKeys[i])) {                 return;             }             final V value = sampleValues[i];             final V test = getMap().get(sampleKeys[i]);             if (value == test || value != null && value.equals(test)) {                 continue;             }             return;         }         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<>(entrySet);         try {             assertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeys.length, getMap().size());         try {             assertTrue(entrySet.removeAll(comparisonSet));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Test entrySet.retainAll.      */     public void testEntrySetRetainAll() {         resetFull();         final K[] sampleKeys = getSampleKeys();         final V[] sampleValues = getSampleValues();         //verify map looks as expected:         for (int i = 0; i < sampleKeys.length; i++) {             if (!getMap().containsKey(sampleKeys[i])) {                 return;             }             final V value = sampleValues[i];             final V test = getMap().get(sampleKeys[i]);             if (value == test || value != null && value.equals(test)) {                 continue;             }             return;         }         final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();         final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<>(entrySet);         try {             assertFalse(entrySet.retainAll(comparisonSet));         } catch (final UnsupportedOperationException e) {             return;         }         assertEquals(sampleKeys.length, getMap().size());         try {             assertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>>emptySet()));         } catch (final UnsupportedOperationException e) {             return;         }         assertTrue(getMap().isEmpty());     }      /**      * Verify that entrySet.iterator.remove changes the underlying map.      */     public void testEntrySetIteratorRemoveChangesMap() {         resetFull();         for (final Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {             final K key = iter.next().getKey();             try {                 iter.remove();             } catch (final UnsupportedOperationException e) {                 return;             }             assertFalse(getMap().containsKey(key));         }     }      /**      * Utility methods to create an array of Map.Entry objects      * out of the given key and value arrays.<P>      *      * @param keys    the array of keys      * @param values  the array of values      * @return an array of Map.Entry of those keys to those values      */     @SuppressWarnings("unchecked")     private Map.Entry<K, V>[] makeEntryArray(final K[] keys, final V[] values) {         final Map.Entry<K, V>[] result = new Map.Entry[keys.length];         for (int i = 0; i < keys.length; i++) {             final Map<K, V> map = makeConfirmedMap();             map.put(keys[i], values[i]);             result[i] = map.entrySet().iterator().next();         }         return result;     }      /**      * Bulk test {@link Map#entrySet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the map and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the map's entry set      */     public BulkTest bulkTestMapEntrySet() {         return new TestMapEntrySet();     }      public class TestMapEntrySet extends AbstractSetTest<Map.Entry<K, V>> {         public TestMapEntrySet() {             super("MapEntrySet");         }          // Have to implement manually; entrySet doesn't support addAll         /**          * {@inheritDoc}          */         @Override         public Entry<K, V>[] getFullElements() {             return getFullNonNullElements();         }          /**          * {@inheritDoc}          */         @Override         public Map.Entry<K, V>[] getFullNonNullElements() {             final K[] k = getSampleKeys();             final V[] v = getSampleValues();             return makeEntryArray(k, v);         }          // Have to implement manually; entrySet doesn't support addAll         @Override         public Map.Entry<K, V>[] getOtherElements() {             final K[] k = getOtherKeys();             final V[] v = getOtherValues();             return makeEntryArray(k, v);         }          @Override         public Set<Map.Entry<K, V>> makeObject() {             return AbstractMapTest.this.makeObject().entrySet();         }          @Override         public Set<Map.Entry<K, V>> makeFullCollection() {             return makeFullMap().entrySet();         }          @Override         public boolean isAddSupported() {             // Collection views don't support add operations.             return false;         }          @Override         public boolean isRemoveSupported() {             // Entry set should only support remove if map does             return AbstractMapTest.this.isRemoveSupported();         }          public boolean isGetStructuralModify() {             return AbstractMapTest.this.isGetStructuralModify();         }          @Override         public boolean areEqualElementsDistinguishable() {             return AbstractMapTest.this.areEqualElementsDistinguishable();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetFull() {             AbstractMapTest.this.resetFull();             setCollection(AbstractMapTest.this.getMap().entrySet());             TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());         }          @Override         public void resetEmpty() {             AbstractMapTest.this.resetEmpty();             setCollection(AbstractMapTest.this.getMap().entrySet());             TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());         }          public void testMapEntrySetIteratorEntry() {             resetFull();             final Iterator<Map.Entry<K, V>> it = getCollection().iterator();             int count = 0;             while (it.hasNext()) {                 final Map.Entry<K, V> entry = it.next();                 assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry.getKey()));                 assertEquals(true, AbstractMapTest.this.getMap().containsValue(entry.getValue()));                 if (!isGetStructuralModify()) {                     assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());                 }                 count++;             }             assertEquals(getCollection().size(), count);         }          public void testMapEntrySetIteratorEntrySetValue() {             final K key1 = getSampleKeys()[0];             final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];             final V newValue1 = getNewSampleValues()[0];             final V newValue2 = getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1];              resetFull();             // explicitly get entries as sample values/keys are connected for some maps             // such as BeanMap             Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry1 = getEntry(it, key1);             it = TestMapEntrySet.this.getCollection().iterator();             final Map.Entry<K, V> entry2 = getEntry(it, key2);             Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);             itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();             final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);             verify();              if (!isSetValueSupported()) {                 try {                     entry1.setValue(newValue1);                 } catch (final UnsupportedOperationException ex) {                 }                 return;             }              entry1.setValue(newValue1);             entryConfirmed1.setValue(newValue1);             assertEquals(newValue1, entry1.getValue());             assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));             assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));             assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));             verify();              entry1.setValue(newValue1);             entryConfirmed1.setValue(newValue1);             assertEquals(newValue1, entry1.getValue());             assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));             assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));             assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));             verify();              entry2.setValue(newValue2);             entryConfirmed2.setValue(newValue2);             assertEquals(newValue2, entry2.getValue());             assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry2.getKey()));             assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue2));             assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));             verify();         }          public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key) {             Map.Entry<K, V> entry = null;             while (itConfirmed.hasNext()) {                 final Map.Entry<K, V> temp = itConfirmed.next();                 if (temp.getKey() == null) {                     if (key == null) {                         entry = temp;                         break;                     }                 } else if (temp.getKey().equals(key)) {                     entry = temp;                     break;                 }             }             assertNotNull("No matching entry in map for key '" + key + "'", entry);             return entry;         }          public void testMapEntrySetRemoveNonMapEntry() {             if (!isRemoveSupported()) {                 return;             }             resetFull();             assertEquals(false, getCollection().remove(null));             assertEquals(false, getCollection().remove(new Object()));         }          @Override         public void verify() {             super.verify();             AbstractMapTest.this.verify();         }     }       /**      * Bulk test {@link Map#keySet()}.  This method runs through all of      * the tests in {@link AbstractSetTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the map and the other collection views are still valid.      *      * @return a {@link AbstractSetTest} instance for testing the map's key set      */     public BulkTest bulkTestMapKeySet() {         return new TestMapKeySet();     }      public class TestMapKeySet extends AbstractSetTest<K> {         public TestMapKeySet() {             super("");         }          @Override         public K[] getFullElements() {             return getSampleKeys();         }          @Override         public K[] getOtherElements() {             return getOtherKeys();         }          @Override         public Set<K> makeObject() {             return AbstractMapTest.this.makeObject().keySet();         }          @Override         public Set<K> makeFullCollection() {             return AbstractMapTest.this.makeFullMap().keySet();         }          @Override         public boolean isNullSupported() {             return AbstractMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public void resetEmpty() {             AbstractMapTest.this.resetEmpty();             setCollection(AbstractMapTest.this.getMap().keySet());             TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());         }          @Override         public void resetFull() {             AbstractMapTest.this.resetFull();             setCollection(AbstractMapTest.this.getMap().keySet());             TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());         }          @Override         public void verify() {             super.verify();             AbstractMapTest.this.verify();         }     }      /**      * Bulk test {@link Map#values()}.  This method runs through all of      * the tests in {@link AbstractCollectionTest}.      * After modification operations, {@link #verify()} is invoked to ensure      * that the map and the other collection views are still valid.      *      * @return a {@link AbstractCollectionTest} instance for testing the map's      *    values collection      */     public BulkTest bulkTestMapValues() {         return new TestMapValues();     }      public class TestMapValues extends AbstractCollectionTest<V> {         public TestMapValues() {             super("");         }          @Override         public V[] getFullElements() {             return getSampleValues();         }          @Override         public V[] getOtherElements() {             return getOtherValues();         }          @Override         public Collection<V> makeObject() {             return AbstractMapTest.this.makeObject().values();         }          @Override         public Collection<V> makeFullCollection() {             return AbstractMapTest.this.makeFullMap().values();         }          @Override         public boolean isNullSupported() {             return AbstractMapTest.this.isAllowNullKey();         }          @Override         public boolean isAddSupported() {             return false;         }          @Override         public boolean isRemoveSupported() {             return AbstractMapTest.this.isRemoveSupported();         }          @Override         public boolean isTestSerialization() {             return false;         }          @Override         public boolean areEqualElementsDistinguishable() {             // equal values are associated with different keys, so they are             // distinguishable.             return true;         }          @Override         public Collection<V> makeConfirmedCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public Collection<V> makeConfirmedFullCollection() {             // never gets called, reset methods are overridden             return null;         }          @Override         public void resetFull() {             AbstractMapTest.this.resetFull();             setCollection(map.values());             TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());         }          @Override         public void resetEmpty() {             AbstractMapTest.this.resetEmpty();             setCollection(map.values());             TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());         }          @Override         public void verify() {             super.verify();             AbstractMapTest.this.verify();         }          // TODO: should test that a remove on the values collection view         // removes the proper mapping and not just any mapping that may have         // the value equal to the value returned from the values iterator.     }       /**      * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},      * {@link #values} and {@link #confirmed} fields to empty.      */     public void resetEmpty() {         this.map = makeObject();         views();         this.confirmed = makeConfirmedMap();     }      /**      * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},      * {@link #values} and {@link #confirmed} fields to full.      */     public void resetFull() {         this.map = makeFullMap();         views();         this.confirmed = makeConfirmedMap();         final K[] k = getSampleKeys();         final V[] v = getSampleValues();         for (int i = 0; i < k.length; i++) {             confirmed.put(k[i], v[i]);         }     }      /**      * Resets the collection view fields.      */     private void views() {         this.keySet = getMap().keySet();         // see verifyValues: retrieve the values collection only when verifying them         // this.values = getMap().values();         this.entrySet = getMap().entrySet();     }      /**      * Verifies that {@link #map} is still equal to {@link #confirmed}.      * This method checks that the map is equal to the HashMap,      * <I>and</I> that the map's collection views are still equal to      * the HashMap's collection views.  An <Code>equals</Code> test      * is done on the maps and their collection views; their size and      * <Code>isEmpty</Code> results are compared; their hashCodes are      * compared; and <Code>containsAll</Code> tests are run on the      * collection views.      */     public void verify() {         verifyMap();         verifyEntrySet();         verifyKeySet();         verifyValues();     }      public void verifyMap() {         final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("Map should be same size as HashMap", size, getMap().size());         assertEquals("Map should be empty if HashMap is", empty, getMap().isEmpty());         assertEquals("hashCodes should be the same", getConfirmed().hashCode(), getMap().hashCode());         // changing the order of the assertion below fails for LRUMap because confirmed is         // another collection (e.g. treemap) and confirmed.equals() creates a normal iterator (not         // #mapIterator()), which modifies the parent expected modCount of the map object, causing         // concurrent modification exceptions.         // Because of this we have assertEquals(map, confirmed), and not the other way around.         assertEquals("Map should still equal HashMap", map, confirmed);         assertTrue("Map should still equal HashMap", getMap().equals(getConfirmed()));     }      public void verifyEntrySet() {         final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("entrySet should be same size as HashMap's" +                      "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                      size, entrySet.size());         assertEquals("entrySet should be empty if HashMap is" +                      "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                      empty, entrySet.isEmpty());         assertTrue("entrySet should contain all HashMap's elements" +                    "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                    entrySet.containsAll(getConfirmed().entrySet()));         assertEquals("entrySet hashCodes should be the same" +                      "\nTest: " + entrySet + "\nReal: " + getConfirmed().entrySet(),                      getConfirmed().entrySet().hashCode(), entrySet.hashCode());         assertEquals("Map's entry set should still equal HashMap's",                      getConfirmed().entrySet(), entrySet);     }      public void verifyKeySet() {         final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("keySet should be same size as HashMap's" +                      "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                      size, keySet.size());         assertEquals("keySet should be empty if HashMap is" +                      "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                      empty, keySet.isEmpty());         assertTrue("keySet should contain all HashMap's elements" +                    "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                    keySet.containsAll(getConfirmed().keySet()));         assertEquals("keySet hashCodes should be the same" +                      "\nTest: " + keySet + "\nReal: " + getConfirmed().keySet(),                      getConfirmed().keySet().hashCode(), keySet.hashCode());         assertEquals("Map's key set should still equal HashMap's",                 getConfirmed().keySet(), keySet);     }      public void verifyValues() {         final List<V> known = new ArrayList<>(getConfirmed().values());          values = getMap().values();          final List<V> test = new ArrayList<>(values);          final int size = getConfirmed().size();         final boolean empty = getConfirmed().isEmpty();         assertEquals("values should be same size as HashMap's" +                      "\nTest: " + test + "\nReal: " + known,                      size, values.size());         assertEquals("values should be empty if HashMap is" +                      "\nTest: " + test + "\nReal: " + known,                      empty, values.isEmpty());         assertTrue("values should contain all HashMap's elements" +                    "\nTest: " + test + "\nReal: " + known,                     test.containsAll(known));         assertTrue("values should contain all HashMap's elements" +                    "\nTest: " + test + "\nReal: " + known,                    known.containsAll(test));         // originally coded to use a HashBag, but now separate jar so...         for (final V v : known) {             final boolean removed = test.remove(v);             assertTrue("Map's values should still equal HashMap's", removed);         }         assertTrue("Map's values should still equal HashMap's", test.isEmpty());     }      /**      * Erases any leftover instance variables by setting them to null.      */     @Override     public void tearDown() throws Exception {         map = null;         keySet = null;         entrySet = null;         values = null;         confirmed = null;     }      /**      * Get the map.      * @return Map<K, V>      */     public Map<K, V> getMap() {         return map;     }      /**      * Get the confirmed.      * @return Map<K, V>      */     public Map<K, V> getConfirmed() {         return confirmed;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.SortedMap; import java.util.TreeMap;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the {@link FixedSizeSortedMap}  * implementation.  *  * @since 3.0  */ public class FixedSizeSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      public FixedSizeSortedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(FixedSizeSortedMapTest.class);     }      //-----------------------------------------------------------------------     @Override     public SortedMap<K, V> makeObject() {         return FixedSizeSortedMap.fixedSizeSortedMap(new TreeMap<K, V>());     }      @Override     public SortedMap<K, V> makeFullMap() {         final SortedMap<K, V> map = new TreeMap<>();         addSampleMappings(map);         return FixedSizeSortedMap.fixedSizeSortedMap(map);     }      @Override     public boolean isSubMapViewsSerializable() {         // TreeMap sub map views have a bug in deserialization.         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      //-----------------------------------------------------------------------     @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeSortedMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * JUnit tests.  *  */ public class HashedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public HashedMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(HashedMapTest.class);     }      @Override     public HashedMap<K, V> makeObject() {         return new HashedMap<>();     }      @Override     public String getCompatibilityVersion() {         return "4";     }      @SuppressWarnings("unchecked")     public void testClone() {         final HashedMap<K, V> map = new HashedMap<>(10);         map.put((K) "1", (V) "1");         final HashedMap<K, V> cloned = map.clone();         assertEquals(map.size(), cloned.size());         assertSame(map.get("1"), cloned.get("1"));     }      public void testInternalState() {         final HashedMap<Integer, Integer> map = new HashedMap<>(42, 0.75f);         assertEquals(0.75f, map.loadFactor, 0.1f);         assertEquals(0, map.size);         assertEquals(64, map.data.length);         assertEquals(48, map.threshold);         assertEquals(0, map.modCount);          // contract: the capacity is ensured when too many elements are added         final HashedMap<Integer, Integer> tmpMap = new HashedMap<>();         // we need to put at least the "threshold" number of elements         // in order to double the capacity         for (int i = 1; i <= map.threshold; i++) {             tmpMap.put(i, i);         }         map.putAll(tmpMap);         // the threshold has changed due to calling ensureCapacity         assertEquals(96, map.threshold);     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/HashedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk((java.io.Serializable) map, "src/test/resources/data/test/HashedMap.fullCollection.version4.obj"); //    }      /**      * Test for <a href="https://issues.apache.org/jira/browse/COLLECTIONS-323">COLLECTIONS-323</a>.      */     public void testInitialCapacityZero() {         final HashedMap<String, String> map = new HashedMap<>(0);         assertEquals(1, map.data.length);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.Map;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;  /**  * Abstract test class for {@link IterableMap} methods and contracts.  *  */ public abstract class AbstractIterableMapTest<K, V> extends AbstractMapTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractIterableMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public abstract IterableMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public IterableMap<K, V> makeFullMap() {         return (IterableMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     public void testFailFastEntrySet() {         if (!isRemoveSupported()) {             return;         }         if (!isFailFastExpected()) {             return;         }         resetFull();         Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();         final Map.Entry<K, V> val = it.next();         getMap().remove(val.getKey());         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}          resetFull();         it = getMap().entrySet().iterator();         it.next();         getMap().clear();         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}     }      public void testFailFastKeySet() {         if (!isRemoveSupported()) {             return;         }         if (!isFailFastExpected()) {             return;         }         resetFull();         Iterator<K> it = getMap().keySet().iterator();         final K val = it.next();         getMap().remove(val);         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}          resetFull();         it = getMap().keySet().iterator();         it.next();         getMap().clear();         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}     }      public void testFailFastValues() {         if (!isRemoveSupported()) {             return;         }         if (!isFailFastExpected()) {             return;         }         resetFull();         Iterator<V> it = getMap().values().iterator();         it.next();         getMap().remove(getMap().keySet().iterator().next());         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}          resetFull();         it = getMap().values().iterator();         it.next();         getMap().clear();         try {             it.next();             fail();         } catch (final ConcurrentModificationException ex) {}     }      //-----------------------------------------------------------------------     public BulkTest bulkTestMapIterator() {         return new InnerTestMapIterator();     }      public class InnerTestMapIterator extends AbstractMapIteratorTest<K, V> {         public InnerTestMapIterator() {             super("InnerTestMapIterator");         }          @Override         public V[] addSetValues() {             return AbstractIterableMapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return AbstractIterableMapTest.this.isRemoveSupported();         }          @Override         public boolean isGetStructuralModify() {             return AbstractIterableMapTest.this.isGetStructuralModify();         }          @Override         public boolean supportsSetValue() {             return AbstractIterableMapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractIterableMapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return AbstractIterableMapTest.this.getMap().mapIterator();         }          @Override         public Map<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractIterableMapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractIterableMapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             AbstractIterableMapTest.this.verify();         }     }  //  public void testCreate() throws Exception { //      resetEmpty(); //      writeExternalFormToDisk((Serializable) map, "D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj"); //      resetFull(); //      writeExternalFormToDisk((Serializable) map, "D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj"); //  }      /**      * {@inheritDoc}      */     @Override     public IterableMap<K, V> getMap() {         return (IterableMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.function.Consumer;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.map.AbstractHashedMap.HashEntry; import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceEntry; import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;  import junit.framework.Test;  /**  * Tests for ReferenceMap.  *  */ public class ReferenceMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public ReferenceMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(ReferenceMapTest.class);     }      @Override     public ReferenceMap<K, V> makeObject() {         return new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);     }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceMap.fullCollection.version4.obj"); //    }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testNullHandling() {         resetFull();         assertEquals(null, map.get(null));         assertEquals(false, map.containsKey(null));         assertEquals(false, map.containsValue(null));         assertEquals(null, map.remove(null));         assertEquals(false, map.entrySet().contains(null));         assertEquals(false, map.keySet().contains(null));         assertEquals(false, map.values().contains(null));         try {             map.put(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             map.put((K) new Object(), null);             fail();         } catch (final NullPointerException ex) {}         try {             map.put(null, (V) new Object());             fail();         } catch (final NullPointerException ex) {}     }      //----------------------------------------------------------------------- /*     // Tests often fail because gc is uncontrollable      public void testPurge() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < hard.length; i++) {             hard[i] = new Object();             map.put(hard[i], new Object());         }         gc();         assertTrue("map should be empty after purge of weak values", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);         }         gc();         assertTrue("map should be empty after purge of weak keys", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);             map.put(hard[i], new Object());         }          gc();         assertTrue("map should be empty after purge of weak keys and values", map.isEmpty());     }       public void testGetAfterGC() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         for (int i = 0; i < 10; i++) {             map.put(Integer.valueOf(i), Integer.valueOf(i));         }          gc();         for (int i = 0; i < 10; i++) {             Integer I = Integer.valueOf(i);             assertTrue("map.containsKey should return false for GC'd element", !map.containsKey(I));             assertTrue("map.get should return null for GC'd element", map.get(I) == null);         }     }       public void testEntrySetIteratorAfterGC() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         Iterator iterator = map.entrySet().iterator();         while (iterator.hasNext()) {             Map.Entry entry = (Map.Entry)iterator.next();             Integer key = (Integer)entry.getKey();             Integer value = (Integer)entry.getValue();             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC2() {         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             gc();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      } */      WeakReference<K> keyReference;     WeakReference<V> valueReference;      @SuppressWarnings("unchecked")     public Map<K, V> buildRefMap() {         final K key = (K) new Object();         final V value = (V) new Object();          keyReference = new WeakReference<>(key);         valueReference = new WeakReference<>(value);          final Map<K, V> testMap = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);         testMap.put(key, value);          assertEquals("In map", value, testMap.get(key));         assertNotNull("Weak reference released early (1)", keyReference.get());         assertNotNull("Weak reference released early (2)", valueReference.get());         return testMap;     }      /** Tests whether purge values setting works */     public void testPurgeValues() throws Exception {         // many thanks to Juozas Baliuka for suggesting this method         final Map<K, V> testMap = buildRefMap();          int iterations = 0;         int bytz = 2;         while (true) {             System.gc();             if (iterations++ > 50) {                 fail("Max iterations reached before resource released.");             }             testMap.isEmpty();             if (keyReference.get() == null && valueReference.get() == null) {                 break;              }             // create garbage:             @SuppressWarnings("unused")             final byte[] b = new byte[bytz];             bytz = bytz * 2;         }     }      public void testCustomPurge() {         final List<Integer> expiredValues = new ArrayList<>();         @SuppressWarnings("unchecked")         final Consumer<Integer> consumer = (Consumer<Integer> & Serializable) v -> expiredValues.add(v);         final Map<Integer, Integer> map = new ReferenceMap<Integer, Integer>(ReferenceStrength.WEAK, ReferenceStrength.HARD, false) {             private static final long serialVersionUID = 1L;              @Override             protected ReferenceEntry<Integer, Integer> createEntry(final HashEntry<Integer, Integer> next, final int hashCode, final Integer key, final Integer value) {                 return new AccessibleEntry<>(this, next, hashCode, key, value, consumer);             }         };         for (int i = 100000; i < 100010; i++) {             map.put(Integer.valueOf(i), Integer.valueOf(i));         }         int iterations = 0;         int bytz = 2;         while (true) {             System.gc();             if (iterations++ > 50 || bytz < 0) {                 fail("Max iterations reached before resource released.");             }             map.isEmpty();             if (!expiredValues.isEmpty()) {                 break;             }             // create garbage:             @SuppressWarnings("unused")             final byte[] b = new byte[bytz];             bytz = bytz * 2;         }         assertFalse("Value should be stored", expiredValues.isEmpty());     }      /**      * Test whether after serialization the "data" HashEntry array is the same size as the original.<p>      *      * See <a href="https://issues.apache.org/jira/browse/COLLECTIONS-599">COLLECTIONS-599: HashEntry array object naming data initialized with double the size during deserialization</a>      */     public void testDataSizeAfterSerialization() throws IOException, ClassNotFoundException {          final ReferenceMap<String, String> serializeMap = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK, true);         serializeMap.put("KEY", "VALUE");          final ByteArrayOutputStream baos = new ByteArrayOutputStream();         try (ObjectOutputStream out = new ObjectOutputStream(baos)) {             out.writeObject(serializeMap);         }          final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());         try (ObjectInputStream in = new ObjectInputStream(bais)) {             @SuppressWarnings("unchecked")             final ReferenceMap<String, String> deserializedMap = (ReferenceMap<String, String>) in.readObject();             assertEquals(1, deserializedMap.size());             assertEquals(serializeMap.data.length, deserializedMap.data.length);         }      }      @SuppressWarnings("unused")     private static void gc() {         try {             // trigger GC             final byte[][] tooLarge = new byte[1000000000][1000000000];             fail("you have too much RAM");         } catch (final OutOfMemoryError ex) {             System.gc(); // ignore         }     }      private static class AccessibleEntry<K, V> extends ReferenceEntry<K, V> {         final AbstractReferenceMap<K, V> parent;         final Consumer<V> consumer;          AccessibleEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value, final Consumer<V> consumer) {             super(parent, next, hashCode, key, value);             this.parent = parent;             this.consumer = consumer;         }          @Override         protected void onPurge() {             if (parent.isValueType(ReferenceStrength.HARD)) {                 consumer.accept(getValue());             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.Map; import java.util.Collection;  /**  * This class is used in TestCompositeMap. When testing serialization,  * the class has to be separate of TestCompositeMap, else the test  * class also has to be serialized.  */ class EmptyMapMutator<K, V> implements CompositeMap.MapMutator<K, V> {     /** Serialization version */     private static final long serialVersionUID = -2729718980002476794L;      @Override     public void resolveCollision(final CompositeMap<K, V> composite,         final Map<K, V> existing,         final Map<K, V> added,         final Collection<K> intersect) {         // Do nothing     }      @Override     public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, final V value) {         return composited[0].put(key, value);     }      @Override     public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {         composited[0].putAll(t);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.NoSuchElementException; import java.util.TreeMap;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.OrderedMap; import org.apache.commons.collections4.OrderedMapIterator; import org.apache.commons.collections4.comparators.NullComparator; import org.apache.commons.collections4.iterators.AbstractOrderedMapIteratorTest;  /**  * Abstract test class for {@link OrderedMap} methods and contracts.  *  */ public abstract class AbstractOrderedMapTest<K, V> extends AbstractIterableMapTest<K, V> {      /**      * JUnit constructor.      *      * @param testName  the test name      */     public AbstractOrderedMapTest(final String testName) {         super(testName);     }      /**      * {@inheritDoc}      */     @Override     public abstract OrderedMap<K, V> makeObject();      /**      * {@inheritDoc}      */     @Override     public OrderedMap<K, V> makeFullMap() {         return (OrderedMap<K, V>) super.makeFullMap();     }      //-----------------------------------------------------------------------     /**      * OrderedMap uses TreeMap as its known comparison.      *      * @return a map that is known to be valid      */     @Override     public Map<K, V> makeConfirmedMap() {         return new TreeMap<>(new NullComparator<K>());     }      /**      * The only confirmed collection we have that is ordered is the sorted one.      * Thus, sort the keys.      */     @Override     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         final List<K> list = new ArrayList<>(Arrays.asList(super.getSampleKeys()));         Collections.sort(list, new NullComparator<K>());         return (K[]) list.toArray();     }      //-----------------------------------------------------------------------     public void testFirstKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         try {             ordered.firstKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         ordered = getMap();         final K confirmedFirst = confirmed.keySet().iterator().next();         assertEquals(confirmedFirst, ordered.firstKey());     }      public void testLastKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         try {             ordered.lastKey();             fail();         } catch (final NoSuchElementException ex) {}          resetFull();         ordered = getMap();         K confirmedLast = null;         for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {             confirmedLast = it.next();         }         assertEquals(confirmedLast, ordered.lastKey());     }      //-----------------------------------------------------------------------     public void testNextKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         assertEquals(null, ordered.nextKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, ordered.nextKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, ordered.nextKey(null));         }          resetFull();         ordered = getMap();         final Iterator<K> it = confirmed.keySet().iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, ordered.nextKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, ordered.nextKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 ordered.nextKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, ordered.nextKey(null));         }     }      public void testPreviousKey() {         resetEmpty();         OrderedMap<K, V> ordered = getMap();         assertEquals(null, ordered.previousKey(getOtherKeys()[0]));         if (!isAllowNullKey()) {             try {                 assertEquals(null, ordered.previousKey(null)); // this is allowed too             } catch (final NullPointerException ex) {}         } else {             assertEquals(null, ordered.previousKey(null));         }          resetFull();         ordered = getMap();         final List<K> list = new ArrayList<>(confirmed.keySet());         Collections.reverse(list);         final Iterator<K> it = list.iterator();         K confirmedLast = it.next();         while (it.hasNext()) {             final K confirmedObject = it.next();             assertEquals(confirmedObject, ordered.previousKey(confirmedLast));             confirmedLast = confirmedObject;         }         assertEquals(null, ordered.previousKey(confirmedLast));          if (!isAllowNullKey()) {             try {                 ordered.previousKey(null);                 fail();             } catch (final NullPointerException ex) {}         } else {             if (!isAllowNullKey()) {                 assertEquals(null, ordered.previousKey(null));             }         }     }      //-----------------------------------------------------------------------     public BulkTest bulkTestOrderedMapIterator() {         return new InnerTestOrderedMapIterator();     }      public class InnerTestOrderedMapIterator extends AbstractOrderedMapIteratorTest<K, V> {         public InnerTestOrderedMapIterator() {             super("InnerTestOrderedMapIterator");         }          @Override         public boolean supportsRemove() {             return AbstractOrderedMapTest.this.isRemoveSupported();         }          @Override         public boolean isGetStructuralModify() {             return AbstractOrderedMapTest.this.isGetStructuralModify();         }          @Override         public boolean supportsSetValue() {             return AbstractOrderedMapTest.this.isSetValueSupported();         }          @Override         public OrderedMapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return AbstractOrderedMapTest.this.getMap().mapIterator();         }          @Override         public OrderedMapIterator<K, V> makeObject() {             resetFull();             return AbstractOrderedMapTest.this.getMap().mapIterator();         }          @Override         public OrderedMap<K, V> getMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedMapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return AbstractOrderedMapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             AbstractOrderedMapTest.this.verify();         }     }      /**      * {@inheritDoc}      */     @Override     public OrderedMap<K, V> getMap() {         return (OrderedMap<K, V>) super.getMap();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import static org.apache.commons.collections4.map.LazySortedMap.*;  import java.util.Comparator; import java.util.Map; import java.util.SortedMap; import java.util.TreeMap; import java.util.concurrent.ConcurrentSkipListMap;  import org.apache.commons.collections4.Factory; import org.apache.commons.collections4.FactoryUtils; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.TransformerUtils; import org.junit.Test;  /**  * Extension of {@link LazyMapTest} for exercising the  * {@link LazySortedMap} implementation.  *  * @since 3.0  */ @SuppressWarnings("boxing") public class LazySortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      private class ReverseStringComparator implements Comparator<String> {         @Override         public int compare(final String arg0, final String arg1) {             return arg1.compareTo(arg0);         }     }      private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);      protected final Comparator<String> reverseStringComparator = new ReverseStringComparator();      public LazySortedMapTest(final String testName) {         super(testName);     }      @Override     public SortedMap<K, V> makeObject() {         return lazySortedMap(new TreeMap<K, V>(), FactoryUtils.<V>nullFactory());     }      @Override     public boolean isAllowNullKey() {         return false;     }      // from LazyMapTest     //-----------------------------------------------------------------------     @Override     public void testMapGet() {         //TODO eliminate need for this via superclass - see svn history.     }      @Test     public void mapGet() {         Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), oneFactory);         assertEquals(0, map.size());         final Number i1 = map.get(5);         assertEquals(1, i1);         assertEquals(1, map.size());          map = lazySortedMap(new TreeMap<Integer, Number>(), FactoryUtils.<Number>nullFactory());         final Number o = map.get(5);         assertEquals(null, o);         assertEquals(1, map.size());      }      //-----------------------------------------------------------------------     public void testSortOrder() {         final SortedMap<String, Number> map = lazySortedMap(new TreeMap<String, Number>(), oneFactory);         map.put("A",  5);         map.get("B"); // Entry with value "One" created         map.put("C", 8);         assertEquals("First key should be A", "A", map.firstKey());         assertEquals("Last key should be C", "C", map.lastKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap("B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap("C").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap("A", "C").lastKey());          final Comparator<?> c = map.comparator();         assertTrue("natural order, so comparator should be null",             c == null);     }      public void testReverseSortOrder() {         final SortedMap<String, Number> map = lazySortedMap(new ConcurrentSkipListMap<String, Number>(reverseStringComparator), oneFactory);         map.put("A",  5);         map.get("B"); // Entry with value "One" created         map.put("C", 8);         assertEquals("Last key should be A", "A", map.lastKey());         assertEquals("First key should be C", "C", map.firstKey());         assertEquals("First key in tail map should be B",             "B", map.tailMap("B").firstKey());         assertEquals("Last key in head map should be B",             "B", map.headMap("A").lastKey());         assertEquals("Last key in submap should be B",             "B", map.subMap("C", "A").lastKey());          final Comparator<?> c = map.comparator();         assertTrue("natural order, so comparator should be null",             c == reverseStringComparator);     }      public void testTransformerDecorate() {         final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);         SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);         assertTrue(map instanceof LazySortedMap);         try {             map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);             fail("Expecting NullPointerException for null transformer");         } catch (final NullPointerException e) {             // expected         }         try {             map = lazySortedMap((SortedMap<Integer, Number>) null, transformer);             fail("Expecting NullPointerException for null map");         } catch (final NullPointerException e) {             // expected         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazySortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/LazySortedMap.fullCollection.version4.obj"); //    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest;  /**  * Unit tests.  * {@link StaticBucketMap}.  *  */ public class StaticBucketMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public StaticBucketMapTest(final String name) {         super(name);     }      public static Test suite() {         return BulkTest.makeSuite(StaticBucketMapTest.class);     }      @Override     public StaticBucketMap<K, V> makeObject() {         return new StaticBucketMap<>(30);     }      /**      * {@inheritDoc}      */     @Override     public boolean isFailFastExpected() {         return false;     }      @Override     public String[] ignoredTests() {         final String pre = "StaticBucketMapTest.bulkTestMap";         final String post = ".testCollectionIteratorFailFast";         return new String[] {             pre + "EntrySet" + post,             pre + "KeySet" + post,             pre + "Values" + post         };     }      // Bugzilla 37567     @SuppressWarnings("unchecked")     public void test_get_nullMatchesIncorrectly() {         final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);         map.put(null, (V) "A");         assertEquals("A", map.get(null));         // loop so we find a string that is in the same bucket as the null         for (int i = 'A'; i <= 'Z'; i++) {             final String str = String.valueOf((char) i);             assertEquals("String: " + str, null, map.get(str));         }     }      @SuppressWarnings("unchecked")     public void test_containsKey_nullMatchesIncorrectly() {         final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);         map.put(null, (V) "A");         assertEquals(true, map.containsKey(null));         // loop so we find a string that is in the same bucket as the null         for (int i = 'A'; i <= 'Z'; i++) {             final String str = String.valueOf((char) i);             assertEquals("String: " + str, false, map.containsKey(str));         }     }      @SuppressWarnings("unchecked")     public void test_containsValue_nullMatchesIncorrectly() {         final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);         map.put((K) "A", null);         assertEquals(true, map.containsValue(null));         // loop so we find a string that is in the same bucket as the null         for (int i = 'A'; i <= 'Z'; i++) {             final String str = String.valueOf((char) i);             assertEquals("String: " + str, false, map.containsValue(str));         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map;  import org.apache.commons.collections4.IterableMap;  /**  * Extension of {@link AbstractMapTest} for exercising the {@link FixedSizeMap}  * implementation.  *  * @since 3.0  */ public class FixedSizeMapTest<K, V> extends AbstractIterableMapTest<K, V> {      public FixedSizeMapTest(final String testName) {         super(testName);     }      @Override     public IterableMap<K, V> makeObject() {         return FixedSizeMap.fixedSizeMap(new HashMap<K, V>());     }      @Override     public IterableMap<K, V> makeFullMap() {         final Map<K, V> map = new HashMap<>();         addSampleMappings(map);         return FixedSizeMap.fixedSizeMap(map);     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/FixedSizeMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy;  /**  * JUnit tests.  *  * @since 4.0  */ public class PassiveExpiringMapTest<K, V> extends AbstractMapTest<K, V> {      private static class TestExpirationPolicy         implements ExpirationPolicy<Integer, String> {          private static final long serialVersionUID = 1L;          @Override         public long expirationTime(final Integer key, final String value) {             // odd keys expire immediately, even keys never expire             if (key == null) {                 return 0;             }              if (key.intValue() % 2 == 0) {                 return -1;             }              return 0;         }     }      public static Test suite() {         return BulkTest.makeSuite(PassiveExpiringMapTest.class);     }      public PassiveExpiringMapTest(final String testName) {         super(testName);     }  //    public void testCreate() throws Exception { //        writeExternalFormToDisk((java.io.Serializable) makeObject(), //                "src/test/resources/data/test/PassiveExpiringMap.emptyCollection.version4.obj"); // //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(), //                "src/test/resources/data/test/PassiveExpiringMap.fullCollection.version4.obj"); //    }      @Override     public String getCompatibilityVersion() {         return "4";     }      private Map<Integer, String> makeDecoratedTestMap() {         final Map<Integer, String> m = new HashMap<>();         m.put(Integer.valueOf(1), "one");         m.put(Integer.valueOf(2), "two");         m.put(Integer.valueOf(3), "three");         m.put(Integer.valueOf(4), "four");         m.put(Integer.valueOf(5), "five");         m.put(Integer.valueOf(6), "six");         return new PassiveExpiringMap<>(new TestExpirationPolicy(), m);     }      @Override     public Map<K, V> makeObject() {         return new PassiveExpiringMap<>();     }      private Map<Integer, String> makeTestMap() {         final Map<Integer, String> m =                 new PassiveExpiringMap<>(new TestExpirationPolicy());         m.put(Integer.valueOf(1), "one");         m.put(Integer.valueOf(2), "two");         m.put(Integer.valueOf(3), "three");         m.put(Integer.valueOf(4), "four");         m.put(Integer.valueOf(5), "five");         m.put(Integer.valueOf(6), "six");         return m;     }      public void testConstructors() {         try {             final Map<String, String> map = null;             new PassiveExpiringMap<>(map);             fail("constructor - exception should have been thrown.");         } catch (final NullPointerException ex) {             // success         }          try {             final ExpirationPolicy<String, String> policy = null;             new PassiveExpiringMap<>(policy);             fail("constructor - exception should have been thrown.");         } catch (final NullPointerException ex) {             // success         }          try {             final TimeUnit unit = null;             new PassiveExpiringMap<String, String>(10L, unit);             fail("constructor - exception should have been thrown.");         } catch (final NullPointerException ex) {             // success         }     }      public void testContainsKey() {         final Map<Integer, String> m = makeTestMap();         assertFalse(m.containsKey(Integer.valueOf(1)));         assertFalse(m.containsKey(Integer.valueOf(3)));         assertFalse(m.containsKey(Integer.valueOf(5)));         assertTrue(m.containsKey(Integer.valueOf(2)));         assertTrue(m.containsKey(Integer.valueOf(4)));         assertTrue(m.containsKey(Integer.valueOf(6)));     }      public void testContainsValue() {         final Map<Integer, String> m = makeTestMap();         assertFalse(m.containsValue("one"));         assertFalse(m.containsValue("three"));         assertFalse(m.containsValue("five"));         assertTrue(m.containsValue("two"));         assertTrue(m.containsValue("four"));         assertTrue(m.containsValue("six"));     }      public void testDecoratedMap() {         // entries shouldn't expire         final Map<Integer, String> m = makeDecoratedTestMap();         assertEquals(6, m.size());         assertEquals("one", m.get(Integer.valueOf(1)));          // removing a single item shouldn't affect any other items         assertEquals("two", m.get(Integer.valueOf(2)));         m.remove(Integer.valueOf(2));         assertEquals(5, m.size());         assertEquals("one", m.get(Integer.valueOf(1)));         assertNull(m.get(Integer.valueOf(2)));          // adding a single, even item shouldn't affect any other items         assertNull(m.get(Integer.valueOf(2)));         m.put(Integer.valueOf(2), "two");         assertEquals(6, m.size());         assertEquals("one", m.get(Integer.valueOf(1)));         assertEquals("two", m.get(Integer.valueOf(2)));          // adding a single, odd item (one that expires) shouldn't affect any         // other items         // put the entry expires immediately         m.put(Integer.valueOf(1), "one-one");         assertEquals(5, m.size());         assertNull(m.get(Integer.valueOf(1)));         assertEquals("two", m.get(Integer.valueOf(2)));     }      public void testEntrySet() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.entrySet().size());     }      public void testExpiration() {         validateExpiration(new PassiveExpiringMap<String, String>(500), 500);         validateExpiration(new PassiveExpiringMap<String, String>(1000), 1000);         validateExpiration(new PassiveExpiringMap<>(                 new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<String, String>(500)), 500);         validateExpiration(new PassiveExpiringMap<>(                 new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<String, String>(1, TimeUnit.SECONDS)), 1000);     }      public void testGet() {         final Map<Integer, String> m = makeTestMap();         assertNull(m.get(Integer.valueOf(1)));         assertEquals("two", m.get(Integer.valueOf(2)));         assertNull(m.get(Integer.valueOf(3)));         assertEquals("four", m.get(Integer.valueOf(4)));         assertNull(m.get(Integer.valueOf(5)));         assertEquals("six", m.get(Integer.valueOf(6)));     }      public void testIsEmpty() {         Map<Integer, String> m = makeTestMap();         assertFalse(m.isEmpty());          // remove just evens         m = makeTestMap();         m.remove(Integer.valueOf(2));         m.remove(Integer.valueOf(4));         m.remove(Integer.valueOf(6));         assertTrue(m.isEmpty());     }      public void testKeySet() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.keySet().size());     }      public void testPut() {         final Map<Integer, String> m = makeTestMap();         assertNull(m.put(Integer.valueOf(1), "ONE"));         assertEquals("two", m.put(Integer.valueOf(2), "TWO"));         assertNull(m.put(Integer.valueOf(3), "THREE"));         assertEquals("four", m.put(Integer.valueOf(4), "FOUR"));         assertNull(m.put(Integer.valueOf(5), "FIVE"));         assertEquals("six", m.put(Integer.valueOf(6), "SIX"));     }      public void testSize() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.size());     }      public void testValues() {         final Map<Integer, String> m = makeTestMap();         assertEquals(3, m.values().size());     }      public void testZeroTimeToLive() {         // item should not be available         final PassiveExpiringMap<String, String> m = new PassiveExpiringMap<>(0L);         m.put("a", "b");         assertNull(m.get("a"));     }      private void validateExpiration(final Map<String, String> map, final long timeout) {         map.put("a", "b");          assertNotNull(map.get("a"));          try {             Thread.sleep(2 * timeout);         } catch (final InterruptedException e) {             fail();         }          assertNull(map.get("a"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.HashMap;  import junit.framework.Test; import org.apache.commons.collections4.BoundedMap; import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.KeyValue; import org.apache.commons.collections4.OrderedMap;  /**  * JUnit tests.  *  */ public class SingletonMapTest<K, V> extends AbstractOrderedMapTest<K, V> {      private static final Integer ONE = Integer.valueOf(1);     private static final Integer TWO = Integer.valueOf(2);     private static final String TEN = "10";      public SingletonMapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(SingletonMapTest.class);     }      //-----------------------------------------------------------------------     @Override     public OrderedMap<K, V> makeObject() {         // need an empty singleton map, but thats not possible         // use a ridiculous fake instead to make the tests pass         return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));     }      @Override     public String[] ignoredTests() {         // the ridiculous map above still doesn't pass these tests         // but its not relevant, so we ignore them         return new String[] {             "SingletonMapTest.bulkTestMapIterator.testEmptyMapIterator",             "SingletonMapTest.bulkTestOrderedMapIterator.testEmptyMapIterator",         };     }      @Override     @SuppressWarnings("unchecked")     public SingletonMap<K, V> makeFullMap() {         return new SingletonMap<>((K) ONE, (V) TWO);     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     @SuppressWarnings("unchecked")     public K[] getSampleKeys() {         return (K[]) new Object[] { ONE };     }      @Override     @SuppressWarnings("unchecked")     public V[] getSampleValues() {         return (V[]) new Object[] { TWO };     }      @Override     @SuppressWarnings("unchecked")     public V[] getNewSampleValues() {         return (V[]) new Object[] { TEN };     }      //-----------------------------------------------------------------------     public void testClone() {         final SingletonMap<K, V> map = makeFullMap();         assertEquals(1, map.size());         final SingletonMap<K, V> cloned = map.clone();         assertEquals(1, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsValue(TWO));     }      public void testKeyValue() {         final SingletonMap<K, V> map = makeFullMap();         assertEquals(1, map.size());         assertEquals(ONE, map.getKey());         assertEquals(TWO, map.getValue());         assertTrue(map instanceof KeyValue);     }      public void testBoundedMap() {         final SingletonMap<K, V> map = makeFullMap();         assertEquals(1, map.size());         assertEquals(true, map.isFull());         assertEquals(1, map.maxSize());         assertTrue(map instanceof BoundedMap);     }      //----------------------------------------------------------------------- //    public BulkTest bulkTestMapIterator() { //        return new TestFlatMapIterator(); //    } // //    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator { //        public TestFlatMapIterator() { //            super("TestFlatMapIterator"); //        } // //        public Object[] addSetValues() { //            return TestSingletonMap.this.getNewSampleValues(); //        } // //        public boolean supportsRemove() { //            return TestSingletonMap.this.isRemoveSupported(); //        } // //        public boolean supportsSetValue() { //            return TestSingletonMap.this.isSetValueSupported(); //        } // //        public MapIterator makeEmptyMapIterator() { //            resetEmpty(); //            return ((Flat3Map) TestSingletonMap.this.map).mapIterator(); //        } // //        public MapIterator makeFullMapIterator() { //            resetFull(); //            return ((Flat3Map) TestSingletonMap.this.map).mapIterator(); //        } // //        public Map getMap() { //            // assumes makeFullMapIterator() called first //            return TestSingletonMap.this.map; //        } // //        public Map getConfirmedMap() { //            // assumes makeFullMapIterator() called first //            return TestSingletonMap.this.confirmed; //        } // //        public void verify() { //            super.verify(); //            TestSingletonMap.this.verify(); //        } //    }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/SingletonMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/SingletonMap.fullCollection.version4.obj"); //    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.lang.ref.WeakReference; import java.util.Iterator; import java.util.Map;  import junit.framework.Test;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;  /**  * Tests for ReferenceIdentityMap.  *  */ public class ReferenceIdentityMapTest<K, V> extends AbstractIterableMapTest<K, V> {      private static final Integer I1A = new Integer(1); // Cannot use valueOf here     private static final Integer I1B = new Integer(1);     private static final Integer I2A = new Integer(2);     private static final Integer I2B = new Integer(2);      @SuppressWarnings("unused")     private static void gc() {         try {             // trigger GC             final byte[][] tooLarge = new byte[1000000000][1000000000];             fail("you have too much RAM");         } catch (final OutOfMemoryError ex) {             System.gc(); // ignore         }     }      public static Test suite() {         return BulkTest.makeSuite(ReferenceIdentityMapTest.class);     }      WeakReference<K> keyReference;      WeakReference<V> valueReference;      public ReferenceIdentityMapTest(final String testName) {         super(testName);     }      @SuppressWarnings("unchecked")     private Map<K, V> buildRefMap() {         final K key = (K) new Object();         final V value = (V) new Object();          keyReference = new WeakReference<>(key);         valueReference = new WeakReference<>(value);          final Map<K, V> testMap = new ReferenceIdentityMap<>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);         testMap.put(key, value);          assertEquals("In map", value, testMap.get(key));         assertNotNull("Weak reference released early (1)", keyReference.get());         assertNotNull("Weak reference released early (2)", valueReference.get());         return testMap;     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceIdentityMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/ReferenceIdentityMap.fullCollection.version4.obj"); //    }      @Override     public boolean isAllowNullKey() {         return false;     }      @Override     public boolean isAllowNullValue() {         return false;     }      @Override     public Map<K, V> makeConfirmedMap() {         // Testing against another [collections] class generally isn't a good idea,         // but the closest alternative is IdentityHashMap, which propagates reference-equality down to keySet and values.         // arguably ReferenceIdentityMap should do the same but that's a later discussion.         return new IdentityMap<>();     }  /*     // Tests often fail because gc is uncontrollable      public void testPurge() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < hard.length; i++) {             hard[i] = new Object();             map.put(hard[i], new Object());         }         gc();         assertTrue("map should be empty after purge of weak values", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);         }         gc();         assertTrue("map should be empty after purge of weak keys", map.isEmpty());          for (int i = 0; i < hard.length; i++) {             map.put(new Object(), hard[i]);             map.put(hard[i], new Object());         }          gc();         assertTrue("map should be empty after purge of weak keys and values", map.isEmpty());     }       public void testGetAfterGC() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         for (int i = 0; i < 10; i++) {             map.put(Integer.valueOf(i), Integer.valueOf(i));         }          gc();         for (int i = 0; i < 10; i++) {             Integer I = Integer.valueOf(i);             assertTrue("map.containsKey should return false for GC'd element", !map.containsKey(I));             assertTrue("map.get should return null for GC'd element", map.get(I) == null);         }     }       public void testEntrySetIteratorAfterGC() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         Iterator iterator = map.entrySet().iterator();         while (iterator.hasNext()) {             Map.Entry entry = (Map.Entry)iterator.next();             Integer key = (Integer)entry.getKey();             Integer value = (Integer)entry.getValue();             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          gc();         MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      }      public void testMapIteratorAfterGC2() {         ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);         Object[] hard = new Object[10];         for (int i = 0; i < 10; i++) {             hard[i] = Integer.valueOf(10 + i);             map.put(Integer.valueOf(i), Integer.valueOf(i));             map.put(hard[i], hard[i]);         }          MapIterator iterator = map.mapIterator();         while (iterator.hasNext()) {             Object key1 = iterator.next();             gc();             Integer key = (Integer) iterator.getKey();             Integer value = (Integer) iterator.getValue();             assertTrue("iterator keys should match", key == key1);             assertTrue("iterator should skip GC'd keys", key.intValue() >= 10);             assertTrue("iterator should skip GC'd values", value.intValue() >= 10);         }      } */      @Override     public ReferenceIdentityMap<K, V> makeObject() {         return new ReferenceIdentityMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);     }      @SuppressWarnings("unchecked")     public void testBasics() {         final IterableMap<K, V> map = new ReferenceIdentityMap<>(ReferenceStrength.HARD, ReferenceStrength.HARD);         assertEquals(0, map.size());          map.put((K) I1A, (V) I2A);         assertEquals(1, map.size());         assertSame(I2A, map.get(I1A));         assertSame(null, map.get(I1B));         assertEquals(true, map.containsKey(I1A));         assertEquals(false, map.containsKey(I1B));         assertEquals(true, map.containsValue(I2A));         assertEquals(false, map.containsValue(I2B));          map.put((K) I1A, (V) I2B);         assertEquals(1, map.size());         assertSame(I2B, map.get(I1A));         assertSame(null, map.get(I1B));         assertEquals(true, map.containsKey(I1A));         assertEquals(false, map.containsKey(I1B));         assertEquals(false, map.containsValue(I2A));         assertEquals(true, map.containsValue(I2B));          map.put((K) I1B, (V) I2B);         assertEquals(2, map.size());         assertSame(I2B, map.get(I1A));         assertSame(I2B, map.get(I1B));         assertEquals(true, map.containsKey(I1A));         assertEquals(true, map.containsKey(I1B));         assertEquals(false, map.containsValue(I2A));         assertEquals(true, map.containsValue(I2B));     }      @SuppressWarnings("unchecked")     public void testHashEntry() {         final IterableMap<K, V> map = new ReferenceIdentityMap<>(ReferenceStrength.HARD, ReferenceStrength.HARD);          map.put((K) I1A, (V) I2A);         map.put((K) I1B, (V) I2A);          final Map.Entry<K, V> entry1 = map.entrySet().iterator().next();         final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         final Map.Entry<K, V> entry2 = it.next();         final Map.Entry<K, V> entry3 = it.next();          assertEquals(true, entry1.equals(entry2));         assertEquals(true, entry2.equals(entry1));         assertEquals(false, entry1.equals(entry3));     }      @SuppressWarnings("unchecked")     public void testNullHandling() {         resetFull();         assertEquals(null, getMap().get(null));         assertEquals(false, getMap().containsKey(null));         assertEquals(false, getMap().containsValue(null));         assertEquals(null, getMap().remove(null));         assertEquals(false, getMap().entrySet().contains(null));         assertEquals(false, getMap().keySet().contains(null));         assertEquals(false, getMap().values().contains(null));         try {             getMap().put(null, null);             fail();         } catch (final NullPointerException ex) {}         try {             getMap().put((K) new Object(), null);             fail();         } catch (final NullPointerException ex) {}         try {             getMap().put(null, (V) new Object());             fail();         } catch (final NullPointerException ex) {}     }      /** Tests whether purge values setting works */     public void testPurgeValues() throws Exception {         // many thanks to Juozas Baliuka for suggesting this method         final Map<K, V> testMap = buildRefMap();          int iterations = 0;         int bytz = 2;         while (true) {             System.gc();             if (iterations++ > 50) {                 fail("Max iterations reached before resource released.");             }             testMap.isEmpty();             if (                 keyReference.get() == null &&                 valueReference.get() == null) {                 break;              }             // create garbage:             @SuppressWarnings("unused")             final byte[] b =  new byte[bytz];             bytz = bytz * 2;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.HashMap; import java.util.Iterator; import java.util.Map;  import org.apache.commons.collections4.BulkTest; import org.apache.commons.collections4.IterableMap; import org.apache.commons.collections4.MapIterator; import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;  import junit.framework.Test;  /**  * JUnit tests.  *  */ public class Flat3MapTest<K, V> extends AbstractIterableMapTest<K, V> {      private static final Integer ONE = Integer.valueOf(1);     private static final Integer TWO = Integer.valueOf(2);     private static final Integer THREE = Integer.valueOf(3);     private static final String TEN = "10";     private static final String TWENTY = "20";     private static final String THIRTY = "30";      public Flat3MapTest(final String testName) {         super(testName);     }      public static Test suite() {         return BulkTest.makeSuite(Flat3MapTest.class);     }      @Override     public Flat3Map<K, V> makeObject() {         return new Flat3Map<>();     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEquals1() {         final Flat3Map<K, V> map1 = makeObject();         map1.put((K) "a", (V) "testA");         map1.put((K) "b", (V) "testB");         final Flat3Map<K, V> map2 = makeObject();         map2.put((K) "a", (V) "testB");         map2.put((K) "b", (V) "testA");         assertEquals(false, map1.equals(map2));     }      @SuppressWarnings("unchecked")     public void testEquals2() {         final Flat3Map<K, V> map1 = makeObject();         map1.put((K) "a", (V) "testA");         map1.put((K) "b", (V) "testB");         final Flat3Map<K, V> map2 = makeObject();         map2.put((K) "a", (V) "testB");         map2.put((K) "c", (V) "testA");         assertEquals(false, map1.equals(map2));     }      @SuppressWarnings("unchecked")     public void testClone2() {         final Flat3Map<K, V> map = makeObject();         assertEquals(0, map.size());         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         assertEquals(2, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertSame(TEN, map.get(ONE));         assertSame(TWENTY, map.get(TWO));          // clone works (size = 2)         final Flat3Map<K, V> cloned = map.clone();         assertEquals(2, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));          // change original doesn't change clone         map.put((K) TEN, (V) ONE);         map.put((K) TWENTY, (V) TWO);         assertEquals(4, map.size());         assertEquals(2, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));     }      @SuppressWarnings("unchecked")     public void testClone4() {         final Flat3Map<K, V> map = makeObject();         assertEquals(0, map.size());         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) TEN, (V) ONE);         map.put((K) TWENTY, (V) TWO);          // clone works (size = 4)         final Flat3Map<K, V> cloned = map.clone();         assertEquals(4, map.size());         assertEquals(4, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertEquals(true, cloned.containsKey(TEN));         assertEquals(true, cloned.containsKey(TWENTY));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));         assertSame(ONE, cloned.get(TEN));         assertSame(TWO, cloned.get(TWENTY));          // change original doesn't change clone         map.clear();         assertEquals(0, map.size());         assertEquals(4, cloned.size());         assertEquals(true, cloned.containsKey(ONE));         assertEquals(true, cloned.containsKey(TWO));         assertEquals(true, cloned.containsKey(TEN));         assertEquals(true, cloned.containsKey(TWENTY));         assertSame(TEN, cloned.get(ONE));         assertSame(TWENTY, cloned.get(TWO));         assertSame(ONE, cloned.get(TEN));         assertSame(TWO, cloned.get(TWENTY));     }      public void testSerialisation0() throws Exception {         final Flat3Map<K, V> map = makeObject();         final ByteArrayOutputStream bout = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(bout);         out.writeObject(map);         final byte[] bytes = bout.toByteArray();         out.close();         final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);         final ObjectInputStream in = new ObjectInputStream(bin);         final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();         in.close();         assertEquals(0, map.size());         assertEquals(0, ser.size());     }      @SuppressWarnings("unchecked")     public void testSerialisation2() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);          final ByteArrayOutputStream bout = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(bout);         out.writeObject(map);         final byte[] bytes = bout.toByteArray();         out.close();         final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);         final ObjectInputStream in = new ObjectInputStream(bin);         final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();         in.close();         assertEquals(2, map.size());         assertEquals(2, ser.size());         assertEquals(true, ser.containsKey(ONE));         assertEquals(true, ser.containsKey(TWO));         assertEquals(TEN, ser.get(ONE));         assertEquals(TWENTY, ser.get(TWO));     }      @SuppressWarnings("unchecked")     public void testSerialisation4() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) TEN, (V) ONE);         map.put((K) TWENTY, (V) TWO);          final ByteArrayOutputStream bout = new ByteArrayOutputStream();         final ObjectOutputStream out = new ObjectOutputStream(bout);         out.writeObject(map);         final byte[] bytes = bout.toByteArray();         out.close();         final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);         final ObjectInputStream in = new ObjectInputStream(bin);         final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();         in.close();         assertEquals(4, map.size());         assertEquals(4, ser.size());         assertEquals(true, ser.containsKey(ONE));         assertEquals(true, ser.containsKey(TWO));         assertEquals(true, ser.containsKey(TEN));         assertEquals(true, ser.containsKey(TWENTY));         assertEquals(TEN, ser.get(ONE));         assertEquals(TWENTY, ser.get(TWO));         assertEquals(ONE, ser.get(TEN));         assertEquals(TWO, ser.get(TWENTY));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testEntryIteratorSetValue1() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         final Map.Entry<K, V> entry = it.next();         entry.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals("NewValue", map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testEntryIteratorSetValue2() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         it.next();         final Map.Entry<K, V> entry = it.next();         entry.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals("NewValue", map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testEntryIteratorSetValue3() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();         it.next();         it.next();         final Map.Entry<K, V> entry = it.next();         entry.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals("NewValue", map.get(THREE));     }      //-----------------------------------------------------------------------     @SuppressWarnings("unchecked")     public void testMapIteratorSetValue1() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final MapIterator<K, V> it = map.mapIterator();         it.next();         it.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals("NewValue", map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testMapIteratorSetValue2() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final MapIterator<K, V> it = map.mapIterator();         it.next();         it.next();         it.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals("NewValue", map.get(TWO));         assertEquals(THIRTY, map.get(THREE));     }      @SuppressWarnings("unchecked")     public void testMapIteratorSetValue3() throws Exception {         final Flat3Map<K, V> map = makeObject();         map.put((K) ONE, (V) TEN);         map.put((K) TWO, (V) TWENTY);         map.put((K) THREE, (V) THIRTY);          final MapIterator<K, V> it = map.mapIterator();         it.next();         it.next();         it.next();         it.setValue((V) "NewValue");         assertEquals(3, map.size());         assertEquals(true, map.containsKey(ONE));         assertEquals(true, map.containsKey(TWO));         assertEquals(true, map.containsKey(THREE));         assertEquals(TEN, map.get(ONE));         assertEquals(TWENTY, map.get(TWO));         assertEquals("NewValue", map.get(THREE));     }      public void testEntrySet() {         // Sanity check         putAndRemove(new HashMap<>());         // Actual test         putAndRemove(new Flat3Map<>());     }      private void putAndRemove(final Map<K, V> map) {         map.put((K) "A", (V) "one");         map.put((K) "B", (V) "two");         map.put((K) "C", (V) "three");         final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();          final Map.Entry<K, V> mapEntry1 = it.next();         final Map.Entry<K, V> mapEntry2 = it.next();         final Map.Entry<K, V> mapEntry3 = it.next();         it.remove();         assertEquals(2, map.size());         assertEquals("one", map.get("A"));         assertEquals("two", map.get("B"));         assertEquals(null, map.get("C"));     }      //-----------------------------------------------------------------------     @Override     public BulkTest bulkTestMapIterator() {         return new TestFlatMapIterator();     }      public class TestFlatMapIterator extends AbstractMapIteratorTest<K, V> {         public TestFlatMapIterator() {             super("TestFlatMapIterator");         }          @Override         public V[] addSetValues() {             return Flat3MapTest.this.getNewSampleValues();         }          @Override         public boolean supportsRemove() {             return Flat3MapTest.this.isRemoveSupported();         }          @Override         public boolean supportsSetValue() {             return Flat3MapTest.this.isSetValueSupported();         }          @Override         public MapIterator<K, V> makeEmptyIterator() {             resetEmpty();             return Flat3MapTest.this.getMap().mapIterator();         }          @Override         public MapIterator<K, V> makeObject() {             resetFull();             return Flat3MapTest.this.getMap().mapIterator();         }          @Override         public IterableMap<K, V> getMap() {             // assumes makeFullMapIterator() called first             return Flat3MapTest.this.getMap();         }          @Override         public Map<K, V> getConfirmedMap() {             // assumes makeFullMapIterator() called first             return Flat3MapTest.this.getConfirmed();         }          @Override         public void verify() {             super.verify();             Flat3MapTest.this.verify();         }     }      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/Flat3Map.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/Flat3Map.fullCollection.version4.obj"); //    }      public void testCollections261() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         m.put( Integer.valueOf(1), Integer.valueOf(1) );         m.put( Integer.valueOf(0), Integer.valueOf(0) );         assertEquals( Integer.valueOf(1), m.remove( Integer.valueOf(1) ) );         assertEquals( Integer.valueOf(0), m.remove( Integer.valueOf(0) ) );          m.put( Integer.valueOf(2), Integer.valueOf(2) );         m.put( Integer.valueOf(1), Integer.valueOf(1) );         m.put( Integer.valueOf(0), Integer.valueOf(0) );         assertEquals( Integer.valueOf(2), m.remove( Integer.valueOf(2) ) );         assertEquals( Integer.valueOf(1), m.remove( Integer.valueOf(1) ) );         assertEquals( Integer.valueOf(0), m.remove( Integer.valueOf(0) ) );     }      public void testToString() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         final String string0 = m.toString();         assertNotNull(string0);         m.put( Integer.valueOf(1), Integer.valueOf(1) );         final String string1 = m.toString();         assertNotNull(string1);         assertNotSame(string0, string1);         m.put( Integer.valueOf(0), Integer.valueOf(0) );         final String string2 = m.toString();         assertNotNull(string2);         assertNotSame(string0, string2);         assertNotSame(string1, string2);         m.put( Integer.valueOf(2), Integer.valueOf(2) );         final String string3 = m.toString();         assertNotNull(string3);         assertNotSame(string0, string3);         assertNotSame(string1, string3);         assertNotSame(string2, string3);     }      public void testRemove1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          // object is not existing         Object obj = m.remove(44);         assertNull(obj);          m.put(ONE, ONE);         obj = m.remove(ONE);         assertSame(ONE, obj);         assertEquals(0, m.size());          // after removal, be no longer there         obj = m.get(ONE);         assertNull(obj);          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(ONE);         assertSame(ONE, obj);          obj = m.get(ONE);         assertNull(obj);         obj = m.get(TWO);         assertSame(TWO, obj);     }      public void testRemove2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(ONE);         assertSame(ONE, obj);          obj = m.get(ONE);         assertNull(obj);         obj = m.get(TWO);         assertSame(TWO, obj);         obj = m.get(THREE);         assertSame(THREE, obj);     }      public void testRemove3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(TWO);         assertSame(TWO, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(TWO);         assertNull(obj);         obj = m.get(THREE);         assertSame(THREE, obj);     }      public void testRemove4() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(THREE);         assertSame(THREE, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(TWO);         assertSame(TWO, obj);         obj = m.get(THREE);         assertNull(obj);     }      public void testRemove5() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(null, ONE);          obj = m.remove(null);         assertSame(ONE, obj);          obj = m.get(null);         assertNull(obj);     }      public void testRemove6() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(null, TWO);          obj = m.remove(null);         assertSame(TWO, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(null);         assertNull(obj);     }      public void testRemove7() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(null, ONE);         m.put(TWO, TWO);          obj = m.remove(null);         assertSame(ONE, obj);          obj = m.get(null);         assertNull(obj);         obj = m.get(TWO);         assertSame(TWO, obj);     }      public void testRemove8() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);          obj = m.remove(null);         assertSame(THREE, obj);          obj = m.get(ONE);         assertSame(ONE, obj);         obj = m.get(TWO);         assertSame(TWO, obj);         obj = m.get(null);         assertNull(obj);     }      public void testRemove9() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);          obj = m.remove(null);         assertNull(obj);     }      public void testRemove10() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);          obj = m.remove(null);         assertNull(obj);     }      public void testRemove11() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(null);         assertNull(obj);     }      public void testRemove12() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);          obj = m.remove(42);         assertNull(obj);     }      public void testRemove13() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);          obj = m.remove(42);         assertNull(obj);     }      public void testNewInstance1() {         final Map<Integer, Integer> orig = new HashMap<>();         orig.put(ONE, ONE);         orig.put(TWO, TWO);          final Flat3Map<Integer, Integer> m = new Flat3Map<>(orig);          assertEquals(orig, m);         assertEquals(2, m.size());     }      public void testGet1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(null, ONE);         obj = m.get(null);         assertSame(ONE, obj);     }      public void testGet2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(null, TWO);         obj = m.get(null);         assertSame(TWO, obj);     }      public void testGet3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();         Object obj;          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);         obj = m.get(null);         assertSame(THREE, obj);     }      public void testContainsKey1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);         final boolean contains = m.containsKey(null);         assertEquals(true, contains);     }      public void testContainsKey2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(null, TWO);         final boolean contains = m.containsKey(null);         assertEquals(true, contains);     }      public void testContainsKey3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(null, ONE);         final boolean contains = m.containsKey(null);         assertEquals(true, contains);     }      public void testContainsValue1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, null);         final boolean contains = m.containsValue(null);         assertEquals(true, contains);     }      public void testContainsValue2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, null);         final boolean contains = m.containsValue(null);         assertEquals(true, contains);     }      public void testContainsValue3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, null);         final boolean contains = m.containsValue(null);         assertEquals(true, contains);     }      public void testPut1() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(null, THREE);         final Object old = m.put(null, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(null));     }      public void testPut2() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(null, THREE);         final Object old = m.put(null, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(null));     }      public void testPut3() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(null, THREE);         final Object old = m.put(null, ONE);         assertEquals(THREE, old);         assertEquals(null, m.get(ONE));     }      public void testPut4() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, TWO);         m.put(THREE, THREE);         final Object old = m.put(THREE, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(THREE));     }      public void testPut5() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, ONE);         m.put(TWO, THREE);         final Object old = m.put(TWO, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(TWO));     }      public void testPut6() {         final Flat3Map<Integer, Integer> m = new Flat3Map<>();          m.put(ONE, THREE);         final Object old = m.put(ONE, ONE);         assertEquals(THREE, old);         assertEquals(ONE, m.get(ONE));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.collections4.map;  import java.util.SortedMap; import java.util.TreeMap;  import org.apache.commons.collections4.Unmodifiable;  /**  * Extension of {@link AbstractSortedMapTest} for exercising the  * {@link UnmodifiableSortedMap} implementation.  *  * @since 3.0  */ public class UnmodifiableSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {      public UnmodifiableSortedMapTest(final String testName) {         super(testName);     }      //-------------------------------------------------------------------      @Override     public SortedMap<K, V> makeObject() {         return UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<K, V>());     }      @Override     public boolean isPutChangeSupported() {         return false;     }      @Override     public boolean isPutAddSupported() {         return false;     }      @Override     public boolean isRemoveSupported() {         return false;     }      @Override     public SortedMap<K, V> makeFullMap() {         final SortedMap<K, V> m = new TreeMap<>();         addSampleMappings(m);         return UnmodifiableSortedMap.unmodifiableSortedMap(m);     }      //-----------------------------------------------------------------------      public void testUnmodifiable() {         assertTrue(makeObject() instanceof Unmodifiable);         assertTrue(makeFullMap() instanceof Unmodifiable);     }      public void testDecorateFactory() {         final SortedMap<K, V> map = makeFullMap();         assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));          try {             UnmodifiableSortedMap.unmodifiableSortedMap(null);             fail();         } catch (final NullPointerException ex) {}     }      //-----------------------------------------------------------------------      public void testHeadMap() {         final SortedMap<K, V> map = makeFullMap();         final SortedMap<K, V> m = new TreeMap<>();         // "again" is the first key of the map         assertSame(m.isEmpty(), map.headMap((K) "again").isEmpty());         assertSame(18, map.size());         // "you" is the last key of the map         assertSame(17, map.headMap((K) "you").size());         // "we'll" is the before key of "you"         assertSame(16, map.headMap((K) "we'll").size());     }      //-----------------------------------------------------------------------      public void testTailMap() {         final SortedMap<K, V> map = makeFullMap();          assertSame(18, map.size());         // "you" is the last key of the map         assertSame(1, map.tailMap((K) "you").size());         // "we'll" is the before key of "you"         assertSame(2, map.tailMap((K) "we'll").size());         // "again" is the first key of the map         assertSame(18, map.tailMap((K) "again").size());     }      //-----------------------------------------------------------------------      public void testSubMap() {         final SortedMap<K, V> map = makeFullMap();          assertSame(18, map.size());         // get the sub map from again to you(exclusive)         assertSame(17, map.subMap((K) "again", (K) "you").size());         // get the sub map from again to we'll(exclusive)         assertSame(16, map.subMap((K) "again", (K) "we'll").size());         // "again" is the first key of the map         assertSame(0, map.subMap((K) "again", (K) "again").size());          assertSame(map.headMap((K) "you").size(), map.subMap((K) "again", (K) "you").size());     }      //-----------------------------------------------------------------------      @Override     public String getCompatibilityVersion() {         return "4";     }  //    public void testCreate() throws Exception { //        resetEmpty(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableSortedMap.emptyCollection.version4.obj"); //        resetFull(); //        writeExternalFormToDisk( //            (java.io.Serializable) map, //            "src/test/resources/data/test/UnmodifiableSortedMap.fullCollection.version4.obj"); //    }  } 
