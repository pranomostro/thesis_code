/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import org.junit.Assert; import org.junit.Test;  public class OnePointCrossoverTest {      @Test     public void testCrossover() {         @SuppressWarnings("boxing")         Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         @SuppressWarnings("boxing")         Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};          BinaryChromosome p1c = new DummyBinaryChromosome(p1);         BinaryChromosome p2c = new DummyBinaryChromosome(p2);          OnePointCrossover<Integer> opc = new OnePointCrossover<>();          // how to test a stochastic method?         for (int i=0; i<20; i++) {             ChromosomePair pair = opc.crossover(p1c,p2c);              Integer[] c1 = new Integer[p1.length];             Integer[] c2 = new Integer[p2.length];              c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);             c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);              // first and last values will be the same             Assert.assertEquals(p1[0],  c1[0]);             Assert.assertEquals(p2[0], c2[0]);             Assert.assertEquals(p1[p1.length-1], c1[c1.length-1]);             Assert.assertEquals(p2[p2.length-1], c2[c2.length-1]);             // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same             Assert.assertEquals(p1[2], c1[2]);             Assert.assertEquals(p2[2], c2[2]);             Assert.assertEquals(p1[3], c1[3]);             Assert.assertEquals(p2[3], c2[3]);             Assert.assertEquals(p1[7], c1[7]);             Assert.assertEquals(p2[7], c2[7]);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.ArrayList; import java.util.Iterator;  import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Test;  public class ListPopulationTest {      @Test     public void testGetFittestChromosome() {         Chromosome c1 = new Chromosome() {             @Override             public double fitness() {                 return 0;             }         };         Chromosome c2 = new Chromosome() {             @Override             public double fitness() {                 return 10;             }         };         Chromosome c3 = new Chromosome() {             @Override             public double fitness() {                 return 15;             }         };          ArrayList<Chromosome> chromosomes = new ArrayList<> ();         chromosomes.add(c1);         chromosomes.add(c2);         chromosomes.add(c3);          ListPopulation population = new ListPopulation(chromosomes, 10) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          Assert.assertEquals(c3, population.getFittestChromosome());     }      @Test     public void testChromosomes() {         final ArrayList<Chromosome> chromosomes = new ArrayList<> ();         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));          final ListPopulation population = new ListPopulation(10) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          population.addChromosomes(chromosomes);          Assert.assertEquals(chromosomes, population.getChromosomes());         Assert.assertEquals(chromosomes.toString(), population.toString());          population.setPopulationLimit(50);         Assert.assertEquals(50, population.getPopulationLimit());     }      @Test(expected = NotPositiveException.class)     public void testSetPopulationLimit() {         final ListPopulation population = new ListPopulation(10) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          population.setPopulationLimit(-50);     }      @Test(expected = NotPositiveException.class)     public void testConstructorPopulationLimitNotPositive() {         new ListPopulation(-10) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };     }      @Test(expected = NotPositiveException.class)     public void testChromosomeListConstructorPopulationLimitNotPositive() {         final ArrayList<Chromosome> chromosomes = new ArrayList<> ();         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         new ListPopulation(chromosomes, -10) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };     }      @Test(expected = NumberIsTooLargeException.class)     public void testConstructorListOfChromosomesBiggerThanPopulationSize() {         final ArrayList<Chromosome> chromosomes = new ArrayList<> ();         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         new ListPopulation(chromosomes, 1) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };     }      @Test(expected=NumberIsTooLargeException.class)     public void testAddTooManyChromosomes() {         final ArrayList<Chromosome> chromosomes = new ArrayList<> ();         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));          final ListPopulation population = new ListPopulation(2) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          population.addChromosomes(chromosomes);     }      @Test(expected=NumberIsTooLargeException.class)     public void testAddTooManyChromosomesSingleCall() {          final ListPopulation population = new ListPopulation(2) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          for (int i = 0; i <= population.getPopulationLimit(); i++) {             population.addChromosome(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         }     }      @Test(expected = UnsupportedOperationException.class)     public void testIterator() {         final ArrayList<Chromosome> chromosomes = new ArrayList<>();         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));          final ListPopulation population = new ListPopulation(10) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          population.addChromosomes(chromosomes);          final Iterator<Chromosome> iter = population.iterator();         while (iter.hasNext()) {             iter.next();             iter.remove();         }     }      @Test(expected=NumberIsTooSmallException.class)     public void testSetPopulationLimitTooSmall() {         final ArrayList<Chromosome> chromosomes = new ArrayList<> ();         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));         chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));          final ListPopulation population = new ListPopulation(chromosomes, 3) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          population.setPopulationLimit(2);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  public class CycleCrossoverTest {      @Test     public void testCrossoverExample() {         // taken from http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx         final Integer[] p1 = new Integer[] { 8, 4, 7, 3, 6, 2, 5, 1, 9, 0 };         final Integer[] p2 = new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };         final DummyListChromosome p1c = new DummyListChromosome(p1);         final DummyListChromosome p2c = new DummyListChromosome(p2);          final CrossoverPolicy cp = new CycleCrossover<Integer>();         final ChromosomePair pair = cp.crossover(p1c, p2c);          final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);         final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);          final Integer[] c1e = new Integer[] { 8, 1, 2, 3, 4, 5, 6, 7, 9, 0 };         final Integer[] c2e = new Integer[] { 0, 4, 7, 3, 6, 2, 5, 1, 8, 9 };          Assert.assertArrayEquals(c1e, c1);         Assert.assertArrayEquals(c2e, c2);     }      @Test     public void testCrossoverExample2() {         // taken from http://www.scribd.com/doc/54206412/32/Cycle-crossover         final Integer[] p1 = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };         final Integer[] p2 = new Integer[] { 9, 3, 7, 8, 2, 6, 5, 1, 4};         final DummyListChromosome p1c = new DummyListChromosome(p1);         final DummyListChromosome p2c = new DummyListChromosome(p2);          final CrossoverPolicy cp = new CycleCrossover<Integer>();         final ChromosomePair pair = cp.crossover(p1c, p2c);          final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);         final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);          final Integer[] c1e = new Integer[] { 1, 3, 7, 4, 2, 6, 5, 8, 9 };         final Integer[] c2e = new Integer[] { 9, 2, 3, 8, 5, 6, 7, 1, 4 };          Assert.assertArrayEquals(c1e, c1);         Assert.assertArrayEquals(c2e, c2);     }      @Test     public void testCrossover() {         final Integer[] p1 = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };         final Integer[] p2 = new Integer[] { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };         final DummyListChromosome p1c = new DummyListChromosome(p1);         final DummyListChromosome p2c = new DummyListChromosome(p2);          final CrossoverPolicy cp = new CycleCrossover<Integer>(true);          for (int i = 0; i < 20; i++) {             final ChromosomePair pair = cp.crossover(p1c, p2c);              final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);             final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);              int index = 0;             // Determine if it is in the same spot as in the first parent, if             // not it comes from the second parent.             for (final Integer j : c1) {                 if (!p1[index].equals(j)) {                     Assert.assertEquals(j, p2[index]);                 } else {                     Assert.assertEquals(j, p1[index]);                 }                 index++;             }              // Same as above only for the second parent.             index = 0;             for (final Integer k : c2) {                 if (p2[index] != k) {                     Assert.assertEquals(k, p1[index]);                 } else {                     Assert.assertEquals(k, p2[index]);                 }                 index++;             }         }     }      @Test(expected = DimensionMismatchException.class)     public void testCrossoverDimensionMismatchException() {         final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };         final Integer[] p2 = new Integer[] { 0, 1, 1, 0, 1 };          final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final BinaryChromosome p2c = new DummyBinaryChromosome(p2);          final CrossoverPolicy cp = new CycleCrossover<Integer>();         cp.crossover(p1c, p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeFirst() {         final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };         final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final Chromosome p2c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new CycleCrossover<Integer>();         cp.crossover(p1c, p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeSecond() {         final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };         final BinaryChromosome p2c = new DummyBinaryChromosome(p1);         final Chromosome p1c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new CycleCrossover<Integer>();         cp.crossover(p1c, p2c);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.LinkedList; import java.util.List;  import org.junit.Assert; import org.junit.Test;   public class FitnessCachingTest {      // parameters for the GA     private static final int DIMENSION = 50;     private static final double CROSSOVER_RATE = 1;     private static final double MUTATION_RATE = 0.1;     private static final int TOURNAMENT_ARITY = 5;      private static final int POPULATION_SIZE = 10;     private static final int NUM_GENERATIONS = 50;     private static final double ELITISM_RATE = 0.2;      // how many times was the fitness computed     private static int fitnessCalls = 0;       @Test     public void testFitnessCaching() {         // initialize a new genetic algorithm         GeneticAlgorithm ga = new GeneticAlgorithm(                 new OnePointCrossover<Integer>(),                 CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)                 new BinaryMutation(),                 MUTATION_RATE, // no mutation                 new TournamentSelection(TOURNAMENT_ARITY)         );          // initial population         Population initial = randomPopulation();         // stopping conditions         StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);          // run the algorithm         ga.evolve(initial, stopCond);          int neededCalls =             POPULATION_SIZE /*initial population*/ +             (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/             ;         Assert.assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones     }       /**      * Initializes a random population.      */     private static ElitisticListPopulation randomPopulation() {         List<Chromosome> popList = new LinkedList<>();          for (int i=0; i<POPULATION_SIZE; i++) {             BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION));             popList.add(randChrom);         }         return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);     }      private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome {          public DummyCountingBinaryChromosome(List<Integer> representation) {             super(representation);         }          @Override         public double fitness() {             fitnessCalls++;             return 0;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import java.util.List;  /**  * Implementation of RandomKey for testing purposes  */ public class DummyRandomKey extends RandomKey<String> {      public DummyRandomKey(List<Double> representation) {         super(representation);     }      public DummyRandomKey(Double[] representation) {         super(representation);     }      @Override     public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> chromosomeRepresentation) {         return new DummyRandomKey(chromosomeRepresentation);     }      @Override     public double fitness() {         // unimportant         return 0;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import java.util.Iterator; import java.util.concurrent.TimeUnit;  import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class FixedElapsedTimeTest {      @Test     public void testIsSatisfied() {         final Population pop = new Population() {             @Override             public void addChromosome(final Chromosome chromosome) {                 // unimportant             }             @Override             public Chromosome getFittestChromosome() {                 // unimportant                 return null;             }             @Override             public int getPopulationLimit() {                 // unimportant                 return 0;             }             @Override             public int getPopulationSize() {                 // unimportant                 return 0;             }             @Override             public Population nextGeneration() {                 // unimportant                 return null;             }             @Override             public Iterator<Chromosome> iterator() {                 // unimportant                 return null;             }         };          final long start = System.nanoTime();         final long duration = 3;         final FixedElapsedTime tec = new FixedElapsedTime(duration, TimeUnit.SECONDS);          while (!tec.isSatisfied(pop)) {             try {                 Thread.sleep(50);             } catch (InterruptedException e) {                 // ignore             }         }          final long end = System.nanoTime();         final long elapsedTime = end - start;         final long diff = FastMath.abs(elapsedTime - TimeUnit.SECONDS.toNanos(duration));          Assert.assertTrue(diff < TimeUnit.MILLISECONDS.toNanos(100));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.Iterator;  import org.junit.Assert; import org.junit.Test;  public class FixedGenerationCountTest {      @Test     public void testIsSatisfied() {         FixedGenerationCount fgc = new FixedGenerationCount(20);          int cnt = 0;         Population pop = new Population() {             @Override             public void addChromosome(Chromosome chromosome) {                 // unimportant             }             @Override             public Chromosome getFittestChromosome() {                 // unimportant                 return null;             }             @Override             public int getPopulationLimit() {                 // unimportant                 return 0;             }             @Override             public int getPopulationSize() {                 // unimportant                 return 0;             }             @Override             public Population nextGeneration() {                 // unimportant                 return null;             }             @Override             public Iterator<Chromosome> iterator() {                 // unimportant                 return null;             }         };          while (!fgc.isSatisfied(pop)) {             cnt++;         }         Assert.assertEquals(20, cnt);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.Collections; import java.util.List;  import org.apache.commons.math4.exception.OutOfRangeException; import org.junit.Assert; import org.junit.Test;  public class ElitisticListPopulationTest {      private static int counter = 0;      @Test     public void testNextGeneration() {         ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);          for (int i=0; i<pop.getPopulationLimit(); i++) {             pop.addChromosome(new DummyChromosome());         }          Population nextGeneration = pop.nextGeneration();          Assert.assertEquals(20, nextGeneration.getPopulationSize());     }      @Test     public void testSetElitismRate() {         final double rate = 0.25;         final ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);         pop.setElitismRate(rate);         Assert.assertEquals(rate, pop.getElitismRate(), 1e-6);     }      @Test(expected = OutOfRangeException.class)     public void testSetElitismRateTooLow() {         final double rate = -0.25;         final ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);         pop.setElitismRate(rate);     }      @Test(expected = OutOfRangeException.class)     public void testSetElitismRateTooHigh() {         final double rate = 1.25;         final ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);         pop.setElitismRate(rate);     }      @Test(expected = OutOfRangeException.class)     public void testConstructorTooLow() {         final double rate = -0.25;         new ElitisticListPopulation(100, rate);     }      @Test(expected = OutOfRangeException.class)     public void testConstructorTooHigh() {         final double rate = 1.25;         new ElitisticListPopulation(100, rate);     }      @Test(expected = OutOfRangeException.class)     public void testChromosomeListConstructorTooLow() {         final List<Chromosome> chromosomes = Collections.emptyList();         final double rate = -0.25;         new ElitisticListPopulation(chromosomes, 100, rate);     }      @Test(expected = OutOfRangeException.class)     public void testChromosomeListConstructorTooHigh() {         final List<Chromosome> chromosomes = Collections.emptyList();         final double rate = 1.25;         new ElitisticListPopulation(chromosomes, 100, rate);     }      private static class DummyChromosome extends Chromosome {         private final int fitness;          public DummyChromosome() {             this.fitness = counter;             counter++;         }          @Override         public double fitness() {             return this.fitness;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import java.util.ArrayList; import java.util.List;  import org.junit.Assert; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.OutOfRangeException; import org.junit.BeforeClass; import org.junit.Test;  public class UniformCrossoverTest {     private static final int LEN = 10000;     private static final List<Integer> p1 = new ArrayList<>(LEN);     private static final List<Integer> p2 = new ArrayList<>(LEN);      @SuppressWarnings("boxing")     @BeforeClass     public static void setUpBeforeClass() {         for (int i = 0; i < LEN; i++) {             p1.add(0);             p2.add(1);         }     }      @Test(expected = OutOfRangeException.class)     public void testRatioTooLow() {         new UniformCrossover<Integer>(-0.5d);     }      @Test(expected = OutOfRangeException.class)     public void testRatioTooHigh() {         new UniformCrossover<Integer>(1.5d);     }      @Test     public void testCrossover() {         // test crossover with different ratios         performCrossover(0.5);         performCrossover(0.7);         performCrossover(0.2);     }      private void performCrossover(double ratio) {         final DummyBinaryChromosome p1c = new DummyBinaryChromosome(p1);         final DummyBinaryChromosome p2c = new DummyBinaryChromosome(p2);          final CrossoverPolicy cp = new UniformCrossover<Integer>(ratio);          // make a number of rounds         for (int i = 0; i < 20; i++) {             final ChromosomePair pair = cp.crossover(p1c, p2c);              final List<Integer> c1 = ((DummyBinaryChromosome) pair.getFirst()).getRepresentation();             final List<Integer> c2 = ((DummyBinaryChromosome) pair.getSecond()).getRepresentation();              int from1 = 0;             int from2 = 0;              // check first child             for (int val : c1) {                 if (val == 0) {                     from1++;                 } else {                     from2++;                 }             }              Assert.assertEquals(1.0 - ratio, (double) from1 / LEN, 0.1);             Assert.assertEquals(ratio, (double) from2 / LEN, 0.1);              from1 = 0;             from2 = 0;              // check second child             for (int val : c2) {                 if (val == 0) {                     from1++;                 } else {                     from2++;                 }             }              Assert.assertEquals(ratio, (double) from1 / LEN, 0.1);             Assert.assertEquals(1.0 - ratio, (double) from2 / LEN, 0.1);         }     }      @Test(expected = DimensionMismatchException.class)     public void testCrossoverDimensionMismatchException(){         @SuppressWarnings("boxing")         final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         @SuppressWarnings("boxing")         final Integer[] p2 = new Integer[] {0,1,1,0,1};          final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final BinaryChromosome p2c = new DummyBinaryChromosome(p2);          final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d);         cp.crossover(p1c, p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeFirst() {         @SuppressWarnings("boxing")         final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final Chromosome p2c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d);         cp.crossover(p1c, p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeSecond() {         @SuppressWarnings("boxing")         final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         final BinaryChromosome p2c = new DummyBinaryChromosome(p1);         final Chromosome p1c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d);         cp.crossover(p1c, p2c);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import org.junit.Assert; import org.junit.Test;  public class RandomKeyMutationTest {      @Test     public void testMutate() {         MutationPolicy mutation = new RandomKeyMutation();         int l=10;         for (int i=0; i<20; i++) {             DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l));             Chromosome mutated = mutation.mutate(origRk);             DummyRandomKey mutatedRk = (DummyRandomKey) mutated;              int changes = 0;             for (int j=0; j<origRk.getLength(); j++) {                 if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) {                     changes++;                 }             }             Assert.assertEquals(1,changes);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import java.util.List;  /**  * Implementation of BinaryChromosome for testing purposes  */ public class DummyBinaryChromosome extends BinaryChromosome {      public DummyBinaryChromosome(List<Integer> representation) {         super(representation);     }      public DummyBinaryChromosome(Integer[] representation) {         super(representation);     }      @Override     public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> chromosomeRepresentation) {         return new DummyBinaryChromosome(chromosomeRepresentation);     }      @Override     public double fitness() {         // uninteresting         return 0;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import java.util.Arrays; import java.util.HashSet; import java.util.Set;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  public class OrderedCrossoverTest {      @Test     public void testCrossover() {         final Integer[] p1 = new Integer[] { 8, 4, 7, 3, 6, 2, 5, 1, 9, 0 };         final Integer[] p2 = new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };         final DummyListChromosome p1c = new DummyListChromosome(p1);         final DummyListChromosome p2c = new DummyListChromosome(p2);          final CrossoverPolicy cp = new OrderedCrossover<Integer>();          for (int i = 0; i < 20; i++) {             final Set<Integer> parentSet1 = new HashSet<>(Arrays.asList(p1));             final Set<Integer> parentSet2 = new HashSet<>(Arrays.asList(p2));              final ChromosomePair pair = cp.crossover(p1c, p2c);              final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);             final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);              Assert.assertNotSame(p1c, pair.getFirst());             Assert.assertNotSame(p2c, pair.getSecond());              // make sure that the children have exactly the same elements as their parents             for (int j = 0; j < c1.length; j++) {                 Assert.assertTrue(parentSet1.contains(c1[j]));                 parentSet1.remove(c1[j]);                 Assert.assertTrue(parentSet2.contains(c2[j]));                 parentSet2.remove(c2[j]);             }         }     }      @Test(expected = DimensionMismatchException.class)     public void testCrossoverDimensionMismatchException() {         final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };         final Integer[] p2 = new Integer[] { 0, 1, 1, 0, 1 };          final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final BinaryChromosome p2c = new DummyBinaryChromosome(p2);          final CrossoverPolicy cp = new OrderedCrossover<Integer>();         cp.crossover(p1c, p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeFirst() {         final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };         final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final Chromosome p2c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new OrderedCrossover<Integer>();         cp.crossover(p1c, p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeSecond() {         final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };         final BinaryChromosome p2c = new DummyBinaryChromosome(p1);         final Chromosome p1c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new OrderedCrossover<Integer>();         cp.crossover(p1c, p2c);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import org.junit.Assert; import org.junit.Test;  public class TournamentSelectionTest {      private static int counter = 0;      @Test     public void testSelect() {         TournamentSelection ts = new TournamentSelection(2);         ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);          for (int i=0; i<pop.getPopulationLimit(); i++) {             pop.addChromosome(new DummyChromosome());         }         // how to write a test for stochastic method?         for (int i=0; i<20; i++) {             ChromosomePair pair = ts.select(pop);             // the worst chromosome should NEVER be selected             Assert.assertTrue(pair.getFirst().getFitness() > 0);             Assert.assertTrue(pair.getSecond().getFitness() > 0);         }     }      private static class DummyChromosome extends Chromosome {         private final int fitness;          public DummyChromosome() {             this.fitness = counter;             counter++;         }          @Override         public double fitness() {             return this.fitness;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import java.util.List;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.junit.Assert; import org.junit.Test;  public class NPointCrossoverTest {      @Test(expected = DimensionMismatchException.class)     public void testCrossoverDimensionMismatchException() {         final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         final Integer[] p2 = new Integer[] {0,1,1,0,1};          final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final BinaryChromosome p2c = new DummyBinaryChromosome(p2);          final CrossoverPolicy cp = new NPointCrossover<Integer>(1);         cp.crossover(p1c,p2c);     }      @Test(expected = NumberIsTooLargeException.class)     public void testNumberIsTooLargeException() {         final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         final Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};          final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final BinaryChromosome p2c = new DummyBinaryChromosome(p2);          final CrossoverPolicy cp = new NPointCrossover<Integer>(15);         cp.crossover(p1c,p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeFirst() {         final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         final BinaryChromosome p1c = new DummyBinaryChromosome(p1);         final Chromosome p2c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new NPointCrossover<Integer>(1);         cp.crossover(p1c,p2c);     }      @Test(expected = MathIllegalArgumentException.class)     public void testCrossoverInvalidFixedLengthChromosomeSecond() {         final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};         final BinaryChromosome p2c = new DummyBinaryChromosome(p1);         final Chromosome p1c = new Chromosome() {             @Override             public double fitness() {                 // Not important                 return 0;             }         };          final CrossoverPolicy cp = new NPointCrossover<Integer>(1);         cp.crossover(p1c,p2c);     }      @Test     public void testCrossover() {         Integer[] p1 = new Integer[] {1,0,1,0,1,0,1,0,1};         Integer[] p2 = new Integer[] {0,1,0,1,0,1,0,1,0};          BinaryChromosome p1c = new DummyBinaryChromosome(p1);         BinaryChromosome p2c = new DummyBinaryChromosome(p2);          final int order = 3;         NPointCrossover<Integer> npc = new NPointCrossover<>(order);          // the two parent chromosomes are different at each position, so it is easy to detect         // the number of crossovers that happened for each child         for (int i=0; i<20; i++) {             ChromosomePair pair = npc.crossover(p1c,p2c);              Integer[] c1 = new Integer[p1.length];             Integer[] c2 = new Integer[p2.length];              c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);             c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);              Assert.assertEquals(order, detectCrossoverPoints(p1c, p2c, (BinaryChromosome) pair.getFirst()));             Assert.assertEquals(order, detectCrossoverPoints(p2c, p1c, (BinaryChromosome) pair.getSecond()));         }     }      private int detectCrossoverPoints(BinaryChromosome p1, BinaryChromosome p2, BinaryChromosome c) {         int crossovers = 0;         final int length = p1.getLength();          final List<Integer> p1Rep = p1.getRepresentation();         final List<Integer> p2Rep = p2.getRepresentation();         final List<Integer> cRep = c.getRepresentation();          List<Integer> rep = p1Rep;         for (int i = 0; i < length; i++) {             if (rep.get(i) != cRep.get(i)) {                 crossovers++;                 rep = rep == p1Rep ? p2Rep : p1Rep;             }         }          return crossovers;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;  import java.util.Arrays; import java.util.List;  /**  * Implementation of ListChromosome for testing purposes  */ public class DummyListChromosome extends AbstractListChromosome<Integer> {     public DummyListChromosome(final Integer[] representation) {         super(representation);     }      public DummyListChromosome(final List<Integer> representation) {         super(representation);     }      @Override     public double fitness() {         // Not important.         return 0;     }      @Override     protected void checkValidity(final List<Integer> chromosomeRepresentation) throws InvalidRepresentationException {         // Not important.     }      @Override     public AbstractListChromosome<Integer> newFixedLengthChromosome(final List<Integer> chromosomeRepresentation) {         return new DummyListChromosome(chromosomeRepresentation);     }      @Override     public int hashCode() {         final int prime = 31;         int result = 1;         result = prime * result + (getRepresentation() == null ? 0 : getRepresentation().hashCode());         return result;     }      @Override     public boolean equals(final Object obj) {         if (this == obj) {             return true;         }         if (obj == null) {             return false;         }         if (!(obj instanceof DummyListChromosome)) {             return false;         }         final DummyListChromosome other = (DummyListChromosome) obj;         if (getRepresentation() == null) {             if (other.getRepresentation() != null) {                 return false;             }         }         final Integer[] rep = getRepresentation().toArray(new Integer[getRepresentation().size()]);         final Integer[] otherRep = other.getRepresentation().toArray(new Integer[other.getRepresentation().size()]);         return Arrays.equals(rep, otherRep);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import org.junit.Assert; import org.junit.Test;  public class BinaryMutationTest {      @Test     public void testMutate() {         BinaryMutation mutation = new BinaryMutation();          // stochastic testing :)         for (int i=0; i<20; i++) {             DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));             DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original);              // one gene should be different             int numDifferent = 0;             for (int j=0; j<original.getRepresentation().size(); j++) {                 if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j)) {                     numDifferent++;                 }             }             Assert.assertEquals(1, numDifferent);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.ArrayList; import java.util.List;  import org.junit.Assert; import org.junit.Test;  public class ChromosomeTest {      @Test     public void testCompareTo() {         Chromosome c1 = new Chromosome() {             @Override             public double fitness() {                 return 0;             }         };         Chromosome c2 = new Chromosome() {             @Override             public double fitness() {                 return 10;             }         };         Chromosome c3 = new Chromosome() {             @Override             public double fitness() {                 return 10;             }         };          Assert.assertTrue(c1.compareTo(c2) < 0);         Assert.assertTrue(c2.compareTo(c1) > 0);         Assert.assertEquals(0,c3.compareTo(c2));         Assert.assertEquals(0,c2.compareTo(c3));     }      private abstract static class DummyChromosome extends Chromosome {         private final int repr;          public DummyChromosome(final int repr) {             this.repr = repr;         }         @Override         protected boolean isSame(Chromosome another) {             return ((DummyChromosome) another).repr == repr;         }     }      @Test     public void testFindSameChromosome() {         Chromosome c1 = new DummyChromosome(1) {             @Override             public double fitness() {                 return 1;             }         };         Chromosome c2 = new DummyChromosome(2) {             @Override             public double fitness() {                 return 2;             }         };         Chromosome c3 = new DummyChromosome(3) {             @Override             public double fitness() {                 return 3;             }         };         Chromosome c4 = new DummyChromosome(1) {             @Override             public double fitness() {                 return 5;             }         };         Chromosome c5 = new DummyChromosome(15) {             @Override             public double fitness() {                 return 15;             }         };          List<Chromosome> popChr = new ArrayList<>();         popChr.add(c1);         popChr.add(c2);         popChr.add(c3);         Population pop = new ListPopulation(popChr,3) {             @Override             public Population nextGeneration() {                 // not important                 return null;             }         };          Assert.assertNull(c5.findSameChromosome(pop));         Assert.assertEquals(c1, c4.findSameChromosome(pop));          c4.searchForFitnessUpdate(pop);         Assert.assertEquals(1, c4.getFitness(),0);     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.Arrays; import java.util.Comparator; import java.util.List;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  @SuppressWarnings("boxing") public class RandomKeyTest {      @Test(expected=MathIllegalArgumentException.class)     public void testConstructor1() {         new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});     }      @Test(expected=MathIllegalArgumentException.class)     public void testConstructor2() {         new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});     }      @Test     public void testIsSame() {         DummyRandomKey drk1 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});         DummyRandomKey drk2 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});         DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2});         DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});         DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});          Assert.assertTrue(drk1.isSame(drk2));         Assert.assertTrue(drk2.isSame(drk3));         Assert.assertFalse(drk3.isSame(drk4));         Assert.assertFalse(drk4.isSame(drk5));     }      @Test     public void testDecode() {         DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});         List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));          Assert.assertEquals("b", decoded.get(0));         Assert.assertEquals("e", decoded.get(1));         Assert.assertEquals("a", decoded.get(2));         Assert.assertEquals("c", decoded.get(3));         Assert.assertEquals("d", decoded.get(4));     }      @Test(expected=MathIllegalArgumentException.class)     public void testInvalidRepresentation() {         new DummyRandomKey(new Double[] {0.1, 0.1, 2d, 0.8, 0.2});     }      @Test     public void testRandomPermutation() {         // never generate an invalid one         for (int i=0; i<10; i++) {             DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20));             Assert.assertNotNull(drk);         }     }      @Test     public void testIdentityPermutation() {         DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));         List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));          Assert.assertEquals("a", decoded.get(0));         Assert.assertEquals("b", decoded.get(1));         Assert.assertEquals("c", decoded.get(2));         Assert.assertEquals("d", decoded.get(3));         Assert.assertEquals("e", decoded.get(4));     }      @Test     public void testComparatorPermutation() {         List<String> data = Arrays.asList(new String[] {"x", "b", "c", "z", "b"});          List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {             @Override             public int compare(String o1, String o2) {                 return o1.compareTo(o2);             }         });         Double[] permArr = new Double[data.size()];         permArr = permutation.toArray(permArr);         Assert.assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);         List<String> decodedData = new DummyRandomKey(permutation).decode(data);         Assert.assertEquals("b", decodedData.get(0));         Assert.assertEquals("b", decodedData.get(1));         Assert.assertEquals("c", decodedData.get(2));         Assert.assertEquals("x", decodedData.get(3));         Assert.assertEquals("z", decodedData.get(4));          permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {             @Override             public int compare(String o1, String o2) {                 return o2.compareTo(o1);             }         });         permArr = new Double[data.size()];         permArr = permutation.toArray(permArr);         Assert.assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);         decodedData = new DummyRandomKey(permutation).decode(data);         Assert.assertEquals("z", decodedData.get(0));         Assert.assertEquals("x", decodedData.get(1));         Assert.assertEquals("c", decodedData.get(2));         Assert.assertEquals("b", decodedData.get(3));         Assert.assertEquals("b", decodedData.get(4));     }      @Test     public void testInducedPermutation() {         List<String> origData = Arrays.asList(new String[] {"a", "b", "c", "d", "d"});         List<String> permutedData = Arrays.asList(new String[] {"d", "b", "c", "a", "d"});          DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));         List<String> decoded = drk.decode(origData);          Assert.assertEquals("d", decoded.get(0));         Assert.assertEquals("b", decoded.get(1));         Assert.assertEquals("c", decoded.get(2));         Assert.assertEquals("a", decoded.get(3));         Assert.assertEquals("d", decoded.get(4));          try {             RandomKey.inducedPermutation(                     Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                     Arrays.asList(new String[] {"a", "b", "c", "d"})             );             Assert.fail("Uncaught exception");         } catch (MathIllegalArgumentException e) {             // no-op         }         try {             RandomKey.inducedPermutation(                     Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                     Arrays.asList(new String[] {"a", "b", "c", "d", "f"})             );             Assert.fail("Uncaught exception");         } catch (MathIllegalArgumentException e) {             // no-op         }     }      @Test     public void testEqualRepr() {         DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5});         List<String> decodedData = drk.decode(Arrays.asList(new String[] {"a", "b", "c"}));         Assert.assertEquals("a", decodedData.get(0));         Assert.assertEquals("b", decodedData.get(1));         Assert.assertEquals("c", decodedData.get(2));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  public class BinaryChromosomeTest {      @Test     public void testInvalidConstructor() {         Integer[][] reprs = new Integer[][] {                 new Integer[] {0,1,0,1,2},                 new Integer[] {0,1,0,1,-1}         };          for (Integer[] repr : reprs) {             try {                 new DummyBinaryChromosome(repr);                 Assert.fail("Exception not caught");             } catch (MathIllegalArgumentException e) {                 // Expected             }         }     }      @Test     public void testRandomConstructor() {         for (int i=0; i<20; i++) {             new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));         }     }      @Test     public void testIsSame() {         Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});         Chromosome c2 = new DummyBinaryChromosome(new Integer[] {0,1,1,0,1});         Chromosome c3 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1,1});         Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1});         Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});         Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});          Assert.assertFalse(c1.isSame(c2));         Assert.assertFalse(c1.isSame(c3));         Assert.assertFalse(c1.isSame(c4));         Assert.assertFalse(c1.isSame(c5));         Assert.assertTrue(c1.isSame(c6));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * This is also an example of usage.  *  * This algorithm does "stochastic sorting" of a sequence 0,...,N.  *  */ public class GeneticAlgorithmTestPermutations {      // parameters for the GA     private static final int DIMENSION = 20;     private static final int POPULATION_SIZE = 80;     private static final int NUM_GENERATIONS = 200;     private static final double ELITISM_RATE = 0.2;     private static final double CROSSOVER_RATE = 1;     private static final double MUTATION_RATE = 0.08;     private static final int TOURNAMENT_ARITY = 2;      // numbers from 0 to N-1     private static final List<Integer> sequence = new ArrayList<>();     static {         for (int i=0; i<DIMENSION; i++) {             sequence.add(i);         }     }      @Test     public void test() {         // to test a stochastic algorithm is hard, so this will rather be an usage example          // initialize a new genetic algorithm         GeneticAlgorithm ga = new GeneticAlgorithm(                 new OnePointCrossover<Integer>(),                 CROSSOVER_RATE,                 new RandomKeyMutation(),                 MUTATION_RATE,                 new TournamentSelection(TOURNAMENT_ARITY)         );          // initial population         Population initial = randomPopulation();         // stopping conditions         StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);          // best initial chromosome         Chromosome bestInitial = initial.getFittestChromosome();          // run the algorithm         Population finalPopulation = ga.evolve(initial, stopCond);          // best chromosome from the final population         Chromosome bestFinal = finalPopulation.getFittestChromosome();          // the only thing we can test is whether the final solution is not worse than the initial one         // however, for some implementations of GA, this need not be true :)          Assert.assertTrue(bestFinal.compareTo(bestInitial) > 0);          //System.out.println(bestInitial);         //System.out.println(bestFinal);     }       /**      * Initializes a random population      */     private static ElitisticListPopulation randomPopulation() {         List<Chromosome> popList = new ArrayList<>();         for (int i=0; i<POPULATION_SIZE; i++) {             Chromosome randChrom = new MinPermutations(RandomKey.randomPermutation(DIMENSION));             popList.add(randChrom);         }         return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);     }      /**      * Chromosomes representing a permutation of (0,1,2,...,DIMENSION-1).      *      * The goal is to sort the sequence.      */     private static class MinPermutations extends RandomKey<Integer> {          public MinPermutations(List<Double> representation) {             super(representation);         }          @Override         public double fitness() {             int res = 0;             List<Integer> decoded = decode(sequence);             for (int i=0; i<decoded.size(); i++) {                 int value = decoded.get(i);                 if (value != i) {                     // bad position found                     res += FastMath.abs(value - i);                 }             }             // the most fitted chromosome is the one with minimal error             // therefore we must return negative value             return -res;         }          @Override         public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> chromosomeRepresentation) {             return new MinPermutations(chromosomeRepresentation);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.genetics;   import java.util.LinkedList; import java.util.List;  import org.junit.Assert; import org.junit.Test;  /**  * This is also an example of usage.  */ public class GeneticAlgorithmTestBinary {      // parameters for the GA     private static final int DIMENSION = 50;     private static final int POPULATION_SIZE = 50;     private static final int NUM_GENERATIONS = 50;     private static final double ELITISM_RATE = 0.2;     private static final double CROSSOVER_RATE = 1;     private static final double MUTATION_RATE = 0.1;     private static final int TOURNAMENT_ARITY = 2;      @Test     public void test() {         // to test a stochastic algorithm is hard, so this will rather be an usage example          // initialize a new genetic algorithm         GeneticAlgorithm ga = new GeneticAlgorithm(                 new OnePointCrossover<Integer>(),                 CROSSOVER_RATE, // all selected chromosomes will be recombined (=crossover)                 new BinaryMutation(),                 MUTATION_RATE,                 new TournamentSelection(TOURNAMENT_ARITY)         );          Assert.assertEquals(0, ga.getGenerationsEvolved());          // initial population         Population initial = randomPopulation();         // stopping conditions         StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);          // best initial chromosome         Chromosome bestInitial = initial.getFittestChromosome();          // run the algorithm         Population finalPopulation = ga.evolve(initial, stopCond);          // best chromosome from the final population         Chromosome bestFinal = finalPopulation.getFittestChromosome();          // the only thing we can test is whether the final solution is not worse than the initial one         // however, for some implementations of GA, this need not be true :)          Assert.assertTrue(bestFinal.compareTo(bestInitial) > 0);         Assert.assertEquals(NUM_GENERATIONS, ga.getGenerationsEvolved());      }         /**      * Initializes a random population.      */     private static ElitisticListPopulation randomPopulation() {         List<Chromosome> popList = new LinkedList<>();          for (int i=0; i<POPULATION_SIZE; i++) {             BinaryChromosome randChrom = new FindOnes(BinaryChromosome.randomBinaryRepresentation(DIMENSION));             popList.add(randChrom);         }         return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);     }      /**      * Chromosomes represented by a binary chromosome.      *      * The goal is to set all bits (genes) to 1.      */     private static class FindOnes extends BinaryChromosome {          public FindOnes(List<Integer> representation) {             super(representation);         }          /**          * Returns number of elements != 0          */         @Override         public double fitness() {             int num = 0;             for (int val : this.getRepresentation()) {                 if (val != 0) {                     num++;                 }             }             // number of elements >= 0             return num;         }          @Override         public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> chromosomeRepresentation) {             return new FindOnes(chromosomeRepresentation);         }      } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.special;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  /**  */ public class BesselJTest {      /**      * Reference data for the {@link BesselJ#value(double, double)} function. This data      * was generated with the following <a href="http://www.r-project.org/">R</a> script.      *      * <pre>      * smallxs = 10 ** (-(seq(0,8,.5)))      * medxs = seq(1,20)      * near.eight = 8 + seq(-.5,.5,.1)      * largexs = c(10,30,100,300,1000)      * xs = unique(sort(c(smallxs, medxs, near.eight,largexs)))      *      * for (n in c(0:15, 30, 100)) {      * for (x in xs) {      * val = format( besselJ(x,n), digits=20 )      * s = paste("{", n, ",", x, ",", val, "},")      * print(s)      * }      * }      * </pre>      */     private static final double[][] BESSEL_J_REF = {         { 0 , 1e-08 , 1 },         { 0 , 3.16227766016838e-08 , 0.99999999999999977796 },         { 0 , 1e-07 , 0.99999999999999744649 },         { 0 , 3.16227766016838e-07 , 0.99999999999997501998 },         { 0 , 1e-06 , 0.99999999999974997777 },         { 0 , 3.16227766016838e-06 , 0.99999999999749999979 },         { 0 , 1e-05 , 0.99999999997499999793 },         { 0 , 3.16227766016838e-05 , 0.99999999974999997931 },         { 0 , 1e-04 , 0.99999999750000001519 },         { 0 , 0.000316227766016838 , 0.99999997500000015194 },         { 0 , 0.001 , 0.9999997500000156192 },         { 0 , 0.00316227766016838 , 0.99999750000156251151 },         { 0 , 0.01 , 0.99997500015624951608 },         { 0 , 0.0316227766016838 , 0.9997500156245660019 },         { 0 , 0.1 , 0.99750156206604001508 },         { 0 , 0.316227766016838 , 0.97515581664971295872 },         { 0 , 1 , 0.76519768655796649437 },         { 0 , 2 , 0.22389077914123567403 },         { 0 , 3 , -0.26005195490193344643 },         { 0 , 4 , -0.39714980986384734729 },         { 0 , 5 , -0.177596771314338292 },         { 0 , 6 , 0.15064525725099692233 },         { 0 , 7 , 0.3000792705195556298 },         { 0 , 7.5 , 0.26633965788037838873 },         { 0 , 7.6 , 0.25160183384997636402 },         { 0 , 7.7 , 0.23455913958646437689 },         { 0 , 7.8 , 0.21540780774626291927 },         { 0 , 7.9 , 0.19436184484127824734 },         { 0 , 8 , 0.17165080713755390129 },         { 0 , 8.1 , 0.14751745404437766052 },         { 0 , 8.2 , 0.12221530178413773926 },         { 0 , 8.3 , 0.09600610089501022959 },         { 0 , 8.4 , 0.069157261656985186127 },         { 0 , 8.5 , 0.041939251842934503756 },         { 0 , 9 , -0.090333611182876139001 },         { 0 , 10 , -0.24593576445134832098 },         { 0 , 11 , -0.17119030040719609986 },         { 0 , 12 , 0.0476893107968335353 },         { 0 , 13 , 0.20692610237706782206 },         { 0 , 14 , 0.17107347611045864433 },         { 0 , 15 , -0.014224472826780772475 },         { 0 , 16 , -0.17489907398362919411 },         { 0 , 17 , -0.16985425215118354902 },         { 0 , 18 , -0.013355805721984111492 },         { 0 , 19 , 0.14662943965965119508 },         { 0 , 20 , 0.16702466434058313438 },         { 0 , 30 , -0.086367983581040239094 },         { 0 , 100 , 0.019985850304223118368 },         { 0 , 300 , -0.033298554876305661021 },         { 0 , 1000 , 0.024786686152420175921 },         { 1 , 1e-08 , 5.0000000000000001046e-09 },         { 1 , 3.16227766016838e-08 , 1.5811388300841892647e-08 },         { 1 , 1e-07 , 4.999999999999993818e-08 },         { 1 , 3.16227766016838e-07 , 1.5811388300841697432e-07 },         { 1 , 1e-06 , 4.9999999999993750869e-07 },         { 1 , 3.16227766016838e-06 , 1.5811388300822132559e-06 },         { 1 , 1e-05 , 4.9999999999375003889e-06 },         { 1 , 3.16227766016838e-05 , 1.5811388298865475016e-05 },         { 1 , 1e-04 , 4.9999999937500002646e-05 },         { 1 , 0.000316227766016838 , 0.00015811388103199544184 },         { 1 , 0.001 , 0.00049999993750000253697 },         { 1 , 0.00316227766016838 , 0.0015811368536614756226 },         { 1 , 0.01 , 0.0049999375002604158624 },         { 1 , 0.0316227766016838 , 0.015809411959653556917 },         { 1 , 0.1 , 0.049937526036241998428 },         { 1 , 0.316227766016838 , 0.15614567743386048582 },         { 1 , 1 , 0.44005058574493355339 },         { 1 , 2 , 0.57672480775687340326 },         { 1 , 3 , 0.33905895852593642692 },         { 1 , 4 , -0.066043328023549133232 },         { 1 , 5 , -0.32757913759146523036 },         { 1 , 6 , -0.27668385812756562947 },         { 1 , 7 , -0.0046828234823458325664 },         { 1 , 7.5 , 0.13524842757970551022 },         { 1 , 7.6 , 0.15921376839635667522 },         { 1 , 7.7 , 0.18131271532458800855 },         { 1 , 7.8 , 0.20135687275589611578 },         { 1 , 7.9 , 0.21917939992175122788 },         { 1 , 8 , 0.23463634685391462908 },         { 1 , 8.1 , 0.2476077669815928417 },         { 1 , 8.2 , 0.25799859764868082745 },         { 1 , 8.3 , 0.26573930204186430037 },         { 1 , 8.4 , 0.27078626827683538458 },         { 1 , 8.5 , 0.27312196367405372488 },         { 1 , 9 , 0.24531178657332528004 },         { 1 , 10 , 0.043472746168861438332 },         { 1 , 11 , -0.17678529895672151495 },         { 1 , 12 , -0.2234471044906276016 },         { 1 , 13 , -0.070318052121778371055 },         { 1 , 14 , 0.13337515469879324126 },         { 1 , 15 , 0.20510403861352277666 },         { 1 , 16 , 0.090397175661304188243 },         { 1 , 17 , -0.097668492757780639435 },         { 1 , 18 , -0.18799488548806958521 },         { 1 , 19 , -0.10570143114240927729 },         { 1 , 20 , 0.066833124175850036619 },         { 1 , 30 , -0.1187510626166229516 },         { 1 , 100 , -0.077145352014112156258 },         { 1 , 300 , -0.031887431377499955709 },         { 1 , 1000 , 0.0047283119070895248195 },         { 2 , 1e-08 , 1.2499999999999999739e-17 },         { 2 , 3.16227766016838e-08 , 1.2499999999999998506e-16 },         { 2 , 1e-07 , 1.2499999999999988152e-15 },         { 2 , 3.16227766016838e-07 , 1.2499999999999894672e-14 },         { 2 , 1e-06 , 1.249999999999895719e-13 },         { 2 , 3.16227766016838e-06 , 1.2499999999989582746e-12 },         { 2 , 1e-05 , 1.2499999999895835475e-11 },         { 2 , 3.16227766016838e-05 , 1.2499999998958334818e-10 },         { 2 , 1e-04 , 1.2499999989583335487e-09 },         { 2 , 0.000316227766016838 , 1.2499999895833333493e-08 },         { 2 , 0.001 , 1.2499998958333367811e-07 },         { 2 , 0.00316227766016838 , 1.2499989583336589057e-06 },         { 2 , 0.01 , 1.2499895833658854395e-05 },         { 2 , 0.0316227766016838 , 0.00012498958365884872863 },         { 2 , 0.1 , 0.0012489586587999190141 },         { 2 , 0.316227766016838 , 0.012396158312196680837 },         { 2 , 1 , 0.11490348493190047363 },         { 2 , 2 , 0.35283402861563772923 },         { 2 , 3 , 0.48609126058589108288 },         { 2 , 4 , 0.36412814585207281537 },         { 2 , 5 , 0.046565116277752213736 },         { 2 , 6 , -0.24287320996018546548 },         { 2 , 7 , -0.3014172200859401296 },         { 2 , 7.5 , -0.23027341052579025638 },         { 2 , 7.6 , -0.20970347374567196996 },         { 2 , 7.7 , -0.18746492781384410664 },         { 2 , 7.8 , -0.16377784037295622932 },         { 2 , 7.9 , -0.13887338916488553564 },         { 2 , 8 , -0.11299172042407523708 },         { 2 , 8.1 , -0.086379733802009056598 },         { 2 , 8.2 , -0.059288814552752158726 },         { 2 , 8.3 , -0.031972534137934507936 },         { 2 , 8.4 , -0.0046843406386910518141 },         { 2 , 8.5 , 0.022324739609784025052 },         { 2 , 9 , 0.14484734153250397592 },         { 2 , 10 , 0.25463031368512062391 },         { 2 , 11 , 0.13904751877870125121 },         { 2 , 12 , -0.084930494878604809172 },         { 2 , 13 , -0.21774426424195678087 },         { 2 , 14 , -0.15201988258205964555 },         { 2 , 15 , 0.041571677975250471981 },         { 2 , 16 , 0.18619872094129222284 },         { 2 , 17 , 0.15836384123850347216 },         { 2 , 18 , -0.0075325148878013998069 },         { 2 , 19 , -0.15775590609569428713 },         { 2 , 20 , -0.16034135192299814321 },         { 2 , 30 , 0.07845124607326538213 },         { 2 , 100 , -0.021528757344505360799 },         { 2 , 300 , 0.033085972000455661501 },         { 2 , 1000 , -0.024777229528605997089 },         { 3 , 1e-08 , 2.0833333333333334614e-26 },         { 3 , 3.16227766016838e-08 , 6.5880784586841223417e-25 },         { 3 , 1e-07 , 2.0833333333333317693e-23 },         { 3 , 3.16227766016838e-07 , 6.5880784586840819929e-22 },         { 3 , 1e-06 , 2.0833333333332027799e-20 },         { 3 , 3.16227766016838e-06 , 6.5880784586800051603e-19 },         { 3 , 1e-05 , 2.0833333333203129762e-17 },         { 3 , 3.16227766016838e-05 , 6.5880784582723696076e-16 },         { 3 , 1e-04 , 2.083333332031250315e-14 },         { 3 , 0.000316227766016838 , 6.5880784175086335665e-13 },         { 3 , 0.001 , 2.0833332031250032117e-11 },         { 3 , 0.00316227766016838 , 6.5880743411361163135e-10 },         { 3 , 0.01 , 2.083320312532551971e-08 },         { 3 , 0.0316227766016838 , 6.5876667140741846331e-07 },         { 3 , 0.1 , 2.0820315754756265453e-05 },         { 3 , 0.316227766016838 , 0.00065470057642003857534 },         { 3 , 1 , 0.019563353982668403586 },         { 3 , 2 , 0.1289432494744020552 },         { 3 , 3 , 0.30906272225525166508 },         { 3 , 4 , 0.43017147387562193472 },         { 3 , 5 , 0.36483123061366695694 },         { 3 , 6 , 0.11476838482077529602 },         { 3 , 7 , -0.16755558799533423753 },         { 3 , 7.5 , -0.25806091319346030621 },         { 3 , 7.6 , -0.26958401773618401176 },         { 3 , 7.7 , -0.27869709340970183487 },         { 3 , 7.8 , -0.28534550884459158882 },         { 3 , 7.9 , -0.2894950400052375139 },         { 3 , 8 , -0.29113220706595221987 },         { 3 , 8.1 , -0.29026442564925164502 },         { 3 , 8.2 , -0.28691997060124291297 },         { 3 , 8.3 , -0.28114775222882071315 },         { 3 , 8.4 , -0.27301690667621203445 },         { 3 , 8.5 , -0.26261620385768480457 },         { 3 , 9 , -0.1809351903366568648 },         { 3 , 10 , 0.058379379305186815396 },         { 3 , 11 , 0.22734803305806741691 },         { 3 , 12 , 0.19513693953109267909 },         { 3 , 13 , 0.0033198169704070513292 },         { 3 , 14 , -0.17680940686509599713 },         { 3 , 15 , -0.19401825782012263599 },         { 3 , 16 , -0.043847495425981139472 },         { 3 , 17 , 0.13493057304919323092 },         { 3 , 18 , 0.18632099329078039007 },         { 3 , 19 , 0.072489661438052577225 },         { 3 , 20 , -0.098901394560449676363 },         { 3 , 30 , 0.12921122875972501642 },         { 3 , 100 , 0.076284201720331942798 },         { 3 , 300 , 0.032328577670839367397 },         { 3 , 1000 , -0.0048274208252039483777 },         { 4 , 1e-08 , 2.6041666666666666342e-35 },         { 4 , 3.16227766016838e-08 , 2.6041666666666659714e-33 },         { 4 , 1e-07 , 2.6041666666666649861e-31 },         { 4 , 3.16227766016838e-07 , 2.6041666666666531276e-29 },         { 4 , 1e-06 , 2.6041666666665358894e-27 },         { 4 , 3.16227766016838e-06 , 2.6041666666653639536e-25 },         { 4 , 1e-05 , 2.6041666666536465525e-23 },         { 4 , 3.16227766016838e-05 , 2.604166666536458817e-21 },         { 4 , 1e-04 , 2.6041666653645840559e-19 },         { 4 , 0.000316227766016838 , 2.6041666536458338462e-17 },         { 4 , 0.001 , 2.6041665364583368871e-15 },         { 4 , 0.00316227766016838 , 2.604165364583604802e-13 },         { 4 , 0.01 , 2.6041536458604605458e-11 },         { 4 , 0.0316227766016838 , 2.6040364610459735901e-09 },         { 4 , 0.1 , 2.6028648545684040871e-07 },         { 4 , 0.316227766016838 , 2.5911729278009268374e-05 },         { 4 , 1 , 0.002476638964109955255 },         { 4 , 2 , 0.033995719807568429427 },         { 4 , 3 , 0.13203418392461221953 },         { 4 , 4 , 0.28112906496136008672 },         { 4 , 5 , 0.39123236045864817623 },         { 4 , 6 , 0.35764159478096080313 },         { 4 , 7 , 0.15779814466136793394 },         { 4 , 7.5 , 0.02382467997102201071 },         { 4 , 7.6 , -0.0031260139407891210546 },         { 4 , 7.7 , -0.029701638479430046702 },         { 4 , 7.8 , -0.055718704892114230554 },         { 4 , 7.9 , -0.080996261472003727722 },         { 4 , 8 , -0.10535743487538892782 },         { 4 , 8.1 , -0.12863095186410331006 },         { 4 , 8.2 , -0.15065262735059631316 },         { 4 , 8.3 , -0.17126680482265874139 },         { 4 , 8.4 , -0.19032773555860327264 },         { 4 , 8.5 , -0.2077008835093262229 },         { 4 , 9 , -0.26547080175694187654 },         { 4 , 10 , -0.21960268610200855965 },         { 4 , 11 , -0.015039500747028132846 },         { 4 , 12 , 0.18249896464415113484 },         { 4 , 13 , 0.21927648745906774819 },         { 4 , 14 , 0.076244422497018474183 },         { 4 , 15 , -0.11917898110329952499 },         { 4 , 16 , -0.20264153172603513453 },         { 4 , 17 , -0.11074128604467056713 },         { 4 , 18 , 0.069639512651394869236 },         { 4 , 19 , 0.18064737812876355272 },         { 4 , 20 , 0.13067093355486322781 },         { 4 , 30 , -0.05260900032132037607 },         { 4 , 100 , 0.026105809447725277644 },         { 4 , 300 , -0.032439400447038871378 },         { 4 , 1000 , 0.024748265003654772859 },         { 5 , 1e-08 , 2.6041666666666666817e-44 },         { 5 , 3.16227766016838e-08 , 8.2350980733551520153e-42 },         { 5 , 1e-07 , 2.6041666666666648818e-39 },         { 5 , 3.16227766016838e-07 , 8.2350980733551185479e-37 },         { 5 , 1e-06 , 2.6041666666665576923e-34 },         { 5 , 3.16227766016838e-06 , 8.2350980733517218878e-32 },         { 5 , 1e-05 , 2.6041666666558171668e-29 },         { 5 , 3.16227766016838e-05 , 8.2350980730120282499e-27 },         { 5 , 1e-04 , 2.6041666655815978351e-24 },         { 5 , 0.000316227766016838 , 8.2350980390422474771e-22 },         { 5 , 0.001 , 2.6041665581597245947e-19 },         { 5 , 0.00316227766016838 , 8.2350946420649040367e-17 },         { 5 , 0.01 , 2.6041558159915982186e-14 },         { 5 , 0.0316227766016838 , 8.2347549503960048977e-12 },         { 5 , 0.1 , 2.6030817909644421178e-09 },         { 5 , 0.316227766016838 , 8.2008463739855235578e-07 },         { 5 , 1 , 0.00024975773021123438876 },         { 5 , 2 , 0.0070396297558716850601 },         { 5 , 3 , 0.043028434877047584683 },         { 5 , 4 , 0.13208665604709826646 },         { 5 , 5 , 0.26114054612017006951 },         { 5 , 6 , 0.36208707488717239986 },         { 5 , 7 , 0.34789632475118331678 },         { 5 , 7.5 , 0.28347390516255044357 },         { 5 , 7.6 , 0.26629347674587972028 },         { 5 , 7.7 , 0.2478382482362680439 },         { 5 , 7.8 , 0.22819811921165392143 },         { 5 , 7.9 , 0.20747350940067682545 },         { 5 , 8 , 0.18577477219056331981 },         { 5 , 8.1 , 0.16322151022791506203 },         { 5 , 8.2 , 0.13994179757627084326 },         { 5 , 8.3 , 0.11607131384553516507 },         { 5 , 8.4 , 0.091752396620399440108 },         { 5 , 8.5 , 0.067133019378318919967 },         { 5 , 9 , -0.055038855669513706004 },         { 5 , 10 , -0.23406152818679362704 },         { 5 , 11 , -0.23828585178317879256 },         { 5 , 12 , -0.073470963101658584571 },         { 5 , 13 , 0.13161955992748081146 },         { 5 , 14 , 0.22037764829196368477 },         { 5 , 15 , 0.1304561345650295523 },         { 5 , 16 , -0.057473270437036434732 },         { 5 , 17 , -0.18704411942315585238 },         { 5 , 18 , -0.15537009877904933708 },         { 5 , 19 , 0.0035723925109004857348 },         { 5 , 20 , 0.15116976798239498136 },         { 5 , 30 , -0.14324029551207712041 },         { 5 , 100 , -0.074195736964513925304 },         { 5 , 300 , -0.03319362834942707341 },         { 5 , 1000 , 0.0050254069452331864842 },         { 6 , 1e-08 , 2.170138888888889163e-53 },         { 6 , 3.16227766016838e-08 , 2.1701388888888880947e-50 },         { 6 , 1e-07 , 2.1701388888888875174e-47 },         { 6 , 3.16227766016838e-07 , 2.170138888888880604e-44 },         { 6 , 1e-06 , 2.1701388888888106952e-41 },         { 6 , 3.16227766016838e-06 , 2.1701388888881133808e-38 },         { 6 , 1e-05 , 2.1701388888811393588e-35 },         { 6 , 3.16227766016838e-05 , 2.1701388888113848269e-32 },         { 6 , 1e-04 , 2.1701388881138396044e-29 },         { 6 , 0.000316227766016838 , 2.1701388811383932341e-26 },         { 6 , 0.001 , 2.1701388113839301844e-23 },         { 6 , 0.00316227766016838 , 2.1701381138394068717e-20 },         { 6 , 0.01 , 2.1701311384049674283e-17 },         { 6 , 0.0316227766016838 , 2.1700613851395740978e-14 },         { 6 , 0.1 , 2.1693639603760032489e-11 },         { 6 , 0.316227766016838 , 2.1624004918010960028e-08 },         { 6 , 1 , 2.0938338002389272967e-05 },         { 6 , 2 , 0.0012024289717899932714 },         { 6 , 3 , 0.011393932332213070266 },         { 6 , 4 , 0.049087575156385579445 },         { 6 , 5 , 0.13104873178169201831 },         { 6 , 6 , 0.24583686336432652997 },         { 6 , 7 , 0.33919660498317966146 },         { 6 , 7.5 , 0.35414052691237862813 },         { 6 , 7.6 , 0.35351216755378872536 },         { 6 , 7.7 , 0.35156949333172621275 },         { 6 , 7.8 , 0.3482803961891063893 },         { 6 , 7.9 , 0.34362095691589844559 },         { 6 , 8 , 0.33757590011359311921 },         { 6 , 8.1 , 0.33013898918251699532 },         { 6 , 8.2 , 0.32131335610214611931 },         { 6 , 8.3 , 0.3111117612630625584 },         { 6 , 8.4 , 0.29955677915431688785 },         { 6 , 8.5 , 0.28668090630734854862 },         { 6 , 9 , 0.20431651767970440692 },         { 6 , 10 , -0.014458842084785107282 },         { 6 , 11 , -0.20158400087404348966 },         { 6 , 12 , -0.24372476722886662892 },         { 6 , 13 , -0.1180306721302363665 },         { 6 , 14 , 0.081168183425812737153 },         { 6 , 15 , 0.20614973747998591169 },         { 6 , 16 , 0.16672073770288736716 },         { 6 , 17 , 0.00071533344281418307069 },         { 6 , 18 , -0.15595623419531115528 },         { 6 , 19 , -0.17876717154407903432 },         { 6 , 20 , -0.055086049563665764883 },         { 6 , 30 , 0.0048622351506280026001 },         { 6 , 100 , -0.033525383144176669481 },         { 6 , 300 , 0.031332946168724638836 },         { 6 , 1000 , -0.024698010934202440508 },         { 7 , 1e-08 , 1.5500992063492066701e-62 },         { 7 , 3.16227766016838e-08 , 4.9018440912828279875e-59 },         { 7 , 1e-07 , 1.5500992063492053031e-55 },         { 7 , 3.16227766016838e-07 , 4.9018440912828133382e-52 },         { 7 , 1e-06 , 1.55009920634915736e-48 },         { 7 , 3.16227766016838e-06 , 4.9018440912812964979e-45 },         { 7 , 1e-05 , 1.550099206344363137e-41 },         { 7 , 3.16227766016838e-05 , 4.9018440911296494971e-38 },         { 7 , 1e-04 , 1.5500992058648010339e-34 },         { 7 , 0.000316227766016838 , 4.9018440759645687969e-31 },         { 7 , 0.001 , 1.5500991579086071003e-27 },         { 7 , 0.00316227766016838 , 4.9018425594567649302e-24 },         { 7 , 0.01 , 1.550094362295914728e-20 },         { 7 , 0.0316227766016838 , 4.9016909107824929132e-17 },         { 7 , 0.1 , 1.5496148676202282287e-13 },         { 7 , 0.316227766016838 , 4.8865470861431505644e-10 },         { 7 , 1 , 1.5023258174368078499e-06 },         { 7 , 2 , 0.00017494407486827416175 },         { 7 , 3 , 0.0025472944518046929108 },         { 7 , 4 , 0.015176069422058449318 },         { 7 , 5 , 0.053376410155890716136 },         { 7 , 6 , 0.12958665184148068783 },         { 7 , 7 , 0.23358356950569605925 },         { 7 , 7.5 , 0.28315093789725531703 },         { 7 , 7.6 , 0.29188362991799726709 },         { 7 , 7.7 , 0.30006226085213638655 },         { 7 , 7.8 , 0.30761787492543296585 },         { 7 , 7.9 , 0.31448237452220684229 },         { 7 , 8 , 0.32058907797982633125 },         { 7 , 8.1 , 0.3258732885609990082 },         { 7 , 8.2 , 0.33027286989028453723 },         { 7 , 8.3 , 0.33372882292033839713 },         { 7 , 8.4 , 0.33618585931433897507 },         { 7 , 8.5 , 0.33759296599676130723 },         { 7 , 9 , 0.32746087924245292911 },         { 7 , 10 , 0.21671091768505151842 },         { 7 , 11 , 0.018376032647858614455 },         { 7 , 12 , -0.17025380412720803047 },         { 7 , 13 , -0.24057094958616048741 },         { 7 , 14 , -0.15080491964126707671 },         { 7 , 15 , 0.034463655418959161791 },         { 7 , 16 , 0.18251382371420196704 },         { 7 , 17 , 0.1875490606769070201 },         { 7 , 18 , 0.051399275982175231248 },         { 7 , 19 , -0.11647797453873988405 },         { 7 , 20 , -0.18422139772059445417 },         { 7 , 30 , 0.1451851895723283159 },         { 7 , 100 , 0.070172690987212724134 },         { 7 , 300 , 0.034446946196176060628 },         { 7 , 1000 , -0.0053217830764436153956 },         { 8 , 1e-08 , 9.6881200396825412359e-72 },         { 8 , 3.16227766016838e-08 , 9.6881200396825359082e-68 },         { 8 , 1e-07 , 9.6881200396825335915e-64 },         { 8 , 3.16227766016838e-07 , 9.6881200396825091166e-60 },         { 8 , 1e-06 , 9.6881200396822669073e-56 },         { 8 , 3.16227766016838e-06 , 9.6881200396798449492e-52 },         { 8 , 1e-05 , 9.6881200396556345156e-48 },         { 8 , 3.16227766016838e-05 , 9.6881200394134308774e-44 },         { 8 , 1e-04 , 9.6881200369913995322e-40 },         { 8 , 0.000316227766016838 , 9.688120012771098157e-36 },         { 8 , 0.001 , 9.6881197705681010442e-32 },         { 8 , 0.00316227766016838 , 9.688117348538421731e-28 },         { 8 , 0.01 , 9.6880931282716245736e-24 },         { 8 , 0.0316227766016838 , 9.6878509286008909493e-20 },         { 8 , 0.1 , 9.6854292315946525669e-16 },         { 8 , 0.316227766016838 , 9.6612422089625085973e-12 },         { 8 , 1 , 9.4223441726045005392e-08 },         { 8 , 2 , 2.2179552287925904881e-05 },         { 8 , 3 , 0.00049344177620883479096 },         { 8 , 4 , 0.0040286678208190035769 },         { 8 , 5 , 0.018405216654802002835 },         { 8 , 6 , 0.056531990932461785582 },         { 8 , 7 , 0.12797053402821254031 },         { 8 , 7.5 , 0.17440789049583127479 },         { 8 , 7.6 , 0.18416820334778524759 },         { 8 , 7.7 , 0.19399825367215817185 },         { 8 , 7.8 , 0.20385425111295268907 },         { 8 , 7.9 , 0.21368958021206302389 },         { 8 , 8 , 0.22345498635110294661 },         { 8 , 8.1 , 0.23309879351550599758 },         { 8 , 8.2 , 0.24256715346663235144 },         { 8 , 8.3 , 0.25180432559052018382 },         { 8 , 8.4 , 0.26075298636958132992 },         { 8 , 8.5 , 0.26935456709908189854 },         { 8 , 9 , 0.30506707225300011554 },         { 8 , 10 , 0.31785412684385727644 },         { 8 , 11 , 0.22497167878949989039 },         { 8 , 12 , 0.045095329080457241533 },         { 8 , 13 , -0.14104573511639803551 },         { 8 , 14 , -0.23197310306707982774 },         { 8 , 15 , -0.17398365908895732646 },         { 8 , 16 , -0.0070211419529606520704 },         { 8 , 17 , 0.1537368341734622057 },         { 8 , 18 , 0.19593344884811411677 },         { 8 , 19 , 0.092941295568165452345 },         { 8 , 20 , -0.073868928840750344711 },         { 8 , 30 , 0.062890853316458550371 },         { 8 , 100 , 0.043349559882386451415 },         { 8 , 300 , -0.029725422012903089664 },         { 8 , 1000 , 0.02462350597113223058 } ,         { 9 , 1e-08 , 5.382288910934745386e-81 },         { 9 , 3.16227766016838e-08 , 1.702029198362092975e-76 },         { 9 , 1e-07 , 5.3822889109347404393e-72 },         { 9 , 3.16227766016838e-07 , 1.7020291983620889989e-67 },         { 9 , 1e-06 , 5.3822889109346077433e-63 },         { 9 , 3.16227766016838e-06 , 1.7020291983616675345e-58 },         { 9 , 1e-05 , 5.3822889109212923968e-54 },         { 9 , 3.16227766016838e-05 , 1.7020291983195439884e-49 },         { 9 , 1e-04 , 5.3822889095891748719e-45 },         { 9 , 0.000316227766016838 , 1.7020291941070210695e-40 },         { 9 , 0.001 , 5.382288776377523226e-36 },         { 9 , 0.00316227766016838 , 1.7020287728548427703e-31 },         { 9 , 0.01 , 5.3822754552277587118e-27 },         { 9 , 0.0316227766016838 , 1.7019866481156611902e-22 },         { 9 , 0.1 , 5.3809434916023306372e-18 },         { 9 , 0.316227766016838 , 1.6977789573201714453e-13 },         { 9 , 1 , 5.2492501799118757129e-09 },         { 9 , 2 , 2.492343435133064173e-06 },         { 9 , 3 , 8.4395021309091773631e-05 },         { 9 , 4 , 0.00093860186121756401367 },         { 9 , 5 , 0.005520283139475687037 },         { 9 , 6 , 0.021165323978417364265 },         { 9 , 7 , 0.058920508273075426764 },         { 9 , 7.5 , 0.088919228493851462658 },         { 9 , 7.6 , 0.095838903445761125521 },         { 9 , 7.7 , 0.10305099353156887965 },         { 9 , 7.8 , 0.11054469146011103309 },         { 9 , 7.9 , 0.11830664869209804591 },         { 9 , 8 , 0.12632089472237958971 },         { 9 , 8.1 , 0.13456877270419806414 },         { 9 , 8.2 , 0.14302889297143717151 },         { 9 , 8.3 , 0.15167710592885710885 },         { 9 , 8.4 , 0.16048649567533976312 },         { 9 , 8.5 , 0.16942739560151048872 },         { 9 , 9 , 0.2148805825406584491 },         { 9 , 10 , 0.29185568526512006837 },         { 9 , 11 , 0.30885550013686852155 },         { 9 , 12 , 0.23038090956781773211 },         { 9 , 13 , 0.066976198673670619965 },         { 9 , 14 , -0.11430719814968128001 },         { 9 , 15 , -0.22004622511384699934 },         { 9 , 16 , -0.18953496566716260263 },         { 9 , 17 , -0.042855569690119083015 },         { 9 , 18 , 0.12276378966059287023 },         { 9 , 19 , 0.19474432870140553908 },         { 9 , 20 , 0.12512625464799415065 },         { 9 , 30 , -0.11164340113688375755 },         { 9 , 100 , -0.063236761406030891908 },         { 9 , 300 , -0.036032302036864222172 },         { 9 , 1000 , 0.0057157591719817308837 },         { 10 , 1e-08 , 2.6911444554673727331e-90 },         { 10 , 3.16227766016838e-08 , 2.6911444554673710334e-85 },         { 10 , 1e-07 , 2.6911444554673703522e-80 },         { 10 , 3.16227766016838e-07 , 2.6911444554673646193e-75 },         { 10 , 1e-06 , 2.6911444554673096152e-70 },         { 10 , 3.16227766016838e-06 , 2.6911444554667591352e-65 },         { 10 , 1e-05 , 2.6911444554612582946e-60 },         { 10 , 3.16227766016838e-05 , 2.6911444554062112799e-55 },         { 10 , 1e-04 , 2.6911444548557502587e-50 },         { 10 , 0.000316227766016838 , 2.691144449351135505e-45 },         { 10 , 0.001 , 2.6911443943049990395e-40 },         { 10 , 0.00316227766016838 , 2.6911438438436965201e-35 },         { 10 , 0.01 , 2.6911383392363445476e-30 },         { 10 , 0.0316227766016838 , 2.691083293730485964e-25 },         { 10 , 0.1 , 2.6905328954342172306e-20 },         { 10 , 0.316227766016838 , 2.6850345850670040022e-15 },         { 10 , 1 , 2.630615123687452921e-10 },         { 10 , 2 , 2.5153862827167368199e-07 },         { 10 , 3 , 1.292835164571588302e-05 },         { 10 , 4 , 0.00019504055466003448463 },         { 10 , 5 , 0.0014678026473104743583 },         { 10 , 6 , 0.0069639810027903158857 },         { 10 , 7 , 0.023539344388267140901 },         { 10 , 7.5 , 0.038998257889412211996 },         { 10 , 7.6 , 0.042818673234280582585 },         { 10 , 7.7 , 0.04690017276527555512 },         { 10 , 7.8 , 0.051248883025765065713 },         { 10 , 7.9 , 0.055869872504109699407 },         { 10 , 8 , 0.060767026774251164944 },         { 10 , 8.1 , 0.065942923604934144954 },         { 10 , 8.2 , 0.071398709153595626975 },         { 10 , 8.3 , 0.077133976423868738648 },         { 10 , 8.4 , 0.083146647220432454151 },         { 10 , 8.5 , 0.089432858880587384753 },         { 10 , 9 , 0.12469409282831672714 },         { 10 , 10 , 0.20748610663335886883 },         { 10 , 11 , 0.28042823052537591 },         { 10 , 12 , 0.300476035271269315 },         { 10 , 13 , 0.23378201020301889179 },         { 10 , 14 , 0.085006705446061009424 },         { 10 , 15 , -0.09007181104765905888 },         { 10 , 16 , -0.20620569442259728543 },         { 10 , 17 , -0.19911331972770593413 },         { 10 , 18 , -0.073169659187521246535 },         { 10 , 19 , 0.091553331622639774756 },         { 10 , 20 , 0.18648255802394508862 },         { 10 , 30 , -0.129876893998588816 },         { 10 , 100 , -0.054732176935472012791 },         { 10 , 300 , 0.027563483890691235778 },         { 10 , 1000 , -0.02452062230603655954 },         { 30 , 1e-08 , 3.511074584737334481e-282 },         { 30 , 3.16227766016838e-08 , 3.5110745847373276748e-267 },         { 30 , 1e-07 , 3.5110745847373271436e-252 },         { 30 , 3.16227766016838e-07 , 3.5110745847373244839e-237 },         { 30 , 1e-06 , 3.5110745847372989351e-222 },         { 30 , 3.16227766016838e-06 , 3.511074584737044636e-207 },         { 30 , 1e-05 , 3.5110745847345094386e-192 },         { 30 , 3.16227766016838e-05 , 3.5110745847090235522e-177 },         { 30 , 1e-04 , 3.5110745844541855471e-162 },         { 30 , 0.000316227766016838 , 3.5110745819058229075e-147 },         { 30 , 0.001 , 3.5110745564222159037e-132 },         { 30 , 0.00316227766016838 , 3.5110743015861690319e-117 },         { 30 , 0.01 , 3.5110717532266786188e-102 },         { 30 , 0.0316227766016838 , 3.5110462697303107185e-87 },         { 30 , 0.1 , 3.5107914446214635799e-72 },         { 30 , 0.316227766016838 , 3.5082441787554764315e-57 },         { 30 , 1 , 3.4828697942514824077e-42 },         { 30 , 2 , 3.6502562664740960186e-33 },         { 30 , 3 , 6.7223399381463293316e-28 },         { 30 , 4 , 3.5570357020361055268e-24 },         { 30 , 5 , 2.6711772782507989195e-21 },         { 30 , 6 , 5.7984683652785706951e-19 },         { 30 , 7 , 5.3172607940100176027e-17 },         { 30 , 7.5 , 3.9705139492720914996e-16 },         { 30 , 7.6 , 5.8351206236969734897e-16 },         { 30 , 7.7 , 8.5295046954365007979e-16 },         { 30 , 7.8 , 1.240300099862031423e-15 },         { 30 , 7.9 , 1.7943809060373146352e-15 },         { 30 , 8 , 2.5830997825663086363e-15 },         { 30 , 8.1 , 3.7004810818946501642e-15 },         { 30 , 8.2 , 5.2761304350589830578e-15 },         { 30 , 8.3 , 7.4879207291538333461e-15 },         { 30 , 8.4 , 1.057892772982890842e-14 },         { 30 , 8.5 , 1.4879948521285087748e-14 },         { 30 , 9 , 7.6921564693354977569e-14 },         { 30 , 10 , 1.5510960782574666161e-12 },         { 30 , 11 , 2.2735383676316185421e-11 },         { 30 , 12 , 2.5522590430344176732e-10 },         { 30 , 13 , 2.2828783239868354402e-09 },         { 30 , 14 , 1.6775399533577877891e-08 },         { 30 , 15 , 1.0374710201078721135e-07 },         { 30 , 16 , 5.5052386643076382366e-07 },         { 30 , 17 , 2.5460065118711982301e-06 },         { 30 , 18 , 1.0393652487465728599e-05 },         { 30 , 19 , 3.7849142225173515583e-05 },         { 30 , 20 , 0.00012401536360354329497 },         { 30 , 30 , 0.14393585001030734238 },         { 30 , 100 , 0.081460129581172213697 },         { 30 , 300 , -0.029514887800373371812 },         { 30 , 1000 , -0.020271896981075843147 },         { 100 , 1e-08 , 0 },         { 100 , 3.16227766016838e-08 , 0 },         { 100 , 1e-07 , 0 },         { 100 , 3.16227766016838e-07 , 0 },         { 100 , 1e-06 , 0 },         { 100 , 3.16227766016838e-06 , 0 },         { 100 , 1e-05 , 0 },         { 100 , 3.16227766016838e-05 , 0 },         { 100 , 1e-04 , 0 },         { 100 , 0.000316227766016838 , 0 },         { 100 , 0.001 , 0 },         { 100 , 0.00316227766016838 , 0 },         { 100 , 0.01 , 0 },         { 100 , 0.0316227766016838 , 0 },         { 100 , 0.1 , 8.4525165351217888791e-289 },         { 100 , 0.316227766016838 , 8.4506337559752745816e-239 },         { 100 , 1 , 8.4318287896267070128e-189 },         { 100 , 2 , 1.0609531124391718917e-158 },         { 100 , 3 , 4.260360181132621405e-141 },         { 100 , 4 , 1.305547836452271925e-128 },         { 100 , 5 , 6.2677893955418752099e-119 },         { 100 , 6 , 5.0513258541507019365e-111 },         { 100 , 7 , 2.4215591572118171706e-104 },         { 100 , 7.5 , 2.3583800455568589368e-101 },         { 100 , 7.6 , 8.8352979458474109476e-101 },         { 100 , 7.7 , 3.253025120751429903e-100 },         { 100 , 7.8 , 1.1776236102157393805e-99 },         { 100 , 7.9 , 4.1933885427120016432e-99 },         { 100 , 8 , 1.4694094093552327336e-98 },         { 100 , 8.1 , 5.0688862671208964077e-98 },         { 100 , 8.2 , 1.7220304874625643909e-97 },         { 100 , 8.3 , 5.7635248300942440709e-97 },         { 100 , 8.4 , 1.9011188242236321325e-96 },         { 100 , 8.5 , 6.182346491260611201e-96 },         { 100 , 9 , 1.8369106342703587456e-93 },         { 100 , 10 , 6.5973160641553802341e-89 },         { 100 , 11 , 8.6297901331738815878e-85 },         { 100 , 12 , 4.8983704457507876536e-81 },         { 100 , 13 , 1.3781127544328333402e-77 },         { 100 , 14 , 2.1310751903146119988e-74 },         { 100 , 15 , 1.9660095611249536378e-71 },         { 100 , 16 , 1.1559435724349575529e-68 },         { 100 , 17 , 4.5721265690179434188e-66 },         { 100 , 18 , 1.2722370655682102766e-63 },         { 100 , 19 , 2.5856336302772506687e-61 },         { 100 , 20 , 3.9617550943362506795e-59 },         { 100 , 30 , 4.5788015281752424119e-42 },         { 100 , 100 , 0.09636667329586150188 },         { 100 , 300 , -0.014491227064785699996 },         { 100 , 1000 , 0.011676135007802557891 },         { 300 , 1e-08 , 0 },         { 300 , 3.16227766016838e-08 , 0 },         { 300 , 1e-07 , 0 },         { 300 , 3.16227766016838e-07 , 0 },         { 300 , 1e-06 , 0 },         { 300 , 3.16227766016838e-06 , 0 },         { 300 , 1e-05 , 0 },         { 300 , 3.16227766016838e-05 , 0 },         { 300 , 1e-04 , 0 },         { 300 , 0.000316227766016838 , 0 },         { 300 , 0.001 , 0 },         { 300 , 0.00316227766016838 , 0 },         { 300 , 0.01 , 0 },         { 300 , 0.0316227766016838 , 0 },         { 300 , 0.1 , 0 },         { 300 , 0.316227766016838 , 0 },         { 300 , 1 , 0 },         { 300 , 2 , 0 },         { 300 , 3 , 0 },         { 300 , 4 , 0 },         { 300 , 5 , 0 },         { 300 , 6 , 0 },         { 300 , 7 , 0 },         { 300 , 7.5 , 0 },         { 300 , 7.6 , 0 },         { 300 , 7.7 , 0 },         { 300 , 7.8 , 0 },         { 300 , 7.9 , 0 },         { 300 , 8 , 0 },         { 300 , 8.1 , 0 },         { 300 , 8.2 , 0 },         { 300 , 8.3 , 0 },         { 300 , 8.4 , 0 },         { 300 , 8.5 , 0 },         { 300 , 9 , 0 },         { 300 , 10 , 0 },         { 300 , 11 , 0 },         { 300 , 12 , 0 },         { 300 , 13 , 0 },         { 300 , 14 , 0 },         { 300 , 15 , 0 },         { 300 , 16 , 0 },         { 300 , 17 , 0 },         { 300 , 18 , 0 },         { 300 , 19 , 0 },         { 300 , 20 , 0 },         { 300 , 30 , 1.0388021531643495593e-262 },         { 300 , 100 , 3.5203666218469330448e-109 },         { 300 , 300 , 0.066818398128979980544 },         { 300 , 1000 , 0.00046782803879124944908 }     };      @Test     public void testBesselJ() {         final double tol = 1e-15;          for (int i = 0; i < BESSEL_J_REF.length; i++) {             final double[] data = BESSEL_J_REF[i];             final double order = data[0];             final double x = data[1];             final double expected = data[2];             final double actual = BesselJ.value(order, x);              String msg = "" + order + " @ " + x;             Assert.assertEquals(msg, expected, actual, tol);         }     }      @Test(expected=MathIllegalArgumentException.class)     public void testIAEBadOrder() {         BesselJ.value(-1, 1);     }      @Test(expected=MathIllegalArgumentException.class)     public void testIAEBadArgument() {         BesselJ.value(1, 100000);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */  package org.apache.commons.math4.filter;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.ArrayRealVector; import org.apache.commons.math4.linear.MatrixDimensionMismatchException; import org.apache.commons.math4.linear.MatrixUtils; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link KalmanFilter}.  *  */ public class KalmanFilterTest {      @Test(expected=MatrixDimensionMismatchException.class)     public void testTransitionMeasurementMatrixMismatch() {          // A and H matrix do not match in dimensions          // A = [ 1 ]         RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });         // no control input         RealMatrix B = null;         // H = [ 1 1 ]         RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d, 1d });         // Q = [ 0 ]         RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });         // R = [ 0 ]         RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });          ProcessModel pm             = new DefaultProcessModel(A, B, Q,                                       new ArrayRealVector(new double[] { 0 }), null);         MeasurementModel mm = new DefaultMeasurementModel(H, R);         new KalmanFilter(pm, mm);         Assert.fail("transition and measurement matrix should not be compatible");     }      @Test(expected=MatrixDimensionMismatchException.class)     public void testTransitionControlMatrixMismatch() {          // A and B matrix do not match in dimensions          // A = [ 1 ]         RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });         // B = [ 1 1 ]         RealMatrix B = new Array2DRowRealMatrix(new double[] { 1d, 1d });         // H = [ 1 ]         RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });         // Q = [ 0 ]         RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });         // R = [ 0 ]         RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });          ProcessModel pm             = new DefaultProcessModel(A, B, Q,                                       new ArrayRealVector(new double[] { 0 }), null);         MeasurementModel mm = new DefaultMeasurementModel(H, R);         new KalmanFilter(pm, mm);         Assert.fail("transition and control matrix should not be compatible");     }      @Test     public void testConstant() {         // simulates a simple process with a constant state and no control input          double constantValue = 10d;         double measurementNoise = 0.1d;         double processNoise = 1e-5d;          // A = [ 1 ]         RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });         // no control input         RealMatrix B = null;         // H = [ 1 ]         RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });         // x = [ 10 ]         RealVector x = new ArrayRealVector(new double[] { constantValue });         // Q = [ 1e-5 ]         RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });         // R = [ 0.1 ]         RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });          ProcessModel pm             = new DefaultProcessModel(A, B, Q,                                       new ArrayRealVector(new double[] { constantValue }), null);         MeasurementModel mm = new DefaultMeasurementModel(H, R);         KalmanFilter filter = new KalmanFilter(pm, mm);          Assert.assertEquals(1, filter.getMeasurementDimension());         Assert.assertEquals(1, filter.getStateDimension());          assertMatrixEquals(Q.getData(), filter.getErrorCovariance());          // check the initial state         double[] expectedInitialState = new double[] { constantValue };         assertVectorEquals(expectedInitialState, filter.getStateEstimation());          RealVector pNoise = new ArrayRealVector(1);         RealVector mNoise = new ArrayRealVector(1);          final ContinuousDistribution.Sampler rand = new NormalDistribution(0, 1).createSampler(RandomSource.create(RandomSource.WELL_19937_C));          // iterate 60 steps         for (int i = 0; i < 60; i++) {             filter.predict();              // Simulate the process             pNoise.setEntry(0, processNoise * rand.sample());              // x = A * x + p_noise             x = A.operate(x).add(pNoise);              // Simulate the measurement             mNoise.setEntry(0, measurementNoise * rand.sample());              // z = H * x + m_noise             RealVector z = H.operate(x).add(mNoise);              filter.correct(z);              // state estimate shouldn't be larger than measurement noise             double diff = FastMath.abs(constantValue - filter.getStateEstimation()[0]);             // System.out.println(diff);             Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);         }          // error covariance should be already very low (< 0.02)         Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[0][0],                                               0.02d, 1e-6) < 0);     }      @Test     public void testConstantAcceleration() {         // simulates a vehicle, accelerating at a constant rate (0.1 m/s)          // discrete time interval         double dt = 0.1d;         // position measurement noise (meter)         double measurementNoise = 10d;         // acceleration noise (meter/sec^2)         double accelNoise = 0.2d;          // A = [ 1 dt ]         //     [ 0  1 ]         RealMatrix A = new Array2DRowRealMatrix(new double[][] { { 1, dt }, { 0, 1 } });          // B = [ dt^2/2 ]         //     [ dt     ]         RealMatrix B = new Array2DRowRealMatrix(                 new double[][] { { FastMath.pow(dt, 2d) / 2d }, { dt } });          // H = [ 1 0 ]         RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } });          // x = [ 0 0 ]         RealVector x = new ArrayRealVector(new double[] { 0, 0 });          RealMatrix tmp = new Array2DRowRealMatrix(                 new double[][] { { FastMath.pow(dt, 4d) / 4d, FastMath.pow(dt, 3d) / 2d },                                  { FastMath.pow(dt, 3d) / 2d, FastMath.pow(dt, 2d) } });          // Q = [ dt^4/4 dt^3/2 ]         //     [ dt^3/2 dt^2   ]         RealMatrix Q = tmp.scalarMultiply(FastMath.pow(accelNoise, 2));          // P0 = [ 1 1 ]         //      [ 1 1 ]         RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } });          // R = [ measurementNoise^2 ]         RealMatrix R = new Array2DRowRealMatrix(                 new double[] { FastMath.pow(measurementNoise, 2) });          // constant control input, increase velocity by 0.1 m/s per cycle         RealVector u = new ArrayRealVector(new double[] { 0.1d });          ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);         MeasurementModel mm = new DefaultMeasurementModel(H, R);         KalmanFilter filter = new KalmanFilter(pm, mm);          Assert.assertEquals(1, filter.getMeasurementDimension());         Assert.assertEquals(2, filter.getStateDimension());          assertMatrixEquals(P0.getData(), filter.getErrorCovariance());          // check the initial state         double[] expectedInitialState = new double[] { 0.0, 0.0 };         assertVectorEquals(expectedInitialState, filter.getStateEstimation());          final ContinuousDistribution.Sampler rand = new NormalDistribution(0, 1).createSampler(RandomSource.create(RandomSource.WELL_19937_C));          RealVector tmpPNoise = new ArrayRealVector(                 new double[] { FastMath.pow(dt, 2d) / 2d, dt });          // iterate 60 steps         for (int i = 0; i < 60; i++) {             filter.predict(u);              // Simulate the process             RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.sample());              // x = A * x + B * u + pNoise             x = A.operate(x).add(B.operate(u)).add(pNoise);              // Simulate the measurement             double mNoise = measurementNoise * rand.sample();              // z = H * x + m_noise             RealVector z = H.operate(x).mapAdd(mNoise);              filter.correct(z);              // state estimate shouldn't be larger than the measurement noise             double diff = FastMath.abs(x.getEntry(0) - filter.getStateEstimation()[0]);             Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);         }          // error covariance of the velocity should be already very low (< 0.1)         Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[1][1],                                               0.1d, 1e-6) < 0);     }      /**      * Represents an idealized Cannonball only taking into account gravity.      */     public static class Cannonball {          private final double[] gravity = { 0, -9.81 };          private final double[] velocity;         private final double[] location;          private double timeslice;          public Cannonball(double timeslice, double angle, double initialVelocity) {             this.timeslice = timeslice;              final double angleInRadians = FastMath.toRadians(angle);             this.velocity = new double[] {                     initialVelocity * FastMath.cos(angleInRadians),                     initialVelocity * FastMath.sin(angleInRadians)             };              this.location = new double[] { 0, 0 };         }          public double getX() {             return location[0];         }          public double getY() {             return location[1];         }          public double getXVelocity() {             return velocity[0];         }          public double getYVelocity() {             return velocity[1];         }          public void step() {             // break gravitational force into a smaller time slice.             double[] slicedGravity = gravity.clone();             for ( int i = 0; i < slicedGravity.length; i++ ) {                 slicedGravity[i] *= timeslice;             }              // apply the acceleration to velocity.             double[] slicedVelocity = velocity.clone();             for ( int i = 0; i < velocity.length; i++ ) {                 velocity[i] += slicedGravity[i];                 slicedVelocity[i] = velocity[i] * timeslice;                 location[i] += slicedVelocity[i];             }              // cannonballs shouldn't go into the ground.             if ( location[1] < 0 ) {                 location[1] = 0;             }         }     }      @Test     public void testCannonball() {         // simulates the flight of a cannonball (only taking gravity and initial thrust into account)          // number of iterations         final int iterations = 144;         // discrete time interval         final double dt = 0.1d;         // position measurement noise (meter)         final double measurementNoise = 30d;         // the initial velocity of the cannonball         final double initialVelocity = 100;         // shooting angle         final double angle = 45;          final Cannonball cannonball = new Cannonball(dt, angle, initialVelocity);          final double speedX = cannonball.getXVelocity();         final double speedY = cannonball.getYVelocity();          // A = [ 1, dt, 0,  0 ]  =>  x(n+1) = x(n) + vx(n)         //     [ 0,  1, 0,  0 ]  => vx(n+1) =        vx(n)         //     [ 0,  0, 1, dt ]  =>  y(n+1) =              y(n) + vy(n)         //     [ 0,  0, 0,  1 ]  => vy(n+1) =                     vy(n)         final RealMatrix A = MatrixUtils.createRealMatrix(new double[][] {                 { 1, dt, 0,  0 },                 { 0,  1, 0,  0 },                 { 0,  0, 1, dt },                 { 0,  0, 0,  1 }         });          // The control vector, which adds acceleration to the kinematic equations.         // 0          =>  x(n+1) =  x(n+1)         // 0          => vx(n+1) = vx(n+1)         // -9.81*dt^2 =>  y(n+1) =  y(n+1) - 1/2 * 9.81 * dt^2         // -9.81*dt   => vy(n+1) = vy(n+1) - 9.81 * dt         final RealVector controlVector =                 MatrixUtils.createRealVector(new double[] { 0, 0, 0.5 * -9.81 * dt * dt, -9.81 * dt } );          // The control matrix B only expects y and vy, see control vector         final RealMatrix B = MatrixUtils.createRealMatrix(new double[][] {                 { 0, 0, 0, 0 },                 { 0, 0, 0, 0 },                 { 0, 0, 1, 0 },                 { 0, 0, 0, 1 }         });          // We only observe the x/y position of the cannonball         final RealMatrix H = MatrixUtils.createRealMatrix(new double[][] {                 { 1, 0, 0, 0 },                 { 0, 0, 0, 0 },                 { 0, 0, 1, 0 },                 { 0, 0, 0, 0 }         });          // our guess of the initial state.         final RealVector initialState = MatrixUtils.createRealVector(new double[] { 0, speedX, 0, speedY } );          // the initial error covariance matrix, the variance = noise^2         final double var = measurementNoise * measurementNoise;         final RealMatrix initialErrorCovariance = MatrixUtils.createRealMatrix(new double[][] {                 { var,    0,   0,    0 },                 {   0, 1e-3,   0,    0 },                 {   0,    0, var,    0 },                 {   0,    0,   0, 1e-3 }         });          // we assume no process noise -> zero matrix         final RealMatrix Q = MatrixUtils.createRealMatrix(4, 4);          // the measurement covariance matrix         final RealMatrix R = MatrixUtils.createRealMatrix(new double[][] {                 { var,    0,   0,    0 },                 {   0, 1e-3,   0,    0 },                 {   0,    0, var,    0 },                 {   0,    0,   0, 1e-3 }         });          final ProcessModel pm = new DefaultProcessModel(A, B, Q, initialState, initialErrorCovariance);         final MeasurementModel mm = new DefaultMeasurementModel(H, R);         final KalmanFilter filter = new KalmanFilter(pm, mm);          final ContinuousDistribution.Sampler dist = new NormalDistribution(0, measurementNoise).createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1001));          for (int i = 0; i < iterations; i++) {             // get the "real" cannonball position             double x = cannonball.getX();             double y = cannonball.getY();              // apply measurement noise to current cannonball position             double nx = x + dist.sample();             double ny = y + dist.sample();              cannonball.step();              filter.predict(controlVector);             // correct the filter with our measurements             filter.correct(new double[] { nx, 0, ny, 0 } );              // state estimate shouldn't be larger than the measurement noise             double diff = FastMath.abs(cannonball.getY() - filter.getStateEstimation()[2]);             Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);         }          // error covariance of the x/y-position should be already very low (< 3m std dev = 9 variance)          Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[0][0],                                               9, 1e-6) < 0);          Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[2][2],                                               9, 1e-6) < 0);     }      private void assertVectorEquals(double[] expected, double[] result) {         Assert.assertEquals("Wrong number of rows.", expected.length,                             result.length);         for (int i = 0; i < expected.length; i++) {             Assert.assertEquals("Wrong value at position [" + i + "]",                                 expected[i], result[i], 1.0e-6);         }     }      private void assertMatrixEquals(double[][] expected, double[][] result) {         Assert.assertEquals("Wrong number of rows.", expected.length,                             result.length);         for (int i = 0; i < expected.length; i++) {             Assert.assertEquals("Wrong number of columns.", expected[i].length,                                 result[i].length);             for (int j = 0; j < expected[i].length; j++) {                 Assert.assertEquals("Wrong value at position [" + i + "," + j                                     + "]", expected[i][j], result[i][j], 1.0e-6);             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.complex;  import java.util.Locale;   public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {      @Override     protected char getDecimalCharacter() {         return ',';     }      @Override     protected Locale getLocale() {         return Locale.FRENCH;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.complex;  import java.util.Locale;   public class ComplexFormatTest extends ComplexFormatAbstractTest {     @Override     protected char getDecimalCharacter() {         return '.';     }      @Override     protected Locale getLocale() {         return Locale.US;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.complex;  import java.text.FieldPosition; import java.text.NumberFormat; import java.text.ParsePosition; import java.util.Arrays; import java.util.HashSet; import java.util.Locale; import org.junit.Test; import org.junit.Assert; import org.apache.commons.numbers.complex.Complex; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.util.FastMath;  public abstract class ComplexFormatAbstractTest {      ComplexFormat complexFormat = null;     ComplexFormat complexFormatJ = null;      protected abstract Locale getLocale();      protected abstract char getDecimalCharacter();      protected ComplexFormatAbstractTest() {         complexFormat = ComplexFormat.getInstance(getLocale());         complexFormatJ = ComplexFormat.getInstance("j", getLocale());     }      @Test     public void testSimpleNoDecimals() {         Complex c = Complex.ofCartesian(1, 2);         String expected = "1 + 2i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testTrimOneImaginary() {         final ComplexFormat fmt = ComplexFormat.getInstance(getLocale());         fmt.getImaginaryFormat().setMaximumFractionDigits(1);          Complex c = Complex.ofCartesian(1, 1.04);         String expected = "1 + i";         String actual = fmt.format(c);         Assert.assertEquals(expected, actual);          c = Complex.ofCartesian(1, 1.09);         expected = "1 + 1" + getDecimalCharacter() + "1i";         actual = fmt.format(c);         Assert.assertEquals(expected, actual);          c = Complex.ofCartesian(1, -1.09);         expected = "1 - 1" + getDecimalCharacter() + "1i";         actual = fmt.format(c);         Assert.assertEquals(expected, actual);          c = Complex.ofCartesian(1, -1.04);         expected = "1 - i";         actual = fmt.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testSimpleWithDecimals() {         Complex c = Complex.ofCartesian(1.23, 1.43);         String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testSimpleWithDecimalsTrunc() {         Complex c = Complex.ofCartesian(1.232323232323, 1.434343434343);         String expected = "1" + getDecimalCharacter() + "2323232323 + 1" + getDecimalCharacter() + "4343434343i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeReal() {         Complex c = Complex.ofCartesian(-1.232323232323, 1.43);         String expected = "-1" + getDecimalCharacter() + "2323232323 + 1" + getDecimalCharacter() + "43i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeImaginary() {         Complex c = Complex.ofCartesian(1.23, -1.434343434343);         String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "4343434343i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeBoth() {         Complex c = Complex.ofCartesian(-1.232323232323, -1.434343434343);         String expected = "-1" + getDecimalCharacter() + "2323232323 - 1" + getDecimalCharacter() + "4343434343i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testZeroReal() {         Complex c = Complex.ofCartesian(0.0, -1.434343434343);         String expected = "0 - 1" + getDecimalCharacter() + "4343434343i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testZeroImaginary() {         Complex c = Complex.ofCartesian(30.23333333333, 0);         String expected = "30" + getDecimalCharacter() + "2333333333";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testDifferentImaginaryChar() {         Complex c = Complex.ofCartesian(1, 1);         String expected = "1 + j";         String actual = complexFormatJ.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testDefaultFormatComplex() {         Locale defaultLocal = Locale.getDefault();         Locale.setDefault(getLocale());          Complex c = Complex.ofCartesian(232.22222222222, -342.3333333333);         String expected = "232" + getDecimalCharacter() + "2222222222 - 342" + getDecimalCharacter() + "3333333333i";         String actual = (new ComplexFormat()).format(c);         Assert.assertEquals(expected, actual);          Locale.setDefault(defaultLocal);     }      @Test     public void testNan() {         Complex c = Complex.ofCartesian(Double.NaN, Double.NaN);         String expected = "(NaN) + (NaN)i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testPositiveInfinity() {         Complex c = Complex.ofCartesian(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);         String expected = "(Infinity) + (Infinity)i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeInfinity() {         Complex c = Complex.ofCartesian(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);         String expected = "(-Infinity) - (Infinity)i";         String actual = complexFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseSimpleNoDecimals() {         String source = "1 + 1i";         Complex expected = Complex.ofCartesian(1, 1);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseSimpleWithDecimals() {         String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";         Complex expected = Complex.ofCartesian(1.23, 1.43);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseSimpleWithDecimalsTrunc() {         String source = "1" + getDecimalCharacter() + "232323232323 + 1" + getDecimalCharacter() + "434343434343i";         Complex expected = Complex.ofCartesian(1.232323232323, 1.434343434343);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeReal() {         String source = "-1" + getDecimalCharacter() + "232323232323 + 1" + getDecimalCharacter() + "4343i";         Complex expected = Complex.ofCartesian(-1.232323232323, 1.4343);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeImaginary() {         String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "434343434343i";         Complex expected = Complex.ofCartesian(1.2323, -1.434343434343);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeBoth() {         String source = "-1" + getDecimalCharacter() + "232323232323 - 1" + getDecimalCharacter() + "434343434343i";         Complex expected = Complex.ofCartesian(-1.232323232323, -1.434343434343);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseZeroReal() {         String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i";         Complex expected = Complex.ofCartesian(0.0, -1.4343);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseZeroImaginary() {         String source = "-1" + getDecimalCharacter() + "2323";         Complex expected = Complex.ofCartesian(-1.2323, 0);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseDifferentImaginaryChar() {         String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j";         Complex expected = Complex.ofCartesian(-1.2323, -1.4343);         Complex actual = complexFormatJ.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNan() {         String source = "(NaN) + (NaN)i";         Complex expected = Complex.ofCartesian(Double.NaN, Double.NaN);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParsePositiveInfinity() {         String source = "(Infinity) + (Infinity)i";         Complex expected = Complex.ofCartesian(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testPaseNegativeInfinity() {         String source = "(-Infinity) - (Infinity)i";         Complex expected = Complex.ofCartesian(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);         Complex actual = complexFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testConstructorSingleFormat() {         NumberFormat nf = NumberFormat.getInstance();         ComplexFormat cf = new ComplexFormat(nf);         Assert.assertNotNull(cf);         Assert.assertEquals(nf, cf.getRealFormat());     }      @Test     public void testConstructorExceptions() {         NumberFormat nullFormat = null;         NumberFormat format = NumberFormat.getInstance();         try {             ComplexFormat cf = new ComplexFormat(nullFormat);         }         catch (Exception e) {             Assert.assertTrue(e instanceof NullArgumentException);         }         try {             ComplexFormat cf = new ComplexFormat(nullFormat, format);         }         catch (Exception e) {             Assert.assertTrue(e instanceof NullArgumentException);         }         try {             ComplexFormat cf = new ComplexFormat(format, nullFormat);         }         catch (Exception e) {             Assert.assertTrue(e instanceof NullArgumentException);         }     }      @Test     public void testConstructorDoubleFormat() {         NumberFormat defaultFormat = NumberFormat.getInstance();         NumberFormat numberFormat = NumberFormat.getNumberInstance();         ComplexFormat cf = new ComplexFormat(defaultFormat, numberFormat);         Assert.assertEquals(defaultFormat, cf.getRealFormat());         Assert.assertEquals(numberFormat, cf.getImaginaryFormat());     }      @Test     public void testStringConstructor() {         String nullString = null;         String emptyString = "";         String oddImaginaryCharacter = "q";         try {             ComplexFormat cf = new ComplexFormat(nullString);         }         catch (Exception e) {             Assert.assertTrue(e instanceof NullArgumentException);         }         try {             ComplexFormat cf = new ComplexFormat(emptyString);         }         catch (Exception e) {             Assert.assertTrue(e instanceof NoDataException);         }         ComplexFormat cf = new ComplexFormat(oddImaginaryCharacter);         Assert.assertEquals(oddImaginaryCharacter, cf.getImaginaryCharacter());     }      @Test     public void testGetAvailableLocales() {         Assert.assertEquals(new HashSet<>(Arrays.asList(NumberFormat.getAvailableLocales())),                             new HashSet<>(Arrays.asList(ComplexFormat.getAvailableLocales())));     }      @Test     public void testGetInstance() {         ComplexFormat cf = ComplexFormat.getInstance();         Assert.assertNotNull(cf);         Assert.assertNotNull(cf.getRealFormat());         Assert.assertNotNull(cf.getImaginaryFormat());         Assert.assertTrue(cf.getRealFormat() instanceof NumberFormat);         Assert.assertTrue(cf.getImaginaryFormat() instanceof NumberFormat);     }      @Test     public void testFormatObjectStringBufferFieldPositionWithComplex() {         ComplexFormat cf = ComplexFormat.getInstance(getLocale());         String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";         Object expected = Complex.ofCartesian(1.23, 1.43);         String formatted = cf.format(expected, new StringBuffer(), new FieldPosition(0)).toString();         Assert.assertEquals(source, formatted);     }      @Test     public void testFormatObjectStringBufferFieldPositionWitNumber() {         ComplexFormat cf = ComplexFormat.getInstance(getLocale());         String source = "1" + getDecimalCharacter() + "23";         Number expected = new Double(1.23);         String formatted = cf.format(expected, new StringBuffer(), new FieldPosition(0)).toString();         Assert.assertEquals(source, formatted);     }      @Test     public void testFormatObjectStringBufferFieldPositionException() {         ComplexFormat cf = ComplexFormat.getInstance();         Object expected = "Something that's not a number or Complex";         try {             String formatted = cf.format(expected, new StringBuffer(), new FieldPosition(0)).toString();         }         catch (Exception e) {             Assert.assertTrue(e instanceof MathIllegalArgumentException);         }      }      @Test     public void testGetImaginaryFormat() {         NumberFormat nf = NumberFormat.getInstance();         ComplexFormat cf = new ComplexFormat(nf);         Assert.assertSame(nf, cf.getImaginaryFormat());     }      @Test     public void testGetRealFormat() {         NumberFormat nf = NumberFormat.getInstance();         ComplexFormat cf = new ComplexFormat(nf);         Assert.assertSame(nf, cf.getRealFormat());     }      @Test     public void testFormatNumber() {         ComplexFormat cf = ComplexFormat.getInstance(getLocale());         Double pi = Double.valueOf(FastMath.PI);         String text = cf.format(pi);         Assert.assertEquals("3" + getDecimalCharacter() + "1415926536", text);     }      @Test     public void testForgottenImaginaryCharacter() {         ParsePosition pos = new ParsePosition(0);         Assert.assertNull(new ComplexFormat().parse("1 + 1", pos));         Assert.assertEquals(5, pos.getErrorIndex());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4;  import java.util.regex.Pattern; import java.util.regex.Matcher; import java.util.regex.MatchResult; import java.util.concurrent.Callable;  import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.rng.sampling.PermutationSampler; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.util.LocalizedFormats; import org.apache.commons.math4.stat.descriptive.StatisticalSummary; import org.apache.commons.math4.stat.descriptive.SummaryStatistics;  /**  * Simple benchmarking utilities.  */ public class PerfTestUtils {     /** Formatting. */     private static final int DEFAULT_MAX_NAME_WIDTH = 45;     /** Formatting. */     private static final String ELLIPSIS = "...";     /** Formatting. */     private static final String TO_STRING_MEMORY_ADDRESS_REGEX = "@\\p{XDigit}{1,8}";     /** Formatting. */     private static final String JAVA_IDENTIFIER_REGEX =         "(\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*\\.)*\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*";     /** Formatting. */     private static final Pattern JAVA_IDENTIFIER_PATTERN =         Pattern.compile(JAVA_IDENTIFIER_REGEX);     /** Nanoseconds to milliseconds conversion factor ({@value}). */     public static final double NANO_TO_MILLI = 1e-6;     /** Default number of code repeat per timed block. */     private static final int DEFAULT_REPEAT_CHUNK = 1000;     /** Default number of code repeats for computing the average run time. */     private static final int DEFAULT_REPEAT_STAT = 10000;     /** RNG. */     private static UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C);      /**      * Timing.      *      * @param repeatChunk Each timing measurement will done done for that      * number of repeats of the code.      * @param repeatStat Timing will be averaged over that number of runs.      * @param runGC Call {@code System.gc()} between each timed block. When      * set to {@code true}, the test will run much slower.      * @param methods Codes being timed.      * @return for each of the given {@code methods}, a      * {@link StatisticalSummary} of the average times (in milliseconds)      * taken by a single call to the {@code call} method (i.e. the time      * taken by each timed block divided by {@code repeatChunk}).      */     @SafeVarargs     public static StatisticalSummary[] time(int repeatChunk,                                             int repeatStat,                                             boolean runGC,                                             Callable<Double> ... methods) {         final double[][][] times = timesAndResults(repeatChunk,                                                    repeatStat,                                                    runGC,                                                    methods);          final int len = methods.length;         final StatisticalSummary[] stats = new StatisticalSummary[len];         for (int j = 0; j < len; j++) {             final SummaryStatistics s = new SummaryStatistics();             for (int k = 0; k < repeatStat; k++) {                 s.addValue(times[j][k][0]);             }             stats[j] = s.getSummary();         }          return stats;     }      /**      * Timing.      *      * @param repeatChunk Each timing measurement will done done for that      * number of repeats of the code.      * @param repeatStat Timing will be averaged over that number of runs.      * @param runGC Call {@code System.gc()} between each timed block. When      * set to {@code true}, the test will run much slower.      * @param methods Codes being timed.      * @return for each of the given {@code methods} (first dimension), and      * each of the {@code repeatStat} runs (second dimension):      * <ul>      *  <li>      *   the average time (in milliseconds) taken by a single call to the      *   {@code call} method (i.e. the time taken by each timed block divided      *   by {@code repeatChunk})      *  </li>      *  <li>      *   the result returned by the {@code call} method.      *  </li>      * </ul>      */     @SafeVarargs     public static double[][][] timesAndResults(int repeatChunk,                                                int repeatStat,                                                boolean runGC,                                                Callable<Double> ... methods) {         final int numMethods = methods.length;         final double[][][] timesAndResults = new double[numMethods][repeatStat][2];          // Indices into the array containing the methods to benchmark.         // The purpose is that at each repeat, the "methods" are called in a different order.         final int[] methodSequence = PermutationSampler.natural(numMethods);          try {             for (int k = 0; k < repeatStat; k++) {                 PermutationSampler.shuffle(rng, methodSequence);                 for (int n = 0; n < numMethods; n++) {                     final int j = methodSequence[n]; // Index of the timed method.                      if (runGC) {                         // Try to perform GC outside the timed block.                         System.gc();                     }                      final Callable<Double> r = methods[j];                     final double[] result = new double[repeatChunk];                      // Timed block.                     final long start = System.nanoTime();                     for (int i = 0; i < repeatChunk; i++) {                         result[i] = r.call().doubleValue();                     }                     final long stop = System.nanoTime();                      // Collect run time.                     timesAndResults[j][k][0] = (stop - start) * NANO_TO_MILLI;                     // Keep track of a randomly selected result.                     timesAndResults[j][k][1] = result[rng.nextInt(repeatChunk)];                 }             }         } catch (Exception e) {             // Abort benchmarking if codes throw exceptions.             throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, e.getMessage());         }          final double normFactor = 1d / repeatChunk;         for (int j = 0; j < numMethods; j++) {             for (int k = 0; k < repeatStat; k++) {                 timesAndResults[j][k][0] *= normFactor;             }         }          return timesAndResults;     }      /**      * Timing and report (to standard output) the average time and standard      * deviation of a single call.      * The timing is performed by calling the      * {@link #time(int,int,boolean,Callable[]) time} method.      *      * @param title Title of the test (for the report).      * @param maxNameWidth Maximum width of the first column of the report.      * @param repeatChunk Each timing measurement will done done for that      * number of repeats of the code.      * @param repeatStat Timing will be averaged over that number of runs.      * @param runGC Call {@code System.gc()} between each timed block. When      * set to {@code true}, the test will run much slower.      * @param methods Codes being timed.      * @return for each of the given {@code methods}, a statistics of the      * average times (in milliseconds) taken by a single call to the      * {@code call} method (i.e. the time taken by each timed block divided      * by {@code repeatChunk}).      */     @SuppressWarnings("boxing")     public static StatisticalSummary[] timeAndReport(String title,                                                      int maxNameWidth,                                                      int repeatChunk,                                                      int repeatStat,                                                      boolean runGC,                                                      RunTest ... methods) {         // Header format.         final String hFormat = "%s (calls per timed block: %d, timed blocks: %d, time unit: ms)";          // TODO: user-defined parameter?         final boolean removePackageName = false;          // Width of the longest name.         int nameLength = 0;         for (RunTest m : methods) {             int len = shorten(m.getName(), removePackageName).length();             if (len > nameLength) {                 nameLength = len;             }         }         final int actualNameLength = nameLength < maxNameWidth ?             nameLength :             maxNameWidth;         final String nameLengthFormat = "%" + actualNameLength + "s";          // Column format.         final String cFormat = nameLengthFormat + " %9s %7s %10s %5s %4s %10s";         // Result format.         final String format = nameLengthFormat + " %.3e %.1e %.4e %.3f %.2f %.4e";          System.out.println(String.format(hFormat,                                          title,                                          repeatChunk,                                          repeatStat));         System.out.println(String.format(cFormat,                                          "name",                                          "time/call",                                          "std dev",                                          "total time",                                          "ratio",                                          "cv",                                          "difference"));         final StatisticalSummary[] time = time(repeatChunk,                                                repeatStat,                                                runGC,                                                methods);         final double refSum = time[0].getSum() * repeatChunk;         for (int i = 0, max = time.length; i < max; i++) {             final StatisticalSummary s = time[i];             final double sum = s.getSum() * repeatChunk;             final double mean = s.getMean();             final double sigma = s.getStandardDeviation();             System.out.println(String.format(format,                                              truncate(shorten(methods[i].getName(),                                                               removePackageName),                                                       actualNameLength,                                                       ELLIPSIS),                                              mean,                                              sigma,                                              sum,                                              sum / refSum,                                              sigma / mean,                                              sum - refSum));         }          return time;     }      /**      * Timing and report (to standard output).      * This method calls {@link #timeAndReport(String,int,int,int,boolean,RunTest[])      * timeAndReport(title, 45, 1000, 10000, false, methods)}.      *      * @param title Title of the test (for the report).      * @param methods Codes being timed.      * @return for each of the given {@code methods}, a statistics of the      * average times (in milliseconds) taken by a single call to the      * {@code call} method (i.e. the time taken by each timed block divided      * by {@code repeatChunk}).      */     public static StatisticalSummary[] timeAndReport(String title,                                                      RunTest ... methods) {         return timeAndReport(title,                              DEFAULT_MAX_NAME_WIDTH,                              DEFAULT_REPEAT_CHUNK,                              DEFAULT_REPEAT_STAT,                              false,                              methods);     }      /**      * Utility class for storing a test label.      */     public static abstract class RunTest implements Callable<Double> {         private final String name;          /**          * @param name Test name.          */         public RunTest(String name) {             this.name = name;         }          /**          * @return the name of this test.          */         public String getName() {             return name;         }          /** {@inheritDoc} */         @Override         public abstract Double call() throws Exception;     }      /**      * Truncates a string so that it will not be longer than the      * specified length.      *      * @param str String to truncate.      * @param maxLength Maximum length.      * @param ellipsis String to use in place of the part being removed      * from the original string.      * @return the truncated string.      * @throws NumberIsTooLargeException if the length of {@code ellipsis}      * is larger than {@code maxLength - 2}.      */     private static String truncate(String str,                                    int maxLength,                                    String ellipsis) {         final int ellSize = ellipsis.length();         if (ellSize > maxLength - 2) {             throw new NumberIsTooLargeException(ellSize, maxLength - 2, false);         }          final int strSize = str.length();         if (strSize <= maxLength) {             // Size is OK.             return str;         }          return str.substring(0, maxLength - ellSize) + ellipsis;     }      /**      * Shortens a string.      * It will shorten package names and remove memory addresses      * that appear in an instance's name.      *      * @param str Original string.      * @param removePackageName Whether package name part of a      * fully-qualified name should be removed entirely.      * @return the shortened string.      */     private static String shorten(String str,                                   boolean removePackageName) {         final Matcher m = JAVA_IDENTIFIER_PATTERN.matcher(str);         final StringBuffer sb = new StringBuffer();         while (m.find()) {             final MatchResult r = m.toMatchResult();             m.appendReplacement(sb, shortenPackageName(r.group(),                                                        removePackageName));         }         m.appendTail(sb);          return sb.toString().replaceAll(TO_STRING_MEMORY_ADDRESS_REGEX, "");     }      /**      * Shortens package part of the name of a class.      *      * @param name Class name.      * @param remove Whether package name part of a fully-qualified      * name should be removed entirely.      * @return the shortened name.      */     private static String shortenPackageName(String name,                                              boolean remove) {         final String[] comp = name.split("\\.");         final int last = comp.length - 1;          if (remove) {             return comp[last];         }          final StringBuilder s = new StringBuilder();         for (int i = 0; i < last; i++) {             s.append(comp[i].substring(0, 1)).append(".");         }         s.append(comp[last]);          return s.toString();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.twod;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Collection; import java.util.Set; import java.util.HashSet; import java.util.List; import java.util.stream.StreamSupport; import java.util.stream.Collectors;  import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.ml.neuralnet.FeatureInitializer; import org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory; import org.apache.commons.math4.ml.neuralnet.Network; import org.apache.commons.math4.ml.neuralnet.Neuron; import org.apache.commons.math4.ml.neuralnet.SquareNeighbourhood; import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link NeuronSquareMesh2D} and {@link Network} functionality for  * a two-dimensional network.  */ public class NeuronSquareMesh2DTest {     final FeatureInitializer init = FeatureInitializerFactory.uniform(0, 2);      @Test(expected=NumberIsTooSmallException.class)     public void testMinimalNetworkSize1() {         final FeatureInitializer[] initArray = { init };          new NeuronSquareMesh2D(1, false,                                2, false,                                SquareNeighbourhood.VON_NEUMANN,                                initArray);     }      @Test(expected=NumberIsTooSmallException.class)     public void testMinimalNetworkSize2() {         final FeatureInitializer[] initArray = { init };          new NeuronSquareMesh2D(2, false,                                0, false,                                SquareNeighbourhood.VON_NEUMANN,                                initArray);     }      @Test     public void testGetFeaturesSize() {         final FeatureInitializer[] initArray = { init, init, init };          final Network net = new NeuronSquareMesh2D(2, false,                                                    2, false,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();         Assert.assertEquals(3, net.getFeaturesSize());     }       /*      * Test assumes that the network is      *      *  0-----1      *  |     |      *  |     |      *  2-----3      */     @Test     public void test2x2Network() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(2, false,                                                    2, false,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // Neurons 0 and 3.         for (long id : new long[] { 0, 3 }) {             neighbours = net.getNeighbours(net.getNeuron(id));             for (long nId : new long[] { 1, 2 }) {                 Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));             }             // Ensures that no other neurons is in the neighbourhood set.             Assert.assertEquals(2, neighbours.size());         }          // Neurons 1 and 2.         for (long id : new long[] { 1, 2 }) {             neighbours = net.getNeighbours(net.getNeuron(id));             for (long nId : new long[] { 0, 3 }) {                 Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));             }             // Ensures that no other neurons is in the neighbourhood set.             Assert.assertEquals(2, neighbours.size());         }     }      /*      * Test assumes that the network is      *      *  0-----1      *  |     |      *  |     |      *  2-----3      */     @Test     public void test2x2Network2() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(2, false,                                                    2, false,                                                    SquareNeighbourhood.MOORE,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // All neurons         for (long id : new long[] { 0, 1, 2, 3 }) {             neighbours = net.getNeighbours(net.getNeuron(id));             for (long nId : new long[] { 0, 1, 2, 3 }) {                 if (id != nId) {                     Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));                 }             }         }     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      */     @Test     public void test3x2CylinderNetwork() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(2, false,                                                    3, true,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // Neuron 0.         neighbours = net.getNeighbours(net.getNeuron(0));         for (long nId : new long[] { 1, 2, 3 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 1.         neighbours = net.getNeighbours(net.getNeuron(1));         for (long nId : new long[] { 0, 2, 4 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 2.         neighbours = net.getNeighbours(net.getNeuron(2));         for (long nId : new long[] { 0, 1, 5 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 3.         neighbours = net.getNeighbours(net.getNeuron(3));         for (long nId : new long[] { 0, 4, 5 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 4.         neighbours = net.getNeighbours(net.getNeuron(4));         for (long nId : new long[] { 1, 3, 5 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 5.         neighbours = net.getNeighbours(net.getNeuron(5));         for (long nId : new long[] { 2, 3, 4 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      */     @Test     public void test3x2CylinderNetwork2() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(2, false,                                                    3, true,                                                    SquareNeighbourhood.MOORE,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // All neurons.         for (long id : new long[] { 0, 1, 2, 3, 4, 5 }) {             neighbours = net.getNeighbours(net.getNeuron(id));             for (long nId : new long[] { 0, 1, 2, 3, 4, 5 }) {                 if (id != nId) {                     Assert.assertTrue("id=" + id + " nId=" + nId,                                       neighbours.contains(net.getNeuron(nId)));                 }             }         }     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      *  |     |     |      *  |     |     |      *  6-----7-----8      */     @Test     public void test3x3TorusNetwork() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(3, true,                                                    3, true,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // Neuron 0.         neighbours = net.getNeighbours(net.getNeuron(0));         for (long nId : new long[] { 1, 2, 3, 6 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 1.         neighbours = net.getNeighbours(net.getNeuron(1));         for (long nId : new long[] { 0, 2, 4, 7 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 2.         neighbours = net.getNeighbours(net.getNeuron(2));         for (long nId : new long[] { 0, 1, 5, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 3.         neighbours = net.getNeighbours(net.getNeuron(3));         for (long nId : new long[] { 0, 4, 5, 6 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 4.         neighbours = net.getNeighbours(net.getNeuron(4));         for (long nId : new long[] { 1, 3, 5, 7 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 5.         neighbours = net.getNeighbours(net.getNeuron(5));         for (long nId : new long[] { 2, 3, 4, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 6.         neighbours = net.getNeighbours(net.getNeuron(6));         for (long nId : new long[] { 0, 3, 7, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 7.         neighbours = net.getNeighbours(net.getNeuron(7));         for (long nId : new long[] { 1, 4, 6, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // Neuron 8.         neighbours = net.getNeighbours(net.getNeuron(8));         for (long nId : new long[] { 2, 5, 6, 7 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      *  |     |     |      *  |     |     |      *  6-----7-----8      */     @Test     public void test3x3TorusNetwork2() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(3, true,                                                    3, true,                                                    SquareNeighbourhood.MOORE,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // All neurons.         for (long id : new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 }) {             neighbours = net.getNeighbours(net.getNeuron(id));             for (long nId : new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 }) {                 if (id != nId) {                     Assert.assertTrue("id=" + id + " nId=" + nId,                                       neighbours.contains(net.getNeuron(nId)));                 }             }         }     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      *  |     |     |      *  |     |     |      *  6-----7-----8      */     @Test     public void test3x3CylinderNetwork() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(3, false,                                                    3, true,                                                    SquareNeighbourhood.MOORE,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // Neuron 0.         neighbours = net.getNeighbours(net.getNeuron(0));         for (long nId : new long[] { 1, 2, 3, 4, 5}) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 1.         neighbours = net.getNeighbours(net.getNeuron(1));         for (long nId : new long[] { 0, 2, 3, 4, 5 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 2.         neighbours = net.getNeighbours(net.getNeuron(2));         for (long nId : new long[] { 0, 1, 3, 4, 5 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 3.         neighbours = net.getNeighbours(net.getNeuron(3));         for (long nId : new long[] { 0, 1, 2, 4, 5, 6, 7, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(8, neighbours.size());          // Neuron 4.         neighbours = net.getNeighbours(net.getNeuron(4));         for (long nId : new long[] { 0, 1, 2, 3, 5, 6, 7, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(8, neighbours.size());          // Neuron 5.         neighbours = net.getNeighbours(net.getNeuron(5));         for (long nId : new long[] { 0, 1, 2, 3, 4, 6, 7, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(8, neighbours.size());          // Neuron 6.         neighbours = net.getNeighbours(net.getNeuron(6));         for (long nId : new long[] { 3, 4, 5, 7, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 7.         neighbours = net.getNeighbours(net.getNeuron(7));         for (long nId : new long[] { 3, 4, 5, 6, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 8.         neighbours = net.getNeighbours(net.getNeuron(8));         for (long nId : new long[] { 3, 4, 5, 6, 7 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      *  |     |     |      *  |     |     |      *  6-----7-----8      */     @Test     public void test3x3CylinderNetwork2() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(3, false,                                                    3, false,                                                    SquareNeighbourhood.MOORE,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // Neuron 0.         neighbours = net.getNeighbours(net.getNeuron(0));         for (long nId : new long[] { 1, 3, 4}) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 1.         neighbours = net.getNeighbours(net.getNeuron(1));         for (long nId : new long[] { 0, 2, 3, 4, 5 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 2.         neighbours = net.getNeighbours(net.getNeuron(2));         for (long nId : new long[] { 1, 4, 5 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 3.         neighbours = net.getNeighbours(net.getNeuron(3));         for (long nId : new long[] { 0, 1, 4, 6, 7 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 4.         neighbours = net.getNeighbours(net.getNeuron(4));         for (long nId : new long[] { 0, 1, 2, 3, 5, 6, 7, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(8, neighbours.size());          // Neuron 5.         neighbours = net.getNeighbours(net.getNeuron(5));         for (long nId : new long[] { 1, 2, 4, 7, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 6.         neighbours = net.getNeighbours(net.getNeuron(6));         for (long nId : new long[] { 3, 4, 7 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());          // Neuron 7.         neighbours = net.getNeighbours(net.getNeuron(7));         for (long nId : new long[] { 3, 4, 5, 6, 8 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(5, neighbours.size());          // Neuron 8.         neighbours = net.getNeighbours(net.getNeuron(8));         for (long nId : new long[] { 4, 5, 7 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(3, neighbours.size());     }      /*      * Test assumes that the network is      *      *  0-----1-----2-----3-----4      *  |     |     |     |     |      *  |     |     |     |     |      *  5-----6-----7-----8-----9      *  |     |     |     |     |      *  |     |     |     |     |      *  10----11----12----13---14      *  |     |     |     |     |      *  |     |     |     |     |      *  15----16----17----18---19      *  |     |     |     |     |      *  |     |     |     |     |      *  20----21----22----23---24      */     @Test     public void testConcentricNeighbourhood() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(5, true,                                                    5, true,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();          Collection<Neuron> neighbours;         Collection<Neuron> exclude = new HashSet<>();          // Level-1 neighbourhood.         neighbours = net.getNeighbours(net.getNeuron(12));         for (long nId : new long[] { 7, 11, 13, 17 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(4, neighbours.size());          // 1. Add the neuron to the "exclude" list.         exclude.add(net.getNeuron(12));         // 2. Add all neurons from level-1 neighbourhood.         exclude.addAll(neighbours);         // 3. Retrieve level-2 neighbourhood.         neighbours = net.getNeighbours(neighbours, exclude);         for (long nId : new long[] { 6, 8, 16, 18, 2, 10, 14, 22 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(8, neighbours.size());     }      /*      * Test assumes that the network is      *      *  0-----1-----2-----3-----4      *  |     |     |     |     |      *  |     |     |     |     |      *  5-----6-----7-----8-----9      *  |     |     |     |     |      *  |     |     |     |     |      *  10----11----12----13---14      *  |     |     |     |     |      *  |     |     |     |     |      *  15----16----17----18---19      *  |     |     |     |     |      *  |     |     |     |     |      *  20----21----22----23---24      */     @Test     public void testConcentricNeighbourhood2() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(5, true,                                                    5, true,                                                    SquareNeighbourhood.MOORE,                                                    initArray).getNetwork();          Collection<Neuron> neighbours;         Collection<Neuron> exclude = new HashSet<>();          // Level-1 neighbourhood.         neighbours = net.getNeighbours(net.getNeuron(8));         for (long nId : new long[] { 2, 3, 4, 7, 9, 12, 13, 14 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(8, neighbours.size());          // 1. Add the neuron to the "exclude" list.         exclude.add(net.getNeuron(8));         // 2. Add all neurons from level-1 neighbourhood.         exclude.addAll(neighbours);         // 3. Retrieve level-2 neighbourhood.         neighbours = net.getNeighbours(neighbours, exclude);         for (long nId : new long[] { 1, 6, 11, 16, 17, 18, 19, 15, 10, 5, 0, 20, 24, 23, 22, 21 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(16, neighbours.size());     }      @Test     public void testSerialize()         throws IOException,                ClassNotFoundException {         final FeatureInitializer[] initArray = { init };         final NeuronSquareMesh2D out = new NeuronSquareMesh2D(4, false,                                                               3, true,                                                               SquareNeighbourhood.VON_NEUMANN,                                                               initArray);          final ByteArrayOutputStream bos = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(bos);         oos.writeObject(out);          final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());         final ObjectInputStream ois = new ObjectInputStream(bis);         final NeuronSquareMesh2D in = (NeuronSquareMesh2D) ois.readObject();          for (Neuron nOut : out.getNetwork()) {             final Neuron nIn = in.getNetwork().getNeuron(nOut.getIdentifier());              // Same values.             final double[] outF = nOut.getFeatures();             final double[] inF = nIn.getFeatures();             Assert.assertEquals(outF.length, inF.length);             for (int i = 0; i < outF.length; i++) {                 Assert.assertEquals(outF[i], inF[i], 0d);             }              // Same neighbours.             final Collection<Neuron> outNeighbours = out.getNetwork().getNeighbours(nOut);             final Collection<Neuron> inNeighbours = in.getNetwork().getNeighbours(nIn);             Assert.assertEquals(outNeighbours.size(), inNeighbours.size());             for (Neuron oN : outNeighbours) {                 Assert.assertTrue(inNeighbours.contains(in.getNetwork().getNeuron(oN.getIdentifier())));             }         }     }      /*      * Test assumes that the network is      *      *  0-----1      *  |     |      *  |     |      *  2-----3      */     @Test     public void testGetNeuron() {         final FeatureInitializer[] initArray = { init };         final NeuronSquareMesh2D net = new NeuronSquareMesh2D(2, false,                                                               2, true,                                                               SquareNeighbourhood.VON_NEUMANN,                                                               initArray);         Assert.assertEquals(0, net.getNeuron(0, 0).getIdentifier());         Assert.assertEquals(1, net.getNeuron(0, 1).getIdentifier());         Assert.assertEquals(2, net.getNeuron(1, 0).getIdentifier());         Assert.assertEquals(3, net.getNeuron(1, 1).getIdentifier());          try {             net.getNeuron(2, 0);             Assert.fail("exception expected");         } catch (OutOfRangeException e) {             // Expected.         }         try {             net.getNeuron(0, 2);             Assert.fail("exception expected");         } catch (OutOfRangeException e) {             // Expected.         }         try {             net.getNeuron(-1, 0);             Assert.fail("exception expected");         } catch (OutOfRangeException e) {             // Expected.         }         try {             net.getNeuron(0, -1);             Assert.fail("exception expected");         } catch (OutOfRangeException e) {             // Expected.         }     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      *  |     |     |      *  |     |     |      *  6-----7-----8      */     @Test     public void testGetNeuronAlongDirection() {         final FeatureInitializer[] initArray = { init };         final NeuronSquareMesh2D net = new NeuronSquareMesh2D(3, false,                                                               3, false,                                                               SquareNeighbourhood.VON_NEUMANN,                                                               initArray);         Assert.assertEquals(0, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.LEFT,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         Assert.assertEquals(1, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.CENTER,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         Assert.assertEquals(2, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         Assert.assertEquals(3, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.LEFT,                                              NeuronSquareMesh2D.VerticalDirection.CENTER).getIdentifier());         Assert.assertEquals(4, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.CENTER,                                              NeuronSquareMesh2D.VerticalDirection.CENTER).getIdentifier());         Assert.assertEquals(5, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                              NeuronSquareMesh2D.VerticalDirection.CENTER).getIdentifier());         Assert.assertEquals(6, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.LEFT,                                              NeuronSquareMesh2D.VerticalDirection.DOWN).getIdentifier());         Assert.assertEquals(7, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.CENTER,                                              NeuronSquareMesh2D.VerticalDirection.DOWN).getIdentifier());         Assert.assertEquals(8, net.getNeuron(1, 1,                                              NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                              NeuronSquareMesh2D.VerticalDirection.DOWN).getIdentifier());          // Locations not in map.         Assert.assertNull(net.getNeuron(0, 1,                                         NeuronSquareMesh2D.HorizontalDirection.CENTER,                                         NeuronSquareMesh2D.VerticalDirection.UP));         Assert.assertNull(net.getNeuron(1, 0,                                         NeuronSquareMesh2D.HorizontalDirection.LEFT,                                         NeuronSquareMesh2D.VerticalDirection.CENTER));         Assert.assertNull(net.getNeuron(2, 1,                                         NeuronSquareMesh2D.HorizontalDirection.CENTER,                                         NeuronSquareMesh2D.VerticalDirection.DOWN));         Assert.assertNull(net.getNeuron(1, 2,                                         NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                         NeuronSquareMesh2D.VerticalDirection.CENTER));     }      /*      * Test assumes that the network is      *      *  0-----1-----2      *  |     |     |      *  |     |     |      *  3-----4-----5      *  |     |     |      *  |     |     |      *  6-----7-----8      */     @Test     public void testGetNeuronAlongDirectionWrappedMap() {         final FeatureInitializer[] initArray = { init };         final NeuronSquareMesh2D net = new NeuronSquareMesh2D(3, true,                                                               3, true,                                                               SquareNeighbourhood.VON_NEUMANN,                                                               initArray);         // No wrapping.         Assert.assertEquals(3, net.getNeuron(0, 0,                                              NeuronSquareMesh2D.HorizontalDirection.CENTER,                                              NeuronSquareMesh2D.VerticalDirection.DOWN).getIdentifier());         // With wrapping.         Assert.assertEquals(2, net.getNeuron(0, 0,                                              NeuronSquareMesh2D.HorizontalDirection.LEFT,                                              NeuronSquareMesh2D.VerticalDirection.CENTER).getIdentifier());         Assert.assertEquals(7, net.getNeuron(0, 0,                                              NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         Assert.assertEquals(8, net.getNeuron(0, 0,                                              NeuronSquareMesh2D.HorizontalDirection.LEFT,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         Assert.assertEquals(6, net.getNeuron(0, 0,                                              NeuronSquareMesh2D.HorizontalDirection.CENTER,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         Assert.assertEquals(5, net.getNeuron(0, 0,                                              NeuronSquareMesh2D.HorizontalDirection.LEFT,                                              NeuronSquareMesh2D.VerticalDirection.DOWN).getIdentifier());          // No wrapping.         Assert.assertEquals(1, net.getNeuron(1, 2,                                              NeuronSquareMesh2D.HorizontalDirection.LEFT,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         // With wrapping.         Assert.assertEquals(0, net.getNeuron(1, 2,                                              NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                              NeuronSquareMesh2D.VerticalDirection.UP).getIdentifier());         Assert.assertEquals(3, net.getNeuron(1, 2,                                              NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                              NeuronSquareMesh2D.VerticalDirection.CENTER).getIdentifier());         Assert.assertEquals(6, net.getNeuron(1, 2,                                              NeuronSquareMesh2D.HorizontalDirection.RIGHT,                                              NeuronSquareMesh2D.VerticalDirection.DOWN).getIdentifier());     }      @Test     public void testIterator() {         final FeatureInitializer[] initArray = { init };         final NeuronSquareMesh2D map = new NeuronSquareMesh2D(3, true,                                                               3, true,                                                               SquareNeighbourhood.VON_NEUMANN,                                                               initArray);         final Set<Neuron> fromMap = new HashSet<>();         for (Neuron n : map) {             fromMap.add(n);         }          final Network net = map.getNetwork();         final Set<Neuron> fromNet = new HashSet<>();         for (Neuron n : net) {             fromNet.add(n);         }          for (Neuron n : fromMap) {             Assert.assertTrue(fromNet.contains(n));         }         for (Neuron n : fromNet) {             Assert.assertTrue(fromMap.contains(n));         }     }      @Test     public void testDataVisualization() {         final FeatureInitializer[] initArray = { init };         final NeuronSquareMesh2D map = new NeuronSquareMesh2D(3, true,                                                               3, true,                                                               SquareNeighbourhood.VON_NEUMANN,                                                               initArray);          // Trivial test: Use neurons' features as data.          final List<double[]> data = StreamSupport.stream(map.spliterator(), false)             .map(n -> n.getFeatures())             .collect(Collectors.toList());         final NeuronSquareMesh2D.DataVisualization v = map.computeQualityIndicators(data);          final int numRows = map.getNumberOfRows();         final int numCols = map.getNumberOfColumns();          // Test hits.         final double[][] hits = v.getNormalizedHits();         final double expectedHits = 1d / (numRows * numCols);         for (int i = 0; i < numRows; i++) {             for (int j = 0; j < numCols; j++) {                 Assert.assertEquals(expectedHits, hits[i][j], 0d);             }         }          // Test quantization error.         final double[][] qe = v.getQuantizationError();         final double expectedQE = 0;         for (int i = 0; i < numRows; i++) {             for (int j = 0; j < numCols; j++) {                 Assert.assertEquals(expectedQE, qe[i][j], 0d);             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.twod.util;  import org.apache.commons.math4.ml.neuralnet.Network; import org.apache.commons.math4.ml.neuralnet.FeatureInitializer; import org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory; import org.apache.commons.math4.ml.neuralnet.SquareNeighbourhood; import org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D; import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link LocationFinder}.  */ public class LocationFinderTest {     final FeatureInitializer init = FeatureInitializerFactory.uniform(0, 2);      /*      * Test assumes that the network is      *      *  0-----1      *  |     |      *  |     |      *  2-----3      */     @Test     public void test2x2Network() {         final FeatureInitializer[] initArray = { init };         final NeuronSquareMesh2D map = new NeuronSquareMesh2D(2, false,                                                               2, false,                                                               SquareNeighbourhood.VON_NEUMANN,                                                               initArray);         final LocationFinder finder = new LocationFinder(map);         final Network net = map.getNetwork();         LocationFinder.Location loc;          loc = finder.getLocation(net.getNeuron(0));         Assert.assertEquals(0, loc.getRow());         Assert.assertEquals(0, loc.getColumn());          loc = finder.getLocation(net.getNeuron(1));         Assert.assertEquals(0, loc.getRow());         Assert.assertEquals(1, loc.getColumn());          loc = finder.getLocation(net.getNeuron(2));         Assert.assertEquals(1, loc.getRow());         Assert.assertEquals(0, loc.getColumn());          loc = finder.getLocation(net.getNeuron(3));         Assert.assertEquals(1, loc.getRow());         Assert.assertEquals(1, loc.getColumn());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet;  import java.util.Set; import java.util.HashSet; import java.util.List; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.ml.distance.EuclideanDistance; import org.apache.commons.math4.ml.neuralnet.oned.NeuronString; import org.junit.Test; import org.junit.Assert;  /**  * Tests for {@link MapRanking} class.  */ public class MapRankingTest {     /*      * Test assumes that the network is      *      *  0-----1-----2      */     @Test     public void testFindClosestNeuron() {         final FeatureInitializer init             = new OffsetFeatureInitializer(FeatureInitializerFactory.uniform(-0.1, 0.1));         final FeatureInitializer[] initArray = { init };          final MapRanking ranking = new MapRanking(new NeuronString(3, false, initArray).getNetwork(),                                                   new EuclideanDistance());          final Set<Neuron> allBest = new HashSet<>();         final Set<Neuron> best = new HashSet<>();         double[][] features;          // The following tests ensures that         // 1. the same neuron is always selected when the input feature is         //    in the range of the initializer,         // 2. different network's neuron have been selected by inputs features         //    that belong to different ranges.          best.clear();         features = new double[][] {             { -1 },             { 0.4 },         };         for (double[] f : features) {             best.addAll(ranking.rank(f, 1));         }         Assert.assertEquals(1, best.size());         allBest.addAll(best);          best.clear();         features = new double[][] {             { 0.6 },             { 1.4 },         };         for (double[] f : features) {             best.addAll(ranking.rank(f, 1));         }         Assert.assertEquals(1, best.size());         allBest.addAll(best);          best.clear();         features = new double[][] {             { 1.6 },             { 3 },         };         for (double[] f : features) {             best.addAll(ranking.rank(f, 1));         }         Assert.assertEquals(1, best.size());         allBest.addAll(best);          Assert.assertEquals(3, allBest.size());     }      @Test(expected=NotStrictlyPositiveException.class)     public void testRankPrecondition() {         final FeatureInitializer init             = new OffsetFeatureInitializer(FeatureInitializerFactory.uniform(-0.1, 0.1));         final FeatureInitializer[] initArray = { init };          new MapRanking(new NeuronString(3, false, initArray).getNetwork(),                        new EuclideanDistance()).rank(new double[] { -1 }, 0);     }      @Test     public void testSort() {         final Set<Neuron> list = new HashSet<>();          for (int i = 0; i < 4; i++) {             list.add(new Neuron(i, new double[] { i - 0.5 }));         }          final MapRanking rank = new MapRanking(list, new EuclideanDistance());         final List<Neuron> sorted = rank.rank(new double[] { 3.4 });          final long[] expected = new long[] { 3, 2, 1, 0 };         for (int i = 0; i < list.size(); i++) {             Assert.assertEquals(expected[i], sorted.get(i).getIdentifier());         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.oned;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.Collection;  import org.apache.commons.math4.ml.neuralnet.FeatureInitializer; import org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory; import org.apache.commons.math4.ml.neuralnet.Network; import org.apache.commons.math4.ml.neuralnet.Neuron; import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link NeuronString} and {@link Network} functionality for  * a one-dimensional network.  */ public class NeuronStringTest {     final FeatureInitializer init = FeatureInitializerFactory.uniform(0, 2);      /*      * Test assumes that the network is      *      *  0-----1-----2-----3      */     @Test     public void testSegmentNetwork() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronString(4, false, initArray).getNetwork();          Collection<Neuron> neighbours;          // Neuron 0.         neighbours = net.getNeighbours(net.getNeuron(0));         for (long nId : new long[] { 1 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(1, neighbours.size());          // Neuron 1.         neighbours = net.getNeighbours(net.getNeuron(1));         for (long nId : new long[] { 0, 2 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(2, neighbours.size());          // Neuron 2.         neighbours = net.getNeighbours(net.getNeuron(2));         for (long nId : new long[] { 1, 3 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(2, neighbours.size());          // Neuron 3.         neighbours = net.getNeighbours(net.getNeuron(3));         for (long nId : new long[] { 2 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(1, neighbours.size());     }      /*      * Test assumes that the network is      *      *  0-----1-----2-----3      */     @Test     public void testCircleNetwork() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronString(4, true, initArray).getNetwork();          Collection<Neuron> neighbours;          // Neuron 0.         neighbours = net.getNeighbours(net.getNeuron(0));         for (long nId : new long[] { 1, 3 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(2, neighbours.size());          // Neuron 1.         neighbours = net.getNeighbours(net.getNeuron(1));         for (long nId : new long[] { 0, 2 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(2, neighbours.size());          // Neuron 2.         neighbours = net.getNeighbours(net.getNeuron(2));         for (long nId : new long[] { 1, 3 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(2, neighbours.size());          // Neuron 3.         neighbours = net.getNeighbours(net.getNeuron(3));         for (long nId : new long[] { 0, 2 }) {             Assert.assertTrue(neighbours.contains(net.getNeuron(nId)));         }         // Ensures that no other neurons is in the neighbourhood set.         Assert.assertEquals(2, neighbours.size());     }      /*      * Test assumes that the network is      *      *  0-----1-----2-----3-----4      */     @Test     public void testGetNeighboursWithExclude() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronString(5, true, initArray).getNetwork();         final Collection<Neuron> exclude = new ArrayList<>();         exclude.add(net.getNeuron(1));         final Collection<Neuron> neighbours = net.getNeighbours(net.getNeuron(0),                                                                 exclude);         Assert.assertTrue(neighbours.contains(net.getNeuron(4)));         Assert.assertEquals(1, neighbours.size());     }      @Test     public void testSerialize()         throws IOException,                ClassNotFoundException {         final FeatureInitializer[] initArray = { init };         final NeuronString out = new NeuronString(4, false, initArray);          final ByteArrayOutputStream bos = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(bos);         oos.writeObject(out);          final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());         final ObjectInputStream ois = new ObjectInputStream(bis);         final NeuronString in = (NeuronString) ois.readObject();          for (Neuron nOut : out.getNetwork()) {             final Neuron nIn = in.getNetwork().getNeuron(nOut.getIdentifier());              // Same values.             final double[] outF = nOut.getFeatures();             final double[] inF = nIn.getFeatures();             Assert.assertEquals(outF.length, inF.length);             for (int i = 0; i < outF.length; i++) {                 Assert.assertEquals(outF[i], inF[i], 0d);             }              // Same neighbours.             final Collection<Neuron> outNeighbours = out.getNetwork().getNeighbours(nOut);             final Collection<Neuron> inNeighbours = in.getNetwork().getNeighbours(nIn);             Assert.assertEquals(outNeighbours.size(), inNeighbours.size());             for (Neuron oN : outNeighbours) {                 Assert.assertTrue(inNeighbours.contains(in.getNetwork().getNeuron(oN.getIdentifier())));             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Collection; import java.util.NoSuchElementException;  import org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D; import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link Network}.  */ public class NetworkTest {     final FeatureInitializer init = FeatureInitializerFactory.uniform(0, 2);      @Test     public void testGetFeaturesSize() {         final FeatureInitializer[] initArray = { init, init, init };          final Network net = new NeuronSquareMesh2D(2, false,                                                    2, false,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();         Assert.assertEquals(3, net.getFeaturesSize());     }      /*      * Test assumes that the network is      *      *  0-----1      *  |     |      *  |     |      *  2-----3      */     @Test     public void testDeleteLink() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(2, false,                                                    2, false,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();         Collection<Neuron> neighbours;          // Delete 0 --> 1.         net.deleteLink(net.getNeuron(0),                        net.getNeuron(1));          // Link from 0 to 1 was deleted.         neighbours = net.getNeighbours(net.getNeuron(0));         Assert.assertFalse(neighbours.contains(net.getNeuron(1)));         // Link from 1 to 0 still exists.         neighbours = net.getNeighbours(net.getNeuron(1));         Assert.assertTrue(neighbours.contains(net.getNeuron(0)));     }      /*      * Test assumes that the network is      *      *  0-----1      *  |     |      *  |     |      *  2-----3      */     @Test     public void testDeleteNeuron() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(2, false,                                                    2, false,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();          Assert.assertEquals(2, net.getNeighbours(net.getNeuron(0)).size());         Assert.assertEquals(2, net.getNeighbours(net.getNeuron(3)).size());          // Delete neuron 1.         net.deleteNeuron(net.getNeuron(1));          try {             net.getNeuron(1);         } catch (NoSuchElementException expected) {}          Assert.assertEquals(1, net.getNeighbours(net.getNeuron(0)).size());         Assert.assertEquals(1, net.getNeighbours(net.getNeuron(3)).size());     }      @Test     public void testIterationOrder() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(4, false,                                                    3, true,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();          // Check that the comparator provides a specific order.         boolean isUnspecifiedOrder = false;         long previousId = Long.MIN_VALUE;         for (Neuron n : net.getNeurons(new Network.NeuronIdentifierComparator())) {             final long currentId = n.getIdentifier();             if (currentId < previousId) {                 isUnspecifiedOrder = true;                 break;             }             previousId = currentId;         }         Assert.assertFalse(isUnspecifiedOrder);     }      /*      * Test assumes that the network is      *      *  0-----1      *  |     |      *  |     |      *  2-----3      */     @Test     public void testCopy() {         final FeatureInitializer[] initArray = { init };         final Network net = new NeuronSquareMesh2D(2, false,                                                    2, false,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();          final Network copy = net.copy();          final Neuron netNeuron0 = net.getNeuron(0);         final Neuron copyNeuron0 = copy.getNeuron(0);         final Neuron netNeuron1 = net.getNeuron(1);         final Neuron copyNeuron1 = copy.getNeuron(1);         Collection<Neuron> netNeighbours;         Collection<Neuron> copyNeighbours;          // Check that both networks have the same connections.         netNeighbours = net.getNeighbours(netNeuron0);         copyNeighbours = copy.getNeighbours(copyNeuron0);         Assert.assertTrue(netNeighbours.contains(netNeuron1));         Assert.assertTrue(copyNeighbours.contains(copyNeuron1));          // Delete neuron 1 from original.         net.deleteNeuron(netNeuron1);          // Check that the networks now differ.         netNeighbours = net.getNeighbours(netNeuron0);         copyNeighbours = copy.getNeighbours(copyNeuron0);         Assert.assertFalse(netNeighbours.contains(netNeuron1));         Assert.assertTrue(copyNeighbours.contains(copyNeuron1));     }      @Test     public void testSerialize()         throws IOException,                ClassNotFoundException {         final FeatureInitializer[] initArray = { init };         final Network out = new NeuronSquareMesh2D(4, false,                                                    3, true,                                                    SquareNeighbourhood.VON_NEUMANN,                                                    initArray).getNetwork();          final ByteArrayOutputStream bos = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(bos);         oos.writeObject(out);          final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());         final ObjectInputStream ois = new ObjectInputStream(bis);         final Network in = (Network) ois.readObject();          for (Neuron nOut : out) {             final Neuron nIn = in.getNeuron(nOut.getIdentifier());              // Same values.             final double[] outF = nOut.getFeatures();             final double[] inF = nIn.getFeatures();             Assert.assertEquals(outF.length, inF.length);             for (int i = 0; i < outF.length; i++) {                 Assert.assertEquals(outF[i], inF[i], 0d);             }              // Same neighbours.             final Collection<Neuron> outNeighbours = out.getNeighbours(nOut);             final Collection<Neuron> inNeighbours = in.getNeighbours(nIn);             Assert.assertEquals(outNeighbours.size(), inNeighbours.size());             for (Neuron oN : outNeighbours) {                 Assert.assertTrue(inNeighbours.contains(in.getNeuron(oN.getIdentifier())));             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet;   /**  * Wraps a given initializer.  */ public class OffsetFeatureInitializer     implements FeatureInitializer {     /** Wrapped initializer. */     private final FeatureInitializer orig;     /** Offset. */     private int inc = 0;      /**      * Creates a new initializer whose {@link #value()} method      * will return {@code orig.value() + offset}, where      * {@code offset} is automatically incremented by one at      * each call.      *      * @param orig Original initializer.      */     public OffsetFeatureInitializer(FeatureInitializer orig) {         this.orig = orig;     }      /** {@inheritDoc} */     @Override     public double value() {         return orig.value() + inc++;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet;  import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.IOException;  import org.junit.Test; import org.junit.Assert;  /**  * Tests for {@link Neuron}.  */ public class NeuronTest {     @Test     public void testGetIdentifier() {         final long id = 1234567;         final Neuron n = new Neuron(id, new double[] { 0 });          Assert.assertEquals(id, n.getIdentifier());     }      @Test     public void testGetSize() {         final double[] features = { -1, -1e-97, 0, 23.456, 9.01e203 } ;         final Neuron n = new Neuron(1, features);         Assert.assertEquals(features.length, n.getSize());     }      @Test     public void testGetFeatures() {         final double[] features = { -1, -1e-97, 0, 23.456, 9.01e203 } ;         final Neuron n = new Neuron(1, features);          final double[] f = n.getFeatures();         // Accessor returns a copy.         Assert.assertFalse(f == features);          // Values are the same.         Assert.assertEquals(features.length, f.length);         for (int i = 0; i < features.length; i++) {             Assert.assertEquals(features[i], f[i], 0d);         }     }      @Test     public void testCompareAndSetFeatures() {         final Neuron n = new Neuron(1, new double[] { 0 });         double[] expect = n.getFeatures();         double[] update = new double[] { expect[0] + 1.23 };          // Test "success".         boolean ok = n.compareAndSetFeatures(expect, update);         // Check that the update is reported as successful.         Assert.assertTrue(ok);         // Check that the new value is correct.         Assert.assertEquals(update[0],  n.getFeatures()[0], 0d);          // Test "failure".         double[] update1 = new double[] { update[0] + 4.56 };         // Must return "false" because the neuron has been         // updated: a new update can only succeed if "expect"         // is set to the new features.         ok = n.compareAndSetFeatures(expect, update1);         // Check that the update is reported as failed.         Assert.assertFalse(ok);         // Check that the value was not changed.         Assert.assertEquals(update[0],  n.getFeatures()[0], 0d);     }      @Test     public void testCopy() {         final Neuron n = new Neuron(1, new double[] { 9.87 });          // Update original.         double[] update = new double[] { n.getFeatures()[0] + 2.34 };         n.compareAndSetFeatures(n.getFeatures(), update);          // Create a copy.         final Neuron copy = n.copy();          // Check that original and copy have the same value.         Assert.assertTrue(n.getFeatures()[0] == copy.getFeatures()[0]);         Assert.assertEquals(n.getNumberOfAttemptedUpdates(),                             copy.getNumberOfAttemptedUpdates());          // Update original.         update = new double[] { 1.23 * n.getFeatures()[0] };         n.compareAndSetFeatures(n.getFeatures(), update);          // Check that original and copy differ.         Assert.assertFalse(n.getFeatures()[0] == copy.getFeatures()[0]);         Assert.assertNotEquals(n.getNumberOfSuccessfulUpdates(),                                copy.getNumberOfSuccessfulUpdates());     }      @Test     public void testSerialize()         throws IOException,                ClassNotFoundException {         final Neuron out = new Neuron(123, new double[] { -98.76, -1, 0, 1e-23, 543.21, 1e234 });         final ByteArrayOutputStream bos = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(bos);         oos.writeObject(out);          final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());         final ObjectInputStream ois = new ObjectInputStream(bis);         final Neuron in = (Neuron) ois.readObject();          // Same identifier.         Assert.assertEquals(out.getIdentifier(),                             in.getIdentifier());         // Same values.         final double[] outF = out.getFeatures();         final double[] inF = in.getFeatures();         Assert.assertEquals(outF.length, inF.length);         for (int i = 0; i < outF.length; i++) {             Assert.assertEquals(outF[i], inF[i], 0d);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.sofm;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.junit.Test; import org.junit.Assert;  /**  * Tests for {@link NeighbourhoodSizeFunctionFactory} class.  */ public class NeighbourhoodSizeFunctionFactoryTest {     @Test(expected=NotStrictlyPositiveException.class)     public void testExponentialDecayPrecondition1() {         NeighbourhoodSizeFunctionFactory.exponentialDecay(0, 0, 2);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testExponentialDecayPrecondition2() {         NeighbourhoodSizeFunctionFactory.exponentialDecay(1, 0, 2);     }     @Test(expected=NumberIsTooLargeException.class)     public void testExponentialDecayPrecondition3() {         NeighbourhoodSizeFunctionFactory.exponentialDecay(1, 1, 100);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testExponentialDecayPrecondition4() {         NeighbourhoodSizeFunctionFactory.exponentialDecay(2, 1, 0);     }      @Test     public void testExponentialDecayTrivial() {         final int n = 65;         final int init = 4;         final int valueAtN = 3;         final NeighbourhoodSizeFunction f             = NeighbourhoodSizeFunctionFactory.exponentialDecay(init, valueAtN, n);          Assert.assertEquals(init, f.value(0));         Assert.assertEquals(valueAtN, f.value(n));         Assert.assertEquals(0, f.value(Long.MAX_VALUE));     }      @Test(expected=NotStrictlyPositiveException.class)     public void testQuasiSigmoidDecayPrecondition1() {         NeighbourhoodSizeFunctionFactory.quasiSigmoidDecay(0d, -1d, 2);     }     @Test(expected=NumberIsTooLargeException.class)     public void testQuasiSigmoidDecayPrecondition3() {         NeighbourhoodSizeFunctionFactory.quasiSigmoidDecay(1d, 0d, 100);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testQuasiSigmoidDecayPrecondition4() {         NeighbourhoodSizeFunctionFactory.quasiSigmoidDecay(1d, -1d, 0);     }      @Test     public void testQuasiSigmoidDecayTrivial() {         final int n = 65;         final double init = 4;         final double slope = -1e-1;         final NeighbourhoodSizeFunction f             = NeighbourhoodSizeFunctionFactory.quasiSigmoidDecay(init, slope, n);          Assert.assertEquals(init, f.value(0), 0d);         Assert.assertEquals(0, f.value(Long.MAX_VALUE), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.sofm;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.OutOfRangeException; import org.junit.Test; import org.junit.Assert;  /**  * Tests for {@link LearningFactorFunctionFactory} class.  */ public class LearningFactorFunctionFactoryTest {     @Test(expected=OutOfRangeException.class)     public void testExponentialDecayPrecondition0() {         LearningFactorFunctionFactory.exponentialDecay(0d, 0d, 2);     }     @Test(expected=OutOfRangeException.class)     public void testExponentialDecayPrecondition1() {         LearningFactorFunctionFactory.exponentialDecay(1 + 1e-10, 0d, 2);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testExponentialDecayPrecondition2() {         LearningFactorFunctionFactory.exponentialDecay(1d, 0d, 2);     }     @Test(expected=NumberIsTooLargeException.class)     public void testExponentialDecayPrecondition3() {         LearningFactorFunctionFactory.exponentialDecay(1d, 1d, 100);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testExponentialDecayPrecondition4() {         LearningFactorFunctionFactory.exponentialDecay(1d, 0.2, 0);     }      @Test     public void testExponentialDecayTrivial() {         final int n = 65;         final double init = 0.5;         final double valueAtN = 0.1;         final LearningFactorFunction f             = LearningFactorFunctionFactory.exponentialDecay(init, valueAtN, n);          Assert.assertEquals(init, f.value(0), 0d);         Assert.assertEquals(valueAtN, f.value(n), 0d);         Assert.assertEquals(0, f.value(Long.MAX_VALUE), 0d);     }      @Test(expected=OutOfRangeException.class)     public void testQuasiSigmoidDecayPrecondition0() {         LearningFactorFunctionFactory.quasiSigmoidDecay(0d, -1d, 2);     }     @Test(expected=OutOfRangeException.class)     public void testQuasiSigmoidDecayPrecondition1() {         LearningFactorFunctionFactory.quasiSigmoidDecay(1 + 1e-10, -1d, 2);     }     @Test(expected=NumberIsTooLargeException.class)     public void testQuasiSigmoidDecayPrecondition3() {         LearningFactorFunctionFactory.quasiSigmoidDecay(1d, 0d, 100);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testQuasiSigmoidDecayPrecondition4() {         LearningFactorFunctionFactory.quasiSigmoidDecay(1d, -1d, 0);     }      @Test     public void testQuasiSigmoidDecayTrivial() {         final int n = 65;         final double init = 0.5;         final double slope = -1e-1;         final LearningFactorFunction f             = LearningFactorFunctionFactory.quasiSigmoidDecay(init, slope, n);          Assert.assertEquals(init, f.value(0), 0d);         // Very approximate derivative.         Assert.assertEquals(slope, f.value(n) - f.value(n - 1), 1e-2);         Assert.assertEquals(0, f.value(Long.MAX_VALUE), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.sofm;  import java.util.Arrays; import java.util.List; import java.util.ArrayList; import java.util.Set; import java.util.HashSet; import java.util.Collection; import java.util.Iterator;  import org.apache.commons.math4.analysis.FunctionUtils; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Constant; import org.apache.commons.math4.analysis.function.HarmonicOscillator; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.ml.distance.DistanceMeasure; import org.apache.commons.math4.ml.distance.EuclideanDistance; import org.apache.commons.math4.ml.neuralnet.FeatureInitializer; import org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory; import org.apache.commons.math4.ml.neuralnet.Network; import org.apache.commons.math4.ml.neuralnet.Neuron; import org.apache.commons.math4.ml.neuralnet.oned.NeuronString; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.math4.util.FastMath;  /**  * Solves the "Travelling Salesman's Problem" (i.e. trying to find the  * sequence of cities that minimizes the travel distance) using a 1D  * SOFM.  */ public class TravellingSalesmanSolver {     private static final long FIRST_NEURON_ID = 0;     /** RNG. */     private final UniformRandomProvider random;     /** Set of cities. */     private final Set<City> cities = new HashSet<>();     /** SOFM. */     private final Network net;     /** Distance function. */     private final DistanceMeasure distance = new EuclideanDistance();     /** Total number of neurons. */     private final int numberOfNeurons;      /**      * @param cityList List of cities to visit in a single travel.      * @param numNeuronsPerCity Number of neurons per city.      */     public TravellingSalesmanSolver(City[] cityList,                                     double numNeuronsPerCity) {         this(cityList, numNeuronsPerCity, RandomSource.createLong());     }      /**      * @param cityList List of cities to visit in a single travel.      * @param numNeuronsPerCity Number of neurons per city.      * @param seed Seed for the RNG that is used to present the samples      * to the trainer.      */     public TravellingSalesmanSolver(City[] cityList,                                     double numNeuronsPerCity,                                     long seed) {         random = RandomSource.create(RandomSource.WELL_1024_A, seed);          // Make sure that each city will appear only once in the list.         cities.addAll(Arrays.asList(cityList));          // Total number of neurons.         numberOfNeurons = (int) numNeuronsPerCity * cities.size();          // Create a network with circle topology.         net = new NeuronString(numberOfNeurons, true, makeInitializers()).getNetwork();     }      /**      * Creates training tasks.      *      * @param numTasks Number of tasks to create.      * @param numSamplesPerTask Number of training samples per task.      * @return the created tasks.      */     public Runnable[] createParallelTasks(int numTasks,                                           long numSamplesPerTask) {         final Runnable[] tasks = new Runnable[numTasks];         final LearningFactorFunction learning             = LearningFactorFunctionFactory.exponentialDecay(2e-1,                                                              5e-2,                                                              numSamplesPerTask / 2);         final NeighbourhoodSizeFunction neighbourhood             = NeighbourhoodSizeFunctionFactory.exponentialDecay(0.5 * numberOfNeurons,                                                                 0.1 * numberOfNeurons,                                                                 numSamplesPerTask / 2);          for (int i = 0; i < numTasks; i++) {             final KohonenUpdateAction action = new KohonenUpdateAction(distance,                                                                        learning,                                                                        neighbourhood);             tasks[i] = new KohonenTrainingTask(net,                                                createRandomIterator(numSamplesPerTask),                                                action);         }          return tasks;     }      /**      * Creates a training task.      *      * @param numSamples Number of training samples.      * @return the created task.      */     public Runnable createSequentialTask(long numSamples) {         return createParallelTasks(1, numSamples)[0];     }      /**      * Measures the network's concurrent update performance.      *      * @return the ratio between the number of successful network updates      * and the number of update attempts.      */     public double getUpdateRatio() {         return computeUpdateRatio(net);     }      /**      * Measures the network's concurrent update performance.      *      * @param net Network to be trained with the SOFM algorithm.      * @return the ratio between the number of successful network updates      * and the number of update attempts.      */     private static double computeUpdateRatio(Network net) {         long numAttempts = 0;         long numSuccesses = 0;          for (Neuron n : net) {             numAttempts += n.getNumberOfAttemptedUpdates();             numSuccesses += n.getNumberOfSuccessfulUpdates();         }          return (double) numSuccesses / (double) numAttempts;     }      /**      * Creates an iterator that will present a series of city's coordinates in      * a random order.      *      * @param numSamples Number of samples.      * @return the iterator.      */     private Iterator<double[]> createRandomIterator(final long numSamples) {         final List<City> cityList = new ArrayList<>();         cityList.addAll(cities);          return new Iterator<double[]>() {             /** Number of samples. */             private long n = 0;             /** {@inheritDoc} */             @Override             public boolean hasNext() {                 return n < numSamples;             }             /** {@inheritDoc} */             @Override             public double[] next() {                 ++n;                 return cityList.get(random.nextInt(cityList.size())).getCoordinates();             }             /** {@inheritDoc} */             @Override             public void remove() {                 throw new MathUnsupportedOperationException();             }         };     }      /**      * @return the list of linked neurons (i.e. the one-dimensional      * SOFM).      */     private List<Neuron> getNeuronList() {         // Sequence of coordinates.         final List<Neuron> list = new ArrayList<>();          // First neuron.         Neuron current = net.getNeuron(FIRST_NEURON_ID);         while (true) {             list.add(current);             final Collection<Neuron> neighbours                 = net.getNeighbours(current, list);              final Iterator<Neuron> iter = neighbours.iterator();             if (!iter.hasNext()) {                 // All neurons have been visited.                 break;             }              current = iter.next();         }          return list;     }      /**      * @return the list of features (coordinates) of linked neurons.      */     public List<double[]> getCoordinatesList() {         // Sequence of coordinates.         final List<double[]> coordinatesList = new ArrayList<>();          for (Neuron n : getNeuronList()) {             coordinatesList.add(n.getFeatures());         }          return coordinatesList;     }      /**      * Returns the travel proposed by the solver.      * Note: cities can be missing or duplicated.      *      * @return the list of cities in travel order.      */     public City[] getCityList() {         final List<double[]> coord = getCoordinatesList();         final City[] cityList = new City[coord.size()];         for (int i = 0; i < cityList.length; i++) {             final double[] c = coord.get(i);             cityList[i] = getClosestCity(c[0], c[1]);         }         return cityList;     }      /**      * @param x x-coordinate.      * @param y y-coordinate.      * @return the city whose coordinates are closest to {@code (x, y)}.      */     public City getClosestCity(double x,                                double y) {         City closest = null;         double min = Double.POSITIVE_INFINITY;         for (City c : cities) {             final double d = c.distance(x, y);             if (d < min) {                 min = d;                 closest = c;             }         }         return closest;     }      /**      * Computes the barycentre of all city locations.      *      * @param cities City list.      * @return the barycentre.      */     private static double[] barycentre(Set<City> cities) {         double xB = 0;         double yB = 0;          int count = 0;         for (City c : cities) {             final double[] coord = c.getCoordinates();             xB += coord[0];             yB += coord[1];              ++count;         }          return new double[] { xB / count, yB / count };     }      /**      * Computes the largest distance between the point at coordinates      * {@code (x, y)} and any of the cities.      *      * @param x x-coordinate.      * @param y y-coordinate.      * @param cities City list.      * @return the largest distance.      */     private static double largestDistance(double x,                                           double y,                                           Set<City> cities) {         double maxDist = 0;         for (City c : cities) {             final double dist = c.distance(x, y);             if (dist > maxDist) {                 maxDist = dist;             }         }          return maxDist;     }      /**      * Creates the features' initializers: an approximate circle around the      * barycentre of the cities.      *      * @return an array containing the two initializers.      */     private FeatureInitializer[] makeInitializers() {         // Barycentre.         final double[] centre = barycentre(cities);         // Largest distance from centre.         final double radius = 0.5 * largestDistance(centre[0], centre[1], cities);          final double omega = 2 * Math.PI / numberOfNeurons;         final UnivariateFunction h1 = new HarmonicOscillator(radius, omega, 0);         final UnivariateFunction h2 = new HarmonicOscillator(radius, omega, 0.5 * Math.PI);          final UnivariateFunction f1 = FunctionUtils.add(h1, new Constant(centre[0]));         final UnivariateFunction f2 = FunctionUtils.add(h2, new Constant(centre[1]));          final ContinuousDistribution u = new UniformContinuousDistribution(-0.05 * radius, 0.05 * radius);          return new FeatureInitializer[] {             FeatureInitializerFactory.randomize(u.createSampler(random),                                                 FeatureInitializerFactory.function(f1, 0, 1)),             FeatureInitializerFactory.randomize(u.createSampler(random),                                                 FeatureInitializerFactory.function(f2, 0, 1))         };     } }  /**  * A city, represented by a name and two-dimensional coordinates.  */ class City {     /** Identifier. */     final String name;     /** x-coordinate. */     final double x;     /** y-coordinate. */     final double y;      /**      * @param name Name.      * @param x Cartesian x-coordinate.      * @param y Cartesian y-coordinate.      */     public City(String name,                 double x,                 double y) {         this.name = name;         this.x = x;         this.y = y;     }      /**      * @retun the name.      */     public String getName() {         return name;     }      /**      * @return the (x, y) coordinates.      */     public double[] getCoordinates() {         return new double[] { x, y };     }      /**      * Computes the distance between this city and      * the given point.      *      * @param x x-coordinate.      * @param y y-coordinate.      * @return the distance between {@code (x, y)} and this      * city.      */     public double distance(double x,                            double y) {         final double xDiff = this.x - x;         final double yDiff = this.y - y;          return FastMath.sqrt(xDiff * xDiff + yDiff * yDiff);     }      /** {@inheritDoc} */     @Override     public boolean equals(Object o) {         if (o instanceof City) {             final City other = (City) o;             return x == other.x &&                 y == other.y;         }         return false;     }      /** {@inheritDoc} */     @Override     public int hashCode() {         int result = 17;          final long c1 = Double.doubleToLongBits(x);         result = 31 * result + (int) (c1 ^ (c1 >>> 32));          final long c2 = Double.doubleToLongBits(y);         result = 31 * result + (int) (c2 ^ (c2 >>> 32));          return result;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.sofm;  import java.io.PrintWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future;  import org.apache.commons.math4.Retry; import org.apache.commons.math4.RetryRunner; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith;  /**  * Tests for {@link KohonenTrainingTask}  */ @RunWith(RetryRunner.class) public class KohonenTrainingTaskTest {     @Test     public void testTravellerSalesmanSquareTourSequentialSolver() {         // Cities (in optimal travel order).         final City[] squareOfCities = new City[] {             new City("o0", 0, 0),             new City("o1", 1, 0),             new City("o2", 2, 0),             new City("o3", 3, 0),             new City("o4", 3, 1),             new City("o5", 3, 2),             new City("o6", 3, 3),             new City("o7", 2, 3),             new City("o8", 1, 3),             new City("o9", 0, 3),             new City("i3", 1, 2),             new City("i2", 2, 2),             new City("i1", 2, 1),             new City("i0", 1, 1),         };          // Seed that allows the unit test to always succeed.         final long seed = 1245632379L;          final TravellingSalesmanSolver solver = new TravellingSalesmanSolver(squareOfCities, 2, seed);         // printSummary("before.travel.seq.dat", solver);         final Runnable task = solver.createSequentialTask(15000);         task.run();          // All update attempts must be successful in the absence of concurrency.         Assert.assertEquals(solver.getUpdateRatio(), 1, 0d);          // printSummary("after.travel.seq.dat", solver);         final City[] result = solver.getCityList();         Assert.assertEquals(squareOfCities.length,                             uniqueCities(result).size());         final double ratio = computeTravelDistance(squareOfCities) / computeTravelDistance(result);         Assert.assertEquals(1, ratio, 1e-1); // We do not require the optimal travel.     }      // Test can sometimes fail: Run several times.     @Test     @Retry     public void testTravellerSalesmanSquareTourParallelSolver() throws ExecutionException {         // Cities (in optimal travel order).         final City[] squareOfCities = new City[] {             new City("o0", 0, 0),             new City("o1", 1, 0),             new City("o2", 2, 0),             new City("o3", 3, 0),             new City("o4", 3, 1),             new City("o5", 3, 2),             new City("o6", 3, 3),             new City("o7", 2, 3),             new City("o8", 1, 3),             new City("o9", 0, 3),             new City("i3", 1, 2),             new City("i2", 2, 2),             new City("i1", 2, 1),             new City("i0", 1, 1),         };          // Seed that allows the unit test to always succeed.         final long seed = 534712311L;          final TravellingSalesmanSolver solver = new TravellingSalesmanSolver(squareOfCities, 2, seed);         // printSummary("before.travel.par.dat", solver);          // Parallel execution.         final ExecutorService service = Executors.newCachedThreadPool();         final int numProcs = Runtime.getRuntime().availableProcessors();         final Runnable[] tasks = solver.createParallelTasks(numProcs, 5000);         final List<Future<?>> execOutput = new ArrayList<>();         // Run tasks.         for (Runnable r : tasks) {             execOutput.add(service.submit(r));         }         // Wait for completion (ignoring return value).         try {             for (Future<?> f : execOutput) {                 f.get();             }         } catch (InterruptedException ignored) {}         // Terminate all threads.         service.shutdown();          if (numProcs > 1) {             // We expect that some update attempts will be concurrent.             Assert.assertTrue(solver.getUpdateRatio() < 1);         }          // printSummary("after.travel.par.dat", solver);         final City[] result = solver.getCityList();         Assert.assertEquals(squareOfCities.length,                             uniqueCities(result).size());         final double ratio = computeTravelDistance(squareOfCities) / computeTravelDistance(result);         Assert.assertEquals(1, ratio, 1e-1); // We do not require the optimal travel.     }      /**      * Creates a map of the travel suggested by the solver.      *      * @param solver Solver.      * @return a 4-columns table: {@code <x (neuron)> <y (neuron)> <x (city)> <y (city)>}.      */     private String travelCoordinatesTable(TravellingSalesmanSolver solver) {         final StringBuilder s = new StringBuilder();         for (double[] c : solver.getCoordinatesList()) {             s.append(c[0]).append(" ").append(c[1]).append(" ");             final City city = solver.getClosestCity(c[0], c[1]);             final double[] cityCoord = city.getCoordinates();             s.append(cityCoord[0]).append(" ").append(cityCoord[1]).append(" ");             s.append("   # ").append(city.getName()).append("\n");         }         return s.toString();     }      /**      * Compute the distance covered by the salesman, including      * the trip back (from the last to first city).      *      * @param cityList List of cities visited during the travel.      * @return the total distance.      */     private Collection<City> uniqueCities(City[] cityList) {         final Set<City> unique = new HashSet<>();         unique.addAll(Arrays.asList(cityList));         return unique;     }      /**      * Compute the distance covered by the salesman, including      * the trip back (from the last to first city).      *      * @param cityList List of cities visited during the travel.      * @return the total distance.      */     private double computeTravelDistance(City[] cityList) {         double dist = 0;         for (int i = 0; i < cityList.length; i++) {             final double[] currentCoord = cityList[i].getCoordinates();             final double[] nextCoord = cityList[(i + 1) % cityList.length].getCoordinates();              final double xDiff = currentCoord[0] - nextCoord[0];             final double yDiff = currentCoord[1] - nextCoord[1];              dist += FastMath.sqrt(xDiff * xDiff + yDiff * yDiff);         }          return dist;     }      /**      * Prints a summary of the current state of the solver to the      * given file name.      *      * @param fileName File.      * @param solver Solver.      */     @SuppressWarnings("unused")     private void printSummary(String fileName,                               TravellingSalesmanSolver solver) {         PrintWriter out = null;         try {             out = new PrintWriter(fileName);             out.println(travelCoordinatesTable(solver));              final City[] result = solver.getCityList();             out.println("# Number of unique cities: " + uniqueCities(result).size());             out.println("# Travel distance: " + computeTravelDistance(result));         } catch (Exception e) {             // Do nothing.         } finally {             if (out != null) {                 out.close();             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.sofm.util;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.junit.Test; import org.junit.Assert;  /**  * Tests for {@link QuasiSigmoidDecayFunction} class  */ public class QuasiSigmoidDecayFunctionTest {     @Test(expected=NotStrictlyPositiveException.class)     public void testPrecondition1() {         new QuasiSigmoidDecayFunction(0d, -1d, 2);     }     @Test(expected=NumberIsTooLargeException.class)     public void testPrecondition3() {         new QuasiSigmoidDecayFunction(1d, 0d, 100);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testPrecondition4() {         new QuasiSigmoidDecayFunction(1d, -1d, 0);     }      @Test     public void testTrivial() {         final int n = 65;         final double init = 4;         final double slope = -1e-1;         final QuasiSigmoidDecayFunction f = new QuasiSigmoidDecayFunction(init, slope, n);          Assert.assertEquals(init, f.value(0), 0d);         // Very approximate derivative.         Assert.assertEquals(slope, f.value(n + 1) - f.value(n), 1e-4);         Assert.assertEquals(0, f.value(Long.MAX_VALUE), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.sofm.util;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.junit.Test; import org.junit.Assert;  /**  * Tests for {@link ExponentialDecayFunction} class  */ public class ExponentialDecayFunctionTest {     @Test(expected=NotStrictlyPositiveException.class)     public void testPrecondition1() {         new ExponentialDecayFunction(0d, 0d, 2);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testPrecondition2() {         new ExponentialDecayFunction(1d, 0d, 2);     }     @Test(expected=NumberIsTooLargeException.class)     public void testPrecondition3() {         new ExponentialDecayFunction(1d, 1d, 100);     }     @Test(expected=NotStrictlyPositiveException.class)     public void testPrecondition4() {         new ExponentialDecayFunction(1d, 0.2, 0);     }      @Test     public void testTrivial() {         final int n = 65;         final double init = 4;         final double valueAtN = 3;         final ExponentialDecayFunction f = new ExponentialDecayFunction(init, valueAtN, n);          Assert.assertEquals(init, f.value(0), 0d);         Assert.assertEquals(valueAtN, f.value(n), 0d);         Assert.assertEquals(0, f.value(Long.MAX_VALUE), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.neuralnet.sofm;  import org.apache.commons.math4.ml.distance.DistanceMeasure; import org.apache.commons.math4.ml.distance.EuclideanDistance; import org.apache.commons.math4.ml.neuralnet.FeatureInitializer; import org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory; import org.apache.commons.math4.ml.neuralnet.MapRanking; import org.apache.commons.math4.ml.neuralnet.Network; import org.apache.commons.math4.ml.neuralnet.Neuron; import org.apache.commons.math4.ml.neuralnet.OffsetFeatureInitializer; import org.apache.commons.math4.ml.neuralnet.UpdateAction; import org.apache.commons.math4.ml.neuralnet.oned.NeuronString; import org.junit.Test; import org.junit.Assert;  /**  * Tests for {@link KohonenUpdateAction} class.  */ public class KohonenUpdateActionTest {     /*      * Test assumes that the network is      *      *  0-----1-----2      */     @Test     public void testUpdate() {         final FeatureInitializer init             = new OffsetFeatureInitializer(FeatureInitializerFactory.uniform(0, 0.1));         final FeatureInitializer[] initArray = { init };          final int netSize = 3;         final Network net = new NeuronString(netSize, false, initArray).getNetwork();         final DistanceMeasure dist = new EuclideanDistance();         final LearningFactorFunction learning             = LearningFactorFunctionFactory.exponentialDecay(1, 0.1, 100);         final NeighbourhoodSizeFunction neighbourhood             = NeighbourhoodSizeFunctionFactory.exponentialDecay(3, 1, 100);         final UpdateAction update = new KohonenUpdateAction(dist, learning, neighbourhood);         final MapRanking rank = new MapRanking(net, dist);          // The following test ensures that, after one "update",         // 1. when the initial learning rate equal to 1, the best matching         //    neuron's features are mapped to the input's features,         // 2. when the initial neighbourhood is larger than the network's size,         //    all neuron's features get closer to the input's features.          final double[] features = new double[] { 0.3 };         final double[] distancesBefore = new double[netSize];         int count = 0;         for (Neuron n : net) {             distancesBefore[count++] = dist.compute(n.getFeatures(), features);         }         final Neuron bestBefore = rank.rank(features, 1).get(0);          // Initial distance from the best match is larger than zero.         Assert.assertTrue(dist.compute(bestBefore.getFeatures(), features) >= 0.2);          update.update(net, features);          final double[] distancesAfter = new double[netSize];         count = 0;         for (Neuron n : net) {             distancesAfter[count++] = dist.compute(n.getFeatures(), features);         }         final Neuron bestAfter = rank.rank(features, 1).get(0);          Assert.assertEquals(bestBefore, bestAfter);         // Distance is now zero.         Assert.assertEquals(0, dist.compute(bestAfter.getFeatures(), features), 1e-16);          for (int i = 0; i < netSize; i++) {             // All distances have decreased.             Assert.assertTrue(distancesAfter[i] < distancesBefore[i]);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ml.distance;  import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link EarthMoversDistance} class.  */ public class EarthMoversDistanceTest {      final DistanceMeasure distance = new EarthMoversDistance();     final double[] a = { 0.1, 0.3, 0.2, 0.0, 0.25, 0.15 };     final double[] b = { 0.3, 0.0, 0.4, 0.1, 0.0, 0.2 };      @Test     public void testZero() {         Assert.assertEquals(0, distance.compute(a, a), 0d);     }      @Test     public void testZero2() {         final double[] zero = new double[] { 0, 0 };         Assert.assertEquals(0, distance.compute(zero, zero), 0d);     }      @Test     public void test() {         double expected = 0.65; //0.2 + 0.1 + 0.1 + 0.2 + 0.05 + 0.0;         Assert.assertEquals(expected, distance.compute(a, b), 1e-10);         Assert.assertEquals(expected, distance.compute(b, a), 1e-10);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ml.distance;  import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link CanberraDistance} class.  */ public class CanberraDistanceTest {     final DistanceMeasure distance = new CanberraDistance();      @Test     public void testZero() {         final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 };         Assert.assertEquals(0, distance.compute(a, a), 0d);     }      @Test     public void testZero2() {         final double[] a = { 0, 0 };         Assert.assertEquals(0, distance.compute(a, a), 0d);     }      @Test     public void test() {         final double[] a = { 1, 2, 3, 4, 9 };         final double[] b = { -5, -6, 7, 4, 3 };         final double expected = 2.9;         Assert.assertEquals(expected, distance.compute(a, b), 0d);         Assert.assertEquals(expected, distance.compute(b, a), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ml.distance;  import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link ManhattanDistance} class.  */ public class ManhattanDistanceTest {     final DistanceMeasure distance = new ManhattanDistance();      @Test     public void testZero() {         final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 };         Assert.assertEquals(0, distance.compute(a, a), 0d);     }      @Test     public void test() {         final double[] a = { 1, -2, 3, 4 };         final double[] b = { -5, -6, 7, 8 };         final double expected = 18;         Assert.assertEquals(expected, distance.compute(a, b), 0d);         Assert.assertEquals(expected, distance.compute(b, a), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ml.distance;  import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link ChebyshevDistance} class.  */ public class ChebyshevDistanceTest {     final DistanceMeasure distance = new ChebyshevDistance();      @Test     public void testZero() {         final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 };         Assert.assertEquals(0, distance.compute(a, a), 0d);     }      @Test     public void test() {         final double[] a = { 1, 2, 3, 4 };         final double[] b = { -5, -6, 7, 8 };         final double expected = 8;         Assert.assertEquals(expected, distance.compute(a, b), 0d);         Assert.assertEquals(expected, distance.compute(b, a), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ml.distance;  import org.junit.Assert; import org.junit.Test; import org.apache.commons.math4.util.FastMath;  /**  * Tests for {@link EuclideanDistance} class.  */ public class EuclideanDistanceTest {     final DistanceMeasure distance = new EuclideanDistance();      @Test     public void testZero() {         final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 };         Assert.assertEquals(0, distance.compute(a, a), 0d);     }      @Test     public void test() {         final double[] a = { 1, -2, 3, 4 };         final double[] b = { -5, -6, 7, 8 };         final double expected = FastMath.sqrt(84);         Assert.assertEquals(expected, distance.compute(a, b), 0d);         Assert.assertEquals(expected, distance.compute(b, a), 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.clustering;   import java.util.Arrays; import java.util.List;  import org.junit.Assert; import org.junit.Test;  public class MultiKMeansPlusPlusClustererTest {      @Test     public void dimension2() {         MultiKMeansPlusPlusClusterer<DoublePoint> transformer =             new MultiKMeansPlusPlusClusterer<>(                     new KMeansPlusPlusClusterer<DoublePoint>(3, 10), 5);          DoublePoint[] points = new DoublePoint[] {                  // first expected cluster                 new DoublePoint(new int[] { -15,  3 }),                 new DoublePoint(new int[] { -15,  4 }),                 new DoublePoint(new int[] { -15,  5 }),                 new DoublePoint(new int[] { -14,  3 }),                 new DoublePoint(new int[] { -14,  5 }),                 new DoublePoint(new int[] { -13,  3 }),                 new DoublePoint(new int[] { -13,  4 }),                 new DoublePoint(new int[] { -13,  5 }),                  // second expected cluster                 new DoublePoint(new int[] { -1,  0 }),                 new DoublePoint(new int[] { -1, -1 }),                 new DoublePoint(new int[] {  0, -1 }),                 new DoublePoint(new int[] {  1, -1 }),                 new DoublePoint(new int[] {  1, -2 }),                  // third expected cluster                 new DoublePoint(new int[] { 13,  3 }),                 new DoublePoint(new int[] { 13,  4 }),                 new DoublePoint(new int[] { 14,  4 }),                 new DoublePoint(new int[] { 14,  7 }),                 new DoublePoint(new int[] { 16,  5 }),                 new DoublePoint(new int[] { 16,  6 }),                 new DoublePoint(new int[] { 17,  4 }),                 new DoublePoint(new int[] { 17,  7 })          };         List<CentroidCluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points));          Assert.assertEquals(3, clusters.size());         boolean cluster1Found = false;         boolean cluster2Found = false;         boolean cluster3Found = false;         double epsilon = 1e-6;         for (CentroidCluster<DoublePoint> cluster : clusters) {             Clusterable center = cluster.getCenter();             double[] point = center.getPoint();             if (point[0] < 0) {                 cluster1Found = true;                 Assert.assertEquals(8, cluster.getPoints().size());                 Assert.assertEquals(-14, point[0], epsilon);                 Assert.assertEquals( 4, point[1], epsilon);             } else if (point[1] < 0) {                 cluster2Found = true;                 Assert.assertEquals(5, cluster.getPoints().size());                 Assert.assertEquals( 0, point[0], epsilon);                 Assert.assertEquals(-1, point[1], epsilon);             } else {                 cluster3Found = true;                 Assert.assertEquals(8, cluster.getPoints().size());                 Assert.assertEquals(15, point[0], epsilon);                 Assert.assertEquals(5, point[1], epsilon);             }         }         Assert.assertTrue(cluster1Found);         Assert.assertTrue(cluster2Found);         Assert.assertTrue(cluster3Found);      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.clustering;  import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ml.clustering.evaluation.CalinskiHarabasz; import org.apache.commons.math4.ml.distance.DistanceMeasure; import org.apache.commons.math4.ml.distance.EuclideanDistance; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  import java.util.ArrayList; import java.util.List; import java.util.Random;  public class MiniBatchKMeansClustererTest {     /**      * Assert the illegal parameter throws proper Exceptions.      */     @Test     public void testConstructorParameterChecks() {         expectNumberIsTooSmallException(() -> new MiniBatchKMeansClusterer<>(1, -1, -1, 3, 300, 10, null, null, null));         expectNumberIsTooSmallException(() -> new MiniBatchKMeansClusterer<>(1, -1, 100, -2, 300, 10, null, null, null));         expectNumberIsTooSmallException(() -> new MiniBatchKMeansClusterer<>(1, -1, 100, 3, -300, 10, null, null, null));         expectNumberIsTooSmallException(() -> new MiniBatchKMeansClusterer<>(1, -1, 100, 3, 300, -10, null, null, null));     }      /**      * Expects block throws NumberIsTooSmallException.      * @param block the block need to run.      */     private void expectNumberIsTooSmallException(Runnable block) {         assertException(block, NumberIsTooSmallException.class);     }      /**      * Compare the result to KMeansPlusPlusClusterer      */     @Test     public void testCompareToKMeans() {         //Generate 4 cluster         int randomSeed = 0;         List<DoublePoint> data = generateCircles(randomSeed);         KMeansPlusPlusClusterer<DoublePoint> kMeans = new KMeansPlusPlusClusterer<>(4, -1, DEFAULT_MEASURE,                 RandomSource.create(RandomSource.MT_64, randomSeed));         MiniBatchKMeansClusterer<DoublePoint> miniBatchKMeans = new MiniBatchKMeansClusterer<>(4, -1, 100, 3, 300, 10,                 DEFAULT_MEASURE, RandomSource.create(RandomSource.MT_64, randomSeed), KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE);         // Test 100 times between KMeansPlusPlusClusterer and MiniBatchKMeansClusterer         for (int i = 0; i < 100; i++) {             List<CentroidCluster<DoublePoint>> kMeansClusters = kMeans.cluster(data);             List<CentroidCluster<DoublePoint>> miniBatchKMeansClusters = miniBatchKMeans.cluster(data);             // Assert cluster result has proper clusters count.             Assert.assertEquals(4, kMeansClusters.size());             Assert.assertEquals(kMeansClusters.size(), miniBatchKMeansClusters.size());             int totalDiffCount = 0;             for (CentroidCluster<DoublePoint> kMeanCluster : kMeansClusters) {                 // Find out most similar cluster between two clusters, and summary the points count variances.                 CentroidCluster<DoublePoint> miniBatchCluster = predict(miniBatchKMeansClusters, kMeanCluster.getCenter());                 totalDiffCount += Math.abs(kMeanCluster.getPoints().size() - miniBatchCluster.getPoints().size());             }             // Statistic points different ratio.             double diffPointsRatio = totalDiffCount * 1.0 / data.size();             // Evaluator score different ratio by "CalinskiHarabasz" algorithm.             ClusterEvaluator clusterEvaluator = new CalinskiHarabasz();             double kMeansScore = clusterEvaluator.score(kMeansClusters);             double miniBatchKMeansScore = clusterEvaluator.score(miniBatchKMeansClusters);             double scoreDiffRatio = (kMeansScore - miniBatchKMeansScore) /                     kMeansScore;             // MiniBatchKMeansClusterer has few score differences between KMeansClusterer(less then 10%).             Assert.assertTrue(String.format("Different score ratio %f%%!, diff points ratio: %f%%", scoreDiffRatio * 100, diffPointsRatio * 100),                     scoreDiffRatio < 0.1);         }     }      /**      * Generate points around 4 circles.      * @param randomSeed Random seed      * @return Generated points.      */     private List<DoublePoint> generateCircles(int randomSeed) {         List<DoublePoint> data = new ArrayList<>();         Random random = new Random(randomSeed);         data.addAll(generateCircle(250, new double[]{-1.0, -1.0}, 1.0, random));         data.addAll(generateCircle(260, new double[]{0.0, 0.0}, 0.7, random));         data.addAll(generateCircle(270, new double[]{1.0, 1.0}, 0.7, random));         data.addAll(generateCircle(280, new double[]{2.0, 2.0}, 0.7, random));         return data;     }      /**      * Generate points as circles.      * @param count total points count.      * @param center circle center point.      * @param radius the circle radius points around.      * @param random the Random source.      * @return Generated points.      */     List<DoublePoint> generateCircle(int count, double[] center, double radius, Random random) {         double x0 = center[0];         double y0 = center[1];         ArrayList<DoublePoint> list = new ArrayList<>(count);         for (int i = 0; i < count; i++) {             double ao = random.nextDouble() * 720 - 360;             double r = random.nextDouble() * radius * 2 - radius;             double x1 = x0 + r * Math.cos(ao * Math.PI / 180);             double y1 = y0 + r * Math.sin(ao * Math.PI / 180);             list.add(new DoublePoint(new double[]{x1, y1}));         }         return list;     }      /**      * Assert there should be a exception.      *      * @param block          The code block need to assert.      * @param exceptionClass A exception class.      */     public static void assertException(Runnable block, Class<? extends Throwable> exceptionClass) {         try {             block.run();             Assert.fail(String.format("Expects %s", exceptionClass.getSimpleName()));         } catch (Throwable e) {             if (!exceptionClass.isInstance(e)) throw e;         }     }      /**      * Use EuclideanDistance as default DistanceMeasure      */     public static final DistanceMeasure DEFAULT_MEASURE = new EuclideanDistance();      /**      * Predict which cluster is best for the point      *      * @param clusters cluster to predict into      * @param point    point to predict      * @param measure  distance measurer      * @param <T>      type of cluster point      * @return the cluster which has nearest center to the point      */     public static <T extends Clusterable> CentroidCluster<T> predict(List<CentroidCluster<T>> clusters, Clusterable point, DistanceMeasure measure) {         double minDistance = Double.POSITIVE_INFINITY;         CentroidCluster<T> nearestCluster = null;         for (CentroidCluster<T> cluster : clusters) {             double distance = measure.compute(point.getPoint(), cluster.getCenter().getPoint());             if (distance < minDistance) {                 minDistance = distance;                 nearestCluster = cluster;             }         }         return nearestCluster;     }      /**      * Predict which cluster is best for the point      *      * @param clusters cluster to predict into      * @param point    point to predict      * @param <T>      type of cluster point      * @return the cluster which has nearest center to the point      */     public static <T extends Clusterable> CentroidCluster<T> predict(List<CentroidCluster<T>> clusters, Clusterable point) {         return predict(clusters, point, DEFAULT_MEASURE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ml.clustering;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.ml.distance.CanberraDistance; import org.apache.commons.math4.ml.distance.DistanceMeasure; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.rng.UniformRandomProvider; import org.hamcrest.CoreMatchers; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for FuzzyKMeansClusterer.  *  * @since 3.3  */ public class FuzzyKMeansClustererTest {      @Test     public void testCluster() {         final List<DoublePoint> points = new ArrayList<>();          // create 10 data points: [1], ... [10]         for (int i = 1; i <= 10; i++) {             final DoublePoint p = new DoublePoint(new double[] { i } );             points.add(p);         }          final FuzzyKMeansClusterer<DoublePoint> transformer =                 new FuzzyKMeansClusterer<>(3, 2.0);         final List<CentroidCluster<DoublePoint>> clusters = transformer.cluster(points);          // we expect 3 clusters:         //   [1], [2], [3]         //   [4], [5], [6], [7]         //   [8], [9], [10]         final List<DoublePoint> clusterOne = Arrays.asList(points.get(0), points.get(1), points.get(2));         final List<DoublePoint> clusterTwo = Arrays.asList(points.get(3), points.get(4), points.get(5), points.get(6));         final List<DoublePoint> clusterThree = Arrays.asList(points.get(7), points.get(8), points.get(9));          boolean cluster1Found = false;         boolean cluster2Found = false;         boolean cluster3Found = false;         Assert.assertEquals(3, clusters.size());         for (final Cluster<DoublePoint> cluster : clusters) {             if (cluster.getPoints().containsAll(clusterOne)) {                 cluster1Found = true;             }             if (cluster.getPoints().containsAll(clusterTwo)) {                 cluster2Found = true;             }             if (cluster.getPoints().containsAll(clusterThree)) {                 cluster3Found = true;             }         }         Assert.assertTrue(cluster1Found);         Assert.assertTrue(cluster2Found);         Assert.assertTrue(cluster3Found);     }      @Test(expected = MathIllegalArgumentException.class)     public void testTooSmallFuzzynessFactor() {         new FuzzyKMeansClusterer<DoublePoint>(3, 1.0);     }      @Test(expected = NullArgumentException.class)     public void testNullDataset() {         final FuzzyKMeansClusterer<DoublePoint> clusterer = new FuzzyKMeansClusterer<>(3, 2.0);         clusterer.cluster(null);     }      @Test     public void testGetters() {         final DistanceMeasure measure = new CanberraDistance();         final UniformRandomProvider random = RandomSource.create(RandomSource.MT_64);         final FuzzyKMeansClusterer<DoublePoint> clusterer =                 new FuzzyKMeansClusterer<>(3, 2.0, 100, measure, 1e-6, random);          Assert.assertEquals(3, clusterer.getK());         Assert.assertEquals(2.0, clusterer.getFuzziness(), 1e-6);         Assert.assertEquals(100, clusterer.getMaxIterations());         Assert.assertEquals(1e-6, clusterer.getEpsilon(), 1e-12);         Assert.assertThat(clusterer.getDistanceMeasure(), CoreMatchers.is(measure));         Assert.assertThat(clusterer.getRandomGenerator(), CoreMatchers.is(random));     }      @Test     public void testSingleCluster() {         final List<DoublePoint> points = new ArrayList<>();         points.add(new DoublePoint(new double[] { 1, 1 }));          final FuzzyKMeansClusterer<DoublePoint> transformer =                 new FuzzyKMeansClusterer<>(1, 2.0);         final List<CentroidCluster<DoublePoint>> clusters = transformer.cluster(points);          Assert.assertEquals(1, clusters.size());     }      @Test     public void testClusterCenterEqualsPoints() {         final List<DoublePoint> points = new ArrayList<>();         points.add(new DoublePoint(new double[] { 1, 1 }));         points.add(new DoublePoint(new double[] { 1.00001, 1.00001 }));         points.add(new DoublePoint(new double[] { 2, 2 }));         points.add(new DoublePoint(new double[] { 3, 3 }));          final FuzzyKMeansClusterer<DoublePoint> transformer =                 new FuzzyKMeansClusterer<>(3, 2.0);         final List<CentroidCluster<DoublePoint>> clusters = transformer.cluster(points);          Assert.assertEquals(3, clusters.size());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ml.clustering;  import java.util.Arrays; import java.util.List;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test;  public class DBSCANClustererTest {      @Test     public void testCluster() {         // Test data generated using: http://people.cs.nctu.edu.tw/~rsliang/dbscan/testdatagen.html         final DoublePoint[] points = new DoublePoint[] {                 new DoublePoint(new double[] { 83.08303244924173, 58.83387754182331 }),                 new DoublePoint(new double[] { 45.05445510940626, 23.469642649637535 }),                 new DoublePoint(new double[] { 14.96417921432294, 69.0264096390456 }),                 new DoublePoint(new double[] { 73.53189604333602, 34.896145021310076 }),                 new DoublePoint(new double[] { 73.28498173551634, 33.96860806993209 }),                 new DoublePoint(new double[] { 73.45828098873608, 33.92584423092194 }),                 new DoublePoint(new double[] { 73.9657889183145, 35.73191006924026 }),                 new DoublePoint(new double[] { 74.0074097183533, 36.81735596177168 }),                 new DoublePoint(new double[] { 73.41247541410848, 34.27314856695011 }),                 new DoublePoint(new double[] { 73.9156256353017, 36.83206791547127 }),                 new DoublePoint(new double[] { 74.81499205809087, 37.15682749846019 }),                 new DoublePoint(new double[] { 74.03144880081527, 37.57399178552441 }),                 new DoublePoint(new double[] { 74.51870941207744, 38.674258946906775 }),                 new DoublePoint(new double[] { 74.50754595105536, 35.58903978415765 }),                 new DoublePoint(new double[] { 74.51322752749547, 36.030572259100154 }),                 new DoublePoint(new double[] { 59.27900996617973, 46.41091720294207 }),                 new DoublePoint(new double[] { 59.73744793841615, 46.20015558367595 }),                 new DoublePoint(new double[] { 58.81134076672606, 45.71150126331486 }),                 new DoublePoint(new double[] { 58.52225539437495, 47.416083617601544 }),                 new DoublePoint(new double[] { 58.218626647023484, 47.36228902172297 }),                 new DoublePoint(new double[] { 60.27139669447206, 46.606106348801404 }),                 new DoublePoint(new double[] { 60.894962462363765, 46.976924697402865 }),                 new DoublePoint(new double[] { 62.29048673878424, 47.66970563563518 }),                 new DoublePoint(new double[] { 61.03857608977705, 46.212924720020965 }),                 new DoublePoint(new double[] { 60.16916214139201, 45.18193661351688 }),                 new DoublePoint(new double[] { 59.90036905976012, 47.555364347063005 }),                 new DoublePoint(new double[] { 62.33003634144552, 47.83941489877179 }),                 new DoublePoint(new double[] { 57.86035536718555, 47.31117930193432 }),                 new DoublePoint(new double[] { 58.13715479685925, 48.985960494028404 }),                 new DoublePoint(new double[] { 56.131923963548616, 46.8508904252667 }),                 new DoublePoint(new double[] { 55.976329887053, 47.46384037658572 }),                 new DoublePoint(new double[] { 56.23245975235477, 47.940035191131756 }),                 new DoublePoint(new double[] { 58.51687048212625, 46.622885352699086 }),                 new DoublePoint(new double[] { 57.85411081905477, 45.95394361577928 }),                 new DoublePoint(new double[] { 56.445776311447844, 45.162093662656844 }),                 new DoublePoint(new double[] { 57.36691949656233, 47.50097194337286 }),                 new DoublePoint(new double[] { 58.243626387557015, 46.114052729681134 }),                 new DoublePoint(new double[] { 56.27224595635198, 44.799080066150054 }),                 new DoublePoint(new double[] { 57.606924816500396, 46.94291057763621 }),                 new DoublePoint(new double[] { 30.18714230041951, 13.877149710431695 }),                 new DoublePoint(new double[] { 30.449448810657486, 13.490778346545994 }),                 new DoublePoint(new double[] { 30.295018390286714, 13.264889000216499 }),                 new DoublePoint(new double[] { 30.160201832884923, 11.89278262341395 }),                 new DoublePoint(new double[] { 31.341509791789576, 15.282655921997502 }),                 new DoublePoint(new double[] { 31.68601630325429, 14.756873246748 }),                 new DoublePoint(new double[] { 29.325963742565364, 12.097849250072613 }),                 new DoublePoint(new double[] { 29.54820742388256, 13.613295356975868 }),                 new DoublePoint(new double[] { 28.79359608888626, 10.36352064087987 }),                 new DoublePoint(new double[] { 31.01284597092308, 12.788479208014905 }),                 new DoublePoint(new double[] { 27.58509216737002, 11.47570110601373 }),                 new DoublePoint(new double[] { 28.593799561727792, 10.780998203903437 }),                 new DoublePoint(new double[] { 31.356105766724795, 15.080316198524088 }),                 new DoublePoint(new double[] { 31.25948503636755, 13.674329151166603 }),                 new DoublePoint(new double[] { 32.31590076372959, 14.95261758659035 }),                 new DoublePoint(new double[] { 30.460413702763617, 15.88402809202671 }),                 new DoublePoint(new double[] { 32.56178203062154, 14.586076852632686 }),                 new DoublePoint(new double[] { 32.76138648530468, 16.239837325178087 }),                 new DoublePoint(new double[] { 30.1829453331884, 14.709592407103628 }),                 new DoublePoint(new double[] { 29.55088173528202, 15.0651247180067 }),                 new DoublePoint(new double[] { 29.004155302187428, 14.089665298582986 }),                 new DoublePoint(new double[] { 29.339624439831823, 13.29096065578051 }),                 new DoublePoint(new double[] { 30.997460327576846, 14.551914158277214 }),                 new DoublePoint(new double[] { 30.66784126125276, 16.269703107886016 })         };          final DBSCANClusterer<DoublePoint> transformer =                 new DBSCANClusterer<>(2.0, 5);         final List<Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points));          final List<DoublePoint> clusterOne =                 Arrays.asList(points[3], points[4], points[5], points[6], points[7], points[8], points[9], points[10],                               points[11], points[12], points[13], points[14]);         final List<DoublePoint> clusterTwo =                 Arrays.asList(points[15], points[16], points[17], points[18], points[19], points[20], points[21],                               points[22], points[23], points[24], points[25], points[26], points[27], points[28],                               points[29], points[30], points[31], points[32], points[33], points[34], points[35],                               points[36], points[37], points[38]);         final List<DoublePoint> clusterThree =                 Arrays.asList(points[39], points[40], points[41], points[42], points[43], points[44], points[45],                               points[46], points[47], points[48], points[49], points[50], points[51], points[52],                               points[53], points[54], points[55], points[56], points[57], points[58], points[59],                               points[60], points[61], points[62]);          boolean cluster1Found = false;         boolean cluster2Found = false;         boolean cluster3Found = false;         Assert.assertEquals(3, clusters.size());         for (final Cluster<DoublePoint> cluster : clusters) {             if (cluster.getPoints().containsAll(clusterOne)) {                 cluster1Found = true;             }             if (cluster.getPoints().containsAll(clusterTwo)) {                 cluster2Found = true;             }             if (cluster.getPoints().containsAll(clusterThree)) {                 cluster3Found = true;             }         }         Assert.assertTrue(cluster1Found);         Assert.assertTrue(cluster2Found);         Assert.assertTrue(cluster3Found);     }      @Test     public void testSingleLink() {         final DoublePoint[] points = {                 new DoublePoint(new int[] {10, 10}), // A                 new DoublePoint(new int[] {12, 9}),                 new DoublePoint(new int[] {10, 8}),                 new DoublePoint(new int[] {8, 8}),                 new DoublePoint(new int[] {8, 6}),                 new DoublePoint(new int[] {7, 7}),                 new DoublePoint(new int[] {5, 6}),  // B                 new DoublePoint(new int[] {14, 8}), // C                 new DoublePoint(new int[] {7, 15}), // N - Noise, should not be present                 new DoublePoint(new int[] {17, 8}), // D - single-link connected to C should not be present          };          final DBSCANClusterer<DoublePoint> clusterer = new DBSCANClusterer<>(3, 3);         List<Cluster<DoublePoint>> clusters = clusterer.cluster(Arrays.asList(points));          Assert.assertEquals(1, clusters.size());          final List<DoublePoint> clusterOne =                 Arrays.asList(points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]);         Assert.assertTrue(clusters.get(0).getPoints().containsAll(clusterOne));     }      @Test     public void testGetEps() {         final DBSCANClusterer<DoublePoint> transformer = new DBSCANClusterer<>(2.0, 5);         Assert.assertEquals(2.0, transformer.getEps(), 0.0);     }      @Test     public void testGetMinPts() {         final DBSCANClusterer<DoublePoint> transformer = new DBSCANClusterer<>(2.0, 5);         Assert.assertEquals(5, transformer.getMinPts());     }      @Test(expected = MathIllegalArgumentException.class)     public void testNegativeEps() {         new DBSCANClusterer<DoublePoint>(-2.0, 5);     }      @Test(expected = MathIllegalArgumentException.class)     public void testNegativeMinPts() {         new DBSCANClusterer<DoublePoint>(2.0, -5);     }      @Test(expected = NullArgumentException.class)     public void testNullDataset() {         DBSCANClusterer<DoublePoint> clusterer = new DBSCANClusterer<>(2.0, 5);         clusterer.cluster(null);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.clustering;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;  import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ml.distance.EuclideanDistance; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.rng.UniformRandomProvider; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class KMeansPlusPlusClustererTest {      private UniformRandomProvider random;      @Before     public void setUp() {         random = RandomSource.create(RandomSource.MT_64, 1746432956321l);     }      /**      * JIRA: MATH-305      *      * Two points, one cluster, one iteration      */     @Test     public void testPerformClusterAnalysisDegenerate() {         KMeansPlusPlusClusterer<DoublePoint> transformer =                 new KMeansPlusPlusClusterer<>(1, 1);          DoublePoint[] points = new DoublePoint[] {                 new DoublePoint(new int[] { 1959, 325100 }),                 new DoublePoint(new int[] { 1960, 373200 }), };         List<? extends Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points));         Assert.assertEquals(1, clusters.size());         Assert.assertEquals(2, (clusters.get(0).getPoints().size()));         DoublePoint pt1 = new DoublePoint(new int[] { 1959, 325100 });         DoublePoint pt2 = new DoublePoint(new int[] { 1960, 373200 });         Assert.assertTrue(clusters.get(0).getPoints().contains(pt1));         Assert.assertTrue(clusters.get(0).getPoints().contains(pt2));      }      @Test     public void testCertainSpace() {         KMeansPlusPlusClusterer.EmptyClusterStrategy[] strategies = {             KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE,             KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER,             KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT         };         for (KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies) {             int numberOfVariables = 27;             // initialise testvalues             int position1 = 1;             int position2 = position1 + numberOfVariables;             int position3 = position2 + numberOfVariables;             int position4 = position3 + numberOfVariables;             // testvalues will be multiplied             int multiplier = 1000000;              DoublePoint[] breakingPoints = new DoublePoint[numberOfVariables];             // define the space which will break the cluster algorithm             for (int i = 0; i < numberOfVariables; i++) {                 int points[] = { position1, position2, position3, position4 };                 // multiply the values                 for (int j = 0; j < points.length; j++) {                     points[j] *= multiplier;                 }                 DoublePoint DoublePoint = new DoublePoint(points);                 breakingPoints[i] = DoublePoint;                 position1 += numberOfVariables;                 position2 += numberOfVariables;                 position3 += numberOfVariables;                 position4 += numberOfVariables;             }              for (int n = 2; n < 27; ++n) {                 KMeansPlusPlusClusterer<DoublePoint> transformer =                     new KMeansPlusPlusClusterer<>(n, 100, new EuclideanDistance(), random, strategy);                  List<? extends Cluster<DoublePoint>> clusters =                         transformer.cluster(Arrays.asList(breakingPoints));                  Assert.assertEquals(n, clusters.size());                 int sum = 0;                 for (Cluster<DoublePoint> cluster : clusters) {                     sum += cluster.getPoints().size();                 }                 Assert.assertEquals(numberOfVariables, sum);             }         }      }      /**      * A helper class for testSmallDistances(). This class is similar to DoublePoint, but      * it defines a different distanceFrom() method that tends to return distances less than 1.      */     private class CloseDistance extends EuclideanDistance {         private static final long serialVersionUID = 1L;          @Override         public double compute(double[] a, double[] b) {             return super.compute(a, b) * 0.001;         }     }      /**      * Test points that are very close together. See issue MATH-546.      */     @Test     public void testSmallDistances() {         // Create a bunch of CloseDoublePoints. Most are identical, but one is different by a         // small distance.         int[] repeatedArray = { 0 };         int[] uniqueArray = { 1 };         DoublePoint repeatedPoint = new DoublePoint(repeatedArray);         DoublePoint uniquePoint = new DoublePoint(uniqueArray);          Collection<DoublePoint> points = new ArrayList<>();         final int NUM_REPEATED_POINTS = 10 * 1000;         for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {             points.add(repeatedPoint);         }         points.add(uniquePoint);          // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial         // cluster centers).         final int NUM_CLUSTERS = 2;         final int NUM_ITERATIONS = 0;          KMeansPlusPlusClusterer<DoublePoint> clusterer =             new KMeansPlusPlusClusterer<>(NUM_CLUSTERS, NUM_ITERATIONS,                     new CloseDistance(), random);         List<CentroidCluster<DoublePoint>> clusters = clusterer.cluster(points);          // Check that one of the chosen centers is the unique point.         boolean uniquePointIsCenter = false;         for (CentroidCluster<DoublePoint> cluster : clusters) {             if (cluster.getCenter().equals(uniquePoint)) {                 uniquePointIsCenter = true;             }         }         Assert.assertTrue(uniquePointIsCenter);     }      /**      * 2 variables cannot be clustered into 3 clusters. See issue MATH-436.      */     @Test(expected=NumberIsTooSmallException.class)     public void testPerformClusterAnalysisToManyClusters() {         KMeansPlusPlusClusterer<DoublePoint> transformer =             new KMeansPlusPlusClusterer<>(3, 1, new EuclideanDistance(), random);          DoublePoint[] points = new DoublePoint[] {             new DoublePoint(new int[] {                 1959, 325100             }), new DoublePoint(new int[] {                 1960, 373200             })         };          transformer.cluster(Arrays.asList(points));      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.clustering.evaluation;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.ml.clustering.Cluster; import org.apache.commons.math4.ml.clustering.DoublePoint; import org.apache.commons.math4.ml.clustering.ClusterEvaluator; import org.apache.commons.math4.ml.distance.EuclideanDistance; import org.junit.Before; import org.junit.Test;  public class SumOfClusterVariancesTest {      private ClusterEvaluator evaluator;      @Before     public void setUp() {         evaluator = new SumOfClusterVariances(new EuclideanDistance());     }      @Test     public void testScore() {         final DoublePoint[] points1 = new DoublePoint[] {                 new DoublePoint(new double[] { 1 }),                 new DoublePoint(new double[] { 2 }),                 new DoublePoint(new double[] { 3 })         };          final DoublePoint[] points2 = new DoublePoint[] {                 new DoublePoint(new double[] { 1 }),                 new DoublePoint(new double[] { 5 }),                 new DoublePoint(new double[] { 10 })         };          final List<Cluster<DoublePoint>> clusters = new ArrayList<>();          final Cluster<DoublePoint> cluster1 = new Cluster<>();         for (DoublePoint p : points1) {             cluster1.addPoint(p);         }         clusters.add(cluster1);          assertEquals(1.0/3.0, evaluator.score(clusters), 1e-6);          final Cluster<DoublePoint> cluster2 = new Cluster<>();         for (DoublePoint p : points2) {             cluster2.addPoint(p);         }         clusters.add(cluster2);          assertEquals(6.148148148, evaluator.score(clusters), 1e-6);     }      @Test     public void testOrdering() {         assertTrue(evaluator.isBetterScore(10, 20));         assertFalse(evaluator.isBetterScore(20, 1));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ml.clustering.evaluation;  import org.apache.commons.math4.ml.clustering.CentroidCluster; import org.apache.commons.math4.ml.clustering.ClusterEvaluator; import org.apache.commons.math4.ml.clustering.DoublePoint; import org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer; import org.apache.commons.math4.ml.distance.DistanceMeasure; import org.apache.commons.math4.ml.distance.EuclideanDistance; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  import java.util.ArrayList; import java.util.List;  public class CalinskiHarabaszTest {     private ClusterEvaluator evaluator;     private DistanceMeasure distanceMeasure;      @Before     public void setUp() {         evaluator = new CalinskiHarabasz();         distanceMeasure = new EuclideanDistance();     }      @Test     public void test_k_equals_4_is_best_for_a_4_center_points() {         final int dimension = 2;         final double[][] centers = {{-1, -1}, {0, 0}, {1, 1}, {2, 2}};         final UniformRandomProvider rnd = RandomSource.create(RandomSource.MT_64, 0);         final List<DoublePoint> points = new ArrayList<>();         // Generate 1000 points around 4 centers for test.         for (int i = 0; i < 1000; i++) {             double[] center = centers[i % centers.length];             double[] point = new double[dimension];             for (int j = 0; j < dimension; j++) {                 double offset = (rnd.nextDouble() - 0.5) / 2;                 Assert.assertTrue(offset < 0.25 && offset > -0.25);                 point[j] = offset + center[j];             }             points.add(new DoublePoint(point));         }         double expectBestScore = 0.0;         double actualBestScore = 0.0;         for (int i = 0; i < 5; i++) {             final int k = i + 2;             KMeansPlusPlusClusterer<DoublePoint> kMeans = new KMeansPlusPlusClusterer<>(k, -1, distanceMeasure, rnd);             List<CentroidCluster<DoublePoint>> clusters = kMeans.cluster(points);             double score = evaluator.score(clusters);             if (score > expectBestScore) {                 expectBestScore = score;             }             if (k == centers.length) {                 actualBestScore = score;             }         }          // k=4 get the highest score         Assert.assertEquals(expectBestScore, actualBestScore, 0.0);     }      @Test     public void test_compare_to_skLearn() {         final UniformRandomProvider rnd = RandomSource.create(RandomSource.MT_64, 0);         final List<DoublePoint> points = new ArrayList<>();         for (double[] p : dataFromSkLearn) {             points.add(new DoublePoint(p));         }         double expectBestScore = 0.0;         double actualBestScore = 0.0;         for (int i = 0; i < 5; i++) {             final int k = i + 2;             KMeansPlusPlusClusterer<DoublePoint> kMeans = new KMeansPlusPlusClusterer<>(k, -1, distanceMeasure, rnd);             List<CentroidCluster<DoublePoint>> clusters = kMeans.cluster(points);             double score = evaluator.score(clusters);             if (score > expectBestScore) {                 expectBestScore = score;             }              // The score is approximately equals sklearn's score when k is smaller or equals to best k.             if (k <= kFromSkLearn) {                 actualBestScore = score;                 Assert.assertEquals(scoreFromSkLearn[i], score, 0.001);             }         }          // k=4 get the highest score         Assert.assertEquals(expectBestScore, actualBestScore, 0.0);     }      final static int kFromSkLearn = 4;     final static double[] scoreFromSkLearn = {622.487247165719, 597.7763150683217, 1157.7901325495295,             1136.8201767857847, 1092.708039201163};     final static double[][] dataFromSkLearn = {             {1.403414, 1.148639}, {0.203959, 0.172137}, {2.132351, 1.883029}, {0.176704, -0.106040},             {-0.729892, -0.987217}, {2.073591, 1.891133}, {-0.632742, -0.847796}, {-0.080353, 0.388064},             {1.293772, 0.999236}, {-0.478476, -0.444240}, {1.154994, 0.922124}, {0.213056, 0.247446},             {1.246047, 1.329821}, {2.010432, 1.939522}, {-0.249074, 0.060909}, {1.960038, 1.883771},             {0.068528, -0.119460}, {1.035851, 0.992598}, {2.206471, 2.040334}, {2.114869, 2.186366},             {0.192118, 0.042242}, {0.194172, 0.230945}, {1.969581, 2.118761}, {1.211497, 0.803267},             {0.852534, 1.171513}, {2.032709, 2.068391}, {0.862354, 1.096274}, {-1.151345, -1.192454},             {2.642026, 1.905175}, {-1.009092, -1.383999}, {1.123967, 0.799541}, {2.452222, 2.079981},             {0.665412, 0.829890}, {2.145178, 1.991171}, {-1.186327, -1.110976}, {2.009537, 1.683832},             {1.900143, 2.059320}, {1.217072, 1.073173}, {-0.011930, 0.182649}, {-1.255492, -0.670092},             {0.221479, -0.239351}, {-0.155211, -0.129519}, {0.076976, 0.070879}, {2.340748, 1.728946},             {-0.785182, -1.003191}, {-0.048162, 0.054161}, {-0.590787, -1.261207}, {-0.322545, -1.678934},             {1.721805, 2.019360}, {-0.055982, 0.406160}, {1.786591, 2.030543}, {2.319241, 1.662943},             {-0.037710, 0.140065}, {1.255095, 1.042194}, {1.111086, 1.165950}, {-0.218115, -0.034970},             {2.187137, 1.692329}, {1.316916, 1.077612}, {0.112255, 0.047945}, {0.739778, 0.945151},             {-0.452803, -0.989958}, {2.105973, 2.005392}, {-1.090926, -0.892274}, {-0.016388, -0.243725},             {1.069622, 0.746740}, {2.071495, 1.707953}, {-0.734458, -0.700208}, {-0.793453, -1.142096},             {0.279182, 0.216376}, {-1.280766, -1.789708}, {-0.547815, -0.583041}, {1.320526, 1.312906},             {-0.881327, -0.716999}, {0.779240, 0.887246}, {1.925328, 1.547436}, {-0.024202, -0.206561},             {2.320019, 2.209286}, {-0.265125, 0.187406}, {-0.841028, -0.336119}, {-1.158193, -0.486245},             {2.107928, 2.027572}, {-0.203312, -0.058400}, {1.746752, 1.692956}, {-0.943192, -1.661465},             {-0.692261, -1.359602}, {1.189437, 1.239394}, {2.122793, 1.946352}, {0.808161, 1.145078},             {-0.214102, -0.254642}, {1.964497, 1.659230}, {0.162827, -0.203977}, {-1.197499, -1.150439},             {0.893478, 1.187206}, {2.268571, 1.937285}, {1.874589, 1.792590}, {2.115534, 2.148600},             {0.971884, 0.741704}, {-2.068844, -1.365312}, {1.923238, 2.135497}, {0.943657, 1.303986},             {2.059181, 1.866467}, {-1.150325, -1.369225}, {-0.090138, 0.186226}, {-0.361086, 0.086080},             {0.781402, 0.552706}, {1.788317, 2.180373}, {0.798725, 1.200775}, {-1.054850, -0.480968},             {-0.161374, 0.263608}, {1.261640, 0.869688}, {0.924957, 1.192590}, {1.094182, 1.031706},             {1.622207, 1.731404}, {-2.117348, -1.090460}, {1.005802, 1.040883}, {2.015137, 1.958903},             {-0.248881, 0.187862}, {1.890444, 2.059389}, {1.074242, 0.875771}, {2.004657, 1.895254},             {0.854140, 0.811218}, {-0.798992, -1.633529}, {0.311872, -0.109260}, {-0.219108, 0.480269},             {1.138654, 1.324903}, {-2.062293, -1.023073}, {0.141443, -0.087330}, {-0.745644, -0.303953},             {0.763012, 0.793850}, {0.975160, 0.969506}, {-1.262475, -1.264683}, {-0.934801, -0.516551},             {-1.342065, -0.999911}, {-0.113459, 0.213991}, {2.359609, 1.856216}, {0.408595, 0.377997},             {-0.382908, -1.360288}, {1.873100, 1.984283}, {-0.158167, 0.128779}, {1.001959, 0.842014},             {2.073056, 1.993139}, {-0.916489, -0.868636}, {1.350903, 1.159256}, {-0.999557, -1.115818},             {1.699934, 2.255168}, {-0.451647, 0.135991}, {1.761330, 2.091668}, {0.158764, -0.052111},             {0.948387, 0.928156}, {-1.723536, -0.864100}, {1.791458, 2.053596}, {0.765689, 1.028344},             {2.232360, 1.956492}, {-0.270874, -0.827692}, {0.702813, 0.784622}, {-0.205446, -0.314226},             {0.817023, 0.835158}, {-1.484335, -1.201362}, {1.875541, 1.974222}, {1.096270, 0.543190},             {-1.096272, -1.259179}, {-0.985800, -0.660712}, {0.095980, 0.012351}, {0.905097, 0.998787},             {2.087597, 1.879789}, {-0.146487, 0.088045}, {-1.606932, -1.196349}, {1.168532, 0.837345},             {2.119787, 2.128731}, {-0.115728, 0.016410}, {1.049650, 1.258826}, {-0.207201, -0.026785},             {-0.119676, 0.024613}, {-0.167932, -0.295941}, {-0.233100, -1.060121}, {1.379617, 1.104958},             {-0.097467, 0.075053}, {-1.153246, -0.956188}, {-0.159732, -0.364957}, {0.184015, 0.210984},             {-1.446427, -1.005153}, {1.970006, 2.084909}, {1.443284, 1.450596}, {1.133778, 1.024311},             {2.236527, 2.063874}, {0.167056, -0.170384}, {0.108058, 0.061813}, {-0.630086, -0.981357},             {-1.262581, -1.022503}, {0.993000, 1.033955}, {1.939089, 2.116008}, {0.888129, 1.150939},             {-1.033035, -0.017927}, {-1.067896, -0.033157}, {2.082978, 2.321452}, {0.975302, 0.964340},             {-1.199290, -1.836711}, {-1.199961, -0.825432}, {0.084522, 0.199842}, {0.129213, 0.052383}     }; } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.dfp;  public class Decimal10 extends DfpDec {      Decimal10(final DfpField factory) {         super(factory);     }      Decimal10(final DfpField factory, final byte x) {         super(factory, x);     }      Decimal10(final DfpField factory, final int x) {         super(factory, x);     }      Decimal10(final DfpField factory, final long x) {         super(factory, x);     }      Decimal10(final DfpField factory, final double x) {         super(factory, x);     }      public Decimal10(final Dfp d) {         super(d);     }      public Decimal10(final DfpField factory, final String s) {         super(factory, s);     }      protected Decimal10(final DfpField factory, final byte sign, final byte nans) {         super(factory, sign, nans);     }      @Override     public Dfp newInstance() {         return new Decimal10(getField());     }      @Override     public Dfp newInstance(final byte x) {         return new Decimal10(getField(), x);     }      @Override     public Dfp newInstance(final int x) {         return new Decimal10(getField(), x);     }      @Override     public Dfp newInstance(final long x) {         return new Decimal10(getField(), x);     }      @Override     public Dfp newInstance(final double x) {         return new Decimal10(getField(), x);     }      @Override     public Dfp newInstance(final Dfp d) {         return new Decimal10(d);     }      @Override     public Dfp newInstance(final String s) {         return new Decimal10(getField(), s);     }      @Override     public Dfp newInstance(final byte sign, final byte nans) {         return new Decimal10(getField(), sign, nans);     }      @Override     protected int getDecimalDigits() {         return 10;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.dfp;  import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class DfpDecTest {      private DfpField field;     private Dfp pinf;     private Dfp ninf;      @Before     public void setUp() {         // Some basic setup.  Define some constants and clear the status flags         field = new DfpField(20);         pinf = new DfpDec(field, 1).divide(new DfpDec(field, 0));         ninf = new DfpDec(field, -1).divide(new DfpDec(field, 0));         ninf.getField().clearIEEEFlags();     }      @After     public void tearDown() {         field = null;         pinf    = null;         ninf    = null;     }      // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.     // If the test fail, it prints the desc string     private void test(Dfp x, Dfp y, int flags, String desc) {         boolean b = x.equals(y);          if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));          if (x.equals(new DfpDec(field, 0)))  // distinguish +/- zero             b = (b && (x.toString().equals(y.toString())));          b = (b && x.getField().getIEEEFlags() == flags);          if (!b) {             Assert.assertTrue("assertion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);         }          x.getField().clearIEEEFlags();     }      @Test     public void testRound()     {         field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);          test(new DfpDec(field, "12345678901234567890"),              new DfpDec(field, "12345678901234568000"),              DfpField.FLAG_INEXACT, "Round #1");          test(new DfpDec(field, "0.12345678901234567890"),              new DfpDec(field, "0.12345678901234568"),              DfpField.FLAG_INEXACT, "Round #2");          test(new DfpDec(field, "0.12345678901234567500"),              new DfpDec(field, "0.12345678901234568"),              DfpField.FLAG_INEXACT, "Round #3");          test(new DfpDec(field, "0.12345678901234568500"),              new DfpDec(field, "0.12345678901234568"),              DfpField.FLAG_INEXACT, "Round #4");          test(new DfpDec(field, "0.12345678901234568501"),              new DfpDec(field, "0.12345678901234569"),              DfpField.FLAG_INEXACT, "Round #5");          test(new DfpDec(field, "0.12345678901234568499"),              new DfpDec(field, "0.12345678901234568"),              DfpField.FLAG_INEXACT, "Round #6");          test(new DfpDec(field, "1.2345678901234567890"),              new DfpDec(field, "1.2345678901234568"),              DfpField.FLAG_INEXACT, "Round #7");          test(new DfpDec(field, "1.2345678901234567500"),              new DfpDec(field, "1.2345678901234568"),              DfpField.FLAG_INEXACT, "Round #8");          test(new DfpDec(field, "1.2345678901234568500"),              new DfpDec(field, "1.2345678901234568"),              DfpField.FLAG_INEXACT, "Round #9");          test(new DfpDec(field, "1.2345678901234568000").add(new DfpDec(field, ".0000000000000000501")),              new DfpDec(field, "1.2345678901234569"),              DfpField.FLAG_INEXACT, "Round #10");          test(new DfpDec(field, "1.2345678901234568499"),              new DfpDec(field, "1.2345678901234568"),              DfpField.FLAG_INEXACT, "Round #11");          test(new DfpDec(field, "12.345678901234567890"),              new DfpDec(field, "12.345678901234568"),              DfpField.FLAG_INEXACT, "Round #12");          test(new DfpDec(field, "12.345678901234567500"),              new DfpDec(field, "12.345678901234568"),              DfpField.FLAG_INEXACT, "Round #13");          test(new DfpDec(field, "12.345678901234568500"),              new DfpDec(field, "12.345678901234568"),              DfpField.FLAG_INEXACT, "Round #14");          test(new DfpDec(field, "12.345678901234568").add(new DfpDec(field, ".000000000000000501")),              new DfpDec(field, "12.345678901234569"),              DfpField.FLAG_INEXACT, "Round #15");          test(new DfpDec(field, "12.345678901234568499"),              new DfpDec(field, "12.345678901234568"),              DfpField.FLAG_INEXACT, "Round #16");          test(new DfpDec(field, "123.45678901234567890"),              new DfpDec(field, "123.45678901234568"),              DfpField.FLAG_INEXACT, "Round #17");          test(new DfpDec(field, "123.45678901234567500"),              new DfpDec(field, "123.45678901234568"),              DfpField.FLAG_INEXACT, "Round #18");          test(new DfpDec(field, "123.45678901234568500"),              new DfpDec(field, "123.45678901234568"),              DfpField.FLAG_INEXACT, "Round #19");          test(new DfpDec(field, "123.456789012345685").add(new DfpDec(field, ".00000000000000501")),              new DfpDec(field, "123.45678901234569"),              DfpField.FLAG_INEXACT, "Round #20");          test(new DfpDec(field, "123.45678901234568499"),              new DfpDec(field, "123.45678901234568"),              DfpField.FLAG_INEXACT, "Round #21");          field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);          // Round down         test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9")),              new DfpDec(field, "12345678901234567"),              DfpField.FLAG_INEXACT, "Round #22");          test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.99999999")),              new DfpDec(field, "12345678901234567"),              DfpField.FLAG_INEXACT, "Round #23");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.99999999")),              new DfpDec(field, "-12345678901234567"),              DfpField.FLAG_INEXACT, "Round #24");          field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);          // Round up         test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.1")),              new DfpDec(field, "12345678901234568"),              DfpField.FLAG_INEXACT, "Round #25");          test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")),              new DfpDec(field, "12345678901234568"),              DfpField.FLAG_INEXACT, "Round #26");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.1")),              new DfpDec(field, "-12345678901234568"),              DfpField.FLAG_INEXACT, "Round #27");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")),              new DfpDec(field, "-12345678901234568"),              DfpField.FLAG_INEXACT, "Round #28");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "0")),              new DfpDec(field, "-12345678901234567"),              0, "Round #28.5");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);          // Round half up         test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.499999999999")),              new DfpDec(field, "12345678901234567"),              DfpField.FLAG_INEXACT, "Round #29");          test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.50000001")),              new DfpDec(field, "12345678901234568"),              DfpField.FLAG_INEXACT, "Round #30");          test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5")),              new DfpDec(field, "12345678901234568"),              DfpField.FLAG_INEXACT, "Round #30.5");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.499999999999")),              new DfpDec(field, "-12345678901234567"),              DfpField.FLAG_INEXACT, "Round #31");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.50000001")),              new DfpDec(field, "-12345678901234568"),              DfpField.FLAG_INEXACT, "Round #32");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);          // Round half down         test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5001")),              new DfpDec(field, "12345678901234568"),              DfpField.FLAG_INEXACT, "Round #33");          test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")),              new DfpDec(field, "12345678901234567"),              DfpField.FLAG_INEXACT, "Round #34");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5001")),              new DfpDec(field, "-12345678901234568"),              DfpField.FLAG_INEXACT, "Round #35");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.6")),              new DfpDec(field, "-12345678901234568"),              DfpField.FLAG_INEXACT, "Round #35.5");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")),              new DfpDec(field, "-12345678901234567"),              DfpField.FLAG_INEXACT, "Round #36");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);          // Round half odd         test(new DfpDec(field, "12345678901234568").add(new DfpDec(field, "0.5000")),              new DfpDec(field, "12345678901234569"),              DfpField.FLAG_INEXACT, "Round #37");          test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")),              new DfpDec(field, "12345678901234567"),              DfpField.FLAG_INEXACT, "Round #38");          test(new DfpDec(field, "-12345678901234568").add(new DfpDec(field, "-0.5000")),              new DfpDec(field, "-12345678901234569"),              DfpField.FLAG_INEXACT, "Round #39");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")),              new DfpDec(field, "-12345678901234567"),              DfpField.FLAG_INEXACT, "Round #40");          field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);          // Round ceil         test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")),              new DfpDec(field, "12345678901234568"),              DfpField.FLAG_INEXACT, "Round #41");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.9999")),              new DfpDec(field, "-12345678901234567"),              DfpField.FLAG_INEXACT, "Round #42");          field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);          // Round floor         test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9999")),              new DfpDec(field, "12345678901234567"),              DfpField.FLAG_INEXACT, "Round #43");          test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")),              new DfpDec(field, "-12345678901234568"),              DfpField.FLAG_INEXACT, "Round #44");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset     }      @Test     public void testRoundDecimal10()     {         field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);          test(new Decimal10(field, "1234567891234567890"),              new Decimal10(field, "1234567891000000000"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #1");          test(new Decimal10(field, "0.1234567891634567890"),              new Decimal10(field, "0.1234567892"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #2");          test(new Decimal10(field, "0.1234567891500000000"),              new Decimal10(field, "0.1234567892"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #3");          test(new Decimal10(field, "0.1234567890500"),              new Decimal10(field, "0.1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #4");          test(new Decimal10(field, "0.1234567890501"),              new Decimal10(field, "0.1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #5");          test(new Decimal10(field, "0.1234567890499"),              new Decimal10(field, "0.1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #6");          test(new Decimal10(field, "1.234567890890"),              new Decimal10(field, "1.234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #7");          test(new Decimal10(field, "1.234567891500"),              new Decimal10(field, "1.234567892"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #8");          test(new Decimal10(field, "1.234567890500"),              new Decimal10(field, "1.234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #9");          test(new Decimal10(field, "1.234567890000").add(new Decimal10(field, ".000000000501")),              new Decimal10(field, "1.234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #10");          test(new Decimal10(field, "1.234567890499"),              new Decimal10(field, "1.234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #11");          test(new Decimal10(field, "12.34567890890"),              new Decimal10(field, "12.34567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #12");          test(new Decimal10(field, "12.34567891500"),              new Decimal10(field, "12.34567892"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #13");          test(new Decimal10(field, "12.34567890500"),              new Decimal10(field, "12.34567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #14");          test(new Decimal10(field, "12.34567890").add(new Decimal10(field, ".00000000501")),              new Decimal10(field, "12.34567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #15");          test(new Decimal10(field, "12.34567890499"),              new Decimal10(field, "12.34567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #16");          test(new Decimal10(field, "123.4567890890"),              new Decimal10(field, "123.4567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #17");          test(new Decimal10(field, "123.4567891500"),              new Decimal10(field, "123.4567892"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #18");          test(new Decimal10(field, "123.4567890500"),              new Decimal10(field, "123.4567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #19");          test(new Decimal10(field, "123.4567890").add(new Decimal10(field, ".0000000501")),              new Decimal10(field, "123.4567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #20");          test(new Decimal10(field, "123.4567890499"),              new Decimal10(field, "123.4567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #21");          field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);          // RoundDecimal10 down         test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9")),              new Decimal10(field, "1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #22");          test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.99999999")),              new Decimal10(field, "1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #23");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.99999999")),              new Decimal10(field, "-1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #24");          field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);          // RoundDecimal10 up         test(new Decimal10(field, 1234567890).add(new Decimal10(field, "0.1")),              new Decimal10(field, 1234567891l),              DfpField.FLAG_INEXACT, "RoundDecimal10 #25");          test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")),              new Decimal10(field, "1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #26");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.1")),              new Decimal10(field, "-1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #27");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")),              new Decimal10(field, "-1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #28");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "0")),              new Decimal10(field, "-1234567890"),              0, "RoundDecimal10 #28.5");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);          // RoundDecimal10 half up         test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.4999999999")),              new Decimal10(field, "1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #29");          test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.50000001")),              new Decimal10(field, "1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #30");          test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5")),              new Decimal10(field, "1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #30.5");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.4999999999")),              new Decimal10(field, "-1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #31");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.50000001")),              new Decimal10(field, "-1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #32");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);          // RoundDecimal10 half down         test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5001")),              new Decimal10(field, "1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #33");          test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")),              new Decimal10(field, "1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #34");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5001")),              new Decimal10(field, "-1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #35");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.6")),              new Decimal10(field, "-1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #35.5");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")),              new Decimal10(field, "-1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #36");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);          // RoundDecimal10 half odd         test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")),              new Decimal10(field, "1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #37");          test(new Decimal10(field, "1234567891").add(new Decimal10(field, "0.5000")),              new Decimal10(field, "1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #38");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")),              new Decimal10(field, "-1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #39");          test(new Decimal10(field, "-1234567891").add(new Decimal10(field, "-0.5000")),              new Decimal10(field, "-1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #40");          field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);          // RoundDecimal10 ceil         test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")),              new Decimal10(field, "1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #41");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.9999")),              new Decimal10(field, "-1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #42");          field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);          // RoundDecimal10 floor         test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9999")),              new Decimal10(field, "1234567890"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #43");          test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")),              new Decimal10(field, "-1234567891"),              DfpField.FLAG_INEXACT, "RoundDecimal10 #44");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset     }      @Test     public void testNextAfter()     {         test(new DfpDec(field, 1).nextAfter(pinf),              new DfpDec(field, "1.0000000000000001"),              0, "NextAfter #1");          test(new DfpDec(field, "1.0000000000000001").nextAfter(ninf),              new DfpDec(field, 1),              0, "NextAfter #1.5");          test(new DfpDec(field, 1).nextAfter(ninf),              new DfpDec(field, "0.99999999999999999"),              0, "NextAfter #2");          test(new DfpDec(field, "0.99999999999999999").nextAfter(new DfpDec(field, 2)),              new DfpDec(field, 1),              0, "NextAfter #3");          test(new DfpDec(field, -1).nextAfter(ninf),              new DfpDec(field, "-1.0000000000000001"),              0, "NextAfter #4");          test(new DfpDec(field, -1).nextAfter(pinf),              new DfpDec(field, "-0.99999999999999999"),              0, "NextAfter #5");          test(new DfpDec(field, "-0.99999999999999999").nextAfter(new DfpDec(field, -2)),              new DfpDec(field, (byte) -1),              0, "NextAfter #6");          test(new DfpDec(field, (byte) 2).nextAfter(new DfpDec(field, 2)),              new DfpDec(field, 2l),              0, "NextAfter #7");          test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 0)),              new DfpDec(field, 0),              0, "NextAfter #8");          test(new DfpDec(field, -2).nextAfter(new DfpDec(field, -2)),              new DfpDec(field, -2),              0, "NextAfter #9");          test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 1)),              new DfpDec(field, "1e-131092"),              DfpField.FLAG_UNDERFLOW, "NextAfter #10");          test(new DfpDec(field, 0).nextAfter(new DfpDec(field, -1)),              new DfpDec(field, "-1e-131092"),              DfpField.FLAG_UNDERFLOW, "NextAfter #11");          test(new DfpDec(field, "-1e-131092").nextAfter(pinf),              new DfpDec(field, "-0"),              DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12");          test(new DfpDec(field, "1e-131092").nextAfter(ninf),              new DfpDec(field, "0"),              DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13");          test(new DfpDec(field, "9.9999999999999999e131078").nextAfter(pinf),              pinf,              DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14");     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.dfp;  import org.apache.commons.math4.ExtendedFieldElementAbstractTest; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class DfpTest extends ExtendedFieldElementAbstractTest<Dfp> {      @Override     protected Dfp build(final double x) {         return field.newDfp(x);     }      private DfpField field;     private Dfp pinf;     private Dfp ninf;     private Dfp nan;     private Dfp snan;     private Dfp qnan;      @Before     public void setUp() {         // Some basic setup.  Define some constants and clear the status flags         field = new DfpField(20);         pinf = field.newDfp("1").divide(field.newDfp("0"));         ninf = field.newDfp("-1").divide(field.newDfp("0"));         nan = field.newDfp("0").divide(field.newDfp("0"));         snan = field.newDfp((byte)1, Dfp.SNAN);         qnan = field.newDfp((byte)1, Dfp.QNAN);         ninf.getField().clearIEEEFlags();     }      @After     public void tearDown() {         field = null;         pinf    = null;         ninf    = null;         nan     = null;         snan    = null;         qnan    = null;     }      // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.     // If the test fail, it prints the desc string     private void test(Dfp x, Dfp y, int flags, String desc) {         boolean b = x.equals(y);          if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));          if (x.equals(field.newDfp("0")))  // distinguish +/- zero             b = (b && (x.toString().equals(y.toString())));          b = (b && x.getField().getIEEEFlags() == flags);          if (!b)             Assert.assertTrue("assertion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);          x.getField().clearIEEEFlags();     }      @Test     public void testByteConstructor() {         Assert.assertEquals("0.", new Dfp(field, (byte) 0).toString());         Assert.assertEquals("1.", new Dfp(field, (byte) 1).toString());         Assert.assertEquals("-1.", new Dfp(field, (byte) -1).toString());         Assert.assertEquals("-128.", new Dfp(field, Byte.MIN_VALUE).toString());         Assert.assertEquals("127.", new Dfp(field, Byte.MAX_VALUE).toString());     }      @Test     public void testIntConstructor() {         Assert.assertEquals("0.", new Dfp(field, 0).toString());         Assert.assertEquals("1.", new Dfp(field, 1).toString());         Assert.assertEquals("-1.", new Dfp(field, -1).toString());         Assert.assertEquals("1234567890.", new Dfp(field, 1234567890).toString());         Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890).toString());         Assert.assertEquals("-2147483648.", new Dfp(field, Integer.MIN_VALUE).toString());         Assert.assertEquals("2147483647.", new Dfp(field, Integer.MAX_VALUE).toString());     }      @Test     public void testLongConstructor() {         Assert.assertEquals("0.", new Dfp(field, 0l).toString());         Assert.assertEquals("1.", new Dfp(field, 1l).toString());         Assert.assertEquals("-1.", new Dfp(field, -1l).toString());         Assert.assertEquals("1234567890.", new Dfp(field, 1234567890l).toString());         Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890l).toString());         Assert.assertEquals("-9223372036854775808.", new Dfp(field, Long.MIN_VALUE).toString());         Assert.assertEquals("9223372036854775807.", new Dfp(field, Long.MAX_VALUE).toString());     }      /*      *  Test addition      */     @Test     public void testAdd() {         test(field.newDfp("1").add(field.newDfp("1")),      // Basic tests   1+1 = 2              field.newDfp("2"),              0, "Add #1");          test(field.newDfp("1").add(field.newDfp("-1")),     // 1 + (-1) = 0              field.newDfp("0"),              0, "Add #2");          test(field.newDfp("-1").add(field.newDfp("1")),     // (-1) + 1 = 0              field.newDfp("0"),              0, "Add #3");          test(field.newDfp("-1").add(field.newDfp("-1")),     // (-1) + (-1) = -2              field.newDfp("-2"),              0, "Add #4");          // rounding mode is round half even          test(field.newDfp("1").add(field.newDfp("1e-16")),     // rounding on add              field.newDfp("1.0000000000000001"),              0, "Add #5");          test(field.newDfp("1").add(field.newDfp("1e-17")),     // rounding on add              field.newDfp("1"),              DfpField.FLAG_INEXACT, "Add #6");          test(field.newDfp("0.90999999999999999999").add(field.newDfp("0.1")),     // rounding on add              field.newDfp("1.01"),              DfpField.FLAG_INEXACT, "Add #7");          test(field.newDfp(".10000000000000005000").add(field.newDfp(".9")),     // rounding on add              field.newDfp("1."),              DfpField.FLAG_INEXACT, "Add #8");          test(field.newDfp(".10000000000000015000").add(field.newDfp(".9")),     // rounding on add              field.newDfp("1.0000000000000002"),              DfpField.FLAG_INEXACT, "Add #9");          test(field.newDfp(".10000000000000014999").add(field.newDfp(".9")),     // rounding on add              field.newDfp("1.0000000000000001"),              DfpField.FLAG_INEXACT, "Add #10");          test(field.newDfp(".10000000000000015001").add(field.newDfp(".9")),     // rounding on add              field.newDfp("1.0000000000000002"),              DfpField.FLAG_INEXACT, "Add #11");          test(field.newDfp(".11111111111111111111").add(field.newDfp("11.1111111111111111")), // rounding on add              field.newDfp("11.22222222222222222222"),              DfpField.FLAG_INEXACT, "Add #12");          test(field.newDfp(".11111111111111111111").add(field.newDfp("1111111111111111.1111")), // rounding on add              field.newDfp("1111111111111111.2222"),              DfpField.FLAG_INEXACT, "Add #13");          test(field.newDfp(".11111111111111111111").add(field.newDfp("11111111111111111111")), // rounding on add              field.newDfp("11111111111111111111"),              DfpField.FLAG_INEXACT, "Add #14");          test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add              field.newDfp("9.9999999999999999998e131071"),              0, "Add #15");          test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add              pinf,              DfpField.FLAG_OVERFLOW, "Add #16");          test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add              ninf,              DfpField.FLAG_OVERFLOW, "Add #17");          test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add              field.newDfp("-9.9999999999999999998e131071"),              0, "Add #18");          test(field.newDfp("1e-131072").add(field.newDfp("1e-131072")), // underflow on add              field.newDfp("2e-131072"),              0, "Add #19");          test(field.newDfp("1.0000000000000001e-131057").add(field.newDfp("-1e-131057")), // underflow on add              field.newDfp("1e-131073"),              DfpField.FLAG_UNDERFLOW, "Add #20");          test(field.newDfp("1.1e-131072").add(field.newDfp("-1e-131072")), // underflow on add              field.newDfp("1e-131073"),              DfpField.FLAG_UNDERFLOW, "Add #21");          test(field.newDfp("1.0000000000000001e-131072").add(field.newDfp("-1e-131072")), // underflow on add              field.newDfp("1e-131088"),              DfpField.FLAG_UNDERFLOW, "Add #22");          test(field.newDfp("1.0000000000000001e-131078").add(field.newDfp("-1e-131078")), // underflow on add              field.newDfp("0"),              DfpField.FLAG_UNDERFLOW, "Add #23");          test(field.newDfp("1.0").add(field.newDfp("-1e-20")), // loss of precision on alignment?              field.newDfp("0.99999999999999999999"),              0, "Add #23.1");          test(field.newDfp("-0.99999999999999999999").add(field.newDfp("1")), // proper normalization?              field.newDfp("0.00000000000000000001"),              0, "Add #23.2");          test(field.newDfp("1").add(field.newDfp("0")), // adding zeros              field.newDfp("1"),              0, "Add #24");          test(field.newDfp("0").add(field.newDfp("0")), // adding zeros              field.newDfp("0"),              0, "Add #25");          test(field.newDfp("-0").add(field.newDfp("0")), // adding zeros              field.newDfp("0"),              0, "Add #26");          test(field.newDfp("0").add(field.newDfp("-0")), // adding zeros              field.newDfp("0"),              0, "Add #27");          test(field.newDfp("-0").add(field.newDfp("-0")), // adding zeros              field.newDfp("-0"),              0, "Add #28");          test(field.newDfp("1e-20").add(field.newDfp("0")), // adding zeros              field.newDfp("1e-20"),              0, "Add #29");          test(field.newDfp("1e-40").add(field.newDfp("0")), // adding zeros              field.newDfp("1e-40"),              0, "Add #30");          test(pinf.add(ninf), // adding infinities              nan,              DfpField.FLAG_INVALID, "Add #31");          test(ninf.add(pinf), // adding infinities              nan,              DfpField.FLAG_INVALID, "Add #32");          test(ninf.add(ninf), // adding infinities              ninf,              0, "Add #33");          test(pinf.add(pinf), // adding infinities              pinf,              0, "Add #34");          test(pinf.add(field.newDfp("0")), // adding infinities              pinf,              0, "Add #35");          test(pinf.add(field.newDfp("-1e131071")), // adding infinities              pinf,              0, "Add #36");          test(pinf.add(field.newDfp("1e131071")), // adding infinities              pinf,              0, "Add #37");          test(field.newDfp("0").add(pinf), // adding infinities              pinf,              0, "Add #38");          test(field.newDfp("-1e131071").add(pinf), // adding infinities              pinf,              0, "Add #39");          test(field.newDfp("1e131071").add(pinf), // adding infinities              pinf,              0, "Add #40");          test(ninf.add(field.newDfp("0")), // adding infinities              ninf,              0, "Add #41");          test(ninf.add(field.newDfp("-1e131071")), // adding infinities              ninf,              0, "Add #42");          test(ninf.add(field.newDfp("1e131071")), // adding infinities              ninf,              0, "Add #43");          test(field.newDfp("0").add(ninf), // adding infinities              ninf,              0, "Add #44");          test(field.newDfp("-1e131071").add(ninf), // adding infinities              ninf,              0, "Add #45");          test(field.newDfp("1e131071").add(ninf), // adding infinities              ninf,              0, "Add #46");          test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("5e131051")),  // overflow              pinf,              DfpField.FLAG_OVERFLOW, "Add #47");          test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("4.9999999999999999999e131051")),  // overflow              field.newDfp("9.9999999999999999999e131071"),              DfpField.FLAG_INEXACT, "Add #48");          test(nan.add(field.newDfp("1")),              nan,              0, "Add #49");          test(field.newDfp("1").add(nan),              nan,              0, "Add #50");          test(field.newDfp("12345678123456781234").add(field.newDfp("0.12345678123456781234")),              field.newDfp("12345678123456781234"),              DfpField.FLAG_INEXACT, "Add #51");          test(field.newDfp("12345678123456781234").add(field.newDfp("123.45678123456781234")),              field.newDfp("12345678123456781357"),              DfpField.FLAG_INEXACT, "Add #52");          test(field.newDfp("123.45678123456781234").add(field.newDfp("12345678123456781234")),              field.newDfp("12345678123456781357"),              DfpField.FLAG_INEXACT, "Add #53");          test(field.newDfp("12345678123456781234").add(field.newDfp(".00001234567812345678")),              field.newDfp("12345678123456781234"),              DfpField.FLAG_INEXACT, "Add #54");          test(field.newDfp("12345678123456781234").add(field.newDfp(".00000000123456781234")),              field.newDfp("12345678123456781234"),              DfpField.FLAG_INEXACT, "Add #55");          test(field.newDfp("-0").add(field.newDfp("-0")),              field.newDfp("-0"),              0, "Add #56");          test(field.newDfp("0").add(field.newDfp("-0")),              field.newDfp("0"),              0, "Add #57");          test(field.newDfp("-0").add(field.newDfp("0")),              field.newDfp("0"),              0, "Add #58");          test(field.newDfp("0").add(field.newDfp("0")),              field.newDfp("0"),              0, "Add #59");     }      ////////////////////////////////////////////////////////////////////////////////////////////////////////      // Test comparisons      // utility function to help test comparisons     private void cmptst(Dfp a, Dfp b, String op, boolean result, double num) {         if (op == "equal") {             if (a.equals(b) != result) {                 assertionFailOpNum(op, num);             }         }          if (op == "unequal") {             if (a.unequal(b) != result) {                 assertionFailOpNum(op, num);             }         }          if (op == "lessThan") {             if (a.lessThan(b) != result) {                 assertionFailOpNum(op, num);             }         }          if (op == "greaterThan") {             if (a.greaterThan(b) != result) {                 assertionFailOpNum(op, num);             }         }     }      @Test     public void  testCompare() {         // test equal() comparison         // check zero vs. zero         field.clearIEEEFlags();          cmptst(field.newDfp("0"), field.newDfp("0"), "equal", true, 1);         // 0 == 0         cmptst(field.newDfp("0"), field.newDfp("-0"), "equal", true, 2);        // 0 == -0         cmptst(field.newDfp("-0"), field.newDfp("-0"), "equal", true, 3);       // -0 == -0         cmptst(field.newDfp("-0"), field.newDfp("0"), "equal", true, 4);        // -0 == 0          // check zero vs normal numbers          cmptst(field.newDfp("0"), field.newDfp("1"), "equal", false, 5);         // 0 == 1         cmptst(field.newDfp("1"), field.newDfp("0"), "equal", false, 6);         // 1 == 0         cmptst(field.newDfp("-1"), field.newDfp("0"), "equal", false, 7);        // -1 == 0         cmptst(field.newDfp("0"), field.newDfp("-1"), "equal", false, 8);        // 0 == -1         cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "equal", false, 9); // 0 == 1e-131072         // check flags         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "equal", false, 10); // 0 == 1e-131078          // check flags  -- underflow should be set         if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) {             assertionFailDfpField(field);         }          field.clearIEEEFlags();          cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "equal", false, 11); // 0 == 1e+131071          // check zero vs infinities          cmptst(field.newDfp("0"), pinf, "equal", false, 12);    // 0 == pinf         cmptst(field.newDfp("0"), ninf, "equal", false, 13);    // 0 == ninf         cmptst(field.newDfp("-0"), pinf, "equal", false, 14);   // -0 == pinf         cmptst(field.newDfp("-0"), ninf, "equal", false, 15);   // -0 == ninf         cmptst(pinf, field.newDfp("0"), "equal", false, 16);    // pinf == 0         cmptst(ninf, field.newDfp("0"), "equal", false, 17);    // ninf == 0         cmptst(pinf, field.newDfp("-0"), "equal", false, 18);   // pinf == -0         cmptst(ninf, field.newDfp("-0"), "equal", false, 19);   // ninf == -0         cmptst(ninf, pinf, "equal", false, 19.10);     // ninf == pinf         cmptst(pinf, ninf, "equal", false, 19.11);     // pinf == ninf         cmptst(pinf, pinf, "equal", true, 19.12);     // pinf == pinf         cmptst(ninf, ninf, "equal", true, 19.13);     // ninf == ninf          // check some normal numbers         cmptst(field.newDfp("1"), field.newDfp("1"), "equal", true, 20);   // 1 == 1         cmptst(field.newDfp("1"), field.newDfp("-1"), "equal", false, 21);   // 1 == -1         cmptst(field.newDfp("-1"), field.newDfp("-1"), "equal", true, 22);   // -1 == -1         cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "equal", false, 23);   // 1 == 1.0000000000000001          // The tests below checks to ensure that comparisons don't set FLAG_INEXACT         // 100000 == 1.0000000000000001         cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "equal", false, 24);         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "equal", true, 25);          // check some nans -- nans shouldn't equal anything          cmptst(snan, snan, "equal", false, 27);         cmptst(qnan, qnan, "equal", false, 28);         cmptst(snan, qnan, "equal", false, 29);         cmptst(qnan, snan, "equal", false, 30);         cmptst(qnan, field.newDfp("0"), "equal", false, 31);         cmptst(snan, field.newDfp("0"), "equal", false, 32);         cmptst(field.newDfp("0"), snan, "equal", false, 33);         cmptst(field.newDfp("0"), qnan, "equal", false, 34);         cmptst(qnan, pinf, "equal", false, 35);         cmptst(snan, pinf, "equal", false, 36);         cmptst(pinf, snan, "equal", false, 37);         cmptst(pinf, qnan, "equal", false, 38);         cmptst(qnan, ninf, "equal", false, 39);         cmptst(snan, ninf, "equal", false, 40);         cmptst(ninf, snan, "equal", false, 41);         cmptst(ninf, qnan, "equal", false, 42);         cmptst(qnan, field.newDfp("-1"), "equal", false, 43);         cmptst(snan, field.newDfp("-1"), "equal", false, 44);         cmptst(field.newDfp("-1"), snan, "equal", false, 45);         cmptst(field.newDfp("-1"), qnan, "equal", false, 46);         cmptst(qnan, field.newDfp("1"), "equal", false, 47);         cmptst(snan, field.newDfp("1"), "equal", false, 48);         cmptst(field.newDfp("1"), snan, "equal", false, 49);         cmptst(field.newDfp("1"), qnan, "equal", false, 50);         cmptst(snan.negate(), snan, "equal", false, 51);         cmptst(qnan.negate(), qnan, "equal", false, 52);          //         // Tests for un equal  -- do it all over again         //          cmptst(field.newDfp("0"), field.newDfp("0"), "unequal", false, 1);         // 0 == 0         cmptst(field.newDfp("0"), field.newDfp("-0"), "unequal", false, 2);        // 0 == -0         cmptst(field.newDfp("-0"), field.newDfp("-0"), "unequal", false, 3);       // -0 == -0         cmptst(field.newDfp("-0"), field.newDfp("0"), "unequal", false, 4);        // -0 == 0          // check zero vs normal numbers          cmptst(field.newDfp("0"), field.newDfp("1"), "unequal", true, 5);         // 0 == 1         cmptst(field.newDfp("1"), field.newDfp("0"), "unequal", true, 6);         // 1 == 0         cmptst(field.newDfp("-1"), field.newDfp("0"), "unequal", true, 7);        // -1 == 0         cmptst(field.newDfp("0"), field.newDfp("-1"), "unequal", true, 8);        // 0 == -1         cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "unequal", true, 9); // 0 == 1e-131072         // check flags         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "unequal", true, 10); // 0 == 1e-131078          // check flags  -- underflow should be set         if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) {             assertionFailDfpField(field);         }          field.clearIEEEFlags();          cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "unequal", true, 11); // 0 == 1e+131071          // check zero vs infinities          cmptst(field.newDfp("0"), pinf, "unequal", true, 12);    // 0 == pinf         cmptst(field.newDfp("0"), ninf, "unequal", true, 13);    // 0 == ninf         cmptst(field.newDfp("-0"), pinf, "unequal", true, 14);   // -0 == pinf         cmptst(field.newDfp("-0"), ninf, "unequal", true, 15);   // -0 == ninf         cmptst(pinf, field.newDfp("0"), "unequal", true, 16);    // pinf == 0         cmptst(ninf, field.newDfp("0"), "unequal", true, 17);    // ninf == 0         cmptst(pinf, field.newDfp("-0"), "unequal", true, 18);   // pinf == -0         cmptst(ninf, field.newDfp("-0"), "unequal", true, 19);   // ninf == -0         cmptst(ninf, pinf, "unequal", true, 19.10);     // ninf == pinf         cmptst(pinf, ninf, "unequal", true, 19.11);     // pinf == ninf         cmptst(pinf, pinf, "unequal", false, 19.12);     // pinf == pinf         cmptst(ninf, ninf, "unequal", false, 19.13);     // ninf == ninf          // check some normal numbers         cmptst(field.newDfp("1"), field.newDfp("1"), "unequal", false, 20);   // 1 == 1         cmptst(field.newDfp("1"), field.newDfp("-1"), "unequal", true, 21);   // 1 == -1         cmptst(field.newDfp("-1"), field.newDfp("-1"), "unequal", false, 22);   // -1 == -1         cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "unequal", true, 23);   // 1 == 1.0000000000000001          // The tests below checks to ensure that comparisons don't set FLAG_INEXACT         // 100000 == 1.0000000000000001         cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "unequal", true, 24);         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "unequal", false, 25);          // check some nans -- nans shouldn't be unequal to anything          cmptst(snan, snan, "unequal", false, 27);         cmptst(qnan, qnan, "unequal", false, 28);         cmptst(snan, qnan, "unequal", false, 29);         cmptst(qnan, snan, "unequal", false, 30);         cmptst(qnan, field.newDfp("0"), "unequal", false, 31);         cmptst(snan, field.newDfp("0"), "unequal", false, 32);         cmptst(field.newDfp("0"), snan, "unequal", false, 33);         cmptst(field.newDfp("0"), qnan, "unequal", false, 34);         cmptst(qnan, pinf, "unequal", false, 35);         cmptst(snan, pinf, "unequal", false, 36);         cmptst(pinf, snan, "unequal", false, 37);         cmptst(pinf, qnan, "unequal", false, 38);         cmptst(qnan, ninf, "unequal", false, 39);         cmptst(snan, ninf, "unequal", false, 40);         cmptst(ninf, snan, "unequal", false, 41);         cmptst(ninf, qnan, "unequal", false, 42);         cmptst(qnan, field.newDfp("-1"), "unequal", false, 43);         cmptst(snan, field.newDfp("-1"), "unequal", false, 44);         cmptst(field.newDfp("-1"), snan, "unequal", false, 45);         cmptst(field.newDfp("-1"), qnan, "unequal", false, 46);         cmptst(qnan, field.newDfp("1"), "unequal", false, 47);         cmptst(snan, field.newDfp("1"), "unequal", false, 48);         cmptst(field.newDfp("1"), snan, "unequal", false, 49);         cmptst(field.newDfp("1"), qnan, "unequal", false, 50);         cmptst(snan.negate(), snan, "unequal", false, 51);         cmptst(qnan.negate(), qnan, "unequal", false, 52);          if (field.getIEEEFlags() != 0) {             assertionFail("compare unequal flags = "+field.getIEEEFlags());         }          //         // Tests for lessThan  -- do it all over again         //          cmptst(field.newDfp("0"), field.newDfp("0"), "lessThan", false, 1);         // 0 < 0         cmptst(field.newDfp("0"), field.newDfp("-0"), "lessThan", false, 2);        // 0 < -0         cmptst(field.newDfp("-0"), field.newDfp("-0"), "lessThan", false, 3);       // -0 < -0         cmptst(field.newDfp("-0"), field.newDfp("0"), "lessThan", false, 4);        // -0 < 0          // check zero vs normal numbers          cmptst(field.newDfp("0"), field.newDfp("1"), "lessThan", true, 5);         // 0 < 1         cmptst(field.newDfp("1"), field.newDfp("0"), "lessThan", false, 6);         // 1 < 0         cmptst(field.newDfp("-1"), field.newDfp("0"), "lessThan", true, 7);        // -1 < 0         cmptst(field.newDfp("0"), field.newDfp("-1"), "lessThan", false, 8);        // 0 < -1         cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "lessThan", true, 9); // 0 < 1e-131072         // check flags         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "lessThan", true, 10); // 0 < 1e-131078          // check flags  -- underflow should be set         if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) {             assertionFailDfpField(field);         }         field.clearIEEEFlags();          cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "lessThan", true, 11); // 0 < 1e+131071          // check zero vs infinities          cmptst(field.newDfp("0"), pinf, "lessThan", true, 12);    // 0 < pinf         cmptst(field.newDfp("0"), ninf, "lessThan", false, 13);    // 0 < ninf         cmptst(field.newDfp("-0"), pinf, "lessThan", true, 14);   // -0 < pinf         cmptst(field.newDfp("-0"), ninf, "lessThan", false, 15);   // -0 < ninf         cmptst(pinf, field.newDfp("0"), "lessThan", false, 16);    // pinf < 0         cmptst(ninf, field.newDfp("0"), "lessThan", true, 17);    // ninf < 0         cmptst(pinf, field.newDfp("-0"), "lessThan", false, 18);   // pinf < -0         cmptst(ninf, field.newDfp("-0"), "lessThan", true, 19);   // ninf < -0         cmptst(ninf, pinf, "lessThan", true, 19.10);     // ninf < pinf         cmptst(pinf, ninf, "lessThan", false, 19.11);     // pinf < ninf         cmptst(pinf, pinf, "lessThan", false, 19.12);     // pinf < pinf         cmptst(ninf, ninf, "lessThan", false, 19.13);     // ninf < ninf          // check some normal numbers         cmptst(field.newDfp("1"), field.newDfp("1"), "lessThan", false, 20);   // 1 < 1         cmptst(field.newDfp("1"), field.newDfp("-1"), "lessThan", false, 21);   // 1 < -1         cmptst(field.newDfp("-1"), field.newDfp("-1"), "lessThan", false, 22);   // -1 < -1         cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "lessThan", true, 23);   // 1 < 1.0000000000000001          // The tests below checks to ensure that comparisons don't set FLAG_INEXACT         // 100000 < 1.0000000000000001         cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "lessThan", false, 24);         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "lessThan", false, 25);          // check some nans -- nans shouldn't be lessThan to anything         cmptst(snan, snan, "lessThan", false, 27);         cmptst(qnan, qnan, "lessThan", false, 28);         cmptst(snan, qnan, "lessThan", false, 29);         cmptst(qnan, snan, "lessThan", false, 30);         cmptst(qnan, field.newDfp("0"), "lessThan", false, 31);         cmptst(snan, field.newDfp("0"), "lessThan", false, 32);         cmptst(field.newDfp("0"), snan, "lessThan", false, 33);         cmptst(field.newDfp("0"), qnan, "lessThan", false, 34);         cmptst(qnan, pinf, "lessThan", false, 35);         cmptst(snan, pinf, "lessThan", false, 36);         cmptst(pinf, snan, "lessThan", false, 37);         cmptst(pinf, qnan, "lessThan", false, 38);         cmptst(qnan, ninf, "lessThan", false, 39);         cmptst(snan, ninf, "lessThan", false, 40);         cmptst(ninf, snan, "lessThan", false, 41);         cmptst(ninf, qnan, "lessThan", false, 42);         cmptst(qnan, field.newDfp("-1"), "lessThan", false, 43);         cmptst(snan, field.newDfp("-1"), "lessThan", false, 44);         cmptst(field.newDfp("-1"), snan, "lessThan", false, 45);         cmptst(field.newDfp("-1"), qnan, "lessThan", false, 46);         cmptst(qnan, field.newDfp("1"), "lessThan", false, 47);         cmptst(snan, field.newDfp("1"), "lessThan", false, 48);         cmptst(field.newDfp("1"), snan, "lessThan", false, 49);         cmptst(field.newDfp("1"), qnan, "lessThan", false, 50);         cmptst(snan.negate(), snan, "lessThan", false, 51);         cmptst(qnan.negate(), qnan, "lessThan", false, 52);          //lessThan compares with nans should raise FLAG_INVALID         if (field.getIEEEFlags() != DfpField.FLAG_INVALID) {             assertionFail("compare lessThan flags = "+field.getIEEEFlags());         }         field.clearIEEEFlags();          //         // Tests for greaterThan  -- do it all over again         //          cmptst(field.newDfp("0"), field.newDfp("0"), "greaterThan", false, 1);         // 0 > 0         cmptst(field.newDfp("0"), field.newDfp("-0"), "greaterThan", false, 2);        // 0 > -0         cmptst(field.newDfp("-0"), field.newDfp("-0"), "greaterThan", false, 3);       // -0 > -0         cmptst(field.newDfp("-0"), field.newDfp("0"), "greaterThan", false, 4);        // -0 > 0          // check zero vs normal numbers          cmptst(field.newDfp("0"), field.newDfp("1"), "greaterThan", false, 5);         // 0 > 1         cmptst(field.newDfp("1"), field.newDfp("0"), "greaterThan", true, 6);         // 1 > 0         cmptst(field.newDfp("-1"), field.newDfp("0"), "greaterThan", false, 7);        // -1 > 0         cmptst(field.newDfp("0"), field.newDfp("-1"), "greaterThan", true, 8);        // 0 > -1         cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "greaterThan", false, 9); // 0 > 1e-131072         // check flags         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "greaterThan", false, 10); // 0 > 1e-131078          // check flags  -- underflow should be set         if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) {             assertionFailDfpField(field);         }         field.clearIEEEFlags();          cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "greaterThan", false, 11); // 0 > 1e+131071          // check zero vs infinities          cmptst(field.newDfp("0"), pinf, "greaterThan", false, 12);    // 0 > pinf         cmptst(field.newDfp("0"), ninf, "greaterThan", true, 13);    // 0 > ninf         cmptst(field.newDfp("-0"), pinf, "greaterThan", false, 14);   // -0 > pinf         cmptst(field.newDfp("-0"), ninf, "greaterThan", true, 15);   // -0 > ninf         cmptst(pinf, field.newDfp("0"), "greaterThan", true, 16);    // pinf > 0         cmptst(ninf, field.newDfp("0"), "greaterThan", false, 17);    // ninf > 0         cmptst(pinf, field.newDfp("-0"), "greaterThan", true, 18);   // pinf > -0         cmptst(ninf, field.newDfp("-0"), "greaterThan", false, 19);   // ninf > -0         cmptst(ninf, pinf, "greaterThan", false, 19.10);     // ninf > pinf         cmptst(pinf, ninf, "greaterThan", true, 19.11);     // pinf > ninf         cmptst(pinf, pinf, "greaterThan", false, 19.12);     // pinf > pinf         cmptst(ninf, ninf, "greaterThan", false, 19.13);     // ninf > ninf          // check some normal numbers         cmptst(field.newDfp("1"), field.newDfp("1"), "greaterThan", false, 20);   // 1 > 1         cmptst(field.newDfp("1"), field.newDfp("-1"), "greaterThan", true, 21);   // 1 > -1         cmptst(field.newDfp("-1"), field.newDfp("-1"), "greaterThan", false, 22);   // -1 > -1         cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "greaterThan", false, 23);   // 1 > 1.0000000000000001          // The tests below checks to ensure that comparisons don't set FLAG_INEXACT         // 100000 > 1.0000000000000001         cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "greaterThan", true, 24);         if (field.getIEEEFlags() != 0) {             assertionFailDfpField(field);         }          cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "greaterThan", false, 25);          // check some nans -- nans shouldn't be greaterThan to anything         cmptst(snan, snan, "greaterThan", false, 27);         cmptst(qnan, qnan, "greaterThan", false, 28);         cmptst(snan, qnan, "greaterThan", false, 29);         cmptst(qnan, snan, "greaterThan", false, 30);         cmptst(qnan, field.newDfp("0"), "greaterThan", false, 31);         cmptst(snan, field.newDfp("0"), "greaterThan", false, 32);         cmptst(field.newDfp("0"), snan, "greaterThan", false, 33);         cmptst(field.newDfp("0"), qnan, "greaterThan", false, 34);         cmptst(qnan, pinf, "greaterThan", false, 35);         cmptst(snan, pinf, "greaterThan", false, 36);         cmptst(pinf, snan, "greaterThan", false, 37);         cmptst(pinf, qnan, "greaterThan", false, 38);         cmptst(qnan, ninf, "greaterThan", false, 39);         cmptst(snan, ninf, "greaterThan", false, 40);         cmptst(ninf, snan, "greaterThan", false, 41);         cmptst(ninf, qnan, "greaterThan", false, 42);         cmptst(qnan, field.newDfp("-1"), "greaterThan", false, 43);         cmptst(snan, field.newDfp("-1"), "greaterThan", false, 44);         cmptst(field.newDfp("-1"), snan, "greaterThan", false, 45);         cmptst(field.newDfp("-1"), qnan, "greaterThan", false, 46);         cmptst(qnan, field.newDfp("1"), "greaterThan", false, 47);         cmptst(snan, field.newDfp("1"), "greaterThan", false, 48);         cmptst(field.newDfp("1"), snan, "greaterThan", false, 49);         cmptst(field.newDfp("1"), qnan, "greaterThan", false, 50);         cmptst(snan.negate(), snan, "greaterThan", false, 51);         cmptst(qnan.negate(), qnan, "greaterThan", false, 52);          //greaterThan compares with nans should raise FLAG_INVALID         if (field.getIEEEFlags() != DfpField.FLAG_INVALID) {             assertionFail("compare greaterThan flags = "+field.getIEEEFlags());         }         field.clearIEEEFlags();     }      //     // Test multiplication     //     @Test     public void testMultiply() {         test(field.newDfp("1").multiply(field.newDfp("1")),      // Basic tests   1*1 = 1              field.newDfp("1"),              0, "Multiply #1");          test(field.newDfp("1").multiply(1),             // Basic tests   1*1 = 1              field.newDfp("1"),              0, "Multiply #2");          test(field.newDfp("-1").multiply(field.newDfp("1")),     // Basic tests   -1*1 = -1              field.newDfp("-1"),              0, "Multiply #3");          test(field.newDfp("-1").multiply(1),            // Basic tests   -1*1 = -1              field.newDfp("-1"),              0, "Multiply #4");          // basic tests with integers         test(field.newDfp("2").multiply(field.newDfp("3")),              field.newDfp("6"),              0, "Multiply #5");          test(field.newDfp("2").multiply(3),              field.newDfp("6"),              0, "Multiply #6");          test(field.newDfp("-2").multiply(field.newDfp("3")),              field.newDfp("-6"),              0, "Multiply #7");          test(field.newDfp("-2").multiply(3),              field.newDfp("-6"),              0, "Multiply #8");          test(field.newDfp("2").multiply(field.newDfp("-3")),              field.newDfp("-6"),              0, "Multiply #9");          test(field.newDfp("-2").multiply(field.newDfp("-3")),              field.newDfp("6"),              0, "Multiply #10");          //multiply by zero          test(field.newDfp("-2").multiply(field.newDfp("0")),              field.newDfp("-0"),              0, "Multiply #11");          test(field.newDfp("-2").multiply(0),              field.newDfp("-0"),              0, "Multiply #12");          test(field.newDfp("2").multiply(field.newDfp("0")),              field.newDfp("0"),              0, "Multiply #13");          test(field.newDfp("2").multiply(0),              field.newDfp("0"),              0, "Multiply #14");          test(field.newDfp("2").multiply(pinf),              pinf,              0, "Multiply #15");          test(field.newDfp("2").multiply(ninf),              ninf,              0, "Multiply #16");          test(field.newDfp("-2").multiply(pinf),              ninf,              0, "Multiply #17");          test(field.newDfp("-2").multiply(ninf),              pinf,              0, "Multiply #18");          test(ninf.multiply(field.newDfp("-2")),              pinf,              0, "Multiply #18.1");          test(field.newDfp("5e131071").multiply(2),              pinf,              DfpField.FLAG_OVERFLOW, "Multiply #19");          test(field.newDfp("5e131071").multiply(field.newDfp("1.999999999999999")),              field.newDfp("9.9999999999999950000e131071"),              0, "Multiply #20");          test(field.newDfp("-5e131071").multiply(2),              ninf,              DfpField.FLAG_OVERFLOW, "Multiply #22");          test(field.newDfp("-5e131071").multiply(field.newDfp("1.999999999999999")),              field.newDfp("-9.9999999999999950000e131071"),              0, "Multiply #23");          test(field.newDfp("1e-65539").multiply(field.newDfp("1e-65539")),              field.newDfp("1e-131078"),              DfpField.FLAG_UNDERFLOW, "Multiply #24");          test(field.newDfp("1").multiply(nan),              nan,              0, "Multiply #25");          test(nan.multiply(field.newDfp("1")),              nan,              0, "Multiply #26");          test(nan.multiply(pinf),              nan,              0, "Multiply #27");          test(pinf.multiply(nan),              nan,              0, "Multiply #27");          test(pinf.multiply(field.newDfp("0")),              nan,              DfpField.FLAG_INVALID, "Multiply #28");          test(field.newDfp("0").multiply(pinf),              nan,              DfpField.FLAG_INVALID, "Multiply #29");          test(pinf.multiply(pinf),              pinf,              0, "Multiply #30");          test(ninf.multiply(pinf),              ninf,              0, "Multiply #31");          test(pinf.multiply(ninf),              ninf,              0, "Multiply #32");          test(ninf.multiply(ninf),              pinf,              0, "Multiply #33");          test(pinf.multiply(1),              pinf,              0, "Multiply #34");          test(pinf.multiply(0),              nan,              DfpField.FLAG_INVALID, "Multiply #35");          test(nan.multiply(1),              nan,              0, "Multiply #36");          test(field.newDfp("1").multiply(10000),              field.newDfp("10000"),              0, "Multiply #37");          test(field.newDfp("2").multiply(1000000),              field.newDfp("2000000"),              0, "Multiply #38");          test(field.newDfp("1").multiply(-1),              field.newDfp("-1"),              0, "Multiply #39");     }      @Test     public void testDivide() {         test(field.newDfp("1").divide(nan),      // divide by NaN = NaN              nan,              0, "Divide #1");          test(nan.divide(field.newDfp("1")),      // NaN / number = NaN              nan,              0, "Divide #2");          test(pinf.divide(field.newDfp("1")),              pinf,              0, "Divide #3");          test(pinf.divide(field.newDfp("-1")),              ninf,              0, "Divide #4");          test(pinf.divide(pinf),              nan,              DfpField.FLAG_INVALID, "Divide #5");          test(ninf.divide(pinf),              nan,              DfpField.FLAG_INVALID, "Divide #6");          test(pinf.divide(ninf),              nan,              DfpField.FLAG_INVALID, "Divide #7");          test(ninf.divide(ninf),              nan,              DfpField.FLAG_INVALID, "Divide #8");          test(field.newDfp("0").divide(field.newDfp("0")),              nan,              DfpField.FLAG_DIV_ZERO, "Divide #9");          test(field.newDfp("1").divide(field.newDfp("0")),              pinf,              DfpField.FLAG_DIV_ZERO, "Divide #10");          test(field.newDfp("1").divide(field.newDfp("-0")),              ninf,              DfpField.FLAG_DIV_ZERO, "Divide #11");          test(field.newDfp("-1").divide(field.newDfp("0")),              ninf,              DfpField.FLAG_DIV_ZERO, "Divide #12");          test(field.newDfp("-1").divide(field.newDfp("-0")),              pinf,              DfpField.FLAG_DIV_ZERO, "Divide #13");          test(field.newDfp("1").divide(field.newDfp("3")),              field.newDfp("0.33333333333333333333"),              DfpField.FLAG_INEXACT, "Divide #14");          test(field.newDfp("1").divide(field.newDfp("6")),              field.newDfp("0.16666666666666666667"),              DfpField.FLAG_INEXACT, "Divide #15");          test(field.newDfp("10").divide(field.newDfp("6")),              field.newDfp("1.6666666666666667"),              DfpField.FLAG_INEXACT, "Divide #16");          test(field.newDfp("100").divide(field.newDfp("6")),              field.newDfp("16.6666666666666667"),              DfpField.FLAG_INEXACT, "Divide #17");          test(field.newDfp("1000").divide(field.newDfp("6")),              field.newDfp("166.6666666666666667"),              DfpField.FLAG_INEXACT, "Divide #18");          test(field.newDfp("10000").divide(field.newDfp("6")),              field.newDfp("1666.6666666666666667"),              DfpField.FLAG_INEXACT, "Divide #19");          test(field.newDfp("1").divide(field.newDfp("1")),              field.newDfp("1"),              0, "Divide #20");          test(field.newDfp("1").divide(field.newDfp("-1")),              field.newDfp("-1"),              0, "Divide #21");          test(field.newDfp("-1").divide(field.newDfp("1")),              field.newDfp("-1"),              0, "Divide #22");          test(field.newDfp("-1").divide(field.newDfp("-1")),              field.newDfp("1"),              0, "Divide #23");          test(field.newDfp("1e-65539").divide(field.newDfp("1e65539")),              field.newDfp("1e-131078"),              DfpField.FLAG_UNDERFLOW, "Divide #24");          test(field.newDfp("1e65539").divide(field.newDfp("1e-65539")),              pinf,              DfpField.FLAG_OVERFLOW, "Divide #24");          test(field.newDfp("2").divide(field.newDfp("1.5")),     // test trial-divisor too high              field.newDfp("1.3333333333333333"),              DfpField.FLAG_INEXACT, "Divide #25");          test(field.newDfp("2").divide(pinf),              field.newDfp("0"),              0, "Divide #26");          test(field.newDfp("2").divide(ninf),              field.newDfp("-0"),              0, "Divide #27");          test(field.newDfp("0").divide(field.newDfp("1")),              field.newDfp("0"),              0, "Divide #28");     }      @Test     public void testReciprocal() {         test(nan.reciprocal(),              nan,              0, "Reciprocal #1");          test(field.newDfp("0").reciprocal(),              pinf,              DfpField.FLAG_DIV_ZERO, "Reciprocal #2");          test(field.newDfp("-0").reciprocal(),              ninf,              DfpField.FLAG_DIV_ZERO, "Reciprocal #3");          test(field.newDfp("3").reciprocal(),              field.newDfp("0.33333333333333333333"),              DfpField.FLAG_INEXACT, "Reciprocal #4");          test(field.newDfp("6").reciprocal(),              field.newDfp("0.16666666666666666667"),              DfpField.FLAG_INEXACT, "Reciprocal #5");          test(field.newDfp("1").reciprocal(),              field.newDfp("1"),              0, "Reciprocal #6");          test(field.newDfp("-1").reciprocal(),              field.newDfp("-1"),              0, "Reciprocal #7");          test(pinf.reciprocal(),              field.newDfp("0"),              0, "Reciprocal #8");          test(ninf.reciprocal(),              field.newDfp("-0"),              0, "Reciprocal #9");     }      @Test     public void testDivideInt() {         test(nan.divide(1),      // NaN / number = NaN              nan,              0, "DivideInt #1");          test(pinf.divide(1),              pinf,              0, "DivideInt #2");          test(field.newDfp("0").divide(0),              nan,              DfpField.FLAG_DIV_ZERO, "DivideInt #3");          test(field.newDfp("1").divide(0),              pinf,              DfpField.FLAG_DIV_ZERO, "DivideInt #4");          test(field.newDfp("-1").divide(0),              ninf,              DfpField.FLAG_DIV_ZERO, "DivideInt #5");          test(field.newDfp("1").divide(3),              field.newDfp("0.33333333333333333333"),              DfpField.FLAG_INEXACT, "DivideInt #6");          test(field.newDfp("1").divide(6),              field.newDfp("0.16666666666666666667"),              DfpField.FLAG_INEXACT, "DivideInt #7");          test(field.newDfp("10").divide(6),              field.newDfp("1.6666666666666667"),              DfpField.FLAG_INEXACT, "DivideInt #8");          test(field.newDfp("100").divide(6),              field.newDfp("16.6666666666666667"),              DfpField.FLAG_INEXACT, "DivideInt #9");          test(field.newDfp("1000").divide(6),              field.newDfp("166.6666666666666667"),              DfpField.FLAG_INEXACT, "DivideInt #10");          test(field.newDfp("10000").divide(6),              field.newDfp("1666.6666666666666667"),              DfpField.FLAG_INEXACT, "DivideInt #20");          test(field.newDfp("1").divide(1),              field.newDfp("1"),              0, "DivideInt #21");          test(field.newDfp("1e-131077").divide(10),              field.newDfp("1e-131078"),              DfpField.FLAG_UNDERFLOW, "DivideInt #22");          test(field.newDfp("0").divide(1),              field.newDfp("0"),              0, "DivideInt #23");          test(field.newDfp("1").divide(10000),              nan,              DfpField.FLAG_INVALID, "DivideInt #24");          test(field.newDfp("1").divide(-1),              nan,              DfpField.FLAG_INVALID, "DivideInt #25");     }      @Test     public void testNextAfter() {         test(field.newDfp("1").nextAfter(pinf),              field.newDfp("1.0000000000000001"),              0, "NextAfter #1");          test(field.newDfp("1.0000000000000001").nextAfter(ninf),              field.newDfp("1"),              0, "NextAfter #1.5");          test(field.newDfp("1").nextAfter(ninf),              field.newDfp("0.99999999999999999999"),              0, "NextAfter #2");          test(field.newDfp("0.99999999999999999999").nextAfter(field.newDfp("2")),              field.newDfp("1"),              0, "NextAfter #3");          test(field.newDfp("-1").nextAfter(ninf),              field.newDfp("-1.0000000000000001"),              0, "NextAfter #4");          test(field.newDfp("-1").nextAfter(pinf),              field.newDfp("-0.99999999999999999999"),              0, "NextAfter #5");          test(field.newDfp("-0.99999999999999999999").nextAfter(field.newDfp("-2")),              field.newDfp("-1"),              0, "NextAfter #6");          test(field.newDfp("2").nextAfter(field.newDfp("2")),              field.newDfp("2"),              0, "NextAfter #7");          test(field.newDfp("0").nextAfter(field.newDfp("0")),              field.newDfp("0"),              0, "NextAfter #8");          test(field.newDfp("-2").nextAfter(field.newDfp("-2")),              field.newDfp("-2"),              0, "NextAfter #9");          test(field.newDfp("0").nextAfter(field.newDfp("1")),              field.newDfp("1e-131092"),              DfpField.FLAG_UNDERFLOW, "NextAfter #10");          test(field.newDfp("0").nextAfter(field.newDfp("-1")),              field.newDfp("-1e-131092"),              DfpField.FLAG_UNDERFLOW, "NextAfter #11");          test(field.newDfp("-1e-131092").nextAfter(pinf),              field.newDfp("-0"),              DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12");          test(field.newDfp("1e-131092").nextAfter(ninf),              field.newDfp("0"),              DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13");          test(field.newDfp("9.9999999999999999999e131078").nextAfter(pinf),              pinf,              DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14");     }      @Test     public void testToString() {         Assert.assertEquals("toString #1", "Infinity", pinf.toString());         Assert.assertEquals("toString #2", "-Infinity", ninf.toString());         Assert.assertEquals("toString #3", "NaN", nan.toString());         Assert.assertEquals("toString #4", "NaN", field.newDfp((byte) 1, Dfp.QNAN).toString());         Assert.assertEquals("toString #5", "NaN", field.newDfp((byte) 1, Dfp.SNAN).toString());         Assert.assertEquals("toString #6", "1.2300000000000000e100", field.newDfp("1.23e100").toString());         Assert.assertEquals("toString #7", "-1.2300000000000000e100", field.newDfp("-1.23e100").toString());         Assert.assertEquals("toString #8", "12345678.1234", field.newDfp("12345678.1234").toString());         Assert.assertEquals("toString #9", "0.00001234", field.newDfp("0.00001234").toString());     }      @Override     @Test     public void testRound() {         field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);          // Round down         test(field.newDfp("12345678901234567890").add(field.newDfp("0.9")),              field.newDfp("12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #1");          test(field.newDfp("12345678901234567890").add(field.newDfp("0.99999999")),              field.newDfp("12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #2");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.99999999")),              field.newDfp("-12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #3");          field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);          // Round up         test(field.newDfp("12345678901234567890").add(field.newDfp("0.1")),              field.newDfp("12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #4");          test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),              field.newDfp("12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #5");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.1")),              field.newDfp("-12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #6");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),              field.newDfp("-12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #7");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);          // Round half up         test(field.newDfp("12345678901234567890").add(field.newDfp("0.4999")),              field.newDfp("12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #8");          test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),              field.newDfp("12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #9");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.4999")),              field.newDfp("-12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #10");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),              field.newDfp("-12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #11");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);          // Round half down         test(field.newDfp("12345678901234567890").add(field.newDfp("0.5001")),              field.newDfp("12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #12");          test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),              field.newDfp("12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #13");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5001")),              field.newDfp("-12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #14");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),              field.newDfp("-12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #15");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);          // Round half odd         test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),              field.newDfp("12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #16");          test(field.newDfp("12345678901234567891").add(field.newDfp("0.5000")),              field.newDfp("12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #17");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),              field.newDfp("-12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #18");          test(field.newDfp("-12345678901234567891").add(field.newDfp("-0.5000")),              field.newDfp("-12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #19");          field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);          // Round ceil         test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),              field.newDfp("12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #20");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.9999")),              field.newDfp("-12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #21");          field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);          // Round floor         test(field.newDfp("12345678901234567890").add(field.newDfp("0.9999")),              field.newDfp("12345678901234567890"),              DfpField.FLAG_INEXACT, "Round #22");          test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),              field.newDfp("-12345678901234567891"),              DfpField.FLAG_INEXACT, "Round #23");          field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset     }      @Override     @Test     public void testCeil()  {         test(field.newDfp("1234.0000000000000001").ceil(),              field.newDfp("1235"),              DfpField.FLAG_INEXACT, "Ceil #1");     }      @Override     @Test     public void testFloor() {         test(field.newDfp("1234.9999999999999999").floor(),              field.newDfp("1234"),              DfpField.FLAG_INEXACT, "Floor #1");     }      @Override     @Test     public void testRint() {         test(field.newDfp("1234.50000000001").rint(),              field.newDfp("1235"),              DfpField.FLAG_INEXACT, "Rint #1");          test(field.newDfp("1234.5000").rint(),              field.newDfp("1234"),              DfpField.FLAG_INEXACT, "Rint #2");          test(field.newDfp("1235.5000").rint(),              field.newDfp("1236"),              DfpField.FLAG_INEXACT, "Rint #3");     }      @Test     public void testCopySign() {         test(Dfp.copysign(field.newDfp("1234."), field.newDfp("-1")),              field.newDfp("-1234"),              0, "CopySign #1");          test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("-1")),              field.newDfp("-1234"),              0, "CopySign #2");          test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("1")),              field.newDfp("1234"),              0, "CopySign #3");          test(Dfp.copysign(field.newDfp("1234."), field.newDfp("1")),              field.newDfp("1234"),              0, "CopySign #4");     }      @Test     public void testIntValue() {         Assert.assertEquals("intValue #1", 1234, field.newDfp("1234").intValue());         Assert.assertEquals("intValue #2", -1234, field.newDfp("-1234").intValue());         Assert.assertEquals("intValue #3", 1234, field.newDfp("1234.5").intValue());         Assert.assertEquals("intValue #4", 1235, field.newDfp("1234.500001").intValue());         Assert.assertEquals("intValue #5", 2147483647, field.newDfp("1e1000").intValue());         Assert.assertEquals("intValue #6", -2147483648, field.newDfp("-1e1000").intValue());     }      @Test     public void testLog10K() {         Assert.assertEquals("log10K #1", 1, field.newDfp("123456").log10K());         Assert.assertEquals("log10K #2", 2, field.newDfp("123456789").log10K());         Assert.assertEquals("log10K #3", 0, field.newDfp("2").log10K());         Assert.assertEquals("log10K #3", 0, field.newDfp("1").log10K());         Assert.assertEquals("log10K #4", -1, field.newDfp("0.1").log10K());     }      @Test     public void testPower10K() {         Dfp d = field.newDfp();          test(d.power10K(0), field.newDfp("1"), 0, "Power10 #1");         test(d.power10K(1), field.newDfp("10000"), 0, "Power10 #2");         test(d.power10K(2), field.newDfp("100000000"), 0, "Power10 #3");          test(d.power10K(-1), field.newDfp("0.0001"), 0, "Power10 #4");         test(d.power10K(-2), field.newDfp("0.00000001"), 0, "Power10 #5");         test(d.power10K(-3), field.newDfp("0.000000000001"), 0, "Power10 #6");     }      @Test     public void testLog10() {         Assert.assertEquals("log10 #1", 1, field.newDfp("12").intLog10());         Assert.assertEquals("log10 #2", 2, field.newDfp("123").intLog10());         Assert.assertEquals("log10 #3", 3, field.newDfp("1234").intLog10());         Assert.assertEquals("log10 #4", 4, field.newDfp("12345").intLog10());         Assert.assertEquals("log10 #5", 5, field.newDfp("123456").intLog10());         Assert.assertEquals("log10 #6", 6, field.newDfp("1234567").intLog10());         Assert.assertEquals("log10 #6", 7, field.newDfp("12345678").intLog10());         Assert.assertEquals("log10 #7", 8, field.newDfp("123456789").intLog10());         Assert.assertEquals("log10 #8", 9, field.newDfp("1234567890").intLog10());         Assert.assertEquals("log10 #9", 10, field.newDfp("12345678901").intLog10());         Assert.assertEquals("log10 #10", 11, field.newDfp("123456789012").intLog10());         Assert.assertEquals("log10 #11", 12, field.newDfp("1234567890123").intLog10());          Assert.assertEquals("log10 #12", 0, field.newDfp("2").intLog10());         Assert.assertEquals("log10 #13", 0, field.newDfp("1").intLog10());         Assert.assertEquals("log10 #14", -1, field.newDfp("0.12").intLog10());         Assert.assertEquals("log10 #15", -2, field.newDfp("0.012").intLog10());     }      @Test     public void testPower10() {         Dfp d = field.newDfp();          test(d.power10(0), field.newDfp("1"), 0, "Power10 #1");         test(d.power10(1), field.newDfp("10"), 0, "Power10 #2");         test(d.power10(2), field.newDfp("100"), 0, "Power10 #3");         test(d.power10(3), field.newDfp("1000"), 0, "Power10 #4");         test(d.power10(4), field.newDfp("10000"), 0, "Power10 #5");         test(d.power10(5), field.newDfp("100000"), 0, "Power10 #6");         test(d.power10(6), field.newDfp("1000000"), 0, "Power10 #7");         test(d.power10(7), field.newDfp("10000000"), 0, "Power10 #8");         test(d.power10(8), field.newDfp("100000000"), 0, "Power10 #9");         test(d.power10(9), field.newDfp("1000000000"), 0, "Power10 #10");          test(d.power10(-1), field.newDfp(".1"), 0, "Power10 #11");         test(d.power10(-2), field.newDfp(".01"), 0, "Power10 #12");         test(d.power10(-3), field.newDfp(".001"), 0, "Power10 #13");         test(d.power10(-4), field.newDfp(".0001"), 0, "Power10 #14");         test(d.power10(-5), field.newDfp(".00001"), 0, "Power10 #15");         test(d.power10(-6), field.newDfp(".000001"), 0, "Power10 #16");         test(d.power10(-7), field.newDfp(".0000001"), 0, "Power10 #17");         test(d.power10(-8), field.newDfp(".00000001"), 0, "Power10 #18");         test(d.power10(-9), field.newDfp(".000000001"), 0, "Power10 #19");         test(d.power10(-10), field.newDfp(".0000000001"), 0, "Power10 #20");     }      @Test     public void testRemainder() {         test(field.newDfp("10").remainder(field.newDfp("3")),              field.newDfp("1"),              DfpField.FLAG_INEXACT, "Remainder #1");          test(field.newDfp("9").remainder(field.newDfp("3")),              field.newDfp("0"),              0, "Remainder #2");          test(field.newDfp("-9").remainder(field.newDfp("3")),              field.newDfp("-0"),              0, "Remainder #3");     }      @Override     @Test     public void testSqrt() {         test(field.newDfp("0").sqrt(),              field.newDfp("0"),              0, "Sqrt #1");          test(field.newDfp("-0").sqrt(),              field.newDfp("-0"),              0, "Sqrt #2");          test(field.newDfp("1").sqrt(),              field.newDfp("1"),              0, "Sqrt #3");          test(field.newDfp("2").sqrt(),              field.newDfp("1.4142135623730950"),              DfpField.FLAG_INEXACT, "Sqrt #4");          test(field.newDfp("3").sqrt(),              field.newDfp("1.7320508075688773"),              DfpField.FLAG_INEXACT, "Sqrt #5");          test(field.newDfp("5").sqrt(),              field.newDfp("2.2360679774997897"),              DfpField.FLAG_INEXACT, "Sqrt #6");          test(field.newDfp("500").sqrt(),              field.newDfp("22.3606797749978970"),              DfpField.FLAG_INEXACT, "Sqrt #6.2");          test(field.newDfp("50000").sqrt(),              field.newDfp("223.6067977499789696"),              DfpField.FLAG_INEXACT, "Sqrt #6.3");          test(field.newDfp("-1").sqrt(),              nan,              DfpField.FLAG_INVALID, "Sqrt #7");          test(pinf.sqrt(),              pinf,              0, "Sqrt #8");          test(field.newDfp((byte) 1, Dfp.QNAN).sqrt(),              nan,              0, "Sqrt #9");          test(field.newDfp((byte) 1, Dfp.SNAN).sqrt(),              nan,              DfpField.FLAG_INVALID, "Sqrt #9");     }      @Test     public void testIssue567() {         DfpField field = new DfpField(100);         Assert.assertEquals(0.0, field.getZero().toDouble(), Precision.SAFE_MIN);         Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), Precision.SAFE_MIN);         Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), Precision.EPSILON);         Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), Precision.EPSILON);     }      @Test     public void testIsZero() {         Assert.assertTrue(field.getZero().isZero());         Assert.assertTrue(field.getZero().negate().isZero());         Assert.assertTrue(field.newDfp(+0.0).isZero());         Assert.assertTrue(field.newDfp(-0.0).isZero());         Assert.assertFalse(field.newDfp(1.0e-90).isZero());         Assert.assertFalse(nan.isZero());         Assert.assertFalse(nan.negate().isZero());         Assert.assertFalse(pinf.isZero());         Assert.assertFalse(pinf.negate().isZero());         Assert.assertFalse(ninf.isZero());         Assert.assertFalse(ninf.negate().isZero());     }      @Test     public void testSignPredicates() {          Assert.assertTrue(field.getZero().negativeOrNull());         Assert.assertTrue(field.getZero().positiveOrNull());         Assert.assertFalse(field.getZero().strictlyNegative());         Assert.assertFalse(field.getZero().strictlyPositive());          Assert.assertTrue(field.getZero().negate().negativeOrNull());         Assert.assertTrue(field.getZero().negate().positiveOrNull());         Assert.assertFalse(field.getZero().negate().strictlyNegative());         Assert.assertFalse(field.getZero().negate().strictlyPositive());          Assert.assertFalse(field.getOne().negativeOrNull());         Assert.assertTrue(field.getOne().positiveOrNull());         Assert.assertFalse(field.getOne().strictlyNegative());         Assert.assertTrue(field.getOne().strictlyPositive());          Assert.assertTrue(field.getOne().negate().negativeOrNull());         Assert.assertFalse(field.getOne().negate().positiveOrNull());         Assert.assertTrue(field.getOne().negate().strictlyNegative());         Assert.assertFalse(field.getOne().negate().strictlyPositive());          Assert.assertFalse(nan.negativeOrNull());         Assert.assertFalse(nan.positiveOrNull());         Assert.assertFalse(nan.strictlyNegative());         Assert.assertFalse(nan.strictlyPositive());          Assert.assertFalse(nan.negate().negativeOrNull());         Assert.assertFalse(nan.negate().positiveOrNull());         Assert.assertFalse(nan.negate().strictlyNegative());         Assert.assertFalse(nan.negate().strictlyPositive());          Assert.assertFalse(pinf.negativeOrNull());         Assert.assertTrue(pinf.positiveOrNull());         Assert.assertFalse(pinf.strictlyNegative());         Assert.assertTrue(pinf.strictlyPositive());          Assert.assertTrue(pinf.negate().negativeOrNull());         Assert.assertFalse(pinf.negate().positiveOrNull());         Assert.assertTrue(pinf.negate().strictlyNegative());         Assert.assertFalse(pinf.negate().strictlyPositive());          Assert.assertTrue(ninf.negativeOrNull());         Assert.assertFalse(ninf.positiveOrNull());         Assert.assertTrue(ninf.strictlyNegative());         Assert.assertFalse(ninf.strictlyPositive());          Assert.assertFalse(ninf.negate().negativeOrNull());         Assert.assertTrue(ninf.negate().positiveOrNull());         Assert.assertFalse(ninf.negate().strictlyNegative());         Assert.assertTrue(ninf.negate().strictlyPositive());      }      @Test     public void testSpecialConstructors() {         Assert.assertEquals(ninf, field.newDfp(Double.NEGATIVE_INFINITY));         Assert.assertEquals(ninf, field.newDfp("-Infinity"));         Assert.assertEquals(pinf, field.newDfp(Double.POSITIVE_INFINITY));         Assert.assertEquals(pinf, field.newDfp("Infinity"));         Assert.assertTrue(field.newDfp(Double.NaN).isNaN());         Assert.assertTrue(field.newDfp("NaN").isNaN());     }      @Test     public void testEqualsHashcodeContract() {         DfpField var1 = new DfpField(1);         Dfp var6 = var1.newDfp(-0.0d);         Dfp var5 = var1.newDfp(0L);          // Checks the contract:  equals-hashcode on var5 and var6         Assert.assertTrue(var5.equals(var6) ? var5.hashCode() == var6.hashCode() : true);     }      private static void assertionFail(String content){         Assert.fail("assertion failed: " + content);     }      private static void assertionFailOpNum(String op, double num){         assertionFail(op + " compare #" + num);     }      private static final void assertionFailDfpField(DfpField field){         assertionFail("compare flags = " + field.getIEEEFlags());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.dfp;  import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class DfpMathTest {      private DfpField factory;     private Dfp pinf;     private Dfp ninf;     private Dfp nan;     private Dfp qnan;      @Before     public void setUp() {         // Some basic setup.  Define some constants and clear the status flags         factory = new DfpField(20);         pinf = factory.newDfp("1").divide(factory.newDfp("0"));         ninf = factory.newDfp("-1").divide(factory.newDfp("0"));         nan = factory.newDfp("0").divide(factory.newDfp("0"));         qnan = factory.newDfp((byte)1, Dfp.QNAN);         ninf.getField().clearIEEEFlags();          // force loading of dfpmath         Dfp pi = factory.getPi();         pi.getField().clearIEEEFlags();     }      @After     public void tearDown() {         pinf = null;         ninf = null;         nan  = null;         qnan = null;     }      // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.     // If the test fail, it prints the desc string     private void test(Dfp x, Dfp y, int flags, String desc)     {         boolean b = x.equals(y);          if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));          if (x.equals(factory.newDfp("0")))  // distinguish +/- zero             b = (b && (x.toString().equals(y.toString())));          b = (b && x.getField().getIEEEFlags() == flags);          if (!b) {             Assert.assertTrue("assertion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);         }          x.getField().clearIEEEFlags();     }      @Test     public void testPow()     {         // Test special cases  exponent of zero         test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("0")),              factory.newDfp("1"),              0, "pow #1");          test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-0")),              factory.newDfp("1"),              0, "pow #2");          test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("0")),              factory.newDfp("1"),              0, "pow #3");          test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-0")),              factory.newDfp("1"),              0, "pow #4");          test(DfpMath.pow(pinf, factory.newDfp("-0")),              factory.newDfp("1"),              0, "pow #5");          test(DfpMath.pow(pinf, factory.newDfp("0")),              factory.newDfp("1"),              0, "pow #6");          test(DfpMath.pow(ninf, factory.newDfp("-0")),              factory.newDfp("1"),              0, "pow #7");          test(DfpMath.pow(ninf, factory.newDfp("0")),              factory.newDfp("1"),              0, "pow #8");          test(DfpMath.pow(qnan, factory.newDfp("0")),              factory.newDfp("1"),              0, "pow #8");          // exponent of one         test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")),              factory.newDfp("0"),              0, "pow #9");          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1")),              factory.newDfp("-0"),              0, "pow #10");          test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("1")),              factory.newDfp("2"),              0, "pow #11");          test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("1")),              factory.newDfp("-2"),              0, "pow #12");          test(DfpMath.pow(pinf, factory.newDfp("1")),              pinf,              0, "pow #13");          test(DfpMath.pow(ninf, factory.newDfp("1")),              ninf,              0, "pow #14");          test(DfpMath.pow(qnan, factory.newDfp("1")),              qnan,              DfpField.FLAG_INVALID, "pow #14.1");          // exponent of NaN         test(DfpMath.pow(factory.newDfp("0"), qnan),              qnan,              DfpField.FLAG_INVALID, "pow #15");          test(DfpMath.pow(factory.newDfp("-0"), qnan),              qnan,              DfpField.FLAG_INVALID, "pow #16");          test(DfpMath.pow(factory.newDfp("2"), qnan),              qnan,              DfpField.FLAG_INVALID, "pow #17");          test(DfpMath.pow(factory.newDfp("-2"), qnan),              qnan,              DfpField.FLAG_INVALID, "pow #18");          test(DfpMath.pow(pinf, qnan),              qnan,              DfpField.FLAG_INVALID, "pow #19");          test(DfpMath.pow(ninf, qnan),              qnan,              DfpField.FLAG_INVALID, "pow #20");          test(DfpMath.pow(qnan, qnan),              qnan,              DfpField.FLAG_INVALID, "pow #21");          // radix of NaN         test(DfpMath.pow(qnan, factory.newDfp("1")),              qnan,              DfpField.FLAG_INVALID, "pow #22");          test(DfpMath.pow(qnan, factory.newDfp("-1")),              qnan,              DfpField.FLAG_INVALID, "pow #23");          test(DfpMath.pow(qnan, pinf),              qnan,              DfpField.FLAG_INVALID, "pow #24");          test(DfpMath.pow(qnan, ninf),              qnan,              DfpField.FLAG_INVALID, "pow #25");          test(DfpMath.pow(qnan, qnan),              qnan,              DfpField.FLAG_INVALID, "pow #26");          // (x > 1) ^ pinf = pinf,    (x < -1) ^ pinf = pinf         test(DfpMath.pow(factory.newDfp("2"), pinf),              pinf,              0, "pow #27");          test(DfpMath.pow(factory.newDfp("-2"), pinf),              pinf,              0, "pow #28");          test(DfpMath.pow(pinf, pinf),              pinf,              0, "pow #29");          test(DfpMath.pow(ninf, pinf),              pinf,              0, "pow #30");          // (x > 1) ^ ninf = +0,    (x < -1) ^ ninf = +0         test(DfpMath.pow(factory.newDfp("2"), ninf),              factory.getZero(),              0, "pow #31");          test(DfpMath.pow(factory.newDfp("-2"), ninf),              factory.getZero(),              0, "pow #32");          test(DfpMath.pow(pinf, ninf),              factory.getZero(),              0, "pow #33");          test(DfpMath.pow(ninf, ninf),              factory.getZero(),              0, "pow #34");          // (-1 < x < 1) ^ pinf = 0         test(DfpMath.pow(factory.newDfp("0.5"), pinf),              factory.getZero(),              0, "pow #35");          test(DfpMath.pow(factory.newDfp("-0.5"), pinf),              factory.getZero(),              0, "pow #36");          // (-1 < x < 1) ^ ninf = pinf         test(DfpMath.pow(factory.newDfp("0.5"), ninf),              pinf,              0, "pow #37");          test(DfpMath.pow(factory.newDfp("-0.5"), ninf),              pinf,              0, "pow #38");          // +/- 1  ^ +/-inf  = NaN         test(DfpMath.pow(factory.getOne(), pinf),              qnan,              DfpField.FLAG_INVALID, "pow #39");          test(DfpMath.pow(factory.getOne(), ninf),              qnan,              DfpField.FLAG_INVALID, "pow #40");          test(DfpMath.pow(factory.newDfp("-1"), pinf),              qnan,              DfpField.FLAG_INVALID, "pow #41");          test(DfpMath.pow(factory.getOne().negate(), ninf),              qnan,              DfpField.FLAG_INVALID, "pow #42");          // +0  ^ +anything except 0, NAN  = +0          test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")),              factory.newDfp("0"),              0, "pow #43");          test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e30")),              factory.newDfp("0"),              0, "pow #44");          test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e-30")),              factory.newDfp("0"),              0, "pow #45");          test(DfpMath.pow(factory.newDfp("0"), pinf),              factory.newDfp("0"),              0, "pow #46");          // -0  ^ +anything except 0, NAN, odd integer  = +0          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("2")),              factory.newDfp("0"),              0, "pow #47");          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e30")),              factory.newDfp("0"),              0, "pow #48");          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e-30")),              factory.newDfp("0"),              DfpField.FLAG_INEXACT, "pow #49");          test(DfpMath.pow(factory.newDfp("-0"), pinf),              factory.newDfp("0"),              0, "pow #50");          // +0  ^ -anything except 0, NAN  = +INF          test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1")),              pinf,              0, "pow #51");          test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e30")),              pinf,              0, "pow #52");          test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e-30")),              pinf,              0, "pow #53");          test(DfpMath.pow(factory.newDfp("0"), ninf),              pinf,              0, "pow #54");          // -0  ^ -anything except 0, NAN, odd integer  = +INF          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-2")),              pinf,              0, "pow #55");          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e30")),              pinf,              0, "pow #56");          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e-30")),              pinf,              DfpField.FLAG_INEXACT, "pow #57");          test(DfpMath.pow(factory.newDfp("-0"), ninf),              pinf,              0, "pow #58");          // -0  ^ -odd integer   =  -INF         test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1")),              ninf,              DfpField.FLAG_INEXACT, "pow #59");          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-12345")),              ninf,              DfpField.FLAG_INEXACT, "pow #60");          // -0  ^ +odd integer   =  -0         test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("3")),              factory.newDfp("-0"),              DfpField.FLAG_INEXACT, "pow #61");          test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("12345")),              factory.newDfp("-0"),              DfpField.FLAG_INEXACT, "pow #62");          // pinf  ^ +anything   = pinf         test(DfpMath.pow(pinf, factory.newDfp("3")),              pinf,              0, "pow #63");          test(DfpMath.pow(pinf, factory.newDfp("1e30")),              pinf,              0, "pow #64");          test(DfpMath.pow(pinf, factory.newDfp("1e-30")),              pinf,              0, "pow #65");          test(DfpMath.pow(pinf, pinf),              pinf,              0, "pow #66");          // pinf  ^ -anything   = +0          test(DfpMath.pow(pinf, factory.newDfp("-3")),              factory.getZero(),              0, "pow #67");          test(DfpMath.pow(pinf, factory.newDfp("-1e30")),              factory.getZero(),              0, "pow #68");          test(DfpMath.pow(pinf, factory.newDfp("-1e-30")),              factory.getZero(),              0, "pow #69");          test(DfpMath.pow(pinf, ninf),              factory.getZero(),              0, "pow #70");          // ninf  ^ anything   = -0 ^ -anything         // ninf  ^ -anything except 0, NAN, odd integer  = +0          test(DfpMath.pow(ninf, factory.newDfp("-2")),              factory.newDfp("0"),              0, "pow #71");          test(DfpMath.pow(ninf, factory.newDfp("-1e30")),              factory.newDfp("0"),              0, "pow #72");          test(DfpMath.pow(ninf, factory.newDfp("-1e-30")),              factory.newDfp("0"),              DfpField.FLAG_INEXACT, "pow #73");          test(DfpMath.pow(ninf, ninf),              factory.newDfp("0"),              0, "pow #74");          // ninf  ^ +anything except 0, NAN, odd integer  = +INF          test(DfpMath.pow(ninf, factory.newDfp("2")),              pinf,              0, "pow #75");          test(DfpMath.pow(ninf, factory.newDfp("1e30")),              pinf,              0, "pow #76");          test(DfpMath.pow(ninf, factory.newDfp("1e-30")),              pinf,              DfpField.FLAG_INEXACT, "pow #77");          test(DfpMath.pow(ninf, pinf),              pinf,              0, "pow #78");          // ninf  ^ +odd integer   =  -INF         test(DfpMath.pow(ninf, factory.newDfp("3")),              ninf,              DfpField.FLAG_INEXACT, "pow #79");          test(DfpMath.pow(ninf, factory.newDfp("12345")),              ninf,              DfpField.FLAG_INEXACT, "pow #80");          // ninf  ^ -odd integer   =  -0         test(DfpMath.pow(ninf, factory.newDfp("-3")),              factory.newDfp("-0"),              DfpField.FLAG_INEXACT, "pow #81");          test(DfpMath.pow(ninf, factory.newDfp("-12345")),              factory.newDfp("-0"),              DfpField.FLAG_INEXACT, "pow #82");          // -anything ^ integer         test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("3")),              factory.newDfp("-8"),              DfpField.FLAG_INEXACT, "pow #83");          test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("16")),              factory.newDfp("65536"),              0, "pow #84");          test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-3")),              factory.newDfp("-0.125"),              DfpField.FLAG_INEXACT, "pow #85");          test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4")),              factory.newDfp("0.0625"),              0, "pow #86");          // -anything ^ noninteger = NaN          test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4.1")),              qnan,              DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "pow #87");          // Some fractional cases.         test(DfpMath.pow(factory.newDfp("2"),factory.newDfp("1.5")),              factory.newDfp("2.8284271247461901"),              DfpField.FLAG_INEXACT, "pow #88");     }      @Test     public void testSin()     {         test(DfpMath.sin(pinf),              nan,              DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #1");          test(DfpMath.sin(nan),              nan,              DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #2");          test(DfpMath.sin(factory.getZero()),              factory.getZero(),              DfpField.FLAG_INEXACT, "sin #3");          test(DfpMath.sin(factory.getPi()),              factory.getZero(),              DfpField.FLAG_INEXACT, "sin #4");          test(DfpMath.sin(factory.getPi().negate()),              factory.newDfp("-0"),              DfpField.FLAG_INEXACT, "sin #5");          test(DfpMath.sin(factory.getPi().multiply(2)),              factory.getZero(),              DfpField.FLAG_INEXACT, "sin #6");          test(DfpMath.sin(factory.getPi().divide(2)),              factory.getOne(),              DfpField.FLAG_INEXACT, "sin #7");          test(DfpMath.sin(factory.getPi().divide(2).negate()),              factory.getOne().negate(),              DfpField.FLAG_INEXACT, "sin #8");          test(DfpMath.sin(DfpMath.atan(factory.getOne())),  // pi/4              factory.newDfp("0.5").sqrt(),              DfpField.FLAG_INEXACT, "sin #9");          test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4              factory.newDfp("0.5").sqrt().negate(),              DfpField.FLAG_INEXACT, "sin #10");          test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4              factory.newDfp("0.5").sqrt().negate(),              DfpField.FLAG_INEXACT, "sin #11");          test(DfpMath.sin(factory.newDfp("0.1")),              factory.newDfp("0.0998334166468281523"),              DfpField.FLAG_INEXACT, "sin #12");          test(DfpMath.sin(factory.newDfp("0.2")),              factory.newDfp("0.19866933079506121546"),              DfpField.FLAG_INEXACT, "sin #13");          test(DfpMath.sin(factory.newDfp("0.3")),              factory.newDfp("0.2955202066613395751"),              DfpField.FLAG_INEXACT, "sin #14");          test(DfpMath.sin(factory.newDfp("0.4")),              factory.newDfp("0.38941834230865049166"),              DfpField.FLAG_INEXACT, "sin #15");          test(DfpMath.sin(factory.newDfp("0.5")),              factory.newDfp("0.47942553860420300026"),  // off by one ULP              DfpField.FLAG_INEXACT, "sin #16");          test(DfpMath.sin(factory.newDfp("0.6")),              factory.newDfp("0.56464247339503535721"),  // off by one ULP              DfpField.FLAG_INEXACT, "sin #17");          test(DfpMath.sin(factory.newDfp("0.7")),              factory.newDfp("0.64421768723769105367"),              DfpField.FLAG_INEXACT, "sin #18");          test(DfpMath.sin(factory.newDfp("0.8")),              factory.newDfp("0.71735609089952276163"),              DfpField.FLAG_INEXACT, "sin #19");          test(DfpMath.sin(factory.newDfp("0.9")),        // off by one ULP              factory.newDfp("0.78332690962748338847"),              DfpField.FLAG_INEXACT, "sin #20");          test(DfpMath.sin(factory.newDfp("1.0")),              factory.newDfp("0.84147098480789650666"),              DfpField.FLAG_INEXACT, "sin #21");          test(DfpMath.sin(factory.newDfp("1.1")),              factory.newDfp("0.89120736006143533995"),              DfpField.FLAG_INEXACT, "sin #22");          test(DfpMath.sin(factory.newDfp("1.2")),              factory.newDfp("0.93203908596722634968"),              DfpField.FLAG_INEXACT, "sin #23");          test(DfpMath.sin(factory.newDfp("1.3")),              factory.newDfp("0.9635581854171929647"),              DfpField.FLAG_INEXACT, "sin #24");          test(DfpMath.sin(factory.newDfp("1.4")),              factory.newDfp("0.98544972998846018066"),              DfpField.FLAG_INEXACT, "sin #25");          test(DfpMath.sin(factory.newDfp("1.5")),              factory.newDfp("0.99749498660405443096"),              DfpField.FLAG_INEXACT, "sin #26");          test(DfpMath.sin(factory.newDfp("1.6")),              factory.newDfp("0.99957360304150516323"),              DfpField.FLAG_INEXACT, "sin #27");     }   } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math4.ode.sampling.DummyStepInterpolator; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class ContinuousOutputModelTest {    public ContinuousOutputModelTest() {     pb    = null;     integ = null;   }    @Test   public void testBoundaries() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);     ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();     cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());     cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());     cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));   }    @Test   public void testRandomAccess() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {      ContinuousOutputModel cm = new ContinuousOutputModel();     integ.addStepHandler(cm);     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Random random = new Random(347588535632l);     double maxError    = 0.0;     double maxErrorDot = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY    = cm.getInterpolatedState();       double[] interpolatedYDot = cm.getInterpolatedDerivatives();       double[] theoreticalY     = pb.computeTheoreticalState(time);       double[] theoreticalYDot  = new double[pb.getDimension()];       pb.doComputeDerivatives(time, theoreticalY, theoreticalYDot);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       maxError = FastMath.max(maxError, error);       double dxDot = interpolatedYDot[0] - theoreticalYDot[0];       double dyDot = interpolatedYDot[1] - theoreticalYDot[1];       double errorDot = dxDot * dxDot + dyDot * dyDot;       maxErrorDot = FastMath.max(maxErrorDot, errorDot);     }      Assert.assertEquals(0.0, maxError,    1.0e-9);     Assert.assertEquals(0.0, maxErrorDot, 4.0e-7);    }    @Test   public void testModelsMerging() throws MaxCountExceededException, MathIllegalArgumentException {        // theoretical solution: y[0] = cos(t), y[1] = sin(t)       FirstOrderDifferentialEquations problem =           new FirstOrderDifferentialEquations() {               @Override             public void computeDerivatives(double t, double[] y, double[] dot) {                   dot[0] = -y[1];                   dot[1] =  y[0];               }               @Override             public int getDimension() {                   return 2;               }           };        // integrate backward from &pi; to 0;       ContinuousOutputModel cm1 = new ContinuousOutputModel();       FirstOrderIntegrator integ1 =           new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);       integ1.addStepHandler(cm1);       integ1.integrate(problem, FastMath.PI, new double[] { -1.0, 0.0 },                        0, new double[2]);        // integrate backward from 2&pi; to &pi;       ContinuousOutputModel cm2 = new ContinuousOutputModel();       FirstOrderIntegrator integ2 =           new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);       integ2.addStepHandler(cm2);       integ2.integrate(problem, 2.0 * FastMath.PI, new double[] { 1.0, 0.0 },                        FastMath.PI, new double[2]);        // merge the two half circles       ContinuousOutputModel cm = new ContinuousOutputModel();       cm.append(cm2);       cm.append(new ContinuousOutputModel());       cm.append(cm1);        // check circle       Assert.assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12);       Assert.assertEquals(0, cm.getFinalTime(), 1.0e-12);       Assert.assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);       for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) {           cm.setInterpolatedTime(t);           double[] y = cm.getInterpolatedState();           Assert.assertEquals(FastMath.cos(t), y[0], 1.0e-7);           Assert.assertEquals(FastMath.sin(t), y[1], 1.0e-7);       }    }    @Test   public void testErrorConditions() throws MaxCountExceededException, MathIllegalArgumentException {        ContinuousOutputModel cm = new ContinuousOutputModel();       cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);        // dimension mismatch       Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));        // hole between time ranges       Assert.assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));        // propagation direction mismatch       Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));        // no errors       Assert.assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));    }    private boolean checkAppendError(ContinuousOutputModel cm,                                    double t0, double[] y0, double t1)       throws MaxCountExceededException, MathIllegalArgumentException {       try {           ContinuousOutputModel otherCm = new ContinuousOutputModel();           otherCm.handleStep(buildInterpolator(t0, y0, t1), true);           cm.append(otherCm);       } catch(MathIllegalArgumentException iae) {           return true; // there was an allowable error       }       return false; // no allowable error   }    private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) {       DummyStepInterpolator interpolator  = new DummyStepInterpolator(y0, new double[y0.length], t1 >= t0);       interpolator.storeTime(t0);       interpolator.shift();       interpolator.storeTime(t1);       return interpolator;   }    public void checkValue(double value, double reference) {     Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10);   }    @Before   public void setUp() {     pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);   }    @After   public void tearDown() {     pb    = null;     integ = null;   }    TestProblem3 pb;   FirstOrderIntegrator integ;  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import java.util.Random;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator; import org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator; import org.apache.commons.math4.ode.sampling.DummyFieldStepInterpolator; import org.apache.commons.math4.ode.sampling.FieldStepInterpolator; import org.apache.commons.math4.util.Decimal64Field; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.apache.commons.math4.util.MathUtils; import org.junit.Assert; import org.junit.Test;  public class ContinuousOutputFieldModelTest {      @Test     public void testBoundaries() {         doTestBoundaries(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestBoundaries(final Field<T> field) {         TestFieldProblem3<T> pb = new TestFieldProblem3<>(field, field.getZero().add(0.9));         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         FirstOrderFieldIntegrator<T> integ = new DormandPrince54FieldIntegrator<>(field, minStep, maxStep, 1.0e-8, 1.0e-8);         integ.addStepHandler(new ContinuousOutputFieldModel<T>());         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());         ContinuousOutputFieldModel<T> cm = (ContinuousOutputFieldModel<T>) integ.getStepHandlers().iterator().next();         cm.getInterpolatedState(pb.getInitialState().getTime().multiply(2).subtract(pb.getFinalTime()));         cm.getInterpolatedState(pb.getFinalTime().multiply(2).subtract(pb.getInitialState().getTime()));         cm.getInterpolatedState(pb.getInitialState().getTime().add(pb.getFinalTime()).multiply(0.5));     }      @Test     public void testRandomAccess() {         doTestRandomAccess(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestRandomAccess(final Field<T> field)  {          TestFieldProblem3<T> pb = new TestFieldProblem3<>(field, field.getZero().add(0.9));         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         FirstOrderFieldIntegrator<T> integ = new DormandPrince54FieldIntegrator<>(field, minStep, maxStep, 1.0e-8, 1.0e-8);         ContinuousOutputFieldModel<T> cm = new ContinuousOutputFieldModel<>();         integ.addStepHandler(cm);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Random random = new Random(347588535632l);         T maxError    = field.getZero();         T maxErrorDot = field.getZero();         for (int i = 0; i < 1000; ++i) {             double r = random.nextDouble();             T time = pb.getInitialState().getTime().multiply(r).add(pb.getFinalTime().multiply(1.0 - r));             FieldODEStateAndDerivative<T> interpolated = cm.getInterpolatedState(time);             T[] theoreticalY = pb.computeTheoreticalState(time);             T[] theoreticalYDot  = pb.doComputeDerivatives(time, theoreticalY);             T dx = interpolated.getState()[0].subtract(theoreticalY[0]);             T dy = interpolated.getState()[1].subtract(theoreticalY[1]);             T error = dx.multiply(dx).add(dy.multiply(dy));             maxError = MathUtils.max(maxError, error);             T dxDot = interpolated.getDerivative()[0].subtract(theoreticalYDot[0]);             T dyDot = interpolated.getDerivative()[1].subtract(theoreticalYDot[1]);             T errorDot = dxDot.multiply(dxDot).add(dyDot.multiply(dyDot));             maxErrorDot = MathUtils.max(maxErrorDot, errorDot);         }          Assert.assertEquals(0.0, maxError.getReal(),    1.0e-9);         Assert.assertEquals(0.0, maxErrorDot.getReal(), 4.0e-7);      }      @Test     public void testModelsMerging() {         doTestModelsMerging(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestModelsMerging(final Field<T> field) {          // theoretical solution: y[0] = cos(t), y[1] = sin(t)         FirstOrderFieldDifferentialEquations<T> problem =                         new FirstOrderFieldDifferentialEquations<T>() {             @Override             public T[] computeDerivatives(T t, T[] y) {                 T[] yDot = MathArrays.buildArray(field, 2);                 yDot[0] = y[1].negate();                 yDot[1] = y[0];                 return yDot;             }             @Override             public int getDimension() {                 return 2;             }             @Override             public void init(T t0, T[] y0, T finalTime) {             }         };          // integrate backward from &pi; to 0;         ContinuousOutputFieldModel<T> cm1 = new ContinuousOutputFieldModel<>();         FirstOrderFieldIntegrator<T> integ1 =                         new DormandPrince853FieldIntegrator<>(field, 0, 1.0, 1.0e-8, 1.0e-8);         integ1.addStepHandler(cm1);         T t0 = field.getZero().add(FastMath.PI);         T[] y0 = MathArrays.buildArray(field, 2);         y0[0] = field.getOne().negate();         y0[1] = field.getZero();         integ1.integrate(new FieldExpandableODE<>(problem),                          new FieldODEState<>(t0, y0),                          field.getZero());          // integrate backward from 2&pi; to &pi;         ContinuousOutputFieldModel<T> cm2 = new ContinuousOutputFieldModel<>();         FirstOrderFieldIntegrator<T> integ2 =                         new DormandPrince853FieldIntegrator<>(field, 0, 0.1, 1.0e-12, 1.0e-12);         integ2.addStepHandler(cm2);         t0 = field.getZero().add(2.0 * FastMath.PI);         y0[0] = field.getOne();         y0[1] = field.getZero();         integ2.integrate(new FieldExpandableODE<>(problem),                          new FieldODEState<>(t0, y0),                          field.getZero().add(FastMath.PI));          // merge the two half circles         ContinuousOutputFieldModel<T> cm = new ContinuousOutputFieldModel<>();         cm.append(cm2);         cm.append(new ContinuousOutputFieldModel<T>());         cm.append(cm1);          // check circle         Assert.assertEquals(2.0 * FastMath.PI, cm.getInitialTime().getReal(), 1.0e-12);         Assert.assertEquals(0, cm.getFinalTime().getReal(), 1.0e-12);         for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) {             FieldODEStateAndDerivative<T> interpolated = cm.getInterpolatedState(field.getZero().add(t));             Assert.assertEquals(FastMath.cos(t), interpolated.getState()[0].getReal(), 1.0e-7);             Assert.assertEquals(FastMath.sin(t), interpolated.getState()[1].getReal(), 1.0e-7);         }      }      @Test     public void testErrorConditions() {         doTestErrorConditions(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestErrorConditions(final Field<T> field) {         ContinuousOutputFieldModel<T> cm = new ContinuousOutputFieldModel<>();         cm.handleStep(buildInterpolator(field, 0, 1, new double[] { 0.0, 1.0, -2.0 }), true);          // dimension mismatch         Assert.assertTrue(checkAppendError(field, cm, 1.0, 2.0, new double[] { 0.0, 1.0 }));          // hole between time ranges         Assert.assertTrue(checkAppendError(field, cm, 10.0, 20.0, new double[] { 0.0, 1.0, -2.0 }));          // propagation direction mismatch         Assert.assertTrue(checkAppendError(field, cm, 1.0, 0.0, new double[] { 0.0, 1.0, -2.0 }));          // no errors         Assert.assertFalse(checkAppendError(field, cm, 1.0, 2.0, new double[] { 0.0, 1.0, -2.0 }));      }      private <T extends RealFieldElement<T>> boolean checkAppendError(Field<T> field, ContinuousOutputFieldModel<T> cm,                                                                      double t0, double t1, double[] y) {         try {             ContinuousOutputFieldModel<T> otherCm = new ContinuousOutputFieldModel<>();             otherCm.handleStep(buildInterpolator(field, t0, t1, y), true);             cm.append(otherCm);         } catch(DimensionMismatchException dme) {             return true; // there was an allowable error         } catch(MathIllegalArgumentException miae) {             return true; // there was an allowable error         }         return false; // no allowable error     }      private <T extends RealFieldElement<T>> FieldStepInterpolator<T> buildInterpolator(Field<T> field,                                                                                        double t0, double t1, double[] y) {         T[] fieldY = MathArrays.buildArray(field, y.length);         for (int i = 0; i < y.length; ++i) {             fieldY[i] = field.getZero().add(y[i]);         }         final FieldODEStateAndDerivative<T> s0 = new FieldODEStateAndDerivative<>(field.getZero().add(t0), fieldY, fieldY);         final FieldODEStateAndDerivative<T> s1 = new FieldODEStateAndDerivative<>(field.getZero().add(t1), fieldY, fieldY);         final FieldEquationsMapper<T> mapper   = new FieldExpandableODE<>(new FirstOrderFieldDifferentialEquations<T>() {             @Override             public int getDimension() {                 return s0.getStateDimension();             }             @Override             public void init(T t0, T[] y0, T finalTime) {             }             @Override             public T[] computeDerivatives(T t, T[] y) {                 return y;             }         }).getMapper();         return new DummyFieldStepInterpolator<>(t1 >= t0, s0, s1, s0, s1, mapper);     }      public void checkValue(double value, double reference) {         Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.ode.sampling.FieldStepHandler; import org.apache.commons.math4.ode.sampling.FieldStepInterpolator; import org.apache.commons.math4.util.MathUtils;  /**  * This class is used to handle steps for the test problems  * integrated during the junit tests for the ODE integrators.  * @param <T> the type of the field elements  */ public class TestFieldProblemHandler<T extends RealFieldElement<T>>     implements FieldStepHandler<T> {      /** Associated problem. */     private TestFieldProblemAbstract<T> problem;      /** Maximal errors encountered during the integration. */     private T maxValueError;     private T maxTimeError;      /** Error at the end of the integration. */     private T lastError;      /** Time at the end of integration. */     private T lastTime;      /** ODE solver used. */     private FirstOrderFieldIntegrator<T> integrator;      /** Expected start for step. */     private T expectedStepStart;      /**      * Simple constructor.      * @param problem problem for which steps should be handled      * @param integrator ODE solver used      */     public TestFieldProblemHandler(TestFieldProblemAbstract<T> problem, FirstOrderFieldIntegrator<T> integrator) {         this.problem      = problem;         this.integrator   = integrator;         maxValueError     = problem.getField().getZero();         maxTimeError      = problem.getField().getZero();         lastError         = problem.getField().getZero();         expectedStepStart = null;     }      @Override     public void init(FieldODEStateAndDerivative<T> state0, T t) {         maxValueError     = problem.getField().getZero();         maxTimeError      = problem.getField().getZero();         lastError         = problem.getField().getZero();         expectedStepStart = null;     }      @Override     public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast) throws MaxCountExceededException {          T start = integrator.getCurrentStepStart().getTime();         if (start.subtract(problem.getInitialState().getTime()).divide(integrator.getCurrentSignedStepsize()).abs().getReal() > 0.001) {             // multistep integrators do not handle the first steps themselves             // so we have to make sure the integrator we look at has really started its work             if (expectedStepStart != null) {                 // the step should either start at the end of the integrator step                 // or at an event if the step is split into several substeps                 T stepError = MathUtils.max(maxTimeError, start.subtract(expectedStepStart).abs());                 for (T eventTime : problem.getTheoreticalEventsTimes()) {                     stepError = MathUtils.min(stepError, start.subtract(eventTime).abs());                 }                 maxTimeError = MathUtils.max(maxTimeError, stepError);             }             expectedStepStart = start.add(integrator.getCurrentSignedStepsize());         }          T pT = interpolator.getPreviousState().getTime();         T cT = interpolator.getCurrentState().getTime();         T[] errorScale = problem.getErrorScale();          // store the error at the last step         if (isLast) {             T[] interpolatedY = interpolator.getInterpolatedState(cT).getState();             T[] theoreticalY  = problem.computeTheoreticalState(cT);             for (int i = 0; i < interpolatedY.length; ++i) {                 T error = interpolatedY[i].subtract(theoreticalY[i]).abs();                 lastError = MathUtils.max(error, lastError);             }             lastTime = cT;         }          // walk through the step         for (int k = 0; k <= 20; ++k) {              T time = pT.add(cT.subtract(pT).multiply(k).divide(20));             T[] interpolatedY = interpolator.getInterpolatedState(time).getState();             T[] theoreticalY  = problem.computeTheoreticalState(time);              // update the errors             for (int i = 0; i < interpolatedY.length; ++i) {                 T error = errorScale[i].multiply(interpolatedY[i].subtract(theoreticalY[i]).abs());                 maxValueError = MathUtils.max(error, maxValueError);             }         }     }      /**      * Get the maximal value error encountered during integration.      * @return maximal value error      */     public T getMaximalValueError() {         return maxValueError;     }      /**      * Get the maximal time error encountered during integration.      * @return maximal time error      */     public T getMaximalTimeError() {         return maxTimeError;     }      /**      * Get the error at the end of the integration.      * @return error at the end of the integration      */     public T getLastError() {         return lastError;     }      /**      * Get the time at the end of the integration.      * @return time at the end of the integration.      */     public T getLastTime() {         return lastTime;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import java.lang.reflect.Array;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.events.Action; import org.apache.commons.math4.ode.events.FieldEventHandler; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    x'' = -x  * </pre>  * And when x decreases down to 0, the state should be changed as follows :  * <pre>  *   x' -> -x'  * </pre>  * The theoretical solution of this problem is x = |sin(t+a)|  * </p>   * @param <T> the type of the field elements  */ public class TestFieldProblem4<T extends RealFieldElement<T>>     extends TestFieldProblemAbstract<T> {      /** Time offset. */     private T a;      /** Simple constructor.      * @param field field to which elements belong      */     public TestFieldProblem4(Field<T> field) {         super(field);         a = convert(1.2);         T[] y0 = MathArrays.buildArray(field, 2);         y0[0] = a.sin();         y0[1] = a.cos();;         setInitialConditions(convert(0.0), y0);         setFinalConditions(convert(15));         setErrorScale(convert(1.0, 0.0));     }      @Override     public FieldEventHandler<T>[] getEventsHandlers() {         @SuppressWarnings("unchecked")         FieldEventHandler<T>[] handlers =                         (FieldEventHandler<T>[]) Array.newInstance(FieldEventHandler.class, 2);         handlers[0] = new Bounce<>();         handlers[1] = new Stop<>();         return handlers;     }      /**      * Get the theoretical events times.      * @return theoretical events times      */     @Override     public T[] getTheoreticalEventsTimes() {         T[] array = MathArrays.buildArray(getField(), 5);         array[0] = a.negate().add(1 * FastMath.PI);         array[1] = a.negate().add(2 * FastMath.PI);         array[2] = a.negate().add(3 * FastMath.PI);         array[3] = a.negate().add(4 * FastMath.PI);         array[4] = convert(120.0);         return array;     }      @Override     public T[] doComputeDerivatives(T t, T[] y) {         final T[] yDot = MathArrays.buildArray(getField(), getDimension());         yDot[0] = y[1];         yDot[1] = y[0].negate();         return yDot;     }      @Override     public T[] computeTheoreticalState(T t) {         T sin = t.add(a).sin();         T cos = t.add(a).cos();         final T[] y = MathArrays.buildArray(getField(), getDimension());         y[0] = sin.abs();         y[1] = (sin.getReal() >= 0) ? cos : cos.negate();         return y;     }      private static class Bounce<T extends RealFieldElement<T>> implements FieldEventHandler<T> {          private int sign;          public Bounce() {             sign = +1;         }          @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {         }          @Override         public T g(FieldODEStateAndDerivative<T> state) {             return state.getState()[0].multiply(sign);         }          @Override         public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {             // this sign change is needed because the state will be reset soon             sign = -sign;             return Action.RESET_STATE;         }          @Override         public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {             T[] y = state.getState();             y[0] = y[0].negate();             y[1] = y[1].negate();             return new FieldODEState<>(state.getTime(), y);         }      }      private static class Stop<T extends RealFieldElement<T>> implements FieldEventHandler<T> {          public Stop() {         }          @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {         }          @Override         public T g(FieldODEStateAndDerivative<T> state) {             return state.getTime().subtract(12.0);         }          @Override         public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {             return Action.STOP;         }          @Override         public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {             return state;         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.util.FastMath;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0  *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e))  *    r = sqrt (y1^2 + y2^2), e = 0.9  * </pre>  * This is a two-body problem in the plane which can be solved by  * Kepler's equation  * <pre>  *   y1 (t) = ...  * </pre>  * </p>   */ public class TestProblem3   extends TestProblemAbstract {    /** Eccentricity */   double e;    /** theoretical state */   private double[] y;    /**    * Simple constructor.    * @param e eccentricity    */   public TestProblem3(double e) {     super();     this.e = e;     double[] y0 = { 1 - e, 0, 0, FastMath.sqrt((1+e)/(1-e)) };     setInitialConditions(0.0, y0);     setFinalConditions(20.0);     double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };     setErrorScale(errorScale);     y = new double[y0.length];   }    /**    * Simple constructor.    */   public TestProblem3() {     this(0.1);   }    @Override   public void doComputeDerivatives(double t, double[] y, double[] yDot) {      // current radius     double r2 = y[0] * y[0] + y[1] * y[1];     double invR3 = 1 / (r2 * FastMath.sqrt(r2));      // compute the derivatives     yDot[0] = y[2];     yDot[1] = y[3];     yDot[2] = -invR3  * y[0];     yDot[3] = -invR3  * y[1];    }    @Override   public double[] computeTheoreticalState(double t) {      // solve Kepler's equation     double E = t;     double d = 0;     double corr = 999.0;     for (int i = 0; (i < 50) && (FastMath.abs(corr) > 1.0e-12); ++i) {       double f2  = e * FastMath.sin(E);       double f0  = d - f2;       double f1  = 1 - e * FastMath.cos(E);       double f12 = f1 + f1;       corr  = f0 * f12 / (f1 * f12 - f0 * f2);       d -= corr;       E = t + d;     }      double cosE = FastMath.cos(E);     double sinE = FastMath.sin(E);      y[0] = cosE - e;     y[1] = FastMath.sqrt(1 - e * e) * sinE;     y[2] = -sinE / (1 - e * cosE);     y[3] = FastMath.sqrt(1 - e * e) * cosE / (1 - e * cosE);      return y;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.JacobianMatrices.MismatchedEquations; import org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math4.stat.descriptive.SummaryStatistics; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class JacobianMatricesTest {      @Test     public void testLowAccuracyExternalDifferentiation()         throws NumberIsTooSmallException, DimensionMismatchException,                MaxCountExceededException, NoBracketingException {         // this test does not really test JacobianMatrices,         // it only shows that WITHOUT this class, attempting to recover         // the jacobians from external differentiation on simple integration         // results with low accuracy gives very poor results. In fact,         // the curves dy/dp = g(b) when b varies from 2.88 to 3.08 are         // essentially noise.         // This test is taken from Hairer, Norsett and Wanner book         // Solving Ordinary Differential Equations I (Nonstiff problems),         // the curves dy/dp = g(b) are in figure 6.5         FirstOrderIntegrator integ =             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });         double hP = 1.0e-12;         SummaryStatistics residualsP0 = new SummaryStatistics();         SummaryStatistics residualsP1 = new SummaryStatistics();         for (double b = 2.88; b < 3.08; b += 0.001) {             Brusselator brusselator = new Brusselator(b);             double[] y = { 1.3, b };             integ.integrate(brusselator, 0, y, 20.0, y);             double[] yP = { 1.3, b + hP };             integ.integrate(brusselator, 0, yP, 20.0, yP);             residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());             residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());         }         Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 500);         Assert.assertTrue(residualsP0.getStandardDeviation() > 30);         Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 700);         Assert.assertTrue(residualsP1.getStandardDeviation() > 40);     }      @Test     public void testHighAccuracyExternalDifferentiation()         throws NumberIsTooSmallException, DimensionMismatchException,                MaxCountExceededException, NoBracketingException, UnknownParameterException {         FirstOrderIntegrator integ =             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });         double hP = 1.0e-12;         SummaryStatistics residualsP0 = new SummaryStatistics();         SummaryStatistics residualsP1 = new SummaryStatistics();         for (double b = 2.88; b < 3.08; b += 0.001) {             ParamBrusselator brusselator = new ParamBrusselator(b);             double[] y = { 1.3, b };             integ.integrate(brusselator, 0, y, 20.0, y);             double[] yP = { 1.3, b + hP };             brusselator.setParameter("b", b + hP);             integ.integrate(brusselator, 0, yP, 20.0, yP);             residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());             residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());         }         Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 0.02);         Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.03);         Assert.assertTrue(residualsP0.getStandardDeviation() > 0.003);         Assert.assertTrue(residualsP0.getStandardDeviation() < 0.004);         Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 0.04);         Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);         Assert.assertTrue(residualsP1.getStandardDeviation() > 0.007);         Assert.assertTrue(residualsP1.getStandardDeviation() < 0.008);     }      @Test     public void testWrongParameterName() {         final String name = "an-unknown-parameter";         try {             ParamBrusselator brusselator = new ParamBrusselator(2.9);             brusselator.setParameter(name, 3.0);             Assert.fail("an exception should have been thrown");         } catch (UnknownParameterException upe) {             Assert.assertTrue(upe.getMessage().contains(name));             Assert.assertEquals(name, upe.getName());         }     }      @Test     public void testInternalDifferentiation()                     throws NumberIsTooSmallException, DimensionMismatchException,                     MaxCountExceededException, NoBracketingException,                     UnknownParameterException, MismatchedEquations {         AbstractIntegrator integ =                         new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });         double hP = 1.0e-12;         double hY = 1.0e-12;         SummaryStatistics residualsP0 = new SummaryStatistics();         SummaryStatistics residualsP1 = new SummaryStatistics();         for (double b = 2.88; b < 3.08; b += 0.001) {                 ParamBrusselator brusselator = new ParamBrusselator(b);                 brusselator.setParameter(ParamBrusselator.B, b);             double[] z = { 1.3, b };             double[][] dZdZ0 = new double[2][2];             double[]   dZdP  = new double[2];              JacobianMatrices jacob = new JacobianMatrices(brusselator, new double[] { hY, hY }, ParamBrusselator.B);             jacob.setParameterizedODE(brusselator);             jacob.setParameterStep(ParamBrusselator.B, hP);             jacob.setInitialParameterJacobian(ParamBrusselator.B, new double[] { 0.0, 1.0 });              ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator);             efode.setTime(0);             efode.setPrimaryState(z);             jacob.registerVariationalEquations(efode);              integ.setMaxEvaluations(5000);             integ.integrate(efode, 20.0);             jacob.getCurrentMainSetJacobian(dZdZ0);             jacob.getCurrentParameterJacobian(ParamBrusselator.B, dZdP); //            Assert.assertEquals(5000, integ.getMaxEvaluations()); //            Assert.assertTrue(integ.getEvaluations() > 1500); //            Assert.assertTrue(integ.getEvaluations() < 2100); //            Assert.assertEquals(4 * integ.getEvaluations(), integ.getEvaluations());             residualsP0.addValue(dZdP[0] - brusselator.dYdP0());             residualsP1.addValue(dZdP[1] - brusselator.dYdP1());         }         Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.02);         Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);         Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);         Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);     }      @Test     public void testAnalyticalDifferentiation()         throws MaxCountExceededException, DimensionMismatchException,                NumberIsTooSmallException, NoBracketingException,                UnknownParameterException, MismatchedEquations {         AbstractIntegrator integ =             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });         SummaryStatistics residualsP0 = new SummaryStatistics();         SummaryStatistics residualsP1 = new SummaryStatistics();         for (double b = 2.88; b < 3.08; b += 0.001) {             Brusselator brusselator = new Brusselator(b);             double[] z = { 1.3, b };             double[][] dZdZ0 = new double[2][2];             double[]   dZdP  = new double[2];              JacobianMatrices jacob = new JacobianMatrices(brusselator, Brusselator.B);             jacob.addParameterJacobianProvider(brusselator);             jacob.setInitialParameterJacobian(Brusselator.B, new double[] { 0.0, 1.0 });              ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator);             efode.setTime(0);             efode.setPrimaryState(z);             jacob.registerVariationalEquations(efode);              integ.setMaxEvaluations(5000);             integ.integrate(efode, 20.0);             jacob.getCurrentMainSetJacobian(dZdZ0);             jacob.getCurrentParameterJacobian(Brusselator.B, dZdP); //            Assert.assertEquals(5000, integ.getMaxEvaluations()); //            Assert.assertTrue(integ.getEvaluations() > 350); //            Assert.assertTrue(integ.getEvaluations() < 510);             residualsP0.addValue(dZdP[0] - brusselator.dYdP0());             residualsP1.addValue(dZdP[1] - brusselator.dYdP1());         }         Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.014);         Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);         Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);         Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);     }      @Test     public void testFinalResult()         throws MaxCountExceededException, DimensionMismatchException,                NumberIsTooSmallException, NoBracketingException,                UnknownParameterException, MismatchedEquations {          AbstractIntegrator integ =             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });         double[] y = new double[] { 0.0, 1.0 };         Circle circle = new Circle(y, 1.0, 1.0, 0.1);          JacobianMatrices jacob = new JacobianMatrices(circle, Circle.CX, Circle.CY, Circle.OMEGA);         jacob.addParameterJacobianProvider(circle);         jacob.setInitialMainStateJacobian(circle.exactDyDy0(0));         jacob.setInitialParameterJacobian(Circle.CX, circle.exactDyDcx(0));         jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0));         jacob.setInitialParameterJacobian(Circle.OMEGA, circle.exactDyDom(0));          ExpandableStatefulODE efode = new ExpandableStatefulODE(circle);         efode.setTime(0);         efode.setPrimaryState(y);         jacob.registerVariationalEquations(efode);          integ.setMaxEvaluations(5000);          double t = 18 * FastMath.PI;         integ.integrate(efode, t);         y = efode.getPrimaryState();         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9);         }          double[][] dydy0 = new double[2][2];         jacob.getCurrentMainSetJacobian(dydy0);         for (int i = 0; i < dydy0.length; ++i) {             for (int j = 0; j < dydy0[i].length; ++j) {                 Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9);             }         }         double[] dydcx = new double[2];         jacob.getCurrentParameterJacobian(Circle.CX, dydcx);         for (int i = 0; i < dydcx.length; ++i) {             Assert.assertEquals(circle.exactDyDcx(t)[i], dydcx[i], 1.0e-7);         }         double[] dydcy = new double[2];         jacob.getCurrentParameterJacobian(Circle.CY, dydcy);         for (int i = 0; i < dydcy.length; ++i) {             Assert.assertEquals(circle.exactDyDcy(t)[i], dydcy[i], 1.0e-7);         }         double[] dydom = new double[2];         jacob.getCurrentParameterJacobian(Circle.OMEGA, dydom);         for (int i = 0; i < dydom.length; ++i) {             Assert.assertEquals(circle.exactDyDom(t)[i], dydom[i], 1.0e-7);         }     }      @Test     public void testParameterizable()         throws MaxCountExceededException, DimensionMismatchException,                NumberIsTooSmallException, NoBracketingException,                UnknownParameterException, MismatchedEquations {          AbstractIntegrator integ =             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });         double[] y = new double[] { 0.0, 1.0 };         ParameterizedCircle pcircle = new ParameterizedCircle(y, 1.0, 1.0, 0.1);          double hP = 1.0e-12;         double hY = 1.0e-12;          JacobianMatrices jacob = new JacobianMatrices(pcircle, new double[] { hY, hY },                                                       ParameterizedCircle.CX, ParameterizedCircle.CY,                                                       ParameterizedCircle.OMEGA);         jacob.setParameterizedODE(pcircle);         jacob.setParameterStep(ParameterizedCircle.CX,    hP);         jacob.setParameterStep(ParameterizedCircle.CY,    hP);         jacob.setParameterStep(ParameterizedCircle.OMEGA, hP);         jacob.setInitialMainStateJacobian(pcircle.exactDyDy0(0));         jacob.setInitialParameterJacobian(ParameterizedCircle.CX, pcircle.exactDyDcx(0));         jacob.setInitialParameterJacobian(ParameterizedCircle.CY, pcircle.exactDyDcy(0));         jacob.setInitialParameterJacobian(ParameterizedCircle.OMEGA, pcircle.exactDyDom(0));          ExpandableStatefulODE efode = new ExpandableStatefulODE(pcircle);         efode.setTime(0);         efode.setPrimaryState(y);         jacob.registerVariationalEquations(efode);          integ.setMaxEvaluations(50000);          double t = 18 * FastMath.PI;         integ.integrate(efode, t);         y = efode.getPrimaryState();         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(pcircle.exactY(t)[i], y[i], 1.0e-9);         }          double[][] dydy0 = new double[2][2];         jacob.getCurrentMainSetJacobian(dydy0);         for (int i = 0; i < dydy0.length; ++i) {             for (int j = 0; j < dydy0[i].length; ++j) {                 Assert.assertEquals(pcircle.exactDyDy0(t)[i][j], dydy0[i][j], 5.0e-4);             }         }          double[] dydp0 = new double[2];         jacob.getCurrentParameterJacobian(ParameterizedCircle.CX, dydp0);         for (int i = 0; i < dydp0.length; ++i) {             Assert.assertEquals(pcircle.exactDyDcx(t)[i], dydp0[i], 5.0e-4);         }          double[] dydp1 = new double[2];         jacob.getCurrentParameterJacobian(ParameterizedCircle.OMEGA, dydp1);         for (int i = 0; i < dydp1.length; ++i) {             Assert.assertEquals(pcircle.exactDyDom(t)[i], dydp1[i], 1.0e-2);         }     }      private static class Brusselator extends AbstractParameterizable         implements MainStateJacobianProvider, ParameterJacobianProvider {          public static final String B = "b";          private double b;          public Brusselator(double b) {             super(B);             this.b = b;         }          @Override         public int getDimension() {             return 2;         }          @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {             double prod = y[0] * y[0] * y[1];             yDot[0] = 1 + prod - (b + 1) * y[0];             yDot[1] = b * y[0] - prod;         }          @Override         public void computeMainStateJacobian(double t, double[] y, double[] yDot,                                              double[][] dFdY) {             double p = 2 * y[0] * y[1];             double y02 = y[0] * y[0];             dFdY[0][0] = p - (1 + b);             dFdY[0][1] = y02;             dFdY[1][0] = b - p;             dFdY[1][1] = -y02;         }          @Override         public void computeParameterJacobian(double t, double[] y, double[] yDot,                                              String paramName, double[] dFdP) {             if (isSupported(paramName)) {                 dFdP[0] = -y[0];                 dFdP[1] = y[0];             } else {                 dFdP[0] = 0;                 dFdP[1] = 0;             }         }          public double dYdP0() {             return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b;         }          public double dYdP1() {             return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b;         }      }      private static class ParamBrusselator extends AbstractParameterizable         implements FirstOrderDifferentialEquations, ParameterizedODE {          public static final String B = "b";          private double b;          public ParamBrusselator(double b) {             super(B);             this.b = b;         }          @Override         public int getDimension() {             return 2;         }          /** {@inheritDoc} */         @Override         public double getParameter(final String name)             throws UnknownParameterException {             complainIfNotSupported(name);             return b;         }          /** {@inheritDoc} */         @Override         public void setParameter(final String name, final double value)             throws UnknownParameterException {             complainIfNotSupported(name);             b = value;         }          @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {             double prod = y[0] * y[0] * y[1];             yDot[0] = 1 + prod - (b + 1) * y[0];             yDot[1] = b * y[0] - prod;         }          public double dYdP0() {             return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b;         }          public double dYdP1() {             return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b;         }      }      /** ODE representing a point moving on a circle with provided center and angular rate. */     private static class Circle extends AbstractParameterizable         implements MainStateJacobianProvider, ParameterJacobianProvider {          public static final String CX = "cx";         public static final String CY = "cy";         public static final String OMEGA = "omega";          private final double[] y0;         private double cx;         private double cy;         private double omega;          public Circle(double[] y0, double cx, double cy, double omega) {             super(CX,CY,OMEGA);             this.y0    = y0.clone();             this.cx    = cx;             this.cy    = cy;             this.omega = omega;         }          @Override         public int getDimension() {             return 2;         }          @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {             yDot[0] = omega * (cy - y[1]);             yDot[1] = omega * (y[0] - cx);         }          @Override         public void computeMainStateJacobian(double t, double[] y,                                              double[] yDot, double[][] dFdY) {             dFdY[0][0] = 0;             dFdY[0][1] = -omega;             dFdY[1][0] = omega;             dFdY[1][1] = 0;         }          @Override         public void computeParameterJacobian(double t, double[] y, double[] yDot,                                              String paramName, double[] dFdP)             throws UnknownParameterException {             complainIfNotSupported(paramName);             if (paramName.equals(CX)) {                 dFdP[0] = 0;                 dFdP[1] = -omega;             } else if (paramName.equals(CY)) {                 dFdP[0] = omega;                 dFdP[1] = 0;             }  else {                 dFdP[0] = cy - y[1];                 dFdP[1] = y[0] - cx;             }         }          public double[] exactY(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             double dx0 = y0[0] - cx;             double dy0 = y0[1] - cy;             return new double[] {                 cx + cos * dx0 - sin * dy0,                 cy + sin * dx0 + cos * dy0             };         }          public double[][] exactDyDy0(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             return new double[][] {                 { cos, -sin },                 { sin,  cos }             };         }          public double[] exactDyDcx(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             return new double[] {1 - cos, -sin};         }          public double[] exactDyDcy(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             return new double[] {sin, 1 - cos};         }          public double[] exactDyDom(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             double dx0 = y0[0] - cx;             double dy0 = y0[1] - cy;             return new double[] { -t * (sin * dx0 + cos * dy0) , t * (cos * dx0 - sin * dy0) };         }      }      /** ODE representing a point moving on a circle with provided center and angular rate. */     private static class ParameterizedCircle extends AbstractParameterizable         implements FirstOrderDifferentialEquations, ParameterizedODE {          public static final String CX = "cx";         public static final String CY = "cy";         public static final String OMEGA = "omega";          private final double[] y0;         private double cx;         private double cy;         private double omega;          public ParameterizedCircle(double[] y0, double cx, double cy, double omega) {             super(CX,CY,OMEGA);             this.y0    = y0.clone();             this.cx    = cx;             this.cy    = cy;             this.omega = omega;         }          @Override         public int getDimension() {             return 2;         }          @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {             yDot[0] = omega * (cy - y[1]);             yDot[1] = omega * (y[0] - cx);         }          @Override         public double getParameter(final String name)             throws UnknownParameterException {             if (name.equals(CX)) {                 return cx;             } else if (name.equals(CY)) {                     return cy;             } else if (name.equals(OMEGA)) {                 return omega;             } else {                 throw new UnknownParameterException(name);             }         }          @Override         public void setParameter(final String name, final double value)             throws UnknownParameterException {             if (name.equals(CX)) {                 cx = value;             } else if (name.equals(CY)) {                 cy = value;             } else if (name.equals(OMEGA)) {                 omega = value;             } else {                 throw new UnknownParameterException(name);             }         }          public double[] exactY(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             double dx0 = y0[0] - cx;             double dy0 = y0[1] - cy;             return new double[] {                 cx + cos * dx0 - sin * dy0,                 cy + sin * dx0 + cos * dy0             };         }          public double[][] exactDyDy0(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             return new double[][] {                 { cos, -sin },                 { sin,  cos }             };         }          public double[] exactDyDcx(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             return new double[] {1 - cos, -sin};         }          public double[] exactDyDcy(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             return new double[] {sin, 1 - cos};         }          public double[] exactDyDom(double t) {             double cos = FastMath.cos(omega * t);             double sin = FastMath.sin(omega * t);             double dx0 = y0[0] - cx;             double dy0 = y0[1] - cy;             return new double[] { -t * (sin * dx0 + cos * dy0) , t * (cos * dx0 - sin * dy0) };         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.ode.events.EventHandler;  /**  * This class is used as the base class of the problems that are  * integrated during the junit tests for the ODE integrators.  */ public abstract class TestProblemAbstract   implements FirstOrderDifferentialEquations {    /** Dimension of the problem. */   private int n;    /** Number of functions calls. */   private int calls;    /** Initial time */   private double t0;    /** Initial state */   private double[] y0;    /** Final time */   private double t1;    /** Error scale */   private double[] errorScale;    /**    * Simple constructor.    */   protected TestProblemAbstract() {     n          = 0;     calls      = 0;     t0         = 0;     y0         = null;     t1         = 0;     errorScale = null;   }    /**    * Set the initial conditions    * @param t0 initial time    * @param y0 initial state vector    */   protected void setInitialConditions(double t0, double[] y0) {     calls     = 0;     n         = y0.length;     this.t0   = t0;     this.y0   = y0.clone();    }    /**    * Set the final conditions.    * @param t1 final time    */   protected void setFinalConditions(double t1) {     this.t1 = t1;   }    /**    * Set the error scale    * @param errorScale error scale    */   protected void setErrorScale(double[] errorScale) {     this.errorScale = errorScale.clone();   }    @Override public int getDimension() {     return n;   }    /**    * Get the initial time.    * @return initial time    */   public double getInitialTime() {     return t0;   }    /**    * Get the initial state vector.    * @return initial state vector    */   public double[] getInitialState() {     return y0;   }    /**    * Get the final time.    * @return final time    */   public double getFinalTime() {     return t1;   }    /**    * Get the error scale.    * @return error scale    */   public double[] getErrorScale() {     return errorScale;   }    /**    * Get the events handlers.    * @return events handlers   */   public EventHandler[] getEventsHandlers() {     return new EventHandler[0];   }    /**    * Get the theoretical events times.    * @return theoretical events times    */   public double[] getTheoreticalEventsTimes() {       return new double[0];   }    /**    * Get the number of calls.    * @return number of calls    */   public int getCalls() {     return calls;   }    @Override public void computeDerivatives(double t, double[] y, double[] yDot) {     ++calls;     doComputeDerivatives(t, y, yDot);   }    abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);    /**    * Compute the theoretical state at the specified time.    * @param t time at which the state is required    * @return state vector at time t    */   abstract public double[] computeTheoreticalState(double t);  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.MathArrays;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0  *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e))  *    r = sqrt (y1^2 + y2^2), e = 0.9  * </pre>  * This is a two-body problem in the plane which can be solved by  * Kepler's equation  * <pre>  *   y1 (t) = ...  * </pre>  * </p>   * @param <T> the type of the field elements  */ public class TestFieldProblem3<T extends RealFieldElement<T>> extends TestFieldProblemAbstract<T> {      /** Eccentricity */     T e;      /**      * Simple constructor.      * @param field field to which elements belong      * @param e eccentricity      */     public TestFieldProblem3(Field<T> field, T e) {         super(field);         this.e = e;         T[] y0 = MathArrays.buildArray(field, 4);         y0[0] = e.subtract(1).negate();         y0[1] = field.getZero();         y0[2] = field.getZero();         y0[3] = e.add(1).divide(y0[0]).sqrt();         setInitialConditions(convert(0.0), y0);         setFinalConditions(convert(20.0));         setErrorScale(convert(1.0, 1.0, 1.0, 1.0));     }      /**      * Simple constructor.      * @param field field to which elements belong      */     public TestFieldProblem3(Field<T> field) {         this(field, field.getZero().add(0.1));     }      @Override     public T[] doComputeDerivatives(T t, T[] y) {          final T[] yDot = MathArrays.buildArray(getField(), getDimension());          // current radius         T r2 = y[0].multiply(y[0]).add(y[1].multiply(y[1]));         T invR3 = r2.multiply(r2.sqrt()).reciprocal();          // compute the derivatives         yDot[0] = y[2];         yDot[1] = y[3];         yDot[2] = invR3.negate().multiply(y[0]);         yDot[3] = invR3.negate().multiply(y[1]);          return yDot;      }      @Override     public T[] computeTheoreticalState(T t) {          final T[] y = MathArrays.buildArray(getField(), getDimension());          // solve Kepler's equation         T E = t;         T d = convert(0);         T corr = convert(999.0);         for (int i = 0; (i < 50) && (corr.abs().getReal() > 1.0e-12); ++i) {             T f2  = e.multiply(E.sin());             T f0  = d.subtract(f2);             T f1  = e.multiply(E.cos()).subtract(1).negate();             T f12 = f1.add(f1);             corr  = f0.multiply(f12).divide(f1.multiply(f12).subtract(f0.multiply(f2)));             d = d.subtract(corr);             E = t.add(d);         }          T cosE = E.cos();         T sinE = E.sin();          y[0] = cosE.subtract(e);         y[1] = e.multiply(e).subtract(1).negate().sqrt().multiply(sinE);         y[2] = sinE.divide(e.multiply(cosE).subtract(1));         y[3] = e.multiply(e).subtract(1).negate().sqrt().multiply(cosE).divide(e.multiply(cosE).subtract(1).negate());          return y;      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y' = 3x^5 - y  * </pre>  * when the initial condition is y(0) = -360, the solution of this  * equation degenerates to a simple quintic polynomial function :  * <pre>  *   y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360  * </pre>  * </p>   */ public class TestProblem6   extends TestProblemAbstract {      /** theoretical state */     private double[] y;      /**      * Simple constructor.      */     public TestProblem6() {         super();         double[] y0 = { -360.0 };         setInitialConditions(0.0, y0);         setFinalConditions(1.0);         double[] errorScale = { 1.0 };         setErrorScale(errorScale);         y = new double[y0.length];     }      @Override     public void doComputeDerivatives(double t, double[] y, double[] yDot) {          // compute the derivatives         double t2 = t  * t;         double t4 = t2 * t2;         double t5 = t4 * t;         for (int i = 0; i < getDimension(); ++i) {             yDot[i] = 3 * t5 - y[i];         }      }      @Override     public double[] computeTheoreticalState(double t) {         for (int i = 0; i < getDimension(); ++i) {             y[i] = ((((3 * t - 15) * t + 60) * t - 180) * t + 360) * t - 360;         }         return y;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.MathArrays;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y' = t^3 - t y  * </pre>  * with the initial condition y (0) = 0. The solution of this equation  * is the following function :  * <pre>  *   y (t) = t^2 + 2 (exp (- t^2 / 2) - 1)  * </pre>  * </p>   * @param <T> the type of the field elements  */ public class TestFieldProblem2<T extends RealFieldElement<T>>     extends TestFieldProblemAbstract<T> {      /**      * Simple constructor.      * @param field field to which elements belong      */     public TestFieldProblem2(Field<T> field) {         super(field);         setInitialConditions(convert(0.0), convert(new double[] { 0.0 }));         setFinalConditions(convert(1.0));         setErrorScale(convert(new double[] { 1.0 }));     }      @Override     public T[] doComputeDerivatives(T t, T[] y) {          final T[] yDot = MathArrays.buildArray(getField(), getDimension());         // compute the derivatives         for (int i = 0; i < getDimension(); ++i) {             yDot[i] = t.multiply(t.multiply(t).subtract(y[i]));         }          return yDot;      }      @Override     public T[] computeTheoreticalState(T t) {         final T[] y = MathArrays.buildArray(getField(), getDimension());         T t2 = t.multiply(t);         T c = t2.add(t2.multiply(-0.5).exp().subtract(1).multiply(2));         for (int i = 0; i < getDimension(); ++i) {             y[i] = c;         }         return y;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.MathArrays;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y' = -y  * </pre>  * the solution of this equation is a simple exponential function :  * <pre>  *   y (t) = y (t0) exp (t0-t)  * </pre>  * </p>   * @param <T> the type of the field elements  */ public class TestFieldProblem1<T extends RealFieldElement<T>>     extends TestFieldProblemAbstract<T> {      /**      * Simple constructor.      * @param field field to which elements belong      */     public TestFieldProblem1(Field<T> field) {         super(field);         setInitialConditions(convert(0.0), convert(1.0, 0.1));         setFinalConditions(convert(4.0));         setErrorScale(convert(1.0, 1.0));     }      @Override     public T[] doComputeDerivatives(T t, T[] y) {          final T[] yDot = MathArrays.buildArray(getField(), getDimension());          // compute the derivatives         for (int i = 0; i < getDimension(); ++i) {             yDot[i] = y[i].negate();         }          return yDot;      }      @Override     public T[] computeTheoreticalState(T t) {         final FieldODEState<T> s0 = getInitialState();         final T[] y0 = s0.getState();         final T[] y = MathArrays.buildArray(getField(), getDimension());         T c = s0.getTime().subtract(t).exp();         for (int i = 0; i < getDimension(); ++i) {             y[i] = c.multiply(y0[i]);         }         return y;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath;  /**  * This class is used to handle steps for the test problems  * integrated during the junit tests for the ODE integrators.  */ public class TestProblemHandler   implements StepHandler {    /** Associated problem. */   private TestProblemAbstract problem;    /** Maximal errors encountered during the integration. */   private double maxValueError;   private double maxTimeError;    /** Error at the end of the integration. */   private double lastError;    /** Time at the end of integration. */   private double lastTime;    /** ODE solver used. */   private ODEIntegrator integrator;    /** Expected start for step. */   private double expectedStepStart;    /**    * Simple constructor.    * @param problem problem for which steps should be handled    * @param integrator ODE solver used    */   public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {     this.problem = problem;     this.integrator = integrator;     maxValueError = 0;     maxTimeError  = 0;     lastError     = 0;     expectedStepStart = Double.NaN;   }    @Override public void init(double t0, double[] y0, double t) {     maxValueError = 0;     maxTimeError  = 0;     lastError     = 0;     expectedStepStart = Double.NaN;   }    @Override public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException {      double start = integrator.getCurrentStepStart();     if (FastMath.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {         // multistep integrators do not handle the first steps themselves         // so we have to make sure the integrator we look at has really started its work         if (!Double.isNaN(expectedStepStart)) {             // the step should either start at the end of the integrator step             // or at an event if the step is split into several substeps             double stepError = FastMath.max(maxTimeError, FastMath.abs(start - expectedStepStart));             for (double eventTime : problem.getTheoreticalEventsTimes()) {                 stepError = FastMath.min(stepError, FastMath.abs(start - eventTime));             }             maxTimeError = FastMath.max(maxTimeError, stepError);         }         expectedStepStart = start + integrator.getCurrentSignedStepsize();     }       double pT = interpolator.getPreviousTime();     double cT = interpolator.getCurrentTime();     double[] errorScale = problem.getErrorScale();      // store the error at the last step     if (isLast) {         double[] interpolatedY = interpolator.getInterpolatedState();         double[] theoreticalY  = problem.computeTheoreticalState(cT);         for (int i = 0; i < interpolatedY.length; ++i) {             double error = FastMath.abs(interpolatedY[i] - theoreticalY[i]);             lastError = FastMath.max(error, lastError);         }         lastTime = cT;     }     // walk through the step     for (int k = 0; k <= 20; ++k) {          double time = pT + (k * (cT - pT)) / 20;         interpolator.setInterpolatedTime(time);         double[] interpolatedY = interpolator.getInterpolatedState();         double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());          // update the errors         for (int i = 0; i < interpolatedY.length; ++i) {             double error = errorScale[i] * FastMath.abs(interpolatedY[i] - theoreticalY[i]);             maxValueError = FastMath.max(error, maxValueError);         }     }    }    /**    * Get the maximal value error encountered during integration.    * @return maximal value error    */   public double getMaximalValueError() {     return maxValueError;   }    /**    * Get the maximal time error encountered during integration.    * @return maximal time error    */   public double getMaximalTimeError() {     return maxTimeError;   }     public int getCalls() {       return problem.getCalls();   }    /**    * Get the error at the end of the integration.    * @return error at the end of the integration    */   public double getLastError() {     return lastError;   }    /**    * Get the time at the end of the integration.    * @return time at the end of the integration.    */   public double getLastTime() {     return lastTime;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.MathArrays;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y' = 3x^5 - y  * </pre>  * when the initial condition is y(0) = -360, the solution of this  * equation degenerates to a simple quintic polynomial function :  * <pre>  *   y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360  * </pre>  * </p>   * @param <T> the type of the field elements  */ public class TestFieldProblem6<T extends RealFieldElement<T>>     extends TestFieldProblemAbstract<T> {      /**      * Simple constructor.      * @param field field to which elements belong      */     public TestFieldProblem6(Field<T> field) {         super(field);         setInitialConditions(convert(0.0), convert( new double[] { -360.0 }));         setFinalConditions(convert(1.0));         setErrorScale(convert( new double[] { 1.0 }));     }      @Override     public T[] doComputeDerivatives(T t, T[] y) {          final T[] yDot = MathArrays.buildArray(getField(), getDimension());          // compute the derivatives         T t2 = t.multiply(t);         T t4 = t2.multiply(t2);         T t5 = t4.multiply(t);         for (int i = 0; i < getDimension(); ++i) {             yDot[i] = t5.multiply(3).subtract(y[i]);         }          return yDot;      }      @Override     public T[] computeTheoreticalState(T t) {          final T[] y = MathArrays.buildArray(getField(), getDimension());          for (int i = 0; i < getDimension(); ++i) {             y[i] = t.multiply(3).subtract(15).multiply(t).add(60).multiply(t).subtract(180).multiply(t).add(360).multiply(t).subtract(360);         }          return y;      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import java.lang.reflect.Array;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.events.FieldEventHandler; import org.apache.commons.math4.util.MathArrays;  /**  * This class is used as the base class of the problems that are  * integrated during the junit tests for the ODE integrators.  * @param <T> the type of the field elements  */ public abstract class TestFieldProblemAbstract<T extends RealFieldElement<T>>     implements FirstOrderFieldDifferentialEquations<T> {      /** Field to which elements belong. */     private Field<T> field;      /** Dimension of the problem. */     private int n;      /** Number of functions calls. */     private int calls;      /** Initial time */     private T t0;      /** Initial state */     private T[] y0;      /** Final time */     private T t1;      /** Error scale */     private T[] errorScale;      /**      * Simple constructor.      * @param field field to which elements belong      */     protected TestFieldProblemAbstract(Field<T> field) {         this.field = field;         n          = 0;         calls      = 0;         t0         = field.getZero();         y0         = null;         t1         = field.getZero();         errorScale = null;     }      /**      * Set the initial conditions      * @param t0 initial time      * @param y0 initial state vector      */     protected void setInitialConditions(T t0, T[] y0) {         calls     = 0;         n         = y0.length;         this.t0   = t0;         this.y0   = y0.clone();     }      /**      * Set the final conditions.      * @param t1 final time      */     protected void setFinalConditions(T t1) {         this.t1 = t1;     }      /**      * Set the error scale      * @param errorScale error scale      */     protected void setErrorScale(T[] errorScale) {         this.errorScale = errorScale.clone();     }      /** get the filed to which elements belong.      * @return field to which elements belong      */     public Field<T> getField() {         return field;     }      /** Get the problem dimension.      * @return problem dimension      */     @Override     public int getDimension() {         return n;     }     /**      * Get the initial state.      * @return initial state      */     public FieldODEState<T> getInitialState() {         return new FieldODEState<>(t0, y0);     }      /**      * Get the final time.      * @return final time      */     public T getFinalTime() {         return t1;     }      /**      * Get the error scale.      * @return error scale      */     public T[] getErrorScale() {         return errorScale;     }      /**      * Get the events handlers.      * @return events handlers   */     public FieldEventHandler<T>[] getEventsHandlers() {         @SuppressWarnings("unchecked")         final FieldEventHandler<T>[] empty =                         (FieldEventHandler<T>[]) Array.newInstance(FieldEventHandler.class, 0);         return empty;     }      /**      * Get the theoretical events times.      * @return theoretical events times      */     public T[] getTheoreticalEventsTimes() {         return MathArrays.buildArray(field, 0);     }      /**      * Get the number of calls.      * @return number of calls      */     public int getCalls() {         return calls;     }      /** {@inheritDoc} */     @Override     public void init(T t0, T[] y0, T t) {     }      /** {@inheritDoc} */     @Override     public T[] computeDerivatives(T t, T[] y) {         ++calls;         return doComputeDerivatives(t, y);     }      abstract public T[] doComputeDerivatives(T t, T[] y);      /**      * Compute the theoretical state at the specified time.      * @param t time at which the state is required      * @return state vector at time t      */     abstract public T[] computeTheoreticalState(T t);      /** Convert a double.      * @param d double to convert      * @return converted double      */     protected T convert(double d) {         return field.getZero().add(d);     }      /** Convert a one dimension array.      * @param elements array elements      * @return converted array      */     protected T[] convert(double ... elements) {         T[] array = MathArrays.buildArray(field, elements.length);         for (int i = 0; i < elements.length; ++i) {             array[i] = convert(elements[i]);         }         return array;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ode.events;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.analysis.solvers.BaseSecantSolver; import org.apache.commons.math4.analysis.solvers.PegasusSolver; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator; import org.junit.Assert; import org.junit.Test;  /** Tests for overlapping state events. Also tests an event function that does  * not converge to zero, but does have values of opposite sign around its root.  */ public class OverlappingEventsTest implements FirstOrderDifferentialEquations {      /** Expected event times for first event. */     private static final double[] EVENT_TIMES1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0,                                                   7.0, 8.0, 9.0};      /** Expected event times for second event. */     private static final double[] EVENT_TIMES2 = {0.5, 1.0, 1.5, 2.0, 2.5, 3.0,                                                   3.5, 4.0, 4.5, 5.0, 5.5, 6.0,                                                   6.5, 7.0, 7.5, 8.0, 8.5, 9.0,                                                   9.5};      /** Test for events that occur at the exact same time, but due to numerical      * calculations occur very close together instead. Uses event type 0. See      * {@link org.apache.commons.math4.ode.events.EventHandler#g(double, double[])      * EventHandler.g(double, double[])}.      */     @Test     public void testOverlappingEvents0()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         test(0);     }      /** Test for events that occur at the exact same time, but due to numerical      * calculations occur very close together instead. Uses event type 1. See      * {@link org.apache.commons.math4.ode.events.EventHandler#g(double, double[])      * EventHandler.g(double, double[])}.      */     @Test     public void testOverlappingEvents1()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         test(1);     }      /** Test for events that occur at the exact same time, but due to numerical      * calculations occur very close together instead.      * @param eventType the type of events to use. See      * {@link org.apache.commons.math4.ode.events.EventHandler#g(double, double[])      * EventHandler.g(double, double[])}.      */     public void test(int eventType)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double e = 1e-15;         FirstOrderIntegrator integrator = new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7);         BaseSecantSolver rootSolver = new PegasusSolver(e, e);         EventHandler evt1 = new Event(0, eventType);         EventHandler evt2 = new Event(1, eventType);         integrator.addEventHandler(evt1, 0.1, e, 999, rootSolver);         integrator.addEventHandler(evt2, 0.1, e, 999, rootSolver);         double t = 0.0;         double tEnd = 10.0;         double[] y = {0.0, 0.0};         List<Double> events1 = new ArrayList<>();         List<Double> events2 = new ArrayList<>();         while (t < tEnd) {             t = integrator.integrate(this, t, y, tEnd, y);             //System.out.println("t=" + t + ",\t\ty=[" + y[0] + "," + y[1] + "]");              if (y[0] >= 1.0) {                 y[0] = 0.0;                 events1.add(t);                 //System.out.println("Event 1 @ t=" + t);             }             if (y[1] >= 1.0) {                 y[1] = 0.0;                 events2.add(t);                 //System.out.println("Event 2 @ t=" + t);             }         }         Assert.assertEquals(EVENT_TIMES1.length, events1.size());         Assert.assertEquals(EVENT_TIMES2.length, events2.size());         for(int i = 0; i < EVENT_TIMES1.length; i++) {             Assert.assertEquals(EVENT_TIMES1[i], events1.get(i), 1e-7);         }         for(int i = 0; i < EVENT_TIMES2.length; i++) {             Assert.assertEquals(EVENT_TIMES2[i], events2.get(i), 1e-7);         }         //System.out.println();     }      /** {@inheritDoc} */     @Override     public int getDimension() {         return 2;     }      /** {@inheritDoc} */     @Override     public void computeDerivatives(double t, double[] y, double[] yDot) {         yDot[0] = 1.0;         yDot[1] = 2.0;     }      /** State events for this unit test. */     private class Event implements EventHandler {         /** The index of the continuous variable to use. */         private final int idx;          /** The event type to use. See {@link #g}. */         private final int eventType;          /** Constructor for the {@link Event} class.          * @param idx the index of the continuous variable to use          * @param eventType the type of event to use. See {@link #g}          */         public Event(int idx, int eventType) {             this.idx = idx;             this.eventType = eventType;         }          /** {@inheritDoc} */         @Override         public void init(double t0, double[] y0, double t) {         }          /** {@inheritDoc} */         @Override         public double g(double t, double[] y) {             return (eventType == 0) ? y[idx] >= 1.0 ? 1.0 : -1.0                                     : y[idx] - 1.0;         }          /** {@inheritDoc} */         @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {             return Action.STOP;         }          /** {@inheritDoc} */         @Override         public void resetState(double t, double[] y) {             // Never called.         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ode.events;  import org.junit.Assert;  import java.util.Arrays;  import org.apache.commons.math4.analysis.solvers.PegasusSolver; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator; import org.junit.Test;  public class ReappearingEventTest {     @Test     public void testDormandPrince()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double tEnd = test(1);         Assert.assertEquals(10.0, tEnd, 1e-7);     }      @Test     public void testGragg()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double tEnd = test(2);         Assert.assertEquals(10.0, tEnd, 1e-7);     }      public double test(int integratorType)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double e = 1e-15;         FirstOrderIntegrator integrator;         integrator = (integratorType == 1)                      ? new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7)                      : new GraggBulirschStoerIntegrator(e, 100.0, 1e-7, 1e-7);         PegasusSolver rootSolver = new PegasusSolver(e, e);         integrator.addEventHandler(new Event(), 0.1, e, 1000, rootSolver);         double t0 = 6.0;         double tEnd = 10.0;         double[] y = {2.0, 2.0, 2.0, 4.0, 2.0, 7.0, 15.0};         return integrator.integrate(new Ode(), t0, y, tEnd, y);     }      private static class Ode implements FirstOrderDifferentialEquations {         @Override         public int getDimension() {             return 7;         }          @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {             Arrays.fill(yDot, 1.0);         }     }      /** State events for this unit test. */     protected static class Event implements EventHandler {          @Override         public void init(double t0, double[] y0, double t) {         }          @Override         public double g(double t, double[] y) {             return y[6] - 15.0;         }          @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {             return Action.STOP;         }          @Override         public void resetState(double t, double[] y) {             // Never called.         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ode.events;  import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator; import org.junit.Assert; import org.junit.Test;  /**  * Check events are detected correctly when the event times are close.  *  * @author Evan Ward  */ public class CloseEventsTest {      @Test     public void testCloseEvents() {         // setup         double e = 1e-15;         FirstOrderIntegrator integrator =                 new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7);          TimeDetector detector1 = new TimeDetector(5);         integrator.addEventHandler(detector1, 10, 1, 100);         TimeDetector detector2 = new TimeDetector(5.5);         integrator.addEventHandler(detector2, 10, 1, 100);          // action         integrator.integrate(new Equation(), 0, new double[2], 20, new double[2]);          // verify         Assert.assertEquals(5, detector1.getActualT(), 0.0);         Assert.assertEquals(5.5, detector2.getActualT(), 0.0);     }      @Test     public void testSimultaneousEvents() {         // setup         double e = 1e-15;         FirstOrderIntegrator integrator =                 new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7);          TimeDetector detector1 = new TimeDetector(5);         integrator.addEventHandler(detector1, 10, 1, 100);         TimeDetector detector2 = new TimeDetector(5);         integrator.addEventHandler(detector2, 10, 1, 100);          // action         integrator.integrate(new Equation(), 0, new double[2], 20, new double[2]);          // verify         Assert.assertEquals(5, detector1.getActualT(), 0.0);         Assert.assertEquals(5, detector2.getActualT(), 0.0);     }       /** Trigger an event at a particular time. */     private static class TimeDetector implements EventHandler {          /** time of the event to trigger. */         private final double eventT;          /** time the event was actually triggered. */         private double actualT;          /**          * Create a new detector.          *          * @param eventT the time to trigger an event.          */         public TimeDetector(double eventT) {             this.eventT = eventT;         }          /** Get the actual time the event occurred. */         public double getActualT() {             return actualT;         }          @Override         public void init(double t0, double[] y0, double t) {         }          @Override         public double g(double t, double[] y) {             return t - eventT;         }          @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {             this.actualT = t;             return Action.CONTINUE;         }          @Override         public void resetState(double t, double[] y) {         }      }      /** Some basic equations to integrate. */     public static class Equation implements FirstOrderDifferentialEquations {          @Override         public int getDimension() {             return 2;         }          @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {             yDot[0] = 1.0;             yDot[1] = 2.0;         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ode.events;  import org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class EventFilterTest {      @Test     public void testHistoryIncreasingForward() {          // start point: g > 0         testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,                     0.5 * FastMath.PI, 30.5 * FastMath.PI, FastMath.PI, -1);          // start point: g = 0         testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,                     0, 30.5 * FastMath.PI, FastMath.PI, -1);          // start point: g < 0         testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,                     1.5 * FastMath.PI, 30.5 * FastMath.PI, FastMath.PI, +1);      }      @Test     public void testHistoryIncreasingBackward() {          // start point: g > 0         testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,                     0.5 * FastMath.PI, -30.5 * FastMath.PI, FastMath.PI, -1);          // start point: g = 0         testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,                     0, -30.5 * FastMath.PI, FastMath.PI, +1);          // start point: g < 0         testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,                     1.5 * FastMath.PI, -30.5 * FastMath.PI, FastMath.PI, -1);      }      @Test     public void testHistoryDecreasingForward() {          // start point: g > 0         testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,                     0.5 * FastMath.PI, 30.5 * FastMath.PI, 0, +1);          // start point: g = 0         testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,                     0, 30.5 * FastMath.PI, 0, +1);          // start point: g < 0         testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,                     1.5 * FastMath.PI, 30.5 * FastMath.PI, 0, +1);      }      @Test     public void testHistoryDecreasingBackward() {          // start point: g > 0         testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,                     0.5 * FastMath.PI, -30.5 * FastMath.PI, 0, -1);          // start point: g = 0         testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,                     0, -30.5 * FastMath.PI, 0, -1);          // start point: g < 0         testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,                     1.5 * FastMath.PI, -30.5 * FastMath.PI, 0, +1);      }      public void testHistory(FilterType type, double t0, double t1, double refSwitch, double signEven) {         Event onlyIncreasing = new Event(false, true);         EventFilter eventFilter =                 new EventFilter(onlyIncreasing, type);         eventFilter.init(t0, new double[] {1.0,  0.0}, t1);          // first pass to set up switches history for a long period         double h = FastMath.copySign(0.05, t1 - t0);         double n = (int) FastMath.floor((t1 - t0) / h);         for (int i = 0; i < n; ++i) {             double t = t0 + i * h;             eventFilter.g(t, new double[] { FastMath.sin(t), FastMath.cos(t) });         }          // verify old events are preserved, even if randomly accessed         UniformRandomProvider rng = RandomSource.create(RandomSource.TWO_CMRES, 0xb0e7401265af8cd3l);         for (int i = 0; i < 5000; i++) {             double t = t0 + (t1 - t0) * rng.nextDouble();             double g = eventFilter.g(t, new double[] { FastMath.sin(t), FastMath.cos(t) });             int turn = (int) FastMath.floor((t - refSwitch) / (2 * FastMath.PI));             if (turn % 2 == 0) {                 Assert.assertEquals( signEven * FastMath.sin(t), g, 1.0e-10);             } else {                 Assert.assertEquals(-signEven * FastMath.sin(t), g, 1.0e-10);             }         }      }      @Test     public void testIncreasingOnly()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double e = 1e-15;         FirstOrderIntegrator integrator;         integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7);         Event allEvents = new Event(true, true);         integrator.addEventHandler(allEvents, 0.1, e, 1000,                                    new BracketingNthOrderBrentSolver(1.0e-7, 5));         Event onlyIncreasing = new Event(false, true);         integrator.addEventHandler(new EventFilter(onlyIncreasing,                                                    FilterType.TRIGGER_ONLY_INCREASING_EVENTS),                                    0.1, e, 100,                                    new BracketingNthOrderBrentSolver(1.0e-7, 5));         double t0 = 0.5 * FastMath.PI;         double tEnd = 5.5 * FastMath.PI;         double[] y = { 0.0, 1.0 };         Assert.assertEquals(tEnd,                             integrator.integrate(new SineCosine(), t0, y, tEnd, y),                             1.0e-7);          Assert.assertEquals(5, allEvents.getEventCount());         Assert.assertEquals(2, onlyIncreasing.getEventCount());      }      @Test     public void testDecreasingOnly()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double e = 1e-15;         FirstOrderIntegrator integrator;         integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7);         Event allEvents = new Event(true, true);         integrator.addEventHandler(allEvents, 0.1, e, 1000,                                    new BracketingNthOrderBrentSolver(1.0e-7, 5));         Event onlyDecreasing = new Event(true, false);         integrator.addEventHandler(new EventFilter(onlyDecreasing,                                                    FilterType.TRIGGER_ONLY_DECREASING_EVENTS),                                    0.1, e, 1000,                                    new BracketingNthOrderBrentSolver(1.0e-7, 5));         double t0 = 0.5 * FastMath.PI;         double tEnd = 5.5 * FastMath.PI;         double[] y = { 0.0, 1.0 };         Assert.assertEquals(tEnd,                             integrator.integrate(new SineCosine(), t0, y, tEnd, y),                             1.0e-7);          Assert.assertEquals(5, allEvents.getEventCount());         Assert.assertEquals(3, onlyDecreasing.getEventCount());      }      @Test     public void testTwoOppositeFilters()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double e = 1e-15;         FirstOrderIntegrator integrator;         integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7);         Event allEvents = new Event(true, true);         integrator.addEventHandler(allEvents, 0.1, e, 1000,                                    new BracketingNthOrderBrentSolver(1.0e-7, 5));         Event onlyIncreasing = new Event(false, true);         integrator.addEventHandler(new EventFilter(onlyIncreasing,                                                    FilterType.TRIGGER_ONLY_INCREASING_EVENTS),                                    0.1, e, 1000,                                    new BracketingNthOrderBrentSolver(1.0e-7, 5));         Event onlyDecreasing = new Event(true, false);         integrator.addEventHandler(new EventFilter(onlyDecreasing,                                                    FilterType.TRIGGER_ONLY_DECREASING_EVENTS),                                    0.1, e, 1000,                                    new BracketingNthOrderBrentSolver(1.0e-7, 5));         double t0 = 0.5 * FastMath.PI;         double tEnd = 5.5 * FastMath.PI;         double[] y = { 0.0, 1.0 };         Assert.assertEquals(tEnd,                             integrator.integrate(new SineCosine(), t0, y, tEnd, y),                             1.0e-7);          Assert.assertEquals(5, allEvents.getEventCount());         Assert.assertEquals(2, onlyIncreasing.getEventCount());         Assert.assertEquals(3, onlyDecreasing.getEventCount());      }      private static class SineCosine implements FirstOrderDifferentialEquations {         @Override         public int getDimension() {             return 2;         }          @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {             yDot[0] =  y[1];             yDot[1] = -y[0];         }     }      /** State events for this unit test. */     protected static class Event implements EventHandler {          private final boolean expectDecreasing;         private final boolean expectIncreasing;         private int eventCount;          public Event(boolean expectDecreasing, boolean expectIncreasing) {             this.expectDecreasing = expectDecreasing;             this.expectIncreasing = expectIncreasing;         }          public int getEventCount() {             return eventCount;         }          @Override         public void init(double t0, double[] y0, double t) {             eventCount = 0;         }          @Override         public double g(double t, double[] y) {             return y[0];         }          @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {             if (increasing) {                 Assert.assertTrue(expectIncreasing);             } else {                 Assert.assertTrue(expectDecreasing);             }             eventCount++;             return Action.RESET_STATE;         }          @Override         public void resetState(double t, double[] y) {             // in fact, we don't really reset anything for this test         }      } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.events;   import org.apache.commons.math4.analysis.solvers.BrentSolver; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ExpandableStatefulODE; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.SecondaryEquations; import org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math4.ode.nonstiff.LutherIntegrator; import org.apache.commons.math4.ode.sampling.AbstractStepInterpolator; import org.apache.commons.math4.ode.sampling.DummyStepInterpolator; import org.junit.Assert; import org.junit.Test;  public class EventStateTest {      // JIRA: MATH-322     @Test     public void closeEvents() throws MaxCountExceededException, NoBracketingException {          final double r1  = 90.0;         final double r2  = 135.0;         final double gap = r2 - r1;          final double tolerance = 0.1;         EventState es = new EventState(new CloseEventsGenerator(r1, r2), 1.5 * gap,                                        tolerance, 100,                                        new BrentSolver(tolerance));         es.setExpandable(new ExpandableStatefulODE(new FirstOrderDifferentialEquations() {             @Override             public int getDimension() {                 return 0;             }             @Override             public void computeDerivatives(double t, double[] y, double[] yDot) {             }         }));          AbstractStepInterpolator interpolator =             new DummyStepInterpolator(new double[0], new double[0], true);         interpolator.storeTime(r1 - 2.5 * gap);         interpolator.shift();         interpolator.storeTime(r1 - 1.5 * gap);         es.reinitializeBegin(interpolator);          interpolator.shift();         interpolator.storeTime(r1 - 0.5 * gap);         Assert.assertFalse(es.evaluateStep(interpolator));          interpolator.shift();         interpolator.storeTime(0.5 * (r1 + r2));         Assert.assertTrue(es.evaluateStep(interpolator));         Assert.assertEquals(r1, es.getEventTime(), tolerance);         es.stepAccepted(es.getEventTime(), new double[0]);          interpolator.shift();         interpolator.storeTime(r2 + 0.4 * gap);         Assert.assertTrue(es.evaluateStep(interpolator));         Assert.assertEquals(r2, es.getEventTime(), tolerance);      }      // Jira: MATH-695     @Test     public void testIssue695()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void computeDerivatives(double t, double[] y, double[] yDot) {                 yDot[0] = 1.0;             }         };          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);         integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);         integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);         integrator.setInitialStepSize(3.0);          double target = 30.0;         double[] y = new double[1];         double tEnd = integrator.integrate(equation, 0.0, y, target, y);         Assert.assertEquals(target, tEnd, 1.0e-10);         Assert.assertEquals(32.0, y[0], 1.0e-10);      }      private static class ResettingEvent implements EventHandler {          private static double lastTriggerTime = Double.NEGATIVE_INFINITY;         private final double tEvent;          public ResettingEvent(final double tEvent) {             this.tEvent = tEvent;         }          @Override         public void init(double t0, double[] y0, double t) {         }          @Override         public double g(double t, double[] y) {             // the bug corresponding to issue 695 causes the g function             // to be called at obsolete times t despite an event             // occurring later has already been triggered.             // When this occurs, the following assertion is violated             Assert.assertTrue("going backward in time! (" + t + " < " + lastTriggerTime + ")",                               t >= lastTriggerTime);             return t - tEvent;         }          @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {             // remember in a class variable when the event was triggered             lastTriggerTime = t;             return Action.RESET_STATE;         }          @Override         public void resetState(double t, double[] y) {             y[0] += 1.0;         }      }      // Jira: MATH-965     @Test     public void testIssue965()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          ExpandableStatefulODE equation =                 new ExpandableStatefulODE(new FirstOrderDifferentialEquations() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void computeDerivatives(double t, double[] y, double[] yDot) {                 yDot[0] = 2.0;             }         });         equation.setTime(0.0);         equation.setPrimaryState(new double[1]);         equation.addSecondaryEquations(new SecondaryEquations() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void computeDerivatives(double t, double[] primary,                                            double[] primaryDot, double[] secondary,                                            double[] secondaryDot) {                 secondaryDot[0] = -3.0;             }         });         int index = equation.getSecondaryMappers()[0].getFirstIndex();          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);         integrator.addEventHandler(new SecondaryStateEvent(index, -3.0), 0.1, 1.0e-9, 1000);         integrator.setInitialStepSize(3.0);          integrator.integrate(equation, 30.0);         Assert.assertEquals( 1.0, equation.getTime(), 1.0e-10);         Assert.assertEquals( 2.0, equation.getPrimaryState()[0], 1.0e-10);         Assert.assertEquals(-3.0, equation.getSecondaryState(0)[0], 1.0e-10);      }      private static class SecondaryStateEvent implements EventHandler {          private int index;         private final double target;          public SecondaryStateEvent(final int index, final double target) {             this.index  = index;             this.target = target;         }          @Override         public void init(double t0, double[] y0, double t) {         }          @Override         public double g(double t, double[] y) {             return y[index] - target;         }          @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {             return Action.STOP;         }          @Override         public void resetState(double t, double[] y) {         }      }      @Test     public void testEventsCloserThanThreshold()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void computeDerivatives(double t, double[] y, double[] yDot) {                 yDot[0] = 1.0;             }         };          LutherIntegrator integrator = new LutherIntegrator(20.0);         CloseEventsGenerator eventsGenerator =                         new CloseEventsGenerator(9.0 - 1.0 / 128, 9.0 + 1.0 / 128);         integrator.addEventHandler(eventsGenerator, 1.0, 0.02, 1000);         double[] y = new double[1];         double tEnd = integrator.integrate(equation, 0.0, y, 100.0, y);         Assert.assertEquals( 2, eventsGenerator.getCount());         Assert.assertEquals( 9.0 + 1.0 / 128, tEnd, 1.0 / 32.0);      }      private class CloseEventsGenerator implements EventHandler {          final double r1;         final double r2;         int count;          public CloseEventsGenerator(final double r1, final double r2) {             this.r1    = r1;             this.r2    = r2;             this.count = 0;         }          @Override         public void init(double t0, double[] y0, double t) {         }          @Override         public void resetState(double t, double[] y) {         }          @Override         public double g(double t, double[] y) {             return (t - r1) * (r2 - t);         }          @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {             return ++count < 2 ? Action.CONTINUE : Action.STOP;         }          public int getCount() {             return count;         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  /**  * This class is used in the junit tests for the ODE integrators.  * <p>This is the same as problem 1 except integration is done  * backward in time</p>  */ public class TestProblem5 extends TestProblem1 {    /**    * Simple constructor.    */     public TestProblem5() {         setFinalConditions(2 * getInitialTime() - getFinalTime());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;  import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class DummyStepInterpolatorTest {    @Test   public void testNoReset() throws MaxCountExceededException {      double[]   y    =   { 0.0, 1.0, -2.0 };     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);     interpolator.storeTime(0);     interpolator.shift();     interpolator.storeTime(1);      double[] result = interpolator.getInterpolatedState();     for (int i = 0; i < result.length; ++i) {       Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);     }    }    @Test   public void testFixedState() throws MaxCountExceededException {      double[]   y    =   { 1.0, 3.0, -4.0 };     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);     interpolator.storeTime(0);     interpolator.shift();     interpolator.storeTime(1);      interpolator.setInterpolatedTime(0.1);     double[] result = interpolator.getInterpolatedState();     for (int i = 0; i < result.length; ++i) {         Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);     }      interpolator.setInterpolatedTime(0.5);     result = interpolator.getInterpolatedState();     for (int i = 0; i < result.length; ++i) {         Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);     }    }    @Test   public void testSerialization()   throws IOException, ClassNotFoundException, MaxCountExceededException {      double[]   y    =   { 0.0, 1.0, -2.0 };     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);     interpolator.storeTime(0);     interpolator.shift();     interpolator.storeTime(1);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     oos.writeObject(interpolator);      Assert.assertTrue(bos.size () > 300);     Assert.assertTrue(bos.size () < 500);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject();      dsi.setInterpolatedTime(0.5);     double[] result = dsi.getInterpolatedState();     for (int i = 0; i < result.length; ++i) {         Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);     }    }    @Test   public void testImpossibleSerialization()   throws IOException {      double[] y = { 0.0, 1.0, -2.0 };     AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true);     interpolator.storeTime(0);     interpolator.shift();     interpolator.storeTime(1);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     try {         oos.writeObject(interpolator);         Assert.fail("an exception should have been thrown");     } catch (LocalException le) {         // expected behavior     }   }    private static class BadStepInterpolator extends DummyStepInterpolator {       public BadStepInterpolator(double[] y, boolean forward) {           super(y, new double[y.length], forward);       }       @Override       protected void doFinalize() {           throw new LocalException();       }   }    private static class LocalException extends RuntimeException {     private static final long serialVersionUID = 1L;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;  import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative;  public class DummyFieldStepInterpolator<T extends RealFieldElement<T>>     extends AbstractFieldStepInterpolator<T> {      public DummyFieldStepInterpolator(final boolean forward,                                       final FieldODEStateAndDerivative<T> globalPreviousState,                                       final FieldODEStateAndDerivative<T> globalCurrentState,                                       final FieldODEStateAndDerivative<T> softPreviousState,                                       final FieldODEStateAndDerivative<T> softCurrentState,                                       final FieldEquationsMapper<T> mapper) {         super(forward, globalPreviousState, globalCurrentState, softPreviousState, softCurrentState, mapper);     }      @Override     protected AbstractFieldStepInterpolator<T> create(final boolean newForward,                                                       final FieldODEStateAndDerivative<T> newGlobalPreviousState,                                                       final FieldODEStateAndDerivative<T> newGlobalCurrentState,                                                       final FieldODEStateAndDerivative<T> newSoftPreviousState,                                                       final FieldODEStateAndDerivative<T> newSoftCurrentState,                                                       final FieldEquationsMapper<T> newMapper) {         return new DummyFieldStepInterpolator<>(newForward,                                                  newGlobalPreviousState, newGlobalCurrentState,                                                  newSoftPreviousState, newSoftCurrentState,                                                  newMapper);     }      @Override     protected FieldODEStateAndDerivative<T> computeInterpolatedStateAndDerivatives(FieldEquationsMapper<T> equationsMapper,                                                                                    T time, T theta, T thetaH, T oneMinusThetaH) {         return getGlobalCurrentState();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math4.util.FastMath; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;   public class StepNormalizerTest {    public StepNormalizerTest() {     pb    = null;     integ = null;   }    @Test   public void testBoundaries()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     double range = pb.getFinalTime() - pb.getInitialTime();     setLastSeen(false);     integ.addStepHandler(new StepNormalizer(range / 10.0,                                        new FixedStepHandler() {                                          private boolean firstCall = true;                                          @Override                                         public void init(double t0, double[] y0, double t) {                                          }                                          @Override                                         public void handleStep(double t,                                                                 double[] y,                                                                 double[] yDot,                                                                 boolean isLast) {                                            if (firstCall) {                                              checkValue(t, pb.getInitialTime());                                              firstCall = false;                                            }                                            if (isLast) {                                              setLastSeen(true);                                              checkValue(t, pb.getFinalTime());                                            }                                          }                                        }));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertTrue(lastSeen);   }    @Test   public void testBeforeEnd()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     final double range = pb.getFinalTime() - pb.getInitialTime();     setLastSeen(false);     integ.addStepHandler(new StepNormalizer(range / 10.5,                                        new FixedStepHandler() {                                          @Override                                         public void init(double t0, double[] y0, double t) {                                          }                                          @Override                                         public void handleStep(double t,                                                                 double[] y,                                                                 double[] yDot,                                                                 boolean isLast) {                                            if (isLast) {                                              setLastSeen(true);                                              checkValue(t,                                                         pb.getFinalTime() - range / 21.0);                                            }                                          }                                        }));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertTrue(lastSeen);   }    public void checkValue(double value, double reference) {     Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10);   }    public void setLastSeen(boolean lastSeen) {     this.lastSeen = lastSeen;   }    @Before   public void setUp() {     pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);     lastSeen = false;   }    @After   public void tearDown() {     pb    = null;     integ = null;   }    TestProblem3 pb;   FirstOrderIntegrator integ;   boolean lastSeen;  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;  import java.io.IOException; import java.io.ObjectInput; import java.io.ObjectOutput;  import org.apache.commons.math4.ode.EquationsMapper;  /** This class is a step interpolator that does nothing.  *  * <p>This class is used when the {@link StepHandler "step handler"}  * set up by the user does not need step interpolation. It does not  * recompute the state when {@link AbstractStepInterpolator#setInterpolatedTime  * setInterpolatedTime} is called. This implies the interpolated state  * is always the state at the end of the current step.</p>  *  * @see StepHandler  *  * @since 1.2  */  public class DummyStepInterpolator   extends AbstractStepInterpolator {    /** Serializable version identifier. */   private static final long serialVersionUID = 1708010296707839488L;    /** Current derivative. */   private double[] currentDerivative;    /** Simple constructor.    * This constructor builds an instance that is not usable yet, the    * <code>AbstractStepInterpolator.reinitialize</code> protected method    * should be called before using the instance in order to initialize    * the internal arrays. This constructor is used only in order to delay    * the initialization in some cases. As an example, the {@link    * org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator} uses    * the prototyping design pattern to create the step interpolators by    * cloning an uninitialized model and latter initializing the copy.    */   public DummyStepInterpolator() {     super();     currentDerivative = null;   }    /** Simple constructor.    * @param y reference to the integrator array holding the state at    * the end of the step    * @param yDot reference to the integrator array holding the state    * derivative at some arbitrary point within the step    * @param forward integration direction indicator    */   public DummyStepInterpolator(final double[] y, final double[] yDot, final boolean forward) {     super(y, forward, new EquationsMapper(0, y.length), new EquationsMapper[0]);     currentDerivative = yDot;   }    /** Copy constructor.    * @param interpolator interpolator to copy from. The copy is a deep    * copy: its arrays are separated from the original arrays of the    * instance    */   public DummyStepInterpolator(final DummyStepInterpolator interpolator) {     super(interpolator);     if (interpolator.currentDerivative != null) {         currentDerivative = interpolator.currentDerivative.clone();     }   }    /** Really copy the finalized instance.    * @return a copy of the finalized instance    */   @Override   protected StepInterpolator doCopy() {     return new DummyStepInterpolator(this);   }    /** Compute the state at the interpolated time.    * In this class, this method does nothing: the interpolated state    * is always the state at the end of the current step.    * @param theta normalized interpolation abscissa within the step    * (theta is zero at the previous time step and one at the current time step)    * @param oneMinusThetaH time gap between the interpolated time and    * the current time    */   @Override   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {       System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);   }    /** Write the instance to an output channel.    * @param out output channel    * @exception IOException if the instance cannot be written    */   @Override   public void writeExternal(final ObjectOutput out)     throws IOException {        // save the state of the base class     writeBaseExternal(out);      if (currentDerivative != null) {         for (int i = 0; i < currentDerivative.length; ++i) {             out.writeDouble(currentDerivative[i]);         }     }    }    /** Read the instance from an input channel.    * @param in input channel    * @exception IOException if the instance cannot be read    */   @Override   public void readExternal(final ObjectInput in)     throws IOException, ClassNotFoundException {      // read the base class     final double t = readBaseExternal(in);      if (currentState == null) {         currentDerivative = null;     } else {         currentDerivative  = new double[currentState.length];         for (int i = 0; i < currentDerivative.length; ++i) {             currentDerivative[i] = in.readDouble();         }     }      // we can now set the interpolated time and state     setInterpolatedTime(t);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;  import org.junit.Assert;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator; import org.junit.Test;  /** Base class for step normalizer output tests. */ public abstract class StepNormalizerOutputTestBase     implements FirstOrderDifferentialEquations, FixedStepHandler {      /** The normalized output time values. */     private List<Double> output;      /**      * Returns the start time.      * @return the start time      */     protected abstract double getStart();      /**      * Returns the end time.      * @return the end time      */     protected abstract double getEnd();      /**      * Returns the expected normalized output time values for increment mode.      * @return the expected normalized output time values for increment mode      */     protected abstract double[] getExpInc();      /**      * Returns the expected reversed normalized output time values for      * increment mode.      * @return the expected reversed normalized output time values for      * increment mode      */     protected abstract double[] getExpIncRev();      /**      * Returns the expected normalized output time values for multiples mode.      * @return the expected normalized output time values for multiples mode      */     protected abstract double[] getExpMul();      /**      * Returns the expected reversed normalized output time values for      * multiples mode.      * @return the expected reversed normalized output time values for      * multiples mode      */     protected abstract double[] getExpMulRev();      /**      * Returns the offsets for the unit tests below, in the order they are      * given below. For each test, the left and right offsets are returned.      * @return the offsets for the unit tests below, in the order they are      * given below      */     protected abstract int[][] getO();      /**      * Get the array, given left and right offsets.      * @param a the input array      * @param offsetL the left side offset      * @param offsetR the right side offset      * @return the modified array      */     private double[] getArray(double[] a, int offsetL, int offsetR) {         double[] copy = new double[a.length - offsetR - offsetL];         System.arraycopy(a, offsetL, copy, 0, copy.length);         return copy;     }      @Test     public void testIncNeither()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpInc(), getO()[0][0], getO()[0][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.NEITHER, exp, false);     }      @Test     public void testIncNeitherRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpIncRev(), getO()[1][0], getO()[1][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.NEITHER, exp, true);     }      @Test     public void testIncFirst()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpInc(), getO()[2][0], getO()[2][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.FIRST, exp, false);     }      @Test     public void testIncFirstRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpIncRev(), getO()[3][0], getO()[3][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.FIRST, exp, true);     }      @Test     public void testIncLast()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpInc(), getO()[4][0], getO()[4][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.LAST, exp, false);     }      @Test     public void testIncLastRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpIncRev(), getO()[5][0], getO()[5][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.LAST, exp, true);     }      @Test     public void testIncBoth()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpInc(), getO()[6][0], getO()[6][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.BOTH, exp, false);     }      @Test     public void testIncBothRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpIncRev(), getO()[7][0], getO()[7][1]);         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.BOTH, exp, true);     }      @Test     public void testMulNeither()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMul(), getO()[8][0], getO()[8][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.NEITHER, exp, false);     }      @Test     public void testMulNeitherRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMulRev(), getO()[9][0], getO()[9][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.NEITHER, exp, true);     }      @Test     public void testMulFirst()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMul(), getO()[10][0], getO()[10][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.FIRST, exp, false);     }      @Test     public void testMulFirstRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMulRev(), getO()[11][0], getO()[11][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.FIRST, exp, true);     }      @Test     public void testMulLast()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMul(), getO()[12][0], getO()[12][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.LAST, exp, false);     }      @Test     public void testMulLastRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMulRev(), getO()[13][0], getO()[13][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.LAST, exp, true);     }      @Test     public void testMulBoth()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMul(), getO()[14][0], getO()[14][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.BOTH, exp, false);     }      @Test     public void testMulBothRev()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         double[] exp = getArray(getExpMulRev(), getO()[15][0], getO()[15][1]);         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.BOTH, exp, true);     }      /**      * The actual step normalizer output test code, shared by all the unit      * tests.      *      * @param mode the step normalizer mode to use      * @param bounds the step normalizer bounds setting to use      * @param expected the expected output (normalized time points)      * @param reverse whether to reverse the integration direction      * @throws NoBracketingException      * @throws MaxCountExceededException      * @throws NumberIsTooSmallException      * @throws DimensionMismatchException      */     private void doTest(StepNormalizerMode mode, StepNormalizerBounds bounds,                         double[] expected, boolean reverse)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         // Forward test.         FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(                                                         1e-8, 1.0, 1e-5, 1e-5);         integ.addStepHandler(new StepNormalizer(0.5, this, mode, bounds));         double[] y   = {0.0};         double start = reverse ? getEnd()   : getStart();         double end   = reverse ? getStart() : getEnd();         output       = new ArrayList<>();         integ.integrate(this, start, y, end, y);         double[] actual = new double[output.size()];         for(int i = 0; i < actual.length; i++) {             actual[i] = output.get(i);         }         Assert.assertArrayEquals(expected, actual, 1e-5);     }      /** {@inheritDoc} */     @Override     public int getDimension() {         return 1;     }      /** {@inheritDoc} */     @Override     public void computeDerivatives(double t, double[] y, double[] yDot) {         yDot[0] = y[0];     }      /** {@inheritDoc} */     @Override     public void init(double t0, double[] y0, double t) {     }      /** {@inheritDoc} */     @Override     public void handleStep(double t, double[] y, double[] yDot, boolean isLast) {         output.add(t);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;  /** Step normalizer output tests, for problems where the first and last points  * are not fixed points.  */ public class StepNormalizerOutputTest extends StepNormalizerOutputTestBase {     @Override     protected double getStart() {         return 0.3;     }      @Override     protected double getEnd() {         return 10.1;     }      @Override     protected double[] getExpInc() {         return new double[] { 0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.3, 3.8, 4.3,                               4.8, 5.3, 5.8, 6.3, 6.8, 7.3, 7.8, 8.3, 8.8,                               9.3, 9.8, 10.1 };     }      @Override     protected double[] getExpIncRev() {         return new double[] { 10.1, 9.6, 9.1, 8.6, 8.1, 7.6, 7.1, 6.6,                               6.1, 5.6, 5.1, 4.6, 4.1, 3.6, 3.1, 2.6,                               2.1, 1.6, 1.1, 0.6, 0.3 };     }      @Override     protected double[] getExpMul() {         return new double[] { 0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,                               4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,                               9.0, 9.5, 10.0, 10.1 };     }      @Override     protected double[] getExpMulRev() {         return new double[] { 10.1, 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0,                               6.5, 6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,                               2.0, 1.5, 1.0, 0.5, 0.3 };     }      @Override     protected int[][] getO() {         return new int[][] {{1, 1}, {1, 1}, {0, 1}, {0, 1},                             {1, 0}, {1, 0}, {0, 0}, {0, 0},                             {1, 1}, {1, 1}, {0, 1}, {0, 1},                             {1, 0}, {1, 0}, {0, 0}, {0, 0}};     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.nonstiff.AdamsBashforthIntegrator; import org.junit.Assert; import org.junit.Test;  public class NordsieckStepInterpolatorTest {      @Test     public void derivativesConsistency()         throws NumberIsTooSmallException, DimensionMismatchException,                MaxCountExceededException, NoBracketingException {         TestProblem3 pb = new TestProblem3();         AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);         StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.05, 2.8e-9);     }      @Test     public void serialization()     throws IOException, ClassNotFoundException,            NumberIsTooSmallException, DimensionMismatchException,            MaxCountExceededException, NoBracketingException {          TestProblem1 pb = new TestProblem1();         AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);         integ.addStepHandler(new ContinuousOutputModel());         integ.integrate(pb,                         pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);          ByteArrayOutputStream bos = new ByteArrayOutputStream();         ObjectOutputStream    oos = new ObjectOutputStream(bos);         for (StepHandler handler : integ.getStepHandlers()) {             oos.writeObject(handler);         }          Assert.assertTrue(bos.size() > 47000);         Assert.assertTrue(bos.size() < 48000);          ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());         ObjectInputStream     ois = new ObjectInputStream(bis);         ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();          Random random = new Random(347588535632l);         double maxError = 0.0;         for (int i = 0; i < 1000; ++i) {             double r = random.nextDouble();             double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();             cm.setInterpolatedTime(time);             double[] interpolatedY = cm.getInterpolatedState();             double[] theoreticalY  = pb.computeTheoreticalState(time);             double dx = interpolatedY[0] - theoreticalY[0];             double dy = interpolatedY[1] - theoreticalY[1];             double error = dx * dx + dy * dy;             if (error > maxError) {                 maxError = error;             }         }          Assert.assertTrue(maxError < 1.0e-6);      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.sampling;  /** Step normalizer output tests, for problems where the first and last points  * are overlap fixed points.  */ public class StepNormalizerOutputOverlapTest extends StepNormalizerOutputTestBase {     @Override     protected double getStart() {         return 0.0;     }      @Override     protected double getEnd() {         return 10.0;     }      @Override     protected double[] getExpInc() {         return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,                               4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,                               9.0, 9.5, 10.0 };     }      @Override     protected double[] getExpIncRev() {         return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5,                               6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,                               2.0, 1.5, 1.0, 0.5, 0.0 };     }      @Override     protected double[] getExpMul() {         return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,                               4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,                               9.0, 9.5, 10.0 };     }      @Override     protected double[] getExpMulRev() {         return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5,                               6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,                               2.0, 1.5, 1.0, 0.5, 0.0 };     }      @Override     protected int[][] getO() {         return new int[][] {{1, 0}, {1, 0}, {0, 0}, {0, 0},                             {1, 0}, {1, 0}, {0, 0}, {0, 0},                             {1, 0}, {1, 0}, {0, 0}, {0, 0},                             {1, 0}, {1, 0}, {0, 0}, {0, 0}};     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.ode.sampling;   import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FieldExpandableODE; import org.apache.commons.math4.ode.FirstOrderFieldIntegrator; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestFieldProblemAbstract; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.util.FastMath; import org.junit.Assert;  public class StepInterpolatorTestUtils {      public static void checkDerivativesConsistency(final FirstOrderIntegrator integrator,                                                    final TestProblemAbstract problem,                                                    final double finiteDifferencesRatio,                                                    final double threshold)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         integrator.addStepHandler(new StepHandler() {              @Override             public void handleStep(StepInterpolator interpolator, boolean isLast)                 throws MaxCountExceededException {                  final double dt = interpolator.getCurrentTime() - interpolator.getPreviousTime();                 final double h  = finiteDifferencesRatio * dt;                 final double t  = interpolator.getCurrentTime() - 0.3 * dt;                  if (FastMath.abs(h) < 10 * FastMath.ulp(t)) {                     return;                 }                  interpolator.setInterpolatedTime(t - 4 * h);                 final double[] yM4h = interpolator.getInterpolatedState().clone();                 interpolator.setInterpolatedTime(t - 3 * h);                 final double[] yM3h = interpolator.getInterpolatedState().clone();                 interpolator.setInterpolatedTime(t - 2 * h);                 final double[] yM2h = interpolator.getInterpolatedState().clone();                 interpolator.setInterpolatedTime(t - h);                 final double[] yM1h = interpolator.getInterpolatedState().clone();                 interpolator.setInterpolatedTime(t + h);                 final double[] yP1h = interpolator.getInterpolatedState().clone();                 interpolator.setInterpolatedTime(t + 2 * h);                 final double[] yP2h = interpolator.getInterpolatedState().clone();                 interpolator.setInterpolatedTime(t + 3 * h);                 final double[] yP3h = interpolator.getInterpolatedState().clone();                 interpolator.setInterpolatedTime(t + 4 * h);                 final double[] yP4h = interpolator.getInterpolatedState().clone();                  interpolator.setInterpolatedTime(t);                 final double[] yDot = interpolator.getInterpolatedDerivatives();                  for (int i = 0; i < yDot.length; ++i) {                     final double approYDot = ( -3 * (yP4h[i] - yM4h[i]) +                                                32 * (yP3h[i] - yM3h[i]) +                                              -168 * (yP2h[i] - yM2h[i]) +                                               672 * (yP1h[i] - yM1h[i])) / (840 * h);                     Assert.assertEquals("" + (approYDot - yDot[i]), approYDot, yDot[i], threshold);                 }              }              @Override             public void init(double t0, double[] y0, double t) {             }          });          integrator.integrate(problem,                              problem.getInitialTime(), problem.getInitialState(),                              problem.getFinalTime(), new double[problem.getDimension()]);      }      public static <T extends RealFieldElement<T>> void checkDerivativesConsistency(final FirstOrderFieldIntegrator<T> integrator,                                                                                    final TestFieldProblemAbstract<T> problem,                                                                                    final double threshold) {         integrator.addStepHandler(new FieldStepHandler<T>() {              @Override             public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast)                 throws MaxCountExceededException {                  final T h = interpolator.getCurrentState().getTime().subtract(interpolator.getPreviousState().getTime()).multiply(0.001);                 final T t = interpolator.getCurrentState().getTime().subtract(h.multiply(300));                  if (h.abs().subtract(FastMath.ulp(t.getReal()) * 10).getReal() < 0) {                     return;                 }                  final T[] yM4h = interpolator.getInterpolatedState(t.add(h.multiply(-4))).getState();                 final T[] yM3h = interpolator.getInterpolatedState(t.add(h.multiply(-3))).getState();                 final T[] yM2h = interpolator.getInterpolatedState(t.add(h.multiply(-2))).getState();                 final T[] yM1h = interpolator.getInterpolatedState(t.add(h.multiply(-1))).getState();                 final T[] yP1h = interpolator.getInterpolatedState(t.add(h.multiply( 1))).getState();                 final T[] yP2h = interpolator.getInterpolatedState(t.add(h.multiply( 2))).getState();                 final T[] yP3h = interpolator.getInterpolatedState(t.add(h.multiply( 3))).getState();                 final T[] yP4h = interpolator.getInterpolatedState(t.add(h.multiply( 4))).getState();                  final T[] yDot = interpolator.getInterpolatedState(t).getDerivative();                  for (int i = 0; i < yDot.length; ++i) {                     final T approYDot =     yP4h[i].subtract(yM4h[i]).multiply(  -3).                                         add(yP3h[i].subtract(yM3h[i]).multiply(  32)).                                         add(yP2h[i].subtract(yM2h[i]).multiply(-168)).                                         add(yP1h[i].subtract(yM1h[i]).multiply( 672)).                                         divide(h.multiply(840));                     Assert.assertEquals(approYDot.getReal(), yDot[i].getReal(), threshold);                 }              }              @Override             public void init(FieldODEStateAndDerivative<T> state0, T t) {             }          });          integrator.integrate(new FieldExpandableODE<>(problem), problem.getInitialState(), problem.getFinalTime());      } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;  import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.events.EventHandler;   public class StepProblem   implements FirstOrderDifferentialEquations, EventHandler {    public StepProblem(double rateBefore, double rateAfter,                      double switchTime) {     this.rateAfter  = rateAfter;     this.switchTime = switchTime;     setRate(rateBefore);   }    @Override public void computeDerivatives(double t, double[] y, double[] yDot) {     yDot[0] = rate;   }    @Override public int getDimension() {     return 1;   }    public void setRate(double rate) {     this.rate = rate;   }    @Override public void init(double t0, double[] y0, double t) {   }    @Override public Action eventOccurred(double t, double[] y, boolean increasing) {     setRate(rateAfter);     return Action.RESET_DERIVATIVES;   }    @Override public double g(double t, double[] y) {     return t - switchTime;   }    @Override public void resetState(double t, double[] y) {   }    private double rate;   private double rateAfter;   private double switchTime;  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class GraggBulirschStoerStepInterpolatorTest {    @Test   public void derivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3(0.9);     double minStep   = 0;     double maxStep   = pb.getFinalTime() - pb.getInitialTime();     double absTolerance = 1.0e-8;     double relTolerance = 1.0e-8;      GraggBulirschStoerIntegrator integ =       new GraggBulirschStoerIntegrator(minStep, maxStep,                                        absTolerance, relTolerance);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 5.9e-10);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException {      TestProblem3 pb  = new TestProblem3(0.9);     double minStep   = 0;     double maxStep   = pb.getFinalTime() - pb.getInitialTime();     double absTolerance = 1.0e-8;     double relTolerance = 1.0e-8;      GraggBulirschStoerIntegrator integ =       new GraggBulirschStoerIntegrator(minStep, maxStep,                                        absTolerance, relTolerance);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 35000);     Assert.assertTrue(bos.size () < 36000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError < 5.0e-10);    }    @Test   public void checklone()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                           scalAbsoluteTolerance,                                                                           scalRelativeTolerance);     integ.addStepHandler(new StepHandler() {         @Override         public void handleStep(StepInterpolator interpolator, boolean isLast)             throws MaxCountExceededException {             StepInterpolator cloned = interpolator.copy();             double tA = cloned.getPreviousTime();             double tB = cloned.getCurrentTime();             double halfStep = FastMath.abs(tB - tA) / 2;             Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);             Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);             for (int i = 0; i < 10; ++i) {                 double t = (i * tB + (9 - i) * tA) / 9;                 interpolator.setInterpolatedTime(t);                 Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                 cloned.setInterpolatedTime(t);                 Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                 double[] referenceState = interpolator.getInterpolatedState();                 double[] cloneState     = cloned.getInterpolatedState();                 for (int j = 0; j < referenceState.length; ++j) {                     Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                 }             }         }         @Override         public void init(double t0, double[] y0, double t) {         }     });     integ.integrate(pb,             pb.getInitialTime(), pb.getInitialState(),             pb.getFinalTime(), new double[pb.getDimension()]);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem2; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class ThreeEighthesIntegratorTest {    @Test(expected=DimensionMismatchException.class)   public void testDimensionCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       new ThreeEighthesIntegrator(0.01).integrate(pb,                                                   0.0, new double[pb.getDimension()+10],                                                   1.0, new double[pb.getDimension()+10]);         Assert.fail("an exception should have been thrown");   }    @Test   public void testDecreasingSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        for (TestProblemAbstract pb : new TestProblemAbstract[] {           new TestProblem1(), new TestProblem2(), new TestProblem3(),           new TestProblem4(), new TestProblem5(), new TestProblem6()       }) {        double previousValueError = Double.NaN;       double previousTimeError = Double.NaN;       for (int i = 4; i < 10; ++i) {          double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);          FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         EventHandler[] functions = pb.getEventsHandlers();         for (int l = 0; l < functions.length; ++l) {           integ.addEventHandler(functions[l],                                      Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);         }         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                           pb.getFinalTime(), new double[pb.getDimension()]);         if (functions.length == 0) {             Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);         }          double error = handler.getMaximalValueError();         if (i > 4) {           Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError));         }         previousValueError = error;          double timeError = handler.getMaximalTimeError();         if (i > 4) {           Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));         }         previousTimeError = timeError;        }      }    }   @Test  public void testSmallStep()      throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 2.0e-13);     Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);     Assert.assertEquals("3/8", integ.getName());    }    @Test   public void testBigStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() > 0.0004);     Assert.assertTrue(handler.getMaximalValueError() > 0.005);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 5.0e-10);       Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("3/8", integ.getName());   }    @Test   public void testKepler()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);     integ.addStepHandler(new KeplerHandler(pb));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);   }    private static class KeplerHandler implements StepHandler {      public KeplerHandler(TestProblem3 pb) {       this.pb = pb;       maxError = 0;     }      @Override     public void init(double t0, double[] y0, double t) {       maxError = 0;     }      @Override     public void handleStep(StepInterpolator interpolator, boolean isLast)         throws MaxCountExceededException {        double[] interpolatedY = interpolator.getInterpolatedState();       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }       if (isLast) {         // even with more than 1000 evaluations per period,         // RK4 is not able to integrate such an eccentric         // orbit with a good accuracy         Assert.assertTrue(maxError > 0.005);       }     }      private TestProblem3 pb;     private double maxError = 0;    }    @Test   public void testStepSize()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final double step = 1.23456;       FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);       integ.addStepHandler(new StepHandler() {           @Override         public void handleStep(StepInterpolator interpolator, boolean isLast) {               if (! isLast) {                   Assert.assertEquals(step,                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),                                1.0e-12);               }           }           @Override         public void init(double t0, double[] y0, double t) {           }       });       integ.integrate(new FirstOrderDifferentialEquations() {           @Override         public void computeDerivatives(double t, double[] y, double[] dot) {               dot[0] = 1.0;           }           @Override         public int getDimension() {               return 1;           }       }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FieldExpandableODE; import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderFieldIntegrator; import org.apache.commons.math4.ode.FieldODEState; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.TestFieldProblem1; import org.apache.commons.math4.ode.TestFieldProblem3; import org.apache.commons.math4.ode.TestFieldProblem4; import org.apache.commons.math4.ode.TestFieldProblem5; import org.apache.commons.math4.ode.TestFieldProblemHandler; import org.apache.commons.math4.ode.events.Action; import org.apache.commons.math4.ode.events.FieldEventHandler; import org.apache.commons.math4.ode.sampling.FieldStepHandler; import org.apache.commons.math4.ode.sampling.FieldStepInterpolator; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  public abstract class AbstractEmbeddedRungeKuttaFieldIntegratorTest {      protected abstract <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance);      protected abstract <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance);      @Test     public abstract void testNonFieldIntegratorConsistency();      protected <T extends RealFieldElement<T>> void doTestNonFieldIntegratorConsistency(final Field<T> field) {         try {              // get the Butcher arrays from the field integrator             EmbeddedRungeKuttaFieldIntegrator<T> fieldIntegrator = createIntegrator(field, 0.001, 1.0, 1.0, 1.0);             T[][] fieldA = fieldIntegrator.getA();             T[]   fieldB = fieldIntegrator.getB();             T[]   fieldC = fieldIntegrator.getC();             if (fieldIntegrator instanceof DormandPrince853FieldIntegrator) {                 // special case for Dormand-Prince 8(5,3), the array in the regular                 // integrator is smaller because as of 3.X, the interpolation steps                 // are not performed by the integrator itself                 T[][] reducedFieldA = MathArrays.buildArray(field, 12, -1);                 T[]   reducedFieldB = MathArrays.buildArray(field, 13);                 T[]   reducedFieldC = MathArrays.buildArray(field, 12);                 System.arraycopy(fieldA, 0, reducedFieldA, 0, reducedFieldA.length);                 System.arraycopy(fieldB, 0, reducedFieldB, 0, reducedFieldB.length);                 System.arraycopy(fieldC, 0, reducedFieldC, 0, reducedFieldC.length);                 fieldA = reducedFieldA;                 fieldB = reducedFieldB;                 fieldC = reducedFieldC;             }              String fieldName   = fieldIntegrator.getClass().getName();             String regularName = fieldName.replaceAll("Field", "");              // get the Butcher arrays from the regular integrator             @SuppressWarnings("unchecked")             Class<RungeKuttaIntegrator> c = (Class<RungeKuttaIntegrator>) Class.forName(regularName);             java.lang.reflect.Field jlrFieldA = c.getDeclaredField("STATIC_A");             jlrFieldA.setAccessible(true);             double[][] regularA = (double[][]) jlrFieldA.get(null);             java.lang.reflect.Field jlrFieldB = c.getDeclaredField("STATIC_B");             jlrFieldB.setAccessible(true);             double[]   regularB = (double[])   jlrFieldB.get(null);             java.lang.reflect.Field jlrFieldC = c.getDeclaredField("STATIC_C");             jlrFieldC.setAccessible(true);             double[]   regularC = (double[])   jlrFieldC.get(null);              Assert.assertEquals(regularA.length, fieldA.length);             for (int i = 0; i < regularA.length; ++i) {                 checkArray(regularA[i], fieldA[i]);             }             checkArray(regularB, fieldB);             checkArray(regularC, fieldC);          } catch (ClassNotFoundException cnfe) {             Assert.fail(cnfe.getLocalizedMessage());         } catch (IllegalAccessException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (IllegalArgumentException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (SecurityException se) {             Assert.fail(se.getLocalizedMessage());         } catch (NoSuchFieldException nsfe) {             Assert.fail(nsfe.getLocalizedMessage());         }     }      private <T extends RealFieldElement<T>> void checkArray(double[] regularArray, T[] fieldArray) {         Assert.assertEquals(regularArray.length, fieldArray.length);         for (int i = 0; i < regularArray.length; ++i) {             if (regularArray[i] == 0) {                 Assert.assertTrue(0.0 == fieldArray[i].getReal());             } else {                 Assert.assertEquals(regularArray[i], fieldArray[i].getReal(), FastMath.ulp(regularArray[i]));             }         }     }      @Test     public abstract void testForwardBackwardExceptions();      protected <T extends RealFieldElement<T>> void doTestForwardBackwardExceptions(final Field<T> field) {         FirstOrderFieldDifferentialEquations<T> equations = new FirstOrderFieldDifferentialEquations<T>() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void init(T t0, T[] y0, T t) {             }              @Override             public T[] computeDerivatives(T t, T[] y) {                 if (t.getReal() < -0.5) {                     throw new LocalException();                 } else {                     throw new RuntimeException("oops");                 }             }         };          EmbeddedRungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, 0.0, 1.0, 1.0e-10, 1.0e-10);          try  {             integrator.integrate(new FieldExpandableODE<>(equations),                                  new FieldODEState<>(field.getOne().negate(),                                                       MathArrays.buildArray(field, 1)),                                  field.getZero());             Assert.fail("an exception should have been thrown");           } catch(LocalException de) {             // expected behavior           }            try  {               integrator.integrate(new FieldExpandableODE<>(equations),                                    new FieldODEState<>(field.getZero(),                                                         MathArrays.buildArray(field, 1)),                                    field.getOne());                Assert.fail("an exception should have been thrown");           } catch(RuntimeException de) {             // expected behavior           }     }      protected static class LocalException extends RuntimeException {         private static final long serialVersionUID = 20151208L;     }      @Test(expected=NumberIsTooSmallException.class)     public abstract void testMinStep();      protected <T extends RealFieldElement<T>> void doTestMinStep(final Field<T> field)         throws NumberIsTooSmallException {          TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         double minStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.1).getReal();         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };         double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               vecAbsoluteTolerance, vecRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());         Assert.fail("an exception should have been thrown");      }      @Test     public abstract void testIncreasingTolerance();      protected <T extends RealFieldElement<T>> void doTestIncreasingTolerance(final Field<T> field,                                                                              double factor,                                                                              double epsilon) {          int previousCalls = Integer.MAX_VALUE;         for (int i = -12; i < -2; ++i) {             TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);             double minStep = 0;             double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();             double scalAbsoluteTolerance = FastMath.pow(10.0, i);             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;              FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                                   scalAbsoluteTolerance, scalRelativeTolerance);             TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);             integ.addStepHandler(handler);             integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());              Assert.assertTrue(handler.getMaximalValueError().getReal() < (factor * scalAbsoluteTolerance));             Assert.assertEquals(0, handler.getMaximalTimeError().getReal(), epsilon);              int calls = pb.getCalls();             Assert.assertEquals(integ.getEvaluations(), calls);             Assert.assertTrue(calls <= previousCalls);             previousCalls = calls;          }      }      @Test     public abstract void testEvents();      protected <T extends RealFieldElement<T>> void doTestEvents(final Field<T> field,                                                                 final double epsilonMaxValue,                                                                 final String name) {        TestFieldProblem4<T> pb = new TestFieldProblem4<>(field);       double minStep = 0;       double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                             scalAbsoluteTolerance, scalRelativeTolerance);       TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);       integ.addStepHandler(handler);       FieldEventHandler<T>[] functions = pb.getEventsHandlers();       double convergence = 1.0e-8 * maxStep;       for (int l = 0; l < functions.length; ++l) {           integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);       }       Assert.assertEquals(functions.length, integ.getEventHandlers().size());       integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());        Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);       Assert.assertEquals(0, handler.getMaximalTimeError().getReal(), convergence);       Assert.assertEquals(12.0, handler.getLastTime().getReal(), convergence);       Assert.assertEquals(name, integ.getName());       integ.clearEventHandlers();       Assert.assertEquals(0, integ.getEventHandlers().size());      }      @Test(expected=LocalException.class)     public abstract void testEventsErrors();      protected <T extends RealFieldElement<T>> void doTestEventsErrors(final Field<T> field)         throws LocalException {         final TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double scalAbsoluteTolerance = 1.0e-8;         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               scalAbsoluteTolerance, scalRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);          integ.addEventHandler(new FieldEventHandler<T>() {           @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {           }           @Override         public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {             return Action.CONTINUE;           }           @Override         public T g(FieldODEStateAndDerivative<T> state) {             T middle = pb.getInitialState().getTime().add(pb.getFinalTime()).multiply(0.5);             T offset = state.getTime().subtract(middle);             if (offset.getReal() > 0) {               throw new LocalException();             }             return offset;           }           @Override         public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {               return state;           }         }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);          integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());      }      @Test     public abstract void testEventsNoConvergence();      protected <T extends RealFieldElement<T>> void doTestEventsNoConvergence(final Field<T> field){          final TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double scalAbsoluteTolerance = 1.0e-8;         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               scalAbsoluteTolerance, scalRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);          integ.addEventHandler(new FieldEventHandler<T>() {             @Override             public void init(FieldODEStateAndDerivative<T> state0, T t) {             }             @Override             public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {                 return Action.CONTINUE;             }             @Override             public T g(FieldODEStateAndDerivative<T> state) {                 T middle = pb.getInitialState().getTime().add(pb.getFinalTime()).multiply(0.5);                 T offset = state.getTime().subtract(middle);                 return (offset.getReal() > 0) ? offset.add(0.5) : offset.subtract(0.5);             }             @Override             public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {                 return state;             }         }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);          try {             integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());             Assert.fail("an exception should have been thrown");         } catch (MaxCountExceededException mcee) {             // Expected.         }      }      @Test     public abstract void testSanityChecks();      protected <T extends RealFieldElement<T>> void doTestSanityChecks(Field<T> field) {         TestFieldProblem3<T> pb = new TestFieldProblem3<>(field);         try  {             EmbeddedRungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, 0,                                                                                pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),                                                                                new double[4], new double[4]);             integrator.integrate(new FieldExpandableODE<>(pb),                                  new FieldODEState<>(pb.getInitialState().getTime(),                                                       MathArrays.buildArray(field, 6)),                                  pb.getFinalTime());             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             EmbeddedRungeKuttaFieldIntegrator<T> integrator =                             createIntegrator(field, 0,                                              pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),                                              new double[2], new double[4]);             integrator.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             EmbeddedRungeKuttaFieldIntegrator<T> integrator =                             createIntegrator(field, 0,                                              pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),                                              new double[4], new double[4]);             integrator.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getInitialState().getTime());             Assert.fail("an exception should have been thrown");         } catch(NumberIsTooSmallException ie) {         }     }      @Test     public abstract void testBackward();      protected <T extends RealFieldElement<T>> void doTestBackward(Field<T> field,                                                                   final double epsilonLast,                                                                   final double epsilonMaxValue,                                                                   final double epsilonMaxTime,                                                                   final String name)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          TestFieldProblem5<T> pb = new TestFieldProblem5<>(field);         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).abs().getReal();         double scalAbsoluteTolerance = 1.0e-8;         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;          EmbeddedRungeKuttaFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                                       scalAbsoluteTolerance,                                                                       scalRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);         Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testKepler();      protected <T extends RealFieldElement<T>> void doTestKepler(Field<T> field, double epsilon) {          final TestFieldProblem3<T> pb  = new TestFieldProblem3<>(field, field.getZero().add(0.9));         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };         double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               vecAbsoluteTolerance, vecRelativeTolerance);         integ.addStepHandler(new KeplerHandler<>(pb, epsilon));         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());     }      private static class KeplerHandler<T extends RealFieldElement<T>> implements FieldStepHandler<T> {         private T maxError;         private final TestFieldProblem3<T> pb;         private final double epsilon;         public KeplerHandler(TestFieldProblem3<T> pb, double epsilon) {             this.pb      = pb;             this.epsilon = epsilon;             maxError = pb.getField().getZero();         }         @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {             maxError = pb.getField().getZero();         }         @Override         public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast)                         throws MaxCountExceededException {              FieldODEStateAndDerivative<T> current = interpolator.getCurrentState();             T[] theoreticalY  = pb.computeTheoreticalState(current.getTime());             T dx = current.getState()[0].subtract(theoreticalY[0]);             T dy = current.getState()[1].subtract(theoreticalY[1]);             T error = dx.multiply(dx).add(dy.multiply(dy));             if (error.subtract(maxError).getReal() > 0) {                 maxError = error;             }             if (isLast) {                 Assert.assertEquals(0.0, maxError.getReal(), epsilon);             }         }     }      @Test     public abstract void testPartialDerivatives();      protected <T extends RealFieldElement<T>> void doTestPartialDerivatives(final double epsilonY,                                                                             final double[] epsilonPartials) {          // parameters indices         final int parameters = 5;         final int order      = 1;         final int parOmega   = 0;         final int parTO      = 1;         final int parY00     = 2;         final int parY01     = 3;         final int parT       = 4;          DerivativeStructure omega = new DerivativeStructure(parameters, order, parOmega, 1.3);         DerivativeStructure t0    = new DerivativeStructure(parameters, order, parTO, 1.3);         DerivativeStructure[] y0  = new DerivativeStructure[] {             new DerivativeStructure(parameters, order, parY00, 3.0),             new DerivativeStructure(parameters, order, parY01, 4.0)         };         DerivativeStructure t     = new DerivativeStructure(parameters, order, parT, 6.0);         SinCos sinCos = new SinCos(omega);          EmbeddedRungeKuttaFieldIntegrator<DerivativeStructure> integrator =                         createIntegrator(omega.getField(),                                          t.subtract(t0).multiply(0.001).getReal(), t.subtract(t0).getReal(),                                          1.0e-12, 1.0e-12);         FieldODEStateAndDerivative<DerivativeStructure> result =                         integrator.integrate(new FieldExpandableODE<>(sinCos),                                              new FieldODEState<>(t0, y0),                                              t);          // check values         for (int i = 0; i < sinCos.getDimension(); ++i) {             Assert.assertEquals(sinCos.theoreticalY(t.getReal())[i], result.getState()[i].getValue(), epsilonY);         }          // check derivatives         final double[][] derivatives = sinCos.getDerivatives(t.getReal());          for (int i = 0; i < sinCos.getDimension(); ++i) {             for (int parameter = 0; parameter < parameters; ++parameter) {                 Assert.assertEquals(derivatives[i][parameter], dYdP(result.getState()[i], parameter), epsilonPartials[parameter]);             }         }      }      private double dYdP(final DerivativeStructure y, final int parameter) {         int[] orders = new int[y.getFreeParameters()];         orders[parameter] = 1;         return y.getPartialDerivative(orders);     }      private static class SinCos implements FirstOrderFieldDifferentialEquations<DerivativeStructure> {          private final DerivativeStructure omega;         private       DerivativeStructure r;         private       DerivativeStructure alpha;          private double dRdY00;         private double dRdY01;         private double dAlphadOmega;         private double dAlphadT0;         private double dAlphadY00;         private double dAlphadY01;          protected SinCos(final DerivativeStructure omega) {             this.omega = omega;         }          @Override         public int getDimension() {             return 2;         }          @Override         public void init(final DerivativeStructure t0, final DerivativeStructure[] y0,                          final DerivativeStructure finalTime) {              // theoretical solution is y(t) = { r * sin(omega * t + alpha), r * cos(omega * t + alpha) }             // so we retrieve alpha by identification from the initial state             final DerivativeStructure r2 = y0[0].multiply(y0[0]).add(y0[1].multiply(y0[1]));              this.r            = r2.sqrt();             this.dRdY00       = y0[0].divide(r).getReal();             this.dRdY01       = y0[1].divide(r).getReal();              this.alpha        = y0[0].atan2(y0[1]).subtract(t0.multiply(omega));             this.dAlphadOmega = -t0.getReal();             this.dAlphadT0    = -omega.getReal();             this.dAlphadY00   = y0[1].divide(r2).getReal();             this.dAlphadY01   = y0[0].negate().divide(r2).getReal();          }          @Override         public DerivativeStructure[] computeDerivatives(final DerivativeStructure t, final DerivativeStructure[] y) {             return new DerivativeStructure[] {                 omega.multiply(y[1]),                 omega.multiply(y[0]).negate()             };         }          public double[] theoreticalY(final double t) {             final double theta = omega.getReal() * t + alpha.getReal();             return new double[] {                 r.getReal() * FastMath.sin(theta), r.getReal() * FastMath.cos(theta)             };         }          public double[][] getDerivatives(final double t) {              // intermediate angle and state             final double theta        = omega.getReal() * t + alpha.getReal();             final double sin          = FastMath.sin(theta);             final double cos          = FastMath.cos(theta);             final double y0           = r.getReal() * sin;             final double y1           = r.getReal() * cos;              // partial derivatives of the state first component             final double dY0dOmega    =                y1 * (t + dAlphadOmega);             final double dY0dT0       =                y1 * dAlphadT0;             final double dY0dY00      = dRdY00 * sin + y1 * dAlphadY00;             final double dY0dY01      = dRdY01 * sin + y1 * dAlphadY01;             final double dY0dT        =                y1 * omega.getReal();              // partial derivatives of the state second component             final double dY1dOmega    =              - y0 * (t + dAlphadOmega);             final double dY1dT0       =              - y0 * dAlphadT0;             final double dY1dY00      = dRdY00 * cos - y0 * dAlphadY00;             final double dY1dY01      = dRdY01 * cos - y0 * dAlphadY01;             final double dY1dT        =              - y0 * omega.getReal();              return new double[][] {                 { dY0dOmega, dY0dT0, dY0dY00, dY0dY01, dY0dT },                 { dY1dOmega, dY1dT0, dY1dY00, dY1dY01, dY1dT }             };          }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ObjectInput; import java.io.ObjectOutput;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.AbstractIntegrator; import org.apache.commons.math4.ode.ExpandableStatefulODE; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.MultistepIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class AdamsBashforthIntegratorTest {      @Test(expected=DimensionMismatchException.class)     public void dimensionCheck() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {         TestProblem1 pb = new TestProblem1();         FirstOrderIntegrator integ =             new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);         integ.integrate(pb,                         0.0, new double[pb.getDimension()+10],                         1.0, new double[pb.getDimension()+10]);     }      @Test(expected=NumberIsTooSmallException.class)     public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {            TestProblem1 pb = new TestProblem1();           double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());           double maxStep = pb.getFinalTime() - pb.getInitialTime();           double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };           double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,                                                                     vecAbsoluteTolerance,                                                                     vecRelativeTolerance);           TestProblemHandler handler = new TestProblemHandler(pb, integ);           integ.addStepHandler(handler);           integ.integrate(pb,                           pb.getInitialTime(), pb.getInitialState(),                           pb.getFinalTime(), new double[pb.getDimension()]);      }      @Test     public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {          int previousCalls = Integer.MAX_VALUE;         for (int i = -12; i < -2; ++i) {             TestProblem1 pb = new TestProblem1();             double minStep = 0;             double maxStep = pb.getFinalTime() - pb.getInitialTime();             double scalAbsoluteTolerance = FastMath.pow(10.0, i);             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;              FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,                                                                       scalAbsoluteTolerance,                                                                       scalRelativeTolerance);             TestProblemHandler handler = new TestProblemHandler(pb, integ);             integ.addStepHandler(handler);             integ.integrate(pb,                             pb.getInitialTime(), pb.getInitialState(),                             pb.getFinalTime(), new double[pb.getDimension()]);              // the 2.6 and 122 factors are only valid for this test             // and has been obtained from trial and error             // there are no general relationship between local and global errors             Assert.assertTrue(handler.getMaximalValueError() > (2.6 * scalAbsoluteTolerance));             Assert.assertTrue(handler.getMaximalValueError() < (122 * scalAbsoluteTolerance));              int calls = pb.getCalls();             Assert.assertEquals(integ.getEvaluations(), calls);             Assert.assertTrue(calls <= previousCalls);             previousCalls = calls;          }      }      @Test(expected = MaxCountExceededException.class)     public void exceedMaxEvaluations() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {          TestProblem1 pb  = new TestProblem1();         double range = pb.getFinalTime() - pb.getInitialTime();          AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(2, 0, range, 1.0e-12, 1.0e-12);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.setMaxEvaluations(650);         integ.integrate(pb,                         pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);      }      @Test     public void backward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {          TestProblem5 pb = new TestProblem5();         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());          AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0, range, 1.0e-12, 1.0e-12);         integ.setStarterIntegrator(new PerfectStarter(pb, (integ.getNSteps() + 5) / 2));         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);          Assert.assertEquals(0.0, handler.getLastError(), 4.3e-8);         Assert.assertEquals(0.0, handler.getMaximalValueError(), 4.3e-8);         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);         Assert.assertEquals("Adams-Bashforth", integ.getName());     }      @Test     public void polynomial() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {         TestProblem6 pb = new TestProblem6();         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());          for (int nSteps = 2; nSteps < 8; ++nSteps) {             AdamsBashforthIntegrator integ =                 new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-4, 1.0e-4);             integ.setStarterIntegrator(new PerfectStarter(pb, nSteps));             TestProblemHandler handler = new TestProblemHandler(pb, integ);             integ.addStepHandler(handler);             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                             pb.getFinalTime(), new double[pb.getDimension()]);             if (nSteps < 5) {                 Assert.assertTrue(handler.getMaximalValueError() > 0.005);             } else {                 Assert.assertTrue(handler.getMaximalValueError() < 5.0e-10);             }         }      }      @Test(expected=MathIllegalStateException.class)     public void testStartFailure() {         TestProblem1 pb = new TestProblem1();         double minStep = 0.0001 * (pb.getFinalTime() - pb.getInitialTime());         double maxStep = pb.getFinalTime() - pb.getInitialTime();         double scalAbsoluteTolerance = 1.0e-6;         double scalRelativeTolerance = 1.0e-7;          MultistepIntegrator integ =                         new AdamsBashforthIntegrator(6, minStep, maxStep,                                                      scalAbsoluteTolerance,                                                      scalRelativeTolerance);         integ.setStarterIntegrator(new DormandPrince853Integrator(0.5 * (pb.getFinalTime() - pb.getInitialTime()),                                                                   pb.getFinalTime() - pb.getInitialTime(),                                                                   0.1, 0.1));         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.integrate(pb,                         pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);      }      private static class PerfectStarter extends AbstractIntegrator {          private final PerfectInterpolator interpolator;         private final int nbSteps;          public PerfectStarter(final TestProblemAbstract problem, final int nbSteps) {             this.interpolator = new PerfectInterpolator(problem);             this.nbSteps      = nbSteps;         }          @Override         public void integrate(ExpandableStatefulODE equations, double t) {             double tStart = equations.getTime() + 0.01 * (t - equations.getTime());             getCounter().increment(nbSteps);             for (int i = 0; i < nbSteps; ++i) {                 double tK = ((nbSteps - 1 - (i + 1)) * equations.getTime() + (i + 1) * tStart) / (nbSteps - 1);                 interpolator.setPreviousTime(interpolator.getCurrentTime());                 interpolator.setCurrentTime(tK);                 interpolator.setInterpolatedTime(tK);                 for (StepHandler handler : getStepHandlers()) {                     handler.handleStep(interpolator, i == nbSteps - 1);                 }             }         }      }      private static class PerfectInterpolator implements StepInterpolator {         private final TestProblemAbstract problem;         private double previousTime;         private double currentTime;         private double interpolatedTime;          public PerfectInterpolator(final TestProblemAbstract problem) {             this.problem          = problem;             this.previousTime     = problem.getInitialTime();             this.currentTime      = problem.getInitialTime();             this.interpolatedTime = problem.getInitialTime();         }          @Override         public void readExternal(ObjectInput arg0) {         }          @Override         public void writeExternal(ObjectOutput arg0) {         }          @Override         public double getPreviousTime() {             return previousTime;         }          public void setPreviousTime(double time) {             previousTime = time;         }          @Override         public double getCurrentTime() {             return currentTime;         }          public void setCurrentTime(double time) {             currentTime = time;         }          @Override         public double getInterpolatedTime() {             return interpolatedTime;         }          @Override         public void setInterpolatedTime(double time) {             interpolatedTime = time;         }          @Override         public double[] getInterpolatedState() {             return problem.computeTheoreticalState(interpolatedTime);         }          @Override         public double[] getInterpolatedDerivatives() {             double[] y = problem.computeTheoreticalState(interpolatedTime);             double[] yDot = new double[y.length];             problem.computeDerivatives(interpolatedTime, y, yDot);             return yDot;         }          @Override         public double[] getInterpolatedSecondaryState(int index) {             return null;         }          @Override         public double[] getInterpolatedSecondaryDerivatives(int index) {             return null;         }          @Override         public boolean isForward() {             return problem.getFinalTime() > problem.getInitialTime();         }          @Override         public StepInterpolator copy() {             return this;         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class DormandPrince54StepInterpolatorTest {    @Test   public void derivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3(0.1);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                     scalAbsoluteTolerance,                                                                     scalRelativeTolerance);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 3.6e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException  {      TestProblem3 pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                     scalAbsoluteTolerance,                                                                     scalRelativeTolerance);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 135000);     Assert.assertTrue(bos.size () < 145000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError < 7.0e-10);    }    @Test   public void checkClone()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem3 pb = new TestProblem3(0.9);       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = scalAbsoluteTolerance;       DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                       scalAbsoluteTolerance,                                                                       scalRelativeTolerance);       integ.addStepHandler(new StepHandler() {           @Override         public void handleStep(StepInterpolator interpolator, boolean isLast)               throws MaxCountExceededException {               StepInterpolator cloned = interpolator.copy();               double tA = cloned.getPreviousTime();               double tB = cloned.getCurrentTime();               double halfStep = FastMath.abs(tB - tA) / 2;               Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);               Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);               for (int i = 0; i < 10; ++i) {                   double t = (i * tB + (9 - i) * tA) / 9;                   interpolator.setInterpolatedTime(t);                   Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                   cloned.setInterpolatedTime(t);                   Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                   double[] referenceState = interpolator.getInterpolatedState();                   double[] cloneState     = cloned.getInterpolatedState();                   for (int j = 0; j < referenceState.length; ++j) {                       Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                   }               }           }           @Override         public void init(double t0, double[] y0, double t) {           }       });       integ.integrate(pb,               pb.getInitialTime(), pb.getInitialState(),               pb.getFinalTime(), new double[pb.getDimension()]);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class MidpointFieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new MidpointFieldStepInterpolator<>(field, forward, yDotK,                                                     globalPreviousState, globalCurrentState,                                                     softPreviousState, softCurrentState,                                                     mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new MidpointFieldIntegrator<>(field, field.getOne());     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-15);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 3.3e-4, 1.1e-5);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 1.4e-17, 1.0e-50, 1.0e-50, 7.0e-18);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class HighamHall54FieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new HighamHall54FieldStepInterpolator<>(field, forward, yDotK,                                                         globalPreviousState, globalCurrentState,                                                         softPreviousState, softCurrentState,                                                         mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new HighamHall54FieldIntegrator<>(field, 0, 1, 1, 1);     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 4.9e-16);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 4.0e-13, 2.7e-15);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 1.3e-16, 1.0e-50, 3.6e-15, 2.1e-16);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem2; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class LutherIntegratorTest {      @Test     public void testMissedEndEvent()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {         final double   t0     = 1878250320.0000029;         final double   tEvent = 1878250379.9999986;         final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };         FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {              @Override             public int getDimension() {                 return k.length;             }              @Override             public void computeDerivatives(double t, double[] y, double[] yDot) {                 for (int i = 0; i < y.length; ++i) {                     yDot[i] = k[i] * y[i];                 }             }         };          LutherIntegrator integrator = new LutherIntegrator(60.0);          double[] y0   = new double[k.length];         for (int i = 0; i < y0.length; ++i) {             y0[i] = i + 1;         }         double[] y    = new double[k.length];          double finalT = integrator.integrate(ode, t0, y0, tEvent, y);         Assert.assertEquals(tEvent, finalT, 1.0e-15);         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-15);         }          integrator.addEventHandler(new EventHandler() {              @Override             public void init(double t0, double[] y0, double t) {             }              @Override             public void resetState(double t, double[] y) {             }              @Override             public double g(double t, double[] y) {                 return t - tEvent;             }              @Override             public Action eventOccurred(double t, double[] y, boolean increasing) {                 Assert.assertEquals(tEvent, t, 1.0e-15);                 return Action.CONTINUE;             }         }, Double.POSITIVE_INFINITY, 1.0e-20, 100);         finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);         Assert.assertEquals(tEvent + 120, finalT, 1.0e-15);         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-15);         }      }      @Test     public void testSanityChecks()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {         try  {             TestProblem1 pb = new TestProblem1();             new LutherIntegrator(0.01).integrate(pb,                                                  0.0, new double[pb.getDimension()+10],                                                  1.0, new double[pb.getDimension()]);             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             TestProblem1 pb = new TestProblem1();             new LutherIntegrator(0.01).integrate(pb,                                                  0.0, new double[pb.getDimension()],                                                  1.0, new double[pb.getDimension()+10]);             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             TestProblem1 pb = new TestProblem1();             new LutherIntegrator(0.01).integrate(pb,                                                  0.0, new double[pb.getDimension()],                                                  0.0, new double[pb.getDimension()]);             Assert.fail("an exception should have been thrown");         } catch(NumberIsTooSmallException ie) {         }     }      @Test     public void testDecreasingSteps()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          for (TestProblemAbstract pb : new TestProblemAbstract[] {             new TestProblem1(), new TestProblem2(), new TestProblem3(),             new TestProblem4(), new TestProblem5(), new TestProblem6()         }) {              double previousValueError = Double.NaN;             double previousTimeError = Double.NaN;             for (int i = 4; i < 10; ++i) {                  double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);                  FirstOrderIntegrator integ = new LutherIntegrator(step);                 TestProblemHandler handler = new TestProblemHandler(pb, integ);                 integ.addStepHandler(handler);                 EventHandler[] functions = pb.getEventsHandlers();                 for (int l = 0; l < functions.length; ++l) {                     integ.addEventHandler(functions[l],                                           Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);                 }                 Assert.assertEquals(functions.length, integ.getEventHandlers().size());                 double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                                   pb.getFinalTime(), new double[pb.getDimension()]);                 if (functions.length == 0) {                     Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);                 }                  double error = handler.getMaximalValueError();                 if (i > 4) {                     Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError));                 }                 previousValueError = error;                  double timeError = handler.getMaximalTimeError();                 if (i > 4) {                     Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));                 }                 previousTimeError = timeError;                  integ.clearEventHandlers();                 Assert.assertEquals(0, integ.getEventHandlers().size());             }          }      }      @Test     public void testSmallStep()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          TestProblem1 pb = new TestProblem1();         double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;          FirstOrderIntegrator integ = new LutherIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);          Assert.assertTrue(handler.getLastError() < 9.0e-17);         Assert.assertTrue(handler.getMaximalValueError() < 4.0e-15);         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);         Assert.assertEquals("Luther", integ.getName());     }      @Test     public void testBigStep()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          TestProblem1 pb = new TestProblem1();         double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;          FirstOrderIntegrator integ = new LutherIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);          Assert.assertTrue(handler.getLastError() > 0.00002);         Assert.assertTrue(handler.getMaximalValueError() > 0.001);         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }      @Test     public void testBackward()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          TestProblem5 pb = new TestProblem5();         double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;          FirstOrderIntegrator integ = new LutherIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);          Assert.assertTrue(handler.getLastError() < 3.0e-13);         Assert.assertTrue(handler.getMaximalValueError() < 5.0e-13);         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);         Assert.assertEquals("Luther", integ.getName());     }      @Test     public void testKepler()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          final TestProblem3 pb  = new TestProblem3(0.9);         double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;          FirstOrderIntegrator integ = new LutherIntegrator(step);         integ.addStepHandler(new KeplerHandler(pb));         integ.integrate(pb,                         pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);     }      private static class KeplerHandler implements StepHandler {         public KeplerHandler(TestProblem3 pb) {             this.pb = pb;             maxError = 0;         }         @Override         public void init(double t0, double[] y0, double t) {             maxError = 0;         }         @Override         public void handleStep(StepInterpolator interpolator, boolean isLast) {              double[] interpolatedY = interpolator.getInterpolatedState ();             double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());             double dx = interpolatedY[0] - theoreticalY[0];             double dy = interpolatedY[1] - theoreticalY[1];             double error = dx * dx + dy * dy;             if (error > maxError) {                 maxError = error;             }             if (isLast) {                 Assert.assertTrue(maxError < 2.2e-7);             }         }         private double maxError = 0;         private TestProblem3 pb;     }      @Test     public void testStepSize()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {         final double step = 1.23456;         FirstOrderIntegrator integ = new LutherIntegrator(step);         integ.addStepHandler(new StepHandler() {             @Override             public void handleStep(StepInterpolator interpolator, boolean isLast) {                 if (! isLast) {                     Assert.assertEquals(step,                                         interpolator.getCurrentTime() - interpolator.getPreviousTime(),                                         1.0e-12);                 }             }             @Override             public void init(double t0, double[] y0, double t) {             }         });         integ.integrate(new FirstOrderDifferentialEquations() {             @Override             public void computeDerivatives(double t, double[] y, double[] dot) {                 dot[0] = 1.0;             }             @Override             public int getDimension() {                 return 1;             }         }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);     }      @Test     public void testSingleStep() {          final TestProblem3 pb  = new TestProblem3(0.9);         double h = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;          RungeKuttaIntegrator integ = new LutherIntegrator(Double.NaN);         double   t = pb.getInitialTime();         double[] y = pb.getInitialState();         for (int i = 0; i < 100; ++i) {             y = integ.singleStep(pb, t, y, t + h);             t += h;         }         double[] yth = pb.computeTheoreticalState(t);         double dx = y[0] - yth[0];         double dy = y[1] - yth[1];         double error = dx * dx + dy * dy;         Assert.assertEquals(0.0, error, 1.0e-11);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test;  public class ThreeEighthesStepInterpolatorTest {    @Test   public void derivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;     ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 6.6e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException {      TestProblem3 pb = new TestProblem3(0.9);     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;     ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 880000);     Assert.assertTrue(bos.size () < 900000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError > 0.005);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class ClassicalRungKuttaFieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new ClassicalRungeKuttaFieldStepInterpolator<>(field, forward, yDotK,                                                                globalPreviousState, globalCurrentState,                                                                softPreviousState, softCurrentState,                                                                mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new ClassicalRungeKuttaFieldIntegrator<>(field, field.getOne());     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-15);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 2.6e-7, 3.6e-6);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 2.8e-17, 1.2e-16, 3.4e-16, 2.1e-17);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations; import org.apache.commons.math4.ode.FieldODEState; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.events.Action; import org.apache.commons.math4.ode.events.FieldEventHandler; import org.apache.commons.math4.util.MathArrays;   public class StepFieldProblem<T extends RealFieldElement<T>>     implements FirstOrderFieldDifferentialEquations<T>, FieldEventHandler<T> {      public StepFieldProblem(Field<T> field, T rateBefore, T rateAfter, T switchTime) {         this.field      = field;         this.rateAfter  = rateAfter;         this.switchTime = switchTime;         setRate(rateBefore);     }      @Override     public T[] computeDerivatives(T t, T[] y) {         T[] yDot = MathArrays.buildArray(field, 1);         yDot[0] = rate;         return yDot;     }      @Override     public int getDimension() {         return 1;     }      public void setRate(T rate) {         this.rate = rate;     }      @Override     public void init(T t0, T[] y0, T t) {     }      @Override     public void init(FieldODEStateAndDerivative<T> state0, T t) {     }      @Override     public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {         setRate(rateAfter);         return Action.RESET_DERIVATIVES;     }      @Override     public T g(FieldODEStateAndDerivative<T> state) {         return state.getTime().subtract(switchTime);     }      @Override     public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {         return state;     }      private Field<T> field;     private T        rate;     private T        rateAfter;     private T        switchTime;  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class ThreeEighthesFieldIntegratorTest extends RungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, T step) {         return new ThreeEighthesFieldIntegrator<>(field, step);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testMissedEndEvent() {         doTestMissedEndEvent(Decimal64Field.getInstance(), 1.0e-15, 6.0e-5);     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testDecreasingSteps() {         doTestDecreasingSteps(Decimal64Field.getInstance(), 1.0, 1.0, 1.0e-10);     }      @Override     public void testSmallStep() {         doTestSmallStep(Decimal64Field.getInstance(), 2.0e-13, 4.0e-12, 1.0e-12, "3/8");     }      @Override     public void testBigStep() {         doTestBigStep(Decimal64Field.getInstance(), 0.0004, 0.005, 1.0e-12, "3/8");      }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(), 5.0e-10, 7.0e-10, 1.0e-12, "3/8");     }      @Override     public void testKepler() {         doTestKepler(Decimal64Field.getInstance(), 0.0348, 1.0e-4);     }      @Override     public void testStepSize() {         doTestStepSize(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testSingleStep() {         doTestSingleStep(Decimal64Field.getInstance(), 0.21);     }      @Override     public void testTooLargeFirstStep() {         doTestTooLargeFirstStep(Decimal64Field.getInstance());     }      @Override     public void testUnstableDerivative() {         doTestUnstableDerivative(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testDerivativesConsistency() {         doTestDerivativesConsistency(Decimal64Field.getInstance(), 1.0e-10);     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(3.2e-10, new double[] { 2.1e-9, 5.9e-10, 7.0e-11, 5.9e-10, 5.9e-10 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ObjectInput; import java.io.ObjectOutput;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.AbstractIntegrator; import org.apache.commons.math4.ode.ExpandableStatefulODE; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class AdamsMoultonIntegratorTest {      @Test(expected=DimensionMismatchException.class)     public void dimensionCheck()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         TestProblem1 pb = new TestProblem1();         FirstOrderIntegrator integ =             new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);         integ.integrate(pb,                         0.0, new double[pb.getDimension()+10],                         1.0, new double[pb.getDimension()+10]);     }      @Test(expected=NumberIsTooSmallException.class)     public void testMinStep()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {            TestProblem1 pb = new TestProblem1();           double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());           double maxStep = pb.getFinalTime() - pb.getInitialTime();           double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };           double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,                                                                   vecAbsoluteTolerance,                                                                   vecRelativeTolerance);           TestProblemHandler handler = new TestProblemHandler(pb, integ);           integ.addStepHandler(handler);           integ.integrate(pb,                           pb.getInitialTime(), pb.getInitialState(),                           pb.getFinalTime(), new double[pb.getDimension()]);      }      @Test     public void testIncreasingTolerance()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          int previousCalls = Integer.MAX_VALUE;         for (int i = -12; i < -2; ++i) {             TestProblem1 pb = new TestProblem1();             double minStep = 0;             double maxStep = pb.getFinalTime() - pb.getInitialTime();             double scalAbsoluteTolerance = FastMath.pow(10.0, i);             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;              FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,                                                                     scalAbsoluteTolerance,                                                                     scalRelativeTolerance);             TestProblemHandler handler = new TestProblemHandler(pb, integ);             integ.addStepHandler(handler);             integ.integrate(pb,                             pb.getInitialTime(), pb.getInitialState(),                             pb.getFinalTime(), new double[pb.getDimension()]);              // the 0.45 and 8.69 factors are only valid for this test             // and has been obtained from trial and error             // there is no general relation between local and global errors             Assert.assertTrue(handler.getMaximalValueError() > (0.45 * scalAbsoluteTolerance));             Assert.assertTrue(handler.getMaximalValueError() < (8.69 * scalAbsoluteTolerance));             Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);              int calls = pb.getCalls();             Assert.assertEquals(integ.getEvaluations(), calls);             Assert.assertTrue(calls <= previousCalls);             previousCalls = calls;          }      }      @Test(expected = MaxCountExceededException.class)     public void exceedMaxEvaluations()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          TestProblem1 pb  = new TestProblem1();         double range = pb.getFinalTime() - pb.getInitialTime();          AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(2, 0, range, 1.0e-12, 1.0e-12);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.setMaxEvaluations(650);         integ.integrate(pb,                         pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);      }      @Test     public void backward()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {          TestProblem5 pb = new TestProblem5();         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);          Assert.assertTrue(handler.getLastError() < 3.0e-9);         Assert.assertTrue(handler.getMaximalValueError() < 3.0e-9);         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);         Assert.assertEquals("Adams-Moulton", integ.getName());     }      @Test     public void polynomial()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {         TestProblem6 pb = new TestProblem6();         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());          for (int nSteps = 2; nSteps < 8; ++nSteps) {             AdamsMoultonIntegrator integ =                 new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5);             integ.setStarterIntegrator(new PerfectStarter(pb, nSteps));             TestProblemHandler handler = new TestProblemHandler(pb, integ);             integ.addStepHandler(handler);             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                             pb.getFinalTime(), new double[pb.getDimension()]);             if (nSteps < 5) {                 Assert.assertTrue(handler.getMaximalValueError() > 2.2e-05);             } else {                 Assert.assertTrue(handler.getMaximalValueError() < 1.1e-11);             }         }      }      private static class PerfectStarter extends AbstractIntegrator {          private final PerfectInterpolator interpolator;         private final int nbSteps;          public PerfectStarter(final TestProblemAbstract problem, final int nbSteps) {             this.interpolator = new PerfectInterpolator(problem);             this.nbSteps      = nbSteps;         }          @Override         public void integrate(ExpandableStatefulODE equations, double t) {             double tStart = equations.getTime() + 0.01 * (t - equations.getTime());             getCounter().increment(nbSteps);             for (int i = 0; i < nbSteps; ++i) {                 double tK = ((nbSteps - 1 - (i + 1)) * equations.getTime() + (i + 1) * tStart) / (nbSteps - 1);                 interpolator.setPreviousTime(interpolator.getCurrentTime());                 interpolator.setCurrentTime(tK);                 interpolator.setInterpolatedTime(tK);                 for (StepHandler handler : getStepHandlers()) {                     handler.handleStep(interpolator, i == nbSteps - 1);                 }             }         }      }      private static class PerfectInterpolator implements StepInterpolator {         private final TestProblemAbstract problem;         private double previousTime;         private double currentTime;         private double interpolatedTime;          public PerfectInterpolator(final TestProblemAbstract problem) {             this.problem          = problem;             this.previousTime     = problem.getInitialTime();             this.currentTime      = problem.getInitialTime();             this.interpolatedTime = problem.getInitialTime();         }          @Override         public void readExternal(ObjectInput arg0) {         }          @Override         public void writeExternal(ObjectOutput arg0) {         }          @Override         public double getPreviousTime() {             return previousTime;         }          public void setPreviousTime(double time) {             previousTime = time;         }          @Override         public double getCurrentTime() {             return currentTime;         }          public void setCurrentTime(double time) {             currentTime = time;         }          @Override         public double getInterpolatedTime() {             return interpolatedTime;         }          @Override         public void setInterpolatedTime(double time) {             interpolatedTime = time;         }          @Override         public double[] getInterpolatedState() {             return problem.computeTheoreticalState(interpolatedTime);         }          @Override         public double[] getInterpolatedDerivatives() {             double[] y = problem.computeTheoreticalState(interpolatedTime);             double[] yDot = new double[y.length];             problem.computeDerivatives(interpolatedTime, y, yDot);             return yDot;         }          @Override         public double[] getInterpolatedSecondaryState(int index) {             return null;         }          @Override         public double[] getInterpolatedSecondaryDerivatives(int index) {             return null;         }          @Override         public boolean isForward() {             return problem.getFinalTime() > problem.getInitialTime();         }          @Override         public StepInterpolator copy() {             return this;         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class ClassicalRungeKuttaFieldIntegratorTest extends RungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, T step) {         return new ClassicalRungeKuttaFieldIntegrator<>(field, step);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testMissedEndEvent() {         doTestMissedEndEvent(Decimal64Field.getInstance(), 5.0e-6, 1.0e-9);     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testDecreasingSteps() {         doTestDecreasingSteps(Decimal64Field.getInstance(), 1.0, 1.0, 1.0e-10);     }      @Override     public void testSmallStep() {         doTestSmallStep(Decimal64Field.getInstance(), 2.0e-13, 4.0e-12, 1.0e-12, "classical Runge-Kutta");     }      @Override     public void testBigStep() {         doTestBigStep(Decimal64Field.getInstance(), 0.0004, 0.005, 1.0e-12, "classical Runge-Kutta");      }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(), 5.0e-10, 7.0e-10, 1.0e-12, "classical Runge-Kutta");     }      @Override     public void testKepler() {         doTestKepler(Decimal64Field.getInstance(), 5.82e-3, 1.0e-5);     }      @Override     public void testStepSize() {         doTestStepSize(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testSingleStep() {         doTestSingleStep(Decimal64Field.getInstance(), 9.3e-9);     }      @Override     public void testTooLargeFirstStep() {         doTestTooLargeFirstStep(Decimal64Field.getInstance());     }      @Override     public void testUnstableDerivative() {         doTestUnstableDerivative(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testDerivativesConsistency() {         doTestDerivativesConsistency(Decimal64Field.getInstance(), 1.0e-10);     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(3.2e-10, new double[] { 2.1e-9, 5.9e-10, 7.0e-11, 7.0e-11, 5.9e-10 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.lang.reflect.Array;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FieldExpandableODE; import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations; import org.apache.commons.math4.ode.FieldODEState; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.TestFieldProblem1; import org.apache.commons.math4.ode.TestFieldProblem2; import org.apache.commons.math4.ode.TestFieldProblem3; import org.apache.commons.math4.ode.TestFieldProblem4; import org.apache.commons.math4.ode.TestFieldProblem5; import org.apache.commons.math4.ode.TestFieldProblem6; import org.apache.commons.math4.ode.TestFieldProblemAbstract; import org.apache.commons.math4.ode.TestFieldProblemHandler; import org.apache.commons.math4.ode.events.Action; import org.apache.commons.math4.ode.events.FieldEventHandler; import org.apache.commons.math4.ode.sampling.FieldStepHandler; import org.apache.commons.math4.ode.sampling.FieldStepInterpolator; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  public abstract class AbstractRungeKuttaFieldIntegratorTest {      protected abstract <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>         createIntegrator(Field<T> field, T step);      @Test     public abstract void testNonFieldIntegratorConsistency();      protected <T extends RealFieldElement<T>> void doTestNonFieldIntegratorConsistency(final Field<T> field) {         try {              // get the Butcher arrays from the field integrator             RungeKuttaFieldIntegrator<T> fieldIntegrator = createIntegrator(field, field.getZero().add(1));             T[][] fieldA = fieldIntegrator.getA();             T[]   fieldB = fieldIntegrator.getB();             T[]   fieldC = fieldIntegrator.getC();              String fieldName   = fieldIntegrator.getClass().getName();             String regularName = fieldName.replaceAll("Field", "");              // get the Butcher arrays from the regular integrator             @SuppressWarnings("unchecked")             Class<RungeKuttaIntegrator> c = (Class<RungeKuttaIntegrator>) Class.forName(regularName);             java.lang.reflect.Field jlrFieldA = c.getDeclaredField("STATIC_A");             jlrFieldA.setAccessible(true);             double[][] regularA = (double[][]) jlrFieldA.get(null);             java.lang.reflect.Field jlrFieldB = c.getDeclaredField("STATIC_B");             jlrFieldB.setAccessible(true);             double[]   regularB = (double[])   jlrFieldB.get(null);             java.lang.reflect.Field jlrFieldC = c.getDeclaredField("STATIC_C");             jlrFieldC.setAccessible(true);             double[]   regularC = (double[])   jlrFieldC.get(null);              Assert.assertEquals(regularA.length, fieldA.length);             for (int i = 0; i < regularA.length; ++i) {                 checkArray(regularA[i], fieldA[i]);             }             checkArray(regularB, fieldB);             checkArray(regularC, fieldC);          } catch (ClassNotFoundException cnfe) {             Assert.fail(cnfe.getLocalizedMessage());         } catch (IllegalAccessException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (IllegalArgumentException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (SecurityException se) {             Assert.fail(se.getLocalizedMessage());         } catch (NoSuchFieldException nsfe) {             Assert.fail(nsfe.getLocalizedMessage());         }     }      private <T extends RealFieldElement<T>> void checkArray(double[] regularArray, T[] fieldArray) {         Assert.assertEquals(regularArray.length, fieldArray.length);         for (int i = 0; i < regularArray.length; ++i) {             if (regularArray[i] == 0) {                 Assert.assertTrue(0.0 == fieldArray[i].getReal());             } else {                 Assert.assertEquals(regularArray[i], fieldArray[i].getReal(), FastMath.ulp(regularArray[i]));             }         }     }      @Test     public abstract void testMissedEndEvent();      protected <T extends RealFieldElement<T>> void doTestMissedEndEvent(final Field<T> field,                                                                         final double epsilonT, final double epsilonY)         throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {         final T   t0     = field.getZero().add(1878250320.0000029);         final T   tEvent = field.getZero().add(1878250379.9999986);         final T[] k      = MathArrays.buildArray(field, 3);         k[0] = field.getZero().add(1.0e-4);         k[1] = field.getZero().add(1.0e-5);         k[2] = field.getZero().add(1.0e-6);         FirstOrderFieldDifferentialEquations<T> ode = new FirstOrderFieldDifferentialEquations<T>() {              @Override             public int getDimension() {                 return k.length;             }              @Override             public void init(T t0, T[] y0, T t) {             }              @Override             public T[] computeDerivatives(T t, T[] y) {                 T[] yDot = MathArrays.buildArray(field, k.length);                 for (int i = 0; i < y.length; ++i) {                     yDot[i] = k[i].multiply(y[i]);                 }                 return yDot;             }         };          RungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, field.getZero().add(60.0));          T[] y0   = MathArrays.buildArray(field, k.length);         for (int i = 0; i < y0.length; ++i) {             y0[i] = field.getOne().add(i);         }          FieldODEStateAndDerivative<T> result = integrator.integrate(new FieldExpandableODE<>(ode),                                                                     new FieldODEState<>(t0, y0),                                                                     tEvent);         Assert.assertEquals(tEvent.getReal(), result.getTime().getReal(), epsilonT);         T[] y = result.getState();         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(y0[i].multiply(k[i].multiply(result.getTime().subtract(t0)).exp()).getReal(),                                 y[i].getReal(),                                 epsilonY);         }          integrator.addEventHandler(new FieldEventHandler<T>() {              @Override             public void init(FieldODEStateAndDerivative<T> state0, T t) {             }              @Override             public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {                 return state;             }              @Override             public T g(FieldODEStateAndDerivative<T> state) {                 return state.getTime().subtract(tEvent);             }              @Override             public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {                 Assert.assertEquals(tEvent.getReal(), state.getTime().getReal(), epsilonT);                 return Action.CONTINUE;             }         }, Double.POSITIVE_INFINITY, 1.0e-20, 100);         result = integrator.integrate(new FieldExpandableODE<>(ode),                                       new FieldODEState<>(t0, y0),                                       tEvent.add(120));         Assert.assertEquals(tEvent.add(120).getReal(), result.getTime().getReal(), epsilonT);         y = result.getState();         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(y0[i].multiply(k[i].multiply(result.getTime().subtract(t0)).exp()).getReal(),                                 y[i].getReal(),                                 epsilonY);         }      }      @Test     public abstract void testSanityChecks();      protected <T extends RealFieldElement<T>> void doTestSanityChecks(Field<T> field)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         RungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, field.getZero().add(0.01));         try  {             TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);             integrator.integrate(new FieldExpandableODE<>(pb),                                  new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, pb.getDimension() + 10)),                                  field.getOne());             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);             integrator.integrate(new FieldExpandableODE<>(pb),                                  new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, pb.getDimension())),                                  field.getZero());             Assert.fail("an exception should have been thrown");         } catch(NumberIsTooSmallException ie) {         }     }      @Test     public abstract void testDecreasingSteps();      protected <T extends RealFieldElement<T>> void doTestDecreasingSteps(Field<T> field,                                                                          final double safetyValueFactor,                                                                          final double safetyTimeFactor,                                                                          final double epsilonT)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          @SuppressWarnings("unchecked")         TestFieldProblemAbstract<T>[] allProblems =                         (TestFieldProblemAbstract<T>[]) Array.newInstance(TestFieldProblemAbstract.class, 6);         allProblems[0] = new TestFieldProblem1<>(field);         allProblems[1] = new TestFieldProblem2<>(field);         allProblems[2] = new TestFieldProblem3<>(field);         allProblems[3] = new TestFieldProblem4<>(field);         allProblems[4] = new TestFieldProblem5<>(field);         allProblems[5] = new TestFieldProblem6<>(field);         for (TestFieldProblemAbstract<T> pb :  allProblems) {              T previousValueError = null;             T previousTimeError  = null;             for (int i = 4; i < 10; ++i) {                  T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(FastMath.pow(2.0, -i));                  RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);                 TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);                 integ.addStepHandler(handler);                 FieldEventHandler<T>[] functions = pb.getEventsHandlers();                 for (int l = 0; l < functions.length; ++l) {                     integ.addEventHandler(functions[l],                                           Double.POSITIVE_INFINITY, 1.0e-6 * step.getReal(), 1000);                 }                 Assert.assertEquals(functions.length, integ.getEventHandlers().size());                 FieldODEStateAndDerivative<T> stop = integ.integrate(new FieldExpandableODE<>(pb),                                                                      pb.getInitialState(),                                                                      pb.getFinalTime());                 if (functions.length == 0) {                     Assert.assertEquals(pb.getFinalTime().getReal(), stop.getTime().getReal(), epsilonT);                 }                  T error = handler.getMaximalValueError();                 if (i > 4) {                     Assert.assertTrue(error.subtract(previousValueError.abs().multiply(safetyValueFactor)).getReal() < 0);                 }                 previousValueError = error;                  T timeError = handler.getMaximalTimeError();                 if (i > 4) {                     Assert.assertTrue(timeError.subtract(previousTimeError.abs().multiply(safetyTimeFactor)).getReal() <= 0);                 }                 previousTimeError = timeError;                  integ.clearEventHandlers();                 Assert.assertEquals(0, integ.getEventHandlers().size());             }          }      }      @Test     public abstract void testSmallStep();      protected <T extends RealFieldElement<T>> void doTestSmallStep(Field<T> field,                                                                    final double epsilonLast,                                                                    final double epsilonMaxValue,                                                                    final double epsilonMaxTime,                                                                    final String name)          throws DimensionMismatchException, NumberIsTooSmallException,                 MaxCountExceededException, NoBracketingException {          TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);         Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testBigStep();      protected <T extends RealFieldElement<T>> void doTestBigStep(Field<T> field,                                                                  final double belowLast,                                                                  final double belowMaxValue,                                                                  final double epsilonMaxTime,                                                                  final String name)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.2);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertTrue(handler.getLastError().getReal()         > belowLast);         Assert.assertTrue(handler.getMaximalValueError().getReal() > belowMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testBackward();      protected <T extends RealFieldElement<T>> void doTestBackward(Field<T> field,                                                                   final double epsilonLast,                                                                   final double epsilonMaxValue,                                                                   final double epsilonMaxTime,                                                                   final String name)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          TestFieldProblem5<T> pb = new TestFieldProblem5<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001).abs();          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);         Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testKepler();      protected <T extends RealFieldElement<T>> void doTestKepler(Field<T> field, double expectedMaxError, double epsilon)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          final TestFieldProblem3<T> pb  = new TestFieldProblem3<>(field, field.getZero().add(0.9));         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.0003);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         integ.addStepHandler(new KeplerHandler<>(pb, expectedMaxError, epsilon));         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());     }      private static class KeplerHandler<T extends RealFieldElement<T>> implements FieldStepHandler<T> {         private T maxError;         private final TestFieldProblem3<T> pb;         private final double expectedMaxError;         private final double epsilon;         public KeplerHandler(TestFieldProblem3<T> pb, double expectedMaxError, double epsilon) {             this.pb               = pb;             this.expectedMaxError = expectedMaxError;             this.epsilon          = epsilon;             maxError = pb.getField().getZero();         }         @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {             maxError = pb.getField().getZero();         }         @Override         public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast)                         throws MaxCountExceededException {              FieldODEStateAndDerivative<T> current = interpolator.getCurrentState();             T[] theoreticalY  = pb.computeTheoreticalState(current.getTime());             T dx = current.getState()[0].subtract(theoreticalY[0]);             T dy = current.getState()[1].subtract(theoreticalY[1]);             T error = dx.multiply(dx).add(dy.multiply(dy));             if (error.subtract(maxError).getReal() > 0) {                 maxError = error;             }             if (isLast) {                 Assert.assertEquals(expectedMaxError, maxError.getReal(), epsilon);             }         }     }      @Test     public abstract void testStepSize();      protected <T extends RealFieldElement<T>> void doTestStepSize(final Field<T> field, final double epsilon)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         final T step = field.getZero().add(1.23456);         RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         integ.addStepHandler(new FieldStepHandler<T>() {             @Override             public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast) {                 if (! isLast) {                     Assert.assertEquals(step.getReal(),                                         interpolator.getCurrentState().getTime().subtract(interpolator.getPreviousState().getTime()).getReal(),                                         epsilon);                 }             }             @Override             public void init(FieldODEStateAndDerivative<T> s0, T t) {             }         });         integ.integrate(new FieldExpandableODE<>(new FirstOrderFieldDifferentialEquations<T>() {             @Override             public void init(T t0, T[] y0, T t) {             }             @Override             public T[] computeDerivatives(T t, T[] y) {                 T[] dot = MathArrays.buildArray(t.getField(), 1);                 dot[0] = t.getField().getOne();                 return dot;             }             @Override             public int getDimension() {                 return 1;             }         }), new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, 1)), field.getZero().add(5.0));     }      @Test     public abstract void testSingleStep();      protected <T extends RealFieldElement<T>> void doTestSingleStep(final Field<T> field, final double epsilon) {          final TestFieldProblem3<T> pb  = new TestFieldProblem3<>(field, field.getZero().add(0.9));         T h = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.0003);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, field.getZero().add(Double.NaN));         T   t = pb.getInitialState().getTime();         T[] y = pb.getInitialState().getState();         for (int i = 0; i < 100; ++i) {             y = integ.singleStep(pb, t, y, t.add(h));             t = t.add(h);         }         T[] yth = pb.computeTheoreticalState(t);         T dx = y[0].subtract(yth[0]);         T dy = y[1].subtract(yth[1]);         T error = dx.multiply(dx).add(dy.multiply(dy));         Assert.assertEquals(0.0, error.getReal(), epsilon);     }      @Test     public abstract void testTooLargeFirstStep();      protected <T extends RealFieldElement<T>> void doTestTooLargeFirstStep(final Field<T> field) {          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, field.getZero().add(0.5));         final T t0 = field.getZero();         final T[] y0 = MathArrays.buildArray(field, 1);         y0[0] = field.getOne();         final T t   = field.getZero().add(0.001);         FirstOrderFieldDifferentialEquations<T> equations = new FirstOrderFieldDifferentialEquations<T>() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void init(T t0, T[] y0, T t) {             }              @Override             public T[] computeDerivatives(T t, T[] y) {                 Assert.assertTrue(t.getReal() >= FastMath.nextAfter(t0.getReal(), Double.NEGATIVE_INFINITY));                 Assert.assertTrue(t.getReal() <= FastMath.nextAfter(t.getReal(),   Double.POSITIVE_INFINITY));                 T[] yDot = MathArrays.buildArray(field, 1);                 yDot[0] = y[0].multiply(-100.0);                 return yDot;             }          };          integ.integrate(new FieldExpandableODE<>(equations), new FieldODEState<>(t0, y0), t);      }      @Test     public abstract void testUnstableDerivative();      protected <T extends RealFieldElement<T>> void doTestUnstableDerivative(Field<T> field, double epsilon) {       final StepFieldProblem<T> stepProblem = new StepFieldProblem<>(field,                                                                       field.getZero().add(0.0),                                                                       field.getZero().add(1.0),                                                                       field.getZero().add(2.0));       RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, field.getZero().add(0.3));       integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);       FieldODEStateAndDerivative<T> result = integ.integrate(new FieldExpandableODE<>(stepProblem),                                                              new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, 1)),                                                              field.getZero().add(10.0));       Assert.assertEquals(8.0, result.getState()[0].getReal(), epsilon);     }      @Test     public abstract void testDerivativesConsistency();      protected <T extends RealFieldElement<T>> void doTestDerivativesConsistency(final Field<T> field, double epsilon) {         TestFieldProblem3<T> pb = new TestFieldProblem3<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001);         RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);     }      @Test     public abstract void testPartialDerivatives();      protected <T extends RealFieldElement<T>> void doTestPartialDerivatives(final double epsilonY,                                                                             final double[] epsilonPartials) {          // parameters indices         final int parameters = 5;         final int order      = 1;         final int parOmega   = 0;         final int parTO      = 1;         final int parY00     = 2;         final int parY01     = 3;         final int parT       = 4;          DerivativeStructure omega = new DerivativeStructure(parameters, order, parOmega, 1.3);         DerivativeStructure t0    = new DerivativeStructure(parameters, order, parTO, 1.3);         DerivativeStructure[] y0  = new DerivativeStructure[] {             new DerivativeStructure(parameters, order, parY00, 3.0),             new DerivativeStructure(parameters, order, parY01, 4.0)         };         DerivativeStructure t     = new DerivativeStructure(parameters, order, parT, 6.0);         SinCos sinCos = new SinCos(omega);          RungeKuttaFieldIntegrator<DerivativeStructure> integrator =                         createIntegrator(omega.getField(), t.subtract(t0).multiply(0.001));         FieldODEStateAndDerivative<DerivativeStructure> result =                         integrator.integrate(new FieldExpandableODE<>(sinCos),                                              new FieldODEState<>(t0, y0),                                              t);          // check values         for (int i = 0; i < sinCos.getDimension(); ++i) {             Assert.assertEquals(sinCos.theoreticalY(t.getReal())[i], result.getState()[i].getValue(), epsilonY);         }          // check derivatives         final double[][] derivatives = sinCos.getDerivatives(t.getReal());          for (int i = 0; i < sinCos.getDimension(); ++i) {             for (int parameter = 0; parameter < parameters; ++parameter) {                 Assert.assertEquals(derivatives[i][parameter],                                     dYdP(result.getState()[i], parameter),                                     epsilonPartials[parameter]);             }         }      }      private double dYdP(final DerivativeStructure y, final int parameter) {         int[] orders = new int[y.getFreeParameters()];         orders[parameter] = 1;         return y.getPartialDerivative(orders);     }      private static class SinCos implements FirstOrderFieldDifferentialEquations<DerivativeStructure> {          private final DerivativeStructure omega;         private       DerivativeStructure r;         private       DerivativeStructure alpha;          private double dRdY00;         private double dRdY01;         private double dAlphadOmega;         private double dAlphadT0;         private double dAlphadY00;         private double dAlphadY01;          protected SinCos(final DerivativeStructure omega) {             this.omega = omega;         }          @Override         public int getDimension() {             return 2;         }          @Override         public void init(final DerivativeStructure t0, final DerivativeStructure[] y0,                          final DerivativeStructure finalTime) {              // theoretical solution is y(t) = { r * sin(omega * t + alpha), r * cos(omega * t + alpha) }             // so we retrieve alpha by identification from the initial state             final DerivativeStructure r2 = y0[0].multiply(y0[0]).add(y0[1].multiply(y0[1]));              this.r            = r2.sqrt();             this.dRdY00       = y0[0].divide(r).getReal();             this.dRdY01       = y0[1].divide(r).getReal();              this.alpha        = y0[0].atan2(y0[1]).subtract(t0.multiply(omega));             this.dAlphadOmega = -t0.getReal();             this.dAlphadT0    = -omega.getReal();             this.dAlphadY00   = y0[1].divide(r2).getReal();             this.dAlphadY01   = y0[0].negate().divide(r2).getReal();          }          @Override         public DerivativeStructure[] computeDerivatives(final DerivativeStructure t, final DerivativeStructure[] y) {             return new DerivativeStructure[] {                 omega.multiply(y[1]),                 omega.multiply(y[0]).negate()             };         }          public double[] theoreticalY(final double t) {             final double theta = omega.getReal() * t + alpha.getReal();             return new double[] {                 r.getReal() * FastMath.sin(theta), r.getReal() * FastMath.cos(theta)             };         }          public double[][] getDerivatives(final double t) {              // intermediate angle and state             final double theta        = omega.getReal() * t + alpha.getReal();             final double sin          = FastMath.sin(theta);             final double cos          = FastMath.cos(theta);             final double y0           = r.getReal() * sin;             final double y1           = r.getReal() * cos;              // partial derivatives of the state first component             final double dY0dOmega    =                y1 * (t + dAlphadOmega);             final double dY0dT0       =                y1 * dAlphadT0;             final double dY0dY00      = dRdY00 * sin + y1 * dAlphadY00;             final double dY0dY01      = dRdY01 * sin + y1 * dAlphadY01;             final double dY0dT        =                y1 * omega.getReal();              // partial derivatives of the state second component             final double dY1dOmega    =              - y0 * (t + dAlphadOmega);             final double dY1dT0       =              - y0 * dAlphadT0;             final double dY1dY00      = dRdY00 * cos - y0 * dAlphadY00;             final double dY1dY01      = dRdY01 * cos - y0 * dAlphadY01;             final double dY1dT        =              - y0 * omega.getReal();              return new double[][] {                 { dY0dOmega, dY0dT0, dY0dY00, dY0dY01, dY0dT },                 { dY1dOmega, dY1dT0, dY1dY00, dY1dY01, dY1dT }             };          }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem2; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class GillIntegratorTest {    @Test(expected=DimensionMismatchException.class)   public void testDimensionCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       new GillIntegrator(0.01).integrate(pb,                                          0.0, new double[pb.getDimension()+10],                                          1.0, new double[pb.getDimension()+10]);         Assert.fail("an exception should have been thrown");   }    @Test   public void testDecreasingSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        for (TestProblemAbstract pb : new TestProblemAbstract[] {           new TestProblem1(), new TestProblem2(), new TestProblem3(),           new TestProblem4(), new TestProblem5(), new TestProblem6()       }) {        double previousValueError = Double.NaN;       double previousTimeError = Double.NaN;       for (int i = 5; i < 10; ++i) {          double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);          FirstOrderIntegrator integ = new GillIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         EventHandler[] functions = pb.getEventsHandlers();         for (int l = 0; l < functions.length; ++l) {           integ.addEventHandler(functions[l],                                      Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);         }         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                           pb.getFinalTime(), new double[pb.getDimension()]);         if (functions.length == 0) {             Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);         }          double valueError = handler.getMaximalValueError();         if (i > 5) {           Assert.assertTrue(valueError < 1.01 * FastMath.abs(previousValueError));         }         previousValueError = valueError;          double timeError = handler.getMaximalTimeError();         if (i > 5) {           Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));         }         previousTimeError = timeError;        }      }    }    @Test   public void testSmallStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new GillIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 2.0e-13);     Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);     Assert.assertEquals("Gill", integ.getName());    }    @Test   public void testBigStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;      FirstOrderIntegrator integ = new GillIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() > 0.0004);     Assert.assertTrue(handler.getMaximalValueError() > 0.005);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;        FirstOrderIntegrator integ = new GillIntegrator(step);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 5.0e-10);       Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("Gill", integ.getName());   }    @Test   public void testKepler()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;      FirstOrderIntegrator integ = new GillIntegrator(step);     integ.addStepHandler(new KeplerStepHandler(pb));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);   }    @Test   public void testUnstableDerivative()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);     FirstOrderIntegrator integ = new GillIntegrator(0.3);     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);     double[] y = { Double.NaN };     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);     Assert.assertEquals(8.0, y[0], 1.0e-12);   }    private static class KeplerStepHandler implements StepHandler {     public KeplerStepHandler(TestProblem3 pb) {       this.pb = pb;     }     @Override     public void init(double t0, double[] y0, double t) {       maxError = 0;     }     @Override     public void handleStep(StepInterpolator interpolator, boolean isLast)         throws MaxCountExceededException {        double[] interpolatedY = interpolator.getInterpolatedState();       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }       if (isLast) {         // even with more than 1000 evaluations per period,         // Gill is not able to integrate such an eccentric         // orbit with a good accuracy         Assert.assertTrue(maxError > 0.001);       }     }     private double maxError;     private TestProblem3 pb;   }    @Test   public void testStepSize()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final double step = 1.23456;       FirstOrderIntegrator integ = new GillIntegrator(step);       integ.addStepHandler(new StepHandler() {           @Override         public void handleStep(StepInterpolator interpolator, boolean isLast) {               if (! isLast) {                   Assert.assertEquals(step,                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),                                1.0e-12);               }           }           @Override         public void init(double t0, double[] y0, double t) {           }       });       integ.integrate(new FirstOrderDifferentialEquations() {           @Override         public void computeDerivatives(double t, double[] y, double[] dot) {               dot[0] = 1.0;           }           @Override         public int getDimension() {               return 1;           }       }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class HighamHall54IntegratorTest {    @Test   public void testWrongDerivative()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       HighamHall54Integrator integrator =           new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);       FirstOrderDifferentialEquations equations =           new FirstOrderDifferentialEquations() {             @Override             public void computeDerivatives(double t, double[] y, double[] dot) {             if (t < -0.5) {                 throw new LocalException();             } else {                 throw new RuntimeException("oops");            }           }           @Override         public int getDimension() {               return 1;           }       };        try  {         integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);         Assert.fail("an exception should have been thrown");       } catch(LocalException de) {         // expected behavior       }        try  {         integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);         Assert.fail("an exception should have been thrown");       } catch(RuntimeException de) {         // expected behavior       }    }    @Test(expected=NumberIsTooSmallException.class)   public void testMinStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem1 pb = new TestProblem1();       double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };       double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };        FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                               vecAbsoluteTolerance,                                                               vecRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);       Assert.fail("an exception should have been thrown");    }    @Test   public void testIncreasingTolerance()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      int previousCalls = Integer.MAX_VALUE;     for (int i = -12; i < -2; ++i) {       TestProblem1 pb = new TestProblem1();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = FastMath.pow(10.0, i);       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        // the 1.3 factor is only valid for this test       // and has been obtained from trial and error       // there is no general relation between local and global errors       Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);        int calls = pb.getCalls();       Assert.assertEquals(integ.getEvaluations(), calls);       Assert.assertTrue(calls <= previousCalls);       previousCalls = calls;      }    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 5.0e-7);       Assert.assertTrue(handler.getMaximalValueError() < 5.0e-7);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("Higham-Hall 5(4)", integ.getName());   }    @Test   public void testEvents()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem4 pb = new TestProblem4();     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                             scalAbsoluteTolerance,                                                             scalRelativeTolerance);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     EventHandler[] functions = pb.getEventsHandlers();     double convergence = 1.0e-8 * maxStep;     for (int l = 0; l < functions.length; ++l) {       integ.addEventHandler(functions[l],                                  Double.POSITIVE_INFINITY, convergence, 1000);     }     Assert.assertEquals(functions.length, integ.getEventHandlers().size());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getMaximalValueError() < 1.0e-7);     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);     Assert.assertEquals(12.0, handler.getLastTime(), convergence);     integ.clearEventHandlers();     Assert.assertEquals(0, integ.getEventHandlers().size());    }    @Test(expected=LocalException.class)   public void testEventsErrors()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        final TestProblem1 pb = new TestProblem1();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderIntegrator integ =           new HighamHall54Integrator(minStep, maxStep,                                      scalAbsoluteTolerance, scalRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);        integ.addEventHandler(new EventHandler() {         @Override         public void init(double t0, double[] y0, double t) {         }         @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {           return Action.CONTINUE;         }         @Override         public double g(double t, double[] y) {           double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;           double offset = t - middle;           if (offset > 0) {             throw new LocalException();           }           return offset;         }         @Override         public void resetState(double t, double[] y) {         }       }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);        integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);    }    private static class LocalException extends RuntimeException {     private static final long serialVersionUID = 3041292643919807960L;   }    @Test   public void testEventsNoConvergence()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem1 pb = new TestProblem1();     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ =         new HighamHall54Integrator(minStep, maxStep,                                    scalAbsoluteTolerance, scalRelativeTolerance);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);      integ.addEventHandler(new EventHandler() {       @Override     public void init(double t0, double[] y0, double t) {       }       @Override     public Action eventOccurred(double t, double[] y, boolean increasing) {         return Action.CONTINUE;       }       @Override     public double g(double t, double[] y) {         double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;         double offset = t - middle;         return (offset > 0) ? (offset + 0.5) : (offset - 0.5);       }       @Override     public void resetState(double t, double[] y) {       }     }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);      try {       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);       Assert.fail("an exception should have been thrown");     } catch (TooManyEvaluationsException tmee) {         // Expected.     }  }    @Test   public void testSanityChecks()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final TestProblem3 pb  = new TestProblem3(0.9);       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();        try {         FirstOrderIntegrator integ =             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);         integ.integrate(pb, pb.getInitialTime(), new double[6],                         pb.getFinalTime(), new double[pb.getDimension()]);         Assert.fail("an exception should have been thrown");       } catch (DimensionMismatchException ie) {         // expected behavior       }        try {         FirstOrderIntegrator integ =             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[6]);         Assert.fail("an exception should have been thrown");       } catch (DimensionMismatchException ie) {         // expected behavior       }        try {         FirstOrderIntegrator integ =             new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);         Assert.fail("an exception should have been thrown");       } catch (DimensionMismatchException ie) {         // expected behavior       }        try {         FirstOrderIntegrator integ =             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);         Assert.fail("an exception should have been thrown");       } catch (DimensionMismatchException ie) {         // expected behavior       }        try {         FirstOrderIntegrator integ =             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                         pb.getInitialTime(), new double[pb.getDimension()]);         Assert.fail("an exception should have been thrown");       } catch (NumberIsTooSmallException ie) {         // expected behavior       }    }    @Test   public void testKepler()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };     double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                             vecAbsoluteTolerance,                                                             vecRelativeTolerance);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertEquals(0.0, handler.getMaximalValueError(), 1.5e-4);     Assert.assertEquals("Higham-Hall 5(4)", integ.getName());   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test;  public class GillStepInterpolatorTest {    @Test   public void testDerivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;     GillIntegrator integ = new GillIntegrator(step);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 6.6e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException {      TestProblem3 pb = new TestProblem3(0.9);     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;     GillIntegrator integ = new GillIntegrator(step);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 880000);     Assert.assertTrue(bos.size () < 900000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError < 0.003);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class DormandPrince853FieldIntegratorTest extends EmbeddedRungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance) {         return new DormandPrince853FieldIntegrator<>(field, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);     }      @Override     protected <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {         return new DormandPrince853FieldIntegrator<>(field, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(), 8.1e-8, 1.1e-7, 1.0e-12, "Dormand-Prince 8 (5, 3)");     }      @Override     public void testKepler() {         doTestKepler(Decimal64Field.getInstance(), 4.4e-11);     }      @Override     public void testForwardBackwardExceptions() {         doTestForwardBackwardExceptions(Decimal64Field.getInstance());     }      @Override     public void testMinStep() {         doTestMinStep(Decimal64Field.getInstance());     }      @Override     public void testIncreasingTolerance() {         // the 1.3 factor is only valid for this test         // and has been obtained from trial and error         // there is no general relation between local and global errors         doTestIncreasingTolerance(Decimal64Field.getInstance(), 1.3, 1.0e-12);     }      @Override     public void testEvents() {         doTestEvents(Decimal64Field.getInstance(), 2.1e-7, "Dormand-Prince 8 (5, 3)");     }      @Override     public void testEventsErrors() {         doTestEventsErrors(Decimal64Field.getInstance());     }      @Override     public void testEventsNoConvergence() {         doTestEventsNoConvergence(Decimal64Field.getInstance());     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(2.6e-12, new double[] { 1.3e-11, 3.6e-12, 5.2e-13, 3.6e-12, 3.6e-12 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class AdamsMoultonFieldIntegratorTest extends AdamsFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> AdamsFieldIntegrator<T>     createIntegrator(Field<T> field, final int nSteps, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance) {         return new AdamsMoultonFieldIntegrator<>(field, nSteps, minStep, maxStep,                         scalAbsoluteTolerance, scalRelativeTolerance);     }      @Override     protected <T extends RealFieldElement<T>> AdamsFieldIntegrator<T>     createIntegrator(Field<T> field, final int nSteps, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {         return new AdamsMoultonFieldIntegrator<>(field, nSteps, minStep, maxStep,                         vecAbsoluteTolerance, vecRelativeTolerance);     }      @Override     @Test(expected=NumberIsTooSmallException.class)     public void testMinStep() {         doDimensionCheck(Decimal64Field.getInstance());     }      @Override     @Test     public void testIncreasingTolerance() {         // the 0.45 and 8.69 factors are only valid for this test         // and has been obtained from trial and error         // there are no general relationship between local and global errors         doTestIncreasingTolerance(Decimal64Field.getInstance(), 0.45, 8.69);     }      @Override     @Test(expected = MaxCountExceededException.class)     public void exceedMaxEvaluations() {         doExceedMaxEvaluations(Decimal64Field.getInstance(), 650);     }      @Override     @Test     public void backward() {         doBackward(Decimal64Field.getInstance(), 3.0e-9, 3.0e-9, 1.0e-16, "Adams-Moulton");     }      @Override     @Test     public void polynomial() {         doPolynomial(Decimal64Field.getInstance(), 5, 2.2e-05, 1.1e-11);     }      @Override     @Test(expected=MathIllegalStateException.class)     public void testStartFailure() {         doTestStartFailure(Decimal64Field.getInstance());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem2; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class EulerIntegratorTest {    @Test(expected=DimensionMismatchException.class)   public void testDimensionCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       new EulerIntegrator(0.01).integrate(pb,                                           0.0, new double[pb.getDimension()+10],                                           1.0, new double[pb.getDimension()+10]);         Assert.fail("an exception should have been thrown");   }    @Test   public void testDecreasingSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        for (TestProblemAbstract pb : new TestProblemAbstract[] {           new TestProblem1(), new TestProblem2(), new TestProblem3(),           new TestProblem4(), new TestProblem5(), new TestProblem6()       }) {        double previousValueError = Double.NaN;       double previousTimeError = Double.NaN;       for (int i = 4; i < 8; ++i) {          double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);          FirstOrderIntegrator integ = new EulerIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         EventHandler[] functions = pb.getEventsHandlers();         for (int l = 0; l < functions.length; ++l) {           integ.addEventHandler(functions[l],                                      Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);         }         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                           pb.getFinalTime(), new double[pb.getDimension()]);         if (functions.length == 0) {             Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);         }          double valueError = handler.getMaximalValueError();         if (i > 4) {           Assert.assertTrue(valueError < FastMath.abs(previousValueError));         }         previousValueError = valueError;          double timeError = handler.getMaximalTimeError();         if (i > 4) {           Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));         }         previousTimeError = timeError;        }      }    }    @Test   public void testSmallStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb  = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new EulerIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertTrue(handler.getLastError() < 2.0e-4);    Assert.assertTrue(handler.getMaximalValueError() < 1.0e-3);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    Assert.assertEquals("Euler", integ.getName());    }    @Test   public void testBigStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb  = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;      FirstOrderIntegrator integ = new EulerIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() > 0.01);     Assert.assertTrue(handler.getMaximalValueError() > 0.2);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;        FirstOrderIntegrator integ = new EulerIntegrator(step);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 0.45);       Assert.assertTrue(handler.getMaximalValueError() < 0.45);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("Euler", integ.getName());   }    @Test   public void testStepSize()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final double step = 1.23456;       FirstOrderIntegrator integ = new EulerIntegrator(step);       integ.addStepHandler(new StepHandler() {         @Override         public void handleStep(StepInterpolator interpolator, boolean isLast) {             if (! isLast) {                 Assert.assertEquals(step,                              interpolator.getCurrentTime() - interpolator.getPreviousTime(),                              1.0e-12);             }         }         @Override         public void init(double t0, double[] y0, double t) {         }       });       integ.integrate(new FirstOrderDifferentialEquations() {                           @Override                         public void computeDerivatives(double t, double[] y, double[] dot) {                               dot[0] = 1.0;                           }                           @Override                         public int getDimension() {                               return 1;                           }                       }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem2; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class MidpointIntegratorTest {    @Test(expected=DimensionMismatchException.class)   public void testDimensionCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       new MidpointIntegrator(0.01).integrate(pb,                                              0.0, new double[pb.getDimension()+10],                                              1.0, new double[pb.getDimension()+10]);         Assert.fail("an exception should have been thrown");   }    @Test   public void testDecreasingSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        for (TestProblemAbstract pb : new TestProblemAbstract[] {           new TestProblem1(), new TestProblem2(), new TestProblem3(),           new TestProblem4(), new TestProblem5(), new TestProblem6()       }) {        double previousValueError = Double.NaN;       double previousTimeError = Double.NaN;       for (int i = 4; i < 10; ++i) {          double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);         FirstOrderIntegrator integ = new MidpointIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         EventHandler[] functions = pb.getEventsHandlers();         for (int l = 0; l < functions.length; ++l) {           integ.addEventHandler(functions[l],                                      Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);         }         double stopTime = integ.integrate(pb,                                           pb.getInitialTime(), pb.getInitialState(),                                           pb.getFinalTime(), new double[pb.getDimension()]);         if (functions.length == 0) {             Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);         }          double valueError = handler.getMaximalValueError();         if (i > 4) {           Assert.assertTrue(valueError < FastMath.abs(previousValueError));         }         previousValueError = valueError;          double timeError = handler.getMaximalTimeError();         if (i > 4) {           Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));         }         previousTimeError = timeError;        }      }    }    @Test   public void testSmallStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb  = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new MidpointIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 2.0e-7);     Assert.assertTrue(handler.getMaximalValueError() < 1.0e-6);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);     Assert.assertEquals("midpoint", integ.getName());    }    @Test   public void testBigStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb  = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;      FirstOrderIntegrator integ = new MidpointIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() > 0.01);     Assert.assertTrue(handler.getMaximalValueError() > 0.05);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;        FirstOrderIntegrator integ = new MidpointIntegrator(step);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 6.0e-4);       Assert.assertTrue(handler.getMaximalValueError() < 6.0e-4);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("midpoint", integ.getName());   }    @Test   public void testStepSize()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final double step = 1.23456;       FirstOrderIntegrator integ = new MidpointIntegrator(step);       integ.addStepHandler(new StepHandler() {           @Override         public void handleStep(StepInterpolator interpolator, boolean isLast) {               if (! isLast) {                   Assert.assertEquals(step,                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),                                1.0e-12);               }           }           @Override         public void init(double t0, double[] y0, double t) {           }       });       integ.integrate(new FirstOrderDifferentialEquations() {           @Override         public void computeDerivatives(double t, double[] y, double[] dot) {               dot[0] = 1.0;           }           @Override         public int getDimension() {               return 1;           }       }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class DormandPrince853FieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new DormandPrince853FieldStepInterpolator<>(field, forward, yDotK,                                                             globalPreviousState, globalCurrentState,                                                             softPreviousState, softCurrentState,                                                             mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new DormandPrince853FieldIntegrator<>(field, 0, 1, 1, 1);     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-50);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 3.1e-17, 3.4e-16);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 3.4e-12, 5.7e-11, 1.9e-10, 3.1e-9);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.AbstractFieldIntegrator; import org.apache.commons.math4.ode.FieldExpandableODE; import org.apache.commons.math4.ode.FieldODEState; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.FirstOrderFieldIntegrator; import org.apache.commons.math4.ode.MultistepFieldIntegrator; import org.apache.commons.math4.ode.TestFieldProblem1; import org.apache.commons.math4.ode.TestFieldProblem5; import org.apache.commons.math4.ode.TestFieldProblem6; import org.apache.commons.math4.ode.TestFieldProblemAbstract; import org.apache.commons.math4.ode.TestFieldProblemHandler; import org.apache.commons.math4.ode.sampling.FieldStepHandler; import org.apache.commons.math4.ode.sampling.FieldStepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public abstract class AdamsFieldIntegratorAbstractTest {      protected abstract <T extends RealFieldElement<T>> AdamsFieldIntegrator<T>     createIntegrator(Field<T> field, final int nSteps, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance);      protected abstract <T extends RealFieldElement<T>> AdamsFieldIntegrator<T>     createIntegrator(Field<T> field, final int nSteps, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance);      @Test(expected=NumberIsTooSmallException.class)     public abstract void testMinStep();      protected <T extends RealFieldElement<T>> void doDimensionCheck(final Field<T> field) {         TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);          double minStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.1).getReal();         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };         double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, 4, minStep, maxStep,                                                               vecAbsoluteTolerance,                                                               vecRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());      }      @Test     public abstract void testIncreasingTolerance();      protected <T extends RealFieldElement<T>> void doTestIncreasingTolerance(final Field<T> field,                                                                              double ratioMin, double ratioMax) {          int previousCalls = Integer.MAX_VALUE;         for (int i = -12; i < -2; ++i) {             TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);             double minStep = 0;             double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();             double scalAbsoluteTolerance = FastMath.pow(10.0, i);             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;              FirstOrderFieldIntegrator<T> integ = createIntegrator(field, 4, minStep, maxStep,                                                                   scalAbsoluteTolerance,                                                                   scalRelativeTolerance);             TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);             integ.addStepHandler(handler);             integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());              Assert.assertTrue(handler.getMaximalValueError().getReal() > ratioMin * scalAbsoluteTolerance);             Assert.assertTrue(handler.getMaximalValueError().getReal() < ratioMax * scalAbsoluteTolerance);              int calls = pb.getCalls();             Assert.assertEquals(integ.getEvaluations(), calls);             Assert.assertTrue(calls <= previousCalls);             previousCalls = calls;          }      }      @Test(expected = MaxCountExceededException.class)     public abstract void exceedMaxEvaluations();      protected <T extends RealFieldElement<T>> void doExceedMaxEvaluations(final Field<T> field, final int max) {          TestFieldProblem1<T> pb  = new TestFieldProblem1<>(field);         double range = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, 2, 0, range, 1.0e-12, 1.0e-12);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.setMaxEvaluations(max);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());      }      @Test     public abstract void backward();      protected <T extends RealFieldElement<T>> void doBackward(final Field<T> field,                                                               final double epsilonLast,                                                               final double epsilonMaxValue,                                                               final double epsilonMaxTime,                                                               final String name) {          TestFieldProblem5<T> pb = new TestFieldProblem5<>(field);         double range = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();          AdamsFieldIntegrator<T> integ = createIntegrator(field, 4, 0, range, 1.0e-12, 1.0e-12);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertEquals(0.0, handler.getLastError().getReal(), epsilonLast);         Assert.assertEquals(0.0, handler.getMaximalValueError().getReal(), epsilonMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(), epsilonMaxTime);         Assert.assertEquals(name, integ.getName());     }      @Test     public abstract void polynomial();      protected <T extends RealFieldElement<T>> void doPolynomial(final Field<T> field,                                                                 final int nLimit,                                                                 final double epsilonBad,                                                                 final double epsilonGood) {         TestFieldProblem6<T> pb = new TestFieldProblem6<>(field);         double range = pb.getFinalTime().subtract(pb.getInitialState().getTime()).abs().getReal();          for (int nSteps = 2; nSteps < 8; ++nSteps) {             AdamsFieldIntegrator<T> integ = createIntegrator(field, nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-4, 1.0e-4);             integ.setStarterIntegrator(new PerfectStarter<>(pb, nSteps));             TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);             integ.addStepHandler(handler);             integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());             if (nSteps < nLimit) {                 Assert.assertTrue(handler.getMaximalValueError().getReal() > epsilonBad);             } else {                 Assert.assertTrue(handler.getMaximalValueError().getReal() < epsilonGood);             }         }      }      @Test(expected=MathIllegalStateException.class)     public abstract void testStartFailure();      protected <T extends RealFieldElement<T>> void doTestStartFailure(final Field<T> field) {         TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         double minStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.0001).getReal();         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double scalAbsoluteTolerance = 1.0e-6;         double scalRelativeTolerance = 1.0e-7;          MultistepFieldIntegrator<T> integ = createIntegrator(field, 6, minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);         integ.setStarterIntegrator(new DormandPrince853FieldIntegrator<>(field, maxStep * 0.5, maxStep, 0.1, 0.1));         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());      }      private static class PerfectStarter<T extends RealFieldElement<T>> extends AbstractFieldIntegrator<T> {          private final PerfectInterpolator<T> interpolator;         private final int nbSteps;          public PerfectStarter(final TestFieldProblemAbstract<T> problem, final int nbSteps) {             super(problem.getField(), "perfect-starter");             this.interpolator = new PerfectInterpolator<>(problem);             this.nbSteps      = nbSteps;         }          @Override         public FieldODEStateAndDerivative<T> integrate(FieldExpandableODE<T> equations,                                                        FieldODEState<T> initialState, T finalTime) {             T tStart = initialState.getTime().add(finalTime.subtract(initialState.getTime()).multiply(0.01));             getEvaluationsCounter().increment(nbSteps);             interpolator.setCurrentTime(initialState.getTime());             for (int i = 0; i < nbSteps; ++i) {                 T tK = initialState.getTime().multiply(nbSteps - 1 - (i + 1)).add(tStart.multiply(i + 1)).divide(nbSteps - 1);                 interpolator.setPreviousTime(interpolator.getCurrentTime());                 interpolator.setCurrentTime(tK);                 for (FieldStepHandler<T> handler : getStepHandlers()) {                     handler.handleStep(interpolator, i == nbSteps - 1);                 }             }             return interpolator.getInterpolatedState(tStart);         }      }      private static class PerfectInterpolator<T extends RealFieldElement<T>> implements FieldStepInterpolator<T> {         private final TestFieldProblemAbstract<T> problem;         private T previousTime;         private T currentTime;          public PerfectInterpolator(final TestFieldProblemAbstract<T> problem) {             this.problem = problem;         }          public void setPreviousTime(T previousTime) {             this.previousTime = previousTime;         }          public void setCurrentTime(T currentTime) {             this.currentTime = currentTime;         }          public T getCurrentTime() {             return currentTime;         }          @Override         public boolean isForward() {             return problem.getFinalTime().subtract(problem.getInitialState().getTime()).getReal() >= 0;         }          @Override         public FieldODEStateAndDerivative<T> getPreviousState() {             return getInterpolatedState(previousTime);         }          @Override         public FieldODEStateAndDerivative<T> getCurrentState() {             return getInterpolatedState(currentTime);         }          @Override         public FieldODEStateAndDerivative<T> getInterpolatedState(T time) {             T[] y    = problem.computeTheoreticalState(time);             T[] yDot = problem.computeDerivatives(time, y);             return new FieldODEStateAndDerivative<>(time, y, yDot);         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.junit.Assert; import org.junit.Test;  public class AdamsNordsieckTransformerTest {      @Test     public void testPolynomialExtraDerivative() {         checkNordsieckStart(new PolynomialFunction(new double[] { 6, 5, 4, 3, 2, 1 }),                             5, 0.0, 0.125, 3.2e-16);     }      @Test     public void testPolynomialRegular() {         checkNordsieckStart(new PolynomialFunction(new double[] { 6, 5, 4, 3, 2, 1 }),                             4, 0.0, 0.125, 3.1e-16);     }      @Test     public void testPolynomialMissingLastDerivative() {         // this test intentionally uses not enough start points,         // the Nordsieck vector is therefore not expected to match the exact scaled derivatives         checkNordsieckStart(new PolynomialFunction(new double[] { 6, 5, 4, 3, 2, 1 }),                             3, 0.0, 0.125, 1.6e-4);     }      @Test     public void testTransformExact() {         // a 5 steps transformer handles a degree 5 polynomial exactly         // the Nordsieck vector holds the full information about the function         // transforming the vector from t0 to t0+h or recomputing it from scratch         // at t0+h yields the same result         checkTransform(new PolynomialFunction(new double[] { 6, 5, 4, 3, 2, 1 }), 5, 2.567e-15);     }      @Test     public void testTransformInexact() {         // a 4 steps transformer cannot handle a degree 5 polynomial exactly         // the Nordsieck vector lacks some high degree information about the function         // transforming the vector from t0 to t0+h or recomputing it from scratch         // at t0+h yields different results         checkTransform(new PolynomialFunction(new double[] { 6, 5, 4, 3, 2, 1 }), 4, 5.658e-4);     }      private void checkNordsieckStart(final PolynomialFunction polynomial, final int nbSteps, final double t0,                                      final double h, final double epsilon) {          final AdamsNordsieckTransformer transformer = AdamsNordsieckTransformer.getInstance(nbSteps);         PolynomialFunction derivative = polynomial.polynomialDerivative();         final Array2DRowRealMatrix nordsieck = start(transformer, nbSteps, t0, h, polynomial, derivative);          Assert.assertEquals(nbSteps - 1, nordsieck.getRowDimension());         double coeff = h;         for (int i = 0; i < nordsieck.getRowDimension(); ++i) {             coeff *= h / (i + 2);             derivative = derivative.polynomialDerivative();             Assert.assertEquals(derivative.value(t0) * coeff, nordsieck.getEntry(i, 0), epsilon);         }      }      private void checkTransform(final PolynomialFunction polynomial, final int nbSteps, final double expectedError) {          final AdamsNordsieckTransformer transformer = AdamsNordsieckTransformer.getInstance(nbSteps);         final PolynomialFunction derivative = polynomial.polynomialDerivative();          final double t0 = 0.0;         final double h  = 0.125;         final Array2DRowRealMatrix n0 = start(transformer, nbSteps, t0, h, polynomial, derivative);         final Array2DRowRealMatrix n1 = transformer.updateHighOrderDerivativesPhase1(n0);         transformer.updateHighOrderDerivativesPhase2(new double[] { h * derivative.value(t0)     },                                                      new double[] { h * derivative.value(t0 + h) },                                                      n1);         final Array2DRowRealMatrix n2 = start(transformer, nbSteps, t0 + h, h, polynomial, derivative);          Assert.assertEquals(expectedError, n2.subtract(n1).getNorm(), expectedError * 0.001);      }      private Array2DRowRealMatrix start(final AdamsNordsieckTransformer transformer, final int nbSteps,                                        final double t0, final double h,                                        final UnivariateFunction f0, final UnivariateFunction f1) {          final int        nbStartPoints = (nbSteps + 3) / 2;         final double[]   t             = new double[nbStartPoints];         final double[][] y             = new double[nbStartPoints][1];         final double[][] yDot          = new double[nbStartPoints][1];         for (int i = 0; i < nbStartPoints; ++i) {             t[i]       = t0 + i * h;             y[i][0]    = f0.value(t[i]);             yDot[i][0] = f1.value(t[i]);         }          return transformer.initializeHighOrderDerivatives(h, t, y, yDot);      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class MidpointFieldIntegratorTest extends RungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, T step) {         return new MidpointFieldIntegrator<>(field, step);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testMissedEndEvent() {         doTestMissedEndEvent(Decimal64Field.getInstance(), 1.0e-15, 6.0e-5);     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testDecreasingSteps() {         doTestDecreasingSteps(Decimal64Field.getInstance(), 1.0, 1.0, 1.0e-10);     }      @Override     public void testSmallStep() {         doTestSmallStep(Decimal64Field.getInstance(), 2.0e-7, 1.0e-6, 1.0e-12, "midpoint");     }      @Override     public void testBigStep() {         doTestBigStep(Decimal64Field.getInstance(), 0.01, 0.05, 1.0e-12, "midpoint");      }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(), 6.0e-4, 6.0e-4, 1.0e-12, "midpoint");     }      @Override     public void testKepler() {         doTestKepler(Decimal64Field.getInstance(), 1.19, 0.01);     }      @Override     public void testStepSize() {         doTestStepSize(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testSingleStep() {         doTestSingleStep(Decimal64Field.getInstance(), 0.21);     }      @Override     public void testTooLargeFirstStep() {         doTestTooLargeFirstStep(Decimal64Field.getInstance());     }      @Override     public void testUnstableDerivative() {         doTestUnstableDerivative(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testDerivativesConsistency() {         doTestDerivativesConsistency(Decimal64Field.getInstance(), 1.0e-10);     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(1.7e-4, new double[] { 1.0e-3, 2.8e-4, 3.8e-5, 2.8e-4, 2.8e-4 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test;  public class LutherStepInterpolatorTest {      @Test     public void derivativesConsistency()             throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {         TestProblem3 pb = new TestProblem3();         double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;         LutherIntegrator integ = new LutherIntegrator(step);         StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 6.5e-12);     }      @Test     public void serialization()             throws IOException, ClassNotFoundException,             DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException  {          TestProblem3 pb = new TestProblem3(0.9);         double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;         LutherIntegrator integ = new LutherIntegrator(step);         integ.addStepHandler(new ContinuousOutputModel());         integ.integrate(pb,                         pb.getInitialTime(), pb.getInitialState(),                         pb.getFinalTime(), new double[pb.getDimension()]);          ByteArrayOutputStream bos = new ByteArrayOutputStream();         ObjectOutputStream    oos = new ObjectOutputStream(bos);         for (StepHandler handler : integ.getStepHandlers()) {             oos.writeObject(handler);         }          Assert.assertTrue(bos.size() > 1200000);         Assert.assertTrue(bos.size() < 1250000);          ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());         ObjectInputStream     ois = new ObjectInputStream(bis);         ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();          Random random = new Random(347588535632l);         double maxError = 0.0;         for (int i = 0; i < 1000; ++i) {             double r = random.nextDouble();             double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();             cm.setInterpolatedTime(time);             double[] interpolatedY = cm.getInterpolatedState ();             double[] theoreticalY  = pb.computeTheoreticalState(time);             double dx = interpolatedY[0] - theoreticalY[0];             double dy = interpolatedY[1] - theoreticalY[1];             double error = dx * dx + dy * dy;             if (error > maxError) {                 maxError = error;             }         }          Assert.assertTrue(maxError < 2.2e-7);      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.EquationsMapper; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class EulerStepInterpolatorTest {    @Test   public void noReset() throws MaxCountExceededException {      double[]   y    =   { 0.0, 1.0, -2.0 };     double[][] yDot = { { 1.0, 2.0, -2.0 } };     EulerStepInterpolator interpolator = new EulerStepInterpolator();     interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true,                               new EquationsMapper(0, y.length),                               new EquationsMapper[0]);     interpolator.storeTime(0);     interpolator.shift();     interpolator.storeTime(1);      double[] result = interpolator.getInterpolatedState();     for (int i = 0; i < result.length; ++i) {       Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);     }    }    @Test   public void interpolationAtBounds() throws MaxCountExceededException {      double   t0 = 0;     double[] y0 = {0.0, 1.0, -2.0};      double[] y = y0.clone();     double[][] yDot = { new double[y0.length] };     EulerStepInterpolator interpolator = new EulerStepInterpolator();     interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true,                               new EquationsMapper(0, y.length),                               new EquationsMapper[0]);     interpolator.storeTime(t0);      double dt = 1.0;     interpolator.shift();     y[0] =  1.0;     y[1] =  3.0;     y[2] = -4.0;     yDot[0][0] = (y[0] - y0[0]) / dt;     yDot[0][1] = (y[1] - y0[1]) / dt;     yDot[0][2] = (y[2] - y0[2]) / dt;     interpolator.storeTime(t0 + dt);      interpolator.setInterpolatedTime(interpolator.getPreviousTime());     double[] result = interpolator.getInterpolatedState();     for (int i = 0; i < result.length; ++i) {         Assert.assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);     }      interpolator.setInterpolatedTime(interpolator.getCurrentTime());     result = interpolator.getInterpolatedState();     for (int i = 0; i < result.length; ++i) {       Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);     }    }    @Test   public void interpolationInside() throws MaxCountExceededException {      double[]   y    =   { 0.0, 1.0, -2.0 };     double[][] yDot = { { 1.0, 2.0, -2.0 } };     EulerStepInterpolator interpolator = new EulerStepInterpolator();     interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true,                               new EquationsMapper(0, y.length),                               new EquationsMapper[0]);     interpolator.storeTime(0);     interpolator.shift();     y[0] =  1.0;     y[1] =  3.0;     y[2] = -4.0;     interpolator.storeTime(1);      interpolator.setInterpolatedTime(0.1);     double[] result = interpolator.getInterpolatedState();     Assert.assertTrue(FastMath.abs(result[0] - 0.1) < 1.0e-10);     Assert.assertTrue(FastMath.abs(result[1] - 1.2) < 1.0e-10);     Assert.assertTrue(FastMath.abs(result[2] + 2.2) < 1.0e-10);      interpolator.setInterpolatedTime(0.5);     result = interpolator.getInterpolatedState();     Assert.assertTrue(FastMath.abs(result[0] - 0.5) < 1.0e-10);     Assert.assertTrue(FastMath.abs(result[1] - 2.0) < 1.0e-10);     Assert.assertTrue(FastMath.abs(result[2] + 3.0) < 1.0e-10);    }    @Test   public void derivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;     EulerIntegrator integ = new EulerIntegrator(step);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 5.1e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;     EulerIntegrator integ = new EulerIntegrator(step);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }     Assert.assertTrue(maxError < 0.001);    }    private static class DummyIntegrator extends RungeKuttaIntegrator {         protected DummyIntegrator(RungeKuttaStepInterpolator prototype) {           super("dummy", new double[0], new double[0][0], new double[0], prototype, Double.NaN);       }    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class EulerFieldIntegratorTest extends RungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, T step) {         return new EulerFieldIntegrator<>(field, step);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testMissedEndEvent() {         doTestMissedEndEvent(Decimal64Field.getInstance(), 1.0e-15, 6.0e-5);     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testDecreasingSteps() {         doTestDecreasingSteps(Decimal64Field.getInstance(), 1.0, 1.5, 1.0e-10);     }      @Override     public void testSmallStep() {         doTestSmallStep(Decimal64Field.getInstance(), 2.0e-4, 1.0e-3, 1.0e-12, "Euler");     }      @Override     public void testBigStep() {         doTestBigStep(Decimal64Field.getInstance(), 0.01, 0.2, 1.0e-12, "Euler");      }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(),0.45, 0.45, 1.0e-12, "Euler");     }      @Override     public void testKepler() {         // Euler integrator is clearly not able to solve this problem         doTestKepler(Decimal64Field.getInstance(), 881.176, 0.001);     }      @Override     public void testStepSize() {         doTestStepSize(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testSingleStep() {         doTestSingleStep(Decimal64Field.getInstance(), 0.21);     }      @Override     public void testTooLargeFirstStep() {         doTestTooLargeFirstStep(Decimal64Field.getInstance());     }      @Override     public void testUnstableDerivative() {         doTestUnstableDerivative(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testDerivativesConsistency() {         doTestDerivativesConsistency(Decimal64Field.getInstance(), 1.0e-10);     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(0.085, new double[] { 0.47, 0.13, 0.019, 0.019, 0.13 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test;  public class ClassicalRungeKuttaStepInterpolatorTest {    @Test   public void derivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;     ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 6.6e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException  {      TestProblem3 pb = new TestProblem3(0.9);     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;     ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 880000);     Assert.assertTrue(bos.size () < 900000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError > 0.005);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test;  public class MidpointStepInterpolatorTest {    @Test   public void testDerivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;     MidpointIntegrator integ = new MidpointIntegrator(step);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 6.6e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;     MidpointIntegrator integ = new MidpointIntegrator(step);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 135000);     Assert.assertTrue(bos.size () < 145000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError < 1.0e-6);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class DormandPrince54FieldIntegratorTest extends EmbeddedRungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance) {         return new DormandPrince54FieldIntegrator<>(field, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);     }      @Override     protected <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {         return new DormandPrince54FieldIntegrator<>(field, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(), 1.6e-7, 1.6e-7, 1.0e-22, "Dormand-Prince 5(4)");     }      @Override     public void testKepler() {         doTestKepler(Decimal64Field.getInstance(), 3.1e-10);     }      @Override     public void testForwardBackwardExceptions() {         doTestForwardBackwardExceptions(Decimal64Field.getInstance());     }      @Override     public void testMinStep() {         doTestMinStep(Decimal64Field.getInstance());     }      @Override     public void testIncreasingTolerance() {         // the 0.7 factor is only valid for this test         // and has been obtained from trial and error         // there is no general relation between local and global errors         doTestIncreasingTolerance(Decimal64Field.getInstance(), 0.7, 1.0e-12);     }      @Override     public void testEvents() {         doTestEvents(Decimal64Field.getInstance(), 1.7e-7, "Dormand-Prince 5(4)");     }      @Override     public void testEventsErrors() {         doTestEventsErrors(Decimal64Field.getInstance());     }      @Override     public void testEventsNoConvergence() {         doTestEventsNoConvergence(Decimal64Field.getInstance());     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(4.8e-12, new double[] { 2.3e-11, 6.3e-12, 9.0e-13, 7.4e-13, 6.3e-12 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   public class GraggBulirschStoerIntegratorTest {    @Test(expected=DimensionMismatchException.class)   public void testDimensionCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       AdaptiveStepsizeIntegrator integrator =         new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);       integrator.integrate(pb,                            0.0, new double[pb.getDimension()+10],                            1.0, new double[pb.getDimension()+10]);   }    @Test(expected=NumberIsTooSmallException.class)   public void testNullIntervalCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       GraggBulirschStoerIntegrator integrator =         new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);       integrator.integrate(pb,                            0.0, new double[pb.getDimension()],                            0.0, new double[pb.getDimension()]);   }    @Test(expected=NumberIsTooSmallException.class)   public void testMinStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb  = new TestProblem5();       double minStep   = 0.1 * FastMath.abs(pb.getFinalTime() - pb.getInitialTime());       double maxStep   = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());       double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };       double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };        FirstOrderIntegrator integ =         new GraggBulirschStoerIntegrator(minStep, maxStep,                                          vecAbsoluteTolerance, vecRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                     scalAbsoluteTolerance,                                                                     scalRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 7.5e-9);       Assert.assertTrue(handler.getMaximalValueError() < 8.1e-9);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName());   }    @Test   public void testIncreasingTolerance()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      int previousCalls = Integer.MAX_VALUE;     for (int i = -12; i < -4; ++i) {       TestProblem1 pb     = new TestProblem1();       double minStep      = 0;       double maxStep      = pb.getFinalTime() - pb.getInitialTime();       double absTolerance = FastMath.pow(10.0, i);       double relTolerance = absTolerance;        FirstOrderIntegrator integ =         new GraggBulirschStoerIntegrator(minStep, maxStep,                                          absTolerance, relTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        // the coefficients are only valid for this test       // and have been obtained from trial and error       // there is no general relation between local and global errors       double ratio =  handler.getMaximalValueError() / absTolerance;       Assert.assertTrue(ratio < 2.4);       Assert.assertTrue(ratio > 0.02);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);        int calls = pb.getCalls();       Assert.assertEquals(integ.getEvaluations(), calls);       Assert.assertTrue(calls <= previousCalls);       previousCalls = calls;      }    }    @Test   public void testIntegratorControls()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem3 pb = new TestProblem3(0.999);     GraggBulirschStoerIntegrator integ =         new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(),                 1.0e-8, 1.0e-10);      double errorWithDefaultSettings = getMaxError(integ, pb);      // stability control     integ.setStabilityCheck(true, 2, 1, 0.99);     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));     integ.setStabilityCheck(true, -1, -1, -1);      integ.setControlFactors(0.5, 0.99, 0.1, 2.5);     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));     integ.setControlFactors(-1, -1, -1, -1);      integ.setOrderControl(10, 0.7, 0.95);     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));     integ.setOrderControl(-1, -1, -1);      integ.setInterpolationControl(true, 3);     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));     integ.setInterpolationControl(true, -1);    }    private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblemHandler handler = new TestProblemHandler(pb, integrator);       integrator.addStepHandler(handler);       integrator.integrate(pb,                            pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);       return handler.getMaximalValueError();   }    @Test   public void testEvents()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem4 pb = new TestProblem4();     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-10;     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                   scalAbsoluteTolerance,                                                                   scalRelativeTolerance);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     EventHandler[] functions = pb.getEventsHandlers();     double convergence = 1.0e-8 * maxStep;     for (int l = 0; l < functions.length; ++l) {       integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);     }     Assert.assertEquals(functions.length, integ.getEventHandlers().size());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getMaximalValueError() < 4.0e-7);     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);     Assert.assertEquals(12.0, handler.getLastTime(), convergence);     integ.clearEventHandlers();     Assert.assertEquals(0, integ.getEventHandlers().size());    }    @Test   public void testKepler()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb = new TestProblem3(0.9);     double minStep        = 0;     double maxStep        = pb.getFinalTime() - pb.getInitialTime();     double absTolerance   = 1.0e-6;     double relTolerance   = 1.0e-6;      FirstOrderIntegrator integ =       new GraggBulirschStoerIntegrator(minStep, maxStep,                                        absTolerance, relTolerance);     integ.addStepHandler(new KeplerStepHandler(pb));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertEquals(integ.getEvaluations(), pb.getCalls());     Assert.assertTrue(pb.getCalls() < 2150);    }    @Test   public void testVariableSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb = new TestProblem3(0.9);     double minStep        = 0;     double maxStep        = pb.getFinalTime() - pb.getInitialTime();     double absTolerance   = 1.0e-8;     double relTolerance   = 1.0e-8;     FirstOrderIntegrator integ =       new GraggBulirschStoerIntegrator(minStep, maxStep,                                        absTolerance, relTolerance);     integ.addStepHandler(new VariableStepHandler());     double stopTime = integ.integrate(pb,                                       pb.getInitialTime(), pb.getInitialState(),                                       pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);     Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName());   }    @Test   public void testTooLargeFirstStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        AdaptiveStepsizeIntegrator integ =               new GraggBulirschStoerIntegrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);       final double start = 0.0;       final double end   = 0.001;       FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() {            @Override         public int getDimension() {               return 1;           }            @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {               Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY));               Assert.assertTrue(t <= FastMath.nextAfter(end,   Double.POSITIVE_INFINITY));               yDot[0] = -100.0 * y[0];           }        };        integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8);       integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]);    }    @Test   public void testUnstableDerivative()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);     FirstOrderIntegrator integ =       new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);     double[] y = { Double.NaN };     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);     Assert.assertEquals(8.0, y[0], 1.0e-12);   }    @Test   public void testIssue596()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(1e-10, 100.0, 1e-7, 1e-7);       integ.addStepHandler(new StepHandler() {            @Override         public void init(double t0, double[] y0, double t) {           }            @Override         public void handleStep(StepInterpolator interpolator, boolean isLast)               throws MaxCountExceededException {               double t = interpolator.getCurrentTime();               interpolator.setInterpolatedTime(t);               double[] y = interpolator.getInterpolatedState();               double[] yDot = interpolator.getInterpolatedDerivatives();               Assert.assertEquals(3.0 * t - 5.0, y[0], 1.0e-14);               Assert.assertEquals(3.0, yDot[0], 1.0e-14);           }       });       double[] y = {4.0};       double t0 = 3.0;       double tend = 10.0;       integ.integrate(new FirstOrderDifferentialEquations() {           @Override         public int getDimension() {               return 1;           }            @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {               yDot[0] = 3.0;           }       }, t0, y, tend, y);    }    private static class KeplerStepHandler implements StepHandler {     public KeplerStepHandler(TestProblem3 pb) {       this.pb = pb;     }     @Override     public void init(double t0, double[] y0, double t) {       nbSteps = 0;       maxError = 0;     }     @Override     public void handleStep(StepInterpolator interpolator, boolean isLast)         throws MaxCountExceededException {        ++nbSteps;       for (int a = 1; a < 100; ++a) {          double prev   = interpolator.getPreviousTime();         double curr   = interpolator.getCurrentTime();         double interp = ((100 - a) * prev + a * curr) / 100;         interpolator.setInterpolatedTime(interp);          double[] interpolatedY = interpolator.getInterpolatedState ();         double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());         double dx = interpolatedY[0] - theoreticalY[0];         double dy = interpolatedY[1] - theoreticalY[1];         double error = dx * dx + dy * dy;         if (error > maxError) {           maxError = error;         }       }       if (isLast) {         Assert.assertTrue(maxError < 2.7e-6);         Assert.assertTrue(nbSteps < 80);       }     }     private int nbSteps;     private double maxError;     private TestProblem3 pb;   }    public static class VariableStepHandler implements StepHandler {     public VariableStepHandler() {         firstTime = true;         minStep = 0;         maxStep = 0;     }     @Override     public void init(double t0, double[] y0, double t) {       firstTime = true;       minStep = 0;       maxStep = 0;     }     @Override     public void handleStep(StepInterpolator interpolator,                            boolean isLast) {        double step = FastMath.abs(interpolator.getCurrentTime()                              - interpolator.getPreviousTime());       if (firstTime) {         minStep   = FastMath.abs(step);         maxStep   = minStep;         firstTime = false;       } else {         if (step < minStep) {           minStep = step;         }         if (step > maxStep) {           maxStep = step;         }       }        if (isLast) {         Assert.assertTrue(minStep < 8.2e-3);         Assert.assertTrue(maxStep > 1.5);       }     }     private boolean firstTime;     private double  minStep;     private double  maxStep;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class HighamHall54StepInterpolatorTest {    @Test   public void derivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3(0.1);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 4.8e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException {      TestProblem3 pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 185000);     Assert.assertTrue(bos.size () < 195000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError < 1.6e-10);    }    @Test   public void checkClone()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);     integ.addStepHandler(new StepHandler() {         @Override         public void handleStep(StepInterpolator interpolator, boolean isLast)             throws MaxCountExceededException {             StepInterpolator cloned = interpolator.copy();             double tA = cloned.getPreviousTime();             double tB = cloned.getCurrentTime();             double halfStep = FastMath.abs(tB - tA) / 2;             Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);             Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);             for (int i = 0; i < 10; ++i) {                 double t = (i * tB + (9 - i) * tA) / 9;                 interpolator.setInterpolatedTime(t);                 Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                 cloned.setInterpolatedTime(t);                 Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                 double[] referenceState = interpolator.getInterpolatedState();                 double[] cloneState     = cloned.getInterpolatedState();                 for (int j = 0; j < referenceState.length; ++j) {                     Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                 }             }         }         @Override         public void init(double t0, double[] y0, double t) {         }     });     integ.integrate(pb,             pb.getInitialTime(), pb.getInitialState(),             pb.getFinalTime(), new double[pb.getDimension()]);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class HighamHall54FieldIntegratorTest extends EmbeddedRungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance) {         return new HighamHall54FieldIntegrator<>(field, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);     }      @Override     protected <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {         return new HighamHall54FieldIntegrator<>(field, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(), 5.0e-7, 5.0e-7, 1.0e-12, "Higham-Hall 5(4)");     }      @Override     public void testKepler() {         doTestKepler(Decimal64Field.getInstance(), 1.5e-4);     }      @Override     public void testForwardBackwardExceptions() {         doTestForwardBackwardExceptions(Decimal64Field.getInstance());     }      @Override     public void testMinStep() {         doTestMinStep(Decimal64Field.getInstance());     }      @Override     public void testIncreasingTolerance() {         // the 1.3 factor is only valid for this test         // and has been obtained from trial and error         // there is no general relation between local and global errors         doTestIncreasingTolerance(Decimal64Field.getInstance(), 1.3, 1.0e-12);     }      @Override     public void testEvents() {         doTestEvents(Decimal64Field.getInstance(), 1.0e-7, "Higham-Hall 5(4)");     }      @Override     public void testEventsErrors() {         doTestEventsErrors(Decimal64Field.getInstance());     }      @Override     public void testEventsNoConvergence() {         doTestEventsNoConvergence(Decimal64Field.getInstance());     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(1.2e-11, new double[] { 6.4e-11, 1.8e-11, 2.4e-12, 2.2e-12, 1.8e-11 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class DormandPrince54FieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new DormandPrince54FieldStepInterpolator<>(field, forward, yDotK,                                                            globalPreviousState, globalCurrentState,                                                            softPreviousState, softCurrentState,                                                            mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new DormandPrince54FieldIntegrator<>(field, 0, 1, 1, 1);     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-50);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 9.5e-14, 1.8e-15);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 2.8e-17, 2.3e-16, 5.6e-16, 5.6e-17);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem2; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblem6; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class ClassicalRungeKuttaIntegratorTest {    @Test   public void testMissedEndEvent()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final double   t0     = 1878250320.0000029;       final double   tEvent = 1878250379.9999986;       final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };       FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {            @Override         public int getDimension() {               return k.length;           }            @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {               for (int i = 0; i < y.length; ++i) {                   yDot[i] = k[i] * y[i];               }           }       };        ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);        double[] y0   = new double[k.length];       for (int i = 0; i < y0.length; ++i) {           y0[i] = i + 1;       }       double[] y    = new double[k.length];        double finalT = integrator.integrate(ode, t0, y0, tEvent, y);       Assert.assertEquals(tEvent, finalT, 5.0e-6);       for (int i = 0; i < y.length; ++i) {           Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);       }        integrator.addEventHandler(new EventHandler() {            @Override         public void init(double t0, double[] y0, double t) {           }            @Override         public void resetState(double t, double[] y) {           }            @Override         public double g(double t, double[] y) {               return t - tEvent;           }            @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {               Assert.assertEquals(tEvent, t, 5.0e-6);               return Action.CONTINUE;           }       }, Double.POSITIVE_INFINITY, 1.0e-20, 100);       finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);       Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);       for (int i = 0; i < y.length; ++i) {           Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);       }    }    @Test   public void testSanityChecks()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     try  {       TestProblem1 pb = new TestProblem1();       new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                         0.0, new double[pb.getDimension()+10],                                                         1.0, new double[pb.getDimension()]);         Assert.fail("an exception should have been thrown");     } catch(DimensionMismatchException ie) {     }     try  {         TestProblem1 pb = new TestProblem1();         new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                           0.0, new double[pb.getDimension()],                                                           1.0, new double[pb.getDimension()+10]);           Assert.fail("an exception should have been thrown");       } catch(DimensionMismatchException ie) {       }     try  {       TestProblem1 pb = new TestProblem1();       new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                         0.0, new double[pb.getDimension()],                                                         0.0, new double[pb.getDimension()]);         Assert.fail("an exception should have been thrown");     } catch(NumberIsTooSmallException ie) {     }   }    @Test   public void testDecreasingSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      for (TestProblemAbstract pb : new TestProblemAbstract[] {         new TestProblem1(), new TestProblem2(), new TestProblem3(),         new TestProblem4(), new TestProblem5(), new TestProblem6()     }) {        double previousValueError = Double.NaN;       double previousTimeError = Double.NaN;       for (int i = 4; i < 10; ++i) {          double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);          FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);         TestProblemHandler handler = new TestProblemHandler(pb, integ);         integ.addStepHandler(handler);         EventHandler[] functions = pb.getEventsHandlers();         for (int l = 0; l < functions.length; ++l) {           integ.addEventHandler(functions[l],                                      Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);         }         Assert.assertEquals(functions.length, integ.getEventHandlers().size());         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                           pb.getFinalTime(), new double[pb.getDimension()]);         if (functions.length == 0) {             Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);         }          double error = handler.getMaximalValueError();         if (i > 4) {           Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError));         }         previousValueError = error;          double timeError = handler.getMaximalTimeError();         if (i > 4) {           Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));         }         previousTimeError = timeError;          integ.clearEventHandlers();         Assert.assertEquals(0, integ.getEventHandlers().size());       }      }    }    @Test   public void testSmallStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 2.0e-13);     Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);     Assert.assertEquals("classical Runge-Kutta", integ.getName());   }    @Test   public void testBigStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem1 pb = new TestProblem1();     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() > 0.0004);     Assert.assertTrue(handler.getMaximalValueError() > 0.005);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem5 pb = new TestProblem5();     double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 5.0e-10);     Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);     Assert.assertEquals("classical Runge-Kutta", integ.getName());   }    @Test   public void testKepler()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);     integ.addStepHandler(new KeplerHandler(pb));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);   }    private static class KeplerHandler implements StepHandler {     public KeplerHandler(TestProblem3 pb) {       this.pb = pb;       maxError = 0;     }     @Override     public void init(double t0, double[] y0, double t) {       maxError = 0;     }     @Override     public void handleStep(StepInterpolator interpolator, boolean isLast)         throws MaxCountExceededException {        double[] interpolatedY = interpolator.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }       if (isLast) {         // even with more than 1000 evaluations per period,         // RK4 is not able to integrate such an eccentric         // orbit with a good accuracy         Assert.assertTrue(maxError > 0.005);       }     }     private double maxError = 0;     private TestProblem3 pb;   }    @Test   public void testStepSize()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final double step = 1.23456;       FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);       integ.addStepHandler(new StepHandler() {           @Override         public void handleStep(StepInterpolator interpolator, boolean isLast) {               if (! isLast) {                   Assert.assertEquals(step,                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),                                1.0e-12);               }           }           @Override         public void init(double t0, double[] y0, double t) {           }       });       integ.integrate(new FirstOrderDifferentialEquations() {           @Override         public void computeDerivatives(double t, double[] y, double[] dot) {               dot[0] = 1.0;           }           @Override         public int getDimension() {               return 1;           }       }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);   }    @Test   public void testTooLargeFirstStep() {        RungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(0.5);       final double start = 0.0;       final double end   = 0.001;       FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() {            @Override         public int getDimension() {               return 1;           }            @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {               Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY));               Assert.assertTrue(t <= FastMath.nextAfter(end,   Double.POSITIVE_INFINITY));               yDot[0] = -100.0 * y[0];           }        };        integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblemAbstract; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   public class DormandPrince54IntegratorTest {    @Test(expected=DimensionMismatchException.class)   public void testDimensionCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,                                                                            1.0e-10, 1.0e-10);       integrator.integrate(pb,                            0.0, new double[pb.getDimension()+10],                            1.0, new double[pb.getDimension()+10]);   }    @Test(expected=NumberIsTooSmallException.class)   public void testMinStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem1 pb = new TestProblem1();       double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };       double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };        FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                  vecAbsoluteTolerance,                                                                  vecRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);       Assert.fail("an exception should have been thrown");    }    @Test   public void testSmallLastStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblemAbstract pb = new TestProblem5();     double minStep = 1.25;     double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());     double scalAbsoluteTolerance = 6.0e-4;     double scalRelativeTolerance = 6.0e-4;      AdaptiveStepsizeIntegrator integ =       new DormandPrince54Integrator(minStep, maxStep,                                     scalAbsoluteTolerance,                                     scalRelativeTolerance);      DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);     integ.addStepHandler(handler);     integ.setInitialStepSize(1.7);     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertTrue(handler.wasLastSeen());     Assert.assertEquals("Dormand-Prince 5(4)", integ.getName());    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 2.0e-7);       Assert.assertTrue(handler.getMaximalValueError() < 2.0e-7);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("Dormand-Prince 5(4)", integ.getName());   }    private static class DP54SmallLastHandler implements StepHandler {      public DP54SmallLastHandler(double minStep) {       lastSeen = false;       this.minStep = minStep;     }      @Override     public void init(double t0, double[] y0, double t) {     }      @Override     public void handleStep(StepInterpolator interpolator, boolean isLast) {       if (isLast) {         lastSeen = true;         double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();         Assert.assertTrue(FastMath.abs(h) < minStep);       }     }      public boolean wasLastSeen() {       return lastSeen;     }      private boolean lastSeen;     private double  minStep;    }    @Test   public void testIncreasingTolerance()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      int previousCalls = Integer.MAX_VALUE;     for (int i = -12; i < -2; ++i) {       TestProblem1 pb = new TestProblem1();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = FastMath.pow(10.0, i);       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        EmbeddedRungeKuttaIntegrator integ =           new DormandPrince54Integrator(minStep, maxStep,                                         scalAbsoluteTolerance, scalRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.setSafety(0.8);       integ.setMaxGrowth(5.0);       integ.setMinReduction(0.3);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);       Assert.assertEquals(0.8, integ.getSafety(), 1.0e-12);       Assert.assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);       Assert.assertEquals(0.3, integ.getMinReduction(), 1.0e-12);        // the 0.7 factor is only valid for this test       // and has been obtained from trial and error       // there is no general relation between local and global errors       Assert.assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);        int calls = pb.getCalls();       Assert.assertEquals(integ.getEvaluations(), calls);       Assert.assertTrue(calls <= previousCalls);       previousCalls = calls;      }    }    @Test   public void testEvents()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem4 pb = new TestProblem4();     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     EventHandler[] functions = pb.getEventsHandlers();     double convergence = 1.0e-8 * maxStep;     for (int l = 0; l < functions.length; ++l) {       integ.addEventHandler(functions[l],                                  Double.POSITIVE_INFINITY, convergence, 1000);     }     Assert.assertEquals(functions.length, integ.getEventHandlers().size());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getMaximalValueError() < 5.0e-6);     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);     Assert.assertEquals(12.0, handler.getLastTime(), convergence);     integ.clearEventHandlers();     Assert.assertEquals(0, integ.getEventHandlers().size());    }    @Test   public void testKepler()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);     integ.addStepHandler(new KeplerHandler(pb));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertEquals(integ.getEvaluations(), pb.getCalls());     Assert.assertTrue(pb.getCalls() < 2800);    }    @Test   public void testVariableSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);     integ.addStepHandler(new VariableHandler());     double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                       pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);   }    private static class KeplerHandler implements StepHandler {     public KeplerHandler(TestProblem3 pb) {       this.pb = pb;     }     @Override     public void init(double t0, double[] y0, double t) {       nbSteps = 0;       maxError = 0;     }     @Override     public void handleStep(StepInterpolator interpolator, boolean isLast)         throws MaxCountExceededException {        ++nbSteps;       for (int a = 1; a < 10; ++a) {          double prev   = interpolator.getPreviousTime();         double curr   = interpolator.getCurrentTime();         double interp = ((10 - a) * prev + a * curr) / 10;         interpolator.setInterpolatedTime(interp);          double[] interpolatedY = interpolator.getInterpolatedState ();         double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());         double dx = interpolatedY[0] - theoreticalY[0];         double dy = interpolatedY[1] - theoreticalY[1];         double error = dx * dx + dy * dy;         if (error > maxError) {           maxError = error;         }       }       if (isLast) {         Assert.assertTrue(maxError < 7.0e-10);         Assert.assertTrue(nbSteps < 400);       }     }     private int nbSteps;     private double maxError;     private TestProblem3 pb;   }    private static class VariableHandler implements StepHandler {     public VariableHandler() {       firstTime = true;       minStep = 0;       maxStep = 0;     }     @Override     public void init(double t0, double[] y0, double t) {       firstTime = true;       minStep = 0;       maxStep = 0;     }     @Override     public void handleStep(StepInterpolator interpolator,                            boolean isLast) {        double step = FastMath.abs(interpolator.getCurrentTime()                              - interpolator.getPreviousTime());       if (firstTime) {         minStep   = FastMath.abs(step);         maxStep   = minStep;         firstTime = false;       } else {         if (step < minStep) {           minStep = step;         }         if (step > maxStep) {           maxStep = step;         }       }        if (isLast) {         Assert.assertTrue(minStep < (1.0 / 450.0));         Assert.assertTrue(maxStep > (1.0 / 4.2));       }     }     private boolean firstTime;     private double  minStep;     private double  maxStep;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class ThreeEighthesFieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new ThreeEighthesFieldStepInterpolator<>(field, forward, yDotK,                                                          globalPreviousState, globalCurrentState,                                                          softPreviousState, softCurrentState,                                                          mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new ThreeEighthesFieldIntegrator<>(field, field.getOne());     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-15);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 2.6e-7, 3.6e-6);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 1.4e-17, 1.2e-16, 3.4e-16, 1.4e-17);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FieldExpandableODE; import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderFieldIntegrator; import org.apache.commons.math4.ode.FieldODEState; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.TestFieldProblem1; import org.apache.commons.math4.ode.TestFieldProblem3; import org.apache.commons.math4.ode.TestFieldProblem4; import org.apache.commons.math4.ode.TestFieldProblem5; import org.apache.commons.math4.ode.TestFieldProblemHandler; import org.apache.commons.math4.ode.events.Action; import org.apache.commons.math4.ode.events.FieldEventHandler; import org.apache.commons.math4.ode.sampling.FieldStepHandler; import org.apache.commons.math4.ode.sampling.FieldStepInterpolator; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  public abstract class EmbeddedRungeKuttaFieldIntegratorAbstractTest {      protected abstract <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance);      protected abstract <T extends RealFieldElement<T>> EmbeddedRungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance);      @Test     public abstract void testNonFieldIntegratorConsistency();      protected <T extends RealFieldElement<T>> void doTestNonFieldIntegratorConsistency(final Field<T> field) {         try {              // get the Butcher arrays from the field integrator             EmbeddedRungeKuttaFieldIntegrator<T> fieldIntegrator = createIntegrator(field, 0.001, 1.0, 1.0, 1.0);             T[][] fieldA = fieldIntegrator.getA();             T[]   fieldB = fieldIntegrator.getB();             T[]   fieldC = fieldIntegrator.getC();             if (fieldIntegrator instanceof DormandPrince853FieldIntegrator) {                 // special case for Dormand-Prince 8(5,3), the array in the regular                 // integrator is smaller because as of 3.X, the interpolation steps                 // are not performed by the integrator itself                 T[][] reducedFieldA = MathArrays.buildArray(field, 12, -1);                 T[]   reducedFieldB = MathArrays.buildArray(field, 13);                 T[]   reducedFieldC = MathArrays.buildArray(field, 12);                 System.arraycopy(fieldA, 0, reducedFieldA, 0, reducedFieldA.length);                 System.arraycopy(fieldB, 0, reducedFieldB, 0, reducedFieldB.length);                 System.arraycopy(fieldC, 0, reducedFieldC, 0, reducedFieldC.length);                 fieldA = reducedFieldA;                 fieldB = reducedFieldB;                 fieldC = reducedFieldC;             }              String fieldName   = fieldIntegrator.getClass().getName();             String regularName = fieldName.replaceAll("Field", "");              // get the Butcher arrays from the regular integrator             @SuppressWarnings("unchecked")             Class<RungeKuttaIntegrator> c = (Class<RungeKuttaIntegrator>) Class.forName(regularName);             java.lang.reflect.Field jlrFieldA = c.getDeclaredField("STATIC_A");             jlrFieldA.setAccessible(true);             double[][] regularA = (double[][]) jlrFieldA.get(null);             java.lang.reflect.Field jlrFieldB = c.getDeclaredField("STATIC_B");             jlrFieldB.setAccessible(true);             double[]   regularB = (double[])   jlrFieldB.get(null);             java.lang.reflect.Field jlrFieldC = c.getDeclaredField("STATIC_C");             jlrFieldC.setAccessible(true);             double[]   regularC = (double[])   jlrFieldC.get(null);              Assert.assertEquals(regularA.length, fieldA.length);             for (int i = 0; i < regularA.length; ++i) {                 checkArray(regularA[i], fieldA[i]);             }             checkArray(regularB, fieldB);             checkArray(regularC, fieldC);          } catch (ClassNotFoundException cnfe) {             Assert.fail(cnfe.getLocalizedMessage());         } catch (IllegalAccessException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (IllegalArgumentException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (SecurityException se) {             Assert.fail(se.getLocalizedMessage());         } catch (NoSuchFieldException nsfe) {             Assert.fail(nsfe.getLocalizedMessage());         }     }      private <T extends RealFieldElement<T>> void checkArray(double[] regularArray, T[] fieldArray) {         Assert.assertEquals(regularArray.length, fieldArray.length);         for (int i = 0; i < regularArray.length; ++i) {             if (regularArray[i] == 0) {                 Assert.assertTrue(0.0 == fieldArray[i].getReal());             } else {                 Assert.assertEquals(regularArray[i], fieldArray[i].getReal(), FastMath.ulp(regularArray[i]));             }         }     }      @Test     public abstract void testForwardBackwardExceptions();      protected <T extends RealFieldElement<T>> void doTestForwardBackwardExceptions(final Field<T> field) {         FirstOrderFieldDifferentialEquations<T> equations = new FirstOrderFieldDifferentialEquations<T>() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void init(T t0, T[] y0, T t) {             }              @Override             public T[] computeDerivatives(T t, T[] y) {                 if (t.getReal() < -0.5) {                     throw new LocalException();                 } else {                     throw new RuntimeException("oops");                 }             }         };          EmbeddedRungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, 0.0, 1.0, 1.0e-10, 1.0e-10);          try  {             integrator.integrate(new FieldExpandableODE<>(equations),                                  new FieldODEState<>(field.getOne().negate(),                                                       MathArrays.buildArray(field, 1)),                                  field.getZero());             Assert.fail("an exception should have been thrown");           } catch(LocalException de) {             // expected behavior           }            try  {               integrator.integrate(new FieldExpandableODE<>(equations),                                    new FieldODEState<>(field.getZero(),                                                         MathArrays.buildArray(field, 1)),                                    field.getOne());                Assert.fail("an exception should have been thrown");           } catch(RuntimeException de) {             // expected behavior           }     }      protected static class LocalException extends RuntimeException {         private static final long serialVersionUID = 20151208L;     }      @Test(expected=NumberIsTooSmallException.class)     public abstract void testMinStep();      protected <T extends RealFieldElement<T>> void doTestMinStep(final Field<T> field)         throws NumberIsTooSmallException {          TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         double minStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.1).getReal();         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };         double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               vecAbsoluteTolerance, vecRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());         Assert.fail("an exception should have been thrown");      }      @Test     public abstract void testIncreasingTolerance();      protected <T extends RealFieldElement<T>> void doTestIncreasingTolerance(final Field<T> field,                                                                              double factor,                                                                              double epsilon) {          int previousCalls = Integer.MAX_VALUE;         for (int i = -12; i < -2; ++i) {             TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);             double minStep = 0;             double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();             double scalAbsoluteTolerance = FastMath.pow(10.0, i);             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;              FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                                   scalAbsoluteTolerance, scalRelativeTolerance);             TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);             integ.addStepHandler(handler);             integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());              Assert.assertTrue(handler.getMaximalValueError().getReal() < (factor * scalAbsoluteTolerance));             Assert.assertEquals(0, handler.getMaximalTimeError().getReal(), epsilon);              int calls = pb.getCalls();             Assert.assertEquals(integ.getEvaluations(), calls);             Assert.assertTrue(calls <= previousCalls);             previousCalls = calls;          }      }      @Test     public abstract void testEvents();      protected <T extends RealFieldElement<T>> void doTestEvents(final Field<T> field,                                                                 final double epsilonMaxValue,                                                                 final String name) {        TestFieldProblem4<T> pb = new TestFieldProblem4<>(field);       double minStep = 0;       double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                             scalAbsoluteTolerance, scalRelativeTolerance);       TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);       integ.addStepHandler(handler);       FieldEventHandler<T>[] functions = pb.getEventsHandlers();       double convergence = 1.0e-8 * maxStep;       for (int l = 0; l < functions.length; ++l) {           integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);       }       Assert.assertEquals(functions.length, integ.getEventHandlers().size());       integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());        Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);       Assert.assertEquals(0, handler.getMaximalTimeError().getReal(), convergence);       Assert.assertEquals(12.0, handler.getLastTime().getReal(), convergence);       Assert.assertEquals(name, integ.getName());       integ.clearEventHandlers();       Assert.assertEquals(0, integ.getEventHandlers().size());      }      @Test(expected=LocalException.class)     public abstract void testEventsErrors();      protected <T extends RealFieldElement<T>> void doTestEventsErrors(final Field<T> field)         throws LocalException {         final TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double scalAbsoluteTolerance = 1.0e-8;         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               scalAbsoluteTolerance, scalRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);          integ.addEventHandler(new FieldEventHandler<T>() {           @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {           }           @Override         public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {             return Action.CONTINUE;           }           @Override         public T g(FieldODEStateAndDerivative<T> state) {             T middle = pb.getInitialState().getTime().add(pb.getFinalTime()).multiply(0.5);             T offset = state.getTime().subtract(middle);             if (offset.getReal() > 0) {               throw new LocalException();             }             return offset;           }           @Override         public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {               return state;           }         }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);          integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());      }      @Test     public abstract void testEventsNoConvergence();      protected <T extends RealFieldElement<T>> void doTestEventsNoConvergence(final Field<T> field){          final TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double scalAbsoluteTolerance = 1.0e-8;         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               scalAbsoluteTolerance, scalRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);          integ.addEventHandler(new FieldEventHandler<T>() {             @Override             public void init(FieldODEStateAndDerivative<T> state0, T t) {             }             @Override             public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {                 return Action.CONTINUE;             }             @Override             public T g(FieldODEStateAndDerivative<T> state) {                 T middle = pb.getInitialState().getTime().add(pb.getFinalTime()).multiply(0.5);                 T offset = state.getTime().subtract(middle);                 return (offset.getReal() > 0) ? offset.add(0.5) : offset.subtract(0.5);             }             @Override             public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {                 return state;             }         }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);          try {             integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());             Assert.fail("an exception should have been thrown");         } catch (MaxCountExceededException mcee) {             // Expected.         }      }      @Test     public abstract void testSanityChecks();      protected <T extends RealFieldElement<T>> void doTestSanityChecks(Field<T> field) {         TestFieldProblem3<T> pb = new TestFieldProblem3<>(field);         try  {             EmbeddedRungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, 0,                                                                                pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),                                                                                new double[4], new double[4]);             integrator.integrate(new FieldExpandableODE<>(pb),                                  new FieldODEState<>(pb.getInitialState().getTime(),                                                       MathArrays.buildArray(field, 6)),                                  pb.getFinalTime());             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             EmbeddedRungeKuttaFieldIntegrator<T> integrator =                             createIntegrator(field, 0,                                              pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),                                              new double[2], new double[4]);             integrator.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             EmbeddedRungeKuttaFieldIntegrator<T> integrator =                             createIntegrator(field, 0,                                              pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),                                              new double[4], new double[4]);             integrator.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getInitialState().getTime());             Assert.fail("an exception should have been thrown");         } catch(NumberIsTooSmallException ie) {         }     }      @Test     public abstract void testBackward();      protected <T extends RealFieldElement<T>> void doTestBackward(Field<T> field,                                                                   final double epsilonLast,                                                                   final double epsilonMaxValue,                                                                   final double epsilonMaxTime,                                                                   final String name)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          TestFieldProblem5<T> pb = new TestFieldProblem5<>(field);         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).abs().getReal();         double scalAbsoluteTolerance = 1.0e-8;         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;          EmbeddedRungeKuttaFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                                       scalAbsoluteTolerance,                                                                       scalRelativeTolerance);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);         Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testKepler();      protected <T extends RealFieldElement<T>> void doTestKepler(Field<T> field, double epsilon) {          final TestFieldProblem3<T> pb  = new TestFieldProblem3<>(field, field.getZero().add(0.9));         double minStep = 0;         double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();         double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };         double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };          FirstOrderFieldIntegrator<T> integ = createIntegrator(field, minStep, maxStep,                                                               vecAbsoluteTolerance, vecRelativeTolerance);         integ.addStepHandler(new KeplerHandler<>(pb, epsilon));         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());     }      private static class KeplerHandler<T extends RealFieldElement<T>> implements FieldStepHandler<T> {         private T maxError;         private final TestFieldProblem3<T> pb;         private final double epsilon;         public KeplerHandler(TestFieldProblem3<T> pb, double epsilon) {             this.pb      = pb;             this.epsilon = epsilon;             maxError = pb.getField().getZero();         }         @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {             maxError = pb.getField().getZero();         }         @Override         public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast)                         throws MaxCountExceededException {              FieldODEStateAndDerivative<T> current = interpolator.getCurrentState();             T[] theoreticalY  = pb.computeTheoreticalState(current.getTime());             T dx = current.getState()[0].subtract(theoreticalY[0]);             T dy = current.getState()[1].subtract(theoreticalY[1]);             T error = dx.multiply(dx).add(dy.multiply(dy));             if (error.subtract(maxError).getReal() > 0) {                 maxError = error;             }             if (isLast) {                 Assert.assertEquals(0.0, maxError.getReal(), epsilon);             }         }     }      @Test     public abstract void testPartialDerivatives();      protected void doTestPartialDerivatives(final double epsilonY,                                             final double[] epsilonPartials) {          // parameters indices         final int parameters = 5;         final int order      = 1;         final int parOmega   = 0;         final int parTO      = 1;         final int parY00     = 2;         final int parY01     = 3;         final int parT       = 4;          DerivativeStructure omega = new DerivativeStructure(parameters, order, parOmega, 1.3);         DerivativeStructure t0    = new DerivativeStructure(parameters, order, parTO, 1.3);         DerivativeStructure[] y0  = new DerivativeStructure[] {             new DerivativeStructure(parameters, order, parY00, 3.0),             new DerivativeStructure(parameters, order, parY01, 4.0)         };         DerivativeStructure t     = new DerivativeStructure(parameters, order, parT, 6.0);         SinCos sinCos = new SinCos(omega);          EmbeddedRungeKuttaFieldIntegrator<DerivativeStructure> integrator =                         createIntegrator(omega.getField(),                                          t.subtract(t0).multiply(0.001).getReal(), t.subtract(t0).getReal(),                                          1.0e-12, 1.0e-12);         FieldODEStateAndDerivative<DerivativeStructure> result =                         integrator.integrate(new FieldExpandableODE<>(sinCos),                                              new FieldODEState<>(t0, y0),                                              t);          // check values         for (int i = 0; i < sinCos.getDimension(); ++i) {             Assert.assertEquals(sinCos.theoreticalY(t.getReal())[i], result.getState()[i].getValue(), epsilonY);         }          // check derivatives         final double[][] derivatives = sinCos.getDerivatives(t.getReal());         for (int i = 0; i < sinCos.getDimension(); ++i) {             for (int parameter = 0; parameter < parameters; ++parameter) {                 Assert.assertEquals(derivatives[i][parameter], dYdP(result.getState()[i], parameter), epsilonPartials[parameter]);             }         }      }      private double dYdP(final DerivativeStructure y, final int parameter) {         int[] orders = new int[y.getFreeParameters()];         orders[parameter] = 1;         return y.getPartialDerivative(orders);     }      private static class SinCos implements FirstOrderFieldDifferentialEquations<DerivativeStructure> {          private final DerivativeStructure omega;         private       DerivativeStructure r;         private       DerivativeStructure alpha;          private double dRdY00;         private double dRdY01;         private double dAlphadOmega;         private double dAlphadT0;         private double dAlphadY00;         private double dAlphadY01;          protected SinCos(final DerivativeStructure omega) {             this.omega = omega;         }          @Override         public int getDimension() {             return 2;         }          @Override         public void init(final DerivativeStructure t0, final DerivativeStructure[] y0,                          final DerivativeStructure finalTime) {              // theoretical solution is y(t) = { r * sin(omega * t + alpha), r * cos(omega * t + alpha) }             // so we retrieve alpha by identification from the initial state             final DerivativeStructure r2 = y0[0].multiply(y0[0]).add(y0[1].multiply(y0[1]));              this.r            = r2.sqrt();             this.dRdY00       = y0[0].divide(r).getReal();             this.dRdY01       = y0[1].divide(r).getReal();              this.alpha        = y0[0].atan2(y0[1]).subtract(t0.multiply(omega));             this.dAlphadOmega = -t0.getReal();             this.dAlphadT0    = -omega.getReal();             this.dAlphadY00   = y0[1].divide(r2).getReal();             this.dAlphadY01   = y0[0].negate().divide(r2).getReal();          }          @Override         public DerivativeStructure[] computeDerivatives(final DerivativeStructure t, final DerivativeStructure[] y) {             return new DerivativeStructure[] {                 omega.multiply(y[1]),                 omega.multiply(y[0]).negate()             };         }          public double[] theoreticalY(final double t) {             final double theta = omega.getReal() * t + alpha.getReal();             return new double[] {                 r.getReal() * FastMath.sin(theta), r.getReal() * FastMath.cos(theta)             };         }          public double[][] getDerivatives(final double t) {              // intermediate angle and state             final double theta        = omega.getReal() * t + alpha.getReal();             final double sin          = FastMath.sin(theta);             final double cos          = FastMath.cos(theta);             final double y0           = r.getReal() * sin;             final double y1           = r.getReal() * cos;              // partial derivatives of the state first component             final double dY0dOmega    =                y1 * (t + dAlphadOmega);             final double dY0dT0       =                y1 * dAlphadT0;             final double dY0dY00      = dRdY00 * sin + y1 * dAlphadY00;             final double dY0dY01      = dRdY01 * sin + y1 * dAlphadY01;             final double dY0dT        =                y1 * omega.getReal();              // partial derivatives of the state second component             final double dY1dOmega    =              - y0 * (t + dAlphadOmega);             final double dY1dT0       =              - y0 * dAlphadT0;             final double dY1dY00      = dRdY00 * cos - y0 * dAlphadY00;             final double dY1dY01      = dRdY01 * cos - y0 * dAlphadY01;             final double dY1dT        =              - y0 * omega.getReal();              return new double[][] {                 { dY0dOmega, dY0dT0, dY0dY00, dY0dY01, dY0dT },                 { dY1dOmega, dY1dT0, dY1dY00, dY1dY01, dY1dT }             };          }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.Decimal64Field;  public class LutherFieldIntegratorTest extends RungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, T step) {         return new LutherFieldIntegrator<>(field, step);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testMissedEndEvent()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         doTestMissedEndEvent(Decimal64Field.getInstance(), 1.0e-15, 1.0e-15);     }      @Override     public void testSanityChecks()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testDecreasingSteps()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         doTestDecreasingSteps(Decimal64Field.getInstance(), 1.0, 1.0, 1.0e-10);     }      @Override     public void testSmallStep()          throws DimensionMismatchException, NumberIsTooSmallException,                 MaxCountExceededException, NoBracketingException {         doTestSmallStep(Decimal64Field.getInstance(), 8.7e-17, 3.6e-15, 1.0e-12, "Luther");     }      @Override     public void testBigStep()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         doTestBigStep(Decimal64Field.getInstance(), 2.7e-5, 1.7e-3, 1.0e-12, "Luther");     }      @Override     public void testBackward()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         doTestBackward(Decimal64Field.getInstance(), 2.4e-13, 4.3e-13, 1.0e-12, "Luther");     }      @Override     public void testKepler()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         doTestKepler(Decimal64Field.getInstance(), 2.18e-7, 4.0e-10);     }      @Override     public void testStepSize()         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         doTestStepSize(Decimal64Field.getInstance(), 1.0e-22);     }      @Override     public void testSingleStep() {         doTestSingleStep(Decimal64Field.getInstance(), 6.0e-12);     }      @Override     public void testTooLargeFirstStep() {         doTestTooLargeFirstStep(Decimal64Field.getInstance());     }      @Override     public void testUnstableDerivative() {         doTestUnstableDerivative(Decimal64Field.getInstance(), 4.0e-15);     }      @Override     public void testDerivativesConsistency() {         doTestDerivativesConsistency(Decimal64Field.getInstance(), 1.0e-20);     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(4.3e-13, new double[] { 2.2e-12, 5.6e-13, 9.4e-14, 9.4e-14, 5.6e-13 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.ContinuousOutputModel; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class DormandPrince853StepInterpolatorTest {    @Test   public void derivativesConsistency()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3(0.1);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                       scalAbsoluteTolerance,                                                                       scalRelativeTolerance);     StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 0.01, 1.8e-12);   }    @Test   public void serialization()     throws IOException, ClassNotFoundException,            DimensionMismatchException, NumberIsTooSmallException,            MaxCountExceededException, NoBracketingException {      TestProblem3 pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                       scalAbsoluteTolerance,                                                                       scalRelativeTolerance);     integ.addStepHandler(new ContinuousOutputModel());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      ByteArrayOutputStream bos = new ByteArrayOutputStream();     ObjectOutputStream    oos = new ObjectOutputStream(bos);     for (StepHandler handler : integ.getStepHandlers()) {         oos.writeObject(handler);     }      Assert.assertTrue(bos.size () > 90000);     Assert.assertTrue(bos.size () < 100000);      ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());     ObjectInputStream     ois = new ObjectInputStream(bis);     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();      Random random = new Random(347588535632l);     double maxError = 0.0;     for (int i = 0; i < 1000; ++i) {       double r = random.nextDouble();       double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();       cm.setInterpolatedTime(time);       double[] interpolatedY = cm.getInterpolatedState ();       double[] theoreticalY  = pb.computeTheoreticalState(time);       double dx = interpolatedY[0] - theoreticalY[0];       double dy = interpolatedY[1] - theoreticalY[1];       double error = dx * dx + dy * dy;       if (error > maxError) {         maxError = error;       }     }      Assert.assertTrue(maxError < 2.4e-10);    }    @Test   public void checklone()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     TestProblem3 pb = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;     DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                       scalAbsoluteTolerance,                                                                       scalRelativeTolerance);     integ.addStepHandler(new StepHandler() {         @Override         public void handleStep(StepInterpolator interpolator, boolean isLast)             throws MaxCountExceededException {             StepInterpolator cloned = interpolator.copy();             double tA = cloned.getPreviousTime();             double tB = cloned.getCurrentTime();             double halfStep = FastMath.abs(tB - tA) / 2;             Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);             Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);             for (int i = 0; i < 10; ++i) {                 double t = (i * tB + (9 - i) * tA) / 9;                 interpolator.setInterpolatedTime(t);                 Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                 cloned.setInterpolatedTime(t);                 Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                 double[] referenceState = interpolator.getInterpolatedState();                 double[] cloneState     = cloned.getInterpolatedState();                 for (int j = 0; j < referenceState.length; ++j) {                     Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                 }             }         }         @Override         public void init(double t0, double[] y0, double t) {         }     });     integ.integrate(pb,             pb.getInitialTime(), pb.getInitialState(),             pb.getFinalTime(), new double[pb.getDimension()]);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class EulerFieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState, FieldEquationsMapper<T> mapper) {         return new EulerFieldStepInterpolator<>(field, forward, yDotK,                                                  globalPreviousState, globalCurrentState,                                                  softPreviousState, softCurrentState,                                                  mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new EulerFieldIntegrator<>(field, field.getOne());     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-15);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 3.3e-4, 7.9e-3);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 7.0e-18, 1.0e-50, 1.0e-50, 1.0e-50);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.util.Decimal64Field;  public class GillFieldIntegratorTest extends RungeKuttaFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>     createIntegrator(Field<T> field, T step) {         return new GillFieldIntegrator<>(field, step);     }      @Override     public void testNonFieldIntegratorConsistency() {         doTestNonFieldIntegratorConsistency(Decimal64Field.getInstance());     }      @Override     public void testMissedEndEvent() {         doTestMissedEndEvent(Decimal64Field.getInstance(), 1.0e-15, 6.0e-5);     }      @Override     public void testSanityChecks() {         doTestSanityChecks(Decimal64Field.getInstance());     }      @Override     public void testDecreasingSteps() {         doTestDecreasingSteps(Decimal64Field.getInstance(), 1.0, 1.0, 1.0e-10);     }      @Override     public void testSmallStep() {         doTestSmallStep(Decimal64Field.getInstance(), 2.0e-13, 4.0e-12, 1.0e-12, "Gill");     }      @Override     public void testBigStep() {         doTestBigStep(Decimal64Field.getInstance(), 0.0004, 0.005, 1.0e-12, "Gill");      }      @Override     public void testBackward() {         doTestBackward(Decimal64Field.getInstance(), 5.0e-10, 7.0e-10, 1.0e-12, "Gill");     }      @Override     public void testKepler() {         doTestKepler(Decimal64Field.getInstance(), 1.72e-3, 1.0e-5);     }      @Override     public void testStepSize() {         doTestStepSize(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testSingleStep() {         doTestSingleStep(Decimal64Field.getInstance(), 0.21);     }      @Override     public void testTooLargeFirstStep() {         doTestTooLargeFirstStep(Decimal64Field.getInstance());     }      @Override     public void testUnstableDerivative() {         doTestUnstableDerivative(Decimal64Field.getInstance(), 1.0e-12);     }      @Override     public void testDerivativesConsistency() {         doTestDerivativesConsistency(Decimal64Field.getInstance(), 1.0e-10);     }      @Override     public void testPartialDerivatives() {         doTestPartialDerivatives(3.2e-10, new double[] { 2.1e-9, 5.9e-10, 7.0e-11, 7.0e-11, 5.9e-10 });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.AbstractIntegrator; import org.apache.commons.math4.ode.EquationsMapper; import org.apache.commons.math4.ode.ExpandableStatefulODE; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldExpandableODE; import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  public abstract class RungeKuttaFieldStepInterpolatorAbstractTest {      protected abstract <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>         createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                            FieldODEStateAndDerivative<T> globalPreviousState,                            FieldODEStateAndDerivative<T> globalCurrentState,                            FieldODEStateAndDerivative<T> softPreviousState,                            FieldODEStateAndDerivative<T> softCurrentState,                            FieldEquationsMapper<T> mapper);      protected abstract <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>         createButcherArrayProvider(final Field<T> field);      @Test     public abstract void interpolationAtBounds();      protected <T extends RealFieldElement<T>> void doInterpolationAtBounds(final Field<T> field, double epsilon) {          RungeKuttaFieldStepInterpolator<T> interpolator = setUpInterpolator(field,                                                                             new SinCos<>(field),                                                                             0.0, new double[] { 0.0, 1.0 }, 0.125);          Assert.assertEquals(0.0, interpolator.getPreviousState().getTime().getReal(), 1.0e-15);         for (int i = 0; i < 2; ++i) {             Assert.assertEquals(interpolator.getPreviousState().getState()[i].getReal(),                                 interpolator.getInterpolatedState(interpolator.getPreviousState().getTime()).getState()[i].getReal(),                                 epsilon);         }         Assert.assertEquals(0.125, interpolator.getCurrentState().getTime().getReal(), 1.0e-15);         for (int i = 0; i < 2; ++i) {             Assert.assertEquals(interpolator.getCurrentState().getState()[i].getReal(),                                 interpolator.getInterpolatedState(interpolator.getCurrentState().getTime()).getState()[i].getReal(),                                 epsilon);         }      }      @Test     public abstract void interpolationInside();      protected <T extends RealFieldElement<T>> void doInterpolationInside(final Field<T> field,                                                                          double epsilonSin, double epsilonCos) {          RungeKuttaFieldStepInterpolator<T> interpolator = setUpInterpolator(field,                                                                             new SinCos<>(field),                                                                             0.0, new double[] { 0.0, 1.0 }, 0.0125);          int n = 100;         double maxErrorSin = 0;         double maxErrorCos = 0;         for (int i = 0; i <= n; ++i) {             T t =     interpolator.getPreviousState().getTime().multiply(n - i).                   add(interpolator.getCurrentState().getTime().multiply(i)).                   divide(n);             FieldODEStateAndDerivative<T> state = interpolator.getInterpolatedState(t);             maxErrorSin = FastMath.max(maxErrorSin, state.getState()[0].subtract(t.sin()).abs().getReal());             maxErrorCos = FastMath.max(maxErrorCos, state.getState()[1].subtract(t.cos()).abs().getReal());         }         Assert.assertEquals(0.0, maxErrorSin, epsilonSin);         Assert.assertEquals(0.0, maxErrorCos, epsilonCos);      }      @Test     public abstract void nonFieldInterpolatorConsistency();      protected <T extends RealFieldElement<T>> void doNonFieldInterpolatorConsistency(final Field<T> field,                                                                                      double epsilonSin, double epsilonCos,                                                                                      double epsilonSinDot, double epsilonCosDot) {          FirstOrderFieldDifferentialEquations<T> eqn = new SinCos<>(field);         RungeKuttaFieldStepInterpolator<T> fieldInterpolator =                         setUpInterpolator(field, eqn, 0.0, new double[] { 0.0, 1.0 }, 0.125);         RungeKuttaStepInterpolator regularInterpolator = convertInterpolator(fieldInterpolator, eqn);          int n = 100;         double maxErrorSin    = 0;         double maxErrorCos    = 0;         double maxErrorSinDot = 0;         double maxErrorCosDot = 0;         for (int i = 0; i <= n; ++i) {              T t =     fieldInterpolator.getPreviousState().getTime().multiply(n - i).                   add(fieldInterpolator.getCurrentState().getTime().multiply(i)).                   divide(n);              FieldODEStateAndDerivative<T> state = fieldInterpolator.getInterpolatedState(t);             T[] fieldY    = state.getState();             T[] fieldYDot = state.getDerivative();              regularInterpolator.setInterpolatedTime(t.getReal());             double[] regularY     = regularInterpolator.getInterpolatedState();             double[] regularYDot  = regularInterpolator.getInterpolatedDerivatives();              maxErrorSin    = FastMath.max(maxErrorSin,    fieldY[0].subtract(regularY[0]).abs().getReal());             maxErrorCos    = FastMath.max(maxErrorCos,    fieldY[1].subtract(regularY[1]).abs().getReal());             maxErrorSinDot = FastMath.max(maxErrorSinDot, fieldYDot[0].subtract(regularYDot[0]).abs().getReal());             maxErrorCosDot = FastMath.max(maxErrorCosDot, fieldYDot[1].subtract(regularYDot[1]).abs().getReal());          }         Assert.assertEquals(0.0, maxErrorSin,    epsilonSin);         Assert.assertEquals(0.0, maxErrorCos,    epsilonCos);         Assert.assertEquals(0.0, maxErrorSinDot, epsilonSinDot);         Assert.assertEquals(0.0, maxErrorCosDot, epsilonCosDot);      }      private <T extends RealFieldElement<T>>     RungeKuttaFieldStepInterpolator<T> setUpInterpolator(final Field<T> field,                                                          final FirstOrderFieldDifferentialEquations<T> eqn,                                                          final double t0, final double[] y0,                                                          final double t1) {          // get the Butcher arrays from the field integrator         FieldButcherArrayProvider<T> provider = createButcherArrayProvider(field);         T[][] a = provider.getA();         T[]   b = provider.getB();         T[]   c = provider.getC();          // store initial state         T     t          = field.getZero().add(t0);         T[]   fieldY     = MathArrays.buildArray(field, eqn.getDimension());         T[][] fieldYDotK = MathArrays.buildArray(field, b.length, -1);         for (int i = 0; i < y0.length; ++i) {             fieldY[i] = field.getZero().add(y0[i]);         }         fieldYDotK[0] = eqn.computeDerivatives(t, fieldY);         FieldODEStateAndDerivative<T> s0 = new FieldODEStateAndDerivative<>(t, fieldY, fieldYDotK[0]);          // perform one integration step, in order to get consistent derivatives         T h = field.getZero().add(t1 - t0);         for (int k = 0; k < a.length; ++k) {             for (int i = 0; i < y0.length; ++i) {                 fieldY[i] = field.getZero().add(y0[i]);                 for (int s = 0; s <= k; ++s) {                     fieldY[i] = fieldY[i].add(h.multiply(a[k][s].multiply(fieldYDotK[s][i])));                 }             }             fieldYDotK[k + 1] = eqn.computeDerivatives(h.multiply(c[k]).add(t0), fieldY);         }          // store state at step end         t = field.getZero().add(t1);         for (int i = 0; i < y0.length; ++i) {             fieldY[i] = field.getZero().add(y0[i]);             for (int s = 0; s < b.length; ++s) {                 fieldY[i] = fieldY[i].add(h.multiply(b[s].multiply(fieldYDotK[s][i])));             }         }         FieldODEStateAndDerivative<T> s1 = new FieldODEStateAndDerivative<>(t, fieldY,                                                                              eqn.computeDerivatives(t, fieldY));          return createInterpolator(field, t1 > t0, fieldYDotK, s0, s1, s0, s1,                                   new FieldExpandableODE<>(eqn).getMapper());      }      private <T extends RealFieldElement<T>>     RungeKuttaStepInterpolator convertInterpolator(final RungeKuttaFieldStepInterpolator<T> fieldInterpolator,                                                    final FirstOrderFieldDifferentialEquations<T> eqn) {          RungeKuttaStepInterpolator regularInterpolator = null;         try {              String interpolatorName = fieldInterpolator.getClass().getName();             String integratorName = interpolatorName.replaceAll("Field", "");             @SuppressWarnings("unchecked")             Class<RungeKuttaStepInterpolator> clz = (Class<RungeKuttaStepInterpolator>) Class.forName(integratorName);             regularInterpolator = clz.newInstance();              double[][] yDotArray = null;             java.lang.reflect.Field fYD = RungeKuttaFieldStepInterpolator.class.getDeclaredField("yDotK");             fYD.setAccessible(true);             @SuppressWarnings("unchecked")             T[][] fieldYDotk = (T[][]) fYD.get(fieldInterpolator);             yDotArray = new double[fieldYDotk.length][];             for (int i = 0; i < yDotArray.length; ++i) {                 yDotArray[i] = new double[fieldYDotk[i].length];                 for (int j = 0; j < yDotArray[i].length; ++j) {                     yDotArray[i][j] = fieldYDotk[i][j].getReal();                 }             }             double[] y = new double[yDotArray[0].length];              EquationsMapper primaryMapper = null;             EquationsMapper[] secondaryMappers = null;             java.lang.reflect.Field fMapper = AbstractFieldStepInterpolator.class.getDeclaredField("mapper");             fMapper.setAccessible(true);             @SuppressWarnings("unchecked")             FieldEquationsMapper<T> mapper = (FieldEquationsMapper<T>) fMapper.get(fieldInterpolator);             java.lang.reflect.Field fStart = FieldEquationsMapper.class.getDeclaredField("start");             fStart.setAccessible(true);             int[] start = (int[]) fStart.get(mapper);             primaryMapper = new EquationsMapper(start[0], start[1]);             secondaryMappers = new EquationsMapper[mapper.getNumberOfEquations() - 1];             for (int i = 0; i < secondaryMappers.length; ++i) {                 secondaryMappers[i] = new EquationsMapper(start[i + 1], start[i + 2]);             }              AbstractIntegrator dummyIntegrator = new AbstractIntegrator("dummy") {                 @Override                 public void integrate(ExpandableStatefulODE equations, double t) {                     Assert.fail("this method should not be called");                 }                 @Override                 public void computeDerivatives(final double t, final double[] y, final double[] yDot) {                     T fieldT = fieldInterpolator.getCurrentState().getTime().getField().getZero().add(t);                     T[] fieldY = MathArrays.buildArray(fieldInterpolator.getCurrentState().getTime().getField(), y.length);                     for (int i = 0; i < y.length; ++i) {                         fieldY[i] = fieldInterpolator.getCurrentState().getTime().getField().getZero().add(y[i]);                     }                     T[] fieldYDot = eqn.computeDerivatives(fieldT, fieldY);                     for (int i = 0; i < yDot.length; ++i) {                         yDot[i] = fieldYDot[i].getReal();                     }                 }             };             regularInterpolator.reinitialize(dummyIntegrator, y, yDotArray,                                              fieldInterpolator.isForward(),                                              primaryMapper, secondaryMappers);              T[] fieldPreviousY = fieldInterpolator.getPreviousState().getState();             for (int i = 0; i < y.length; ++i) {                 y[i] = fieldPreviousY[i].getReal();             }             regularInterpolator.storeTime(fieldInterpolator.getPreviousState().getTime().getReal());              regularInterpolator.shift();              T[] fieldCurrentY = fieldInterpolator.getCurrentState().getState();             for (int i = 0; i < y.length; ++i) {                 y[i] = fieldCurrentY[i].getReal();             }             regularInterpolator.storeTime(fieldInterpolator.getCurrentState().getTime().getReal());          } catch (ClassNotFoundException cnfe) {             Assert.fail(cnfe.getLocalizedMessage());         } catch (InstantiationException ie) {             Assert.fail(ie.getLocalizedMessage());         } catch (IllegalAccessException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (NoSuchFieldException nsfe) {             Assert.fail(nsfe.getLocalizedMessage());         } catch (IllegalArgumentException iae) {             Assert.fail(iae.getLocalizedMessage());         }          return regularInterpolator;      }      private static class SinCos<T extends RealFieldElement<T>> implements FirstOrderFieldDifferentialEquations<T> {         private final Field<T> field;         protected SinCos(final Field<T> field) {             this.field = field;         }         @Override         public int getDimension() {             return 2;         }         @Override         public void init(final T t0, final T[] y0, final T finalTime) {         }         @Override         public T[] computeDerivatives(final T t, final T[] y) {             T[] yDot = MathArrays.buildArray(field, 2);             yDot[0] = y[1];             yDot[1] = y[0].negate();             return yDot;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class GillFieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new GillFieldStepInterpolator<>(field, forward, yDotK,                                                 globalPreviousState, globalCurrentState,                                                 softPreviousState, softCurrentState,                                                 mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new GillFieldIntegrator<>(field, field.getOne());     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-15);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 2.6e-7, 3.6e-6);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 1.4e-17, 1.0e-50, 3.4e-16, 2.1e-17);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.ode.FieldEquationsMapper; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class LutherFieldStepInterpolatorTest extends RungeKuttaFieldStepInterpolatorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> RungeKuttaFieldStepInterpolator<T>     createInterpolator(Field<T> field, boolean forward, T[][] yDotK,                        FieldODEStateAndDerivative<T> globalPreviousState,                        FieldODEStateAndDerivative<T> globalCurrentState,                        FieldODEStateAndDerivative<T> softPreviousState,                        FieldODEStateAndDerivative<T> softCurrentState,                        FieldEquationsMapper<T> mapper) {         return new LutherFieldStepInterpolator<>(field, forward, yDotK,                                                   globalPreviousState, globalCurrentState,                                                   softPreviousState, softCurrentState,                                                   mapper);     }      @Override     protected <T extends RealFieldElement<T>> FieldButcherArrayProvider<T>     createButcherArrayProvider(final Field<T> field) {         return new LutherFieldIntegrator<>(field, field.getOne());     }      @Override     @Test     public void interpolationAtBounds() {         doInterpolationAtBounds(Decimal64Field.getInstance(), 1.0e-15);     }      @Override     @Test     public void interpolationInside() {         doInterpolationInside(Decimal64Field.getInstance(), 1.1e-7, 9.6e-9);     }      @Override     @Test     public void nonFieldInterpolatorConsistency() {         doNonFieldInterpolatorConsistency(Decimal64Field.getInstance(), 8.4e-17, 2.3e-16, 2.1e-14, 1.3e-15);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import java.lang.reflect.Array;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FieldExpandableODE; import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations; import org.apache.commons.math4.ode.FieldODEState; import org.apache.commons.math4.ode.FieldODEStateAndDerivative; import org.apache.commons.math4.ode.TestFieldProblem1; import org.apache.commons.math4.ode.TestFieldProblem2; import org.apache.commons.math4.ode.TestFieldProblem3; import org.apache.commons.math4.ode.TestFieldProblem4; import org.apache.commons.math4.ode.TestFieldProblem5; import org.apache.commons.math4.ode.TestFieldProblem6; import org.apache.commons.math4.ode.TestFieldProblemAbstract; import org.apache.commons.math4.ode.TestFieldProblemHandler; import org.apache.commons.math4.ode.events.Action; import org.apache.commons.math4.ode.events.FieldEventHandler; import org.apache.commons.math4.ode.sampling.FieldStepHandler; import org.apache.commons.math4.ode.sampling.FieldStepInterpolator; import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  public abstract class RungeKuttaFieldIntegratorAbstractTest {      protected abstract <T extends RealFieldElement<T>> RungeKuttaFieldIntegrator<T>         createIntegrator(Field<T> field, T step);      @Test     public abstract void testNonFieldIntegratorConsistency();      protected <T extends RealFieldElement<T>> void doTestNonFieldIntegratorConsistency(final Field<T> field) {         try {              // get the Butcher arrays from the field integrator             RungeKuttaFieldIntegrator<T> fieldIntegrator = createIntegrator(field, field.getZero().add(1));             T[][] fieldA = fieldIntegrator.getA();             T[]   fieldB = fieldIntegrator.getB();             T[]   fieldC = fieldIntegrator.getC();              String fieldName   = fieldIntegrator.getClass().getName();             String regularName = fieldName.replaceAll("Field", "");              // get the Butcher arrays from the regular integrator             @SuppressWarnings("unchecked")             Class<RungeKuttaIntegrator> c = (Class<RungeKuttaIntegrator>) Class.forName(regularName);             java.lang.reflect.Field jlrFieldA = c.getDeclaredField("STATIC_A");             jlrFieldA.setAccessible(true);             double[][] regularA = (double[][]) jlrFieldA.get(null);             java.lang.reflect.Field jlrFieldB = c.getDeclaredField("STATIC_B");             jlrFieldB.setAccessible(true);             double[]   regularB = (double[])   jlrFieldB.get(null);             java.lang.reflect.Field jlrFieldC = c.getDeclaredField("STATIC_C");             jlrFieldC.setAccessible(true);             double[]   regularC = (double[])   jlrFieldC.get(null);              Assert.assertEquals(regularA.length, fieldA.length);             for (int i = 0; i < regularA.length; ++i) {                 checkArray(regularA[i], fieldA[i]);             }             checkArray(regularB, fieldB);             checkArray(regularC, fieldC);          } catch (ClassNotFoundException cnfe) {             Assert.fail(cnfe.getLocalizedMessage());         } catch (IllegalAccessException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (IllegalArgumentException iae) {             Assert.fail(iae.getLocalizedMessage());         } catch (SecurityException se) {             Assert.fail(se.getLocalizedMessage());         } catch (NoSuchFieldException nsfe) {             Assert.fail(nsfe.getLocalizedMessage());         }     }      private <T extends RealFieldElement<T>> void checkArray(double[] regularArray, T[] fieldArray) {         Assert.assertEquals(regularArray.length, fieldArray.length);         for (int i = 0; i < regularArray.length; ++i) {             if (regularArray[i] == 0) {                 Assert.assertTrue(0.0 == fieldArray[i].getReal());             } else {                 Assert.assertEquals(regularArray[i], fieldArray[i].getReal(), FastMath.ulp(regularArray[i]));             }         }     }      @Test     public abstract void testMissedEndEvent();      protected <T extends RealFieldElement<T>> void doTestMissedEndEvent(final Field<T> field,                                                                         final double epsilonT, final double epsilonY)         throws DimensionMismatchException, NumberIsTooSmallException,             MaxCountExceededException, NoBracketingException {         final T   t0     = field.getZero().add(1878250320.0000029);         final T   tEvent = field.getZero().add(1878250379.9999986);         final T[] k      = MathArrays.buildArray(field, 3);         k[0] = field.getZero().add(1.0e-4);         k[1] = field.getZero().add(1.0e-5);         k[2] = field.getZero().add(1.0e-6);         FirstOrderFieldDifferentialEquations<T> ode = new FirstOrderFieldDifferentialEquations<T>() {              @Override             public int getDimension() {                 return k.length;             }              @Override             public void init(T t0, T[] y0, T t) {             }              @Override             public T[] computeDerivatives(T t, T[] y) {                 T[] yDot = MathArrays.buildArray(field, k.length);                 for (int i = 0; i < y.length; ++i) {                     yDot[i] = k[i].multiply(y[i]);                 }                 return yDot;             }         };          RungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, field.getZero().add(60.0));          T[] y0   = MathArrays.buildArray(field, k.length);         for (int i = 0; i < y0.length; ++i) {             y0[i] = field.getOne().add(i);         }          FieldODEStateAndDerivative<T> result = integrator.integrate(new FieldExpandableODE<>(ode),                                                                     new FieldODEState<>(t0, y0),                                                                     tEvent);         Assert.assertEquals(tEvent.getReal(), result.getTime().getReal(), epsilonT);         T[] y = result.getState();         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(y0[i].multiply(k[i].multiply(result.getTime().subtract(t0)).exp()).getReal(),                                 y[i].getReal(),                                 epsilonY);         }          integrator.addEventHandler(new FieldEventHandler<T>() {              @Override             public void init(FieldODEStateAndDerivative<T> state0, T t) {             }              @Override             public FieldODEState<T> resetState(FieldODEStateAndDerivative<T> state) {                 return state;             }              @Override             public T g(FieldODEStateAndDerivative<T> state) {                 return state.getTime().subtract(tEvent);             }              @Override             public Action eventOccurred(FieldODEStateAndDerivative<T> state, boolean increasing) {                 Assert.assertEquals(tEvent.getReal(), state.getTime().getReal(), epsilonT);                 return Action.CONTINUE;             }         }, Double.POSITIVE_INFINITY, 1.0e-20, 100);         result = integrator.integrate(new FieldExpandableODE<>(ode),                                       new FieldODEState<>(t0, y0),                                       tEvent.add(120));         Assert.assertEquals(tEvent.add(120).getReal(), result.getTime().getReal(), epsilonT);         y = result.getState();         for (int i = 0; i < y.length; ++i) {             Assert.assertEquals(y0[i].multiply(k[i].multiply(result.getTime().subtract(t0)).exp()).getReal(),                                 y[i].getReal(),                                 epsilonY);         }      }      @Test     public abstract void testSanityChecks();      protected <T extends RealFieldElement<T>> void doTestSanityChecks(Field<T> field)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         RungeKuttaFieldIntegrator<T> integrator = createIntegrator(field, field.getZero().add(0.01));         try  {             TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);             integrator.integrate(new FieldExpandableODE<>(pb),                                  new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, pb.getDimension() + 10)),                                  field.getOne());             Assert.fail("an exception should have been thrown");         } catch(DimensionMismatchException ie) {         }         try  {             TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);             integrator.integrate(new FieldExpandableODE<>(pb),                                  new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, pb.getDimension())),                                  field.getZero());             Assert.fail("an exception should have been thrown");         } catch(NumberIsTooSmallException ie) {         }     }      @Test     public abstract void testDecreasingSteps();      protected <T extends RealFieldElement<T>> void doTestDecreasingSteps(Field<T> field,                                                                          final double safetyValueFactor,                                                                          final double safetyTimeFactor,                                                                          final double epsilonT)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          @SuppressWarnings("unchecked")         TestFieldProblemAbstract<T>[] allProblems =                         (TestFieldProblemAbstract<T>[]) Array.newInstance(TestFieldProblemAbstract.class, 6);         allProblems[0] = new TestFieldProblem1<>(field);         allProblems[1] = new TestFieldProblem2<>(field);         allProblems[2] = new TestFieldProblem3<>(field);         allProblems[3] = new TestFieldProblem4<>(field);         allProblems[4] = new TestFieldProblem5<>(field);         allProblems[5] = new TestFieldProblem6<>(field);         for (TestFieldProblemAbstract<T> pb :  allProblems) {              T previousValueError = null;             T previousTimeError  = null;             for (int i = 4; i < 10; ++i) {                  T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(FastMath.pow(2.0, -i));                  RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);                 TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);                 integ.addStepHandler(handler);                 FieldEventHandler<T>[] functions = pb.getEventsHandlers();                 for (int l = 0; l < functions.length; ++l) {                     integ.addEventHandler(functions[l],                                           Double.POSITIVE_INFINITY, 1.0e-6 * step.getReal(), 1000);                 }                 Assert.assertEquals(functions.length, integ.getEventHandlers().size());                 FieldODEStateAndDerivative<T> stop = integ.integrate(new FieldExpandableODE<>(pb),                                                                      pb.getInitialState(),                                                                      pb.getFinalTime());                 if (functions.length == 0) {                     Assert.assertEquals(pb.getFinalTime().getReal(), stop.getTime().getReal(), epsilonT);                 }                  T error = handler.getMaximalValueError();                 if (i > 4) {                     Assert.assertTrue(error.subtract(previousValueError.abs().multiply(safetyValueFactor)).getReal() < 0);                 }                 previousValueError = error;                  T timeError = handler.getMaximalTimeError();                 if (i > 4) {                     Assert.assertTrue(timeError.subtract(previousTimeError.abs().multiply(safetyTimeFactor)).getReal() <= 0);                 }                 previousTimeError = timeError;                  integ.clearEventHandlers();                 Assert.assertEquals(0, integ.getEventHandlers().size());             }          }      }      @Test     public abstract void testSmallStep();      protected <T extends RealFieldElement<T>> void doTestSmallStep(Field<T> field,                                                                    final double epsilonLast,                                                                    final double epsilonMaxValue,                                                                    final double epsilonMaxTime,                                                                    final String name)          throws DimensionMismatchException, NumberIsTooSmallException,                 MaxCountExceededException, NoBracketingException {          TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);         Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testBigStep();      protected <T extends RealFieldElement<T>> void doTestBigStep(Field<T> field,                                                                  final double belowLast,                                                                  final double belowMaxValue,                                                                  final double epsilonMaxTime,                                                                  final String name)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          TestFieldProblem1<T> pb = new TestFieldProblem1<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.2);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertTrue(handler.getLastError().getReal()         > belowLast);         Assert.assertTrue(handler.getMaximalValueError().getReal() > belowMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testBackward();      protected <T extends RealFieldElement<T>> void doTestBackward(Field<T> field,                                                                   final double epsilonLast,                                                                   final double epsilonMaxValue,                                                                   final double epsilonMaxTime,                                                                   final String name)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          TestFieldProblem5<T> pb = new TestFieldProblem5<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001).abs();          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         TestFieldProblemHandler<T> handler = new TestFieldProblemHandler<>(pb, integ);         integ.addStepHandler(handler);         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());          Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);         Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);         Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);         Assert.assertEquals(name, integ.getName());      }      @Test     public abstract void testKepler();      protected <T extends RealFieldElement<T>> void doTestKepler(Field<T> field, double expectedMaxError, double epsilon)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {          final TestFieldProblem3<T> pb  = new TestFieldProblem3<>(field, field.getZero().add(0.9));         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.0003);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         integ.addStepHandler(new KeplerHandler<>(pb, expectedMaxError, epsilon));         integ.integrate(new FieldExpandableODE<>(pb), pb.getInitialState(), pb.getFinalTime());     }      private static class KeplerHandler<T extends RealFieldElement<T>> implements FieldStepHandler<T> {         private T maxError;         private final TestFieldProblem3<T> pb;         private final double expectedMaxError;         private final double epsilon;         public KeplerHandler(TestFieldProblem3<T> pb, double expectedMaxError, double epsilon) {             this.pb               = pb;             this.expectedMaxError = expectedMaxError;             this.epsilon          = epsilon;             maxError = pb.getField().getZero();         }         @Override         public void init(FieldODEStateAndDerivative<T> state0, T t) {             maxError = pb.getField().getZero();         }         @Override         public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast)                         throws MaxCountExceededException {              FieldODEStateAndDerivative<T> current = interpolator.getCurrentState();             T[] theoreticalY  = pb.computeTheoreticalState(current.getTime());             T dx = current.getState()[0].subtract(theoreticalY[0]);             T dy = current.getState()[1].subtract(theoreticalY[1]);             T error = dx.multiply(dx).add(dy.multiply(dy));             if (error.subtract(maxError).getReal() > 0) {                 maxError = error;             }             if (isLast) {                 Assert.assertEquals(expectedMaxError, maxError.getReal(), epsilon);             }         }     }      @Test     public abstract void testStepSize();      protected <T extends RealFieldElement<T>> void doTestStepSize(final Field<T> field, final double epsilon)         throws DimensionMismatchException, NumberIsTooSmallException,                MaxCountExceededException, NoBracketingException {         final T step = field.getZero().add(1.23456);         RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         integ.addStepHandler(new FieldStepHandler<T>() {             @Override             public void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast) {                 if (! isLast) {                     Assert.assertEquals(step.getReal(),                                         interpolator.getCurrentState().getTime().subtract(interpolator.getPreviousState().getTime()).getReal(),                                         epsilon);                 }             }             @Override             public void init(FieldODEStateAndDerivative<T> s0, T t) {             }         });         integ.integrate(new FieldExpandableODE<>(new FirstOrderFieldDifferentialEquations<T>() {             @Override             public void init(T t0, T[] y0, T t) {             }             @Override             public T[] computeDerivatives(T t, T[] y) {                 T[] dot = MathArrays.buildArray(t.getField(), 1);                 dot[0] = t.getField().getOne();                 return dot;             }             @Override             public int getDimension() {                 return 1;             }         }), new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, 1)), field.getZero().add(5.0));     }      @Test     public abstract void testSingleStep();      protected <T extends RealFieldElement<T>> void doTestSingleStep(final Field<T> field, final double epsilon) {          final TestFieldProblem3<T> pb  = new TestFieldProblem3<>(field, field.getZero().add(0.9));         T h = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.0003);          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, field.getZero().add(Double.NaN));         T   t = pb.getInitialState().getTime();         T[] y = pb.getInitialState().getState();         for (int i = 0; i < 100; ++i) {             y = integ.singleStep(pb, t, y, t.add(h));             t = t.add(h);         }         T[] yth = pb.computeTheoreticalState(t);         T dx = y[0].subtract(yth[0]);         T dy = y[1].subtract(yth[1]);         T error = dx.multiply(dx).add(dy.multiply(dy));         Assert.assertEquals(0.0, error.getReal(), epsilon);     }      @Test     public abstract void testTooLargeFirstStep();      protected <T extends RealFieldElement<T>> void doTestTooLargeFirstStep(final Field<T> field) {          RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, field.getZero().add(0.5));         final T t0 = field.getZero();         final T[] y0 = MathArrays.buildArray(field, 1);         y0[0] = field.getOne();         final T t   = field.getZero().add(0.001);         FirstOrderFieldDifferentialEquations<T> equations = new FirstOrderFieldDifferentialEquations<T>() {              @Override             public int getDimension() {                 return 1;             }              @Override             public void init(T t0, T[] y0, T t) {             }              @Override             public T[] computeDerivatives(T t, T[] y) {                 Assert.assertTrue(t.getReal() >= FastMath.nextAfter(t0.getReal(), Double.NEGATIVE_INFINITY));                 Assert.assertTrue(t.getReal() <= FastMath.nextAfter(t.getReal(),   Double.POSITIVE_INFINITY));                 T[] yDot = MathArrays.buildArray(field, 1);                 yDot[0] = y[0].multiply(-100.0);                 return yDot;             }          };          integ.integrate(new FieldExpandableODE<>(equations), new FieldODEState<>(t0, y0), t);      }      @Test     public abstract void testUnstableDerivative();      protected <T extends RealFieldElement<T>> void doTestUnstableDerivative(Field<T> field, double epsilon) {       final StepFieldProblem<T> stepProblem = new StepFieldProblem<>(field,                                                                       field.getZero().add(0.0),                                                                       field.getZero().add(1.0),                                                                       field.getZero().add(2.0));       RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, field.getZero().add(0.3));       integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);       FieldODEStateAndDerivative<T> result = integ.integrate(new FieldExpandableODE<>(stepProblem),                                                              new FieldODEState<>(field.getZero(), MathArrays.buildArray(field, 1)),                                                              field.getZero().add(10.0));       Assert.assertEquals(8.0, result.getState()[0].getReal(), epsilon);     }      @Test     public abstract void testDerivativesConsistency();      protected <T extends RealFieldElement<T>> void doTestDerivativesConsistency(final Field<T> field, double epsilon) {         TestFieldProblem3<T> pb = new TestFieldProblem3<>(field);         T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001);         RungeKuttaFieldIntegrator<T> integ = createIntegrator(field, step);         StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);     }      @Test     public abstract void testPartialDerivatives();      protected void doTestPartialDerivatives(final double epsilonY,                                             final double[] epsilonPartials) {          // parameters indices         final int parameters = 5;         final int order      = 1;         final int parOmega   = 0;         final int parTO      = 1;         final int parY00     = 2;         final int parY01     = 3;         final int parT       = 4;          DerivativeStructure omega = new DerivativeStructure(parameters, order, parOmega, 1.3);         DerivativeStructure t0    = new DerivativeStructure(parameters, order, parTO, 1.3);         DerivativeStructure[] y0  = new DerivativeStructure[] {             new DerivativeStructure(parameters, order, parY00, 3.0),             new DerivativeStructure(parameters, order, parY01, 4.0)         };         DerivativeStructure t     = new DerivativeStructure(parameters, order, parT, 6.0);         SinCos sinCos = new SinCos(omega);          RungeKuttaFieldIntegrator<DerivativeStructure> integrator =                         createIntegrator(omega.getField(), t.subtract(t0).multiply(0.001));         FieldODEStateAndDerivative<DerivativeStructure> result =                         integrator.integrate(new FieldExpandableODE<>(sinCos),                                              new FieldODEState<>(t0, y0),                                              t);          // check values         for (int i = 0; i < sinCos.getDimension(); ++i) {             Assert.assertEquals(sinCos.theoreticalY(t.getReal())[i], result.getState()[i].getValue(), epsilonY);         }          // check derivatives         final double[][] derivatives = sinCos.getDerivatives(t.getReal());         for (int i = 0; i < sinCos.getDimension(); ++i) {             for (int parameter = 0; parameter < parameters; ++parameter) {                 Assert.assertEquals(derivatives[i][parameter],                                     dYdP(result.getState()[i], parameter),                                     epsilonPartials[parameter]);             }         }      }      private double dYdP(final DerivativeStructure y, final int parameter) {         int[] orders = new int[y.getFreeParameters()];         orders[parameter] = 1;         return y.getPartialDerivative(orders);     }      private static class SinCos implements FirstOrderFieldDifferentialEquations<DerivativeStructure> {          private final DerivativeStructure omega;         private       DerivativeStructure r;         private       DerivativeStructure alpha;          private double dRdY00;         private double dRdY01;         private double dAlphadOmega;         private double dAlphadT0;         private double dAlphadY00;         private double dAlphadY01;          protected SinCos(final DerivativeStructure omega) {             this.omega = omega;         }          @Override         public int getDimension() {             return 2;         }          @Override         public void init(final DerivativeStructure t0, final DerivativeStructure[] y0,                          final DerivativeStructure finalTime) {              // theoretical solution is y(t) = { r * sin(omega * t + alpha), r * cos(omega * t + alpha) }             // so we retrieve alpha by identification from the initial state             final DerivativeStructure r2 = y0[0].multiply(y0[0]).add(y0[1].multiply(y0[1]));              this.r            = r2.sqrt();             this.dRdY00       = y0[0].divide(r).getReal();             this.dRdY01       = y0[1].divide(r).getReal();              this.alpha        = y0[0].atan2(y0[1]).subtract(t0.multiply(omega));             this.dAlphadOmega = -t0.getReal();             this.dAlphadT0    = -omega.getReal();             this.dAlphadY00   = y0[1].divide(r2).getReal();             this.dAlphadY01   = y0[0].negate().divide(r2).getReal();          }          @Override         public DerivativeStructure[] computeDerivatives(final DerivativeStructure t, final DerivativeStructure[] y) {             return new DerivativeStructure[] {                 omega.multiply(y[1]),                 omega.multiply(y[0]).negate()             };         }          public double[] theoreticalY(final double t) {             final double theta = omega.getReal() * t + alpha.getReal();             return new double[] {                 r.getReal() * FastMath.sin(theta), r.getReal() * FastMath.cos(theta)             };         }          public double[][] getDerivatives(final double t) {              // intermediate angle and state             final double theta        = omega.getReal() * t + alpha.getReal();             final double sin          = FastMath.sin(theta);             final double cos          = FastMath.cos(theta);             final double y0           = r.getReal() * sin;             final double y1           = r.getReal() * cos;              // partial derivatives of the state first component             final double dY0dOmega    =                y1 * (t + dAlphadOmega);             final double dY0dT0       =                y1 * dAlphadT0;             final double dY0dY00      = dRdY00 * sin + y1 * dAlphadY00;             final double dY0dY01      = dRdY01 * sin + y1 * dAlphadY01;             final double dY0dT        =                y1 * omega.getReal();              // partial derivatives of the state second component             final double dY1dOmega    =              - y0 * (t + dAlphadOmega);             final double dY1dT0       =              - y0 * dAlphadT0;             final double dY1dY00      = dRdY00 * cos - y0 * dAlphadY00;             final double dY1dY01      = dRdY01 * cos - y0 * dAlphadY01;             final double dY1dT        =              - y0 * omega.getReal();              return new double[][] {                 { dY0dOmega, dY0dT0, dY0dY00, dY0dY01, dY0dT },                 { dY1dOmega, dY1dT0, dY1dY00, dY1dY01, dY1dT }             };          }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.FirstOrderDifferentialEquations; import org.apache.commons.math4.ode.FirstOrderIntegrator; import org.apache.commons.math4.ode.TestProblem1; import org.apache.commons.math4.ode.TestProblem3; import org.apache.commons.math4.ode.TestProblem4; import org.apache.commons.math4.ode.TestProblem5; import org.apache.commons.math4.ode.TestProblemHandler; import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.ode.sampling.StepHandler; import org.apache.commons.math4.ode.sampling.StepInterpolator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   public class DormandPrince853IntegratorTest {    @Test   public void testMissedEndEvent()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       final double   t0     = 1878250320.0000029;       final double   tEvent = 1878250379.9999986;       final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };       FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {            @Override         public int getDimension() {               return k.length;           }            @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {               for (int i = 0; i < y.length; ++i) {                   yDot[i] = k[i] * y[i];               }           }       };        DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,                                                                              1.0e-10, 1.0e-10);        double[] y0   = new double[k.length];       for (int i = 0; i < y0.length; ++i) {           y0[i] = i + 1;       }       double[] y    = new double[k.length];        integrator.setInitialStepSize(60.0);       double finalT = integrator.integrate(ode, t0, y0, tEvent, y);       Assert.assertEquals(tEvent, finalT, 5.0e-6);       for (int i = 0; i < y.length; ++i) {           Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);       }        integrator.setInitialStepSize(60.0);       integrator.addEventHandler(new EventHandler() {            @Override         public void init(double t0, double[] y0, double t) {           }            @Override         public void resetState(double t, double[] y) {           }            @Override         public double g(double t, double[] y) {               return t - tEvent;           }            @Override         public Action eventOccurred(double t, double[] y, boolean increasing) {               Assert.assertEquals(tEvent, t, 5.0e-6);               return Action.CONTINUE;           }       }, Double.POSITIVE_INFINITY, 1.0e-20, 100);       finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);       Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);       for (int i = 0; i < y.length; ++i) {           Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);       }    }    @Test(expected=DimensionMismatchException.class)   public void testDimensionCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                              1.0e-10, 1.0e-10);       integrator.integrate(pb,                            0.0, new double[pb.getDimension()+10],                            1.0, new double[pb.getDimension()+10]);       Assert.fail("an exception should have been thrown");   }    @Test(expected=NumberIsTooSmallException.class)   public void testNullIntervalCheck()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {       TestProblem1 pb = new TestProblem1();       DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                              1.0e-10, 1.0e-10);       integrator.integrate(pb,                            0.0, new double[pb.getDimension()],                            0.0, new double[pb.getDimension()]);       Assert.fail("an exception should have been thrown");   }    @Test(expected=NumberIsTooSmallException.class)   public void testMinStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem1 pb = new TestProblem1();       double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };       double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };        FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                   vecAbsoluteTolerance,                                                                   vecRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);       Assert.fail("an exception should have been thrown");    }    @Test   public void testIncreasingTolerance()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      int previousCalls = Integer.MAX_VALUE;     AdaptiveStepsizeIntegrator integ =         new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY,                                        Double.NaN, Double.NaN);     for (int i = -12; i < -2; ++i) {       TestProblem1 pb = new TestProblem1();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = FastMath.pow(10.0, i);       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;       integ.setStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);        TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb,                       pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        // the 1.3 factor is only valid for this test       // and has been obtained from trial and error       // there is no general relation between local and global errors       Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);        int calls = pb.getCalls();       Assert.assertEquals(integ.getEvaluations(), calls);       Assert.assertTrue(calls <= previousCalls);       previousCalls = calls;      }    }    @Test   public void testTooLargeFirstStep()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        AdaptiveStepsizeIntegrator integ =               new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);       final double start = 0.0;       final double end   = 0.001;       FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() {            @Override         public int getDimension() {               return 1;           }            @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {               Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY));               Assert.assertTrue(t <= FastMath.nextAfter(end,   Double.POSITIVE_INFINITY));               yDot[0] = -100.0 * y[0];           }        };        integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8);       integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]);    }    @Test   public void testBackward()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {        TestProblem5 pb = new TestProblem5();       double minStep = 0;       double maxStep = pb.getFinalTime() - pb.getInitialTime();       double scalAbsoluteTolerance = 1.0e-8;       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;        FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                   scalAbsoluteTolerance,                                                                   scalRelativeTolerance);       TestProblemHandler handler = new TestProblemHandler(pb, integ);       integ.addStepHandler(handler);       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                       pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 1.1e-7);       Assert.assertTrue(handler.getMaximalValueError() < 1.1e-7);       Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);       Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());   }    @Test   public void testEvents()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      TestProblem4 pb = new TestProblem4();     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-9;     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                 scalAbsoluteTolerance,                                                                 scalRelativeTolerance);     TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);     EventHandler[] functions = pb.getEventsHandlers();     double convergence = 1.0e-8 * maxStep;     for (int l = 0; l < functions.length; ++l) {       integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);     }     Assert.assertEquals(functions.length, integ.getEventHandlers().size());     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertEquals(0, handler.getMaximalValueError(), 2.1e-7);     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);     Assert.assertEquals(12.0, handler.getLastTime(), convergence);     integ.clearEventHandlers();     Assert.assertEquals(0, integ.getEventHandlers().size());    }    @Test   public void testKepler()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                 scalAbsoluteTolerance,                                                                 scalRelativeTolerance);     integ.addStepHandler(new KeplerHandler(pb));     integ.integrate(pb,                     pb.getInitialTime(), pb.getInitialState(),                     pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertEquals(integ.getEvaluations(), pb.getCalls());     Assert.assertTrue(pb.getCalls() < 3300);    }    @Test   public void testVariableSteps()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {      final TestProblem3 pb  = new TestProblem3(0.9);     double minStep = 0;     double maxStep = pb.getFinalTime() - pb.getInitialTime();     double scalAbsoluteTolerance = 1.0e-8;     double scalRelativeTolerance = scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);     integ.addStepHandler(new VariableHandler());     double stopTime = integ.integrate(pb,                                       pb.getInitialTime(), pb.getInitialState(),                                       pb.getFinalTime(), new double[pb.getDimension()]);     Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);     Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());   }    @Test   public void testUnstableDerivative()       throws DimensionMismatchException, NumberIsTooSmallException,              MaxCountExceededException, NoBracketingException {     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);     FirstOrderIntegrator integ =       new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);     double[] y = { Double.NaN };     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);     Assert.assertEquals(8.0, y[0], 1.0e-12);   }    @Test   public void testEventsScheduling() {        FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {            @Override         public int getDimension() {               return 2;           }            @Override         public void computeDerivatives(double t, double[] y, double[] yDot) {               yDot[0] =  y[1];               yDot[1] = -y[0];           }        };        SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...       SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...        FirstOrderIntegrator integ =               new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);       integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);       integ.addStepHandler(sinChecker);       integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);       integ.addStepHandler(cosChecker);       double   t0 = 0.5;       double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };       double   t  = 10.0;       double[] y  = new double[2];       integ.integrate(sincos, t0, y0, t, y);    }    private static class SchedulingChecker implements StepHandler, EventHandler {        int index;       double tMin;        public SchedulingChecker(int index) {           this.index = index;       }        @Override     public void init(double t0, double[] y0, double t) {           tMin = t0;       }        @Override     public void handleStep(StepInterpolator interpolator, boolean isLast) {           tMin = interpolator.getCurrentTime();       }        @Override     public double g(double t, double[]  y) {           // once a step has been handled by handleStep,           // events checking should only refer to dates after the step           Assert.assertTrue(t >= tMin);           return y[index];       }        @Override     public Action eventOccurred(double t, double[] y, boolean increasing) {           return Action.RESET_STATE;       }        @Override     public void resetState(double t, double[] y) {           // in fact, we don't need to reset anything for the test       }    }    private static class KeplerHandler implements StepHandler {     public KeplerHandler(TestProblem3 pb) {       this.pb = pb;     }     @Override     public void init(double t0, double[] y0, double t) {       nbSteps = 0;       maxError = 0;     }     @Override     public void handleStep(StepInterpolator interpolator, boolean isLast)         throws MaxCountExceededException {        ++nbSteps;       for (int a = 1; a < 10; ++a) {          double prev   = interpolator.getPreviousTime();         double curr   = interpolator.getCurrentTime();         double interp = ((10 - a) * prev + a * curr) / 10;         interpolator.setInterpolatedTime(interp);          double[] interpolatedY = interpolator.getInterpolatedState ();         double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());         double dx = interpolatedY[0] - theoreticalY[0];         double dy = interpolatedY[1] - theoreticalY[1];         double error = dx * dx + dy * dy;         if (error > maxError) {           maxError = error;         }       }       if (isLast) {         Assert.assertTrue(maxError < 2.4e-10);         Assert.assertTrue(nbSteps < 150);       }     }     private int nbSteps;     private double maxError;     private TestProblem3 pb;   }    private static class VariableHandler implements StepHandler {     public VariableHandler() {         firstTime = true;         minStep = 0;         maxStep = 0;     }     @Override     public void init(double t0, double[] y0, double t) {       firstTime = true;       minStep = 0;       maxStep = 0;     }     @Override     public void handleStep(StepInterpolator interpolator,                            boolean isLast) {        double step = FastMath.abs(interpolator.getCurrentTime()                              - interpolator.getPreviousTime());       if (firstTime) {         minStep   = FastMath.abs(step);         maxStep   = minStep;         firstTime = false;       } else {         if (step < minStep) {           minStep = step;         }         if (step > maxStep) {           maxStep = step;         }       }        if (isLast) {         Assert.assertTrue(minStep < (1.0 / 100.0));         Assert.assertTrue(maxStep > (1.0 / 2.0));       }     }     private boolean firstTime = true;     private double  minStep = 0;     private double  maxStep = 0;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode.nonstiff;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.Decimal64Field; import org.junit.Test;  public class AdamsBashforthFieldIntegratorTest extends AdamsFieldIntegratorAbstractTest {      @Override     protected <T extends RealFieldElement<T>> AdamsFieldIntegrator<T>     createIntegrator(Field<T> field, final int nSteps, final double minStep, final double maxStep,                      final double scalAbsoluteTolerance, final double scalRelativeTolerance) {         return new AdamsBashforthFieldIntegrator<>(field, nSteps, minStep, maxStep,                         scalAbsoluteTolerance, scalRelativeTolerance);     }      @Override     protected <T extends RealFieldElement<T>> AdamsFieldIntegrator<T>     createIntegrator(Field<T> field, final int nSteps, final double minStep, final double maxStep,                      final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {         return new AdamsBashforthFieldIntegrator<>(field, nSteps, minStep, maxStep,                         vecAbsoluteTolerance, vecRelativeTolerance);     }      @Override     @Test(expected=NumberIsTooSmallException.class)     public void testMinStep() {         doDimensionCheck(Decimal64Field.getInstance());     }      @Override     @Test     public void testIncreasingTolerance() {         // the 2.6 and 122 factors are only valid for this test         // and has been obtained from trial and error         // there are no general relationship between local and global errors         doTestIncreasingTolerance(Decimal64Field.getInstance(), 2.6, 122);     }      @Override     @Test(expected = MaxCountExceededException.class)     public void exceedMaxEvaluations() {         doExceedMaxEvaluations(Decimal64Field.getInstance(), 650);     }      @Override     @Test     public void backward() {         doBackward(Decimal64Field.getInstance(), 4.3e-8, 4.3e-8, 1.0e-16, "Adams-Bashforth");     }      @Override     @Test     public void polynomial() {         doPolynomial(Decimal64Field.getInstance(), 5, 0.004, 6.0e-10);     }      @Override     @Test(expected=MathIllegalStateException.class)     public void testStartFailure() {         doTestStartFailure(Decimal64Field.getInstance());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.util.FastMath;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y' = t^3 - t y  * </pre>  * with the initial condition y (0) = 0. The solution of this equation  * is the following function :  * <pre>  *   y (t) = t^2 + 2 (exp (- t^2 / 2) - 1)  * </pre>  * </p>   */ public class TestProblem2   extends TestProblemAbstract {    /** theoretical state */   private double[] y;    /**    * Simple constructor.    */   public TestProblem2() {     super();     double[] y0 = { 0.0 };     setInitialConditions(0.0, y0);     setFinalConditions(1.0);     double[] errorScale = { 1.0 };     setErrorScale(errorScale);     y = new double[y0.length];   }    @Override   public void doComputeDerivatives(double t, double[] y, double[] yDot) {      // compute the derivatives     for (int i = 0; i < getDimension(); ++i) {         yDot[i] = t * (t * t - y[i]);     }    }    @Override   public double[] computeTheoreticalState(double t) {     double t2 = t * t;     double c = t2 + 2 * (FastMath.exp (-0.5 * t2) - 1);     for (int i = 0; i < getDimension(); ++i) {       y[i] = c;     }     return y;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.util.FastMath;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    y' = -y  * </pre>  * the solution of this equation is a simple exponential function :  * <pre>  *   y (t) = y (t0) exp (t0-t)  * </pre>  * </p>   */ public class TestProblem1   extends TestProblemAbstract {    /** theoretical state */   private double[] y;    /**    * Simple constructor.    */   public TestProblem1() {     super();     double[] y0 = { 1.0, 0.1 };     setInitialConditions(0.0, y0);     setFinalConditions(4.0);     double[] errorScale = { 1.0, 1.0 };     setErrorScale(errorScale);     y = new double[y0.length];   }    @Override   public void doComputeDerivatives(double t, double[] y, double[] yDot) {      // compute the derivatives     for (int i = 0; i < getDimension(); ++i) {         yDot[i] = -y[i];     }    }    @Override   public double[] computeTheoreticalState(double t) {     double c = FastMath.exp (getInitialTime() - t);     for (int i = 0; i < getDimension(); ++i) {       y[i] = c * getInitialState()[i];     }     return y;   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement;  /**  * This class is used in the junit tests for the ODE integrators.  * <p>This is the same as problem 1 except integration is done  * backward in time</p>  * @param <T> the type of the field elements  */ public class TestFieldProblem5<T extends RealFieldElement<T>>     extends TestFieldProblem1<T> {      /**      * Simple constructor.      * @param field field to which elements belong      */     public TestFieldProblem5(Field<T> field) {         super(field);         setFinalConditions(getInitialState().getTime().multiply(2).subtract(getFinalTime()));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaIntegrator; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   public class FirstOrderConverterTest {    @Test   public void testDoubleDimension() {     for (int i = 1; i < 10; ++i) {       SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);       FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);       Assert.assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));     }   }    @Test   public void testDecreasingSteps()       throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {      double previousError = Double.NaN;     for (int i = 0; i < 10; ++i) {        double step  = FastMath.pow(2.0, -(i + 1));       double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)                    - FastMath.sin(4.0);       if (i > 0) {         Assert.assertTrue(FastMath.abs(error) < FastMath.abs(previousError));       }       previousError = error;      }   }    @Test   public void testSmallStep()       throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)                    - FastMath.sin(4.0);     Assert.assertTrue(FastMath.abs(error) < 1.0e-10);   }    @Test   public void testBigStep()       throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)                    - FastMath.sin(4.0);     Assert.assertTrue(FastMath.abs(error) > 0.1);   }    private static class Equations     implements SecondOrderDifferentialEquations {       private int n;        private double omega2;        public Equations(int n, double omega) {         this.n = n;         omega2 = omega * omega;       }        @Override     public int getDimension() {         return n;       }        @Override     public void computeSecondDerivatives(double t, double[] y, double[] yDot,                                            double[] yDDot) {         for (int i = 0; i < n; ++i) {           yDDot[i] = -omega2 * y[i];         }     }    }    private double integrateWithSpecifiedStep(double omega,                                             double t0, double t,                                             double step) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {     double[] y0 = new double[2];     y0[0] = FastMath.sin(omega * t0);     y0[1] = omega * FastMath.cos(omega * t0);     ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);     double[] y = new double[2];     i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);     return y[0];   }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;   import org.apache.commons.math4.Field; import org.apache.commons.math4.RealFieldElement; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.util.Decimal64Field; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  public class FieldExpandableODETest {      @Test     public void testOnlyMainEquation() {         doTestOnlyMainEquation(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestOnlyMainEquation(final Field<T> field) {         FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         Assert.assertEquals(main.getDimension(), equation.getMapper().getTotalDimension());         Assert.assertEquals(1, equation.getMapper().getNumberOfEquations());         T t0 = field.getZero().add(10);         T t  = field.getZero().add(100);         T[] complete    = MathArrays.buildArray(field, equation.getMapper().getTotalDimension());         for (int i = 0; i < complete.length; ++i) {             complete[i] = field.getZero().add(i);         }         equation.init(t0, complete, t);         T[] completeDot = equation.computeDerivatives(t0, complete);         FieldODEStateAndDerivative<T> state = equation.getMapper().mapStateAndDerivative(t0, complete, completeDot);         Assert.assertEquals(0, state.getNumberOfSecondaryStates());         T[] mainState    = state.getState();         T[] mainStateDot = state.getDerivative();         Assert.assertEquals(main.getDimension(), mainState.length);         for (int i = 0; i < main.getDimension(); ++i) {             Assert.assertEquals(i, mainState[i].getReal(),   1.0e-15);             Assert.assertEquals(i, mainStateDot[i].getReal(), 1.0e-15);             Assert.assertEquals(i, completeDot[i].getReal(),  1.0e-15);         }     }      @Test     public void testMainAndSecondary() {         doTestMainAndSecondary(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestMainAndSecondary(final Field<T> field) {          FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         FieldSecondaryEquations<T> secondary1 = new Linear<>(field, 3, main.getDimension());         int i1 = equation.addSecondaryEquations(secondary1);         FieldSecondaryEquations<T> secondary2 = new Linear<>(field, 5, main.getDimension() + secondary1.getDimension());         int i2 = equation.addSecondaryEquations(secondary2);         Assert.assertEquals(main.getDimension() + secondary1.getDimension() + secondary2.getDimension(),                             equation.getMapper().getTotalDimension());         Assert.assertEquals(3, equation.getMapper().getNumberOfEquations());         Assert.assertEquals(1, i1);         Assert.assertEquals(2, i2);          T t0 = field.getZero().add(10);         T t  = field.getZero().add(100);         T[] complete    = MathArrays.buildArray(field, equation.getMapper().getTotalDimension());         for (int i = 0; i < complete.length; ++i) {             complete[i] = field.getZero().add(i);         }         equation.init(t0, complete, t);         T[] completeDot = equation.computeDerivatives(t0, complete);          T[] mainState    = equation.getMapper().extractEquationData(0,  complete);         T[] mainStateDot = equation.getMapper().extractEquationData(0,  completeDot);         Assert.assertEquals(main.getDimension(), mainState.length);         for (int i = 0; i < main.getDimension(); ++i) {             Assert.assertEquals(i, mainState[i].getReal(),   1.0e-15);             Assert.assertEquals(i, mainStateDot[i].getReal(), 1.0e-15);             Assert.assertEquals(i, completeDot[i].getReal(),  1.0e-15);         }          T[] secondaryState1    = equation.getMapper().extractEquationData(i1,  complete);         T[] secondaryState1Dot = equation.getMapper().extractEquationData(i1,  completeDot);         Assert.assertEquals(secondary1.getDimension(), secondaryState1.length);         for (int i = 0; i < secondary1.getDimension(); ++i) {             Assert.assertEquals(i + main.getDimension(), secondaryState1[i].getReal(),   1.0e-15);             Assert.assertEquals(-i, secondaryState1Dot[i].getReal(), 1.0e-15);             Assert.assertEquals(-i, completeDot[i + main.getDimension()].getReal(),  1.0e-15);         }          T[] secondaryState2    = equation.getMapper().extractEquationData(i2,  complete);         T[] secondaryState2Dot = equation.getMapper().extractEquationData(i2,  completeDot);         Assert.assertEquals(secondary2.getDimension(), secondaryState2.length);         for (int i = 0; i < secondary2.getDimension(); ++i) {             Assert.assertEquals(i + main.getDimension() + secondary1.getDimension(), secondaryState2[i].getReal(),   1.0e-15);             Assert.assertEquals(-i, secondaryState2Dot[i].getReal(), 1.0e-15);             Assert.assertEquals(-i, completeDot[i + main.getDimension() + secondary1.getDimension()].getReal(),  1.0e-15);         }      }      @Test     public void testMap() {         doTestMap(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestMap(final Field<T> field) {          FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         FieldSecondaryEquations<T> secondary1 = new Linear<>(field, 3, main.getDimension());         int i1 = equation.addSecondaryEquations(secondary1);         FieldSecondaryEquations<T> secondary2 = new Linear<>(field, 5, main.getDimension() + secondary1.getDimension());         int i2 = equation.addSecondaryEquations(secondary2);         Assert.assertEquals(main.getDimension() + secondary1.getDimension() + secondary2.getDimension(),                             equation.getMapper().getTotalDimension());         Assert.assertEquals(3, equation.getMapper().getNumberOfEquations());         Assert.assertEquals(1, i1);         Assert.assertEquals(2, i2);          T t0 = field.getZero().add(10);         T t  = field.getZero().add(100);         T[] complete    = MathArrays.buildArray(field, equation.getMapper().getTotalDimension());         for (int i = 0; i < complete.length; ++i) {             complete[i] = field.getZero().add(i);         }         equation.init(t0, complete, t);         T[] completeDot = equation.computeDerivatives(t0, complete);          try {             equation.getMapper().mapStateAndDerivative(t0, MathArrays.buildArray(field, complete.length + 1), completeDot);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException dme) {             // expected         }         try {             equation.getMapper().mapStateAndDerivative(t0, complete, MathArrays.buildArray(field, completeDot.length + 1));             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException dme) {             // expected         }         FieldODEStateAndDerivative<T> state = equation.getMapper().mapStateAndDerivative(t0, complete, completeDot);         Assert.assertEquals(2, state.getNumberOfSecondaryStates());         Assert.assertEquals(main.getDimension(),       state.getSecondaryStateDimension(0));         Assert.assertEquals(secondary1.getDimension(), state.getSecondaryStateDimension(i1));         Assert.assertEquals(secondary2.getDimension(), state.getSecondaryStateDimension(i2));          T[] mainState             = state.getState();         T[] mainStateDot          = state.getDerivative();         T[] mainStateAlternate    = state.getSecondaryState(0);         T[] mainStateDotAlternate = state.getSecondaryDerivative(0);         Assert.assertEquals(main.getDimension(), mainState.length);         for (int i = 0; i < main.getDimension(); ++i) {             Assert.assertEquals(i, mainState[i].getReal(),             1.0e-15);             Assert.assertEquals(i, mainStateDot[i].getReal(),          1.0e-15);             Assert.assertEquals(i, mainStateAlternate[i].getReal(),    1.0e-15);             Assert.assertEquals(i, mainStateDotAlternate[i].getReal(), 1.0e-15);             Assert.assertEquals(i, completeDot[i].getReal(),           1.0e-15);         }          T[] secondaryState1    = state.getSecondaryState(i1);         T[] secondaryState1Dot = state.getSecondaryDerivative(i1);         Assert.assertEquals(secondary1.getDimension(), secondaryState1.length);         for (int i = 0; i < secondary1.getDimension(); ++i) {             Assert.assertEquals(i + main.getDimension(), secondaryState1[i].getReal(),   1.0e-15);             Assert.assertEquals(-i, secondaryState1Dot[i].getReal(), 1.0e-15);             Assert.assertEquals(-i, completeDot[i + main.getDimension()].getReal(),  1.0e-15);         }          T[] secondaryState2    = state.getSecondaryState(i2);         T[] secondaryState2Dot = state.getSecondaryDerivative(i2);         Assert.assertEquals(secondary2.getDimension(), secondaryState2.length);         for (int i = 0; i < secondary2.getDimension(); ++i) {             Assert.assertEquals(i + main.getDimension() + secondary1.getDimension(), secondaryState2[i].getReal(),   1.0e-15);             Assert.assertEquals(-i, secondaryState2Dot[i].getReal(), 1.0e-15);             Assert.assertEquals(-i, completeDot[i + main.getDimension() + secondary1.getDimension()].getReal(),  1.0e-15);         }          T[] remappedState = equation.getMapper().mapState(state);         T[] remappedDerivative = equation.getMapper().mapDerivative(state);         Assert.assertEquals(equation.getMapper().getTotalDimension(), remappedState.length);         Assert.assertEquals(equation.getMapper().getTotalDimension(), remappedDerivative.length);         for (int i = 0; i < remappedState.length; ++i) {             Assert.assertEquals(complete[i].getReal(),    remappedState[i].getReal(),      1.0e-15);             Assert.assertEquals(completeDot[i].getReal(), remappedDerivative[i].getReal(), 1.0e-15);         }     }      @Test(expected=DimensionMismatchException.class)     public void testExtractDimensionMismatch() {         doTestExtractDimensionMismatch(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestExtractDimensionMismatch(final Field<T> field)         throws DimensionMismatchException {          FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         FieldSecondaryEquations<T> secondary1 = new Linear<>(field, 3, main.getDimension());         int i1 = equation.addSecondaryEquations(secondary1);         T[] tooShort    = MathArrays.buildArray(field, main.getDimension());         equation.getMapper().extractEquationData(i1, tooShort);     }      @Test(expected=DimensionMismatchException.class)     public void testInsertTooShortComplete() {         doTestInsertTooShortComplete(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestInsertTooShortComplete(final Field<T> field)         throws DimensionMismatchException {          FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         FieldSecondaryEquations<T> secondary1 = new Linear<>(field, 3, main.getDimension());         int i1 = equation.addSecondaryEquations(secondary1);         T[] equationData = MathArrays.buildArray(field, secondary1.getDimension());         T[] tooShort     = MathArrays.buildArray(field, main.getDimension());         equation.getMapper().insertEquationData(i1, equationData, tooShort);     }      @Test(expected=DimensionMismatchException.class)     public void testInsertWrongEquationData() {         doTestInsertWrongEquationData(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestInsertWrongEquationData(final Field<T> field)         throws DimensionMismatchException {          FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         FieldSecondaryEquations<T> secondary1 = new Linear<>(field, 3, main.getDimension());         int i1 = equation.addSecondaryEquations(secondary1);         T[] wrongEquationData = MathArrays.buildArray(field, secondary1.getDimension() + 1);         T[] complete          = MathArrays.buildArray(field, equation.getMapper().getTotalDimension());         equation.getMapper().insertEquationData(i1, wrongEquationData, complete);     }      @Test(expected=MathIllegalArgumentException.class)     public void testNegativeIndex() {         doTestNegativeIndex(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestNegativeIndex(final Field<T> field)         throws MathIllegalArgumentException {          FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         T[] complete = MathArrays.buildArray(field, equation.getMapper().getTotalDimension());         equation.getMapper().extractEquationData(-1, complete);     }      @Test(expected=MathIllegalArgumentException.class)     public void testTooLargeIndex() {         doTestTooLargeIndex(Decimal64Field.getInstance());     }      private <T extends RealFieldElement<T>> void doTestTooLargeIndex(final Field<T> field)         throws MathIllegalArgumentException {          FirstOrderFieldDifferentialEquations<T> main = new Linear<>(field, 3, 0);         FieldExpandableODE<T> equation = new FieldExpandableODE<>(main);         T[] complete = MathArrays.buildArray(field, equation.getMapper().getTotalDimension());         equation.getMapper().extractEquationData(+1, complete);     }      private static class  Linear<T extends RealFieldElement<T>>         implements  FirstOrderFieldDifferentialEquations<T>, FieldSecondaryEquations<T> {          private final Field<T> field;         private final int dimension;         private final int start;          private Linear(final Field<T> field, final int dimension, final int start) {             this.field     = field;             this.dimension = dimension;             this.start     = start;         }          @Override         public int getDimension() {             return dimension;         }          @Override         public void init(final T t0, final T[] y0, final T finalTime) {             Assert.assertEquals(dimension, y0.length);             Assert.assertEquals(10.0,  t0.getReal(), 1.0e-15);             Assert.assertEquals(100.0, finalTime.getReal(), 1.0e-15);             for (int i = 0; i < y0.length; ++i) {                 Assert.assertEquals(i, y0[i].getReal(), 1.0e-15);             }         }          @Override         public T[] computeDerivatives(final T t, final T[] y) {             final T[] yDot = MathArrays.buildArray(field, dimension);             for (int i = 0; i < dimension; ++i) {                 yDot[i] = field.getZero().add(i);             }             return yDot;         }          @Override         public void init(final T t0, final T[] primary0, final T[] secondary0, final T finalTime) {             Assert.assertEquals(dimension, secondary0.length);             Assert.assertEquals(10.0,  t0.getReal(), 1.0e-15);             Assert.assertEquals(100.0, finalTime.getReal(), 1.0e-15);             for (int i = 0; i < primary0.length; ++i) {                 Assert.assertEquals(i, primary0[i].getReal(), 1.0e-15);             }             for (int i = 0; i < secondary0.length; ++i) {                 Assert.assertEquals(start + i, secondary0[i].getReal(), 1.0e-15);             }         }          @Override         public T[] computeDerivatives(final T t, final T[] primary, final T[] primaryDot, final T[] secondary) {             final T[] secondaryDot = MathArrays.buildArray(field, dimension);             for (int i = 0; i < dimension; ++i) {                 secondaryDot[i] = field.getZero().subtract(i);             }             return secondaryDot;         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.ode;  import org.apache.commons.math4.ode.events.EventHandler; import org.apache.commons.math4.util.FastMath;  /**  * This class is used in the junit tests for the ODE integrators.   * <p>This specific problem is the following differential equation :  * <pre>  *    x'' = -x  * </pre>  * And when x decreases down to 0, the state should be changed as follows :  * <pre>  *   x' -> -x'  * </pre>  * The theoretical solution of this problem is x = |sin(t+a)|  * </p>   */ public class TestProblem4   extends TestProblemAbstract {    /** Time offset. */   private double a;    /** theoretical state */   private double[] y;    /** Simple constructor. */   public TestProblem4() {     super();     a = 1.2;     double[] y0 = { FastMath.sin(a), FastMath.cos(a) };     setInitialConditions(0.0, y0);     setFinalConditions(15);     double[] errorScale = { 1.0, 0.0 };     setErrorScale(errorScale);     y = new double[y0.length];   }    @Override   public EventHandler[] getEventsHandlers() {     return new EventHandler[] { new Bounce(), new Stop() };   }    /**    * Get the theoretical events times.    * @return theoretical events times    */   @Override   public double[] getTheoreticalEventsTimes() {       return new double[] {           1 * FastMath.PI - a,           2 * FastMath.PI - a,           3 * FastMath.PI - a,           4 * FastMath.PI - a,           12.0       };   }    @Override   public void doComputeDerivatives(double t, double[] y, double[] yDot) {     yDot[0] =  y[1];     yDot[1] = -y[0];   }    @Override   public double[] computeTheoreticalState(double t) {     double sin = FastMath.sin(t + a);     double cos = FastMath.cos(t + a);     y[0] = FastMath.abs(sin);     y[1] = (sin >= 0) ? cos : -cos;     return y;   }    private static class Bounce implements EventHandler {      private int sign;      public Bounce() {       sign = +1;     }      @Override     public void init(double t0, double[] y0, double t) {     }      @Override     public double g(double t, double[] y) {       return sign * y[0];     }      @Override     public Action eventOccurred(double t, double[] y, boolean increasing) {       // this sign change is needed because the state will be reset soon       sign = -sign;       return Action.RESET_STATE;     }      @Override     public void resetState(double t, double[] y) {       y[0] = -y[0];       y[1] = -y[1];     }    }    private static class Stop implements EventHandler {      public Stop() {     }      @Override     public void init(double t0, double[] y0, double t) {     }      @Override     public double g(double t, double[] y) {       return t - 12.0;     }      @Override     public Action eventOccurred(double t, double[] y, boolean increasing) {       return Action.STOP;     }      @Override     public void resetState(double t, double[] y) {     }    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.optim;  import org.apache.commons.math4.TestUtils; import org.junit.Assert; import org.junit.Test;  public class PointVectorValuePairTest {     @Test     public void testSerial() {         PointVectorValuePair pv1 = new PointVectorValuePair(new double[] { 1.0, 2.0, 3.0 },                                                             new double[] { 4.0, 5.0 });         PointVectorValuePair pv2 = (PointVectorValuePair) TestUtils.serializeAndRecover(pv1);         Assert.assertEquals(pv1.getKey().length, pv2.getKey().length);         for (int i = 0; i < pv1.getKey().length; ++i) {             Assert.assertEquals(pv1.getKey()[i], pv2.getKey()[i], 1.0e-15);         }         Assert.assertEquals(pv1.getValue().length, pv2.getValue().length);         for (int i = 0; i < pv1.getValue().length; ++i) {             Assert.assertEquals(pv1.getValue()[i], pv2.getValue()[i], 1.0e-15);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert;  public class SimplePointCheckerTest {     @Test(expected=NotStrictlyPositiveException.class)     public void testIterationCheckPrecondition() {         new SimplePointChecker<PointValuePair>(1e-1, 1e-2, 0);     }      @Test     public void testIterationCheck() {         final int max = 10;         final SimplePointChecker<PointValuePair> checker             = new SimplePointChecker<>(1e-1, 1e-2, max);         Assert.assertTrue(checker.converged(max, null, null));         Assert.assertTrue(checker.converged(max + 1, null, null));     }      @Test     public void testIterationCheckDisabled() {         final SimplePointChecker<PointValuePair> checker             = new SimplePointChecker<>(1e-8, 1e-8);          final PointValuePair a = new PointValuePair(new double[] { 1d }, 1d);         final PointValuePair b = new PointValuePair(new double[] { 10d }, 10d);          Assert.assertFalse(checker.converged(-1, a, b));         Assert.assertFalse(checker.converged(0, a, b));         Assert.assertFalse(checker.converged(1000000, a, b));          Assert.assertTrue(checker.converged(-1, a, a));         Assert.assertTrue(checker.converged(-1, b, b));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.univariate;   import org.apache.commons.math4.analysis.FunctionUtils; import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.StepFunction; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.optim.ConvergenceChecker; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.math4.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  */ public final class BrentOptimizerTest {      @Test     public void testSinMin() {         UnivariateFunction f = new Sin();         UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);         Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(new MaxEval(200),                                                                 new UnivariateObjectiveFunction(f),                                                                 GoalType.MINIMIZE,                                                                 new SearchInterval(4, 5)).getPoint(), 1e-8);         Assert.assertTrue(optimizer.getEvaluations() <= 50);         Assert.assertEquals(200, optimizer.getMaxEvaluations());         Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(new MaxEval(200),                                                                 new UnivariateObjectiveFunction(f),                                                                 GoalType.MINIMIZE,                                                                 new SearchInterval(1, 5)).getPoint(), 1e-8);         Assert.assertTrue(optimizer.getEvaluations() <= 100);         Assert.assertTrue(optimizer.getEvaluations() >= 15);         try {             optimizer.optimize(new MaxEval(10),                                new UnivariateObjectiveFunction(f),                                GoalType.MINIMIZE,                                new SearchInterval(4, 5));             Assert.fail("an exception should have been thrown");         } catch (TooManyEvaluationsException fee) {             // expected         }     }      @Test     public void testSinMinWithValueChecker() {         final UnivariateFunction f = new Sin();         final ConvergenceChecker<UnivariatePointValuePair> checker = new SimpleUnivariateValueChecker(1e-5, 1e-14);         // The default stopping criterion of Brent's algorithm should not         // pass, but the search will stop at the given relative tolerance         // for the function value.         final UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14, checker);         final UnivariatePointValuePair result = optimizer.optimize(new MaxEval(200),                                                                    new UnivariateObjectiveFunction(f),                                                                    GoalType.MINIMIZE,                                                                    new SearchInterval(4, 5));         Assert.assertEquals(3 * Math.PI / 2, result.getPoint(), 1e-3);     }      @Test     public void testBoundaries() {         final double lower = -1.0;         final double upper = +1.0;         UnivariateFunction f = new UnivariateFunction() {             @Override             public double value(double x) {                 if (x < lower) {                     throw new NumberIsTooSmallException(x, lower, true);                 } else if (x > upper) {                     throw new NumberIsTooLargeException(x, upper, true);                 } else {                     return x;                 }             }         };         UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);         Assert.assertEquals(lower,                             optimizer.optimize(new MaxEval(100),                                                new UnivariateObjectiveFunction(f),                                                GoalType.MINIMIZE,                                                new SearchInterval(lower, upper)).getPoint(),                             1.0e-8);         Assert.assertEquals(upper,                             optimizer.optimize(new MaxEval(100),                                                new UnivariateObjectiveFunction(f),                                                GoalType.MAXIMIZE,                                                new SearchInterval(lower, upper)).getPoint(),                             1.0e-8);     }      @Test     public void testQuinticMin() {         // The function has local minima at -0.27195613 and 0.82221643.         UnivariateFunction f = new QuinticFunction();         UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);         Assert.assertEquals(-0.27195613, optimizer.optimize(new MaxEval(200),                                                             new UnivariateObjectiveFunction(f),                                                             GoalType.MINIMIZE,                                                             new SearchInterval(-0.3, -0.2)).getPoint(), 1.0e-8);         Assert.assertEquals( 0.82221643, optimizer.optimize(new MaxEval(200),                                                             new UnivariateObjectiveFunction(f),                                                             GoalType.MINIMIZE,                                                             new SearchInterval(0.3,  0.9)).getPoint(), 1.0e-8);         Assert.assertTrue(optimizer.getEvaluations() <= 50);          // search in a large interval         Assert.assertEquals(-0.27195613, optimizer.optimize(new MaxEval(200),                                                             new UnivariateObjectiveFunction(f),                                                             GoalType.MINIMIZE,                                                             new SearchInterval(-1.0, 0.2)).getPoint(), 1.0e-8);         Assert.assertTrue(optimizer.getEvaluations() <= 50);     }      @Test     public void testQuinticMinStatistics() {         // The function has local minima at -0.27195613 and 0.82221643.         UnivariateFunction f = new QuinticFunction();         UnivariateOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14);          final DescriptiveStatistics[] stat = new DescriptiveStatistics[2];         for (int i = 0; i < stat.length; i++) {             stat[i] = new DescriptiveStatistics();         }          final double min = -0.75;         final double max = 0.25;         final int nSamples = 200;         final double delta = (max - min) / nSamples;         for (int i = 0; i < nSamples; i++) {             final double start = min + i * delta;             stat[0].addValue(optimizer.optimize(new MaxEval(40),                                                 new UnivariateObjectiveFunction(f),                                                 GoalType.MINIMIZE,                                                 new SearchInterval(min, max, start)).getPoint());             stat[1].addValue(optimizer.getEvaluations());         }          final double meanOptValue = stat[0].getMean();         final double medianEval = stat[1].getPercentile(50);         Assert.assertTrue(meanOptValue > -0.2719561281);         Assert.assertTrue(meanOptValue < -0.2719561280);         Assert.assertEquals(23, (int) medianEval);          // MATH-1121: Ensure that the iteration counter is incremented.         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testQuinticMax() {         // The quintic function has zeros at 0, +-0.5 and +-1.         // The function has a local maximum at 0.27195613.         UnivariateFunction f = new QuinticFunction();         UnivariateOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14);         Assert.assertEquals(0.27195613, optimizer.optimize(new MaxEval(100),                                                            new UnivariateObjectiveFunction(f),                                                            GoalType.MAXIMIZE,                                                            new SearchInterval(0.2, 0.3)).getPoint(), 1e-8);         try {             optimizer.optimize(new MaxEval(5),                                new UnivariateObjectiveFunction(f),                                GoalType.MAXIMIZE,                                new SearchInterval(0.2, 0.3));             Assert.fail("an exception should have been thrown");         } catch (TooManyEvaluationsException miee) {             // expected         }     }      @Test     public void testMinEndpoints() {         UnivariateFunction f = new Sin();         UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14);          // endpoint is minimum         double result = optimizer.optimize(new MaxEval(50),                                            new UnivariateObjectiveFunction(f),                                            GoalType.MINIMIZE,                                            new SearchInterval(3 * Math.PI / 2, 5)).getPoint();         Assert.assertEquals(3 * Math.PI / 2, result, 1e-6);          result = optimizer.optimize(new MaxEval(50),                                     new UnivariateObjectiveFunction(f),                                     GoalType.MINIMIZE,                                     new SearchInterval(4, 3 * Math.PI / 2)).getPoint();         Assert.assertEquals(3 * Math.PI / 2, result, 1e-6);     }      @Test     public void testMath832() {         final UnivariateFunction f = new UnivariateFunction() {                 @Override                 public double value(double x) {                     final double sqrtX = FastMath.sqrt(x);                     final double a = 1e2 * sqrtX;                     final double b = 1e6 / x;                     final double c = 1e4 / sqrtX;                      return a + b + c;                 }             };          UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-8);         final double result = optimizer.optimize(new MaxEval(1484),                                                  new UnivariateObjectiveFunction(f),                                                  GoalType.MINIMIZE,                                                  new SearchInterval(Double.MIN_VALUE,                                                                     Double.MAX_VALUE)).getPoint();          Assert.assertEquals(804.9355825, result, 1e-6);     }      /**      * Contrived example showing that prior to the resolution of MATH-855      * (second revision), the algorithm would not return the best point if      * it happened to be the initial guess.      */     @Test     public void testKeepInitIfBest() {         final double minSin = 3 * Math.PI / 2;         final double offset = 1e-8;         final double delta = 1e-7;         final UnivariateFunction f1 = new Sin();         final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},                                                        new double[] { 0, -1, 0 });         final UnivariateFunction f = FunctionUtils.add(f1, f2);         // A slightly less stringent tolerance would make the test pass         // even with the previous implementation.         final double relTol = 1e-8;         final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);         final double init = minSin + 1.5 * offset;         final UnivariatePointValuePair result             = optimizer.optimize(new MaxEval(200),                                  new UnivariateObjectiveFunction(f),                                  GoalType.MINIMIZE,                                  new SearchInterval(minSin - 6.789 * delta,                                                     minSin + 9.876 * delta,                                                     init));          final double sol = result.getPoint();         final double expected = init;  //         System.out.println("numEval=" + numEval); //         System.out.println("min=" + init + " f=" + f.value(init)); //         System.out.println("sol=" + sol + " f=" + f.value(sol)); //         System.out.println("exp=" + expected + " f=" + f.value(expected));          Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected));     }      /**      * Contrived example showing that prior to the resolution of MATH-855,      * the algorithm, by always returning the last evaluated point, would      * sometimes not report the best point it had found.      */     @Test     public void testMath855() {         final double minSin = 3 * Math.PI / 2;         final double offset = 1e-8;         final double delta = 1e-7;         final UnivariateFunction f1 = new Sin();         final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset },                                                        new double[] { 0, -1, 0 });         final UnivariateFunction f = FunctionUtils.add(f1, f2);         final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100);         final UnivariatePointValuePair result             = optimizer.optimize(new MaxEval(200),                                  new UnivariateObjectiveFunction(f),                                  GoalType.MINIMIZE,                                  new SearchInterval(minSin - 6.789 * delta,                                                     minSin + 9.876 * delta));          final double sol = result.getPoint();         final double expected = 4.712389027602411;          // System.out.println("min=" + (minSin + offset) + " f=" + f.value(minSin + offset));         // System.out.println("sol=" + sol + " f=" + f.value(sol));         // System.out.println("exp=" + expected + " f=" + f.value(expected));          Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.univariate;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class MultiStartUnivariateOptimizerTest {     @Test(expected=MathIllegalStateException.class)     public void testMissingMaxEval() {         UnivariateOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);         UniformRandomProvider g = RandomSource.create(RandomSource.TWO_CMRES, 44428400075l);         MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 10, g);         optimizer.optimize(new UnivariateObjectiveFunction(new Sin()),                            GoalType.MINIMIZE,                            new SearchInterval(-1, 1));     }     @Test(expected=MathIllegalStateException.class)     public void testMissingSearchInterval() {         UnivariateOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);         UniformRandomProvider g = RandomSource.create(RandomSource.TWO_CMRES, 44428400075l);         MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 10, g);         optimizer.optimize(new MaxEval(300),                            new UnivariateObjectiveFunction(new Sin()),                            GoalType.MINIMIZE);     }      @Test     public void testSinMin() {         UnivariateFunction f = new Sin();         UnivariateOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);         UniformRandomProvider g = RandomSource.create(RandomSource.TWO_CMRES, 44428400075l);         MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 10, g);         optimizer.optimize(new MaxEval(300),                            new UnivariateObjectiveFunction(f),                            GoalType.MINIMIZE,                            new SearchInterval(-100.0, 100.0));         UnivariatePointValuePair[] optima = optimizer.getOptima();         for (int i = 1; i < optima.length; ++i) {             double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);             Assert.assertTrue(FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);             Assert.assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10);             Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10);         }         Assert.assertTrue(optimizer.getEvaluations() > 200);         Assert.assertTrue(optimizer.getEvaluations() < 300);     }      @Test     public void testQuinticMin() {         UnivariateFunction f = new QuinticFunction();         UnivariateOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);         UniformRandomProvider g = RandomSource.create(RandomSource.TWO_CMRES, 4312000053L);         MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 5, g);          UnivariatePointValuePair optimum             = optimizer.optimize(new MaxEval(300),                                  new UnivariateObjectiveFunction(f),                                  GoalType.MINIMIZE,                                  new SearchInterval(-0.3, -0.2));         Assert.assertEquals(-0.2719561295, optimum.getPoint(), 1e-9);         Assert.assertEquals(-0.0443342695, optimum.getValue(), 1e-9);          UnivariatePointValuePair[] optima = optimizer.getOptima();         for (int i = 0; i < optima.length; ++i) {             Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);         }         Assert.assertTrue(optimizer.getEvaluations() >= 50);         Assert.assertTrue(optimizer.getEvaluations() <= 100);     }      @Test     public void testBadFunction() {         UnivariateFunction f = new UnivariateFunction() {                 @Override                 public double value(double x) {                     if (x < 0) {                         throw new LocalException();                     }                     return 0;                 }             };         UnivariateOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);         UniformRandomProvider g = RandomSource.create(RandomSource.TWO_CMRES, 4312000053L);         MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 5, g);          try {             optimizer.optimize(new MaxEval(300),                                new UnivariateObjectiveFunction(f),                                GoalType.MINIMIZE,                                new SearchInterval(-0.3, -0.2));             Assert.fail();         } catch (LocalException e) {             // Expected.         }          // Ensure that the exception was thrown because no optimum was found.         Assert.assertTrue(optimizer.getOptima()[0] == null);     }      private static class LocalException extends RuntimeException {         private static final long serialVersionUID = 1194682757034350629L;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.univariate;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert;  public class SimpleUnivariateValueCheckerTest {     @Test(expected=NotStrictlyPositiveException.class)     public void testIterationCheckPrecondition() {         new SimpleUnivariateValueChecker(1e-1, 1e-2, 0);     }      @Test     public void testIterationCheck() {         final int max = 10;         final SimpleUnivariateValueChecker checker = new SimpleUnivariateValueChecker(1e-1, 1e-2, max);         Assert.assertTrue(checker.converged(max, null, null));         Assert.assertTrue(checker.converged(max + 1, null, null));     }      @Test     public void testIterationCheckDisabled() {         final SimpleUnivariateValueChecker checker = new SimpleUnivariateValueChecker(1e-8, 1e-8);          final UnivariatePointValuePair a = new UnivariatePointValuePair(1d, 1d);         final UnivariatePointValuePair b = new UnivariatePointValuePair(10d, 10d);          Assert.assertFalse(checker.converged(-1, a, b));         Assert.assertFalse(checker.converged(0, a, b));         Assert.assertFalse(checker.converged(1000000, a, b));          Assert.assertTrue(checker.converged(-1, a, a));         Assert.assertTrue(checker.converged(-1, b, b));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.univariate;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link BracketFinder}.  */ public class BracketFinderTest {      @Test     public void testCubicMin() {         final BracketFinder bFind = new BracketFinder();         final UnivariateFunction func = new UnivariateFunction() {                 @Override                 public double value(double x) {                     if (x < -2) {                         return value(-2);                     }                     else  {                         return (x - 1) * (x + 2) * (x + 3);                     }                 }             };          bFind.search(func, GoalType.MINIMIZE, -2 , -1);         final double tol = 1e-15;         // Comparing with results computed in Python.         Assert.assertEquals(-2, bFind.getLo(), tol);         Assert.assertEquals(-1, bFind.getMid(), tol);         Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);     }      @Test     public void testCubicMax() {         final BracketFinder bFind = new BracketFinder();         final UnivariateFunction func = new UnivariateFunction() {                 @Override                 public double value(double x) {                     if (x < -2) {                         return value(-2);                     }                     else  {                         return -(x - 1) * (x + 2) * (x + 3);                     }                 }             };          bFind.search(func, GoalType.MAXIMIZE, -2 , -1);         final double tol = 1e-15;         Assert.assertEquals(-2, bFind.getLo(), tol);         Assert.assertEquals(-1, bFind.getMid(), tol);         Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);     }      @Test     public void testMinimumIsOnIntervalBoundary() {         final UnivariateFunction func = new UnivariateFunction() {                 @Override                 public double value(double x) {                     return x * x;                 }             };          final BracketFinder bFind = new BracketFinder();          bFind.search(func, GoalType.MINIMIZE, 0, 1);         Assert.assertTrue(bFind.getLo() <= 0);         Assert.assertTrue(0 <= bFind.getHi());          bFind.search(func, GoalType.MINIMIZE, -1, 0);         Assert.assertTrue(bFind.getLo() <= 0);         Assert.assertTrue(0 <= bFind.getHi());     }      @Test     public void testIntervalBoundsOrdering() {         final UnivariateFunction func = new UnivariateFunction() {                 @Override                 public double value(double x) {                     return x * x;                 }             };          final BracketFinder bFind = new BracketFinder();          bFind.search(func, GoalType.MINIMIZE, -1, 1);         Assert.assertTrue(bFind.getLo() <= 0);         Assert.assertTrue(0 <= bFind.getHi());          bFind.search(func, GoalType.MINIMIZE, 1, -1);         Assert.assertTrue(bFind.getLo() <= 0);         Assert.assertTrue(0 <= bFind.getHi());          bFind.search(func, GoalType.MINIMIZE, 1, 2);         Assert.assertTrue(bFind.getLo() <= 0);         Assert.assertTrue(0 <= bFind.getHi());          bFind.search(func, GoalType.MINIMIZE, 2, 1);         Assert.assertTrue(bFind.getLo() <= 0);         Assert.assertTrue(0 <= bFind.getHi());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert;  public class SimpleVectorValueCheckerTest {     @Test(expected=NotStrictlyPositiveException.class)     public void testIterationCheckPrecondition() {         new SimpleVectorValueChecker(1e-1, 1e-2, 0);     }      @Test     public void testIterationCheck() {         final int max = 10;         final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(1e-1, 1e-2, max);         Assert.assertTrue(checker.converged(max, null, null));         Assert.assertTrue(checker.converged(max + 1, null, null));     }      @Test     public void testIterationCheckDisabled() {         final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(1e-8, 1e-8);          final PointVectorValuePair a = new PointVectorValuePair(new double[] { 1d },                                                                 new double[] { 1d });         final PointVectorValuePair b = new PointVectorValuePair(new double[] { 10d },                                                                 new double[] { 10d });          Assert.assertFalse(checker.converged(-1, a, b));         Assert.assertFalse(checker.converged(0, a, b));         Assert.assertFalse(checker.converged(1000000, a, b));          Assert.assertTrue(checker.converged(-1, a, a));         Assert.assertTrue(checker.converged(-1, b, b));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.linear;  import java.util.ArrayList; import java.util.Collection;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.junit.Assert; import org.junit.Test;  public class SimplexTableauTest {      @Test     public void testInitialization() {         LinearObjectiveFunction f = createFunction();         Collection<LinearConstraint> constraints = createConstraints();         SimplexTableau tableau =             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);         double[][] expectedInitialTableau = {                                              {-1, 0,  -1,  -1,  2, 0, 0, 0, -4},                                              { 0, 1, -1.875, -1.25, 3.125, 0, 0, 0,  0},                                              { 0, 0,   1,   0, -1, 1, 0, 0,  2},                                              { 0, 0,   0,   1, -1, 0, 1, 0,  3},                                              { 0, 0,   1,   1, -2, 0, 0, 1,  4}         };         assertMatrixEquals(expectedInitialTableau, tableau.getData());     }      @Test     public void testDropPhase1Objective() {         LinearObjectiveFunction f = createFunction();         Collection<LinearConstraint> constraints = createConstraints();         SimplexTableau tableau =             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);         double[][] expectedTableau = {                                       { 1, -1.875, -1.25, 0, 0, 0, 0},                                       { 0,   1,   0, 1, 0, 0, 2},                                       { 0,   0,   1, 0, 1, 0, 3},                                       { 0,   1,   1, 0, 0, 1, 4}         };         tableau.dropPhase1Objective();         assertMatrixEquals(expectedTableau, tableau.getData());     }      @Test     public void testTableauWithNoArtificialVars() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));         constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));         constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));         SimplexTableau tableau =             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);         double[][] initialTableau = {                                      {1, -1.875, -1.25, 3.125, 0, 0, 0, 0},                                      {0,   1,   0, -1, 1, 0, 0, 2},                                      {0,   0,   1, -1, 0, 1, 0, 3},                                      {0,   1,   1, -2, 0, 0, 1, 4}         };         assertMatrixEquals(initialTableau, tableau.getData());     }      @Test     public void testSerial() {         LinearObjectiveFunction f = createFunction();         Collection<LinearConstraint> constraints = createConstraints();         SimplexTableau tableau =             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);         Assert.assertEquals(tableau, TestUtils.serializeAndRecover(tableau));     }      private LinearObjectiveFunction createFunction() {         return new LinearObjectiveFunction(new double[] {15, 10}, 0);     }      private Collection<LinearConstraint> createConstraints() {         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));         constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));         constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4));         return constraints;     }      private void assertMatrixEquals(double[][] expected, double[][] result) {         Assert.assertEquals("Wrong number of rows.", expected.length, result.length);         for (int i = 0; i < expected.length; i++) {             Assert.assertEquals("Wrong number of columns.", expected[i].length, result[i].length);             for (int j = 0; j < expected[i].length; j++) {                 Assert.assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j], 1.0e-15);             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.linear;  import java.util.ArrayList; import java.util.Collection; import java.util.List; import org.junit.Test; import org.junit.Assert;  import org.apache.commons.numbers.core.Precision; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.TooManyIterationsException; import org.apache.commons.math4.optim.MaxIter; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType;  public class SimplexSolverTest {     private static final MaxIter DEFAULT_MAX_ITER = new MaxIter(100);      @Test     public void testMath842Cycle() {         // from http://www.math.toronto.edu/mpugh/Teaching/APM236_04/bland         //      maximize 10 x1 - 57 x2 - 9 x3 - 24 x4         //      subject to         //          1/2 x1 - 11/2 x2 - 5/2 x3 + 9 x4  <= 0         //          1/2 x1 -  3/2 x2 - 1/2 x3 +   x4  <= 0         //              x1                  <= 1         //      x1,x2,x3,x4 >= 0          LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 10, -57, -9, -24}, 0);          ArrayList<LinearConstraint> constraints = new ArrayList<>();          constraints.add(new LinearConstraint(new double[] {0.5, -5.5, -2.5, 9}, Relationship.LEQ, 0));         constraints.add(new LinearConstraint(new double[] {0.5, -1.5, -0.5, 1}, Relationship.LEQ, 0));         constraints.add(new LinearConstraint(new double[] {  1,    0,    0, 0}, Relationship.LEQ, 1));          double epsilon = 1e-6;         SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE,                                                   new NonNegativeConstraint(true),                                                   PivotSelectionRule.BLAND);         Assert.assertEquals(1.0d, solution.getValue(), epsilon);         Assert.assertTrue(validSolution(solution, constraints, epsilon));     }      @Test     public void testMath828() {         LinearObjectiveFunction f = new LinearObjectiveFunction(                 new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0);          ArrayList <LinearConstraint>constraints = new ArrayList<>();          constraints.add(new LinearConstraint(new double[] {0.0, 39.0, 23.0, 96.0, 15.0, 48.0, 9.0, 21.0, 48.0, 36.0, 76.0, 19.0, 88.0, 17.0, 16.0, 36.0,}, Relationship.GEQ, 15.0));         constraints.add(new LinearConstraint(new double[] {0.0, 59.0, 93.0, 12.0, 29.0, 78.0, 73.0, 87.0, 32.0, 70.0, 68.0, 24.0, 11.0, 26.0, 65.0, 25.0,}, Relationship.GEQ, 29.0));         constraints.add(new LinearConstraint(new double[] {0.0, 74.0, 5.0, 82.0, 6.0, 97.0, 55.0, 44.0, 52.0, 54.0, 5.0, 93.0, 91.0, 8.0, 20.0, 97.0,}, Relationship.GEQ, 6.0));         constraints.add(new LinearConstraint(new double[] {8.0, -3.0, -28.0, -72.0, -8.0, -31.0, -31.0, -74.0, -47.0, -59.0, -24.0, -57.0, -56.0, -16.0, -92.0, -59.0,}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {25.0, -7.0, -99.0, -78.0, -25.0, -14.0, -16.0, -89.0, -39.0, -56.0, -53.0, -9.0, -18.0, -26.0, -11.0, -61.0,}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {33.0, -95.0, -15.0, -4.0, -33.0, -3.0, -20.0, -96.0, -27.0, -13.0, -80.0, -24.0, -3.0, -13.0, -57.0, -76.0,}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {7.0, -95.0, -39.0, -93.0, -7.0, -94.0, -94.0, -62.0, -76.0, -26.0, -53.0, -57.0, -31.0, -76.0, -53.0, -52.0,}, Relationship.GEQ, 0.0));          double epsilon = 1e-6;         PointValuePair solution = new SimplexSolver().optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                                GoalType.MINIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(1.0d, solution.getValue(), epsilon);         Assert.assertTrue(validSolution(solution, constraints, epsilon));     }      @Test     public void testMath828Cycle() {         LinearObjectiveFunction f = new LinearObjectiveFunction(                 new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0);          ArrayList <LinearConstraint>constraints = new ArrayList<>();          constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0));         constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0));         constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0));         constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0));          double epsilon = 1e-6;         PointValuePair solution = new SimplexSolver().optimize(DEFAULT_MAX_ITER, f,                                                                new LinearConstraintSet(constraints),                                                                GoalType.MINIMIZE, new NonNegativeConstraint(true),                                                                PivotSelectionRule.BLAND);         Assert.assertEquals(1.0d, solution.getValue(), epsilon);         Assert.assertTrue(validSolution(solution, constraints, epsilon));     }      @Test     public void testMath781() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 6, 7 }, 0);          ArrayList<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 2, 1 }, Relationship.LEQ, 2));         constraints.add(new LinearConstraint(new double[] { -1, 1, 1 }, Relationship.LEQ, -1));         constraints.add(new LinearConstraint(new double[] { 2, -3, 1 }, Relationship.LEQ, -1));          double epsilon = 1e-6;         SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(false));          Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0);         Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) > 0);         Assert.assertTrue(Precision.compareTo(solution.getPoint()[2], 0.0d, epsilon) < 0);         Assert.assertEquals(2.0d, solution.getValue(), epsilon);     }      @Test     public void testMath713NegativeVariable() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d);         ArrayList<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1));          double epsilon = 1e-6;         SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(true));          Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0);         Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);     }      @Test     public void testMath434NegativeVariable() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0, 0.0, 1.0}, 0.0d);         ArrayList<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {1, 1, 0}, Relationship.EQ, 5));         constraints.add(new LinearConstraint(new double[] {0, 0, 1}, Relationship.GEQ, -10));          double epsilon = 1e-6;         SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(false));          Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon);         Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon);         Assert.assertEquals(-10.0, solution.getValue(), epsilon);      }      @Test(expected = NoFeasibleSolutionException.class)     public void testMath434UnfeasibleSolution() {         double epsilon = 1e-6;          LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 0.0}, 0.0);         ArrayList<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {epsilon/2, 0.5}, Relationship.EQ, 0));         constraints.add(new LinearConstraint(new double[] {1e-3, 0.1}, Relationship.EQ, 10));          SimplexSolver solver = new SimplexSolver();         // allowing only non-negative values, no feasible solution shall be found         solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                         GoalType.MINIMIZE, new NonNegativeConstraint(true));     }      @Test     public void testMath434PivotRowSelection() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0}, 0.0);          double epsilon = 1e-6;         ArrayList<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {200}, Relationship.GEQ, 1));         constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(false));          Assert.assertTrue(Precision.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);         Assert.assertEquals(0.0050, solution.getValue(), epsilon);     }      @Test     public void testMath434PivotRowSelection2() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d);          ArrayList<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d));         constraints.add(new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d));         constraints.add(new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));         constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d));         constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d));         constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));         constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));         constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));         constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));          double epsilon = 1e-7;         SimplexSolver simplex = new SimplexSolver();         PointValuePair solution = simplex.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                    GoalType.MINIMIZE, new NonNegativeConstraint(false));          Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);         Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon);         Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon);         Assert.assertEquals(1.0d, solution.getValue(), epsilon);     }      @Test     public void testMath272() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));         constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));         constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(true));          Assert.assertEquals(0.0, solution.getPoint()[0], .0000001);         Assert.assertEquals(1.0, solution.getPoint()[1], .0000001);         Assert.assertEquals(1.0, solution.getPoint()[2], .0000001);         Assert.assertEquals(3.0, solution.getValue(), .0000001);     }      @Test     public void testMath286() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 );         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0));         constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0));         constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0));         constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0));         constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(true));          Assert.assertEquals(25.8, solution.getValue(), .0000001);         Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001);         Assert.assertEquals(23.0, solution.getPoint()[1] + solution.getPoint()[3] + solution.getPoint()[5], 0.0000001);         Assert.assertTrue(solution.getPoint()[0] >= 10.0 - 0.0000001);         Assert.assertTrue(solution.getPoint()[2] >= 8.0 - 0.0000001);         Assert.assertTrue(solution.getPoint()[4] >= 5.0 - 0.0000001);     }      @Test     public void testDegeneracy() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.7 }, 0 );         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 18.0));         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.GEQ, 10.0));         constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(13.6, solution.getValue(), .0000001);     }      @Test     public void testMath288() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));         constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(10.0, solution.getValue(), .0000001);     }      @Test     public void testMath290GEQ() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0));         SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(0, solution.getValue(), .0000001);         Assert.assertEquals(0, solution.getPoint()[0], .0000001);         Assert.assertEquals(0, solution.getPoint()[1], .0000001);     }      @Test(expected=NoFeasibleSolutionException.class)     public void testMath290LEQ() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0));         SimplexSolver solver = new SimplexSolver();         solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                         GoalType.MINIMIZE, new NonNegativeConstraint(true));     }      @Test     public void testMath293() {       LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );       Collection<LinearConstraint> constraints = new ArrayList<>();       constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));       constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));       constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0));       constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0));       constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0));        SimplexSolver solver = new SimplexSolver();       PointValuePair solution1 = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                  GoalType.MAXIMIZE, new NonNegativeConstraint(true));        Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001);       Assert.assertEquals(0.0, solution1.getPoint()[1], .0001);       Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001);       Assert.assertEquals(0.0, solution1.getPoint()[3], .0001);       Assert.assertEquals(0.0, solution1.getPoint()[4], .0001);       Assert.assertEquals(30.0, solution1.getPoint()[5], .0001);       Assert.assertEquals(40.57143, solution1.getValue(), .0001);        double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1];       double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3];       double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5];        f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );       constraints = new ArrayList<>();       constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));       constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));       constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA));       constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB));       constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC));        PointValuePair solution2 = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                  GoalType.MAXIMIZE, new NonNegativeConstraint(true));       Assert.assertEquals(40.57143, solution2.getValue(), .0001);     }      @Test     public void testMath930() {         Collection<LinearConstraint> constraints = createMath930Constraints();          double[] objFunctionCoeff = new double[33];         objFunctionCoeff[3] = 1;         LinearObjectiveFunction f = new LinearObjectiveFunction(objFunctionCoeff, 0);         SimplexSolver solver = new SimplexSolver(1e-4, 10, 1e-6);          PointValuePair solution = solver.optimize(new MaxIter(1000), f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(0.3752298, solution.getValue(), 1e-4);     }      private List<LinearConstraint> createMath930Constraints() {         List<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 1, 0, -1, 0, -1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0, -1, 0, 1, 0, 1, 0, -1, 0, 1, 0, -1, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.628803}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.676993}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 1, -1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.136677}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.444434}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.254028}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.302218}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 1, -1, -1, 1, 0, 0, 0, 0, -1, 1, 1, -1, 0, 0, 0, 0, -1, 1, 1, -1, 0, 0, 0, 0, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.653981}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.690437}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.423786}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.486717}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.049232}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.304747}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.129826}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.205625}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, 1, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 1, -1, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.621944}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.764385}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.432572}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.480762}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.055983}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.11378}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.009607}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.057797}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.407308}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.452749}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.269677}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.321806}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.049232}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.06902}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.028754}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.484254}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.524607}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, -1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.385492}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.430134}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.34983}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.375781}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.254028}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.281308}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, 0, 0, 0, 0, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.304995}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.345347}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.288899}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.332212}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.14351}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.17057}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, -0.129826}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, -0.157435}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -0.141071}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -0.232574}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, -0.009607}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, -0.057797}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, -0.091644}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, -0.203531}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -0.028754}, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, Relationship.EQ, 1.0));         return constraints;     }      @Test     public void testSimplexSolver() {         LinearObjectiveFunction f =             new LinearObjectiveFunction(new double[] { 15, 10 }, 7);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));         constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);         Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);         Assert.assertEquals(57.0, solution.getValue(), 0.0);     }      @Test     public void testSingleVariableAndConstraint() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(false));         Assert.assertEquals(10.0, solution.getPoint()[0], 0.0);         Assert.assertEquals(30.0, solution.getValue(), 0.0);     }      /**      * With no artificial variables needed (no equals and no greater than      * constraints) we can go straight to Phase 2.      */     @Test     public void testModelWithNoArtificialVars() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));         constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(false));         Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);         Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);         Assert.assertEquals(50.0, solution.getValue(), 0.0);     }      @Test     public void testMinimization() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));         constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12));         constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(false));         Assert.assertEquals(4.0, solution.getPoint()[0], 0.0);         Assert.assertEquals(0.0, solution.getPoint()[1], 0.0);         Assert.assertEquals(-13.0, solution.getValue(), 0.0);     }      @Test     public void testSolutionWithNegativeDecisionVariable() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));         constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(false));         Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0);         Assert.assertEquals(8.0, solution.getPoint()[1], 0.0);         Assert.assertEquals(12.0, solution.getValue(), 0.0);     }      @Test(expected = NoFeasibleSolutionException.class)     public void testInfeasibleSolution() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3));          SimplexSolver solver = new SimplexSolver();         solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                         GoalType.MAXIMIZE, new NonNegativeConstraint(false));     }      @Test(expected = UnboundedSolutionException.class)     public void testUnboundedSolution() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));          SimplexSolver solver = new SimplexSolver();         solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                         GoalType.MAXIMIZE, new NonNegativeConstraint(false));     }      @Test     public void testRestrictVariablesToNonNegative() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));         constraints.add(new LinearConstraint(new double[] {    12,   45,   7,  56,   23 }, Relationship.LEQ,    56454));         constraints.add(new LinearConstraint(new double[] {     8,  768,   0,  34, 7456 }, Relationship.LEQ,  1923421));         constraints.add(new LinearConstraint(new double[] { 12342, 2342,  34, 678, 2342 }, Relationship.GEQ,     4356));         constraints.add(new LinearConstraint(new double[] {    45,  678,  76,  52,   23 }, Relationship.EQ,    456356));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);         Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001);         Assert.assertEquals(0.0, solution.getPoint()[2], .0000001);         Assert.assertEquals(0.0, solution.getPoint()[3], .0000001);         Assert.assertEquals(0.0, solution.getPoint()[4], .0000001);         Assert.assertEquals(1438556.7491409, solution.getValue(), .0000001);     }      @Test     public void testEpsilon() {       LinearObjectiveFunction f =           new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0);       Collection<LinearConstraint> constraints = new ArrayList<>();       constraints.add(new LinearConstraint(new double[] {  9, 8, 0 }, Relationship.EQ,  17));       constraints.add(new LinearConstraint(new double[] {  0, 7, 8 }, Relationship.LEQ,  7));       constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10));        SimplexSolver solver = new SimplexSolver();       PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                 GoalType.MAXIMIZE, new NonNegativeConstraint(false));       Assert.assertEquals(1.0, solution.getPoint()[0], 0.0);       Assert.assertEquals(1.0, solution.getPoint()[1], 0.0);       Assert.assertEquals(0.0, solution.getPoint()[2], 0.0);       Assert.assertEquals(15.0, solution.getValue(), 0.0);   }      @Test     public void testTrivialModel() {         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MAXIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(0, solution.getValue(), .0000001);     }      @Test     public void testLargeModel() {         double[] objective = new double[] {                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            12, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 12, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 12, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 12, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                            1, 1, 1, 1, 1, 1};          LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 - x12 = 0"));         constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0"));         constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49"));         constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 >= 42"));         constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x26 = 0"));         constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0"));         constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x12 = 0"));         constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0"));         constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 - x40 = 0"));         constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0"));         constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49"));         constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 >= 42"));         constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x54 = 0"));         constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0"));         constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x40 = 0"));         constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0"));         constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 - x68 = 0"));         constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0"));         constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51"));         constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 >= 44"));         constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x82 = 0"));         constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0"));         constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x68 = 0"));         constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0"));         constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 - x96 = 0"));         constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0"));         constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51"));         constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 >= 44"));         constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x110 = 0"));         constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0"));         constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x96 = 0"));         constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0"));         constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 - x124 = 0"));         constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0"));         constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49"));         constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 >= 42"));         constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x138 = 0"));         constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0"));         constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x124 = 0"));         constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0"));         constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 - x152 = 0"));         constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0"));         constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59"));         constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 >= 42"));         constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x166 = 0"));         constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0"));         constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x152 = 0"));         constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0"));         constraints.add(equationFromString(objective.length, "x83 + x82 - x168 = 0"));         constraints.add(equationFromString(objective.length, "x111 + x110 - x169 = 0"));         constraints.add(equationFromString(objective.length, "x170 - x182 = 0"));         constraints.add(equationFromString(objective.length, "x171 - x183 = 0"));         constraints.add(equationFromString(objective.length, "x172 - x184 = 0"));         constraints.add(equationFromString(objective.length, "x173 - x185 = 0"));         constraints.add(equationFromString(objective.length, "x174 - x186 = 0"));         constraints.add(equationFromString(objective.length, "x175 + x176 - x187 = 0"));         constraints.add(equationFromString(objective.length, "x177 - x188 = 0"));         constraints.add(equationFromString(objective.length, "x178 - x189 = 0"));         constraints.add(equationFromString(objective.length, "x179 - x190 = 0"));         constraints.add(equationFromString(objective.length, "x180 - x191 = 0"));         constraints.add(equationFromString(objective.length, "x181 - x192 = 0"));         constraints.add(equationFromString(objective.length, "x170 - x26 = 0"));         constraints.add(equationFromString(objective.length, "x171 - x27 = 0"));         constraints.add(equationFromString(objective.length, "x172 - x54 = 0"));         constraints.add(equationFromString(objective.length, "x173 - x55 = 0"));         constraints.add(equationFromString(objective.length, "x174 - x168 = 0"));         constraints.add(equationFromString(objective.length, "x177 - x169 = 0"));         constraints.add(equationFromString(objective.length, "x178 - x138 = 0"));         constraints.add(equationFromString(objective.length, "x179 - x139 = 0"));         constraints.add(equationFromString(objective.length, "x180 - x166 = 0"));         constraints.add(equationFromString(objective.length, "x181 - x167 = 0"));         constraints.add(equationFromString(objective.length, "x193 - x205 = 0"));         constraints.add(equationFromString(objective.length, "x194 - x206 = 0"));         constraints.add(equationFromString(objective.length, "x195 - x207 = 0"));         constraints.add(equationFromString(objective.length, "x196 - x208 = 0"));         constraints.add(equationFromString(objective.length, "x197 - x209 = 0"));         constraints.add(equationFromString(objective.length, "x198 + x199 - x210 = 0"));         constraints.add(equationFromString(objective.length, "x200 - x211 = 0"));         constraints.add(equationFromString(objective.length, "x201 - x212 = 0"));         constraints.add(equationFromString(objective.length, "x202 - x213 = 0"));         constraints.add(equationFromString(objective.length, "x203 - x214 = 0"));         constraints.add(equationFromString(objective.length, "x204 - x215 = 0"));         constraints.add(equationFromString(objective.length, "x193 - x182 = 0"));         constraints.add(equationFromString(objective.length, "x194 - x183 = 0"));         constraints.add(equationFromString(objective.length, "x195 - x184 = 0"));         constraints.add(equationFromString(objective.length, "x196 - x185 = 0"));         constraints.add(equationFromString(objective.length, "x197 - x186 = 0"));         constraints.add(equationFromString(objective.length, "x198 + x199 - x187 = 0"));         constraints.add(equationFromString(objective.length, "x200 - x188 = 0"));         constraints.add(equationFromString(objective.length, "x201 - x189 = 0"));         constraints.add(equationFromString(objective.length, "x202 - x190 = 0"));         constraints.add(equationFromString(objective.length, "x203 - x191 = 0"));         constraints.add(equationFromString(objective.length, "x204 - x192 = 0"));          SimplexSolver solver = new SimplexSolver();         PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints),                                                   GoalType.MINIMIZE, new NonNegativeConstraint(true));         Assert.assertEquals(7518.0, solution.getValue(), .0000001);     }      @Test     public void testSolutionCallback() {         // re-use the problem from testcase for MATH-288         // it normally requires 5 iterations          LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );          List<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));         constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));         constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));          final SimplexSolver solver = new SimplexSolver();         final SolutionCallback callback = new SolutionCallback();          Assert.assertNull(callback.getSolution());         Assert.assertFalse(callback.isSolutionOptimal());          try {             solver.optimize(new MaxIter(4), f, new LinearConstraintSet(constraints),                             GoalType.MAXIMIZE, new NonNegativeConstraint(true), callback);             Assert.fail("expected TooManyIterationsException");         } catch (TooManyIterationsException ex) {             // expected         }          final PointValuePair solution = callback.getSolution();         Assert.assertNotNull(solution);         Assert.assertTrue(validSolution(solution, constraints, 1e-4));         Assert.assertFalse(callback.isSolutionOptimal());         // the solution is clearly not optimal: optimal = 10.0         Assert.assertEquals(7.0, solution.getValue(), 1e-4);     }      @Test(expected=DimensionMismatchException.class)     public void testDimensionMatch() {         // min 2x1 +15x2 +18x3         // Subject to         //   -x1 +2x2 -6x3  <=-10         //         x2 +2x3  <= 6         //   2x1      +10x3 <= 19         //   -x1  +x2       <= -2         // x1,x2,x3 >= 0          LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 15, 18 }, 0);         Collection<LinearConstraint> constraints = new ArrayList<>();         // this constraint is wrong, the dimension is less than expected one         constraints.add(new LinearConstraint(new double[] { -1, 2 - 6 }, Relationship.LEQ, -10));         constraints.add(new LinearConstraint(new double[] { 0, 1, 2 }, Relationship.LEQ, 6));         constraints.add(new LinearConstraint(new double[] { 2, 0, 10 }, Relationship.LEQ, 19));         constraints.add(new LinearConstraint(new double[] { -1, 1, 0 }, Relationship.LEQ, -2));          SimplexSolver solver = new SimplexSolver();         solver.optimize(f,                         new LinearConstraintSet(constraints),                         new NonNegativeConstraint(true),                         PivotSelectionRule.BLAND);     }      /* linear transformation of constants should produce the same result */     @Test     public void testMath1549() {         final double m = 10;         double scale = 1e-12;         for (int pow = 0; pow < 26; pow++) {             tryMath1549(scale);             scale *= m;         }     }      /* See JIRA issue: MATH-1549 */     private void tryMath1549(double scale) {         final NonNegativeConstraint nnegconstr = new NonNegativeConstraint(true);         final int ulps = 10;         final double cutoff = 1e-10;         final double eps = 1e-6;         final SimplexSolver solver = new SimplexSolver(eps, ulps, cutoff);          final LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1, 1}, 0);         final List<LinearConstraint> constraints = new ArrayList<>();         constraints.add(new LinearConstraint(new double[] {scale * 9000, scale * 1}, Relationship.GEQ, 0));         constraints.add(new LinearConstraint(new double[] {scale * 10000, scale}, Relationship.GEQ, scale * 2000));         constraints.add(new LinearConstraint(new double[] {scale, 0}, Relationship.GEQ, scale * 2));         final LinearConstraintSet constraintSet = new LinearConstraintSet(constraints);         final PointValuePair solution = solver.optimize(f, constraintSet, GoalType.MINIMIZE, nnegconstr);          Assert.assertEquals(2.0, solution.getPoint()[0], eps);     }      /**      * Converts a test string to a {@link LinearConstraint}.      * Ex: x0 + x1 + x2 + x3 - x12 = 0      */     private LinearConstraint equationFromString(int numCoefficients, String s) {         Relationship relationship;         if (s.contains(">=")) {             relationship = Relationship.GEQ;         } else if (s.contains("<=")) {             relationship = Relationship.LEQ;         } else if (s.contains("=")) {             relationship = Relationship.EQ;         } else {             throw new IllegalArgumentException();         }          String[] equationParts = s.split("[>|<]?=");         double rhs = Double.parseDouble(equationParts[1].trim());          double[] lhs = new double[numCoefficients];         String left = equationParts[0].replaceAll(" ?x", "");         String[] coefficients = left.split(" ");         for (String coefficient : coefficients) {             double value = coefficient.charAt(0) == '-' ? -1 : 1;             int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim());             lhs[index] = value;         }         return new LinearConstraint(lhs, relationship, rhs);     }      private static boolean validSolution(PointValuePair solution, List<LinearConstraint> constraints, double epsilon) {         double[] vals = solution.getPoint();         for (LinearConstraint c : constraints) {             double[] coeffs = c.getCoefficients().toArray();             double result = 0.0d;             for (int i = 0; i < vals.length; i++) {                 result += vals[i] * coeffs[i];             }              switch (c.getRelationship()) {             case EQ:                 if (!Precision.equals(result, c.getValue(), epsilon)) {                     return false;                 }                 break;              case GEQ:                 if (Precision.compareTo(result, c.getValue(), epsilon) < 0) {                     return false;                 }                 break;              case LEQ:                 if (Precision.compareTo(result, c.getValue(), epsilon) > 0) {                     return false;                 }                 break;             }         }          return true;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim;  import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert;  public class SimpleValueCheckerTest {     @Test(expected=NotStrictlyPositiveException.class)     public void testIterationCheckPrecondition() {         new SimpleValueChecker(1e-1, 1e-2, 0);     }      @Test     public void testIterationCheck() {         final int max = 10;         final SimpleValueChecker checker = new SimpleValueChecker(1e-1, 1e-2, max);         Assert.assertTrue(checker.converged(max, null, null));         Assert.assertTrue(checker.converged(max + 1, null, null));     }      @Test     public void testIterationCheckDisabled() {         final SimpleValueChecker checker = new SimpleValueChecker(1e-8, 1e-8);          final PointValuePair a = new PointValuePair(new double[] { 1d }, 1d);         final PointValuePair b = new PointValuePair(new double[] { 10d }, 10d);          Assert.assertFalse(checker.converged(-1, a, b));         Assert.assertFalse(checker.converged(0, a, b));         Assert.assertFalse(checker.converged(1000000, a, b));          Assert.assertTrue(checker.converged(-1, a, a));         Assert.assertTrue(checker.converged(-1, b, b));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim;  import org.apache.commons.math4.TestUtils; import org.junit.Assert; import org.junit.Test;  public class PointValuePairTest {     @Test     public void testSerial() {         PointValuePair pv1 = new PointValuePair(new double[] { 1.0, 2.0, 3.0 }, 4.0);         PointValuePair pv2 = (PointValuePair) TestUtils.serializeAndRecover(pv1);         Assert.assertEquals(pv1.getKey().length, pv2.getKey().length);         for (int i = 0; i < pv1.getKey().length; ++i) {             Assert.assertEquals(pv1.getKey()[i], pv2.getKey()[i], 1.0e-15);         }         Assert.assertEquals(pv1.getValue(), pv2.getValue(), 1.0e-15);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.optim.nonlinear.scalar.gradient;  import java.util.ArrayList;  import org.apache.commons.geometry.euclidean.twod.Vector2D; import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunctionGradient;  /**  * Class used in the tests.  */ public class CircleScalar {     private ArrayList<Vector2D> points;      public CircleScalar() {         points  = new ArrayList<>();     }      public void addPoint(double px, double py) {         points.add(Vector2D.of(px, py));     }      public double getRadius(Vector2D center) {         double r = 0;         for (Vector2D point : points) {             r += point.distance(center);         }         return r / points.size();     }      public ObjectiveFunction getObjectiveFunction() {         return new ObjectiveFunction(new MultivariateFunction() {                 @Override                 public double value(double[] params)  {                     Vector2D center = Vector2D.of(params[0], params[1]);                     double radius = getRadius(center);                     double sum = 0;                     for (Vector2D point : points) {                         double di = point.distance(center) - radius;                         sum += di * di;                     }                     return sum;                 }             });     }      public ObjectiveFunctionGradient getObjectiveFunctionGradient() {         return new ObjectiveFunctionGradient(new MultivariateVectorFunction() {                 @Override                 public double[] value(double[] params) {                     Vector2D center = Vector2D.of(params[0], params[1]);                     double radius = getRadius(center);                     // gradient of the sum of squared residuals                     double dJdX = 0;                     double dJdY = 0;                     for (Vector2D pk : points) {                         double dk = pk.distance(center);                         dJdX += (center.getX() - pk.getX()) * (dk - radius) / dk;                         dJdY += (center.getY() - pk.getY()) * (dk - radius) / dk;                     }                     dJdX *= 2;                     dJdY *= 2;                      return new double[] { dJdX, dJdY };                 }             });     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.optim.nonlinear.scalar.gradient;  import org.apache.commons.geometry.euclidean.twod.Vector2D; import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.linear.BlockRealMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimpleBounds; import org.apache.commons.math4.optim.SimpleValueChecker; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunctionGradient; import org.junit.Assert; import org.junit.Test;  /**  * <p>Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a  * href="http://www.netlib.org/minpack/disclaimer">here</a>, for  * convenience, it is reproduced below.</p>  *  * <table style="text-align: center; background-color: #E0E0E0" border="0" width="80%" cellpadding="10" summary="MINPACK redistribution policy">  * <tr><td>  *    Minpack Copyright Notice (1999) University of Chicago.  *    All rights reserved  * </td></tr>  * <tr><td>  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * <ol>  *  <li>Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.</li>  * <li>Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.</li>  * <li>The end-user documentation included with the redistribution, if any,  *     must include the following acknowledgment:  *     <code>This product includes software developed by the University of  *           Chicago, as Operator of Argonne National Laboratory.</code>  *     Alternately, this acknowledgment may appear in the software itself,  *     if and wherever such third-party acknowledgments normally appear.</li>  * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"  *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE  *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND  *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR  *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES  *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE  *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY  *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR  *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF  *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)  *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION  *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL  *     BE CORRECTED.</strong></li>  * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT  *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF  *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,  *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF  *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF  *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER  *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT  *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,  *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE  *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>  * <ol></td></tr>  * </table>  *  * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)  * @author Burton S. Garbow (original fortran minpack tests)  * @author Kenneth E. Hillstrom (original fortran minpack tests)  * @author Jorge J. More (original fortran minpack tests)  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)  */ public class NonLinearConjugateGradientOptimizerTest {     @Test(expected=MathUnsupportedOperationException.class)     public void testBoundsUnsupported() {         LinearProblem problem             = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });         NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         optimizer.optimize(new MaxEval(100),                            problem.getObjectiveFunction(),                            problem.getObjectiveFunctionGradient(),                            GoalType.MINIMIZE,                            new InitialGuess(new double[] { 0 }),                            new SimpleBounds(new double[] { -1 },                                             new double[] { 1 }));     }      @Test     public void testTrivial() {         LinearProblem problem             = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });         NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0 }));         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);         Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testColumnsPermutation() {         LinearProblem problem             = new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                                 new double[] { 4.0, 6.0, 1.0 });          NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0, 0 }));         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);         Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);         Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);      }      @Test     public void testNoDependency() {         LinearProblem problem = new LinearProblem(new double[][] {                 { 2, 0, 0, 0, 0, 0 },                 { 0, 2, 0, 0, 0, 0 },                 { 0, 0, 2, 0, 0, 0 },                 { 0, 0, 0, 2, 0, 0 },                 { 0, 0, 0, 0, 2, 0 },                 { 0, 0, 0, 0, 0, 2 }         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });         NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 }));         for (int i = 0; i < problem.target.length; ++i) {             Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);         }     }      @Test     public void testOneSet() {         LinearProblem problem = new LinearProblem(new double[][] {                 {  1,  0, 0 },                 { -1,  1, 0 },                 {  0, -1, 1 }         }, new double[] { 1, 1, 1});         NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0, 0, 0 }));         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);         Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);         Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);      }      @Test     public void testTwoSets() {         final double epsilon = 1.0e-7;         LinearProblem problem = new LinearProblem(new double[][] {                 {  2,  1,   0,  4,       0, 0 },                 { -4, -2,   3, -7,       0, 0 },                 {  4,  1,  -2,  8,       0, 0 },                 {  0, -3, -12, -1,       0, 0 },                 {  0,  0,   0,  0, epsilon, 1 },                 {  0,  0,   0,  0,       1, 1 }         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});          final Preconditioner preconditioner             = new Preconditioner() {                     @Override                     public double[] precondition(double[] point, double[] r) {                         double[] d = r.clone();                         d[0] /=  72.0;                         d[1] /=  30.0;                         d[2] /= 314.0;                         d[3] /= 260.0;                         d[4] /= 2 * (1 + epsilon * epsilon);                         d[5] /= 4.0;                         return d;                     }                 };          NonLinearConjugateGradientOptimizer optimizer            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                      new SimpleValueChecker(1e-13, 1e-13),                                                      1e-7, 1e-7, 1,                                                      preconditioner);          PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 }));          final double[] result = optimum.getPoint();         final double[] expected = {3, 4, -1, -2, 1 + epsilon, 1 - epsilon};          Assert.assertEquals(expected[0], result[0], 1.0e-7);         Assert.assertEquals(expected[1], result[1], 1.0e-7);         Assert.assertEquals(expected[2], result[2], 1.0e-9);         Assert.assertEquals(expected[3], result[3], 1.0e-8);         Assert.assertEquals(expected[4] + epsilon, result[4], 1.0e-6);         Assert.assertEquals(expected[5] - epsilon, result[5], 1.0e-6);      }      @Test     public void testNonInversible() {         LinearProblem problem = new LinearProblem(new double[][] {                 {  1, 2, -3 },                 {  2, 1,  3 },                 { -3, 0, -9 }         }, new double[] { 1, 1, 1 });         NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0, 0, 0 }));         Assert.assertTrue(optimum.getValue() > 0.5);     }      @Test     public void testIllConditioned() {         LinearProblem problem1 = new LinearProblem(new double[][] {                 { 10.0, 7.0,  8.0,  7.0 },                 {  7.0, 5.0,  6.0,  5.0 },                 {  8.0, 6.0, 10.0,  9.0 },                 {  7.0, 5.0,  9.0, 10.0 }         }, new double[] { 32, 23, 33, 31 });         NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-13, 1e-13),                                                       1e-15, 1e-15, 1);         PointValuePair optimum1             = optimizer.optimize(new MaxEval(200),                                  problem1.getObjectiveFunction(),                                  problem1.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0, 1, 2, 3 }));         Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4);         Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-3);         Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4);         Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-4);          LinearProblem problem2 = new LinearProblem(new double[][] {                 { 10.00, 7.00, 8.10, 7.20 },                 {  7.08, 5.04, 6.00, 5.00 },                 {  8.00, 5.98, 9.89, 9.00 },                 {  6.99, 4.99, 9.00, 9.98 }         }, new double[] { 32, 23, 33, 31 });         PointValuePair optimum2             = optimizer.optimize(new MaxEval(200),                                  problem2.getObjectiveFunction(),                                  problem2.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 0, 1, 2, 3 }));          final double[] result2 = optimum2.getPoint();         final double[] expected2 = {-81, 137, -34, 22};          Assert.assertEquals(expected2[0], result2[0], 2);         Assert.assertEquals(expected2[1], result2[1], 4);         Assert.assertEquals(expected2[2], result2[2], 1);         Assert.assertEquals(expected2[3], result2[3], 1);     }      @Test     public void testMoreEstimatedParametersSimple() {         LinearProblem problem = new LinearProblem(new double[][] {                 { 3.0, 2.0,  0.0, 0.0 },                 { 0.0, 1.0, -1.0, 1.0 },                 { 2.0, 0.0,  1.0, 0.0 }         }, new double[] { 7.0, 3.0, 5.0 });          NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 7, 6, 5, 4 }));         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);      }      @Test     public void testMoreEstimatedParametersUnsorted() {         LinearProblem problem = new LinearProblem(new double[][] {                  { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                  { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                  { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                  { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                  { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });         NonLinearConjugateGradientOptimizer optimizer            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                      new SimpleValueChecker(1e-6, 1e-6),                                                      1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 2, 2, 2, 2, 2, 2 }));         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);     }      @Test     public void testRedundantEquations() {         LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0,  1.0 },                 { 1.0, -1.0 },                 { 1.0,  3.0 }         }, new double[] { 3.0, 1.0, 5.0 });          NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 1, 1 }));         Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);         Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);      }      @Test     public void testInconsistentEquations() {         LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0,  1.0 },                 { 1.0, -1.0 },                 { 1.0,  3.0 }         }, new double[] { 3.0, 1.0, 4.0 });          NonLinearConjugateGradientOptimizer optimizer             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-6, 1e-6),                                                       1e-3, 1e-3, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 1, 1 }));         Assert.assertTrue(optimum.getValue() > 0.1);      }      @Test     public void testCircleFitting() {         CircleScalar problem = new CircleScalar();         problem.addPoint( 30.0,  68.0);         problem.addPoint( 50.0,  -6.0);         problem.addPoint(110.0, -20.0);         problem.addPoint( 35.0,  15.0);         problem.addPoint( 45.0,  97.0);         NonLinearConjugateGradientOptimizer optimizer            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                      new SimpleValueChecker(1e-30, 1e-30),                                                      1e-15, 1e-13, 1);         PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  problem.getObjectiveFunction(),                                  problem.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 98.680, 47.345 }));         Vector2D center = Vector2D.of(optimum.getPointRef()[0], optimum.getPointRef()[1]);         Assert.assertEquals(69.960161753, problem.getRadius(center), 1.0e-8);         Assert.assertEquals(96.075902096, center.getX(), 1.0e-7);         Assert.assertEquals(48.135167894, center.getY(), 1.0e-6);     }      private static class LinearProblem {         final RealMatrix factors;         final double[] target;          public LinearProblem(double[][] factors,                              double[] target) {             this.factors = new BlockRealMatrix(factors);             this.target  = target;         }          public ObjectiveFunction getObjectiveFunction() {             return new ObjectiveFunction(new MultivariateFunction() {                     @Override                     public double value(double[] point) {                         double[] y = factors.operate(point);                         double sum = 0;                         for (int i = 0; i < y.length; ++i) {                             double ri = y[i] - target[i];                             sum += ri * ri;                         }                         return sum;                     }                 });         }          public ObjectiveFunctionGradient getObjectiveFunctionGradient() {             return new ObjectiveFunctionGradient(new MultivariateVectorFunction() {                     @Override                     public double[] value(double[] point) {                         double[] r = factors.operate(point);                         for (int i = 0; i < r.length; ++i) {                             r[i] -= target[i];                         }                         double[] p = factors.transpose().operate(r);                         for (int i = 0; i < p.length; ++i) {                             p[i] *= 2;                         }                         return p;                     }                 });         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.nonlinear.scalar;  import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimplePointChecker; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer; import org.junit.Assert; import org.junit.Test;  public class MultivariateFunctionPenaltyAdapterTest {     @Test     public void testStartSimplexInsideRange() {         final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);         final MultivariateFunctionPenaltyAdapter wrapped               = new MultivariateFunctionPenaltyAdapter(biQuadratic,                                                        biQuadratic.getLower(),                                                        biQuadratic.getUpper(),                                                        1000.0, new double[] { 100.0, 100.0 });          SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(300),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 1.5, 2.25 }));          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);     }      @Test     public void testStartSimplexOutsideRange() {         final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);         final MultivariateFunctionPenaltyAdapter wrapped               = new MultivariateFunctionPenaltyAdapter(biQuadratic,                                                        biQuadratic.getLower(),                                                        biQuadratic.getUpper(),                                                        1000.0, new double[] { 100.0, 100.0 });          SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(300),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { -1.5, 4.0 }));          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);     }      @Test     public void testOptimumOutsideRange() {         final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0);         final MultivariateFunctionPenaltyAdapter wrapped             =  new MultivariateFunctionPenaltyAdapter(biQuadratic,                                                       biQuadratic.getLower(),                                                       biQuadratic.getUpper(),                                                       1000.0, new double[] { 100.0, 100.0 });          SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-11, 1.0e-20));         final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(600),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { -1.5, 4.0 }));          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);     }      @Test     public void testUnbounded() {         final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0,                                                         Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,                                                         Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);         final MultivariateFunctionPenaltyAdapter wrapped             = new MultivariateFunctionPenaltyAdapter(biQuadratic,                                                      biQuadratic.getLower(),                                                      biQuadratic.getUpper(),                                                      1000.0, new double[] { 100.0, 100.0 });          SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(300),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { -1.5, 4.0 }));          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);     }      @Test     public void testHalfBounded() {         final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0,                                                         1.0, Double.POSITIVE_INFINITY,                                                         Double.NEGATIVE_INFINITY, 3.0);         final MultivariateFunctionPenaltyAdapter wrapped               = new MultivariateFunctionPenaltyAdapter(biQuadratic,                                                        biQuadratic.getLower(),                                                        biQuadratic.getUpper(),                                                        1000.0, new double[] { 100.0, 100.0 });          SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-10, 1.0e-20));         final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(400),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { -1.5, 4.0 }));          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);     }      private static class BiQuadratic implements MultivariateFunction {          private final double xOptimum;         private final double yOptimum;          private final double xMin;         private final double xMax;         private final double yMin;         private final double yMax;          public BiQuadratic(final double xOptimum, final double yOptimum,                            final double xMin, final double xMax,                            final double yMin, final double yMax) {             this.xOptimum = xOptimum;             this.yOptimum = yOptimum;             this.xMin     = xMin;             this.xMax     = xMax;             this.yMin     = yMin;             this.yMax     = yMax;         }          @Override         public double value(double[] point) {             // the function should never be called with out of range points             Assert.assertTrue(point[0] >= xMin);             Assert.assertTrue(point[0] <= xMax);             Assert.assertTrue(point[1] >= yMin);             Assert.assertTrue(point[1] <= yMax);              final double dx = point[0] - xOptimum;             final double dy = point[1] - yOptimum;             return dx * dx + dy * dy;          }          public double[] getLower() {             return new double[] { xMin, yMin };         }          public double[] getUpper() {             return new double[] { xMax, yMax };         }          public double getBoundedXOptimum() {             return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum);         }          public double getBoundedYOptimum() {             return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum);         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.optim.nonlinear.scalar.noderiv;   import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimpleBounds; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.math4.optim.nonlinear.scalar.LeastSquaresConverter; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore;  public class SimplexOptimizerNelderMeadTest {     private static final int DIM = 13;      @Test(expected=MathUnsupportedOperationException.class)     public void testBoundsUnsupported() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          optimizer.optimize(new MaxEval(100),                            new ObjectiveFunction(fourExtrema),                            GoalType.MINIMIZE,                            new InitialGuess(new double[] { -3, 0 }),                            new NelderMeadSimplex(new double[] { 0.2, 0.2 }),                            new SimpleBounds(new double[] { -5, -1 },                                             new double[] { 5, 1 }));     }      @Test     public void testMinimize1() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { -3, 0 }),                                  new NelderMeadSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);         Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);         Assert.assertTrue(optimizer.getEvaluations() > 60);         Assert.assertTrue(optimizer.getEvaluations() < 90);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testMinimize2() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 1, 0 }),                                  new NelderMeadSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6);         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6);         Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11);         Assert.assertTrue(optimizer.getEvaluations() > 60);         Assert.assertTrue(optimizer.getEvaluations() < 90);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testMaximize1() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MAXIMIZE,                                  new InitialGuess(new double[] { -3, 0 }),                                  new NelderMeadSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5);         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);         Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12);         Assert.assertTrue(optimizer.getEvaluations() > 60);         Assert.assertTrue(optimizer.getEvaluations() < 90);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testMaximize2() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MAXIMIZE,                                  new InitialGuess(new double[] { 1, 0 }),                                  new NelderMeadSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6);         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6);         Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12);         Assert.assertTrue(optimizer.getEvaluations() > 60);         Assert.assertTrue(optimizer.getEvaluations() < 90);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testRosenbrock() {          OptimTestUtils.Rosenbrock rosenbrock = new OptimTestUtils.Rosenbrock();         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);         PointValuePair optimum         = optimizer.optimize(new MaxEval(100),                              new ObjectiveFunction(rosenbrock),                              GoalType.MINIMIZE,                              new InitialGuess(new double[] { -1.2, 1 }),                                 new NelderMeadSimplex(new double[][] {                                         { -1.2,  1 },                                         { 0.9, 1.2 },                                         {  3.5, -2.3 } }));         Assert.assertTrue(optimizer.getEvaluations() > 40);         Assert.assertTrue(optimizer.getEvaluations() < 50);         Assert.assertTrue(optimum.getValue() < 8e-4);     }      @Test     public void testPowell() {         OptimTestUtils.Powell powell = new OptimTestUtils.Powell();         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);         PointValuePair optimum =             optimizer.optimize(new MaxEval(200),                                new ObjectiveFunction(powell),                                GoalType.MINIMIZE,                                new InitialGuess(new double[] { 3, -1, 0, 1 }),                                new NelderMeadSimplex(4));         Assert.assertTrue(optimizer.getEvaluations() > 110);         Assert.assertTrue(optimizer.getEvaluations() < 130);         Assert.assertTrue(optimum.getValue() < 2e-3);     }      @Test     public void testLeastSquares1() {         final RealMatrix factors             = new Array2DRowRealMatrix(new double[][] {                     { 1, 0 },                     { 0, 1 }                 }, false);         LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() {                 @Override                 public double[] value(double[] variables) {                     return factors.operate(variables);                 }             }, new double[] { 2.0, -3.0 });         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);         PointValuePair optimum =             optimizer.optimize(new MaxEval(200),                                new ObjectiveFunction(ls),                                GoalType.MINIMIZE,                                new InitialGuess(new double[] { 10, 10 }),                                new NelderMeadSimplex(2));         Assert.assertEquals( 2, optimum.getPointRef()[0], 3e-5);         Assert.assertEquals(-3, optimum.getPointRef()[1], 4e-4);         Assert.assertTrue(optimizer.getEvaluations() > 60);         Assert.assertTrue(optimizer.getEvaluations() < 80);         Assert.assertTrue(optimum.getValue() < 1.0e-6);     }      @Test     public void testLeastSquares2() {         final RealMatrix factors             = new Array2DRowRealMatrix(new double[][] {                     { 1, 0 },                     { 0, 1 }                 }, false);         LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() {                 @Override                 public double[] value(double[] variables) {                     return factors.operate(variables);                 }             }, new double[] { 2, -3 }, new double[] { 10, 0.1 });         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);         PointValuePair optimum =             optimizer.optimize(new MaxEval(200),                                new ObjectiveFunction(ls),                                GoalType.MINIMIZE,                                new InitialGuess(new double[] { 10, 10 }),                                new NelderMeadSimplex(2));         Assert.assertEquals( 2, optimum.getPointRef()[0], 5e-5);         Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);         Assert.assertTrue(optimizer.getEvaluations() > 60);         Assert.assertTrue(optimizer.getEvaluations() < 80);         Assert.assertTrue(optimum.getValue() < 1e-6);     }      @Test     public void testLeastSquares3() {         final RealMatrix factors =             new Array2DRowRealMatrix(new double[][] {                     { 1, 0 },                     { 0, 1 }                 }, false);         LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() {                 @Override                 public double[] value(double[] variables) {                     return factors.operate(variables);                 }             }, new double[] { 2, -3 }, new Array2DRowRealMatrix(new double [][] {                     { 1, 1.2 }, { 1.2, 2 }                 }));         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);         PointValuePair optimum             = optimizer.optimize(new MaxEval(200),                                  new ObjectiveFunction(ls),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 10, 10 }),                                  new NelderMeadSimplex(2));         Assert.assertEquals( 2, optimum.getPointRef()[0], 2e-3);         Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);         Assert.assertTrue(optimizer.getEvaluations() > 60);         Assert.assertTrue(optimizer.getEvaluations() < 80);         Assert.assertTrue(optimum.getValue() < 1e-6);     }      @Test(expected=TooManyEvaluationsException.class)     public void testMaxIterations() {         OptimTestUtils.Powell powell = new OptimTestUtils.Powell();         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);         optimizer.optimize(new MaxEval(20),                            new ObjectiveFunction(powell),                            GoalType.MINIMIZE,                            new InitialGuess(new double[] { 3, -1, 0, 1 }),                            new NelderMeadSimplex(4));     }      @Test     public void testRosen() {         doTest(new OptimTestUtils.Rosen(),                OptimTestUtils.point(DIM, 0.1),                GoalType.MINIMIZE,                11975,                new PointValuePair(OptimTestUtils.point(DIM, 1.0), 0.0),                1e-6);     }      @Ignore     @Test     public void testEllipse() {         doTest(new OptimTestUtils.Elli(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                7184,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);      }      @Ignore     @Test     public void testElliRotated() {         doTest(new OptimTestUtils.ElliRotated(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                7467,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);     }      @Test     public void testCigar() {         doTest(new OptimTestUtils.Cigar(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                9160,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-6);     }      @Ignore     @Test     public void testTwoAxes() {         doTest(new OptimTestUtils.TwoAxes(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                3451,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);      }      @Ignore     @Test     public void testCigTab() {         doTest(new OptimTestUtils.CigTab(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                7454,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);      }      @Ignore     @Test     public void testSphere() {         doTest(new OptimTestUtils.Sphere(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                3881,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-6);     }      @Ignore     @Test     public void testTablet() {         doTest(new OptimTestUtils.Tablet(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                6639,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);     }      @Ignore     @Test     public void testDiffPow() {         doTest(new OptimTestUtils.DiffPow(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                4105,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);     }      @Ignore     @Test     public void testSsDiffPow() {         doTest(new OptimTestUtils.SsDiffPow(),                OptimTestUtils.point(DIM / 2, 1.0),                GoalType.MINIMIZE,                3990,                new PointValuePair(OptimTestUtils.point(DIM / 2, 0.0), 0.0),                1e-15);     }      @Ignore     @Test     public void testAckley() {         doTest(new OptimTestUtils.Ackley(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                2849,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                0);     }      @Ignore     @Test     public void testRastrigin() {         doTest(new OptimTestUtils.Rastrigin(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                2166,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                0);     }      /**      * @param func Function to optimize.      * @param startPoint Starting point.      * @param goal Minimization or maximization.      * @param maxEvaluations Maximum number of evaluations.      * @param expected Expected optimum.      * @param tol Tolerance for checking that the optimum is correct.      */     private void doTest(MultivariateFunction func,                         double[] startPoint,                         GoalType goal,                         int maxEvaluations,                         PointValuePair expected,                         double tol) {         final int dim = startPoint.length;         final SimplexOptimizer optim = new SimplexOptimizer(1e-13, 1e-14);         final PointValuePair result = optim.optimize(new MaxEval(maxEvaluations),                                                      new ObjectiveFunction(func),                                                      goal,                                                      new InitialGuess(startPoint),                                                      new NelderMeadSimplex(dim, 0.1));         final double dist = MathArrays.distance(expected.getPoint(),                                                 result.getPoint());         Assert.assertEquals(0d, dist, tol);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.nonlinear.scalar.noderiv;  import java.util.Arrays; import java.util.Random; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.util.FastMath;  /**  * Utilities for testing the optimizers.  */ class OptimTestUtils {      static class Sphere implements MultivariateFunction {          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += x[i] * x[i];             }             return f;         }     }      static class Cigar implements MultivariateFunction {         private double factor;          Cigar() {             this(1e3);         }          Cigar(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = x[0] * x[0];             for (int i = 1; i < x.length; ++i) {                 f += factor * x[i] * x[i];             }             return f;         }     }      static class Tablet implements MultivariateFunction {         private double factor;          Tablet() {             this(1e3);         }          Tablet(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = factor * x[0] * x[0];             for (int i = 1; i < x.length; ++i) {                 f += x[i] * x[i];             }             return f;         }     }      static class CigTab implements MultivariateFunction {         private double factor;          CigTab() {             this(1e4);         }          CigTab(double axisratio) {             factor = axisratio;         }          @Override         public double value(double[] x) {             int end = x.length - 1;             double f = x[0] * x[0] / factor + factor * x[end] * x[end];             for (int i = 1; i < end; ++i) {                 f += x[i] * x[i];             }             return f;         }     }      static class TwoAxes implements MultivariateFunction {          private double factor;          TwoAxes() {             this(1e6);         }          TwoAxes(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += (i < x.length / 2 ? factor : 1) * x[i] * x[i];             }             return f;         }     }      static class ElliRotated implements MultivariateFunction {         private Basis B = new Basis();         private double factor;          ElliRotated() {             this(1e3);         }          ElliRotated(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = 0;             x = B.Rotate(x);             for (int i = 0; i < x.length; ++i) {                 f += FastMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];             }             return f;         }     }      static class Elli implements MultivariateFunction {          private double factor;          Elli() {             this(1e3);         }          Elli(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += FastMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];             }             return f;         }     }      static class MinusElli implements MultivariateFunction {         private final Elli elli = new Elli();         @Override         public double value(double[] x) {             return 1.0 - elli.value(x);         }     }      static class DiffPow implements MultivariateFunction {         @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += FastMath.pow(FastMath.abs(x[i]), 2. + 10 * (double) i                         / (x.length - 1.));             }             return f;         }     }      static class SsDiffPow implements MultivariateFunction {          @Override         public double value(double[] x) {             double f = FastMath.pow(new DiffPow().value(x), 0.25);             return f;         }     }       static class Rosen implements MultivariateFunction {         @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length - 1; i++) {                 final double a = x[i] * x[i] - x[i + 1];                 final double b = x[i] - 1;                 f += 1e2 * a * a + b * b;             }             return f;         }     }       static class Ackley implements MultivariateFunction {         private double axisratio;                   Ackley(double axra) {             axisratio = axra;         }                   public Ackley() {             this(1);         }                   @Override         public double value(double[] x) {             double f = 0;             double res2 = 0;             double fac = 0;             for (int i = 0; i < x.length; ++i) {                 fac = FastMath.pow(axisratio, (i - 1.) / (x.length - 1.));                 f += fac * fac * x[i] * x[i];                 res2 += FastMath.cos(2. * FastMath.PI * fac * x[i]);             }             f = (20. - 20. * FastMath.exp(-0.2 * FastMath.sqrt(f / x.length))                  + FastMath.exp(1.) - FastMath.exp(res2 / x.length));             return f;         }     }      static class Rastrigin implements MultivariateFunction {          private double axisratio;         private double amplitude;          Rastrigin() {             this(1, 10);         }               Rastrigin(double axisratio, double amplitude) {             this.axisratio = axisratio;             this.amplitude = amplitude;         }               @Override         public double value(double[] x) {             double f = 0;             double fac;             for (int i = 0; i < x.length; ++i) {                 fac = FastMath.pow(axisratio, (i - 1.) / (x.length - 1.));                 if (i == 0 && x[i] < 0) {                     fac *= 1.;                 }                 f += fac * fac * x[i] * x[i] + amplitude                     * (1. - FastMath.cos(2. * FastMath.PI * fac * x[i]));             }             return f;         }     }      static class FourExtrema implements MultivariateFunction {         // The following function has 4 local extrema.         static final double xM = -3.841947088256863675365;         static final double yM = -1.391745200270734924416;         static final double xP =  0.2286682237349059125691;         static final double yP = -yM;         static final double valueXmYm = 0.2373295333134216789769; // Local maximum.         static final double valueXmYp = -valueXmYm; // Local minimum.         static final double valueXpYm = -0.7290400707055187115322; // Global minimum.         static final double valueXpYp = -valueXpYm; // Global maximum.          @Override         public double value(double[] variables) {             final double x = variables[0];             final double y = variables[1];             return (x == 0 || y == 0) ? 0 :                 FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y);         }     }      static class Rosenbrock implements MultivariateFunction {         @Override         public double value(double[] x) {             double a = x[1] - x[0] * x[0];             double b = 1.0 - x[0];             return 100 * a * a + b * b;         }     }      static class Powell implements MultivariateFunction {         @Override         public double value(double[] x) {             double a = x[0] + 10 * x[1];             double b = x[2] - x[3];             double c = x[1] - 2 * x[2];             double d = x[0] - x[3];             return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;         }     }      static class Gaussian2D implements MultivariateFunction {         private final double[] maximumPosition;         private final double std;          public Gaussian2D(double xOpt, double yOpt, double std) {             maximumPosition = new double[] { xOpt, yOpt };             this.std = std;         }          public double getMaximum() {             return value(maximumPosition);         }          public double[] getMaximumPosition() {             return maximumPosition.clone();         }          @Override         public double value(double[] point) {             final double x = point[0], y = point[1];             final double twoS2 = 2.0 * std * std;             return 1.0 / (twoS2 * FastMath.PI) * FastMath.exp(-(x * x + y * y) / twoS2);         }     }      static double[] point(int n, double value) {         double[] ds = new double[n];         Arrays.fill(ds, value);         return ds;     }      /** Creates a RNG instance. */     static UniformRandomProvider rng() {         return RandomSource.create(RandomSource.MWC_256);     }      private static class Basis {         double[][] basis;         final Random rand = new Random(2); // use not always the same basis          double[] Rotate(double[] x) {             GenBasis(x.length);             double[] y = new double[x.length];             for (int i = 0; i < x.length; ++i) {                 y[i] = 0;                 for (int j = 0; j < x.length; ++j) {                     y[i] += basis[i][j] * x[j];                 }             }             return y;         }          void GenBasis(int DIM) {             if (basis != null ? basis.length == DIM : false) {                 return;             }              double sp;             int i, j, k;              /* generate orthogonal basis */             basis = new double[DIM][DIM];             for (i = 0; i < DIM; ++i) {                 /* sample components gaussian */                 for (j = 0; j < DIM; ++j) {                     basis[i][j] = rand.nextGaussian();                 }                 /* substract projection of previous vectors */                 for (j = i - 1; j >= 0; --j) {                     for (sp = 0., k = 0; k < DIM; ++k) {                         sp += basis[i][k] * basis[j][k]; /* scalar product */                     }                     for (k = 0; k < DIM; ++k) {                         basis[i][k] -= sp * basis[j][k]; /* substract */                     }                 }                 /* normalize */                 for (sp = 0., k = 0; k < DIM; ++k) {                     sp += basis[i][k] * basis[i][k]; /* squared norm */                 }                 for (k = 0; k < DIM; ++k) {                     basis[i][k] /= FastMath.sqrt(sp);                 }             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.nonlinear.scalar.noderiv;  import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.analysis.SumSincFunction; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimpleBounds; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link PowellOptimizer}.  */ public class PowellOptimizerTest {     @Test(expected=MathUnsupportedOperationException.class)     public void testBoundsUnsupported() {         final MultivariateFunction func = new SumSincFunction(-1);         final PowellOptimizer optim = new PowellOptimizer(1e-8, 1e-5,                                                           1e-4, 1e-4);          optim.optimize(new MaxEval(100),                        new ObjectiveFunction(func),                        GoalType.MINIMIZE,                        new InitialGuess(new double[] { -3, 0 }),                        new SimpleBounds(new double[] { -5, -1 },                                         new double[] { 5, 1 }));     }      @Test     public void testSumSinc() {         final MultivariateFunction func = new SumSincFunction(-1);          int dim = 2;         final double[] minPoint = new double[dim];         for (int i = 0; i < dim; i++) {             minPoint[i] = 0;         }          double[] init = new double[dim];          // Initial is minimum.         for (int i = 0; i < dim; i++) {             init[i] = minPoint[i];         }         doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9);          // Initial is far from minimum.         for (int i = 0; i < dim; i++) {             init[i] = minPoint[i] + 3;         }         doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5);         // More stringent line search tolerance enhances the precision         // of the result.         doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7);     }      @Test     public void testQuadratic() {         final MultivariateFunction func = new MultivariateFunction() {                 @Override                 public double value(double[] x) {                     final double a = x[0] - 1;                     final double b = x[1] - 1;                     return a * a + b * b + 1;                 }             };          int dim = 2;         final double[] minPoint = new double[dim];         for (int i = 0; i < dim; i++) {             minPoint[i] = 1;         }          double[] init = new double[dim];          // Initial is minimum.         for (int i = 0; i < dim; i++) {             init[i] = minPoint[i];         }         doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);          // Initial is far from minimum.         for (int i = 0; i < dim; i++) {             init[i] = minPoint[i] - 20;         }         doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);     }      @Test     public void testMaximizeQuadratic() {         final MultivariateFunction func = new MultivariateFunction() {                 @Override                 public double value(double[] x) {                     final double a = x[0] - 1;                     final double b = x[1] - 1;                     return -a * a - b * b + 1;                 }             };          int dim = 2;         final double[] maxPoint = new double[dim];         for (int i = 0; i < dim; i++) {             maxPoint[i] = 1;         }          double[] init = new double[dim];          // Initial is minimum.         for (int i = 0; i < dim; i++) {             init[i] = maxPoint[i];         }         doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-9, 1e-8);          // Initial is far from minimum.         for (int i = 0; i < dim; i++) {             init[i] = maxPoint[i] - 20;         }         doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);     }      /**      * Ensure that we do not increase the number of function evaluations when      * the function values are scaled up.      * Note that the tolerances parameters passed to the constructor must      * still hold sensible values because they are used to set the line search      * tolerances.      */     @Test     public void testRelativeToleranceOnScaledValues() {         final MultivariateFunction func = new MultivariateFunction() {                 @Override                 public double value(double[] x) {                     final double a = x[0] - 1;                     final double b = x[1] - 1;                     return a * a * FastMath.sqrt(FastMath.abs(a)) + b * b + 1;                 }             };          int dim = 2;         final double[] minPoint = new double[dim];         for (int i = 0; i < dim; i++) {             minPoint[i] = 1;         }          double[] init = new double[dim];         // Initial is far from minimum.         for (int i = 0; i < dim; i++) {             init[i] = minPoint[i] - 20;         }          final double relTol = 1e-10;          final int maxEval = 1000;         // Very small absolute tolerance to rely solely on the relative         // tolerance as a stopping criterion         final PowellOptimizer optim = new PowellOptimizer(relTol, 1e-100);          final PointValuePair funcResult = optim.optimize(new MaxEval(maxEval),                                                          new ObjectiveFunction(func),                                                          GoalType.MINIMIZE,                                                          new InitialGuess(init));         final double funcValue = func.value(funcResult.getPoint());         final int funcEvaluations = optim.getEvaluations();          final double scale = 1e10;         final MultivariateFunction funcScaled = new MultivariateFunction() {                 @Override                 public double value(double[] x) {                     return scale * func.value(x);                 }             };          final PointValuePair funcScaledResult = optim.optimize(new MaxEval(maxEval),                                                                new ObjectiveFunction(funcScaled),                                                                GoalType.MINIMIZE,                                                                new InitialGuess(init));         final double funcScaledValue = funcScaled.value(funcScaledResult.getPoint());         final int funcScaledEvaluations = optim.getEvaluations();          // Check that both minima provide the same objective funciton values,         // within the relative function tolerance.         Assert.assertEquals(1, funcScaledValue / (scale * funcValue), relTol);          // Check that the numbers of evaluations are the same.         Assert.assertEquals(funcEvaluations, funcScaledEvaluations);     }      /**      * @param func Function to optimize.      * @param optimum Expected optimum.      * @param init Starting point.      * @param goal Minimization or maximization.      * @param fTol Tolerance (relative error on the objective function) for      * "Powell" algorithm.      * @param pointTol Tolerance for checking that the optimum is correct.      */     private void doTest(MultivariateFunction func,                         double[] optimum,                         double[] init,                         GoalType goal,                         double fTol,                         double pointTol) {         final PowellOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));          final PointValuePair result = optim.optimize(new MaxEval(1000),                                                      new ObjectiveFunction(func),                                                      goal,                                                      new InitialGuess(init));         final double[] point = result.getPoint();          for (int i = 0, dim = optimum.length; i < dim; i++) {             Assert.assertEquals("found[" + i + "]=" + point[i] + " value=" + result.getValue(),                                 optimum[i], point[i], pointTol);         }     }      /**      * @param func Function to optimize.      * @param optimum Expected optimum.      * @param init Starting point.      * @param goal Minimization or maximization.      * @param fTol Tolerance (relative error on the objective function) for      * "Powell" algorithm.      * @param fLineTol Tolerance (relative error on the objective function)      * for the internal line search algorithm.      * @param pointTol Tolerance for checking that the optimum is correct.      */     private void doTest(MultivariateFunction func,                         double[] optimum,                         double[] init,                         GoalType goal,                         double fTol,                         double fLineTol,                         double pointTol) {         final PowellOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d),                                                           fLineTol, Math.ulp(1d));          final PointValuePair result = optim.optimize(new MaxEval(1000),                                                      new ObjectiveFunction(func),                                                      goal,                                                      new InitialGuess(init));         final double[] point = result.getPoint();          for (int i = 0, dim = optimum.length; i < dim; i++) {             Assert.assertEquals("found[" + i + "]=" + point[i] + " value=" + result.getValue(),                                 optimum[i], point[i], pointTol);         }          Assert.assertTrue(optim.getIterations() > 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.nonlinear.scalar.noderiv;  import java.util.Arrays; import java.util.Random;  import org.apache.commons.math4.Retry; import org.apache.commons.math4.RetryRunner; import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimpleBounds; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith;  /**  * Test for {@link CMAESOptimizer}.  */ @RunWith(RetryRunner.class) public class CMAESOptimizerTest {      static final int DIM = 13;     static final int LAMBDA = 4 + (int)(3.*FastMath.log(DIM));      @Test(expected = NumberIsTooLargeException.class)     public void testInitOutofbounds1() {         double[] startPoint = point(DIM,3);         double[] insigma = point(DIM, 0.3);         double[][] boundaries = boundaries(DIM,-1,2);         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }     @Test(expected = NumberIsTooSmallException.class)     public void testInitOutofbounds2() {         double[] startPoint = point(DIM, -2);         double[] insigma = point(DIM, 0.3);         double[][] boundaries = boundaries(DIM,-1,2);         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test(expected = DimensionMismatchException.class)     public void testBoundariesDimensionMismatch() {         double[] startPoint = point(DIM,0.5);         double[] insigma = point(DIM, 0.3);         double[][] boundaries = boundaries(DIM+1,-1,2);         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test(expected = NotPositiveException.class)     public void testInputSigmaNegative() {         double[] startPoint = point(DIM,0.5);         double[] insigma = point(DIM,-0.5);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test(expected = OutOfRangeException.class)     public void testInputSigmaOutOfRange() {         double[] startPoint = point(DIM,0.5);         double[] insigma = point(DIM, 1.1);         double[][] boundaries = boundaries(DIM,-0.5,0.5);         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test(expected = DimensionMismatchException.class)     public void testInputSigmaDimensionMismatch() {         double[] startPoint = point(DIM,0.5);         double[] insigma = point(DIM + 1, 0.5);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     @Retry(3)     public void testRosen() {         double[] startPoint = point(DIM,0.1);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     @Retry(3)     public void testMaximize() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),1.0);         doTest(new MinusElli(), startPoint, insigma, boundaries,                 GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,                 2e-10, 5e-6, 100000, expected);         doTest(new MinusElli(), startPoint, insigma, boundaries,                 GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13,                 2e-10, 5e-6, 100000, expected);         boundaries = boundaries(DIM,-0.3,0.3);         startPoint = point(DIM,0.1);         doTest(new MinusElli(), startPoint, insigma, boundaries,                 GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,                 2e-10, 5e-6, 100000, expected);     }      @Test     public void testMath1466() {         final CMAESOptimizer optimizer             = new CMAESOptimizer(30000, Double.NEGATIVE_INFINITY, true, 10,                                  0, RandomSource.create(RandomSource.MT_64), false, null);         final MultivariateFunction fitnessFunction = new MultivariateFunction() {                 @Override                 public double value(double[] x) {                     return x[0] * x[0] - 100;                 }             };          final double[] start = { 100 };         final double[] sigma = { 1e-1 };         final double[] result = optimizer.optimize(new MaxEval(10000),                                                    new ObjectiveFunction(fitnessFunction),                                                    SimpleBounds.unbounded(1),                                                    GoalType.MINIMIZE,                                                    new CMAESOptimizer.PopulationSize(5),                                                    new CMAESOptimizer.Sigma(sigma),                                                    new InitialGuess(start)).getPoint();         Assert.assertEquals(0, result[0], 1e-7);     }      @Test     public void testEllipse() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new Elli(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);         doTest(new Elli(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     public void testElliRotated() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new ElliRotated(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);         doTest(new ElliRotated(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     public void testCigar() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new Cigar(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 200000, expected);         doTest(new Cigar(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     public void testCigarWithBoundaries() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new Cigar(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 200000, expected);         doTest(new Cigar(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     public void testTwoAxes() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new TwoAxes(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 200000, expected);         doTest(new TwoAxes(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,                 1e-8, 1e-3, 200000, expected);     }      @Test     public void testCigTab() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.3);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new CigTab(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 5e-5, 100000, expected);         doTest(new CigTab(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 5e-5, 100000, expected);     }      @Test     public void testSphere() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new Sphere(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);         doTest(new Sphere(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     public void testTablet() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new Tablet(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);         doTest(new Tablet(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     public void testDiffPow() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new DiffPow(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 10, true, 0, 1e-13,                 1e-8, 1e-1, 100000, expected);         doTest(new DiffPow(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 10, false, 0, 1e-13,                 1e-8, 2e-1, 100000, expected);     }      @Test     public void testSsDiffPow() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new SsDiffPow(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 10, true, 0, 1e-13,                 1e-4, 1e-1, 200000, expected);         doTest(new SsDiffPow(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 10, false, 0, 1e-13,                 1e-4, 1e-1, 200000, expected);     }      @Test     public void testAckley() {         double[] startPoint = point(DIM,1.0);         double[] insigma = point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new Ackley(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,                 1e-9, 1e-5, 100000, expected);         doTest(new Ackley(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,                 1e-9, 1e-5, 100000, expected);     }      @Test     public void testRastrigin() {         double[] startPoint = point(DIM,0.1);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,0.0),0.0);         doTest(new Rastrigin(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, (int)(200*FastMath.sqrt(DIM)), true, 0, 1e-13,                 1e-13, 1e-6, 200000, expected);         doTest(new Rastrigin(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, (int)(200*FastMath.sqrt(DIM)), false, 0, 1e-13,                 1e-13, 1e-6, 200000, expected);     }      @Test     public void testConstrainedRosen() {         double[] startPoint = point(DIM, 0.1);         double[] insigma = point(DIM, 0.1);         double[][] boundaries = boundaries(DIM, -1, 2);         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,                 1e-13, 1e-6, 100000, expected);     }      @Test     public void testDiagonalRosen() {         double[] startPoint = point(DIM,0.1);         double[] insigma = point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(point(DIM,1.0),0.0);         doTest(new Rosen(), startPoint, insigma, boundaries,                 GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,                 1e-10, 1e-4, 1000000, expected);      }      @Test     public void testMath864() {         final CMAESOptimizer optimizer             = new CMAESOptimizer(30000, 0, true, 10,                                  0, RandomSource.create(RandomSource.MT_64), false, null);         final MultivariateFunction fitnessFunction = new MultivariateFunction() {                 @Override                 public double value(double[] parameters) {                     final double target = 1;                     final double error = target - parameters[0];                     return error * error;                 }             };          final double[] start = { 0 };         final double[] lower = { -1e6 };         final double[] upper = { 1.5 };         final double[] sigma = { 1e-1 };         final double[] result = optimizer.optimize(new MaxEval(10000),                                                    new ObjectiveFunction(fitnessFunction),                                                    GoalType.MINIMIZE,                                                    new CMAESOptimizer.PopulationSize(5),                                                    new CMAESOptimizer.Sigma(sigma),                                                    new InitialGuess(start),                                                    new SimpleBounds(lower, upper)).getPoint();         Assert.assertTrue("Out of bounds (" + result[0] + " > " + upper[0] + ")",                           result[0] <= upper[0]);     }      /**      * Cf. MATH-867      */     @Test     public void testFitAccuracyDependsOnBoundary() {         final CMAESOptimizer optimizer             = new CMAESOptimizer(30000, 0, true, 10,                                  0, RandomSource.create(RandomSource.MT_64), false, null);         final MultivariateFunction fitnessFunction = new MultivariateFunction() {                 @Override                 public double value(double[] parameters) {                     final double target = 11.1;                     final double error = target - parameters[0];                     return error * error;                 }             };          final double[] start = { 1 };          // No bounds.         PointValuePair result = optimizer.optimize(new MaxEval(100000),                                                    new ObjectiveFunction(fitnessFunction),                                                    GoalType.MINIMIZE,                                                    SimpleBounds.unbounded(1),                                                    new CMAESOptimizer.PopulationSize(5),                                                    new CMAESOptimizer.Sigma(new double[] { 1e-1 }),                                                    new InitialGuess(start));         final double resNoBound = result.getPoint()[0];          // Optimum is near the lower bound.         final double[] lower = { -20 };         final double[] upper = { 5e16 };         final double[] sigma = { 10 };         result = optimizer.optimize(new MaxEval(100000),                                     new ObjectiveFunction(fitnessFunction),                                     GoalType.MINIMIZE,                                     new CMAESOptimizer.PopulationSize(5),                                     new CMAESOptimizer.Sigma(sigma),                                     new InitialGuess(start),                                     new SimpleBounds(lower, upper));         final double resNearLo = result.getPoint()[0];          // Optimum is near the upper bound.         lower[0] = -5e16;         upper[0] = 20;         result = optimizer.optimize(new MaxEval(100000),                                     new ObjectiveFunction(fitnessFunction),                                     GoalType.MINIMIZE,                                     new CMAESOptimizer.PopulationSize(5),                                     new CMAESOptimizer.Sigma(sigma),                                     new InitialGuess(start),                                     new SimpleBounds(lower, upper));         final double resNearHi = result.getPoint()[0];          // System.out.println("resNoBound=" + resNoBound +         //                    " resNearLo=" + resNearLo +         //                    " resNearHi=" + resNearHi);          // The two values currently differ by a substantial amount, indicating that         // the bounds definition can prevent reaching the optimum.         Assert.assertEquals(resNoBound, resNearLo, 1e-3);         Assert.assertEquals(resNoBound, resNearHi, 1e-3);     }      /**      * @param func Function to optimize.      * @param startPoint Starting point.      * @param inSigma Individual input sigma.      * @param boundaries Upper / lower point limit.      * @param goal Minimization or maximization.      * @param lambda Population size used for offspring.      * @param isActive Covariance update mechanism.      * @param diagonalOnly Simplified covariance update.      * @param stopValue Termination criteria for optimization.      * @param fTol Tolerance relative error on the objective function.      * @param pointTol Tolerance for checking that the optimum is correct.      * @param maxEvaluations Maximum number of evaluations.      * @param expected Expected point / value.      */     private void doTest(MultivariateFunction func,                         double[] startPoint,                         double[] inSigma,                         double[][] boundaries,                         GoalType goal,                         int lambda,                         boolean isActive,                         int diagonalOnly,                         double stopValue,                         double fTol,                         double pointTol,                         int maxEvaluations,                         PointValuePair expected) {         int dim = startPoint.length;         // test diagonalOnly = 0 - slow but normally fewer feval#         CMAESOptimizer optim = new CMAESOptimizer(30000, stopValue, isActive, diagonalOnly,                                                   0, RandomSource.create(RandomSource.MT_64), false, null);         PointValuePair result = boundaries == null ?             optim.optimize(new MaxEval(maxEvaluations),                            new ObjectiveFunction(func),                            goal,                            new InitialGuess(startPoint),                            SimpleBounds.unbounded(dim),                            new CMAESOptimizer.Sigma(inSigma),                            new CMAESOptimizer.PopulationSize(lambda)) :             optim.optimize(new MaxEval(maxEvaluations),                            new ObjectiveFunction(func),                            goal,                            new SimpleBounds(boundaries[0],                                             boundaries[1]),                            new InitialGuess(startPoint),                            new CMAESOptimizer.Sigma(inSigma),                            new CMAESOptimizer.PopulationSize(lambda));          // System.out.println("sol=" + Arrays.toString(result.getPoint()));         Assert.assertEquals(expected.getValue(), result.getValue(), fTol);         for (int i = 0; i < dim; i++) {             Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol);         }          Assert.assertTrue(optim.getIterations() > 0);     }      private static double[] point(int n, double value) {         double[] ds = new double[n];         Arrays.fill(ds, value);         return ds;     }      private static double[][] boundaries(int dim,             double lower, double upper) {         double[][] boundaries = new double[2][dim];         for (int i = 0; i < dim; i++) {             boundaries[0][i] = lower;         }         for (int i = 0; i < dim; i++) {             boundaries[1][i] = upper;         }         return boundaries;     }      private static class Sphere implements MultivariateFunction {          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += x[i] * x[i];             }             return f;         }     }      private static class Cigar implements MultivariateFunction {         private double factor;          Cigar() {             this(1e3);         }          Cigar(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = x[0] * x[0];             for (int i = 1; i < x.length; ++i) {                 f += factor * x[i] * x[i];             }             return f;         }     }      private static class Tablet implements MultivariateFunction {         private double factor;          Tablet() {             this(1e3);         }          Tablet(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = factor * x[0] * x[0];             for (int i = 1; i < x.length; ++i) {                 f += x[i] * x[i];             }             return f;         }     }      private static class CigTab implements MultivariateFunction {         private double factor;          CigTab() {             this(1e4);         }          CigTab(double axisratio) {             factor = axisratio;         }          @Override         public double value(double[] x) {             int end = x.length - 1;             double f = x[0] * x[0] / factor + factor * x[end] * x[end];             for (int i = 1; i < end; ++i) {                 f += x[i] * x[i];             }             return f;         }     }      private static class TwoAxes implements MultivariateFunction {          private double factor;          TwoAxes() {             this(1e6);         }          TwoAxes(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += (i < x.length / 2 ? factor : 1) * x[i] * x[i];             }             return f;         }     }      private static class ElliRotated implements MultivariateFunction {         private Basis B = new Basis();         private double factor;          ElliRotated() {             this(1e3);         }          ElliRotated(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = 0;             x = B.Rotate(x);             for (int i = 0; i < x.length; ++i) {                 f += FastMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];             }             return f;         }     }      private static class Elli implements MultivariateFunction {          private double factor;          Elli() {             this(1e3);         }          Elli(double axisratio) {             factor = axisratio * axisratio;         }          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += FastMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];             }             return f;         }     }      private static class MinusElli implements MultivariateFunction {          @Override         public double value(double[] x) {             return 1.0-(new Elli().value(x));         }     }      private static class DiffPow implements MultivariateFunction {          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length; ++i) {                 f += FastMath.pow(FastMath.abs(x[i]), 2. + 10 * (double) i                         / (x.length - 1.));             }             return f;         }     }      private static class SsDiffPow implements MultivariateFunction {          @Override         public double value(double[] x) {             double f = FastMath.pow(new DiffPow().value(x), 0.25);             return f;         }     }      private static class Rosen implements MultivariateFunction {          @Override         public double value(double[] x) {             double f = 0;             for (int i = 0; i < x.length - 1; ++i) {                 f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1])                 + (x[i] - 1.) * (x[i] - 1.);             }             return f;         }     }      private static class Ackley implements MultivariateFunction {         private double axisratio;          Ackley(double axra) {             axisratio = axra;         }          public Ackley() {             this(1);         }          @Override         public double value(double[] x) {             double f = 0;             double res2 = 0;             double fac = 0;             for (int i = 0; i < x.length; ++i) {                 fac = FastMath.pow(axisratio, (i - 1.) / (x.length - 1.));                 f += fac * fac * x[i] * x[i];                 res2 += FastMath.cos(2. * FastMath.PI * fac * x[i]);             }             f = (20. - 20. * FastMath.exp(-0.2 * FastMath.sqrt(f / x.length))                     + FastMath.exp(1.) - FastMath.exp(res2 / x.length));             return f;         }     }      private static class Rastrigin implements MultivariateFunction {          private double axisratio;         private double amplitude;          Rastrigin() {             this(1, 10);         }          Rastrigin(double axisratio, double amplitude) {             this.axisratio = axisratio;             this.amplitude = amplitude;         }          @Override         public double value(double[] x) {             double f = 0;             double fac;             for (int i = 0; i < x.length; ++i) {                 fac = FastMath.pow(axisratio, (i - 1.) / (x.length - 1.));                 if (i == 0 && x[i] < 0) {                     fac *= 1.;                 }                 f += fac * fac * x[i] * x[i] + amplitude                 * (1. - FastMath.cos(2. * FastMath.PI * fac * x[i]));             }             return f;         }     }      private static class Basis {         double[][] basis;         Random rand = new Random(2); // use not always the same basis          double[] Rotate(double[] x) {             GenBasis(x.length);             double[] y = new double[x.length];             for (int i = 0; i < x.length; ++i) {                 y[i] = 0;                 for (int j = 0; j < x.length; ++j) {                     y[i] += basis[i][j] * x[j];                 }             }             return y;         }          void GenBasis(int DIM) {             if (basis != null ? basis.length == DIM : false) {                 return;             }              double sp;             int i, j, k;              /* generate orthogonal basis */             basis = new double[DIM][DIM];             for (i = 0; i < DIM; ++i) {                 /* sample components gaussian */                 for (j = 0; j < DIM; ++j) {                     basis[i][j] = rand.nextGaussian();                 }                 /* substract projection of previous vectors */                 for (j = i - 1; j >= 0; --j) {                     for (sp = 0., k = 0; k < DIM; ++k) {                         sp += basis[i][k] * basis[j][k]; /* scalar product */                     }                     for (k = 0; k < DIM; ++k) {                         basis[i][k] -= sp * basis[j][k]; /* substract */                     }                 }                 /* normalize */                 for (sp = 0., k = 0; k < DIM; ++k) {                     sp += basis[i][k] * basis[i][k]; /* squared norm */                 }                 for (k = 0; k < DIM; ++k) {                     basis[i][k] /= FastMath.sqrt(sp);                 }             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.optim.nonlinear.scalar.noderiv;  import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimpleBounds; import org.apache.commons.math4.optim.SimpleValueChecker; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore;  public class SimplexOptimizerMultiDirectionalTest {     private static final int DIM = 13;      @Test(expected=MathUnsupportedOperationException.class)     public void testBoundsUnsupported() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          optimizer.optimize(new MaxEval(100),                            new ObjectiveFunction(fourExtrema),                            GoalType.MINIMIZE,                            new InitialGuess(new double[] { -3, 0 }),                            new NelderMeadSimplex(new double[] { 0.2, 0.2 }),                            new SimpleBounds(new double[] { -5, -1 },                                             new double[] { 5, 1 }));     }      @Test     public void testMinimize1() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(200),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { -3, 0 }),                                  new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6);         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);         Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13);         Assert.assertTrue(optimizer.getEvaluations() > 120);         Assert.assertTrue(optimizer.getEvaluations() < 150);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testMinimize2() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(200),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 1, 0 }),                                  new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);         Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12);         Assert.assertTrue(optimizer.getEvaluations() > 120);         Assert.assertTrue(optimizer.getEvaluations() < 150);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testMaximize1() {         SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(200),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MAXIMIZE,                                  new InitialGuess(new double[] { -3.0, 0.0 }),                                  new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7);         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7);         Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14);         Assert.assertTrue(optimizer.getEvaluations() > 120);         Assert.assertTrue(optimizer.getEvaluations() < 150);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testMaximize2() {         SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30));         final OptimTestUtils.FourExtrema fourExtrema = new OptimTestUtils.FourExtrema();          final PointValuePair optimum             = optimizer.optimize(new MaxEval(200),                                  new ObjectiveFunction(fourExtrema),                                  GoalType.MAXIMIZE,                                  new InitialGuess(new double[] { 1, 0 }),                                  new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);         Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);         Assert.assertTrue(optimizer.getEvaluations() > 180);         Assert.assertTrue(optimizer.getEvaluations() < 220);          // Check that the number of iterations is updated (MATH-949).         Assert.assertTrue(optimizer.getIterations() > 0);     }      @Test     public void testRosenbrock() {         final OptimTestUtils.Rosenbrock rosenbrock = new OptimTestUtils.Rosenbrock();         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);         PointValuePair optimum            = optimizer.optimize(new MaxEval(100),                                 new ObjectiveFunction(rosenbrock),                                 GoalType.MINIMIZE,                                 new InitialGuess(new double[] { -1.2, 1 }),                                 new MultiDirectionalSimplex(new double[][] {                                         { -1.2,  1.0 },                                         { 0.9, 1.2 },                                         {  3.5, -2.3 } }));         Assert.assertTrue(optimizer.getEvaluations() > 50);         Assert.assertTrue(optimizer.getEvaluations() < 100);         Assert.assertTrue(optimum.getValue() > 1e-2);     }      @Test     public void testPowell() {         final OptimTestUtils.Powell powell = new OptimTestUtils.Powell();         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);         PointValuePair optimum             = optimizer.optimize(new MaxEval(1000),                                  new ObjectiveFunction(powell),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 3, -1, 0, 1 }),                                  new MultiDirectionalSimplex(4));         Assert.assertTrue(optimizer.getEvaluations() > 800);         Assert.assertTrue(optimizer.getEvaluations() < 900);         Assert.assertTrue(optimum.getValue() > 1e-2);     }      @Test     public void testMath283() {         // fails because MultiDirectional.iterateSimplex is looping forever         // the while(true) should be replaced with a convergence check         SimplexOptimizer optimizer = new SimplexOptimizer(1e-14, 1e-14);         final OptimTestUtils.Gaussian2D function = new OptimTestUtils.Gaussian2D(0, 0, 1);         PointValuePair estimate = optimizer.optimize(new MaxEval(1000),                                                      new ObjectiveFunction(function),                                                      GoalType.MAXIMIZE,                                                      new InitialGuess(function.getMaximumPosition()),                                                      new MultiDirectionalSimplex(2));         final double EPSILON = 1e-5;         final double expectedMaximum = function.getMaximum();         final double actualMaximum = estimate.getValue();         Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);          final double[] expectedPosition = function.getMaximumPosition();         final double[] actualPosition = estimate.getPoint();         Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );         Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );     }      @Test     public void testRosen() {         doTest(new OptimTestUtils.Rosen(),                OptimTestUtils.point(DIM, 0.1),                GoalType.MINIMIZE,                183861,                new PointValuePair(OptimTestUtils.point(DIM, 1.0), 0.0),                1e-4);     }      @Test     public void testEllipse() {         doTest(new OptimTestUtils.Elli(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                873,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);      }      @Test     public void testElliRotated() {         doTest(new OptimTestUtils.ElliRotated(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                873,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);     }      @Test     public void testCigar() {         doTest(new OptimTestUtils.Cigar(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                925,                new PointValuePair(OptimTestUtils.point(DIM,0.0), 0.0),                1e-14);     }      @Test     public void testTwoAxes() {         doTest(new OptimTestUtils.TwoAxes(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                1159,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);      }      @Test     public void testCigTab() {         doTest(new OptimTestUtils.CigTab(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                795,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);      }      @Test     public void testSphere() {         doTest(new OptimTestUtils.Sphere(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                665,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);     }      @Test     public void testTablet() {         doTest(new OptimTestUtils.Tablet(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                873,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);     }      @Test     public void testDiffPow() {         doTest(new OptimTestUtils.DiffPow(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                614,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                1e-14);     }      @Test     public void testSsDiffPow() {         doTest(new OptimTestUtils.SsDiffPow(),                OptimTestUtils.point(DIM / 2, 1.0),                GoalType.MINIMIZE,                656,                new PointValuePair(OptimTestUtils.point(DIM / 2, 0.0), 0.0),                1e-15);     }      @Ignore     @Test     public void testAckley() {         doTest(new OptimTestUtils.Ackley(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                587,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                0);     }      @Ignore     @Test     public void testRastrigin() {         doTest(new OptimTestUtils.Rastrigin(),                OptimTestUtils.point(DIM, 1.0),                GoalType.MINIMIZE,                535,                new PointValuePair(OptimTestUtils.point(DIM, 0.0), 0.0),                0);     }      /**      * @param func Function to optimize.      * @param startPoint Starting point.      * @param goal Minimization or maximization.      * @param maxEvaluations Maximum number of evaluations.      * @param expected Expected optimum.      * @param tol Tolerance for checking that the optimum is correct.      */     private void doTest(MultivariateFunction func,                         double[] startPoint,                         GoalType goal,                         int maxEvaluations,                         PointValuePair expected,                         double tol) {         final int dim = startPoint.length;         final SimplexOptimizer optim = new SimplexOptimizer(1e-10, 1e-12);         final PointValuePair result = optim.optimize(new MaxEval(maxEvaluations),                                                      new ObjectiveFunction(func),                                                      goal,                                                      new InitialGuess(startPoint),                                                      new MultiDirectionalSimplex(dim, 0.1));         final double dist = MathArrays.distance(expected.getPoint(),                                                 result.getPoint());         Assert.assertEquals(0d, dist, tol);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.nonlinear.scalar.noderiv;  import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimpleBounds; import org.apache.commons.math4.optim.nonlinear.scalar.GoalType; import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction; import org.junit.Assert; import org.junit.Ignore; import org.junit.Test;  /**  * Test for {@link BOBYQAOptimizer}.  */ public class BOBYQAOptimizerTest {     private static final int DIM = 13;      @Test(expected=NumberIsTooLargeException.class)     public void testInitOutOfBounds() {         double[] startPoint = OptimTestUtils.point(DIM, 3);         double[][] boundaries = boundaries(DIM, -1, 2);         doTest(new OptimTestUtils.Rosen(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 2000, null);     }      @Test(expected=DimensionMismatchException.class)     public void testBoundariesDimensionMismatch() {         double[] startPoint = OptimTestUtils.point(DIM, 0.5);         double[][] boundaries = boundaries(DIM + 1, -1, 2);         doTest(new OptimTestUtils.Rosen(), startPoint, boundaries,                GoalType.MINIMIZE,                1e-13, 1e-6, 2000, null);     }      @Test(expected=NumberIsTooSmallException.class)     public void testProblemDimensionTooSmall() {         double[] startPoint = OptimTestUtils.point(1, 0.5);         doTest(new OptimTestUtils.Rosen(), startPoint, null,                GoalType.MINIMIZE,                1e-13, 1e-6, 2000, null);     }      @Test(expected=TooManyEvaluationsException.class)     public void testMaxEvaluations() {         final int lowMaxEval = 2;         double[] startPoint = OptimTestUtils.point(DIM, 0.1);         double[][] boundaries = null;         doTest(new OptimTestUtils.Rosen(), startPoint, boundaries,                GoalType.MINIMIZE,                1e-13, 1e-6, lowMaxEval, null);      }      @Test     public void testRosen() {         double[] startPoint = OptimTestUtils.point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected = new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);         doTest(new OptimTestUtils.Rosen(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 2000, expected);      }      @Test     public void testMaximize() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected = new PointValuePair(OptimTestUtils.point(DIM,0.0),1.0);         doTest(new OptimTestUtils.MinusElli(), startPoint, boundaries,                 GoalType.MAXIMIZE,                 2e-10, 5e-6, 1000, expected);         boundaries = boundaries(DIM,-0.3,0.3);         startPoint = OptimTestUtils.point(DIM,0.1);         doTest(new OptimTestUtils.MinusElli(), startPoint, boundaries,                 GoalType.MAXIMIZE,                 2e-10, 5e-6, 1000, expected);     }      @Test     public void testEllipse() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.Elli(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 1000, expected);      }      @Test     public void testElliRotated() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.ElliRotated(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-12, 1e-6, 10000, expected);     }      @Test     public void testCigar() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.Cigar(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 100, expected);     }      @Test     public void testTwoAxes() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.TwoAxes(), startPoint, boundaries,                 GoalType.MINIMIZE, 2*                 1e-13, 1e-6, 100, expected);      }      @Test     public void testCigTab() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.CigTab(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 5e-5, 100, expected);      }      @Test     public void testSphere() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.Sphere(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 100, expected);     }      @Test     public void testTablet() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.Tablet(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 100, expected);     }      @Test     public void testDiffPow() {         double[] startPoint = OptimTestUtils.point(DIM/2,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM/2,0.0),0.0);         doTest(new OptimTestUtils.DiffPow(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-8, 1e-1, 21000, expected);     }      @Test     public void testSsDiffPow() {         double[] startPoint = OptimTestUtils.point(DIM/2,1.0);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM/2,0.0),0.0);         doTest(new OptimTestUtils.SsDiffPow(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-2, 1.3e-1, 50000, expected);     }      @Test     public void testAckley() {         double[] startPoint = OptimTestUtils.point(DIM,0.1);         double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.Ackley(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-7, 1e-5, 1000, expected);     }      @Test     public void testRastrigin() {         double[] startPoint = OptimTestUtils.point(DIM,1.0);          double[][] boundaries = null;         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);         doTest(new OptimTestUtils.Rastrigin(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 1000, expected);     }      @Test     public void testConstrainedRosen() {         double[] startPoint = OptimTestUtils.point(DIM,0.1);          double[][] boundaries = boundaries(DIM,-1,2);         PointValuePair expected =             new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);         doTest(new OptimTestUtils.Rosen(), startPoint, boundaries,                 GoalType.MINIMIZE,                 1e-13, 1e-6, 2000, expected);     }      // See MATH-728     // TODO: this test is temporarily disabled for 3.2 release as a bug in Cobertura     //       makes it run for several hours before completing     @Ignore @Test     public void testConstrainedRosenWithMoreInterpolationPoints() {         final double[] startPoint = OptimTestUtils.point(DIM, 0.1);         final double[][] boundaries = boundaries(DIM, -1, 2);         final PointValuePair expected = new PointValuePair(OptimTestUtils.point(DIM, 1.0), 0.0);          // This should have been 78 because in the code the hard limit is         // said to be         //   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)         // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,         // 65, 66, ...         final int maxAdditionalPoints = 47;          for (int num = 1; num <= maxAdditionalPoints; num++) {             doTest(new OptimTestUtils.Rosen(), startPoint, boundaries,                    GoalType.MINIMIZE,                    1e-12, 1e-6, 2000,                    num,                    expected,                    "num=" + num);         }     }      /**      * @param func Function to optimize.      * @param startPoint Starting point.      * @param boundaries Upper / lower point limit.      * @param goal Minimization or maximization.      * @param fTol Tolerance relative error on the objective function.      * @param pointTol Tolerance for checking that the optimum is correct.      * @param maxEvaluations Maximum number of evaluations.      * @param expected Expected point / value.      */     private void doTest(MultivariateFunction func,                         double[] startPoint,                         double[][] boundaries,                         GoalType goal,                         double fTol,                         double pointTol,                         int maxEvaluations,                         PointValuePair expected) {         doTest(func,                startPoint,                boundaries,                goal,                fTol,                pointTol,                maxEvaluations,                0,                expected,                "");     }      /**      * @param func Function to optimize.      * @param startPoint Starting point.      * @param boundaries Upper / lower point limit.      * @param goal Minimization or maximization.      * @param fTol Tolerance relative error on the objective function.      * @param pointTol Tolerance for checking that the optimum is correct.      * @param maxEvaluations Maximum number of evaluations.      * @param additionalInterpolationPoints Number of interpolation to used      * in addition to the default (2 * dim + 1).      * @param expected Expected point / value.      */     private void doTest(MultivariateFunction func,                         double[] startPoint,                         double[][] boundaries,                         GoalType goal,                         double fTol,                         double pointTol,                         int maxEvaluations,                         int additionalInterpolationPoints,                         PointValuePair expected,                         String assertMsg) {  //         System.out.println(func.getClass().getName() + " BEGIN"); // XXX          int dim = startPoint.length;         final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints;         BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints);         PointValuePair result = boundaries == null ?             optim.optimize(new MaxEval(maxEvaluations),                            new ObjectiveFunction(func),                            goal,                            SimpleBounds.unbounded(dim),                            new InitialGuess(startPoint)) :             optim.optimize(new MaxEval(maxEvaluations),                            new ObjectiveFunction(func),                            goal,                            new InitialGuess(startPoint),                            new SimpleBounds(boundaries[0],                                             boundaries[1])); //        System.out.println(func.getClass().getName() + " = " //              + optim.getEvaluations() + " f("); //        for (double x: result.getPoint())  System.out.print(x + " "); //        System.out.println(") = " +  result.getValue());         Assert.assertEquals(assertMsg, expected.getValue(), result.getValue(), fTol);         for (int i = 0; i < dim; i++) {             Assert.assertEquals(expected.getPoint()[i],                                 result.getPoint()[i], pointTol);         }  //         System.out.println(func.getClass().getName() + " END"); // XXX     }      private static double[][] boundaries(int dim,             double lower, double upper) {         double[][] boundaries = new double[2][dim];         for (int i = 0; i < dim; i++) {             boundaries[0][i] = lower;         }         for (int i = 0; i < dim; i++) {             boundaries[1][i] = upper;         }         return boundaries;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.nonlinear.scalar;  import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer; import org.junit.Assert; import org.junit.Test;  public class MultivariateFunctionMappingAdapterTest {     @Test     public void testStartSimplexInsideRange() {         final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);         final MultivariateFunctionMappingAdapter wrapped             = new MultivariateFunctionMappingAdapter(biQuadratic,                                                      biQuadratic.getLower(),                                                      biQuadratic.getUpper());          SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] {                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),                 wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })             });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(300),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })));         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);     }      @Test     public void testOptimumOutsideRange() {         final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0);         final MultivariateFunctionMappingAdapter wrapped             = new MultivariateFunctionMappingAdapter(biQuadratic,                                                      biQuadratic.getLower(),                                                      biQuadratic.getUpper());          SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] {                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),                 wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })             });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(100),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })));         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);     }      @Test     public void testUnbounded() {         final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0,                                                         Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,                                                         Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);         final MultivariateFunctionMappingAdapter wrapped             = new MultivariateFunctionMappingAdapter(biQuadratic,                                                      biQuadratic.getLower(),                                                      biQuadratic.getUpper());          SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);         final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] {                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),                 wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })             });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(300),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })));         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);     }      @Test     public void testHalfBounded() {         final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0,                                                         1.0, Double.POSITIVE_INFINITY,                                                         Double.NEGATIVE_INFINITY, 3.0);         final MultivariateFunctionMappingAdapter wrapped             = new MultivariateFunctionMappingAdapter(biQuadratic,                                                      biQuadratic.getLower(),                                                      biQuadratic.getUpper());          SimplexOptimizer optimizer = new SimplexOptimizer(1e-13, 1e-30);         final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] {                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),                 wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })             });          final PointValuePair optimum             = optimizer.optimize(new MaxEval(200),                                  new ObjectiveFunction(wrapped),                                  simplex,                                  GoalType.MINIMIZE,                                  new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })));         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());          Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 1e-7);         Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 1e-7);     }      private static class BiQuadratic implements MultivariateFunction {          private final double xOptimum;         private final double yOptimum;          private final double xMin;         private final double xMax;         private final double yMin;         private final double yMax;          public BiQuadratic(final double xOptimum, final double yOptimum,                            final double xMin, final double xMax,                            final double yMin, final double yMax) {             this.xOptimum = xOptimum;             this.yOptimum = yOptimum;             this.xMin     = xMin;             this.xMax     = xMax;             this.yMin     = yMin;             this.yMax     = yMax;         }          @Override         public double value(double[] point) {             // the function should never be called with out of range points             Assert.assertTrue(point[0] >= xMin);             Assert.assertTrue(point[0] <= xMax);             Assert.assertTrue(point[1] >= yMin);             Assert.assertTrue(point[1] <= yMax);              final double dx = point[0] - xOptimum;             final double dy = point[1] - yOptimum;             return dx * dx + dy * dy;          }          public double[] getLower() {             return new double[] { xMin, yMin };         }          public double[] getUpper() {             return new double[] { xMax, yMax };         }          public double getBoundedXOptimum() {             return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum);         }          public double getBoundedYOptimum() {             return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.optim.nonlinear.scalar;  import org.apache.commons.geometry.euclidean.twod.Vector2D; import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.optim.InitialGuess; import org.apache.commons.math4.optim.MaxEval; import org.apache.commons.math4.optim.PointValuePair; import org.apache.commons.math4.optim.SimpleValueChecker; import org.apache.commons.math4.optim.nonlinear.scalar.gradient.CircleScalar; import org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex; import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.random.GaussianRandomGenerator; import org.apache.commons.math4.random.RandomVectorGenerator; import org.apache.commons.math4.random.UncorrelatedRandomVectorGenerator; import org.junit.Assert; import org.junit.Test;  public class MultiStartMultivariateOptimizerTest {     @Test     public void testCircleFitting() {         CircleScalar circle = new CircleScalar();         circle.addPoint( 30.0,  68.0);         circle.addPoint( 50.0,  -6.0);         circle.addPoint(110.0, -20.0);         circle.addPoint( 35.0,  15.0);         circle.addPoint( 45.0,  97.0);         // TODO: the wrapper around NonLinearConjugateGradientOptimizer is a temporary hack for         // version 3.1 of the library. It should be removed when NonLinearConjugateGradientOptimizer         // will officially be declared as implementing MultivariateDifferentiableOptimizer         GradientMultivariateOptimizer underlying             = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,                                                       new SimpleValueChecker(1e-10, 1e-10));         UniformRandomProvider g = RandomSource.create(RandomSource.MT_64, 753289573253l);         RandomVectorGenerator generator             = new UncorrelatedRandomVectorGenerator(new double[] { 50, 50 },                                                     new double[] { 10, 10 },                                                     new GaussianRandomGenerator(g));         int nbStarts = 10;         MultiStartMultivariateOptimizer optimizer             = new MultiStartMultivariateOptimizer(underlying, nbStarts, generator);         PointValuePair optimum             = optimizer.optimize(new MaxEval(1000),                                  circle.getObjectiveFunction(),                                  circle.getObjectiveFunctionGradient(),                                  GoalType.MINIMIZE,                                  new InitialGuess(new double[] { 98.680, 47.345 }));         Assert.assertEquals(1000, optimizer.getMaxEvaluations());         PointValuePair[] optima = optimizer.getOptima();         Assert.assertEquals(nbStarts, optima.length);         for (PointValuePair o : optima) {             // we check the results of all intermediate restarts here (there are 10 such results)             Vector2D center = Vector2D.of(o.getPointRef()[0], o.getPointRef()[1]);             Assert.assertEquals(69.9597, circle.getRadius(center), 1e-3);             Assert.assertEquals(96.07535, center.getX(), 1.4e-3);             Assert.assertEquals(48.1349, center.getY(), 5e-3);         }          Assert.assertTrue(optimizer.getEvaluations() > 800);         Assert.assertTrue(optimizer.getEvaluations() < 900);          Assert.assertEquals(3.1267527, optimum.getValue(), 1e-8);     }      @Test     public void testRosenbrock() {         Rosenbrock rosenbrock = new Rosenbrock();         SimplexOptimizer underlying             = new SimplexOptimizer(new SimpleValueChecker(-1, 1e-3));         NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {                 { -1.2,  1.0 },                 { 0.9, 1.2 } ,                 {  3.5, -2.3 }             });         // The test is extremely sensitive to the seed.         UniformRandomProvider g = RandomSource.create(RandomSource.MT_64, 16069223056L);         RandomVectorGenerator generator             = new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));         int nbStarts = 10;         MultiStartMultivariateOptimizer optimizer             = new MultiStartMultivariateOptimizer(underlying, nbStarts, generator);         PointValuePair optimum             = optimizer.optimize(new MaxEval(1100),                                  new ObjectiveFunction(rosenbrock),                                  GoalType.MINIMIZE,                                  simplex,                                  new InitialGuess(new double[] { -1.2, 1.0 }));         Assert.assertEquals(nbStarts, optimizer.getOptima().length);          final int numEval = optimizer.getEvaluations();         Assert.assertEquals(rosenbrock.getCount(), numEval);         Assert.assertTrue("numEval=" + numEval, numEval > 900);         Assert.assertTrue("numEval=" + numEval, numEval < 1200);         Assert.assertTrue("optimum=" + optimum.getValue(), optimum.getValue() < 5e-5);     }      private static class Rosenbrock implements MultivariateFunction {         private int count;          public Rosenbrock() {             count = 0;         }          @Override         public double value(double[] x) {             ++count;             double a = x[1] - x[0] * x[0];             double b = 1 - x[0];             return 100 * a * a + b * b;         }          public int getCount() {             return count;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;   import org.apache.commons.math4.TestUtils; import org.junit.Assert; import org.junit.Test;  public class BigRealFieldTest {      @Test     public void testZero() {         Assert.assertEquals(BigReal.ZERO, BigRealField.getInstance().getZero());     }      @Test     public void testOne() {         Assert.assertEquals(BigReal.ONE, BigRealField.getInstance().getOne());     }      @Test     public void testSerial() {         // deserializing the singleton should give the singleton itself back         BigRealField field = BigRealField.getInstance();         Assert.assertTrue(field == TestUtils.serializeAndRecover(field));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import java.util.ConcurrentModificationException; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Random; import java.util.Set; import java.util.Map.Entry;  import org.apache.commons.math4.Field; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.dfp.DfpField; import org.apache.commons.math4.linear.Dfp25; import org.junit.Assert; import org.junit.Before; import org.junit.Test;   @SuppressWarnings("boxing") public class OpenIntToFieldTest {      private Map<Integer, Dfp> javaMap = new HashMap<>();     private DfpField field = Dfp25.getField();      @Before     public void setUp() {         javaMap.put(50, Dfp25.of(100.0));         javaMap.put(75, Dfp25.of(75.0));         javaMap.put(25, Dfp25.of(500.0));         javaMap.put(Integer.MAX_VALUE, Dfp25.of(Integer.MAX_VALUE));         javaMap.put(0, Dfp25.of(-1.0));         javaMap.put(1, Dfp25.of(0.0));         javaMap.put(33, Dfp25.of(-0.1));         javaMap.put(23234234, Dfp25.of(-242343.0));         javaMap.put(23321, Dfp25.of (Integer.MIN_VALUE));         javaMap.put(-4444, Dfp25.of(332.0));         javaMap.put(-1, Dfp25.of(-2323.0));         javaMap.put(Integer.MIN_VALUE, Dfp25.of(44.0));          /* Add a few more to cause the table to rehash */         javaMap.putAll(generate());      }      private Map<Integer, Dfp> generate() {         Map<Integer, Dfp> map = new HashMap<>();         Random r = new Random();         double dd=0;         for (int i = 0; i < 2000; ++i) {             dd = r.nextDouble();         }         map.put(r.nextInt(), Dfp25.of(dd));         return map;     }      private OpenIntToFieldHashMap<Dfp> createFromJavaMap(Field<Dfp> field) {         OpenIntToFieldHashMap<Dfp> map = new OpenIntToFieldHashMap<>(field);         for (Map.Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());         }         return map;     }      @Test     public void testPutAndGetWith0ExpectedSize() {         OpenIntToFieldHashMap<Dfp> map = new OpenIntToFieldHashMap<>(field,0);         assertPutAndGet(map);     }      @Test     public void testPutAndGetWithExpectedSize() {         OpenIntToFieldHashMap<Dfp> map = new OpenIntToFieldHashMap<>(field,500);         assertPutAndGet(map);     }      @Test     public void testPutAndGet() {         OpenIntToFieldHashMap<Dfp> map = new OpenIntToFieldHashMap<>(field);         assertPutAndGet(map);     }      private void assertPutAndGet(OpenIntToFieldHashMap<Dfp> map) {         assertPutAndGet(map, 0, new HashSet<Integer>());     }      private void assertPutAndGet(OpenIntToFieldHashMap<Dfp> map, int mapSize,             Set<Integer> keysInMap) {         Assert.assertEquals(mapSize, map.size());         for (Map.Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());             if (!keysInMap.contains(mapEntry.getKey())) {                 ++mapSize;             }             Assert.assertEquals(mapSize, map.size());             Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));         }     }      @Test     public void testPutAbsentOnExisting() {         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         int size = javaMap.size();         for (Map.Entry<Integer, Dfp> mapEntry : generateAbsent().entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());             Assert.assertEquals(++size, map.size());             Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));         }     }      @Test     public void testPutOnExisting() {         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         for (Map.Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());             Assert.assertEquals(javaMap.size(), map.size());             Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));         }     }      @Test     public void testGetAbsent() {         Map<Integer, Dfp> generated = generateAbsent();         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);          for (Map.Entry<Integer, Dfp> mapEntry : generated.entrySet()) {             Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));         }     }      @Test     public void testGetFromEmpty() {         OpenIntToFieldHashMap<Dfp> map = new OpenIntToFieldHashMap<>(field);         Assert.assertTrue(field.getZero().equals(map.get(5)));         Assert.assertTrue(field.getZero().equals(map.get(0)));         Assert.assertTrue(field.getZero().equals(map.get(50)));     }      @Test     public void testRemove() {         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         int mapSize = javaMap.size();         Assert.assertEquals(mapSize, map.size());         for (Map.Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             map.remove(mapEntry.getKey());             Assert.assertEquals(--mapSize, map.size());             Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));         }          /* Ensure that put and get still work correctly after removals */         assertPutAndGet(map);     }      /* This time only remove some entries */     @Test     public void testRemove2() {         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         int mapSize = javaMap.size();         int count = 0;         Set<Integer> keysInMap = new HashSet<>(javaMap.keySet());         for (Map.Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             keysInMap.remove(mapEntry.getKey());             map.remove(mapEntry.getKey());             Assert.assertEquals(--mapSize, map.size());             Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));             if (count++ > 5) {                 break;             }         }          /* Ensure that put and get still work correctly after removals */         assertPutAndGet(map, mapSize, keysInMap);     }      @Test     public void testRemoveFromEmpty() {         OpenIntToFieldHashMap<Dfp> map = new OpenIntToFieldHashMap<>(field);         Assert.assertTrue(field.getZero().equals(map.remove(50)));     }      @Test     public void testRemoveAbsent() {         Map<Integer, Dfp> generated = generateAbsent();          OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         int mapSize = map.size();          for (Map.Entry<Integer, Dfp> mapEntry : generated.entrySet()) {             map.remove(mapEntry.getKey());             Assert.assertEquals(mapSize, map.size());             Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));         }     }      /**      * Returns a map with at least 100 elements where each element is absent from javaMap.      */     private Map<Integer, Dfp> generateAbsent() {         Map<Integer, Dfp> generated = new HashMap<>();         do {             generated.putAll(generate());             for (Integer key : javaMap.keySet()) {                 generated.remove(key);             }         } while (generated.size() < 100);         return generated;     }      @Test     public void testCopy() {         OpenIntToFieldHashMap<Dfp> copy =             new OpenIntToFieldHashMap<>(createFromJavaMap(field));         Assert.assertEquals(javaMap.size(), copy.size());          for (Map.Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             Assert.assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));         }     }      @Test     public void testContainsKey() {         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         for (Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             Assert.assertTrue(map.containsKey(mapEntry.getKey()));         }         for (Map.Entry<Integer, Dfp> mapEntry : generateAbsent().entrySet()) {             Assert.assertFalse(map.containsKey(mapEntry.getKey()));         }         for (Entry<Integer, Dfp> mapEntry : javaMap.entrySet()) {             int key = mapEntry.getKey();             Assert.assertTrue(map.containsKey(key));             map.remove(key);             Assert.assertFalse(map.containsKey(key));         }     }      @Test     public void testIterator() {         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         OpenIntToFieldHashMap<Dfp>.Iterator iterator = map.iterator();         for (int i = 0; i < map.size(); ++i) {             Assert.assertTrue(iterator.hasNext());             iterator.advance();             int key = iterator.key();             Assert.assertTrue(map.containsKey(key));             Assert.assertEquals(javaMap.get(key), map.get(key));             Assert.assertEquals(javaMap.get(key), iterator.value());             Assert.assertTrue(javaMap.containsKey(key));         }         Assert.assertFalse(iterator.hasNext());         try {             iterator.advance();             Assert.fail("an exception should have been thrown");         } catch (NoSuchElementException nsee) {             // expected         }     }      @Test     public void testConcurrentModification() {         OpenIntToFieldHashMap<Dfp> map = createFromJavaMap(field);         OpenIntToFieldHashMap<Dfp>.Iterator iterator = map.iterator();         map.put(3, Dfp25.of(3));         try {             iterator.advance();             Assert.fail("an exception should have been thrown");         } catch (ConcurrentModificationException cme) {             // expected         }     }      /**      * Regression test for a bug in findInsertionIndex where the hashing in the second probing      * loop was inconsistent with the first causing duplicate keys after the right sequence      * of puts and removes.      */     @Test     public void testPutKeysWithCollisions() {         OpenIntToFieldHashMap<Dfp> map = new OpenIntToFieldHashMap<>(field);         int key1 = -1996012590;         Dfp value1 = Dfp25.of(1);         map.put(key1, value1);         int key2 = 835099822;         map.put(key2, value1);         int key3 = 1008859686;         map.put(key3, value1);         Assert.assertEquals(value1, map.get(key3));         Assert.assertEquals(3, map.size());          map.remove(key2);         Dfp value2 = Dfp25.of(2);         map.put(key3, value2);         Assert.assertEquals(value2, map.get(key3));         Assert.assertEquals(2, map.size());     }      /**      * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly      * different manner.      */     @Test     public void testPutKeysWithCollision2() {         OpenIntToFieldHashMap<Dfp>map = new OpenIntToFieldHashMap<>(field);         int key1 = 837989881;         Dfp value1 = Dfp25.of(1);         map.put(key1, value1);         int key2 = 476463321;         map.put(key2, value1);         Assert.assertEquals(2, map.size());         Assert.assertEquals(value1, map.get(key2));          map.remove(key1);         Dfp value2 = Dfp25.of(2);         map.put(key2, value2);         Assert.assertEquals(1, map.size());         Assert.assertEquals(value2, map.get(key2));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.util;  import org.apache.commons.numbers.angle.PlaneAngleRadians; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.math4.exception.NotFiniteNumberException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.util.LocalizedFormats; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.rng.sampling.PermutationSampler; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the MathUtils class.  *  */ public final class MathUtilsTest {     @Test     public void testEqualsDouble() {         final double x = 1234.5678;         Assert.assertTrue(MathUtils.equals(x, x));         Assert.assertFalse(MathUtils.equals(x, -x));          // Special cases (cf. semantics of JDK's "Double").         // 1. NaN         Assert.assertTrue(MathUtils.equals(Double.NaN, Double.NaN));         // 2. Negative zero         final double mZero = -0d;         final double zero = 0d;         Assert.assertTrue(MathUtils.equals(zero, zero));         Assert.assertTrue(MathUtils.equals(mZero, mZero));         Assert.assertFalse(MathUtils.equals(mZero, zero));     }      @Test     public void testHash() {         double[] testArray = {             Double.NaN,             Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY,             1d,             0d,             1E-14,             (1 + 1E-14),             Double.MIN_VALUE,             Double.MAX_VALUE };         for (int i = 0; i < testArray.length; i++) {             for (int j = 0; j < testArray.length; j++) {                 if (i == j) {                     Assert.assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));                     Assert.assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));                 } else {                     Assert.assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));                     Assert.assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));                 }             }         }     }      @Test     public void testArrayHash() {         Assert.assertEquals(0, MathUtils.hash((double[]) null));         Assert.assertEquals(MathUtils.hash(new double[] {                                       Double.NaN, Double.POSITIVE_INFINITY,                                       Double.NEGATIVE_INFINITY, 1d, 0d                                     }),                      MathUtils.hash(new double[] {                                       Double.NaN, Double.POSITIVE_INFINITY,                                       Double.NEGATIVE_INFINITY, 1d, 0d                                     }));         Assert.assertFalse(MathUtils.hash(new double[] { 1d }) ==                     MathUtils.hash(new double[] { FastMath.nextAfter(1d, 2d) }));         Assert.assertFalse(MathUtils.hash(new double[] { 1d }) ==                     MathUtils.hash(new double[] { 1d, 1d }));     }      /**      * Make sure that permuted arrays do not hash to the same value.      */     @Test     public void testPermutedArrayHash() {         double[] original = new double[10];         double[] permuted = new double[10];          final UniformRandomProvider random = RandomSource.create(RandomSource.WELL_512_A,                                                                  64925784252L);          // Generate 10 distinct random values         for (int i = 0; i < 10; i++) {             final ContinuousDistribution.Sampler u                 = new UniformContinuousDistribution(i + 0.5, i + 0.75).createSampler(random);             original[i] = u.sample();         }          // Generate a random permutation, making sure it is not the identity         boolean isIdentity = true;         do {             int[] permutation = PermutationSampler.natural(10);             PermutationSampler.shuffle(random, permutation);             for (int i = 0; i < 10; i++) {                 if (i != permutation[i]) {                     isIdentity = false;                     break;                 }                 permuted[i] = original[permutation[i]];             }         } while (isIdentity);          // Verify that permuted array has different hash         Assert.assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));     }      @Test     public void testIndicatorByte() {         Assert.assertEquals((byte)1, MathUtils.copySign((byte)1, (byte)2));         Assert.assertEquals((byte)1, MathUtils.copySign((byte)1, (byte)0));         Assert.assertEquals((byte)(-1), MathUtils.copySign((byte)1, (byte)(-2)));     }      @Test     public void testIndicatorInt() {         Assert.assertEquals(1, MathUtils.copySign(1, 2));         Assert.assertEquals(1, MathUtils.copySign(1, 0));         Assert.assertEquals((-1), MathUtils.copySign(1, -2));     }      @Test     public void testIndicatorLong() {         Assert.assertEquals(1L, MathUtils.copySign(1L, 2L));         Assert.assertEquals(1L, MathUtils.copySign(1L, 0L));         Assert.assertEquals(-1L, MathUtils.copySign(1L, -2L));     }      @Test     public void testIndicatorShort() {         Assert.assertEquals((short)1, MathUtils.copySign((short)1, (short)2));         Assert.assertEquals((short)1, MathUtils.copySign((short)1, (short)0));         Assert.assertEquals((short)(-1), MathUtils.copySign((short)1, (short)(-2)));     }      @Test     public void testReduce() {         final double period = -12.222;         final double offset = 13;          final double delta = 1.5;          double orig = offset + 122456789 * period + delta;         double expected = delta;         Assert.assertEquals(expected,                             MathUtils.reduce(orig, period, offset),                             1e-7);         Assert.assertEquals(expected,                             MathUtils.reduce(orig, -period, offset),                             1e-7);          orig = offset - 123356789 * period - delta;         expected = FastMath.abs(period) - delta;         Assert.assertEquals(expected,                             MathUtils.reduce(orig, period, offset),                             1e-6);         Assert.assertEquals(expected,                             MathUtils.reduce(orig, -period, offset),                             1e-6);          orig = offset - 123446789 * period + delta;         expected = delta;         Assert.assertEquals(expected,                             MathUtils.reduce(orig, period, offset),                             1e-6);         Assert.assertEquals(expected,                             MathUtils.reduce(orig, -period, offset),                             1e-6);          Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.NaN, offset)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.NaN, period, offset)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period, Double.NaN)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period,                 Double.POSITIVE_INFINITY)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                 period, offset)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,                 Double.POSITIVE_INFINITY, offset)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,                 Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                 period, Double.POSITIVE_INFINITY)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                 Double.POSITIVE_INFINITY, offset)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                 Double.POSITIVE_INFINITY,  Double.POSITIVE_INFINITY)));     }      @Test     public void testReduceComparedWithNormalize() {         final double period = 2 * Math.PI;         for (double a = -15; a <= 15; a += 0.5) {             for (double center = -15; center <= 15; center += 1) {                 final double nA = PlaneAngleRadians.normalize(a, center);                 final double offset = center - Math.PI;                 final double r = MathUtils.reduce(a, period, offset) + offset;                 Assert.assertEquals("a=" + a + " center=" + center,                                     nA, r, 52 * Math.ulp(nA));             }         }     }      @Test     public void testSignByte() {         final byte one = (byte) 1;         Assert.assertEquals((byte) 1, MathUtils.copySign(one, (byte) 2));         Assert.assertEquals((byte) (-1), MathUtils.copySign(one, (byte) (-2)));     }      @Test     public void testSignInt() {         final int one = 1;         Assert.assertEquals(1, MathUtils.copySign(one, 2));         Assert.assertEquals((-1), MathUtils.copySign(one, -2));     }      @Test     public void testSignLong() {         final long one = 1L;         Assert.assertEquals(1L, MathUtils.copySign(one, 2L));         Assert.assertEquals(-1L, MathUtils.copySign(one, -2L));     }      @Test     public void testSignShort() {         final short one = (short) 1;         Assert.assertEquals((short) 1, MathUtils.copySign(one, (short) 2));         Assert.assertEquals((short) (-1), MathUtils.copySign(one, (short) (-2)));     }      @Test     public void testCheckFinite() {         try {             MathUtils.checkFinite(Double.POSITIVE_INFINITY);             Assert.fail("an exception should have been thrown");         } catch (NotFiniteNumberException e) {             // Expected         }         try {             MathUtils.checkFinite(Double.NEGATIVE_INFINITY);             Assert.fail("an exception should have been thrown");         } catch (NotFiniteNumberException e) {             // Expected         }         try {             MathUtils.checkFinite(Double.NaN);             Assert.fail("an exception should have been thrown");         } catch (NotFiniteNumberException e) {             // Expected         }          try {             MathUtils.checkFinite(new double[] {0, -1, Double.POSITIVE_INFINITY, -2, 3});             Assert.fail("an exception should have been thrown");         } catch (NotFiniteNumberException e) {             // Expected         }         try {             MathUtils.checkFinite(new double[] {1, Double.NEGATIVE_INFINITY, -2, 3});             Assert.fail("an exception should have been thrown");         } catch (NotFiniteNumberException e) {             // Expected         }         try {             MathUtils.checkFinite(new double[] {4, 3, -1, Double.NaN, -2, 1});             Assert.fail("an exception should have been thrown");         } catch (NotFiniteNumberException e) {             // Expected         }     }      @Test     public void testCheckNotNull1() {         try {             Object obj = null;             MathUtils.checkNotNull(obj);         } catch (NullArgumentException e) {             // Expected.         }     }      @Test     public void testCheckNotNull2() {         try {             double[] array = null;             MathUtils.checkNotNull(array, LocalizedFormats.INPUT_ARRAY);         } catch (NullArgumentException e) {             // Expected.         }     }      @Test     public void testCopySignByte() {         byte a = MathUtils.copySign(Byte.MIN_VALUE, (byte) -1);         Assert.assertEquals(Byte.MIN_VALUE, a);          final byte minValuePlusOne = Byte.MIN_VALUE + (byte) 1;         a = MathUtils.copySign(minValuePlusOne, (byte) 1);         Assert.assertEquals(Byte.MAX_VALUE, a);          a = MathUtils.copySign(Byte.MAX_VALUE, (byte) -1);         Assert.assertEquals(minValuePlusOne, a);          final byte one = 1;         byte val = -2;         a = MathUtils.copySign(val, one);         Assert.assertEquals(-val, a);          final byte minusOne = -one;         val = 2;         a = MathUtils.copySign(val, minusOne);         Assert.assertEquals(-val, a);          val = 0;         a = MathUtils.copySign(val, minusOne);         Assert.assertEquals(val, a);          val = 0;         a = MathUtils.copySign(val, one);         Assert.assertEquals(val, a);     }      @Test(expected=MathArithmeticException.class)     public void testCopySignByte2() {         MathUtils.copySign(Byte.MIN_VALUE, (byte) 1);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import java.util.ArrayList; import java.util.List; import java.util.Map;  import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.numbers.combinatorics.BinomialCoefficient; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link CombinatoricsUtils} class.  *  */ public class CombinatoricsUtilsTest {      /** cached binomial coefficients */     private static final List<Map<Integer, Long>> binomialCache = new ArrayList<>();      @Test     public void testStirlingS2() {          Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(0, 0));          for (int n = 1; n < 30; ++n) {             Assert.assertEquals(0, CombinatoricsUtils.stirlingS2(n, 0));             Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(n, 1));             if (n > 2) {                 Assert.assertEquals((1l << (n - 1)) - 1l, CombinatoricsUtils.stirlingS2(n, 2));                 Assert.assertEquals(BinomialCoefficient.value(n, 2),                                     CombinatoricsUtils.stirlingS2(n, n - 1));             }             Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(n, n));         }         Assert.assertEquals(536870911l, CombinatoricsUtils.stirlingS2(30, 2));         Assert.assertEquals(576460752303423487l, CombinatoricsUtils.stirlingS2(60, 2));          Assert.assertEquals(   25, CombinatoricsUtils.stirlingS2( 5, 3));         Assert.assertEquals(   90, CombinatoricsUtils.stirlingS2( 6, 3));         Assert.assertEquals(   65, CombinatoricsUtils.stirlingS2( 6, 4));         Assert.assertEquals(  301, CombinatoricsUtils.stirlingS2( 7, 3));         Assert.assertEquals(  350, CombinatoricsUtils.stirlingS2( 7, 4));         Assert.assertEquals(  140, CombinatoricsUtils.stirlingS2( 7, 5));         Assert.assertEquals(  966, CombinatoricsUtils.stirlingS2( 8, 3));         Assert.assertEquals( 1701, CombinatoricsUtils.stirlingS2( 8, 4));         Assert.assertEquals( 1050, CombinatoricsUtils.stirlingS2( 8, 5));         Assert.assertEquals(  266, CombinatoricsUtils.stirlingS2( 8, 6));         Assert.assertEquals( 3025, CombinatoricsUtils.stirlingS2( 9, 3));         Assert.assertEquals( 7770, CombinatoricsUtils.stirlingS2( 9, 4));         Assert.assertEquals( 6951, CombinatoricsUtils.stirlingS2( 9, 5));         Assert.assertEquals( 2646, CombinatoricsUtils.stirlingS2( 9, 6));         Assert.assertEquals(  462, CombinatoricsUtils.stirlingS2( 9, 7));         Assert.assertEquals( 9330, CombinatoricsUtils.stirlingS2(10, 3));         Assert.assertEquals(34105, CombinatoricsUtils.stirlingS2(10, 4));         Assert.assertEquals(42525, CombinatoricsUtils.stirlingS2(10, 5));         Assert.assertEquals(22827, CombinatoricsUtils.stirlingS2(10, 6));         Assert.assertEquals( 5880, CombinatoricsUtils.stirlingS2(10, 7));         Assert.assertEquals(  750, CombinatoricsUtils.stirlingS2(10, 8));      }      @Test(expected=NotPositiveException.class)     public void testStirlingS2NegativeN() {         CombinatoricsUtils.stirlingS2(3, -1);     }      @Test(expected=NumberIsTooLargeException.class)     public void testStirlingS2LargeK() {         CombinatoricsUtils.stirlingS2(3, 4);     }      @Test(expected=MathArithmeticException.class)     public void testStirlingS2Overflow() {         CombinatoricsUtils.stirlingS2(26, 9);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.util;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link Pair}.  */ public class PairTest {      @Test     public void testAccessor() {         final Pair<Integer, Double> p             = new Pair<>(new Integer(1), new Double(2));         Assert.assertEquals(new Integer(1), p.getKey());         Assert.assertEquals(2, p.getValue().doubleValue(), Math.ulp(1d));     }      @Test     public void testAccessor2() {         final Pair<Integer, Double> p             = new Pair<>(new Integer(1), new Double(2));          // Check that both APIs refer to the same data.          Assert.assertTrue(p.getFirst() == p.getKey());         Assert.assertTrue(p.getSecond() == p.getValue());     }      @Test     public void testEquals() {         Pair<Integer, Double> p1 = new Pair<>(null, null);         Assert.assertFalse(p1.equals(null));          Pair<Integer, Double> p2 = new Pair<>(null, null);         Assert.assertTrue(p1.equals(p2));          p1 = new Pair<>(new Integer(1), new Double(2));         Assert.assertFalse(p1.equals(p2));          p2 = new Pair<>(new Integer(1), new Double(2));         Assert.assertTrue(p1.equals(p2));          Pair<Integer, Float> p3 = new Pair<>(new Integer(1), new Float(2));         Assert.assertFalse(p1.equals(p3));     }      @Test     public void testHashCode() {         final MyInteger m1 = new MyInteger(1);         final MyInteger m2 = new MyInteger(1);          final Pair<MyInteger, MyInteger> p1 = new Pair<>(m1, m1);         final Pair<MyInteger, MyInteger> p2 = new Pair<>(m2, m2);         // Same contents, same hash code.         Assert.assertTrue(p1.hashCode() == p2.hashCode());          // Different contents, different hash codes.         m2.set(2);         Assert.assertFalse(p1.hashCode() == p2.hashCode());     }      @Test     public void testToString() {         Assert.assertEquals("[null, null]", new Pair<>(null, null).toString());         Assert.assertEquals("[foo, 3]", new Pair<>("foo", 3).toString());     }      @Test     public void testCreate() {         final Pair<String, Integer> p1 = Pair.create("foo", 3);         Assert.assertNotNull(p1);         final Pair<String, Integer> p2 = new Pair<>("foo", 3);         Assert.assertEquals(p2, p1);     }      /**      * A mutable integer.      */     private static class MyInteger {         private int i;          public MyInteger(int i) {             this.i = i;         }          public void set(int i) {             this.i = i;         }          @Override         public boolean equals(Object o) {             if (!(o instanceof MyInteger)) {                 return false;             } else {                 return i == ((MyInteger) o).i;             }         }          @Override         public int hashCode() {             return i;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import org.apache.commons.math4.ExtendedFieldElementAbstractTest; import org.junit.Assert; import org.junit.Test;  public class Decimal64Test extends ExtendedFieldElementAbstractTest<Decimal64> {     public static final double X = 1.2345;      public static final Decimal64 PLUS_X = new Decimal64(X);      public static final Decimal64 MINUS_X = new Decimal64(-X);      public static final double Y = 6.789;      public static final Decimal64 PLUS_Y = new Decimal64(Y);      public static final Decimal64 MINUS_Y = new Decimal64(-Y);      public static final Decimal64 PLUS_ZERO = new Decimal64(0.0);      public static final Decimal64 MINUS_ZERO = new Decimal64(-0.0);      @Override     protected Decimal64 build(final double x) {         return new Decimal64(x);     }      @Test     public void testAdd() {         Decimal64 expected, actual;          expected = new Decimal64(X + Y);         actual = PLUS_X.add(PLUS_Y);         Assert.assertEquals(expected, actual);         actual = PLUS_Y.add(PLUS_X);         Assert.assertEquals(expected, actual);          expected = new Decimal64(X + (-Y));         actual = PLUS_X.add(MINUS_Y);         Assert.assertEquals(expected, actual);         actual = MINUS_Y.add(PLUS_X);         Assert.assertEquals(expected, actual);          expected = new Decimal64((-X) + (-Y));         actual = MINUS_X.add(MINUS_Y);         Assert.assertEquals(expected, actual);         actual = MINUS_Y.add(MINUS_X);         Assert.assertEquals(expected, actual);          expected = Decimal64.POSITIVE_INFINITY;         actual = PLUS_X.add(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.add(PLUS_X);         Assert.assertEquals(expected, actual);         actual = MINUS_X.add(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.add(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);          expected = Decimal64.NEGATIVE_INFINITY;         actual = PLUS_X.add(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.add(PLUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = MINUS_X.add(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.add(MINUS_X);         Assert.assertEquals(expected, actual);          expected = Decimal64.NAN;         actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = PLUS_X.add(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.add(PLUS_X);         Assert.assertEquals(expected, actual);         actual = MINUS_X.add(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.add(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.add(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.add(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.add(Decimal64.NAN);         Assert.assertEquals(expected, actual);     }      @Test     public void testSubtract() {         Decimal64 expected, actual;          expected = new Decimal64(X - Y);         actual = PLUS_X.subtract(PLUS_Y);         Assert.assertEquals(expected, actual);          expected = new Decimal64(X - (-Y));         actual = PLUS_X.subtract(MINUS_Y);         Assert.assertEquals(expected, actual);          expected = new Decimal64((-X) - Y);         actual = MINUS_X.subtract(PLUS_Y);         Assert.assertEquals(expected, actual);          expected = new Decimal64((-X) - (-Y));         actual = MINUS_X.subtract(MINUS_Y);         Assert.assertEquals(expected, actual);          expected = Decimal64.NEGATIVE_INFINITY;         actual = PLUS_X.subtract(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = MINUS_X.subtract(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY                 .subtract(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);          expected = Decimal64.POSITIVE_INFINITY;         actual = PLUS_X.subtract(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = MINUS_X.subtract(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY                 .subtract(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);          expected = Decimal64.NAN;         actual = Decimal64.POSITIVE_INFINITY                 .subtract(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY                 .subtract(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = PLUS_X.subtract(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.subtract(PLUS_X);         Assert.assertEquals(expected, actual);         actual = MINUS_X.subtract(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.subtract(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.subtract(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.subtract(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.subtract(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.subtract(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.subtract(Decimal64.NAN);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegate() {         Decimal64 expected, actual;          expected = MINUS_X;         actual = PLUS_X.negate();         Assert.assertEquals(expected, actual);          expected = PLUS_X;         actual = MINUS_X.negate();         Assert.assertEquals(expected, actual);          expected = MINUS_ZERO;         actual = PLUS_ZERO.negate();         Assert.assertEquals(expected, actual);          expected = PLUS_ZERO;         actual = MINUS_ZERO.negate();         Assert.assertEquals(expected, actual);          expected = Decimal64.POSITIVE_INFINITY;         actual = Decimal64.NEGATIVE_INFINITY.negate();         Assert.assertEquals(expected, actual);          expected = Decimal64.NEGATIVE_INFINITY;         actual = Decimal64.POSITIVE_INFINITY.negate();         Assert.assertEquals(expected, actual);          expected = Decimal64.NAN;         actual = Decimal64.NAN.negate();         Assert.assertEquals(expected, actual);     }      @Test     public void testMultiply() {         Decimal64 expected, actual;          expected = new Decimal64(X * Y);         actual = PLUS_X.multiply(PLUS_Y);         Assert.assertEquals(expected, actual);         actual = PLUS_Y.multiply(PLUS_X);         Assert.assertEquals(expected, actual);          expected = new Decimal64(X * (-Y));         actual = PLUS_X.multiply(MINUS_Y);         Assert.assertEquals(expected, actual);         actual = MINUS_Y.multiply(PLUS_X);         Assert.assertEquals(expected, actual);          expected = new Decimal64((-X) * (-Y));         actual = MINUS_X.multiply(MINUS_Y);         Assert.assertEquals(expected, actual);         actual = MINUS_Y.multiply(MINUS_X);         Assert.assertEquals(expected, actual);          expected = Decimal64.POSITIVE_INFINITY;         actual = PLUS_X.multiply(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.multiply(PLUS_X);         Assert.assertEquals(expected, actual);         actual = MINUS_X.multiply(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.multiply(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY                 .multiply(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY                 .multiply(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);          expected = Decimal64.NEGATIVE_INFINITY;         actual = PLUS_X.multiply(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.multiply(PLUS_X);         Assert.assertEquals(expected, actual);         actual = MINUS_X.multiply(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.multiply(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY                 .multiply(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY                 .multiply(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);          expected = Decimal64.NAN;         actual = PLUS_X.multiply(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.multiply(PLUS_X);         Assert.assertEquals(expected, actual);         actual = MINUS_X.multiply(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.multiply(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.multiply(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.multiply(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.multiply(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.multiply(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.multiply(Decimal64.NAN);         Assert.assertEquals(expected, actual);     }      @Test     public void testDivide() {         Decimal64 expected, actual;          expected = new Decimal64(X / Y);         actual = PLUS_X.divide(PLUS_Y);         Assert.assertEquals(expected, actual);          expected = new Decimal64(X / (-Y));         actual = PLUS_X.divide(MINUS_Y);         Assert.assertEquals(expected, actual);          expected = new Decimal64((-X) / Y);         actual = MINUS_X.divide(PLUS_Y);         Assert.assertEquals(expected, actual);          expected = new Decimal64((-X) / (-Y));         actual = MINUS_X.divide(MINUS_Y);         Assert.assertEquals(expected, actual);          expected = PLUS_ZERO;         actual = PLUS_X.divide(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = MINUS_X.divide(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);          expected = MINUS_ZERO;         actual = MINUS_X.divide(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = PLUS_X.divide(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);          expected = Decimal64.POSITIVE_INFINITY;         actual = Decimal64.POSITIVE_INFINITY.divide(PLUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.divide(MINUS_X);         Assert.assertEquals(expected, actual);         actual = PLUS_X.divide(PLUS_ZERO);         Assert.assertEquals(expected, actual);         actual = MINUS_X.divide(MINUS_ZERO);         Assert.assertEquals(expected, actual);          expected = Decimal64.NEGATIVE_INFINITY;         actual = Decimal64.POSITIVE_INFINITY.divide(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.divide(PLUS_X);         Assert.assertEquals(expected, actual);         actual = PLUS_X.divide(MINUS_ZERO);         Assert.assertEquals(expected, actual);         actual = MINUS_X.divide(PLUS_ZERO);         Assert.assertEquals(expected, actual);          expected = Decimal64.NAN;         actual = Decimal64.POSITIVE_INFINITY                 .divide(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY                 .divide(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY                 .divide(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY                 .divide(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = PLUS_X.divide(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.divide(PLUS_X);         Assert.assertEquals(expected, actual);         actual = MINUS_X.divide(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.divide(MINUS_X);         Assert.assertEquals(expected, actual);         actual = Decimal64.POSITIVE_INFINITY.divide(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.divide(Decimal64.POSITIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NEGATIVE_INFINITY.divide(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.divide(Decimal64.NEGATIVE_INFINITY);         Assert.assertEquals(expected, actual);         actual = Decimal64.NAN.divide(Decimal64.NAN);         Assert.assertEquals(expected, actual);         actual = PLUS_ZERO.divide(PLUS_ZERO);         Assert.assertEquals(expected, actual);         actual = PLUS_ZERO.divide(MINUS_ZERO);         Assert.assertEquals(expected, actual);         actual = MINUS_ZERO.divide(PLUS_ZERO);         Assert.assertEquals(expected, actual);         actual = MINUS_ZERO.divide(MINUS_ZERO);         Assert.assertEquals(expected, actual);     }      @Test     public void testReciprocal() {         Decimal64 expected, actual;          expected = new Decimal64(1.0 / X);         actual = PLUS_X.reciprocal();         Assert.assertEquals(expected, actual);          expected = new Decimal64(1.0 / (-X));         actual = MINUS_X.reciprocal();         Assert.assertEquals(expected, actual);          expected = PLUS_ZERO;         actual = Decimal64.POSITIVE_INFINITY.reciprocal();         Assert.assertEquals(expected, actual);          expected = MINUS_ZERO;         actual = Decimal64.NEGATIVE_INFINITY.reciprocal();         Assert.assertEquals(expected, actual);     }      @Test     public void testIsInfinite() {         Assert.assertFalse(MINUS_X.isInfinite());         Assert.assertFalse(PLUS_X.isInfinite());         Assert.assertFalse(MINUS_Y.isInfinite());         Assert.assertFalse(PLUS_Y.isInfinite());         Assert.assertFalse(Decimal64.NAN.isInfinite());          Assert.assertTrue(Decimal64.NEGATIVE_INFINITY.isInfinite());         Assert.assertTrue(Decimal64.POSITIVE_INFINITY.isInfinite());     }      @Test     public void testIsNaN() {         Assert.assertFalse(MINUS_X.isNaN());         Assert.assertFalse(PLUS_X.isNaN());         Assert.assertFalse(MINUS_Y.isNaN());         Assert.assertFalse(PLUS_Y.isNaN());         Assert.assertFalse(Decimal64.NEGATIVE_INFINITY.isNaN());         Assert.assertFalse(Decimal64.POSITIVE_INFINITY.isNaN());          Assert.assertTrue(Decimal64.NAN.isNaN());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import org.apache.commons.statistics.distribution.DiscreteDistribution; import org.apache.commons.statistics.distribution.UniformDiscreteDistribution; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.ResizableDoubleArray.ExpansionMode; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;   /**  * This class contains test cases for the ResizableDoubleArray.  */ public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {      @After     public void tearDown() throws Exception {         da = null;         ra = null;     }      @Before     public void setUp() throws Exception {         da = new ResizableDoubleArray();         ra = new ResizableDoubleArray();     }      @Test     public void testConstructors() {         float defaultExpansionFactor = 2.0f;         double defaultContractionCriteria = 2.5;         ExpansionMode defaultMode = ResizableDoubleArray.ExpansionMode.MULTIPLICATIVE;          ResizableDoubleArray testDa = new ResizableDoubleArray(2);         Assert.assertEquals(0, testDa.getNumElements());         Assert.assertEquals(2, testDa.getCapacity());         Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);         Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriterion(), 0);         Assert.assertEquals(defaultMode, testDa.getExpansionMode());         try {             da = new ResizableDoubleArray(-1);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }          testDa = new ResizableDoubleArray((double[]) null);         Assert.assertEquals(0, testDa.getNumElements());          double[] initialArray = new double[] { 0, 1, 2 };         testDa = new ResizableDoubleArray(initialArray);         Assert.assertEquals(3, testDa.getNumElements());          testDa = new ResizableDoubleArray(2, 2.0);         Assert.assertEquals(0, testDa.getNumElements());         Assert.assertEquals(2, testDa.getCapacity());         Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);         Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriterion(), 0);         Assert.assertEquals(defaultMode, testDa.getExpansionMode());          try {             da = new ResizableDoubleArray(2, 0.5);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }          testDa = new ResizableDoubleArray(2, 3.0);         Assert.assertEquals(3.0f, testDa.getExpansionFactor(), 0);         Assert.assertEquals(3.5f, testDa.getContractionCriterion(), 0);          testDa = new ResizableDoubleArray(2, 2.0, 3.0);         Assert.assertEquals(0, testDa.getNumElements());         Assert.assertEquals(2, testDa.getCapacity());         Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);         Assert.assertEquals(3.0f, testDa.getContractionCriterion(), 0);         Assert.assertEquals(defaultMode, testDa.getExpansionMode());          try {             da = new ResizableDoubleArray(2, 2.0, 1.5);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }          testDa = new ResizableDoubleArray(2, 2.0, 3.0, ResizableDoubleArray.ExpansionMode.ADDITIVE);         Assert.assertEquals(0, testDa.getNumElements());         Assert.assertEquals(2, testDa.getCapacity());         Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);         Assert.assertEquals(3.0f, testDa.getContractionCriterion(), 0);         Assert.assertEquals(ResizableDoubleArray.ExpansionMode.ADDITIVE, testDa.getExpansionMode());          try {             da = new ResizableDoubleArray(2, 2.0d, 2.5d, null);             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }          // Copy constructor         testDa = new ResizableDoubleArray(2, 2.0, 3.0,                                           ResizableDoubleArray.ExpansionMode.ADDITIVE);         testDa.addElement(2.0);         testDa.addElement(3.2);         ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);         Assert.assertEquals(copyDa, testDa);         Assert.assertEquals(testDa, copyDa);          // JIRA: MATH-1252         final double[] values = {1};         testDa = new ResizableDoubleArray(values);         Assert.assertArrayEquals(values, testDa.getElements(), 0);         Assert.assertEquals(1, testDa.getNumElements());         Assert.assertEquals(1, testDa.getElement(0), 0);     }      @Test     public void testSetElementArbitraryExpansion1() {          // MULTIPLICATIVE_MODE         da.addElement(2.0);         da.addElement(4.0);         da.addElement(6.0);         da.setElement(1, 3.0);          // Expand the array arbitrarily to 1000 items         da.setElement(1000, 3.4);          Assert.assertEquals( "The number of elements should now be 1001, it isn't",                 da.getNumElements(), 1001);          Assert.assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,                 da.getElement( 760 ), Double.MIN_VALUE );          Assert.assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000),                 Double.MIN_VALUE );         Assert.assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0),                 Double.MIN_VALUE);     }      @Test     public void testSetElementArbitraryExpansion2() {         // Make sure numElements and expansion work correctly for expansion boundary cases         da.addElement(2.0);         da.addElement(4.0);         da.addElement(6.0);         Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity());         Assert.assertEquals(3, da.getNumElements());         da.setElement(3, 7.0);         Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity());         Assert.assertEquals(4, da.getNumElements());         da.setElement(10, 10.0);         Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity());         Assert.assertEquals(11, da.getNumElements());         da.setElement(9, 10.0);         Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity());         Assert.assertEquals(11, da.getNumElements());          try {             da.setElement(-2, 3);             Assert.fail("Expecting ArrayIndexOutOfBoundsException for negative index");         } catch (ArrayIndexOutOfBoundsException ex) {             // expected         }          // ADDITIVE_MODE          ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0, 3.0,                                                                ResizableDoubleArray.ExpansionMode.ADDITIVE);         Assert.assertEquals(2, testDa.getCapacity());         testDa.addElement(1d);         testDa.addElement(1d);         Assert.assertEquals(2, testDa.getCapacity());         testDa.addElement(1d);         Assert.assertEquals(4, testDa.getCapacity());     }      @Override     @Test     public void testAdd1000() {         super.testAdd1000();         Assert.assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +                 "16 and an expansion factor of 2.0",                 1024, ((ResizableDoubleArray) da).getCapacity());     }      @Test     public void testAddElements() {         ResizableDoubleArray testDa = new ResizableDoubleArray();          // MULTIPLICATIVE_MODE         testDa.addElements(new double[] {4, 5, 6});         Assert.assertEquals(3, testDa.getNumElements(), 0);         Assert.assertEquals(4, testDa.getElement(0), 0);         Assert.assertEquals(5, testDa.getElement(1), 0);         Assert.assertEquals(6, testDa.getElement(2), 0);          testDa.addElements(new double[] {4, 5, 6});         Assert.assertEquals(6, testDa.getNumElements());          // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)         testDa = new ResizableDoubleArray(2, 2.0, 2.5,                                           ResizableDoubleArray.ExpansionMode.ADDITIVE);         Assert.assertEquals(2, testDa.getCapacity());         testDa.addElements(new double[] { 1d }); // x,0         testDa.addElements(new double[] { 2d }); // x,x         testDa.addElements(new double[] { 3d }); // x,x,x,0 -- expanded         Assert.assertEquals(1d, testDa.getElement(0), 0);         Assert.assertEquals(2d, testDa.getElement(1), 0);         Assert.assertEquals(3d, testDa.getElement(2), 0);         Assert.assertEquals(4, testDa.getCapacity());  // x,x,x,0         Assert.assertEquals(3, testDa.getNumElements());     }      @Override     @Test     public void testAddElementRolling() {         super.testAddElementRolling();          // MULTIPLICATIVE_MODE         da.clear();         da.addElement(1);         da.addElement(2);         da.addElementRolling(3);         Assert.assertEquals(3, da.getElement(1), 0);         da.addElementRolling(4);         Assert.assertEquals(3, da.getElement(0), 0);         Assert.assertEquals(4, da.getElement(1), 0);         da.addElement(5);         Assert.assertEquals(5, da.getElement(2), 0);         da.addElementRolling(6);         Assert.assertEquals(4, da.getElement(0), 0);         Assert.assertEquals(5, da.getElement(1), 0);         Assert.assertEquals(6, da.getElement(2), 0);          // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)         ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0, 2.5,                                                                ResizableDoubleArray.ExpansionMode.ADDITIVE);         Assert.assertEquals(2, testDa.getCapacity());         testDa.addElement(1d); // x,0         testDa.addElement(2d); // x,x         testDa.addElement(3d); // x,x,x,0 -- expanded         Assert.assertEquals(1d, testDa.getElement(0), 0);         Assert.assertEquals(2d, testDa.getElement(1), 0);         Assert.assertEquals(3d, testDa.getElement(2), 0);         Assert.assertEquals(4, testDa.getCapacity());  // x,x,x,0         Assert.assertEquals(3, testDa.getNumElements());         testDa.addElementRolling(4d);         Assert.assertEquals(2d, testDa.getElement(0), 0);         Assert.assertEquals(3d, testDa.getElement(1), 0);         Assert.assertEquals(4d, testDa.getElement(2), 0);         Assert.assertEquals(4, testDa.getCapacity());  // 0,x,x,x         Assert.assertEquals(3, testDa.getNumElements());         testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract         Assert.assertEquals(3d, testDa.getElement(0), 0);         Assert.assertEquals(4d, testDa.getElement(1), 0);         Assert.assertEquals(5d, testDa.getElement(2), 0);         Assert.assertEquals(4, testDa.getCapacity());  // contracted -- x,x,x,0         Assert.assertEquals(3, testDa.getNumElements());         try {             testDa.getElement(4);             Assert.fail("Expecting ArrayIndexOutOfBoundsException");         } catch (ArrayIndexOutOfBoundsException ex) {             // expected         }         try {             testDa.getElement(-1);             Assert.fail("Expecting ArrayIndexOutOfBoundsException");         } catch (ArrayIndexOutOfBoundsException ex) {             // expected         }     }      @Test     public void testSetNumberOfElements() {         da.addElement( 1.0 );         da.addElement( 1.0 );         da.addElement( 1.0 );         da.addElement( 1.0 );         da.addElement( 1.0 );         da.addElement( 1.0 );         Assert.assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);          ((ResizableDoubleArray) da).setNumElements( 3 );         Assert.assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);          try {             ((ResizableDoubleArray) da).setNumElements( -3 );             Assert.fail( "Setting number of elements to negative should've thrown an exception");         } catch(MathIllegalArgumentException iae) {         }          ((ResizableDoubleArray) da).setNumElements(1024);         Assert.assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);         Assert.assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);      }      @Test     public void testWithInitialCapacity() {          ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);         Assert.assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());          final DiscreteDistribution.Sampler randomData =             new UniformDiscreteDistribution(100, 1000).createSampler(RandomSource.create(RandomSource.WELL_19937_C));         final int iterations = randomData.sample();          for( int i = 0; i < iterations; i++) {             eDA2.addElement( i );         }          Assert.assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements());          eDA2.addElement( 2.0 );          Assert.assertEquals("Number of elements should be equals to " + (iterations +1),                 iterations + 1 , eDA2.getNumElements() );     }      @Test     public void testWithInitialCapacityAndExpansionFactor() {          ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0, 3.5);         Assert.assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );          final DiscreteDistribution.Sampler randomData =             new UniformDiscreteDistribution(100, 3000).createSampler(RandomSource.create(RandomSource.WELL_19937_C));          final int iterations = randomData.sample();          for( int i = 0; i < iterations; i++) {             eDA3.addElement( i );         }          Assert.assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements());          eDA3.addElement( 2.0 );          Assert.assertEquals("Number of elements should be equals to " + (iterations +1),                 iterations +1, eDA3.getNumElements() );          Assert.assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);     }      @Test     public void testDiscard() {         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements());          ((ResizableDoubleArray)da).discardFrontElements(5);         Assert.assertEquals( "Number of elements should be 6", 6, da.getNumElements());          da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         Assert.assertEquals( "Number of elements should be 10", 10, da.getNumElements());          ((ResizableDoubleArray)da).discardMostRecentElements(2);         Assert.assertEquals( "Number of elements should be 8", 8, da.getNumElements());          try {             ((ResizableDoubleArray)da).discardFrontElements(-1);             Assert.fail( "Trying to discard a negative number of element is not allowed");         } catch( Exception e ){         }          try {             ((ResizableDoubleArray)da).discardMostRecentElements(-1);             Assert.fail( "Trying to discard a negative number of element is not allowed");         } catch( Exception e ){         }          try {             ((ResizableDoubleArray)da).discardFrontElements( 10000 );             Assert.fail( "You can't discard more elements than the array contains");         } catch( Exception e ){         }          try {             ((ResizableDoubleArray)da).discardMostRecentElements( 10000 );             Assert.fail( "You can't discard more elements than the array contains");         } catch( Exception e ){         }      }      @Test     public void testSubstitute() {          da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         da.addElement(2.0);         Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements());          ((ResizableDoubleArray)da).substituteMostRecentElement(24);          Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements());          try {             ((ResizableDoubleArray)da).discardMostRecentElements(10);         } catch( Exception e ){             Assert.fail( "Trying to discard a negative number of element is not allowed");         }          ((ResizableDoubleArray)da).substituteMostRecentElement(24);          Assert.assertEquals( "Number of elements should be 1", 1, da.getNumElements());      }      @Test     public void testEqualsAndHashCode() throws Exception {          // Wrong type         ResizableDoubleArray first = new ResizableDoubleArray();         Double other = new Double(2);         Assert.assertFalse(first.equals(other));          // Null         other = null;         Assert.assertFalse(first.equals(other));          // Reflexive         Assert.assertTrue(first.equals(first));          // Non-argument constructor         ResizableDoubleArray second = new ResizableDoubleArray();         verifyEquality(first, second);          // Equals iff same data, same properties         ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0, 2.0);         verifyInequality(third, first);         ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0, 2.0);         ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0, 2.0);         verifyEquality(third, fourth);         verifyInequality(third, fifth);         third.addElement(4.1);         third.addElement(4.2);         third.addElement(4.3);         fourth.addElement(4.1);         fourth.addElement(4.2);         fourth.addElement(4.3);         verifyEquality(third, fourth);          // expand         fourth.addElement(4.4);         verifyInequality(third, fourth);         third.addElement(4.4);         verifyEquality(third, fourth);         fourth.addElement(4.4);         verifyInequality(third, fourth);         third.addElement(4.4);         verifyEquality(third, fourth);         fourth.addElementRolling(4.5);         third.addElementRolling(4.5);         verifyEquality(third, fourth);          // discard         third.discardFrontElements(1);         verifyInequality(third, fourth);         fourth.discardFrontElements(1);         verifyEquality(third, fourth);          // discard recent         third.discardMostRecentElements(2);         fourth.discardMostRecentElements(2);         verifyEquality(third, fourth);          // wrong order         third.addElement(18);         fourth.addElement(17);         third.addElement(17);         fourth.addElement(18);         verifyInequality(third, fourth);          // Copy constructor         verifyEquality(fourth, new ResizableDoubleArray(fourth));          // Instance copy         verifyEquality(fourth, fourth.copy());      }      @Test     public void testGetArrayRef() {         final ResizableDoubleArray a = new ResizableDoubleArray();          // Modify "a" through the public API.         final int index = 20;         final double v1 = 1.2;         a.setElement(index, v1);          // Modify the internal storage through the protected API.         final double v2 = v1 + 3.4;         final double[] aInternalArray = a.getArrayRef();         aInternalArray[a.getStartIndex() + index] = v2;          Assert.assertEquals(v2, a.getElement(index), 0d);     }      @Test     public void testCompute() {         final ResizableDoubleArray a = new ResizableDoubleArray();         final int max = 20;         for (int i = 1; i <= max; i++) {             a.setElement(i, i);         }          final MathArrays.Function add = new MathArrays.Function() {                 @Override                 public double evaluate(double[] a, int index, int num) {                     double sum = 0;                     final int max = index + num;                     for (int i = index; i < max; i++) {                         sum += a[i];                     }                     return sum;                 }                 @Override                 public double evaluate(double[] a) {                     return evaluate(a, 0, a.length);                 }             };          final double sum = a.compute(add);         Assert.assertEquals(0.5 * max * (max + 1), sum, 0);     }      private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {         Assert.assertTrue(b.equals(a));         Assert.assertTrue(a.equals(b));         Assert.assertEquals(a.hashCode(), b.hashCode());     }      private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {         Assert.assertFalse(b.equals(a));         Assert.assertFalse(a.equals(b));         Assert.assertFalse(a.hashCode() == b.hashCode());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import java.math.BigDecimal; import java.math.BigInteger; import java.math.MathContext;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathArithmeticException; import org.junit.Assert; import org.junit.Test;  public class BigRealTest {      @Test     public void testConstructor() {         Assert.assertEquals(1.625,                             new BigReal(new BigDecimal("1.625")).doubleValue(),                             1.0e-15);         Assert.assertEquals(-5.0,                             new BigReal(new BigInteger("-5")).doubleValue(),                             1.0e-15);         Assert.assertEquals(-5.0, new BigReal(new BigInteger("-5"),                                               MathContext.DECIMAL64)             .doubleValue(), 1.0e-15);         Assert             .assertEquals(0.125,                           new BigReal(new BigInteger("125"), 3).doubleValue(),                           1.0e-15);         Assert.assertEquals(0.125, new BigReal(new BigInteger("125"), 3,                                                MathContext.DECIMAL64)             .doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal(new char[] {             '1', '.', '6', '2', '5'         }).doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal(new char[] {             'A', 'A', '1', '.', '6', '2', '5', '9'         }, 2, 5).doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal(new char[] {             'A', 'A', '1', '.', '6', '2', '5', '9'         }, 2, 5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal(new char[] {             '1', '.', '6', '2', '5'         }, MathContext.DECIMAL64).doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal(1.625).doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal(1.625, MathContext.DECIMAL64)             .doubleValue(), 1.0e-15);         Assert.assertEquals(-5.0, new BigReal(-5).doubleValue(), 1.0e-15);         Assert.assertEquals(-5.0, new BigReal(-5, MathContext.DECIMAL64)             .doubleValue(), 1.0e-15);         Assert.assertEquals(-5.0, new BigReal(-5l).doubleValue(), 1.0e-15);         Assert.assertEquals(-5.0, new BigReal(-5l, MathContext.DECIMAL64)             .doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal("1.625").doubleValue(), 1.0e-15);         Assert.assertEquals(1.625, new BigReal("1.625", MathContext.DECIMAL64)             .doubleValue(), 1.0e-15);     }      @Test     public void testCompareTo() {         BigReal first = new BigReal(1.0 / 2.0);         BigReal second = new BigReal(1.0 / 3.0);         BigReal third = new BigReal(1.0 / 2.0);          Assert.assertEquals(0, first.compareTo(first));         Assert.assertEquals(0, first.compareTo(third));         Assert.assertEquals(1, first.compareTo(second));         Assert.assertEquals(-1, second.compareTo(first));      }      @Test     public void testAdd() {         BigReal a = new BigReal("1.2345678");         BigReal b = new BigReal("8.7654321");         Assert.assertEquals(9.9999999, a.add(b).doubleValue(), 1.0e-15);     }      @Test     public void testSubtract() {         BigReal a = new BigReal("1.2345678");         BigReal b = new BigReal("8.7654321");         Assert.assertEquals(-7.5308643, a.subtract(b).doubleValue(), 1.0e-15);     }      @Test     public void testNegate() {         BigReal a = new BigReal("1.2345678");         BigReal zero = new BigReal("0.0000000");         Assert.assertEquals(a.negate().add(a), zero);         Assert.assertEquals(a.add(a.negate()), zero);         Assert.assertEquals(zero, zero.negate());     }      @Test     public void testDivide() {         BigReal a = new BigReal("1.0000000000");         BigReal b = new BigReal("0.0009765625");         Assert.assertEquals(1024.0, a.divide(b).doubleValue(), 1.0e-15);     }      @Test(expected = MathArithmeticException.class)     public void testDivisionByZero() {         final BigReal a = BigReal.ONE;         final BigReal b = BigReal.ZERO;         a.divide(b);     }      @Test     public void testReciprocal() {         BigReal a = new BigReal("1.2345678");         double eps = FastMath.pow(10., -a.getScale());         BigReal one = new BigReal("1.0000000");         BigReal b = a.reciprocal();         BigReal r = one.subtract(a.multiply(b));         Assert.assertTrue(FastMath.abs(r.doubleValue()) <= eps);         r = one.subtract(b.multiply(a));         Assert.assertTrue(FastMath.abs(r.doubleValue()) <= eps);     }      @Test(expected = MathArithmeticException.class)     public void testReciprocalOfZero() {         BigReal.ZERO.reciprocal();     }      @Test     public void testMultiply() {         BigReal a = new BigReal("1024.0");         BigReal b = new BigReal("0.0009765625");         Assert.assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15);         int n = 1024;         Assert.assertEquals(1.0, b.multiply(n).doubleValue(), 1.0e-15);     }      @Test     public void testDoubleValue() {         Assert.assertEquals(0.5, new BigReal(0.5).doubleValue(), 1.0e-15);     }      @Test     public void testBigDecimalValue() {         BigDecimal pi = new BigDecimal(                                        "3.1415926535897932384626433832795028841971693993751");         Assert.assertEquals(pi, new BigReal(pi).bigDecimalValue());         Assert.assertEquals(new BigDecimal(0.5),                             new BigReal(1.0 / 2.0).bigDecimalValue());     }      @Test     public void testEqualsAndHashCode() {         BigReal zero = new BigReal(0.0);         BigReal nullReal = null;         Assert.assertTrue(zero.equals(zero));         Assert.assertFalse(zero.equals(nullReal));         Assert.assertFalse(zero.equals(Double.valueOf(0)));         BigReal zero2 = new BigReal(0.0);         Assert.assertTrue(zero.equals(zero2));         Assert.assertEquals(zero.hashCode(), zero2.hashCode());         BigReal one = new BigReal(1.0);         Assert.assertFalse((one.equals(zero) || zero.equals(one)));         Assert.assertTrue(one.equals(BigReal.ONE));     }      @Test     public void testSerial() {         BigReal[] Reals = {             new BigReal(3.0), BigReal.ONE, BigReal.ZERO, new BigReal(17),             new BigReal(FastMath.PI), new BigReal(-2.5)         };         for (BigReal Real : Reals) {             Assert.assertEquals(Real, TestUtils.serializeAndRecover(Real));         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.util;  import java.math.BigDecimal;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test;  /**  */ public class DefaultTransformerTest {     /**      *      */     @Test     public void testTransformDouble() throws Exception {         double expected = 1.0;         Double input = Double.valueOf(expected);         DefaultTransformer t = new DefaultTransformer();         Assert.assertEquals(expected, t.transform(input), 1.0e-4);     }      /**      *      */     @Test     public void testTransformNull() throws Exception {         DefaultTransformer t = new DefaultTransformer();         try {             t.transform(null);             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException e) {             // expected         }     }      /**      *      */     @Test     public void testTransformInteger() throws Exception {         double expected = 1.0;         Integer input = Integer.valueOf(1);         DefaultTransformer t = new DefaultTransformer();         Assert.assertEquals(expected, t.transform(input), 1.0e-4);     }      /**      *      */     @Test     public void testTransformBigDecimal() throws Exception {         double expected = 1.0;         BigDecimal input = new BigDecimal("1.0");         DefaultTransformer t = new DefaultTransformer();         Assert.assertEquals(expected, t.transform(input), 1.0e-4);     }      /**      *      */     @Test     public void testTransformString() throws Exception {         double expected = 1.0;         String input = "1.0";         DefaultTransformer t = new DefaultTransformer();         Assert.assertEquals(expected, t.transform(input), 1.0e-4);     }      /**      *      */     @Test(expected=MathIllegalArgumentException.class)     public void testTransformObject(){         Boolean input = Boolean.TRUE;         DefaultTransformer t = new DefaultTransformer();         t.transform(input);     }      @Test     public void testSerial() {         Assert.assertEquals(new DefaultTransformer(), TestUtils.serializeAndRecover(new DefaultTransformer()));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.util;  import java.util.Arrays;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NotANumberException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link MathArrays} class.  *  */ public class MathArraysTest {      private double[] testArray = {0, 1, 2, 3, 4, 5};     private double[] testWeightsArray = {0.3, 0.2, 1.3, 1.1, 1.0, 1.8};     private double[] testNegativeWeightsArray = {-0.3, 0.2, -1.3, 1.1, 1.0, 1.8};     private double[] nullArray = null;     private double[] singletonArray = {0};      @Test     public void testScale() {         final double[] test = new double[] { -2.5, -1, 0, 1, 2.5 };         final double[] correctTest = Arrays.copyOf(test, test.length);         final double[] correctScaled = new double[]{5.25, 2.1, 0, -2.1, -5.25};          final double[] scaled = MathArrays.scale(-2.1, test);          // Make sure test has not changed         for (int i = 0; i < test.length; i++) {             Assert.assertEquals(correctTest[i], test[i], 0);         }          // Test scaled values         for (int i = 0; i < scaled.length; i++) {             Assert.assertEquals(correctScaled[i], scaled[i], 0);         }     }      @Test     public void testScaleInPlace() {         final double[] test = new double[] { -2.5, -1, 0, 1, 2.5 };         final double[] correctScaled = new double[]{5.25, 2.1, 0, -2.1, -5.25};         MathArrays.scaleInPlace(-2.1, test);          // Make sure test has changed         for (int i = 0; i < test.length; i++) {             Assert.assertEquals(correctScaled[i], test[i], 0);         }     }      @Test(expected=DimensionMismatchException.class)     public void testEbeAddPrecondition() {         MathArrays.ebeAdd(new double[3], new double[4]);     }     @Test(expected=DimensionMismatchException.class)     public void testEbeSubtractPrecondition() {         MathArrays.ebeSubtract(new double[3], new double[4]);     }     @Test(expected=DimensionMismatchException.class)     public void testEbeMultiplyPrecondition() {         MathArrays.ebeMultiply(new double[3], new double[4]);     }     @Test(expected=DimensionMismatchException.class)     public void testEbeDividePrecondition() {         MathArrays.ebeDivide(new double[3], new double[4]);     }      @Test     public void testEbeAdd() {         final double[] a = { 0, 1, 2 };         final double[] b = { 3, 5, 7 };         final double[] r = MathArrays.ebeAdd(a, b);          for (int i = 0; i < a.length; i++) {             Assert.assertEquals(a[i] + b[i], r[i], 0);         }     }     @Test     public void testEbeSubtract() {         final double[] a = { 0, 1, 2 };         final double[] b = { 3, 5, 7 };         final double[] r = MathArrays.ebeSubtract(a, b);          for (int i = 0; i < a.length; i++) {             Assert.assertEquals(a[i] - b[i], r[i], 0);         }     }     @Test     public void testEbeMultiply() {         final double[] a = { 0, 1, 2 };         final double[] b = { 3, 5, 7 };         final double[] r = MathArrays.ebeMultiply(a, b);          for (int i = 0; i < a.length; i++) {             Assert.assertEquals(a[i] * b[i], r[i], 0);         }     }     @Test     public void testEbeDivide() {         final double[] a = { 0, 1, 2 };         final double[] b = { 3, 5, 7 };         final double[] r = MathArrays.ebeDivide(a, b);          for (int i = 0; i < a.length; i++) {             Assert.assertEquals(a[i] / b[i], r[i], 0);         }     }      @Test     public void testL1DistanceDouble() {         double[] p1 = { 2.5,  0.0 };         double[] p2 = { -0.5, 4.0 };         Assert.assertTrue(Precision.equals(7.0, MathArrays.distance1(p1, p2), 1));     }      @Test     public void testL1DistanceInt() {         int[] p1 = { 3, 0 };         int[] p2 = { 0, 4 };         Assert.assertEquals(7, MathArrays.distance1(p1, p2));     }      @Test     public void testL2DistanceDouble() {         double[] p1 = { 2.5,  0.0 };         double[] p2 = { -0.5, 4.0 };         Assert.assertTrue(Precision.equals(5.0, MathArrays.distance(p1, p2), 1));     }      @Test     public void testL2DistanceInt() {         int[] p1 = { 3, 0 };         int[] p2 = { 0, 4 };         Assert.assertTrue(Precision.equals(5, MathArrays.distance(p1, p2), 1));     }      @Test     public void testLInfDistanceDouble() {         double[] p1 = { 2.5,  0.0 };         double[] p2 = { -0.5, 4.0 };         Assert.assertTrue(Precision.equals(4.0, MathArrays.distanceInf(p1, p2), 1));     }      @Test     public void testLInfDistanceInt() {         int[] p1 = { 3, 0 };         int[] p2 = { 0, 4 };         Assert.assertEquals(4, MathArrays.distanceInf(p1, p2));     }      @Test     public void testCheckOrder() {         MathArrays.checkOrder(new double[] {-15, -5.5, -1, 2, 15},                              MathArrays.OrderDirection.INCREASING, true);         MathArrays.checkOrder(new double[] {-15, -5.5, -1, 2, 2},                              MathArrays.OrderDirection.INCREASING, false);         MathArrays.checkOrder(new double[] {3, -5.5, -11, -27.5},                              MathArrays.OrderDirection.DECREASING, true);         MathArrays.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5},                              MathArrays.OrderDirection.DECREASING, false);          try {             MathArrays.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15},                                  MathArrays.OrderDirection.INCREASING, true);             Assert.fail("an exception should have been thrown");         } catch (NonMonotonicSequenceException e) {             // Expected         }         try {             MathArrays.checkOrder(new double[] {-15, -5.5, -1, -2, 2},                                  MathArrays.OrderDirection.INCREASING, false);             Assert.fail("an exception should have been thrown");         } catch (NonMonotonicSequenceException e) {             // Expected         }         try {             MathArrays.checkOrder(new double[] {3, 3, -5.5, -11, -27.5},                                  MathArrays.OrderDirection.DECREASING, true);             Assert.fail("an exception should have been thrown");         } catch (NonMonotonicSequenceException e) {             // Expected         }         try {             MathArrays.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5},                                  MathArrays.OrderDirection.DECREASING, false);             Assert.fail("an exception should have been thrown");         } catch (NonMonotonicSequenceException e) {             // Expected         }         try {             MathArrays.checkOrder(new double[] {3, 0, -5.5, -11, -10},                                  MathArrays.OrderDirection.DECREASING, false);             Assert.fail("an exception should have been thrown");         } catch (NonMonotonicSequenceException e) {             // Expected         }     }      @Test     public void testIsMonotonic() {         Assert.assertFalse(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -1, 2, 15 },                                                   MathArrays.OrderDirection.INCREASING, true));         Assert.assertTrue(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, 0, 2, 15 },                                                  MathArrays.OrderDirection.INCREASING, true));         Assert.assertFalse(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -2, 2 },                                                   MathArrays.OrderDirection.INCREASING, false));         Assert.assertTrue(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -1, 2 },                                                  MathArrays.OrderDirection.INCREASING, false));         Assert.assertFalse(MathArrays.isMonotonic(new double[] { 3, 3, -5.5, -11, -27.5 },                                                   MathArrays.OrderDirection.DECREASING, true));         Assert.assertTrue(MathArrays.isMonotonic(new double[] { 3, 2, -5.5, -11, -27.5 },                                                  MathArrays.OrderDirection.DECREASING, true));         Assert.assertFalse(MathArrays.isMonotonic(new double[] { 3, -1, 0, -5.5, -11, -27.5 },                                                   MathArrays.OrderDirection.DECREASING, false));         Assert.assertTrue(MathArrays.isMonotonic(new double[] { 3, 0, 0, -5.5, -11, -27.5 },                                                  MathArrays.OrderDirection.DECREASING, false));     }      @Test     public void testIsMonotonicComparable() {         Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(-15),                                                                  new Double(-5.5),                                                                  new Double(-1),                                                                  new Double(-1),                                                                  new Double(2),                                                                  new Double(15) },                 MathArrays.OrderDirection.INCREASING, true));         Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(-15),                                                                 new Double(-5.5),                                                                 new Double(-1),                                                                 new Double(0),                                                                 new Double(2),                                                                 new Double(15) },                 MathArrays.OrderDirection.INCREASING, true));         Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(-15),                                                                  new Double(-5.5),                                                                  new Double(-1),                                                                  new Double(-2),                                                                  new Double(2) },                 MathArrays.OrderDirection.INCREASING, false));         Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(-15),                                                                 new Double(-5.5),                                                                 new Double(-1),                                                                 new Double(-1),                                                                 new Double(2) },                 MathArrays.OrderDirection.INCREASING, false));         Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(3),                                                                  new Double(3),                                                                  new Double(-5.5),                                                                  new Double(-11),                                                                  new Double(-27.5) },                 MathArrays.OrderDirection.DECREASING, true));         Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(3),                                                                 new Double(2),                                                                 new Double(-5.5),                                                                 new Double(-11),                                                                 new Double(-27.5) },                 MathArrays.OrderDirection.DECREASING, true));         Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(3),                                                                  new Double(-1),                                                                  new Double(0),                                                                  new Double(-5.5),                                                                  new Double(-11),                                                                  new Double(-27.5) },                 MathArrays.OrderDirection.DECREASING, false));         Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(3),                                                                 new Double(0),                                                                 new Double(0),                                                                 new Double(-5.5),                                                                 new Double(-11),                                                                 new Double(-27.5) },                 MathArrays.OrderDirection.DECREASING, false));     }      @Test     public void testCheckRectangular() {         final long[][] rect = new long[][] {{0, 1}, {2, 3}};         final long[][] ragged = new long[][] {{0, 1}, {2}};         final long[][] nullArray = null;         final long[][] empty = new long[][] {};         MathArrays.checkRectangular(rect);         MathArrays.checkRectangular(empty);         try {             MathArrays.checkRectangular(ragged);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // Expected         }         try {             MathArrays.checkRectangular(nullArray);             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // Expected         }     }      @Test     public void testCheckPositive() {         final double[] positive = new double[] {1, 2, 3};         final double[] nonNegative = new double[] {0, 1, 2};         final double[] nullArray = null;         final double[] empty = new double[] {};         MathArrays.checkPositive(positive);         MathArrays.checkPositive(empty);         try {             MathArrays.checkPositive(nullArray);             Assert.fail("Expecting NullPointerException");         } catch (NullPointerException ex) {             // Expected         }         try {             MathArrays.checkPositive(nonNegative);             Assert.fail("Expecting NotStrictlyPositiveException");         } catch (NotStrictlyPositiveException ex) {             // Expected         }     }      @Test     public void testCheckNonNegative() {         final long[] nonNegative = new long[] {0, 1};         final long[] hasNegative = new long[] {-1};         final long[] nullArray = null;         final long[] empty = new long[] {};         MathArrays.checkNonNegative(nonNegative);         MathArrays.checkNonNegative(empty);         try {             MathArrays.checkNonNegative(nullArray);             Assert.fail("Expecting NullPointerException");         } catch (NullPointerException ex) {             // Expected         }         try {             MathArrays.checkNonNegative(hasNegative);             Assert.fail("Expecting NotPositiveException");         } catch (NotPositiveException ex) {             // Expected         }     }      @Test     public void testCheckNonNegative2D() {         final long[][] nonNegative = new long[][] {{0, 1}, {1, 0}};         final long[][] hasNegative = new long[][] {{-1}, {0}};         final long[][] nullArray = null;         final long[][] empty = new long[][] {};         MathArrays.checkNonNegative(nonNegative);         MathArrays.checkNonNegative(empty);         try {             MathArrays.checkNonNegative(nullArray);             Assert.fail("Expecting NullPointerException");         } catch (NullPointerException ex) {             // Expected         }         try {             MathArrays.checkNonNegative(hasNegative);             Assert.fail("Expecting NotPositiveException");         } catch (NotPositiveException ex) {             // Expected         }     }      @Test     public void testCheckNotNaN() {         final double[] withoutNaN = { Double.NEGATIVE_INFINITY,                                       -Double.MAX_VALUE,                                       -1, 0,                                       Double.MIN_VALUE,                                       FastMath.ulp(1d),                                       1, 3, 113, 4769,                                       Double.MAX_VALUE,                                       Double.POSITIVE_INFINITY };          final double[] withNaN = { Double.NEGATIVE_INFINITY,                                    -Double.MAX_VALUE,                                    -1, 0,                                    Double.MIN_VALUE,                                    FastMath.ulp(1d),                                    1, 3, 113, 4769,                                    Double.MAX_VALUE,                                    Double.POSITIVE_INFINITY,                                    Double.NaN };           final double[] nullArray = null;         final double[] empty = new double[] {};         MathArrays.checkNotNaN(withoutNaN);         MathArrays.checkNotNaN(empty);         try {             MathArrays.checkNotNaN(nullArray);             Assert.fail("Expecting NullPointerException");         } catch (NullPointerException ex) {             // Expected         }         try {             MathArrays.checkNotNaN(withNaN);             Assert.fail("Expecting NotANumberException");         } catch (NotANumberException ex) {             // Expected         }     }      @Test(expected=DimensionMismatchException.class)     public void testCheckEqualLength1() {         MathArrays.checkEqualLength(new double[] {1, 2, 3},                                     new double[] {1, 2, 3, 4});     }      @Test     public void testCheckEqualLength2() {         final double[] a = new double[] {-1, -12, -23, -34};         final double[] b = new double[] {56, 67, 78, 89};         Assert.assertTrue(MathArrays.checkEqualLength(a, b, false));     }      @Test     public void testSortInPlace() {         final double[] x1 = {2,   5,  -3, 1,  4};         final double[] x2 = {4,  25,   9, 1, 16};         final double[] x3 = {8, 125, -27, 1, 64};          MathArrays.sortInPlace(x1, x2, x3);          Assert.assertEquals(-3,  x1[0], FastMath.ulp(1d));         Assert.assertEquals(9,   x2[0], FastMath.ulp(1d));         Assert.assertEquals(-27, x3[0], FastMath.ulp(1d));          Assert.assertEquals(1, x1[1], FastMath.ulp(1d));         Assert.assertEquals(1, x2[1], FastMath.ulp(1d));         Assert.assertEquals(1, x3[1], FastMath.ulp(1d));          Assert.assertEquals(2, x1[2], FastMath.ulp(1d));         Assert.assertEquals(4, x2[2], FastMath.ulp(1d));         Assert.assertEquals(8, x3[2], FastMath.ulp(1d));          Assert.assertEquals(4,  x1[3], FastMath.ulp(1d));         Assert.assertEquals(16, x2[3], FastMath.ulp(1d));         Assert.assertEquals(64, x3[3], FastMath.ulp(1d));          Assert.assertEquals(5,   x1[4], FastMath.ulp(1d));         Assert.assertEquals(25,  x2[4], FastMath.ulp(1d));         Assert.assertEquals(125, x3[4], FastMath.ulp(1d));     }      @Test     public void testSortInPlaceDecreasingOrder() {         final double[] x1 = {2,   5,  -3, 1,  4};         final double[] x2 = {4,  25,   9, 1, 16};         final double[] x3 = {8, 125, -27, 1, 64};          MathArrays.sortInPlace(x1,                                MathArrays.OrderDirection.DECREASING,                                x2, x3);          Assert.assertEquals(-3,  x1[4], FastMath.ulp(1d));         Assert.assertEquals(9,   x2[4], FastMath.ulp(1d));         Assert.assertEquals(-27, x3[4], FastMath.ulp(1d));          Assert.assertEquals(1, x1[3], FastMath.ulp(1d));         Assert.assertEquals(1, x2[3], FastMath.ulp(1d));         Assert.assertEquals(1, x3[3], FastMath.ulp(1d));          Assert.assertEquals(2, x1[2], FastMath.ulp(1d));         Assert.assertEquals(4, x2[2], FastMath.ulp(1d));         Assert.assertEquals(8, x3[2], FastMath.ulp(1d));          Assert.assertEquals(4,  x1[1], FastMath.ulp(1d));         Assert.assertEquals(16, x2[1], FastMath.ulp(1d));         Assert.assertEquals(64, x3[1], FastMath.ulp(1d));          Assert.assertEquals(5,   x1[0], FastMath.ulp(1d));         Assert.assertEquals(25,  x2[0], FastMath.ulp(1d));         Assert.assertEquals(125, x3[0], FastMath.ulp(1d));     }      /** Example in javadoc */     @Test     public void testSortInPlaceExample() {         final double[] x = {3, 1, 2};         final double[] y = {1, 2, 3};         final double[] z = {0, 5, 7};         MathArrays.sortInPlace(x, y, z);         final double[] sx = {1, 2, 3};         final double[] sy = {2, 3, 1};         final double[] sz = {5, 7, 0};         Assert.assertTrue(Arrays.equals(sx, x));         Assert.assertTrue(Arrays.equals(sy, y));         Assert.assertTrue(Arrays.equals(sz, z));     }      @Test     public void testSortInPlaceFailures() {         final double[] nullArray = null;         final double[] one = {1};         final double[] two = {1, 2};         final double[] onep = {2};         try {             MathArrays.sortInPlace(one, two);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // expected         }         try {             MathArrays.sortInPlace(one, nullArray);             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }         try {             MathArrays.sortInPlace(one, onep, nullArray);             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testArrayEquals() {         Assert.assertFalse(MathArrays.equals(new double[] { 1d }, null));         Assert.assertFalse(MathArrays.equals(null, new double[] { 1d }));         Assert.assertTrue(MathArrays.equals((double[]) null, (double[]) null));          Assert.assertFalse(MathArrays.equals(new double[] { 1d }, new double[0]));         Assert.assertTrue(MathArrays.equals(new double[] { 1d }, new double[] { 1d }));         Assert.assertTrue(MathArrays.equals(new double[] { Double.POSITIVE_INFINITY,                                                            Double.NEGATIVE_INFINITY, 1d, 0d },                                             new double[] { Double.POSITIVE_INFINITY,                                                            Double.NEGATIVE_INFINITY, 1d, 0d }));         Assert.assertFalse(MathArrays.equals(new double[] { Double.NaN },                                              new double[] { Double.NaN }));         Assert.assertFalse(MathArrays.equals(new double[] { Double.POSITIVE_INFINITY },                                              new double[] { Double.NEGATIVE_INFINITY }));         Assert.assertFalse(MathArrays.equals(new double[] { 1d },                                              new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));      }      @Test     public void testArrayEqualsIncludingNaN() {         Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, null));         Assert.assertFalse(MathArrays.equalsIncludingNaN(null, new double[] { 1d }));         Assert.assertTrue(MathArrays.equalsIncludingNaN((double[]) null, (double[]) null));          Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[0]));         Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d }));         Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[] { Double.NaN, Double.POSITIVE_INFINITY,                                                                        Double.NEGATIVE_INFINITY, 1d, 0d },                                                         new double[] { Double.NaN, Double.POSITIVE_INFINITY,                                                                        Double.NEGATIVE_INFINITY, 1d, 0d }));         Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },                                                          new double[] { Double.NEGATIVE_INFINITY }));         Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d },                                                          new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));     }      @Test     public void testNormalizeArray() {         double[] testValues1 = new double[] {1, 1, 2};         TestUtils.assertEquals( new double[] {.25, .25, .5},                                 MathArrays.normalizeArray(testValues1, 1),                                 Double.MIN_VALUE);          double[] testValues2 = new double[] {-1, -1, 1};         TestUtils.assertEquals( new double[] {1, 1, -1},                                 MathArrays.normalizeArray(testValues2, 1),                                 Double.MIN_VALUE);          // Ignore NaNs         double[] testValues3 = new double[] {-1, -1, Double.NaN, 1, Double.NaN};         TestUtils.assertEquals( new double[] {1, 1,Double.NaN, -1, Double.NaN},                                 MathArrays.normalizeArray(testValues3, 1),                                 Double.MIN_VALUE);          // Zero sum -> MathArithmeticException         double[] zeroSum = new double[] {-1, 1};         try {             MathArrays.normalizeArray(zeroSum, 1);             Assert.fail("expecting MathArithmeticException");         } catch (MathArithmeticException ex) {}          // Infinite elements -> MathArithmeticException         double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};         try {             MathArrays.normalizeArray(hasInf, 1);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {}          // Infinite target -> MathIllegalArgumentException         try {             MathArrays.normalizeArray(testValues1, Double.POSITIVE_INFINITY);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {}          // NaN target -> MathIllegalArgumentException         try {             MathArrays.normalizeArray(testValues1, Double.NaN);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {}     }      @Test     public void testConvolve() {         /* Test Case (obtained via SciPy)          * x=[1.2,-1.8,1.4]          * h=[1,0.8,0.5,0.3]          * convolve(x,h) -> array([ 1.2 , -0.84,  0.56,  0.58,  0.16,  0.42])          */         double[] x1 = { 1.2, -1.8, 1.4 };         double[] h1 = { 1, 0.8, 0.5, 0.3 };         double[] y1 = { 1.2, -0.84, 0.56, 0.58, 0.16, 0.42 };         double tolerance = 1e-13;          double[] yActual = MathArrays.convolve(x1, h1);         Assert.assertArrayEquals(y1, yActual, tolerance);          double[] x2 = { 1, 2, 3 };         double[] h2 = { 0, 1, 0.5 };         double[] y2 = { 0, 1, 2.5, 4, 1.5 };          yActual = MathArrays.convolve(x2, h2);         Assert.assertArrayEquals(y2, yActual, tolerance);          try {             MathArrays.convolve(new double[]{1, 2}, null);             Assert.fail("an exception should have been thrown");         } catch (NullArgumentException e) {             // expected behavior         }          try {             MathArrays.convolve(null, new double[]{1, 2});             Assert.fail("an exception should have been thrown");         } catch (NullArgumentException e) {             // expected behavior         }          try {             MathArrays.convolve(new double[]{1, 2}, new double[]{});             Assert.fail("an exception should have been thrown");         } catch (NoDataException e) {             // expected behavior         }          try {             MathArrays.convolve(new double[]{}, new double[]{1, 2});             Assert.fail("an exception should have been thrown");         } catch (NoDataException e) {             // expected behavior         }          try {             MathArrays.convolve(new double[]{}, new double[]{});             Assert.fail("an exception should have been thrown");         } catch (NoDataException e) {             // expected behavior         }     }      @Test     public void testNatural() {         final int n = 4;         final int[] expected = {0, 1, 2, 3};          final int[] natural = MathArrays.natural(n);         for (int i = 0; i < n; i++) {             Assert.assertEquals(expected[i], natural[i]);         }     }      @Test     public void testNaturalZero() {         final int[] natural = MathArrays.natural(0);         Assert.assertEquals(0, natural.length);     }      @Test     public void testSequence() {         final int size = 4;         final int start = 5;         final int stride = 2;         final int[] expected = {5, 7, 9, 11};          final int[] seq = MathArrays.sequence(size, start, stride);         for (int i = 0; i < size; i++) {             Assert.assertEquals(expected[i], seq[i]);         }     }      @Test     public void testSequenceZero() {         final int[] seq = MathArrays.sequence(0, 12345, 6789);         Assert.assertEquals(0, seq.length);     }      @Test     public void testVerifyValuesPositive() {         for (int j = 0; j < 6; j++) {             for (int i = 1; i < (7 - j); i++) {                 Assert.assertTrue(MathArrays.verifyValues(testArray, 0, i));             }         }         Assert.assertTrue(MathArrays.verifyValues(singletonArray, 0, 1));         Assert.assertTrue(MathArrays.verifyValues(singletonArray, 0, 0, true));     }      @Test     public void testVerifyValuesNegative() {         Assert.assertFalse(MathArrays.verifyValues(singletonArray, 0, 0));         Assert.assertFalse(MathArrays.verifyValues(testArray, 0, 0));         try {             MathArrays.verifyValues(singletonArray, 2, 1);  // start past end             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MathArrays.verifyValues(testArray, 0, 7);  // end past end             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MathArrays.verifyValues(testArray, -1, 1);  // start negative             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MathArrays.verifyValues(testArray, 0, -1);  // length negative             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MathArrays.verifyValues(nullArray, 0, 1);  // null array             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }         try {             MathArrays.verifyValues(testArray, nullArray, 0, 1);  // null weights array             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }         try {             MathArrays.verifyValues(singletonArray, testWeightsArray, 0, 1);  // weights.length != value.length             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MathArrays.verifyValues(testArray, testNegativeWeightsArray, 0, 6);  // can't have negative weights             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      @Test     public void testConcatenate() {         final double[] u = new double[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};         final double[] x = new double[] {0, 1, 2};         final double[] y = new double[] {3, 4, 5, 6, 7, 8};         final double[] z = new double[] {9};         Assert.assertArrayEquals(u, MathArrays.concatenate(x, y, z), 0);     }      @Test     public void testConcatenateSingle() {         final double[] x = new double[] {0, 1, 2};         Assert.assertArrayEquals(x, MathArrays.concatenate(x), 0);     }      public void testConcatenateEmptyArguments() {         final double[] x = new double[] {0, 1, 2};         final double[] y = new double[] {3};         final double[] z = new double[] {};         final double[] u = new double[] {0, 1, 2, 3};         Assert.assertArrayEquals(u,  MathArrays.concatenate(x, z, y), 0);         Assert.assertArrayEquals(u,  MathArrays.concatenate(x, y, z), 0);         Assert.assertArrayEquals(u,  MathArrays.concatenate(z, x, y), 0);         Assert.assertEquals(0,  MathArrays.concatenate(z, z, z).length);     }      @Test(expected=NullPointerException.class)     public void testConcatenateNullArguments() {         final double[] x = new double[] {0, 1, 2};         MathArrays.concatenate(x, null);     }      @Test     public void testUnique() {         final double[] x = {0, 9, 3, 0, 11, 7, 3, 5, -1, -2};         final double[] values = {11, 9, 7, 5, 3, 0, -1, -2};         Assert.assertArrayEquals(values, MathArrays.unique(x), 0);     }      @Test     public void testUniqueInfiniteValues() {         final double [] x = {0, Double.NEGATIVE_INFINITY, 3, Double.NEGATIVE_INFINITY,             3, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};         final double[] u = {Double.POSITIVE_INFINITY, 3, 0, Double.NEGATIVE_INFINITY};         Assert.assertArrayEquals(u , MathArrays.unique(x), 0);     }      @Test     public void testUniqueNaNValues() {         final double[] x = new double[] {10, 2, Double.NaN, Double.NaN, Double.NaN,             Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};         final double[] u = MathArrays.unique(x);         Assert.assertEquals(5, u.length);         Assert.assertTrue(Double.isNaN(u[0]));         Assert.assertEquals(Double.POSITIVE_INFINITY, u[1], 0);         Assert.assertEquals(10, u[2], 0);         Assert.assertEquals(2, u[3], 0);         Assert.assertEquals(Double.NEGATIVE_INFINITY, u[4], 0);     }      @Test(expected=NullPointerException.class)     public void testUniqueNullArgument() {         MathArrays.unique(null);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import org.apache.commons.math4.stat.StatUtils; import org.junit.Assert; import org.junit.Test;   /**  * This class contains test cases for the ExpandableDoubleArray.  *  */ public abstract class DoubleArrayAbstractTest {      protected DoubleArray da = null;      // Array used to test rolling     protected DoubleArray ra = null;      @Test     public void testAdd1000() {          for (int i = 0; i < 1000; i++) {             da.addElement(i);         }          Assert.assertEquals(             "Number of elements should be equal to 1000 after adding 1000 values",             1000,             da.getNumElements());          Assert.assertEquals(             "The element at the 56th index should be 56",             56.0,             da.getElement(56),             Double.MIN_VALUE);      }      @Test     public void testGetValues() {         double[] controlArray = { 2.0, 4.0, 6.0 };          da.addElement(2.0);         da.addElement(4.0);         da.addElement(6.0);         double[] testArray = da.getElements();          for (int i = 0; i < da.getNumElements(); i++) {             Assert.assertEquals(                 "The testArray values should equal the controlArray values, index i: "                     + i                     + " does not match",                 testArray[i],                 controlArray[i],                 Double.MIN_VALUE);         }      }      @Test     public void testAddElementRolling() {         ra.addElement(0.5);         ra.addElement(1.0);         ra.addElement(1.0);         ra.addElement(1.0);         ra.addElement(1.0);         ra.addElement(1.0);         ra.addElementRolling(2.0);          Assert.assertEquals(             "There should be 6 elements in the eda",             6,             ra.getNumElements());         Assert.assertEquals(             "The max element should be 2.0",             2.0,             StatUtils.max(ra.getElements()),             Double.MIN_VALUE);         Assert.assertEquals(             "The min element should be 1.0",             1.0,             StatUtils.min(ra.getElements()),             Double.MIN_VALUE);          for (int i = 0; i < 1024; i++) {             ra.addElementRolling(i);         }          Assert.assertEquals(             "We just inserted 1024 rolling elements, num elements should still be 6",             6,             ra.getNumElements());     }      @Test     public void testMinMax() {         da.addElement(2.0);         da.addElement(22.0);         da.addElement(-2.0);         da.addElement(21.0);         da.addElement(22.0);         da.addElement(42.0);         da.addElement(62.0);         da.addElement(22.0);         da.addElement(122.0);         da.addElement(1212.0);          Assert.assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);         Assert.assertEquals(             "Max should be 1212.0",             1212.0,             StatUtils.max(da.getElements()),             Double.MIN_VALUE);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import static org.junit.Assert.assertEquals;  import java.util.Arrays; import java.util.Random;  import org.junit.Test;  public class KthSelectorTest {      @Test     public void testRandom() {                  final int numIterations = 100000;         final double[] possibleValues = {Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.MAX_VALUE, Double.MIN_VALUE, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, -0., 0., 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final Random rnd = new Random(0);         for (int i = 0; i < numIterations; ++i) {                          final int dataSize = rnd.nextInt(30);              final double[] data = new double[dataSize];              for (int j = 0; j < dataSize; ++j) {                 data[j] = possibleValues[rnd.nextInt(possibleValues.length)];             }                          final double[] dataSorted = Arrays.copyOf(data, data.length);             Arrays.sort(dataSorted);              for (int j = 0; j < dataSize; ++j) {                  final double[] dataTmp = Arrays.copyOf(data, data.length);                 final double resultKthSelector = new KthSelector().select(dataTmp, null, j);                 final double resultSort = dataSorted[j];                 assertEquals(Double.doubleToLongBits(resultKthSelector), Double.doubleToLongBits(resultSort));             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.util;  import java.util.List; import java.util.ArrayList; import java.util.NoSuchElementException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.ZeroException; import org.junit.Assert; import org.junit.Test;  /**  * Tests for {@link IntegerSequence} and {@link IntegerSequence.Incrementor}.  */ public class IntegerSequenceTest {     @Test     public void testRangeMultipleIterations() {         // Check that we can iterate several times using the same instance.         final int start = 1;         final int max = 7;         final int step = 2;          final List<Integer> seq = new ArrayList<>();         final IntegerSequence.Range r = IntegerSequence.range(start, max, step);          final int numTimes = 3;         for (int n = 0; n < numTimes; n++) {             seq.clear();             for (Integer i : r) {                 seq.add(i);             }             Assert.assertEquals(4, seq.size());             Assert.assertEquals(seq.size(), r.size());         }     }      @Test     public void testIncreasingRange() {         final int start = 1;         final int max = 7;         final int step = 2;          final List<Integer> seq = new ArrayList<>();         final IntegerSequence.Range r = IntegerSequence.range(start, max, step);         for (Integer i : r) {             seq.add(i);         }          Assert.assertEquals(4, seq.size());         Assert.assertEquals(seq.size(), r.size());         for (int i = 0; i < seq.size(); i++) {             Assert.assertEquals(start + i * step, seq.get(i).intValue());         }     }      @Test     public void testIncreasingRangeNegativeEnd() {         final int start = -10;         final int max = -1;         final int step = 2;          final List<Integer> seq = new ArrayList<>();         final IntegerSequence.Range r = IntegerSequence.range(start, max, step);         for (Integer i : r) {             seq.add(i);         }          Assert.assertEquals(5, seq.size());         Assert.assertEquals(seq.size(), r.size());         for (int i = 0; i < seq.size(); i++) {             Assert.assertEquals(start + i * step, seq.get(i).intValue());         }     }      @Test     public void testDecreasingRange() {         final int start = 10;         final int max = -8;         final int step = -3;          final List<Integer> seq = new ArrayList<>();         final IntegerSequence.Range r = IntegerSequence.range(start, max, step);         for (Integer i : r) {             seq.add(i);         }          Assert.assertEquals(7, seq.size());         Assert.assertEquals(seq.size(), r.size());         for (int i = 0; i < seq.size(); i++) {             Assert.assertEquals(start + i * step, seq.get(i).intValue());         }     }      @Test     public void testSingleElementRange() {         final int start = 1;         final int max = 1;         final int step = -1;          final List<Integer> seq = new ArrayList<>();         final IntegerSequence.Range r = IntegerSequence.range(start, max, step);         for (Integer i : r) {             seq.add(i);         }          Assert.assertEquals(1, seq.size());         Assert.assertEquals(seq.size(), r.size());         Assert.assertEquals(start, seq.get(0).intValue());     }      @Test     public void testBasicRange() {         final int start = -2;         final int end = 4;          final List<Integer> seq = new ArrayList<>();         for (Integer i : IntegerSequence.range(start, end)) {             seq.add(i);         }          for (int i = start; i <= end; i++) {             Assert.assertEquals(i, seq.get(i - start).intValue());         }     }      @Test     public void testEmptyRange() {         final int start = 2;         final int end = 0;          final List<Integer> seq = new ArrayList<>();         final IntegerSequence.Range r = IntegerSequence.range(start, end);         for (Integer i : r) {             seq.add(i);         }          Assert.assertEquals(0, seq.size());         Assert.assertEquals(seq.size(), r.size());     }      @Test     public void testEmptyRangeNegativeStart() {         final int start = -2;         final int max = -1;         final int step = -1;          final List<Integer> seq = new ArrayList<>();         final IntegerSequence.Range r = IntegerSequence.range(start, max, step);         for (Integer i : r) {             seq.add(i);         }          Assert.assertEquals(0, seq.size());         Assert.assertEquals(seq.size(), r.size());     }      @Test(expected=MaxCountExceededException.class)     public void testIncrementorCountExceeded() {         final int start = 1;         final int max = 7;         final int step = 2;          final IntegerSequence.Incrementor inc =             IntegerSequence.Incrementor.create()             .withStart(start)             .withMaximalCount(max)             .withIncrement(step);          Assert.assertTrue(inc.canIncrement(2));         Assert.assertFalse(inc.canIncrement(3));          while (true) {             inc.increment();         }     }      @Test     public void testCanIncrementZeroTimes() {         final int start = 1;         final int max = 2;         final int step = 1;          final IntegerSequence.Incrementor inc             = IntegerSequence.Incrementor.create()             .withStart(start)             .withMaximalCount(max)             .withIncrement(step);          Assert.assertTrue(inc.canIncrement(0));     }      @Test(expected=NotStrictlyPositiveException.class)     public void testIncrementZeroTimes() {         final int start = 1;         final int max = 2;         final int step = 1;          final IntegerSequence.Incrementor inc             = IntegerSequence.Incrementor.create()             .withStart(start)             .withMaximalCount(max)             .withIncrement(step);          inc.increment(0);     }      @Test     public void testIncrementTooManyTimes() {         final int start = 0;         final int max = 3;         final int step = 1;          for (int i = 1; i <= max + 4; i++) {             final IntegerSequence.Incrementor inc                 = IntegerSequence.Incrementor.create()                 .withStart(start)                 .withMaximalCount(max)                 .withIncrement(step);              Assert.assertTrue(inc.canIncrement(max - 1));             Assert.assertFalse(inc.canIncrement(max));              try {                 inc.increment(i);             } catch (MaxCountExceededException e) {                 if (i < max) {                     Assert.fail("i=" + i);                 }                 // Otherwise, the exception is expected.             }         }     }      @Test(expected=ZeroException.class)     public void testIncrementZeroStep() {         final int step = 0;          final IntegerSequence.Incrementor inc             = IntegerSequence.Incrementor.create()             .withIncrement(step);     }      @Test     public void testIteratorZeroElement() {         final int start = 1;         final int max = 1;         final int step = 1;          final IntegerSequence.Incrementor inc             = IntegerSequence.Incrementor.create()             .withStart(start)             .withMaximalCount(max)             .withIncrement(step);          Assert.assertFalse(inc.hasNext());         try {             inc.increment();             Assert.fail("exception expected");         } catch (MaxCountExceededException e) {             // Expected.         }     }      @Test     public void testIteratorNext() {         final int start = 1;         final int max = 2;         final int step = 1;          final IntegerSequence.Incrementor inc             = IntegerSequence.Incrementor.create()             .withStart(start)             .withMaximalCount(max)             .withIncrement(step);          Assert.assertTrue(inc.hasNext());         Assert.assertEquals(1, inc.next().intValue());         Assert.assertFalse(inc.hasNext());         try {             inc.next();             Assert.fail("exception expected");         } catch (NoSuchElementException e) {             // Expected.         }     }      @Test(expected=TooManyEvaluationsException.class)     public void testIncrementorAlternateException() {         final int start = 1;         final int max = 2;         final int step = 1;          final IntegerSequence.Incrementor.MaxCountExceededCallback cb             = new IntegerSequence.Incrementor.MaxCountExceededCallback() {                     /** {@inheritDoc} */                     @Override                     public void trigger(int max) {                         throw new TooManyEvaluationsException(max);                     }                 };          final IntegerSequence.Incrementor inc             = IntegerSequence.Incrementor.create()             .withStart(start)             .withMaximalCount(max)             .withIncrement(step)             .withCallback(cb);          Assert.assertTrue(inc.hasNext());         Assert.assertEquals(start, inc.next().intValue());         inc.increment(); // Must fail.     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import java.util.ConcurrentModificationException; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Random; import java.util.Set;  import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Before; import org.junit.Test;   /**  * Test cases for the {@link OpenIntToDoubleHashMap}.  */ @SuppressWarnings("boxing") public class OpenIntToDoubleHashMapTest {      private Map<Integer, Double> javaMap = new HashMap<>();      @Before     public void setUp() throws Exception {         javaMap.put(50, 100.0);         javaMap.put(75, 75.0);         javaMap.put(25, 500.0);         javaMap.put(Integer.MAX_VALUE, Double.MAX_VALUE);         javaMap.put(0, -1.0);         javaMap.put(1, 0.0);         javaMap.put(33, -0.1);         javaMap.put(23234234, -242343.0);         javaMap.put(23321, Double.MIN_VALUE);         javaMap.put(-4444, 332.0);         javaMap.put(-1, -2323.0);         javaMap.put(Integer.MIN_VALUE, 44.0);          /* Add a few more to cause the table to rehash */         javaMap.putAll(generate());      }      private Map<Integer, Double> generate() {         Map<Integer, Double> map = new HashMap<>();         Random r = new Random();         for (int i = 0; i < 2000; ++i) {             map.put(r.nextInt(), r.nextDouble());         }         return map;     }      private OpenIntToDoubleHashMap createFromJavaMap() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());         }         return map;     }      @Test     public void testPutAndGetWith0ExpectedSize() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);         assertPutAndGet(map);     }      @Test     public void testPutAndGetWithExpectedSize() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);         assertPutAndGet(map);     }      @Test     public void testPutAndGet() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();         assertPutAndGet(map);     }      private void assertPutAndGet(OpenIntToDoubleHashMap map) {         assertPutAndGet(map, 0, new HashSet<Integer>());     }      private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize,             Set<Integer> keysInMap) {         Assert.assertEquals(mapSize, map.size());         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());             if (!keysInMap.contains(mapEntry.getKey())) {                 ++mapSize;             }             Assert.assertEquals(mapSize, map.size());             Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));         }     }      @Test     public void testPutAbsentOnExisting() {         OpenIntToDoubleHashMap map = createFromJavaMap();         int size = javaMap.size();         for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());             Assert.assertEquals(++size, map.size());             Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));         }     }      @Test     public void testPutOnExisting() {         OpenIntToDoubleHashMap map = createFromJavaMap();         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             map.put(mapEntry.getKey(), mapEntry.getValue());             Assert.assertEquals(javaMap.size(), map.size());             Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));         }     }      @Test     public void testGetAbsent() {         Map<Integer, Double> generated = generateAbsent();         OpenIntToDoubleHashMap map = createFromJavaMap();          for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {             Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));         }     }      @Test     public void testGetFromEmpty() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();         Assert.assertTrue(Double.isNaN(map.get(5)));         Assert.assertTrue(Double.isNaN(map.get(0)));         Assert.assertTrue(Double.isNaN(map.get(50)));     }      @Test     public void testRemove() {         OpenIntToDoubleHashMap map = createFromJavaMap();         int mapSize = javaMap.size();         Assert.assertEquals(mapSize, map.size());         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             map.remove(mapEntry.getKey());             Assert.assertEquals(--mapSize, map.size());             Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));         }          /* Ensure that put and get still work correctly after removals */         assertPutAndGet(map);     }      /* This time only remove some entries */     @Test     public void testRemove2() {         OpenIntToDoubleHashMap map = createFromJavaMap();         int mapSize = javaMap.size();         int count = 0;         Set<Integer> keysInMap = new HashSet<>(javaMap.keySet());         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             keysInMap.remove(mapEntry.getKey());             map.remove(mapEntry.getKey());             Assert.assertEquals(--mapSize, map.size());             Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));             if (count++ > 5) {                 break;             }         }          /* Ensure that put and get still work correctly after removals */         assertPutAndGet(map, mapSize, keysInMap);     }      @Test     public void testRemoveFromEmpty() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();         Assert.assertTrue(Double.isNaN(map.remove(50)));     }      @Test     public void testRemoveAbsent() {         Map<Integer, Double> generated = generateAbsent();          OpenIntToDoubleHashMap map = createFromJavaMap();         int mapSize = map.size();          for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {             map.remove(mapEntry.getKey());             Assert.assertEquals(mapSize, map.size());             Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));         }     }      /**      * Returns a map with at least 100 elements where each element is absent from javaMap.      */     private Map<Integer, Double> generateAbsent() {         Map<Integer, Double> generated = new HashMap<>();         do {             generated.putAll(generate());             for (Integer key : javaMap.keySet()) {                 generated.remove(key);             }         } while (generated.size() < 100);         return generated;     }      @Test     public void testCopy() {         OpenIntToDoubleHashMap copy =             new OpenIntToDoubleHashMap(createFromJavaMap());         Assert.assertEquals(javaMap.size(), copy.size());          for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             Assert.assertTrue(Precision.equals(mapEntry.getValue(), copy.get(mapEntry.getKey()), 1));         }     }      @Test     public void testContainsKey() {         OpenIntToDoubleHashMap map = createFromJavaMap();         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             Assert.assertTrue(map.containsKey(mapEntry.getKey()));         }         for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {             Assert.assertFalse(map.containsKey(mapEntry.getKey()));         }         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {             int key = mapEntry.getKey();             Assert.assertTrue(map.containsKey(key));             map.remove(key);             Assert.assertFalse(map.containsKey(key));         }     }      @Test     public void testIterator() {         OpenIntToDoubleHashMap map = createFromJavaMap();         OpenIntToDoubleHashMap.Iterator iterator = map.iterator();         for (int i = 0; i < map.size(); ++i) {             Assert.assertTrue(iterator.hasNext());             iterator.advance();             int key = iterator.key();             Assert.assertTrue(map.containsKey(key));             Assert.assertEquals(javaMap.get(key), map.get(key), 0);             Assert.assertEquals(javaMap.get(key), iterator.value(), 0);             Assert.assertTrue(javaMap.containsKey(key));         }         Assert.assertFalse(iterator.hasNext());         try {             iterator.advance();             Assert.fail("an exception should have been thrown");         } catch (NoSuchElementException nsee) {             // expected         }     }      @Test     public void testConcurrentModification() {         OpenIntToDoubleHashMap map = createFromJavaMap();         OpenIntToDoubleHashMap.Iterator iterator = map.iterator();         map.put(3, 3);         try {             iterator.advance();             Assert.fail("an exception should have been thrown");         } catch (ConcurrentModificationException cme) {             // expected         }     }      /**      * Regression test for a bug in findInsertionIndex where the hashing in the second probing      * loop was inconsistent with the first causing duplicate keys after the right sequence      * of puts and removes.      */     @Test     public void testPutKeysWithCollisions() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();         int key1 = -1996012590;         double value1 = 1.0;         map.put(key1, value1);         int key2 = 835099822;         map.put(key2, value1);         int key3 = 1008859686;         map.put(key3, value1);         Assert.assertTrue(Precision.equals(value1, map.get(key3), 1));         Assert.assertEquals(3, map.size());          map.remove(key2);         double value2 = 2.0;         map.put(key3, value2);         Assert.assertTrue(Precision.equals(value2, map.get(key3), 1));         Assert.assertEquals(2, map.size());     }      /**      * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly      * different manner.      */     @Test     public void testPutKeysWithCollision2() {         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();         int key1 = 837989881;         double value1 = 1.0;         map.put(key1, value1);         int key2 = 476463321;         map.put(key2, value1);         Assert.assertEquals(2, map.size());         Assert.assertTrue(Precision.equals(value1, map.get(key2), 1));          map.remove(key1);         double value2 = 2.0;         map.put(key2, value2);         Assert.assertEquals(1, map.size());         Assert.assertTrue(Precision.equals(value2, map.get(key2), 1));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.util;  import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.exception.util.LocalizedFormats;  /**  */ public class TestBean {     private Double x = Double.valueOf(1.0);      private String y = "1.0";      /**      *      */     public Double getX() {         return x;     }      /**      *      */     public String getY() {         return y;     }      /**      *      */     public void setX(Double double1) {         x = double1;     }      /**      *      */     public void setY(String string) {         y = string;     }      /**      *      */     public Double getZ() {         throw new MathUnsupportedOperationException(LocalizedFormats.SIMPLE_MESSAGE, "?");     }      /**      *      */     public void setZ(Double double1) {     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.util;  import org.apache.commons.math4.TestUtils; import org.junit.Assert; import org.junit.Test;   /**  */ public class TransformerMapTest {     /**      *      */     @Test     public void testPutTransformer(){         NumberTransformer expected = new DefaultTransformer();          TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertEquals(expected, map.getTransformer(TransformerMapTest.class));     }      /**      *      */     @Test     public void testContainsClass(){         NumberTransformer expected = new DefaultTransformer();         TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertTrue(map.containsClass(TransformerMapTest.class));     }      /**      *      */     @Test     public void testContainsTransformer(){         NumberTransformer expected = new DefaultTransformer();         TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertTrue(map.containsTransformer(expected));     }      /**      *      */     @Test     public void testRemoveTransformer(){         NumberTransformer expected = new DefaultTransformer();          TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertTrue(map.containsClass(TransformerMapTest.class));         Assert.assertTrue(map.containsTransformer(expected));         map.removeTransformer(TransformerMapTest.class);         Assert.assertFalse(map.containsClass(TransformerMapTest.class));         Assert.assertFalse(map.containsTransformer(expected));     }      /**      *      */     @Test     public void testClear(){         NumberTransformer expected = new DefaultTransformer();          TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertTrue(map.containsClass(TransformerMapTest.class));         map.clear();         Assert.assertFalse(map.containsClass(TransformerMapTest.class));     }      /**      *      */     @Test     public void testClasses(){         NumberTransformer expected = new DefaultTransformer();         TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertTrue(map.classes().contains(TransformerMapTest.class));     }      /**      *      */     @Test     public void testTransformers(){         NumberTransformer expected = new DefaultTransformer();         TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertTrue(map.transformers().contains(expected));     }      @Test     public void testSerial(){         NumberTransformer expected = new DefaultTransformer();         TransformerMap map = new TransformerMap();         map.putTransformer(TransformerMapTest.class, expected);         Assert.assertEquals(map, TestUtils.serializeAndRecover(map));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.util;  import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.Type; import java.util.ArrayList; import java.util.Arrays; import java.util.List;  import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  /**  * Test to compare FastMath results against StrictMath results for boundary values.  * <p>  * Running all tests independently: <br>  * {@code mvn test -Dtest=FastMathStrictComparisonTest}<br>  * or just run tests against a single method (e.g. scalb):<br>  * {@code mvn test -Dtest=FastMathStrictComparisonTest -DargLine="-DtestMethod=scalb"}  */ @SuppressWarnings("boxing") @RunWith(Parameterized.class) public class FastMathStrictComparisonTest {      // Values which often need special handling     private static final Double[] DOUBLE_SPECIAL_VALUES = {         -0.0, +0.0,                                         // 1,2         Double.NaN,                                         // 3         Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, // 4,5         -Double.MAX_VALUE, Double.MAX_VALUE,                // 6,7         // decreasing order of absolute value to help catch first failure         -Precision.EPSILON, Precision.EPSILON,              // 8,9         -Precision.SAFE_MIN, Precision.SAFE_MIN,            // 10,11         -Double.MIN_VALUE, Double.MIN_VALUE,                // 12,13     };      private static final Float [] FLOAT_SPECIAL_VALUES = {         -0.0f, +0.0f,                                       // 1,2         Float.NaN,                                          // 3         Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,   // 4,5         Float.MIN_VALUE, Float.MAX_VALUE,                   // 6,7         -Float.MIN_VALUE, -Float.MAX_VALUE,                 // 8,9     };      private static final Object [] LONG_SPECIAL_VALUES = {         -1,0,1,                                             // 1,2,3         Long.MIN_VALUE, Long.MAX_VALUE,                     // 4,5     };      private static final Object[] INT_SPECIAL_VALUES = {         -1,0,1,                                             // 1,2,3         Integer.MIN_VALUE, Integer.MAX_VALUE,               // 4,5     };      private final Method mathMethod;     private final Method fastMethod;     private final Type[] types;     private final Object[][] valueArrays;      public FastMathStrictComparisonTest(Method m, Method f, Type[] types, Object[][] data) throws Exception{         this.mathMethod=m;         this.fastMethod=f;         this.types=types;         this.valueArrays=data;     }      @Test     public void test1() throws Exception{         setupMethodCall(mathMethod, fastMethod, types, valueArrays);     }     private static boolean isNumber(Double d) {         return !(d.isInfinite() || d.isNaN());     }      private static boolean isNumber(Float f) {         return !(f.isInfinite() || f.isNaN());     }      private static void reportFailedResults(Method mathMethod, Object[] params, Object expected, Object actual, int[] entries){         final String methodName = mathMethod.getName();         String format = null;         long actL=0;         long expL=0;         if (expected instanceof Double) {             Double exp = (Double) expected;             Double act = (Double) actual;             if (isNumber(exp) && isNumber(act) && exp != 0) { // show difference as hex                 actL = Double.doubleToLongBits(act);                 expL = Double.doubleToLongBits(exp);                 if (Math.abs(actL-expL)==1) {                     // Not 100% sure off-by-one errors are allowed everywhere, so only allow for these methods                     if (methodName.equals("toRadians") || methodName.equals("atan2")) {                         return;                     }                 }                 format = "%016x";             }         } else if (expected instanceof Float ){             Float exp = (Float) expected;             Float act = (Float) actual;             if (isNumber(exp) && isNumber(act) && exp != 0) { // show difference as hex                 actL = Float.floatToIntBits(act);                 expL = Float.floatToIntBits(exp);                 format = "%08x";             }         }         StringBuilder sb = new StringBuilder();         sb.append(mathMethod.getReturnType().getSimpleName());         sb.append(" ");         sb.append(methodName);         sb.append("(");         String sep = "";         for(Object o : params){             sb.append(sep);             sb.append(o);             sep=", ";         }         sb.append(") expected ");         if (format != null){             sb.append(String.format(format, expL));         } else {             sb.append(expected);         }         sb.append(" actual ");         if (format != null){             sb.append(String.format(format, actL));         } else {             sb.append(actual);         }         sb.append(" entries ");         sb.append(Arrays.toString(entries));         String message = sb.toString();         final boolean fatal = true;         if (fatal) {             Assert.fail(message);         } else {             System.out.println(message);         }     }      private static void callMethods(Method mathMethod, Method fastMethod,             Object[] params, int[] entries) throws IllegalAccessException {         try {             Object expected;             try {                 expected = mathMethod.invoke(mathMethod, params);             } catch (InvocationTargetException ite) {                 expected = ite.getCause();             }             Object actual;             try {                 actual = fastMethod.invoke(mathMethod, params);             } catch (InvocationTargetException ite) {                 actual = ite.getCause();             }             if (expected instanceof ArithmeticException) {                 Assert.assertEquals(MathArithmeticException.class, actual.getClass());             } else  if (!expected.equals(actual)) {                 reportFailedResults(mathMethod, params, expected, actual, entries);             }         } catch (IllegalArgumentException e) {             Assert.fail(mathMethod+" "+e);         }     }      private static void setupMethodCall(Method mathMethod, Method fastMethod,             Type[] types, Object[][] valueArrays) throws Exception {         Object[] params = new Object[types.length];         int entry1 = 0;         int[] entries = new int[types.length];         for(Object d : valueArrays[0]) {             entry1++;             params[0] = d;             entries[0] = entry1;             if (params.length > 1){                 int entry2 = 0;                 for(Object d1 : valueArrays[1]) {                     entry2++;                     params[1] = d1;                     entries[1] = entry2;                     callMethods(mathMethod, fastMethod, params, entries);                 }             } else {                 callMethods(mathMethod, fastMethod, params, entries);             }         }     }      @Parameters     public static List<Object[]> data() throws Exception {         String singleMethod = System.getProperty("testMethod");         List<Object[]> list = new ArrayList<>();         for(Method mathMethod : StrictMath.class.getDeclaredMethods()) {             method:             if (Modifier.isPublic(mathMethod.getModifiers())){// Only test public methods                 Type []types = mathMethod.getGenericParameterTypes();                 if (types.length >=1) { // Only check methods with at least one parameter                     try {                         // Get the corresponding FastMath method                         Method fastMethod = FastMath.class.getDeclaredMethod(mathMethod.getName(), (Class[]) types);                         if (Modifier.isPublic(fastMethod.getModifiers())) { // It must be public too                             if (singleMethod != null && !fastMethod.getName().equals(singleMethod)) {                                 break method;                             }                             Object [][] values = new Object[types.length][];                             int index = 0;                             for(Type t : types) {                                 if (t.equals(double.class)){                                     values[index]=DOUBLE_SPECIAL_VALUES;                                 } else if (t.equals(float.class)) {                                     values[index]=FLOAT_SPECIAL_VALUES;                                 } else if (t.equals(long.class)) {                                     values[index]=LONG_SPECIAL_VALUES;                                 } else if (t.equals(int.class)) {                                     values[index]=INT_SPECIAL_VALUES;                                 } else {                                     System.out.println("Cannot handle class "+t+" for "+mathMethod);                                     break method;                                 }                                 index++;                             } //                            System.out.println(fastMethod);                             /*                              * The current implementation runs each method as a separate test.                              * Could be amended to run each value as a separate test                              */                             list.add(new Object[]{mathMethod, fastMethod, types, values}); //                            setupMethodCall(mathMethod, fastMethod, params, data);                         } else {                             System.out.println("Cannot find public FastMath method corresponding to: "+mathMethod);                         }                     } catch (NoSuchMethodException e) {                         System.out.println("Cannot find FastMath method corresponding to: "+mathMethod);                     }                 }             }         }         return list;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.random;  import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future;  import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  public class SynchronizedRandomGeneratorTest {     private final int numberOfThreads = 5;     private final int numberOfGenerators = 5;     private final int numberOfSamples = 100000;      @Test     public void testAdapter() {         final int seed = 12345;         final RandomGenerator orig = new RngAdaptor(RandomSource.MT, seed);         final RandomGenerator wrap             = new SynchronizedRandomGenerator(new RngAdaptor(RandomSource.MT, seed));          final int bSize = 67;         final byte[] bOrig = new byte[bSize];         final byte[] bWrap = new byte[bSize];          for (int i = 0; i < 100; i++) {             orig.nextBytes(bOrig);             wrap.nextBytes(bWrap);             for (int k = 0; k < bSize; k++) {                 Assert.assertEquals(bOrig[k], bWrap[k]);             }              Assert.assertEquals(orig.nextInt(), wrap.nextInt());              final int range = (i + 1) * 89;             Assert.assertEquals(orig.nextInt(range), wrap.nextInt(range));              Assert.assertEquals(orig.nextLong(), wrap.nextLong());             Assert.assertEquals(orig.nextBoolean(), wrap.nextBoolean());             Assert.assertEquals(orig.nextFloat(), wrap.nextFloat(), 0);             Assert.assertEquals(orig.nextDouble(), wrap.nextDouble(), 0);             Assert.assertEquals(orig.nextGaussian(), wrap.nextGaussian(), 0);          }     }      @Test     public void testMath899Sync() throws Throwable {         try {             // Running the test several times in order to decrease the             // probability that a non-thread-safe code did not trigger             // a concurrency problem.             for (int i = 0; i < 10; i++) {                 doTestMath899(true, numberOfThreads, numberOfGenerators, numberOfSamples);             }         } catch (InterruptedException e) {             Assert.fail(e.getMessage());         } catch (ExecutionException e) {             throw e.getCause();         }     }      /**      * @param sync Whether to use a synchronizing wrapper.      */     private double[] doTestMath899(final boolean sync,                                    final int numThreads,                                    final int numGenerators,                                    final int numSamples)         throws InterruptedException,                ExecutionException {         final RandomGenerator rng = new RngAdaptor(RandomSource.MT);         final RandomGenerator wrapper = sync ? new SynchronizedRandomGenerator(rng) : rng;          final List<Callable<Double>> tasks = new ArrayList<>();         for (int i = 0; i < numGenerators; i++) {             tasks.add(new Callable<Double>() {                     @Override                     public Double call() {                         Double lastValue = 0d;                         for (int j = 0; j < numSamples; j++) {                             lastValue = wrapper.nextGaussian();                         }                         return lastValue;                     }                 });         }          final ExecutorService exec = Executors.newFixedThreadPool(numThreads);         final List<Future<Double>> results = exec.invokeAll(tasks);          final double[] values = new double[numGenerators];         for (int i = 0; i < numGenerators; i++) {             values[i] = results.get(i).get();         }         return values;     } } 
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements.  See the NOTICE file //distributed with this work for additional information //regarding copyright ownership.  The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License.  You may obtain a copy of the License at  //http://www.apache.org/licenses/LICENSE-2.0  //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied.  See the License for the //specific language governing permissions and limitations //under the License.  package org.apache.commons.math4.random;  import java.util.Arrays;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.MatrixUtils; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.correlation.StorelessCovariance; import org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance; import org.apache.commons.math4.stat.descriptive.moment.VectorialMean; import org.apache.commons.math4.util.FastMath; import org.junit.Test; import org.junit.Assert;  public class CorrelatedRandomVectorGeneratorTest {     private double[] mean;     private RealMatrix covariance;     private CorrelatedRandomVectorGenerator generator;      public CorrelatedRandomVectorGeneratorTest() {         mean = new double[] { 0.0, 1.0, -3.0, 2.3 };          RealMatrix b = MatrixUtils.createRealMatrix(4, 3);         int counter = 0;         for (int i = 0; i < b.getRowDimension(); ++i) {             for (int j = 0; j < b.getColumnDimension(); ++j) {                 b.setEntry(i, j, 1.0 + 0.1 * ++counter);             }         }         RealMatrix bbt = b.multiply(b.transpose());         covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);         for (int i = 0; i < covariance.getRowDimension(); ++i) {             covariance.setEntry(i, i, bbt.getEntry(i, i));             for (int j = 0; j < covariance.getColumnDimension(); ++j) {                 double s = bbt.getEntry(i, j);                 covariance.setEntry(i, j, s);                 covariance.setEntry(j, i, s);             }         }          GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(RandomSource.create(RandomSource.WELL_1024_A, 17399225432l));         generator = new CorrelatedRandomVectorGenerator(mean,                                                         covariance,                                                         1.0e-12 * covariance.getNorm(),                                                         rawGenerator);     }      @Test     public void testRank() {         Assert.assertEquals(2, generator.getRank());     }      @Test     public void testMath226() {         double[] mean = { 1, 1, 10, 1 };         double[][] cov = {                 { 1, 3, 2, 6 },                 { 3, 13, 16, 2 },                 { 2, 16, 38, -1 },                 { 6, 2, -1, 197 }         };         RealMatrix covRM = MatrixUtils.createRealMatrix(cov);         NormalizedRandomGenerator rg = new GaussianRandomGenerator(RandomSource.create(RandomSource.WELL_1024_A, 5322145245211l));         CorrelatedRandomVectorGenerator sg =             new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);          double[] min = new double[mean.length];         Arrays.fill(min, Double.POSITIVE_INFINITY);         double[] max = new double[mean.length];         Arrays.fill(max, Double.NEGATIVE_INFINITY);         for (int i = 0; i < 10; i++) {             double[] generated = sg.nextVector();             for (int j = 0; j < generated.length; ++j) {                 min[j] = FastMath.min(min[j], generated[j]);                 max[j] = FastMath.max(max[j], generated[j]);             }         }         for (int j = 0; j < min.length; ++j) {             Assert.assertTrue(max[j] - min[j] > 2.0);         }      }      @Test     public void testRootMatrix() {         RealMatrix b = generator.getRootMatrix();         RealMatrix bbt = b.multiply(b.transpose());         for (int i = 0; i < covariance.getRowDimension(); ++i) {             for (int j = 0; j < covariance.getColumnDimension(); ++j) {                 Assert.assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);             }         }     }      @Test     public void testMeanAndCovariance() {          VectorialMean meanStat = new VectorialMean(mean.length);         VectorialCovariance covStat = new VectorialCovariance(mean.length, true);         for (int i = 0; i < 5000; ++i) {             double[] v = generator.nextVector();             meanStat.increment(v);             covStat.increment(v);         }          double[] estimatedMean = meanStat.getResult();         RealMatrix estimatedCovariance = covStat.getResult();         for (int i = 0; i < estimatedMean.length; ++i) {             Assert.assertEquals(mean[i], estimatedMean[i], 0.07);             for (int j = 0; j <= i; ++j) {                 Assert.assertEquals(covariance.getEntry(i, j),                                     estimatedCovariance.getEntry(i, j),                                     0.1 * (1.0 + FastMath.abs(mean[i])) * (1.0 + FastMath.abs(mean[j])));             }         }      }      @Test     public void testSampleWithZeroCovariance() {         final double[][] covMatrix1 = new double[][]{                 {0.013445532, 0.010394690, 0.009881156, 0.010499559},                 {0.010394690, 0.023006616, 0.008196856, 0.010732709},                 {0.009881156, 0.008196856, 0.019023866, 0.009210099},                 {0.010499559, 0.010732709, 0.009210099, 0.019107243}         };          final double[][] covMatrix2 = new double[][]{                 {0.0, 0.0, 0.0, 0.0, 0.0},                 {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},                 {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},                 {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},                 {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}         };          final double[][] covMatrix3 = new double[][]{                 {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},                 {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},                 {0.0, 0.0, 0.0, 0.0, 0.0},                 {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},                 {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}         };          testSampler(covMatrix1, 10000, 0.001);         testSampler(covMatrix2, 10000, 0.001);         testSampler(covMatrix3, 10000, 0.001);      }      private CorrelatedRandomVectorGenerator createSampler(double[][] cov) {         RealMatrix matrix = new Array2DRowRealMatrix(cov);         double small = 10e-12 * matrix.getNorm();         return new CorrelatedRandomVectorGenerator(                 new double[cov.length],                 matrix,                 small,                 new GaussianRandomGenerator(RandomSource.create(RandomSource.WELL_1024_A, 0x366a26b94e520f41l)));     }      private void testSampler(final double[][] covMatrix, int samples, double epsilon) {         CorrelatedRandomVectorGenerator sampler = createSampler(covMatrix);          StorelessCovariance cov = new StorelessCovariance(covMatrix.length);         for (int i = 0; i < samples; ++i) {             cov.increment(sampler.nextVector());         }          double[][] sampleCov = cov.getData();         for (int r = 0; r < covMatrix.length; ++r) {             TestUtils.assertEquals(covMatrix[r], sampleCov[r], epsilon);         }     } } 
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements.  See the NOTICE file //distributed with this work for additional information //regarding copyright ownership.  The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License.  You may obtain a copy of the License at  //http://www.apache.org/licenses/LICENSE-2.0  //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied.  See the License for the //specific language governing permissions and limitations //under the License.  package org.apache.commons.math4.random;  import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.StatUtils; import org.junit.Assert; import org.junit.Test;   public class UniformRandomGeneratorTest {      @Test     public void testMeanAndStandardDeviation() {         final UniformRandomProvider rg = RandomSource.create(RandomSource.ISAAC, 17399225432L);         UniformRandomGenerator generator = new UniformRandomGenerator(rg);         double[] sample = new double[10000];         for (int i = 0; i < sample.length; ++i) {             sample[i] = generator.nextNormalizedDouble();         }         Assert.assertEquals(0.0, StatUtils.mean(sample), 0.07);         Assert.assertEquals(1.0, StatUtils.variance(sample), 0.02);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.random;  import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.StatUtils; import org.apache.commons.math4.stat.descriptive.DescriptiveStatistics; import org.junit.Assert; import org.junit.Test;  /**  * Tests for the class {@link StableRandomGenerator}.  */ public class StableRandomGeneratorTest {     private final UniformRandomProvider rg = RandomSource.create(RandomSource.WELL_19937_C, 100);     private final static int sampleSize = 10000;      /**      * Run the double nextDouble() method test Due to leptokurtic property the      * acceptance range is widened.      *      * TODO: verify that tolerance this wide is really OK      */     @Test     public void testNextDouble() {         StableRandomGenerator generator = new StableRandomGenerator(rg, 1.3,                 0.1);         double[] sample = new double[2 * sampleSize];         for (int i = 0; i < sample.length; ++i) {             sample[i] = generator.nextNormalizedDouble();         }         Assert.assertEquals(0.0, StatUtils.mean(sample), 0.3);     }      /**      * If alpha = 2, than it must be Gaussian distribution      */     @Test     public void testGaussianCase() {         StableRandomGenerator generator = new StableRandomGenerator(rg, 2d, 0.0);          double[] sample = new double[sampleSize];         for (int i = 0; i < sample.length; ++i) {             sample[i] = generator.nextNormalizedDouble();         }         Assert.assertEquals(0.0, StatUtils.mean(sample), 0.02);         Assert.assertEquals(1.0, StatUtils.variance(sample), 0.02);     }      /**      * If alpha = 1, than it must be Cauchy distribution      */     @Test     public void testCauchyCase() {         StableRandomGenerator generator = new StableRandomGenerator(rg, 1d, 0.0);         DescriptiveStatistics summary = new DescriptiveStatistics();          for (int i = 0; i < sampleSize; ++i) {             double sample = generator.nextNormalizedDouble();             summary.addValue(sample);         }          // Standard Cauchy distribution should have zero median and mode         double median = summary.getPercentile(50);         Assert.assertEquals(0.0, median, 0.2);     }      /**      * Input parameter range tests      */     @Test     public void testAlphaRangeBelowZero() {         try {             new StableRandomGenerator(rg,                     -1.0, 0.0);             Assert.fail("Expected OutOfRangeException");         } catch (OutOfRangeException e) {             Assert.assertEquals(-1.0, e.getArgument());         }     }      @Test     public void testAlphaRangeAboveTwo() {         try {             new StableRandomGenerator(rg,                     3.0, 0.0);             Assert.fail("Expected OutOfRangeException");         } catch (OutOfRangeException e) {             Assert.assertEquals(3.0, e.getArgument());         }     }      @Test     public void testBetaRangeBelowMinusOne() {         try {             new StableRandomGenerator(rg,                     1.0, -2.0);             Assert.fail("Expected OutOfRangeException");         } catch (OutOfRangeException e) {             Assert.assertEquals(-2.0, e.getArgument());         }     }      @Test     public void testBetaRangeAboveOne() {         try {             new StableRandomGenerator(rg,                     1.0, 2.0);             Assert.fail("Expected OutOfRangeException");         } catch (OutOfRangeException e) {             Assert.assertEquals(2.0, e.getArgument());         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.random;  import org.junit.Assert;  import java.io.InputStream;  import org.apache.commons.math4.exception.OutOfRangeException; import org.junit.Before; import org.junit.Test;  public class SobolSequenceGeneratorTest {      private double[][] referenceValues = {             { 0.0, 0.0, 0.0 },             { 0.5, 0.5, 0.5 },             { 0.75, 0.25, 0.25 },             { 0.25, 0.75, 0.75 },             { 0.375, 0.375, 0.625 },             { 0.875, 0.875, 0.125 },             { 0.625, 0.125, 0.875 },             { 0.125, 0.625, 0.375 },             { 0.1875, 0.3125, 0.9375 },             { 0.6875, 0.8125, 0.4375 }     };      private SobolSequenceGenerator generator;      @Before     public void setUp() {         generator = new SobolSequenceGenerator(3);     }      @Test     public void test3DReference() {         for (int i = 0; i < referenceValues.length; i++) {             double[] result = generator.nextVector();             Assert.assertArrayEquals(referenceValues[i], result, 1e-6);             Assert.assertEquals(i + 1, generator.getNextIndex());         }     }      @Test     public void testConstructor() {         try {             new SobolSequenceGenerator(0);             Assert.fail("an exception should have been thrown");         } catch (OutOfRangeException e) {             // expected         }          try {             new SobolSequenceGenerator(21202);             Assert.fail("an exception should have been thrown");         } catch (OutOfRangeException e) {             // expected         }     }      @Test     public void testConstructor2() throws Exception{         try {             final String RESOURCE_NAME = "/assets/org/apache/commons/math4/random/new-joe-kuo-6.21201";             final InputStream is = getClass().getResourceAsStream(RESOURCE_NAME);             new SobolSequenceGenerator(21202, is);             Assert.fail("an exception should have been thrown");         } catch (OutOfRangeException e) {             // expected         }          try {             new SobolSequenceGenerator(21202);             Assert.fail("an exception should have been thrown");         } catch (OutOfRangeException e) {             // expected         }     }      @Test     public void testSkip() {         double[] result = generator.skipTo(5);         Assert.assertArrayEquals(referenceValues[5], result, 1e-6);         Assert.assertEquals(6, generator.getNextIndex());          for (int i = 6; i < referenceValues.length; i++) {             result = generator.nextVector();             Assert.assertArrayEquals(referenceValues[i], result, 1e-6);             Assert.assertEquals(i + 1, generator.getNextIndex());         }     }  } 
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements.  See the NOTICE file //distributed with this work for additional information //regarding copyright ownership.  The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License.  You may obtain a copy of the License at  //http://www.apache.org/licenses/LICENSE-2.0  //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied.  See the License for the //specific language governing permissions and limitations //under the License.  package org.apache.commons.math4.random;  import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance; import org.apache.commons.math4.stat.descriptive.moment.VectorialMean; import org.junit.Test; import org.junit.Assert;  public class UncorrelatedRandomVectorGeneratorTest {     private double[] mean;     private double[] standardDeviation;     private UncorrelatedRandomVectorGenerator generator;      public UncorrelatedRandomVectorGeneratorTest() {         mean              = new double[] {0.0, 1.0, -3.0, 2.3};         standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};         generator =             new UncorrelatedRandomVectorGenerator(mean, standardDeviation,                                                   new GaussianRandomGenerator(RandomSource.create(RandomSource.MT,                                                                                                   17399225433L)));     }      @Test     public void testMeanAndCorrelation() {         // The test is extremely sensitive to the seed (cf. constructor).         VectorialMean meanStat = new VectorialMean(mean.length);         VectorialCovariance covStat = new VectorialCovariance(mean.length, true);         for (int i = 0; i < 10000; ++i) {             double[] v = generator.nextVector();             meanStat.increment(v);             covStat.increment(v);         }          double[] estimatedMean = meanStat.getResult();         double scale;         RealMatrix estimatedCorrelation = covStat.getResult();         for (int i = 0; i < estimatedMean.length; ++i) {             Assert.assertEquals(mean[i], estimatedMean[i], 0.07);             for (int j = 0; j < i; ++j) {                 scale = standardDeviation[i] * standardDeviation[j];                 Assert.assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);             }             scale = standardDeviation[i] * standardDeviation[i];             Assert.assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.random;  import java.util.Random;  /**  * Test cases for the {@link RandomUtils.DataGenerator} class, using  * {@link Random} as the underlying source of randomness.  */ public class RandomUtilsDataGeneratorJDKRandomTest     extends RandomUtilsDataGeneratorAbstractTest {      public RandomUtilsDataGeneratorJDKRandomTest() {         super(RandomUtils.asUniformRandomProvider(new Random(1000)));     } } 
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements.  See the NOTICE file //distributed with this work for additional information //regarding copyright ownership.  The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License.  You may obtain a copy of the License at  //http://www.apache.org/licenses/LICENSE-2.0  //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied.  See the License for the //specific language governing permissions and limitations //under the License.  package org.apache.commons.math4.random;  import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.StatUtils; import org.junit.Assert; import org.junit.Test;   public class GaussianRandomGeneratorTest {      @Test     public void testMeanAndStandardDeviation() {         GaussianRandomGenerator generator = new GaussianRandomGenerator(RandomSource.create(RandomSource.MT, 17399225432l));         double[] sample = new double[10000];         for (int i = 0; i < sample.length; ++i) {             sample[i] = generator.nextNormalizedDouble();         }         Assert.assertEquals(0.0, StatUtils.mean(sample), 0.012);         Assert.assertEquals(1.0, StatUtils.variance(sample), 0.01);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.random;  import org.apache.commons.math4.RetryRunner; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.stat.Frequency; import org.apache.commons.math4.util.FastMath; import org.apache.commons.rng.UniformRandomProvider; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith;  /**  * Test cases for the {@link RandomUtils.DataGenerator} class.  */ @RunWith(RetryRunner.class) public abstract class RandomUtilsDataGeneratorAbstractTest {     private final long smallSampleSize = 1000;     private final String[] hex = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",                                    "a", "b", "c", "d", "e", "f" };     /** Data generator. */     private final RandomUtils.DataGenerator randomData;      /**      * @param rng RNG.      */     protected RandomUtilsDataGeneratorAbstractTest(UniformRandomProvider rng) {         randomData = RandomUtils.createDataGenerator(rng);     }      @Test     public void testNextLongExtremeValues() {         long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);         long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);         Assert.assertFalse(x == y);     }      @Test     public void testNextUniformExtremeValues() {         double x = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE);         double y = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE);         Assert.assertFalse(x == y);         Assert.assertFalse(Double.isNaN(x));         Assert.assertFalse(Double.isNaN(y));         Assert.assertFalse(Double.isInfinite(x));         Assert.assertFalse(Double.isInfinite(y));     }      @Test     public void testNextLongIAE() {         try {             randomData.nextLong(4, 3);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testNextLongNegativeToPositiveRange() {         for (int i = 0; i < 5; i++) {             checkNextLongUniform(-3, 5);             checkNextLongUniform(-3, 6);         }     }      @Test     public void testNextLongNegativeRange() {         for (int i = 0; i < 5; i++) {             checkNextLongUniform(-7, -4);             checkNextLongUniform(-15, -2);             checkNextLongUniform(Long.MIN_VALUE + 1, Long.MIN_VALUE + 12);         }     }      @Test     public void testNextLongPositiveRange() {         for (int i = 0; i < 5; i++) {             checkNextLongUniform(0, 3);             checkNextLongUniform(2, 12);             checkNextLongUniform(Long.MAX_VALUE - 12, Long.MAX_VALUE - 1);         }     }      private void checkNextLongUniform(long min, long max) {         final Frequency<Long> freq = new Frequency<>();         for (int i = 0; i < smallSampleSize; i++) {             final long value = randomData.nextLong(min, max);             Assert.assertTrue("nextLong range: " + value + " " + min + " " + max,                               (value >= min) && (value <= max));             freq.addValue(value);         }         final int len = ((int) (max - min)) + 1;         final long[] observed = new long[len];         for (int i = 0; i < len; i++) {             observed[i] = freq.getCount(min + i);         }         final double[] expected = new double[len];         for (int i = 0; i < len; i++) {             expected[i] = 1d / len;         }          TestUtils.assertChiSquareAccept(expected, observed, 0.01);     }      @Test     public void testNextLongWideRange() {         long lower = -0x6543210FEDCBA987L;         long upper =  0x456789ABCDEF0123L;         long max = Long.MIN_VALUE;         long min = Long.MAX_VALUE;         for (int i = 0; i < 10000000; ++i) {             long r = randomData.nextLong(lower, upper);             max = FastMath.max(max, r);             min = FastMath.min(min, r);             Assert.assertTrue(r >= lower);             Assert.assertTrue(r <= upper);         }         double ratio = (((double) max)   - ((double) min)) /                        (((double) upper) - ((double) lower));         Assert.assertTrue(ratio > 0.99999);     }      /** Test dispersion and failure modes for "nextHex". */     @Test     public void testNextHexWithoutSha1() {         checkNextHex(false);     }     @Test     public void testNextHexWithSha1() {         checkNextHex(true);     }      /**      * @param useSha1 Alternative.      */     private void checkNextHex(boolean useSha1) {         try {             randomData.nextHexString(-1, useSha1);             Assert.fail("negative length supplied -- MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }         try {             randomData.nextHexString(0, useSha1);             Assert.fail("zero length supplied -- MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }         String hexString = randomData.nextHexString(3, useSha1);         if (hexString.length() != 3) {             Assert.fail("incorrect length for generated string");         }         hexString = randomData.nextHexString(1, useSha1);         if (hexString.length() != 1) {             Assert.fail("incorrect length for generated string");         }         try {             hexString = randomData.nextHexString(0, useSha1);             Assert.fail("zero length requested -- expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }         Frequency<String> f = new Frequency<>();         for (int i = 0; i < smallSampleSize; i++) {             hexString = randomData.nextHexString(100, useSha1);             if (hexString.length() != 100) {                 Assert.fail("incorrect length for generated string");             }             for (int j = 0; j < hexString.length(); j++) {                 f.addValue(hexString.substring(j, j + 1));             }         }         double[] expected = new double[16];         long[] observed = new long[16];         for (int i = 0; i < 16; i++) {             expected[i] = (double) smallSampleSize * 100 / 16;             observed[i] = f.getCount(hex[i]);         }         TestUtils.assertChiSquareAccept(expected, observed, 0.001);     }      @Test     public void testNextUniformIAE() {         try {             randomData.nextUniform(4, 3);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }         try {             randomData.nextUniform(0, Double.POSITIVE_INFINITY);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }         try {             randomData.nextUniform(Double.NEGATIVE_INFINITY, 0);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }         try {             randomData.nextUniform(0, Double.NaN);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }         try {             randomData.nextUniform(Double.NaN, 0);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testNextUniformPositiveBounds() {         for (int i = 0; i < 5; i++) {             checkNextUniform(0, 10);         }     }      @Test     public void testNextUniformNegativeToPositiveBounds() {         for (int i = 0; i < 5; i++) {             checkNextUniform(-3, 5);         }     }      @Test     public void testNextUniformNegativeBounds() {         for (int i = 0; i < 5; i++) {             checkNextUniform(-7, -3);         }     }      @Test     public void testNextUniformMaximalInterval() {         for (int i = 0; i < 5; i++) {             checkNextUniform(-Double.MAX_VALUE, Double.MAX_VALUE);         }     }      private void checkNextUniform(double min, double max) {         // Set up bin bounds - min, binBound[0], ..., binBound[binCount-2], max         final int binCount = 5;         final double binSize = max / binCount - min/binCount; // Prevent overflow in extreme value case         final double[] binBounds = new double[binCount - 1];         binBounds[0] = min + binSize;         for (int i = 1; i < binCount - 1; i++) {             binBounds[i] = binBounds[i - 1] + binSize;  // + instead of * to avoid overflow in extreme case         }          final Frequency<Integer> freq = new Frequency<>();         for (int i = 0; i < smallSampleSize; i++) {             final double value = randomData.nextUniform(min, max);             Assert.assertTrue("nextUniform range", (value > min) && (value < max));             // Find bin             int j = 0;             while (j < binCount - 1 && value > binBounds[j]) {                 j++;             }             freq.addValue(j);         }          final long[] observed = new long[binCount];         for (int i = 0; i < binCount; i++) {             observed[i] = freq.getCount(i);         }         final double[] expected = new double[binCount];         for (int i = 0; i < binCount; i++) {             expected[i] = 1d / binCount;         }          TestUtils.assertChiSquareAccept(expected, observed, 0.01);     }      /** test exclusive endpoints of nextUniform **/     @Test     public void testNextUniformExclusiveEndpoints() {         for (int i = 0; i < 1000; i++) {             double u = randomData.nextUniform(0.99, 1);             Assert.assertTrue(u > 0.99 && u < 1);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.random;  import org.junit.Assert; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.OutOfRangeException; import org.junit.Before; import org.junit.Test;  public class HaltonSequenceGeneratorTest {      private double[][] referenceValues = {             { 0.0,    0.0,    0.0  },             { 0.5,    0.6667, 0.6  },             { 0.25,   0.3333, 0.2  },             { 0.75,   0.2223, 0.8  },             { 0.125,  0.8888, 0.4  },             { 0.625,  0.5555, 0.12 },             { 0.375,  0.1111, 0.72 },             { 0.875,  0.7777, 0.32 },             { 0.0625, 0.4444, 0.92 },             { 0.5625, 0.0740, 0.52 }     };      private double[][] referenceValuesUnscrambled = {             { 0.0,    0.0    },             { 0.5,    0.3333 },             { 0.25,   0.6666 },             { 0.75,   0.1111 },             { 0.125,  0.4444 },             { 0.625,  0.7777 },             { 0.375,  0.2222 },             { 0.875,  0.5555 },             { 0.0625, 0.8888 },             { 0.5625, 0.0370 }     };      private HaltonSequenceGenerator generator;      @Before     public void setUp() {         generator = new HaltonSequenceGenerator(3);     }      @Test     public void test3DReference() {         for (int i = 0; i < referenceValues.length; i++) {             double[] result = generator.nextVector();             Assert.assertArrayEquals(referenceValues[i], result, 1e-3);             Assert.assertEquals(i + 1, generator.getNextIndex());         }     }      @Test     public void test2DUnscrambledReference() {         generator = new HaltonSequenceGenerator(2, new int[] {2, 3}, null);         for (int i = 0; i < referenceValuesUnscrambled.length; i++) {             double[] result = generator.nextVector();             Assert.assertArrayEquals(referenceValuesUnscrambled[i], result, 1e-3);             Assert.assertEquals(i + 1, generator.getNextIndex());         }     }      @Test     public void testConstructor() {         try {             new HaltonSequenceGenerator(0);             Assert.fail("an exception should have been thrown");         } catch (OutOfRangeException e) {             // expected         }          try {             new HaltonSequenceGenerator(41);             Assert.fail("an exception should have been thrown");         } catch (OutOfRangeException e) {             // expected         }     }      @Test     public void testConstructor2() throws Exception{         try {             new HaltonSequenceGenerator(2, new int[] { 1 }, null);             Assert.fail("an exception should have been thrown");         } catch (OutOfRangeException e) {             // expected         }          try {             new HaltonSequenceGenerator(2, null, null);             Assert.fail("an exception should have been thrown");         } catch (NullArgumentException e) {             // expected         }          try {             new HaltonSequenceGenerator(2, new int[] { 1, 1 }, new int[] { 1 });             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // expected         }     }      @Test     public void testSkip() {         double[] result = generator.skipTo(5);         Assert.assertArrayEquals(referenceValues[5], result, 1e-3);         Assert.assertEquals(6, generator.getNextIndex());          for (int i = 6; i < referenceValues.length; i++) {             result = generator.nextVector();             Assert.assertArrayEquals(referenceValues[i], result, 1e-3);             Assert.assertEquals(i + 1, generator.getNextIndex());         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Test; import org.junit.Assert;  public class LUSolverTest {     private double[][] testData = {             { 1.0, 2.0, 3.0},             { 2.0, 5.0, 3.0},             { 1.0, 0.0, 8.0}     };     private double[][] luData = {             { 2.0, 3.0, 3.0 },             { 0.0, 5.0, 7.0 },             { 6.0, 9.0, 8.0 }     };      // singular matrices     private double[][] singular = {             { 2.0, 3.0 },             { 2.0, 3.0 }     };     private double[][] bigSingular = {             { 1.0, 2.0,   3.0,    4.0 },             { 2.0, 5.0,   3.0,    4.0 },             { 7.0, 3.0, 256.0, 1930.0 },             { 3.0, 7.0,   6.0,    8.0 }     }; // 4th row = 1st + 2nd      /** test threshold impact */     @Test     public void testThreshold() {         final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] {                                                        { 1.0, 2.0, 3.0},                                                        { 2.0, 5.0, 3.0},                                                        { 4.000001, 9.0, 9.0}                                                      });         Assert.assertFalse(new LUDecomposition(matrix, 1.0e-5).getSolver().isNonSingular());         Assert.assertTrue(new LUDecomposition(matrix, 1.0e-10).getSolver().isNonSingular());     }      /** test singular */     @Test     public void testSingular() {         DecompositionSolver solver =             new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();         Assert.assertTrue(solver.isNonSingular());         solver = new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver();         Assert.assertFalse(solver.isNonSingular());         solver = new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular)).getSolver();         Assert.assertFalse(solver.isNonSingular());     }      /** test solve dimension errors */     @Test     public void testSolveDimensionErrors() {         DecompositionSolver solver =             new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }     }      /** test solve singularity errors */     @Test     public void testSolveSingularityErrors() {         DecompositionSolver solver =             new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException ime) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException ime) {             // expected behavior         }         try {             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException ime) {             // expected behavior         }     }      /** test solve */     @Test     public void testSolve() {         DecompositionSolver solver =             new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                 { 1, 0 }, { 2, -5 }, { 3, 1 }         });         RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                 { 19, -71 }, { -6, 22 }, { -2, 9 }         });          // using RealMatrix         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);          // using ArrayRealVector         for (int i = 0; i < b.getColumnDimension(); ++i) {             Assert.assertEquals(0,                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                          1.0e-13);         }          // using RealVector with an alternate implementation         for (int i = 0; i < b.getColumnDimension(); ++i) {             ArrayRealVectorTest.RealVectorTestImpl v =                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));             Assert.assertEquals(0,                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                          1.0e-13);         }     }      /** test determinant */     @Test     public void testDeterminant() {         Assert.assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);         Assert.assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);         Assert.assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);         Assert.assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);     }      private double getDeterminant(RealMatrix m) {         return new LUDecomposition(m).getDeterminant();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.util.BigReal; import org.apache.commons.math4.util.BigRealField;  /**  * Test cases for the {@link Array2DRowFieldMatrix} class.  *  */  public final class FieldMatrixImplTest {      // 3 x 3 identity matrix     protected Dfp[][] id = { {Dfp25.of(1),Dfp25.of(0),Dfp25.of(0)}, {Dfp25.of(0),Dfp25.of(1),Dfp25.of(0)}, {Dfp25.of(0),Dfp25.of(0),Dfp25.of(1)} };      // Test data for group operations     protected Dfp[][] testData = { {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)}, {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3)}, {Dfp25.of(1),Dfp25.of(0),Dfp25.of(8)} };     protected Dfp[][] testDataLU = {{Dfp25.of(2), Dfp25.of(5), Dfp25.of(3)}, {Dfp25.of(1, 2), Dfp25.of(-5, 2), Dfp25.of(13, 2)}, {Dfp25.of(1, 2), Dfp25.of(1, 5), Dfp25.of(1, 5)}};     protected Dfp[][] testDataPlus2 = { {Dfp25.of(3),Dfp25.of(4),Dfp25.of(5)}, {Dfp25.of(4),Dfp25.of(7),Dfp25.of(5)}, {Dfp25.of(3),Dfp25.of(2),Dfp25.of(10)} };     protected Dfp[][] testDataMinus = { {Dfp25.of(-1),Dfp25.of(-2),Dfp25.of(-3)}, {Dfp25.of(-2),Dfp25.of(-5),Dfp25.of(-3)},        {Dfp25.of(-1),Dfp25.of(0),Dfp25.of(-8)} };     protected Dfp[] testDataRow1 = {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)};     protected Dfp[] testDataCol3 = {Dfp25.of(3),Dfp25.of(3),Dfp25.of(8)};     protected Dfp[][] testDataInv =         { {Dfp25.of(-40),Dfp25.of(16),Dfp25.of(9)}, {Dfp25.of(13),Dfp25.of(-5),Dfp25.of(-3)}, {Dfp25.of(5),Dfp25.of(-2),Dfp25.of(-1)} };     protected Dfp[] preMultTest = {Dfp25.of(8),Dfp25.of(12),Dfp25.of(33)};     protected Dfp[][] testData2 ={ {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)}, {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3)}};     protected Dfp[][] testData2T = { {Dfp25.of(1),Dfp25.of(2)}, {Dfp25.of(2),Dfp25.of(5)}, {Dfp25.of(3),Dfp25.of(3)}};     protected Dfp[][] testDataPlusInv =         { {Dfp25.of(-39),Dfp25.of(18),Dfp25.of(12)}, {Dfp25.of(15),Dfp25.of(0),Dfp25.of(0)}, {Dfp25.of(6),Dfp25.of(-2),Dfp25.of(7)} };      // lu decomposition tests     protected Dfp[][] luData = { {Dfp25.of(2),Dfp25.of(3),Dfp25.of(3)}, {Dfp25.of(0),Dfp25.of(5),Dfp25.of(7)}, {Dfp25.of(6),Dfp25.of(9),Dfp25.of(8)} };     protected Dfp[][] luDataLUDecomposition = { {Dfp25.of(6),Dfp25.of(9),Dfp25.of(8)}, {Dfp25.of(0),Dfp25.of(5),Dfp25.of(7)},             {Dfp25.of(1, 3),Dfp25.of(0),Dfp25.of(1, 3)} };      // singular matrices     protected Dfp[][] singular = { {Dfp25.of(2),Dfp25.of(3)}, {Dfp25.of(2),Dfp25.of(3)} };     protected Dfp[][] bigSingular = {{Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)}, {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3),Dfp25.of(4)},         {Dfp25.of(7),Dfp25.of(3),Dfp25.of(256),Dfp25.of(1930)}, {Dfp25.of(3),Dfp25.of(7),Dfp25.of(6),Dfp25.of(8)}}; // 4th row = 1st + 2nd     protected Dfp[][] detData = { {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)}, {Dfp25.of(4),Dfp25.of(5),Dfp25.of(6)}, {Dfp25.of(7),Dfp25.of(8),Dfp25.of(10)} };     protected Dfp[][] detData2 = { {Dfp25.of(1), Dfp25.of(3)}, {Dfp25.of(2), Dfp25.of(4)}};      // vectors     protected Dfp[] testVector = {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)};     protected Dfp[] testVector2 = {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)};      // submatrix accessor tests     protected Dfp[][] subTestData = {{Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4)}, {Dfp25.of(3, 2), Dfp25.of(5, 2), Dfp25.of(7, 2), Dfp25.of(9, 2)},             {Dfp25.of(2), Dfp25.of(4), Dfp25.of(6), Dfp25.of(8)}, {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6), Dfp25.of(7)}};     // array selections     protected Dfp[][] subRows02Cols13 = { {Dfp25.of(2), Dfp25.of(4)}, {Dfp25.of(4), Dfp25.of(8)}};     protected Dfp[][] subRows03Cols12 = { {Dfp25.of(2), Dfp25.of(3)}, {Dfp25.of(5), Dfp25.of(6)}};     protected Dfp[][] subRows03Cols123 = { {Dfp25.of(2), Dfp25.of(3), Dfp25.of(4)} , {Dfp25.of(5), Dfp25.of(6), Dfp25.of(7)}};     // effective permutations     protected Dfp[][] subRows20Cols123 = { {Dfp25.of(4), Dfp25.of(6), Dfp25.of(8)} , {Dfp25.of(2), Dfp25.of(3), Dfp25.of(4)}};     protected Dfp[][] subRows31Cols31 = {{Dfp25.of(7), Dfp25.of(5)}, {Dfp25.of(9, 2), Dfp25.of(5, 2)}};     // contiguous ranges     protected Dfp[][] subRows01Cols23 = {{Dfp25.of(3),Dfp25.of(4)} , {Dfp25.of(7, 2), Dfp25.of(9, 2)}};     protected Dfp[][] subRows23Cols00 = {{Dfp25.of(2)} , {Dfp25.of(4)}};     protected Dfp[][] subRows00Cols33 = {{Dfp25.of(4)}};     // row matrices     protected Dfp[][] subRow0 = {{Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)}};     protected Dfp[][] subRow3 = {{Dfp25.of(4),Dfp25.of(5),Dfp25.of(6),Dfp25.of(7)}};     // column matrices     protected Dfp[][] subColumn1 = {{Dfp25.of(2)}, {Dfp25.of(5, 2)}, {Dfp25.of(4)}, {Dfp25.of(5)}};     protected Dfp[][] subColumn3 = {{Dfp25.of(4)}, {Dfp25.of(9, 2)}, {Dfp25.of(8)}, {Dfp25.of(7)}};      // tolerances     protected double entryTolerance = 10E-16;     protected double normTolerance = 10E-14;      /** test dimensions */     @Test     public void testDimensions() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> m2 = new Array2DRowFieldMatrix<>(testData2);         Assert.assertEquals("testData row dimension",3,m.getRowDimension());         Assert.assertEquals("testData column dimension",3,m.getColumnDimension());         Assert.assertTrue("testData is square",m.isSquare());         Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);         Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);         Assert.assertTrue("testData2 is not square",!m2.isSquare());     }      /** test copy functions */     @Test     public void testCopyFunctions() {         Array2DRowFieldMatrix<Dfp> m1 = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> m2 = new Array2DRowFieldMatrix<>(m1.getData());         Assert.assertEquals(m2,m1);         Array2DRowFieldMatrix<Dfp> m3 = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> m4 = new Array2DRowFieldMatrix<>(m3.getData(), false);         Assert.assertEquals(m4,m3);     }      /** test add */     @Test     public void testAdd() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> mInv = new Array2DRowFieldMatrix<>(testDataInv);         FieldMatrix<Dfp> mPlusMInv = m.add(mInv);         Dfp[][] sumEntries = mPlusMInv.getData();         for (int row = 0; row < m.getRowDimension(); row++) {             for (int col = 0; col < m.getColumnDimension(); col++) {                 Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);             }         }     }      /** test add failure */     @Test     public void testAddFail() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> m2 = new Array2DRowFieldMatrix<>(testData2);         try {             m.add(m2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }       /** test m-n = m + -n */     @Test     public void testPlusMinus() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> m2 = new Array2DRowFieldMatrix<>(testDataInv);         TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(Dfp25.of(-1)).add(m));         try {             m.subtract(new Array2DRowFieldMatrix<>(testData2));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test multiply */     @Test      public void testMultiply() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> mInv = new Array2DRowFieldMatrix<>(testDataInv);         Array2DRowFieldMatrix<Dfp> identity = new Array2DRowFieldMatrix<>(id);         Array2DRowFieldMatrix<Dfp> m2 = new Array2DRowFieldMatrix<>(testData2);         TestUtils.assertEquals(m.multiply(mInv), identity);         TestUtils.assertEquals(mInv.multiply(m), identity);         TestUtils.assertEquals(m.multiply(identity), m);         TestUtils.assertEquals(identity.multiply(mInv), mInv);         TestUtils.assertEquals(m2.multiply(identity), m2);         try {             m.multiply(new Array2DRowFieldMatrix<>(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      //Additional Test for Array2DRowFieldMatrix<Dfp>Test.testMultiply      private final Dfp[][] d3 = new Dfp[][] {{Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)},{Dfp25.of(5),Dfp25.of(6),Dfp25.of(7),Dfp25.of(8)}};     private final Dfp[][] d4 = new Dfp[][] {{Dfp25.of(1)},{Dfp25.of(2)},{Dfp25.of(3)},{Dfp25.of(4)}};     private final Dfp[][] d5 = new Dfp[][] {{Dfp25.of(30)},{Dfp25.of(70)}};      @Test     public void testMultiply2() {        FieldMatrix<Dfp> m3 = new Array2DRowFieldMatrix<>(d3);        FieldMatrix<Dfp> m4 = new Array2DRowFieldMatrix<>(d4);        FieldMatrix<Dfp> m5 = new Array2DRowFieldMatrix<>(d5);        TestUtils.assertEquals(m3.multiply(m4), m5);    }      @Test     public void testPower() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         FieldMatrix<Dfp> mInv = new Array2DRowFieldMatrix<>(testDataInv);         FieldMatrix<Dfp> mPlusInv = new Array2DRowFieldMatrix<>(testDataPlusInv);         FieldMatrix<Dfp> identity = new Array2DRowFieldMatrix<>(id);          TestUtils.assertEquals(m.power(0), identity);         TestUtils.assertEquals(mInv.power(0), identity);         TestUtils.assertEquals(mPlusInv.power(0), identity);          TestUtils.assertEquals(m.power(1), m);         TestUtils.assertEquals(mInv.power(1), mInv);         TestUtils.assertEquals(mPlusInv.power(1), mPlusInv);          FieldMatrix<Dfp> C1 = m.copy();         FieldMatrix<Dfp> C2 = mInv.copy();         FieldMatrix<Dfp> C3 = mPlusInv.copy();          // stop at 5 to avoid overflow         for (int i = 2; i <= 5; ++i) {             C1 = C1.multiply(m);             C2 = C2.multiply(mInv);             C3 = C3.multiply(mPlusInv);              TestUtils.assertEquals(m.power(i), C1);             TestUtils.assertEquals(mInv.power(i), C2);             TestUtils.assertEquals(mPlusInv.power(i), C3);         }          try {             FieldMatrix<Dfp> mNotSquare = new Array2DRowFieldMatrix<>(testData2T);             mNotSquare.power(2);             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }          try {             m.power(-1);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test trace */     @Test     public void testTrace() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(id);         Assert.assertEquals("identity trace",Dfp25.of(3),m.getTrace());         m = new Array2DRowFieldMatrix<>(testData2);         try {             m.getTrace();             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }     }      /** test scalarAdd */     @Test     public void testScalarAdd() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         TestUtils.assertEquals(new Array2DRowFieldMatrix<>(testDataPlus2), m.scalarAdd(Dfp25.of(2)));     }      /** test operate */     @Test     public void testOperate() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(id);         TestUtils.assertEquals(testVector, m.operate(testVector));         TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<>(testVector)).toArray());         m = new Array2DRowFieldMatrix<>(bigSingular);         try {             m.operate(testVector);             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test issue MATH-209 */     @Test     public void testMath209() {         FieldMatrix<Dfp> a = new Array2DRowFieldMatrix<>(new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(2) }, { Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(5), Dfp25.of(6) }         }, false);         Dfp[] b = a.operate(new Dfp[] { Dfp25.of(1), Dfp25.of(1) });         Assert.assertEquals(a.getRowDimension(), b.length);         Assert.assertEquals( Dfp25.of(3), b[0]);         Assert.assertEquals( Dfp25.of(7), b[1]);         Assert.assertEquals(Dfp25.of(11), b[2]);     }      /** test transpose */     @Test     public void testTranspose() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         FieldMatrix<Dfp> mIT = new FieldLUDecomposition<>(m).getSolver().getInverse().transpose();         FieldMatrix<Dfp> mTI = new FieldLUDecomposition<>(m.transpose()).getSolver().getInverse();         TestUtils.assertEquals(mIT, mTI);         m = new Array2DRowFieldMatrix<>(testData2);         FieldMatrix<Dfp> mt = new Array2DRowFieldMatrix<>(testData2T);         TestUtils.assertEquals(mt, m.transpose());     }      /** test preMultiply by vector */     @Test     public void testPremultiplyVector() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);         TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<>(testVector).toArray()),                                preMultTest);         m = new Array2DRowFieldMatrix<>(bigSingular);         try {             m.preMultiply(testVector);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testPremultiply() {         FieldMatrix<Dfp> m3 = new Array2DRowFieldMatrix<>(d3);         FieldMatrix<Dfp> m4 = new Array2DRowFieldMatrix<>(d4);         FieldMatrix<Dfp> m5 = new Array2DRowFieldMatrix<>(d5);         TestUtils.assertEquals(m4.preMultiply(m3), m5);          Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> mInv = new Array2DRowFieldMatrix<>(testDataInv);         Array2DRowFieldMatrix<Dfp> identity = new Array2DRowFieldMatrix<>(id);         TestUtils.assertEquals(m.preMultiply(mInv), identity);         TestUtils.assertEquals(mInv.preMultiply(m), identity);         TestUtils.assertEquals(m.preMultiply(identity), m);         TestUtils.assertEquals(identity.preMultiply(mInv), mInv);         try {             m.preMultiply(new Array2DRowFieldMatrix<>(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testGetVectors() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         TestUtils.assertEquals(m.getRow(0), testDataRow1);         TestUtils.assertEquals(m.getColumn(2), testDataCol3);         try {             m.getRow(10);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }         try {             m.getColumn(-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }     }      @Test     public void testGetEntry() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Assert.assertEquals("get entry", m.getEntry(0,1), Dfp25.of(2));         try {             m.getEntry(10, 4);             Assert.fail ("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      /** test examples in user guide */     @Test     public void testExamples() {         // Create a real matrix with two rows and three columns         Dfp[][] matrixData = {                 {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)},                 {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3)}         };         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(matrixData);         // One more with three rows, two columns         Dfp[][] matrixData2 = {                 {Dfp25.of(1),Dfp25.of(2)},                 {Dfp25.of(2),Dfp25.of(5)},                 {Dfp25.of(1), Dfp25.of(7)}         };         FieldMatrix<Dfp> n = new Array2DRowFieldMatrix<>(matrixData2);         // Now multiply m by n         FieldMatrix<Dfp> p = m.multiply(n);         Assert.assertEquals(2, p.getRowDimension());         Assert.assertEquals(2, p.getColumnDimension());         // Invert p         FieldMatrix<Dfp> pInverse = new FieldLUDecomposition<>(p).getSolver().getInverse();         Assert.assertEquals(2, pInverse.getRowDimension());         Assert.assertEquals(2, pInverse.getColumnDimension());          // Solve example         Dfp[][] coefficientsData = {                 {Dfp25.of(2), Dfp25.of(3), Dfp25.of(-2)},                 {Dfp25.of(-1), Dfp25.of(7), Dfp25.of(6)},                 {Dfp25.of(4), Dfp25.of(-3), Dfp25.of(-5)}         };         FieldMatrix<Dfp> coefficients = new Array2DRowFieldMatrix<>(coefficientsData);         Dfp[] constants = {             Dfp25.of(1), Dfp25.of(-2), Dfp25.of(1)         };         Dfp[] solution;         solution = new FieldLUDecomposition<>(coefficients)             .getSolver()             .solve(new ArrayFieldVector<>(constants, false)).toArray();         Assert.assertEquals(Dfp25.of(2).multiply(solution[0]).                             add(Dfp25.of(3).multiply(solution[1])).                             subtract(Dfp25.of(2).multiply(solution[2])).toDouble(),                             constants[0].toDouble(),                             0d);         Assert.assertEquals(Dfp25.of(-1).multiply(solution[0]).                             add(Dfp25.of(7).multiply(solution[1])).                             add(Dfp25.of(6).multiply(solution[2])).toDouble(),                             constants[1].toDouble(),                             0d);         Assert.assertEquals(Dfp25.of(4).multiply(solution[0]).                             subtract(Dfp25.of(3).multiply(solution[1])).                             subtract(Dfp25.of(5).multiply(solution[2])).toDouble(),                             constants[2].toDouble(),                             0d);      }      // test submatrix accessors     @Test     public void testGetSubMatrix() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);         checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);         checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });         checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });         checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkGetSubMatrix(m, null,  1, 0, 2, 4);         checkGetSubMatrix(m, null, -1, 1, 2, 2);         checkGetSubMatrix(m, null,  1, 0, 2, 2);         checkGetSubMatrix(m, null,  1, 0, 2, 4);         checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });         checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });     }      private void checkGetSubMatrix(FieldMatrix<Dfp> m, Dfp[][] reference,                                    int startRow, int endRow, int startColumn, int endColumn) {         try {             FieldMatrix<Dfp> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);             if (reference != null) {                 Assert.assertEquals(new Array2DRowFieldMatrix<>(reference), sub);             } else {                 Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException"                      + " or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NotStrictlyPositiveException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      private void checkGetSubMatrix(FieldMatrix<Dfp> m, Dfp[][] reference,                                    int[] selectedRows, int[] selectedColumns) {         try {             FieldMatrix<Dfp> sub = m.getSubMatrix(selectedRows, selectedColumns);             if (reference != null) {                 Assert.assertEquals(new Array2DRowFieldMatrix<>(reference), sub);             } else {                 Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException"                      + " or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NotStrictlyPositiveException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      @Test     public void testCopySubMatrix() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);         checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);         checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });         checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });         checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });          checkCopy(m, null,  1, 0, 2, 4);         checkCopy(m, null, -1, 1, 2, 2);         checkCopy(m, null,  1, 0, 2, 2);         checkCopy(m, null,  1, 0, 2, 4);         checkCopy(m, null, new int[] {},    new int[] { 0 });         checkCopy(m, null, new int[] { 0 }, new int[] { 4 });     }      private void checkCopy(FieldMatrix<Dfp> m, Dfp[][] reference,                            int startRow, int endRow, int startColumn, int endColumn) {         try {             Dfp[][] sub = (reference == null) ?                              new Dfp[1][1] :                              new Dfp[reference.length][reference[0].length];             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);             if (reference != null) {                 Assert.assertEquals(new Array2DRowFieldMatrix<>(reference), new Array2DRowFieldMatrix<>(sub));             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      private void checkCopy(FieldMatrix<Dfp> m, Dfp[][] reference,                            int[] selectedRows, int[] selectedColumns) {         try {             Dfp[][] sub = (reference == null) ?                     new Dfp[1][1] :                     new Dfp[reference.length][reference[0].length];             m.copySubMatrix(selectedRows, selectedColumns, sub);             if (reference != null) {                 Assert.assertEquals(new Array2DRowFieldMatrix<>(reference), new Array2DRowFieldMatrix<>(sub));             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      @Test     public void testGetRowMatrix() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mRow0 = new Array2DRowFieldMatrix<>(subRow0);         FieldMatrix<Dfp> mRow3 = new Array2DRowFieldMatrix<>(subRow3);         Assert.assertEquals("Row0", mRow0,                 m.getRowMatrix(0));         Assert.assertEquals("Row3", mRow3,                 m.getRowMatrix(3));         try {             m.getRowMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowMatrix() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mRow3 = new Array2DRowFieldMatrix<>(subRow3);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowMatrix(0, mRow3);         Assert.assertEquals(mRow3, m.getRowMatrix(0));         try {             m.setRowMatrix(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetColumnMatrix() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mColumn1 = new Array2DRowFieldMatrix<>(subColumn1);         FieldMatrix<Dfp> mColumn3 = new Array2DRowFieldMatrix<>(subColumn3);         Assert.assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));         Assert.assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));         try {             m.getColumnMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnMatrix() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mColumn3 = new Array2DRowFieldMatrix<>(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));         m.setColumnMatrix(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnMatrix(1));         try {             m.setColumnMatrix(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetRowVector() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldVector<Dfp> mRow0 = new ArrayFieldVector<>(subRow0[0]);         FieldVector<Dfp> mRow3 = new ArrayFieldVector<>(subRow3[0]);         Assert.assertEquals("Row0", mRow0, m.getRowVector(0));         Assert.assertEquals("Row3", mRow3, m.getRowVector(3));         try {             m.getRowVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowVector() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldVector<Dfp> mRow3 = new ArrayFieldVector<>(subRow3[0]);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowVector(0, mRow3);         Assert.assertEquals(mRow3, m.getRowVector(0));         try {             m.setRowVector(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowVector(0, new ArrayFieldVector<>(Dfp25.getField(), 5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetColumnVector() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldVector<Dfp> mColumn1 = columnToVector(subColumn1);         FieldVector<Dfp> mColumn3 = columnToVector(subColumn3);         Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));         Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));         try {             m.getColumnVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnVector() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         FieldVector<Dfp> mColumn3 = columnToVector(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnVector(1));         m.setColumnVector(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnVector(1));         try {             m.setColumnVector(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnVector(0, new ArrayFieldVector<>(Dfp25.getField(), 5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      private FieldVector<Dfp> columnToVector(Dfp[][] column) {         Dfp[] data = new Dfp[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return new ArrayFieldVector<>(data, false);     }      @Test     public void testGetRow() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         checkArrays(subRow0[0], m.getRow(0));         checkArrays(subRow3[0], m.getRow(3));         try {             m.getRow(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRow(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRow() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);         m.setRow(0, subRow3[0]);         checkArrays(subRow3[0], m.getRow(0));         try {             m.setRow(-1, subRow3[0]);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRow(0, new Dfp[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetColumn() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         Dfp[] mColumn1 = columnToArray(subColumn1);         Dfp[] mColumn3 = columnToArray(subColumn3);         checkArrays(mColumn1, m.getColumn(1));         checkArrays(mColumn3, m.getColumn(3));         try {             m.getColumn(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumn(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumn() {         FieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(subTestData);         Dfp[] mColumn3 = columnToArray(subColumn3);         Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);         m.setColumn(1, mColumn3);         checkArrays(mColumn3, m.getColumn(1));         try {             m.setColumn(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumn(0, new Dfp[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      private Dfp[] columnToArray(Dfp[][] column) {         Dfp[] data = new Dfp[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return data;     }      private void checkArrays(Dfp[] expected, Dfp[] actual) {         Assert.assertEquals(expected.length, actual.length);         for (int i = 0; i < expected.length; ++i) {             Assert.assertEquals(expected[i], actual[i]);         }     }      @Test     public void testEqualsAndHashCode() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Array2DRowFieldMatrix<Dfp> m1 = (Array2DRowFieldMatrix<Dfp>) m.copy();         Array2DRowFieldMatrix<Dfp> mt = (Array2DRowFieldMatrix<Dfp>) m.transpose();         Assert.assertTrue(m.hashCode() != mt.hashCode());         Assert.assertEquals(m.hashCode(), m1.hashCode());         Assert.assertEquals(m, m);         Assert.assertEquals(m, m1);         Assert.assertFalse(m.equals(null));         Assert.assertFalse(m.equals(mt));         Assert.assertFalse(m.equals(new Array2DRowFieldMatrix<>(bigSingular)));     }      @Test     public void testToString() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         Assert.assertEquals("Array2DRowFieldMatrix{{1.,2.,3.},{2.,5.,3.},{1.,0.,8.}}", m.toString());         m = new Array2DRowFieldMatrix<>(Dfp25.getField());         Assert.assertEquals("Array2DRowFieldMatrix{}", m.toString());     }      @Test     public void testSetSubMatrix() {         Array2DRowFieldMatrix<Dfp> m = new Array2DRowFieldMatrix<>(testData);         m.setSubMatrix(detData2,1,1);         FieldMatrix<Dfp> expected = new Array2DRowFieldMatrix<>             (new Dfp[][] {                     {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)},                     {Dfp25.of(2),Dfp25.of(1),Dfp25.of(3)},                     {Dfp25.of(1),Dfp25.of(2),Dfp25.of(4)}              });         Assert.assertEquals(expected, m);          m.setSubMatrix(detData2,0,0);         expected = new Array2DRowFieldMatrix<>             (new Dfp[][] {                     {Dfp25.of(1),Dfp25.of(3),Dfp25.of(3)},                     {Dfp25.of(2),Dfp25.of(4),Dfp25.of(3)},                     {Dfp25.of(1),Dfp25.of(2),Dfp25.of(4)}              });         Assert.assertEquals(expected, m);          m.setSubMatrix(testDataPlus2,0,0);         expected = new Array2DRowFieldMatrix<>             (new Dfp[][] {                     {Dfp25.of(3),Dfp25.of(4),Dfp25.of(5)},                     {Dfp25.of(4),Dfp25.of(7),Dfp25.of(5)},                     {Dfp25.of(3),Dfp25.of(2),Dfp25.of(10)}              });         Assert.assertEquals(expected, m);          // dimension overflow         try {             m.setSubMatrix(testData,1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         // dimension underflow         try {             m.setSubMatrix(testData,-1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         try {             m.setSubMatrix(testData,1,-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }          // null         try {             m.setSubMatrix(null, 1, 1);             Assert.fail("expecting NullArgumentException");         } catch (NullArgumentException e) {             // expected         }         Array2DRowFieldMatrix<Dfp> m2 = new Array2DRowFieldMatrix<>(Dfp25.getField());         try {             m2.setSubMatrix(testData,0,1);             Assert.fail("expecting MathIllegalStateException");         } catch (MathIllegalStateException e) {             // expected         }         try {             m2.setSubMatrix(testData,1,0);             Assert.fail("expecting MathIllegalStateException");         } catch (MathIllegalStateException e) {             // expected         }          // ragged         try {             m.setSubMatrix(new Dfp[][] {{Dfp25.of(1)}, {Dfp25.of(2), Dfp25.of(3)}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // empty         try {             m.setSubMatrix(new Dfp[][] {{}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }      }      @Test     public void testWalk() {         int rows    = 150;         int columns = 75;          FieldMatrix<Dfp> m =             new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInRowOrder(new SetVisitor());         GetVisitor getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }          m = new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInColumnOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }          m = new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }          m = new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }     }      @Test     public void testSerial()  {         final int r = 2;         final int c = 3;         Array2DRowFieldMatrix<BigReal> m = new Array2DRowFieldMatrix<>(BigRealField.getInstance(), r, c);         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 m.setEntry(i, j, new BigReal(Math.random()));             }         }         Assert.assertEquals(m,TestUtils.serializeAndRecover(m));     }      private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Dfp> {         public SetVisitor() {             super(Dfp25.ZERO);         }         @Override         public Dfp visit(int i, int j, Dfp value) {             return Dfp25.of(i * 1024 + j, 1024);         }     }      private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Dfp> {         private int count;         public GetVisitor() {             super(Dfp25.ZERO);             count = 0;         }         @Override         public void visit(int i, int j, Dfp value) {             ++count;             Assert.assertEquals(Dfp25.of(i * 1024 + j, 1024), value);         }         public int getCount() {             return count;         }     }      //--------------- -----------------Protected methods      /** extracts the l  and u matrices from compact lu representation */     protected void splitLU(FieldMatrix<Dfp> lu,                            Dfp[][] lowerData,                            Dfp[][] upperData) {         if (!lu.isSquare()) {             throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension());         }         if (lowerData.length != lowerData[0].length) {             throw new DimensionMismatchException(lowerData.length, lowerData[0].length);         }         if (upperData.length != upperData[0].length) {             throw new DimensionMismatchException(upperData.length, upperData[0].length);         }         if (lowerData.length != upperData.length) {             throw new DimensionMismatchException(lowerData.length, upperData.length);         }         if (lowerData.length != lu.getRowDimension()) {             throw new DimensionMismatchException(lowerData.length, lu.getRowDimension());         }         int n = lu.getRowDimension();         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 if (j < i) {                     lowerData[i][j] = lu.getEntry(i, j);                     upperData[i][j] = Dfp25.ZERO;                 } else if (i == j) {                     lowerData[i][j] = Dfp25.ONE;                     upperData[i][j] = lu.getEntry(i, j);                 } else {                     lowerData[i][j] = Dfp25.ZERO;                     upperData[i][j] = lu.getEntry(i, j);                 }             }         }     }      /** Returns the result of applying the given row permutation to the matrix */     protected FieldMatrix<Dfp> permuteRows(FieldMatrix<Dfp> matrix, int[] permutation) {         if (!matrix.isSquare()) {             throw new NonSquareMatrixException(matrix.getRowDimension(),                                                matrix.getColumnDimension());         }         if (matrix.getRowDimension() != permutation.length) {             throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length);         }         int n = matrix.getRowDimension();         int m = matrix.getColumnDimension();         Dfp out[][] = new Dfp[m][n];         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 out[i][j] = matrix.getEntry(permutation[i], j);             }         }         return new Array2DRowFieldMatrix<>(out);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Random;  import org.junit.Assert; import org.junit.Test;   public class RRQRDecompositionTest {     private double[][] testData3x3NonSingular = {             { 12, -51, 4 },             { 6, 167, -68 },             { -4, 24, -41 }, };      private double[][] testData3x3Singular = {             { 1, 4, 7, },             { 2, 5, 8, },             { 3, 6, 9, }, };      private double[][] testData3x4 = {             { 12, -51, 4, 1 },             { 6, 167, -68, 2 },             { -4, 24, -41, 3 }, };      private double[][] testData4x3 = {             { 12, -51, 4, },             { 6, 167, -68, },             { -4, 24, -41, },             { -5, 34, 7, }, };      private static final double entryTolerance = 10e-16;      private static final double normTolerance = 10e-14;      /** test dimensions */     @Test     public void testDimensions() {         checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));          checkDimension(MatrixUtils.createRealMatrix(testData4x3));          checkDimension(MatrixUtils.createRealMatrix(testData3x4));          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         checkDimension(createTestMatrix(r, p, q));         checkDimension(createTestMatrix(r, q, p));      }      private void checkDimension(RealMatrix m) {         int rows = m.getRowDimension();         int columns = m.getColumnDimension();         RRQRDecomposition qr = new RRQRDecomposition(m);         Assert.assertEquals(rows,    qr.getQ().getRowDimension());         Assert.assertEquals(rows,    qr.getQ().getColumnDimension());         Assert.assertEquals(rows,    qr.getR().getRowDimension());         Assert.assertEquals(columns, qr.getR().getColumnDimension());     }      /** test AP = QR */     @Test     public void testAPEqualQR() {         checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));          checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));          checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x4));          checkAPEqualQR(MatrixUtils.createRealMatrix(testData4x3));          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         checkAPEqualQR(createTestMatrix(r, p, q));          checkAPEqualQR(createTestMatrix(r, q, p));      }      private void checkAPEqualQR(RealMatrix m) {         RRQRDecomposition rrqr = new RRQRDecomposition(m);         double norm = rrqr.getQ().multiply(rrqr.getR()).subtract(m.multiply(rrqr.getP())).getNorm();         Assert.assertEquals(0, norm, normTolerance);     }      /** test the orthogonality of Q */     @Test     public void testQOrthogonal() {         checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));          checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));          checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));          checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         checkQOrthogonal(createTestMatrix(r, p, q));          checkQOrthogonal(createTestMatrix(r, q, p));      }      private void checkQOrthogonal(RealMatrix m) {         RRQRDecomposition qr = new RRQRDecomposition(m);         RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());         double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();         Assert.assertEquals(0, norm, normTolerance);     }      /** test that R is upper triangular */     @Test     public void testRUpperTriangular() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);         checkUpperTriangular(new RRQRDecomposition(matrix).getR());          matrix = MatrixUtils.createRealMatrix(testData3x3Singular);         checkUpperTriangular(new RRQRDecomposition(matrix).getR());          matrix = MatrixUtils.createRealMatrix(testData3x4);         checkUpperTriangular(new RRQRDecomposition(matrix).getR());          matrix = MatrixUtils.createRealMatrix(testData4x3);         checkUpperTriangular(new RRQRDecomposition(matrix).getR());          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         matrix = createTestMatrix(r, p, q);         checkUpperTriangular(new RRQRDecomposition(matrix).getR());          matrix = createTestMatrix(r, p, q);         checkUpperTriangular(new RRQRDecomposition(matrix).getR());      }      private void checkUpperTriangular(RealMatrix m) {         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {             @Override             public void visit(int row, int column, double value) {                 if (column < row) {                     Assert.assertEquals(0.0, value, entryTolerance);                 }             }         });     }      /** test that H is trapezoidal */     @Test     public void testHTrapezoidal() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);         checkTrapezoidal(new RRQRDecomposition(matrix).getH());          matrix = MatrixUtils.createRealMatrix(testData3x3Singular);         checkTrapezoidal(new RRQRDecomposition(matrix).getH());          matrix = MatrixUtils.createRealMatrix(testData3x4);         checkTrapezoidal(new RRQRDecomposition(matrix).getH());          matrix = MatrixUtils.createRealMatrix(testData4x3);         checkTrapezoidal(new RRQRDecomposition(matrix).getH());          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         matrix = createTestMatrix(r, p, q);         checkTrapezoidal(new RRQRDecomposition(matrix).getH());          matrix = createTestMatrix(r, p, q);         checkTrapezoidal(new RRQRDecomposition(matrix).getH());      }      private void checkTrapezoidal(RealMatrix m) {         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {             @Override             public void visit(int row, int column, double value) {                 if (column > row) {                     Assert.assertEquals(0.0, value, entryTolerance);                 }             }         });     }      @Test(expected=SingularMatrixException.class)     public void testNonInvertible() {         RRQRDecomposition qr =             new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 3.0e-16);         qr.getSolver().getInverse();     }      private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {         RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);         m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){             @Override             public double visit(int row, int column, double value) {                 return 2.0 * r.nextDouble() - 1.0;             }         });         return m;     }      /** test the rank is returned correctly */     @Test     public void testRank() {         double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } };         RealMatrix m = new Array2DRowRealMatrix(d);         RRQRDecomposition qr = new RRQRDecomposition(m);         Assert.assertEquals(2, qr.getRank(0));     }     @Test     public void testRank2() {         double[][] d = { { 1, 1, 1 }, { 2, 3, 4 }, { 1, 2, 3 } };         RealMatrix m = new Array2DRowRealMatrix(d);         RRQRDecomposition qr = new RRQRDecomposition(m);         Assert.assertEquals(2, qr.getRank(1e-14));     }      // MATH-1417     @Test     public void testRank3() {         double[][] d = {             {0, 0, 0, 0, 0, 0, 0, 0, 0},             {0, 1, 0, 0, 0, 0, 0, 0, 0},             {0, 0, 1, 0, 0, 0, 0, 0, 0},             {0, 0, 1, 0, 0, 0, 0, 0, 0},             {0, 0, 1, 0, 0, 0, 0, 0, 0},             {0, 0, 0, 1, 0, 0, 0, 0, 0},             {0, 0, 0, 0, 0, 0, 1, 0, 0},             {0, 0, 0, 0, 0, 0, 0, 0, 0}         };         RealMatrix m = new Array2DRowRealMatrix(d);         RRQRDecomposition qr = new RRQRDecomposition(m.transpose());         Assert.assertEquals(4, qr.getRank(1e-14));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import java.io.Serializable; import java.util.Arrays; import java.util.Iterator; import java.util.NoSuchElementException;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Abs; import org.apache.commons.math4.analysis.function.Acos; import org.apache.commons.math4.analysis.function.Asin; import org.apache.commons.math4.analysis.function.Atan; import org.apache.commons.math4.analysis.function.Cbrt; import org.apache.commons.math4.analysis.function.Ceil; import org.apache.commons.math4.analysis.function.Cos; import org.apache.commons.math4.analysis.function.Cosh; import org.apache.commons.math4.analysis.function.Exp; import org.apache.commons.math4.analysis.function.Expm1; import org.apache.commons.math4.analysis.function.Floor; import org.apache.commons.math4.analysis.function.Inverse; import org.apache.commons.math4.analysis.function.Log; import org.apache.commons.math4.analysis.function.Log10; import org.apache.commons.math4.analysis.function.Log1p; import org.apache.commons.math4.analysis.function.Power; import org.apache.commons.math4.analysis.function.Rint; import org.apache.commons.math4.analysis.function.Signum; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.Sinh; import org.apache.commons.math4.analysis.function.Sqrt; import org.apache.commons.math4.analysis.function.Tan; import org.apache.commons.math4.analysis.function.Tanh; import org.apache.commons.math4.analysis.function.Ulp; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   public abstract class RealVectorAbstractTest {      protected enum BinaryOperation {         ADD, SUB, MUL, DIV     }      /**      * <p>      * This is an attempt at covering most particular cases of combining two      * values. Here {@code x} is the value returned by      * {@link #getPreferredEntryValue()}, while {@code y} and {@code z} are two      * "normal" values.      * </p>      * <ol>      *   <li>      *     Addition: the following cases should be covered      *     <ul>      *       <li>{@code (2 * x) + (-x)}</li>      *       <li>{@code (-x) + 2 * x}</li>      *       <li>{@code x + y}</li>      *       <li>{@code y + x}</li>      *       <li>{@code y + z}</li>      *       <li>{@code y + (x - y)}</li>      *       <li>{@code (y - x) + x}</li>      *     </ul>      *     The values to be considered are:      *     {@code x, y, z, 2 * x, -x, x - y, y - x}.      *   </li>      *   <li>      *     Subtraction: the following cases should be covered      *     <ul>      *       <li>{@code (2 * x) - x}</li>      *       <li>{@code x - y}</li>      *       <li>{@code y - x}</li>      *       <li>{@code y - z}</li>      *       <li>{@code y - (y - x)}</li>      *       <li>{@code (y + x) - y}</li>      *     </ul>      *     The values to be considered are: {@code x, y, z, x + y, y - x}.      *   </li>      *   <li>      *     Multiplication      *     <ul>      *       <li>{@code (x * x) * (1 / x)}</li>      *       <li>{@code (1 / x) * (x * x)}</li>      *       <li>{@code x * y}</li>      *       <li>{@code y * x}</li>      *       <li>{@code y * z}</li>      *     </ul>      *     The values to be considered are: {@code x, y, z, 1 / x, x * x}.      *   </li>      *   <li>      *     Division      *     <ul>      *       <li>{@code (x * x) / x}</li>      *       <li>{@code x / y}</li>      *       <li>{@code y / x}</li>      *       <li>{@code y / z}</li>      *     </ul>      *     The values to be considered are: {@code x, y, z, x * x}.      *   </li>      * </ol>      * Also to be considered {@code NaN}, {@code POSITIVE_INFINITY},      * {@code NEGATIVE_INFINITY}, {@code +0.0}, {@code -0.0}.      */     private final double[] values;      /**      * Creates a new instance of {@link RealVector}, with specified entries.      * The returned vector must be of the type currently tested. It should be      * noted that some tests assume that no references to the specified      * {@code double[]} are kept in the returned object: if necessary, defensive      * copy of this array should be made.      *      * @param data the entries of the vector to be created      * @return a new {@link RealVector} of the type to be tested      */     public abstract RealVector create(double[] data);      /**      * Creates a new instance of {@link RealVector}, with specified entries.      * The type of the returned vector must be different from the type currently      * tested. It should be noted that some tests assume that no references to      * the specified {@code double[]} are kept in the returned object: if      * necessary, defensive copy of this array should be made.      *      * @param data the entries of the vector to be created      * @return a new {@link RealVector} of an alien type      */     public RealVector createAlien(double[] data){         return new RealVectorTestImpl(data);     }      /**      * Returns a preferred value of the entries, to be tested specifically. Some      * implementations of {@link RealVector} (e.g. {@link OpenMapRealVector}) do      * not store specific values of entries. In order to ensure that all tests      * take into account this specific value, some entries of the vectors to be      * tested are deliberately set to the value returned by the present method.      * The default implementation returns {@code 0.0}.      *      * @return a value which <em>should</em> be present in all vectors to be      * tested      */     public double getPreferredEntryValue() {         return 0.0;     }      public RealVectorAbstractTest() {         /*          * Make sure that x, y, z are three different values. Also, x is the          * preferred value (e.g. the value which is not stored in sparse          * implementations).          */         final double x = getPreferredEntryValue();         final double y = x + 1d;         final double z = y + 1d;          values =             new double[] {                 Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,                 0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x             };     }      @Test     public void testGetDimension() {         final double x = getPreferredEntryValue();         final double[] data1 = {x, x, x, x};         Assert.assertEquals(data1.length, create(data1).getDimension());         final double y = x + 1;         final double[] data2 = {y, y, y, y};         Assert.assertEquals(data2.length, create(data2).getDimension());     }      @Test     public void testGetEntry() {         final double x = getPreferredEntryValue();         final double[] data = {x, 1d, 2d, x, x};         final RealVector v = create(data);         for (int i = 0; i < data.length; i++) {             Assert.assertEquals("entry " + i, data[i], v.getEntry(i), 0d);         }     }      @Test(expected=OutOfRangeException.class)     public void testGetEntryInvalidIndex1() {         create(new double[4]).getEntry(-1);     }      @Test(expected=OutOfRangeException.class)     public void testGetEntryInvalidIndex2() {         create(new double[4]).getEntry(4);     }      @Test     public void testSetEntry() {         final double x = getPreferredEntryValue();         final double[] data = {x, 1d, 2d, x, x};         final double[] expected = Arrays.copyOf(data, data.length);         final RealVector actual = create(data);          /*          * Try setting to any value.          */         for (int i = 0; i < data.length; i++) {             final double oldValue = data[i];             final double newValue = oldValue + 1d;             expected[i] = newValue;             actual.setEntry(i, newValue);             TestUtils.assertEquals("while setting entry #" + i, expected,                 actual, 0d);             expected[i] = oldValue;             actual.setEntry(i, oldValue);         }          /*          * Try setting to the preferred value.          */         for (int i = 0; i < data.length; i++) {             final double oldValue = data[i];             final double newValue = x;             expected[i] = newValue;             actual.setEntry(i, newValue);             TestUtils.assertEquals("while setting entry #" + i, expected,                 actual, 0d);             expected[i] = oldValue;             actual.setEntry(i, oldValue);         }     }      @Test(expected=OutOfRangeException.class)     public void testSetEntryInvalidIndex1() {         create(new double[4]).setEntry(-1, getPreferredEntryValue());     }      @Test(expected=OutOfRangeException.class)     public void testSetEntryInvalidIndex2() {         create(new double[4]).setEntry(4, getPreferredEntryValue());     }      @Test     public void testAddToEntry() {         final double x = getPreferredEntryValue();         final double[] data1 = {x, 1d, 2d, x, x};          final double[] expected = Arrays.copyOf(data1, data1.length);         final RealVector actual = create(data1);          /*          * Try adding any value.          */         double increment = 1d;         for (int i = 0; i < data1.length; i++) {             final double oldValue = data1[i];             expected[i] += increment;             actual.addToEntry(i, increment);             TestUtils.assertEquals("while incrementing entry #" + i, expected,                 actual, 0d);             expected[i] = oldValue;             actual.setEntry(i, oldValue);         }          /*          * Try incrementing so that result is equal to preferred value.          */         for (int i = 0; i < data1.length; i++) {             final double oldValue = data1[i];             increment = x - oldValue;             expected[i] = x;             actual.addToEntry(i, increment);             TestUtils.assertEquals("while incrementing entry #" + i, expected,                 actual, 0d);             expected[i] = oldValue;             actual.setEntry(i, oldValue);         }     }      @Test(expected=OutOfRangeException.class)     public void testAddToEntryInvalidIndex1() {         create(new double[3]).addToEntry(-1, getPreferredEntryValue());     }      @Test(expected=OutOfRangeException.class)     public void testAddToEntryInvalidIndex2() {         create(new double[3]).addToEntry(4, getPreferredEntryValue());     }      private void doTestAppendVector(final String message, final RealVector v1,         final RealVector v2, final double delta) {          final int n1 = v1.getDimension();         final int n2 = v2.getDimension();         final RealVector v = v1.append(v2);         Assert.assertEquals(message, n1 + n2, v.getDimension());         for (int i = 0; i < n1; i++) {             final String msg = message + ", entry #" + i;             Assert.assertEquals(msg, v1.getEntry(i), v.getEntry(i), delta);         }         for (int i = 0; i < n2; i++) {             final String msg = message + ", entry #" + (n1 + i);             Assert.assertEquals(msg, v2.getEntry(i), v.getEntry(n1 + i), delta);         }     }      @Test     public void testAppendVector() {         final double x = getPreferredEntryValue();         final double[] data1 =  {x, 1d, 2d, x, x};         final double[] data2 =  {x, x, 3d, x, 4d, x};          doTestAppendVector("same type", create(data1), create(data2), 0d);         doTestAppendVector("mixed types", create(data1), createAlien(data2), 0d);     }      private void doTestAppendScalar(final String message, final RealVector v,         final double d, final double delta) {          final int n = v.getDimension();         final RealVector w = v.append(d);         Assert.assertEquals(message, n + 1, w.getDimension());         for (int i = 0; i < n; i++) {             final String msg = message + ", entry #" + i;             Assert.assertEquals(msg, v.getEntry(i), w.getEntry(i), delta);         }         final String msg = message + ", entry #" + n;         Assert.assertEquals(msg, d, w.getEntry(n), delta);     }      @Test     public void testAppendScalar() {         final double x = getPreferredEntryValue();         final double[] data = new double[] {x, 1d, 2d, x, x};          doTestAppendScalar("", create(data), 1d, 0d);         doTestAppendScalar("", create(data), x, 0d);     }      @Test     public void testGetSubVector() {         final double x = getPreferredEntryValue();         final double[] data = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};         final int index = 1;         final int n = data.length - 5;         final RealVector actual = create(data).getSubVector(index, n);         final double[] expected = new double[n];         System.arraycopy(data, index, expected, 0, n);         TestUtils.assertEquals("", expected, actual, 0d);     }      @Test(expected = OutOfRangeException.class)     public void testGetSubVectorInvalidIndex1() {         final int n = 10;         create(new double[n]).getSubVector(-1, 2);     }      @Test(expected = OutOfRangeException.class)     public void testGetSubVectorInvalidIndex2() {         final int n = 10;         create(new double[n]).getSubVector(n, 2);     }      @Test(expected = OutOfRangeException.class)     public void testGetSubVectorInvalidIndex3() {         final int n = 10;         create(new double[n]).getSubVector(0, n + 1);     }      @Test(expected = NotPositiveException.class)     public void testGetSubVectorInvalidIndex4() {         final int n = 10;         create(new double[n]).getSubVector(3, -2);     }      @Test     public void testSetSubVectorSameType() {         final double x = getPreferredEntryValue();         final double[] expected = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};         final double[] sub = {5d, x, 6d, 7d, 8d};         final RealVector actual = create(expected);         final int index = 2;         actual.setSubVector(index, create(sub));          for (int i = 0; i < sub.length; i++){             expected[index + i] = sub[i];         }         TestUtils.assertEquals("", expected, actual, 0d);     }      @Test     public void testSetSubVectorMixedType() {         final double x = getPreferredEntryValue();         final double[] expected = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};         final double[] sub = {5d, x, 6d, 7d, 8d};         final RealVector actual = create(expected);         final int index = 2;         actual.setSubVector(index, createAlien(sub));          for (int i = 0; i < sub.length; i++){             expected[index + i] = sub[i];         }         TestUtils.assertEquals("", expected, actual, 0d);     }      @Test(expected = OutOfRangeException.class)     public void testSetSubVectorInvalidIndex1() {         create(new double[10]).setSubVector(-1, create(new double[2]));     }      @Test(expected = OutOfRangeException.class)     public void testSetSubVectorInvalidIndex2() {         create(new double[10]).setSubVector(10, create(new double[2]));     }      @Test(expected = OutOfRangeException.class)     public void testSetSubVectorInvalidIndex3() {         create(new double[10]).setSubVector(9, create(new double[2]));     }      @Test     public void testIsNaN() {         final RealVector v = create(new double[] {0, 1, 2});          Assert.assertFalse(v.isNaN());         v.setEntry(1, Double.NaN);         Assert.assertTrue(v.isNaN());     }      @Test     public void testIsInfinite() {         final RealVector v = create(new double[] { 0, 1, 2 });          Assert.assertFalse(v.isInfinite());         v.setEntry(0, Double.POSITIVE_INFINITY);         Assert.assertTrue(v.isInfinite());         v.setEntry(1, Double.NaN);         Assert.assertFalse(v.isInfinite());     }      protected void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed, boolean ignoreSpecial) {         final double[] data1 = new double[values.length * values.length];         final double[] data2 = new double[values.length * values.length];         int k = 0;         for (int i = 0; i < values.length; i++) {             for (int j = 0; j < values.length; j++) {                 data1[k] = values[i];                 data2[k] = values[j];                 ++k;             }         }         final RealVector v1 = create(data1);         final RealVector v2 = mixed ? createAlien(data2) : create(data2);         final RealVector actual;         switch (op) {             case ADD:                 actual = v1.add(v2);                 break;             case SUB:                 actual = v1.subtract(v2);                 break;             case MUL:                 actual = v1.ebeMultiply(v2);                 break;             case DIV:                 actual = v1.ebeDivide(v2);                 break;             default:                 throw new AssertionError("unexpected value");         }         final double[] expected = new double[data1.length];         for (int i = 0; i < expected.length; i++) {             switch (op) {                 case ADD:                     expected[i] = data1[i] + data2[i];                     break;                 case SUB:                     expected[i] = data1[i] - data2[i];                     break;                 case MUL:                     expected[i] = data1[i] * data2[i];                     break;                 case DIV:                     expected[i] = data1[i] / data2[i];                     break;                 default:                     throw new AssertionError("unexpected value");             }         }         for (int i = 0; i < expected.length; i++) {             boolean isSpecial = Double.isNaN(expected[i]) || Double.isInfinite(expected[i]);             if (!(isSpecial && ignoreSpecial)) {                 final String msg = "entry #"+i+", left = "+data1[i]+", right = " + data2[i];                 Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);             }         }     }      private void doTestEbeBinaryOperationDimensionMismatch(final BinaryOperation op) {         final int n = 10;         switch (op) {             case ADD:                 create(new double[n]).add(create(new double[n + 1]));                 break;             case SUB:                 create(new double[n]).subtract(create(new double[n + 1]));                 break;             case MUL:                 create(new double[n]).ebeMultiply(create(new double[n + 1]));                 break;             case DIV:                 create(new double[n]).ebeDivide(create(new double[n + 1]));                 break;             default:                 throw new AssertionError("unexpected value");         }     }      @Test     public void testAddSameType() {         doTestEbeBinaryOperation(BinaryOperation.ADD, false, false);     }      @Test     public void testAddMixedTypes() {         doTestEbeBinaryOperation(BinaryOperation.ADD, true, false);     }      @Test(expected = DimensionMismatchException.class)     public void testAddDimensionMismatch() {         doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.ADD);     }      @Test     public void testSubtractSameType() {         doTestEbeBinaryOperation(BinaryOperation.SUB, false, false);     }      @Test     public void testSubtractMixedTypes() {         doTestEbeBinaryOperation(BinaryOperation.SUB, true, false);     }      @Test(expected = DimensionMismatchException.class)     public void testSubtractDimensionMismatch() {         doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.SUB);     }      @Test     public void testEbeMultiplySameType() {         doTestEbeBinaryOperation(BinaryOperation.MUL, false, false);     }      @Test     public void testEbeMultiplyMixedTypes() {         doTestEbeBinaryOperation(BinaryOperation.MUL, true, false);     }      @Test(expected = DimensionMismatchException.class)     public void testEbeMultiplyDimensionMismatch() {         doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.MUL);     }      @Test     public void testEbeDivideSameType() {         doTestEbeBinaryOperation(BinaryOperation.DIV, false, false);     }     @Test     public void testEbeDivideMixedTypes() {         doTestEbeBinaryOperation(BinaryOperation.DIV, true, false);     }      @Test(expected = DimensionMismatchException.class)     public void testEbeDivideDimensionMismatch() {         doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.DIV);     }      private void doTestGetDistance(final boolean mixed) {         final double x = getPreferredEntryValue();         final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };         final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };         final RealVector v1 = create(data1);         final RealVector v2;         if (mixed) {             v2 = createAlien(data2);         } else {             v2 = create(data2);         }         final double actual = v1.getDistance(v2);         double expected = 0d;         for (int i = 0; i < data1.length; i++) {             final double delta = data2[i] - data1[i];             expected += delta * delta;         }         expected = FastMath.sqrt(expected);         Assert.assertEquals("", expected, actual, 0d);     }      @Test     public void testGetDistanceSameType() {         doTestGetDistance(false);     }      @Test     public void testGetDistanceMixedTypes() {         doTestGetDistance(true);     }      @Test(expected = DimensionMismatchException.class)     public void testGetDistanceDimensionMismatch() {         create(new double[4]).getDistance(createAlien(new double[5]));     }      @Test     public void testGetNorm() {         final double x = getPreferredEntryValue();         final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };         final RealVector v = create(data);         final double actual = v.getNorm();         double expected = 0d;         for (int i = 0; i < data.length; i++) {             expected += data[i] * data[i];         }         expected = FastMath.sqrt(expected);         Assert.assertEquals("", expected, actual, 0d);     }      private void doTestGetL1Distance(final boolean mixed) {         final double x = getPreferredEntryValue();         final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };         final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };         final RealVector v1 = create(data1);         final RealVector v2;         if (mixed) {             v2 = createAlien(data2);         } else {             v2 = create(data2);         }         final double actual = v1.getL1Distance(v2);         double expected = 0d;         for (int i = 0; i < data1.length; i++) {             final double delta = data2[i] - data1[i];             expected += FastMath.abs(delta);         }         Assert.assertEquals("", expected, actual, 0d);     }      @Test     public void testGetL1DistanceSameType() {         doTestGetL1Distance(false);     }      @Test     public void testGetL1DistanceMixedTypes() {         doTestGetL1Distance(true);     }      @Test(expected = DimensionMismatchException.class)     public void testGetL1DistanceDimensionMismatch() {         create(new double[4]).getL1Distance(createAlien(new double[5]));     }      @Test     public void testGetL1Norm() {         final double x = getPreferredEntryValue();         final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };         final RealVector v = create(data);         final double actual = v.getL1Norm();         double expected = 0d;         for (int i = 0; i < data.length; i++) {             expected += FastMath.abs(data[i]);         }         Assert.assertEquals("", expected, actual, 0d);      }      private void doTestGetLInfDistance(final boolean mixed) {         final double x = getPreferredEntryValue();         final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };         final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };         final RealVector v1 = create(data1);         final RealVector v2;         if (mixed) {             v2 = createAlien(data2);         } else {             v2 = create(data2);         }         final double actual = v1.getLInfDistance(v2);         double expected = 0d;         for (int i = 0; i < data1.length; i++) {             final double delta = data2[i] - data1[i];             expected = FastMath.max(expected, FastMath.abs(delta));         }         Assert.assertEquals("", expected, actual, 0d);     }      @Test     public void testGetLInfDistanceSameType() {         doTestGetLInfDistance(false);     }      @Test     public void testGetLInfDistanceMixedTypes() {         doTestGetLInfDistance(true);     }      @Test(expected = DimensionMismatchException.class)     public void testGetLInfDistanceDimensionMismatch() {         create(new double[4]).getLInfDistance(createAlien(new double[5]));     }      @Test     public void testGetLInfNorm() {         final double x = getPreferredEntryValue();         final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };         final RealVector v = create(data);         final double actual = v.getLInfNorm();         double expected = 0d;         for (int i = 0; i < data.length; i++) {             expected = FastMath.max(expected, FastMath.abs(data[i]));         }         Assert.assertEquals("", expected, actual, 0d);      }      private void doTestMapBinaryOperation(final BinaryOperation op, final boolean inPlace) {         final double[] expected = new double[values.length];         for (int i = 0; i < values.length; i++) {             final double d = values[i];             for (int j = 0; j < expected.length; j++) {                 switch (op) {                     case ADD:                         expected[j] = values[j] + d;                         break;                     case SUB:                         expected[j] = values[j] - d;                         break;                     case MUL:                         expected[j] = values[j] * d;                         break;                     case DIV:                         expected[j] = values[j] / d;                         break;                     default:                         throw new AssertionError("unexpected value");                 }             }             final RealVector v = create(values);             final RealVector actual;             if (inPlace) {                 switch (op) {                     case ADD:                         actual = v.mapAddToSelf(d);                         break;                     case SUB:                         actual = v.mapSubtractToSelf(d);                         break;                     case MUL:                         actual = v.mapMultiplyToSelf(d);                         break;                     case DIV:                         actual = v.mapDivideToSelf(d);                         break;                     default:                         throw new AssertionError("unexpected value");                 }             } else {                 switch (op) {                     case ADD:                         actual = v.mapAdd(d);                         break;                     case SUB:                         actual = v.mapSubtract(d);                         break;                     case MUL:                         actual = v.mapMultiply(d);                         break;                     case DIV:                         actual = v.mapDivide(d);                         break;                     default:                         throw new AssertionError("unexpected value");                 }             }             TestUtils.assertEquals(Double.toString(d), expected, actual, 0d);         }     }      @Test     public void testMapAdd() {         doTestMapBinaryOperation(BinaryOperation.ADD, false);     }      @Test     public void testMapAddToSelf() {         doTestMapBinaryOperation(BinaryOperation.ADD, true);     }      @Test     public void testMapSubtract() {         doTestMapBinaryOperation(BinaryOperation.SUB, false);     }      @Test     public void testMapSubtractToSelf() {         doTestMapBinaryOperation(BinaryOperation.SUB, true);     }      @Test     public void testMapMultiply() {         doTestMapBinaryOperation(BinaryOperation.MUL, false);     }      @Test     public void testMapMultiplyToSelf() {         doTestMapBinaryOperation(BinaryOperation.MUL, true);     }      @Test     public void testMapDivide() {         doTestMapBinaryOperation(BinaryOperation.DIV, false);     }      @Test     public void testMapDivideToSelf() {         doTestMapBinaryOperation(BinaryOperation.DIV, true);     }      private void doTestMapFunction(final UnivariateFunction f,         final boolean inPlace) {         final double[] data = new double[values.length + 6];         System.arraycopy(values, 0, data, 0, values.length);         data[values.length + 0] = 0.5 * FastMath.PI;         data[values.length + 1] = -0.5 * FastMath.PI;         data[values.length + 2] = FastMath.E;         data[values.length + 3] = -FastMath.E;         data[values.length + 4] = 1.0;         data[values.length + 5] = -1.0;         final double[] expected = new double[data.length];         for (int i = 0; i < data.length; i++) {             expected[i] = f.value(data[i]);         }         final RealVector v = create(data);         final RealVector actual;         if (inPlace) {             actual = v.mapToSelf(f);             Assert.assertSame(v, actual);         } else {             actual = v.map(f);         }         TestUtils.assertEquals(f.getClass().getSimpleName(), expected, actual, 1E-16);     }      protected UnivariateFunction[] createFunctions() {         return new UnivariateFunction[] {             new Power(2.0), new Exp(), new Expm1(), new Log(), new Log10(),             new Log1p(), new Cosh(), new Sinh(), new Tanh(), new Cos(),             new Sin(), new Tan(), new Acos(), new Asin(), new Atan(),             new Inverse(), new Abs(), new Sqrt(), new Cbrt(), new Ceil(),             new Floor(), new Rint(), new Signum(), new Ulp()         };     }      @Test     public void testMap() {         final UnivariateFunction[] functions = createFunctions();         for (UnivariateFunction f : functions) {             doTestMapFunction(f, false);         }     }      @Test     public void testMapToSelf() {         final UnivariateFunction[] functions = createFunctions();         for (UnivariateFunction f : functions) {             doTestMapFunction(f, true);         }     }      private void doTestOuterProduct(final boolean mixed) {         final double[] dataU = values;         final RealVector u = create(dataU);         final double[] dataV = new double[values.length + 3];         System.arraycopy(values, 0, dataV, 0, values.length);         dataV[values.length] = 1d;         dataV[values.length] = -2d;         dataV[values.length] = 3d;         final RealVector v;         if (mixed) {             v = createAlien(dataV);         } else {             v = create(dataV);         }         final RealMatrix uv = u.outerProduct(v);         Assert.assertEquals("number of rows", dataU.length, uv             .getRowDimension());         Assert.assertEquals("number of columns", dataV.length, uv             .getColumnDimension());         for (int i = 0; i < dataU.length; i++) {             for (int j = 0; j < dataV.length; j++) {                 final double expected = dataU[i] * dataV[j];                 final double actual = uv.getEntry(i, j);                 Assert.assertEquals(dataU[i] + " * " + dataV[j], expected, actual, 0d);             }         }     }      @Test     public void testOuterProductSameType() {         doTestOuterProduct(false);     }      @Test     public void testOuterProductMixedTypes() {         doTestOuterProduct(true);     }      private void doTestProjection(final boolean mixed) {         final double x = getPreferredEntryValue();         final double[] data1 = {             x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x         };         final double[] data2 = {             5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d         };         double dotProduct = 0d;         double norm2 = 0d;         for (int i = 0; i < data1.length; i++){             dotProduct += data1[i] * data2[i];             norm2 += data2[i] * data2[i];         }         final double s = dotProduct / norm2;         final double[] expected = new double[data1.length];         for (int i = 0; i < data2.length; i++) {             expected[i] = s * data2[i];         }         final RealVector v1 = create(data1);         final RealVector v2;         if (mixed) {             v2 = createAlien(data2);         } else {             v2 = create(data2);         }         final RealVector actual = v1.projection(v2);         TestUtils.assertEquals("", expected, actual, 0d);     }      @Test     public void testProjectionSameType() {         doTestProjection(false);     }      @Test     public void testProjectionMixedTypes() {         doTestProjection(true);     }      @Test(expected = MathArithmeticException.class)     public void testProjectionNullVector() {         create(new double[4]).projection(create(new double[4]));     }      @Test(expected = DimensionMismatchException.class)     public void testProjectionDimensionMismatch() {         final RealVector v1 = create(new double[4]);         final RealVector v2 = create(new double[5]);         v2.set(1.0);         v1.projection(v2);     }      @Test     public void testSet() {         for (int i = 0; i < values.length; i++) {             final double expected = values[i];             final RealVector v = create(values);             v.set(expected);             for (int j = 0; j < values.length; j++) {                 Assert.assertEquals("entry #" + j, expected, v.getEntry(j), 0);             }         }     }      @Test     public void testToArray() {         final double[] data = create(values).toArray();         Assert.assertNotSame(values, data);         for (int i = 0; i < values.length; i++) {             Assert.assertEquals("entry #" + i, values[i], data[i], 0);         }     }      private void doTestUnitVector(final boolean inPlace) {         final double x = getPreferredEntryValue();         final double[] data = {             x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x         };         double norm = 0d;         for (int i = 0; i < data.length; i++) {             norm += data[i] * data[i];         }         norm = FastMath.sqrt(norm);         final double[] expected = new double[data.length];         for (int i = 0; i < expected.length; i++) {             expected[i] = data[i] / norm;         }         final RealVector v = create(data);         final RealVector actual;         if (inPlace) {             v.unitize();             actual = v;         } else {             actual = v.unitVector();             Assert.assertNotSame(v, actual);         }         TestUtils.assertEquals("", expected, actual, 0d);     }      @Test     public void testUnitVector() {         doTestUnitVector(false);     }      @Test     public void testUnitize() {         doTestUnitVector(true);     }      private void doTestUnitVectorNullVector(final boolean inPlace) {         final double[] data = {             0d, 0d, 0d, 0d, 0d         };         if (inPlace) {             create(data).unitize();         } else {             create(data).unitVector();         }     }      @Test(expected=MathArithmeticException.class)     public void testUnitVectorNullVector() {         doTestUnitVectorNullVector(false);     }      @Test(expected=MathArithmeticException.class)     public void testUnitizeNullVector() {         doTestUnitVectorNullVector(true);     }      @Test     public void testIterator() {         final RealVector v = create(values);         final Iterator<RealVector.Entry> it = v.iterator();         for (int i = 0; i < values.length; i++) {             Assert.assertTrue("entry #" + i, it.hasNext());             final RealVector.Entry e = it.next();             Assert.assertEquals("", i, e.getIndex());             Assert.assertEquals("", values[i], e.getValue(), 0d);             try {                 it.remove();                 Assert.fail("MathUnsupportedOperationException should have been thrown");             } catch (MathUnsupportedOperationException exc) {                 // Expected behavior             }         }         Assert.assertFalse(it.hasNext());         try {             it.next();             Assert.fail("NoSuchElementException should have been thrown");         } catch (NoSuchElementException e) {             // Expected behavior         }     }      private void doTestCombine(final boolean inPlace, final boolean mixed) {         final int n = values.length * values.length;         final double[] data1 = new double[n];         final double[] data2 = new double[n];         for (int i = 0; i < values.length; i++) {             for (int j = 0; j < values.length; j++) {                 final int index = values.length * i + j;                 data1[index] = values[i];                 data2[index] = values[j];             }         }         final RealVector v1 = create(data1);         final RealVector v2 = mixed ? createAlien(data2) : create(data2);         final double[] expected = new double[n];         for (int i = 0; i < values.length; i++) {             final double a1 = values[i];             for (int j = 0; j < values.length; j++) {                 final double a2 = values[j];                 for (int k = 0; k < n; k++) {                     expected[k] = a1 * data1[k] + a2 * data2[k];                 }                 final RealVector actual;                 if (inPlace) {                     final RealVector v1bis = v1.copy();                     actual = v1bis.combineToSelf(a1, a2, v2);                     Assert.assertSame(v1bis, actual);                 } else {                     actual = v1.combine(a1, a2, v2);                 }                 TestUtils.assertEquals("a1 = " + a1 + ", a2 = " + a2, expected,                     actual, 0.);             }         }     }      private void doTestCombineDimensionMismatch(final boolean inPlace, final boolean mixed) {         final RealVector v1 = create(new double[10]);         final RealVector v2;         if (mixed) {             v2 = createAlien(new double[15]);         } else {             v2 = create(new double[15]);         }         if (inPlace) {             v1.combineToSelf(1.0, 1.0, v2);         } else {             v1.combine(1.0, 1.0, v2);         }     }      @Test     public void testCombineSameType() {         doTestCombine(false, false);     }      @Test     public void testCombineMixedTypes() {         doTestCombine(false, true);     }      @Test(expected = DimensionMismatchException.class)     public void testCombineDimensionMismatchSameType() {         doTestCombineDimensionMismatch(false, false);     }      @Test(expected = DimensionMismatchException.class)     public void testCombineDimensionMismatchMixedTypes() {         doTestCombineDimensionMismatch(false, true);     }      @Test     public void testCombineToSelfSameType() {         doTestCombine(true, false);     }      @Test     public void testCombineToSelfMixedTypes() {         doTestCombine(true, true);     }      @Test(expected = DimensionMismatchException.class)     public void testCombineToSelfDimensionMismatchSameType() {         doTestCombineDimensionMismatch(true, false);     }      @Test(expected = DimensionMismatchException.class)     public void testCombineToSelfDimensionMismatchMixedTypes() {         doTestCombineDimensionMismatch(true, true);     }      @Test     public void testCopy() {         final RealVector v = create(values);         final RealVector w = v.copy();         Assert.assertNotSame(v, w);         TestUtils.assertEquals("", values, w, 0d);     }      private void doTestDotProductRegularValues(final boolean mixed) {         final double x = getPreferredEntryValue();         final double[] data1 = {             x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x         };         final double[] data2 = {             5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d         };         double expected = 0d;         for (int i = 0; i < data1.length; i++){             expected += data1[i] * data2[i];         }         final RealVector v1 = create(data1);         final RealVector v2;         if (mixed) {             v2 = createAlien(data2);         } else {             v2 = create(data2);         }         final double actual = v1.dotProduct(v2);         Assert.assertEquals("", expected, actual, 0d);     }      private void doTestDotProductSpecialValues(final boolean mixed) {         for (int i = 0; i < values.length; i++) {             final double[] data1 = {                 values[i]             };             final RealVector v1 = create(data1);             for (int j = 0; j < values.length; j++) {                 final double[] data2 = {                     values[j]                 };                 final RealVector v2;                 if (mixed) {                     v2 = createAlien(data2);                 } else {                     v2 = create(data2);                 }                 final double expected = data1[0] * data2[0];                 final double actual = v1.dotProduct(v2);                 Assert.assertEquals(data1[0] + " * " + data2[0], expected,                     actual, 0d);             }         }     }      private void doTestDotProductDimensionMismatch(final boolean mixed) {         final double[] data1 = new double[10];         final double[] data2 = new double[data1.length + 1];         final RealVector v1 = create(data1);         final RealVector v2;         if (mixed) {             v2 = createAlien(data2);         } else {             v2 = create(data2);         }         v1.dotProduct(v2);     }      @Test     public void testDotProductSameType() {         doTestDotProductRegularValues(false);         doTestDotProductSpecialValues(false);     }      @Test(expected=DimensionMismatchException.class)     public void testDotProductDimensionMismatchSameType() {         doTestDotProductDimensionMismatch(false);     }      @Test     public void testDotProductMixedTypes() {         doTestDotProductRegularValues(true);         doTestDotProductSpecialValues(true);     }      @Test(expected=DimensionMismatchException.class)     public void testDotProductDimensionMismatchMixedTypes() {         doTestDotProductDimensionMismatch(true);     }      private void doTestCosine(final boolean mixed) {         final double x = getPreferredEntryValue();         final double[] data1 = {             x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x         };         final double[] data2 = {             5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d         };         double norm1 = 0d;         double norm2 = 0d;         double dotProduct = 0d;         for (int i = 0; i < data1.length; i++){             norm1 += data1[i] * data1[i];             norm2 += data2[i] * data2[i];             dotProduct += data1[i] * data2[i];         }         norm1 = FastMath.sqrt(norm1);         norm2 = FastMath.sqrt(norm2);         final double expected = dotProduct / (norm1 * norm2);         final RealVector v1 = create(data1);         final RealVector v2;         if (mixed) {             v2 = createAlien(data2);         } else {             v2 = create(data2);         }         final double actual = v1.cosine(v2);         Assert.assertEquals("", expected, actual, 0d);      }      @Test     public void testCosineSameType() {         doTestCosine(false);     }      @Test     public void testCosineMixedTypes() {         doTestCosine(true);     }      @Test(expected=MathArithmeticException.class)     public void testCosineLeftNullVector() {         final RealVector v = create(new double[] {0, 0, 0});         final RealVector w = create(new double[] {1, 0, 0});         v.cosine(w);     }      @Test(expected=MathArithmeticException.class)     public void testCosineRightNullVector() {         final RealVector v = create(new double[] {0, 0, 0});         final RealVector w = create(new double[] {1, 0, 0});         w.cosine(v);     }      @Test(expected=DimensionMismatchException.class)     public void testCosineDimensionMismatch() {         final RealVector v = create(new double[] {1, 2, 3});         final RealVector w = create(new double[] {1, 2, 3, 4});         v.cosine(w);     }      @Test     public void testEquals() {         final RealVector v = create(new double[] { 0, 1, 2 });          Assert.assertTrue(v.equals(v));         Assert.assertTrue(v.equals(v.copy()));         Assert.assertFalse(v.equals(null));         Assert.assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1)));         Assert.assertTrue(v.equals(v.getSubVector(0, v.getDimension())));     }      @Test     public void testSerial()  {         RealVector v = create(new double[] { 0, 1, 2 });         Assert.assertEquals(v,TestUtils.serializeAndRecover(v));     }      @Test     public void testMinMax() {         final RealVector v1 = create(new double[] {0, -6, 4, 12, 7});         Assert.assertEquals(1, v1.getMinIndex());         Assert.assertEquals(-6, v1.getMinValue(), 1.0e-12);         Assert.assertEquals(3, v1.getMaxIndex());         Assert.assertEquals(12, v1.getMaxValue(), 1.0e-12);         final RealVector v2 = create(new double[] {Double.NaN, 3, Double.NaN, -2});         Assert.assertEquals(3, v2.getMinIndex());         Assert.assertEquals(-2, v2.getMinValue(), 1.0e-12);         Assert.assertEquals(1, v2.getMaxIndex());         Assert.assertEquals(3, v2.getMaxValue(), 1.0e-12);         final RealVector v3 = create(new double[] {Double.NaN, Double.NaN});         Assert.assertEquals(-1, v3.getMinIndex());         Assert.assertTrue(Double.isNaN(v3.getMinValue()));         Assert.assertEquals(-1, v3.getMaxIndex());         Assert.assertTrue(Double.isNaN(v3.getMaxValue()));         final RealVector v4 = create(new double[0]);         Assert.assertEquals(-1, v4.getMinIndex());         Assert.assertTrue(Double.isNaN(v4.getMinValue()));         Assert.assertEquals(-1, v4.getMaxIndex());         Assert.assertTrue(Double.isNaN(v4.getMaxValue()));     }      /*      * TESTS OF THE VISITOR PATTERN      */      /** The whole vector is visited. */     @Test     public void testWalkInDefaultOrderPreservingVisitor1() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final RealVector v = create(data);         final RealVectorPreservingVisitor visitor;         visitor = new RealVectorPreservingVisitor() {              private int expectedIndex;              @Override             public void visit(final int actualIndex, final double actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);                 ++expectedIndex;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 expectedIndex = 0;             }              @Override             public double end() {                 return 0.0;             }         };         v.walkInDefaultOrder(visitor);     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInDefaultOrderPreservingVisitor2() {         final RealVector v = create(new double[5]);         final RealVectorPreservingVisitor visitor;         visitor = new RealVectorPreservingVisitor() {              @Override             public void visit(int index, double value) {                 // Do nothing             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public double end() {                 return 0.0;             }         };         try {             v.walkInDefaultOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInDefaultOrderPreservingVisitor3() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final int expectedStart = 2;         final int expectedEnd = 7;         final RealVector v = create(data);         final RealVectorPreservingVisitor visitor;         visitor = new RealVectorPreservingVisitor() {              private int expectedIndex;              @Override             public void visit(final int actualIndex, final double actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);                 ++expectedIndex;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 expectedIndex = expectedStart;             }              @Override             public double end() {                 return 0.0;             }         };         v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);     }      /** The whole vector is visited. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor1() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final RealVector v = create(data);         final RealVectorPreservingVisitor visitor;         visitor = new RealVectorPreservingVisitor() {             private final boolean[] visited = new boolean[data.length];              @Override             public void visit(final int actualIndex, final double actualValue) {                 visited[actualIndex] = true;                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 Arrays.fill(visited, false);             }              @Override             public double end() {                 for (int i = 0; i < data.length; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return 0.0;             }         };         v.walkInOptimizedOrder(visitor);     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor2() {         final RealVector v = create(new double[5]);         final RealVectorPreservingVisitor visitor;         visitor = new RealVectorPreservingVisitor() {              @Override             public void visit(int index, double value) {                 // Do nothing             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public double end() {                 return 0.0;             }         };         try {             v.walkInOptimizedOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor3() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final int expectedStart = 2;         final int expectedEnd = 7;         final RealVector v = create(data);         final RealVectorPreservingVisitor visitor;         visitor = new RealVectorPreservingVisitor() {             private final boolean[] visited = new boolean[data.length];              @Override             public void visit(final int actualIndex, final double actualValue) {                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);                 visited[actualIndex] = true;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 Arrays.fill(visited, true);             }              @Override             public double end() {                 for (int i = expectedStart; i <= expectedEnd; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return 0.0;             }         };         v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);     }      /** The whole vector is visited. */     @Test     public void testWalkInDefaultOrderChangingVisitor1() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final RealVector v = create(data);         final RealVectorChangingVisitor visitor;         visitor = new RealVectorChangingVisitor() {              private int expectedIndex;              @Override             public double visit(final int actualIndex, final double actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);                 ++expectedIndex;                 return actualIndex + actualValue;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 expectedIndex = 0;             }              @Override             public double end() {                 return 0.0;             }         };         v.walkInDefaultOrder(visitor);         for (int i = 0; i < data.length; i++) {             Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);         }     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInDefaultOrderChangingVisitor2() {         final RealVector v = create(new double[5]);         final RealVectorChangingVisitor visitor;         visitor = new RealVectorChangingVisitor() {              @Override             public double visit(int index, double value) {                 return 0.0;             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public double end() {                 return 0.0;             }         };         try {             v.walkInDefaultOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInDefaultOrderChangingVisitor3() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final int expectedStart = 2;         final int expectedEnd = 7;         final RealVector v = create(data);         final RealVectorChangingVisitor visitor;         visitor = new RealVectorChangingVisitor() {              private int expectedIndex;              @Override             public double visit(final int actualIndex, final double actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);                 ++expectedIndex;                 return actualIndex + actualValue;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 expectedIndex = expectedStart;             }              @Override             public double end() {                 return 0.0;             }         };         v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);         for (int i = expectedStart; i <= expectedEnd; i++) {             Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);         }     }      /** The whole vector is visited. */     @Test     public void testWalkInOptimizedOrderChangingVisitor1() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final RealVector v = create(data);         final RealVectorChangingVisitor visitor;         visitor = new RealVectorChangingVisitor() {             private final boolean[] visited = new boolean[data.length];              @Override             public double visit(final int actualIndex, final double actualValue) {                 visited[actualIndex] = true;                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);                 return actualIndex + actualValue;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 Arrays.fill(visited, false);             }              @Override             public double end() {                 for (int i = 0; i < data.length; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return 0.0;             }         };         v.walkInOptimizedOrder(visitor);         for (int i = 0; i < data.length; i++) {             Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);         }     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInOptimizedOrderChangingVisitor2() {         final RealVector v = create(new double[5]);         final RealVectorChangingVisitor visitor;         visitor = new RealVectorChangingVisitor() {              @Override             public double visit(int index, double value) {                 return 0.0;             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public double end() {                 return 0.0;             }         };         try {             v.walkInOptimizedOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInOptimizedOrderChangingVisitor3() {         final double[] data = new double[] {             0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d         };         final int expectedStart = 2;         final int expectedEnd = 7;         final RealVector v = create(data);         final RealVectorChangingVisitor visitor;         visitor = new RealVectorChangingVisitor() {             private final boolean[] visited = new boolean[data.length];              @Override             public double visit(final int actualIndex, final double actualValue) {                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue, 0d);                 visited[actualIndex] = true;                 return actualIndex + actualValue;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 Arrays.fill(visited, true);             }              @Override             public double end() {                 for (int i = expectedStart; i <= expectedEnd; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return 0.0;             }         };         v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);         for (int i = expectedStart; i <= expectedEnd; i++) {             Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);         }     }      /**      * Minimal implementation of the {@link RealVector} abstract class, for      * mixed types unit tests.      */     public static class RealVectorTestImpl extends RealVector         implements Serializable {          /** Serializable version identifier. */         private static final long serialVersionUID = 20120706L;          /** Entries of the vector. */         protected double data[];          public RealVectorTestImpl(double[] d) {             data = d.clone();         }          private UnsupportedOperationException unsupported() {             return new UnsupportedOperationException("Not supported, unneeded for test purposes");         }          @Override         public RealVector copy() {             return new RealVectorTestImpl(data);         }          @Override         public RealVector ebeMultiply(RealVector v) {             throw unsupported();         }          @Override         public RealVector ebeDivide(RealVector v) {             throw unsupported();         }          @Override         public double getEntry(int index) {             checkIndex(index);             return data[index];         }          @Override         public int getDimension() {             return data.length;         }          @Override         public RealVector append(RealVector v) {             throw unsupported();         }          @Override         public RealVector append(double d) {             throw unsupported();         }          @Override         public RealVector getSubVector(int index, int n) {             throw unsupported();         }          @Override         public void setEntry(int index, double value) {             checkIndex(index);             data[index] = value;         }          @Override         public void setSubVector(int index, RealVector v) {             throw unsupported();         }          @Override         public boolean isNaN() {             throw unsupported();         }          @Override         public boolean isInfinite() {             throw unsupported();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Random;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.rng.simple.RandomSource; import org.junit.Test; import org.junit.Assert;  public class SchurTransformerTest {      private double[][] testSquare5 = {             { 5, 4, 3, 2, 1 },             { 1, 4, 0, 3, 3 },             { 2, 0, 3, 0, 0 },             { 3, 2, 1, 2, 5 },             { 4, 2, 1, 4, 1 }     };      private double[][] testSquare3 = {             {  2, -1, 1 },             { -1,  2, 1 },             {  1, -1, 2 }     };      // from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html     private double[][] testRandom = {             {  0.680, -0.3300, -0.2700, -0.717, -0.687,  0.0259 },             { -0.211,  0.5360,  0.0268,  0.214, -0.198,  0.6780 },             {  0.566, -0.4440,  0.9040, -0.967, -0.740,  0.2250 },             {  0.597,  0.1080,  0.8320, -0.514, -0.782, -0.4080 },             {  0.823, -0.0452,  0.2710, -0.726,  0.998,  0.2750 },             { -0.605,  0.2580,  0.4350,  0.608, -0.563,  0.0486 }     };      @Test     public void testNonSquare() {         try {             new SchurTransformer(MatrixUtils.createRealMatrix(new double[3][2]));             Assert.fail("an exception should have been thrown");         } catch (NonSquareMatrixException ime) {             // expected behavior         }     }      @Test     public void testAEqualPTPt() {         checkAEqualPTPt(MatrixUtils.createRealMatrix(testSquare5));         checkAEqualPTPt(MatrixUtils.createRealMatrix(testSquare3));         checkAEqualPTPt(MatrixUtils.createRealMatrix(testRandom));    }      @Test     public void testPOrthogonal() {         checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getP());         checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getP());         checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getP());     }      @Test     public void testPTOrthogonal() {         checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getPT());         checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getPT());         checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getPT());     }      @Test     public void testSchurForm() {         checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());         checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());         checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getT());     }      @Test     public void testRandomData() {         for (int run = 0; run < 100; run++) {             Random r = new Random(System.currentTimeMillis());              // matrix size             int size = r.nextInt(20) + 4;              double[][] data = new double[size][size];             for (int i = 0; i < size; i++) {                 for (int j = 0; j < size; j++) {                     data[i][j] = r.nextInt(100);                 }             }              RealMatrix m = MatrixUtils.createRealMatrix(data);             RealMatrix s = checkAEqualPTPt(m);             checkSchurForm(s);         }     }      @Test     public void testRandomDataNormalDistribution() {         for (int run = 0; run < 100; run++) {             Random r = new Random(System.currentTimeMillis());             ContinuousDistribution.Sampler dist                 = new NormalDistribution(0.0, r.nextDouble() * 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                                     64925784252L));              // matrix size             int size = r.nextInt(20) + 4;              double[][] data = new double[size][size];             for (int i = 0; i < size; i++) {                 for (int j = 0; j < size; j++) {                     data[i][j] = dist.sample();                 }             }              RealMatrix m = MatrixUtils.createRealMatrix(data);             RealMatrix s = checkAEqualPTPt(m);             checkSchurForm(s);         }     }      @Test     public void testMath848() {         double[][] data = {                 { 0.1849449280, -0.0646971046,  0.0774755812, -0.0969651755, -0.0692648806,  0.3282344352, -0.0177423074,  0.2063136340},                 {-0.0742700134, -0.0289063030, -0.0017269460, -0.0375550146, -0.0487737922, -0.2616837868, -0.0821201295, -0.2530000167},                 { 0.2549910127,  0.0995733692, -0.0009718388,  0.0149282808,  0.1791878897, -0.0823182816,  0.0582629256,  0.3219545182},                 {-0.0694747557, -0.1880649148, -0.2740630911,  0.0720096468, -0.1800836914, -0.3518996425,  0.2486747833,  0.6257938167},                 { 0.0536360918, -0.1339297778,  0.2241579764, -0.0195327484, -0.0054103808,  0.0347564518,  0.5120802482, -0.0329902864},                 {-0.5933332356, -0.2488721082,  0.2357173629,  0.0177285473,  0.0856630593, -0.3567126300, -0.1600668126, -0.1010899621},                 {-0.0514349819, -0.0854319435,  0.1125050061,  0.0063453560, -0.2250000688, -0.2209343090,  0.1964623477, -0.1512329924},                 { 0.0197395947, -0.1997170581, -0.1425959019, -0.2749477910, -0.0969467073,  0.0603688520, -0.2826905192,  0.1794315473}};         RealMatrix m = MatrixUtils.createRealMatrix(data);         RealMatrix s = checkAEqualPTPt(m);         checkSchurForm(s);     }      ///////////////////////////////////////////////////////////////////////////     // Test helpers     ///////////////////////////////////////////////////////////////////////////      private RealMatrix checkAEqualPTPt(RealMatrix matrix) {         SchurTransformer transformer = new SchurTransformer(matrix);         RealMatrix p  = transformer.getP();         RealMatrix t  = transformer.getT();         RealMatrix pT = transformer.getPT();          RealMatrix result = p.multiply(t).multiply(pT);          double norm = result.subtract(matrix).getNorm();         Assert.assertEquals(0, norm, 1.0e-9);          return t;     }      private void checkOrthogonal(RealMatrix m) {         RealMatrix mTm = m.transpose().multiply(m);         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());         Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);     }      private void checkSchurForm(final RealMatrix m) {         final int rows = m.getRowDimension();         final int cols = m.getColumnDimension();         for (int i = 0; i < rows; ++i) {             for (int j = 0; j < cols; ++j) {                 if (i > j + 1) {                     Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                 }             }         }     }      @SuppressWarnings("unused")     private void checkMatricesValues(double[][] matrix, double[][] pRef, double[][] hRef) {          SchurTransformer transformer =             new SchurTransformer(MatrixUtils.createRealMatrix(matrix));          // check values against known references         RealMatrix p = transformer.getP();         Assert.assertEquals(0, p.subtract(MatrixUtils.createRealMatrix(pRef)).getNorm(), 1.0e-14);          RealMatrix t = transformer.getT();         Assert.assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(hRef)).getNorm(), 1.0e-14);          // check the same cached instance is returned the second time         Assert.assertTrue(p == transformer.getP());         Assert.assertTrue(t == transformer.getT());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  public class SingularValueSolverTest {      private double[][] testSquare = {             { 24.0 / 25.0, 43.0 / 25.0 },             { 57.0 / 25.0, 24.0 / 25.0 }     };     private double[][] bigSingular = {         { 1.0, 2.0,   3.0,    4.0 },         { 2.0, 5.0,   3.0,    4.0 },         { 7.0, 3.0, 256.0, 1930.0 },         { 3.0, 7.0,   6.0,    8.0 }     }; // 4th row = 1st + 2nd      private static final double normTolerance = 10e-14;      /** test solve dimension errors */     @Test     public void testSolveDimensionErrors() {         DecompositionSolver solver =             new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }     }      /** test least square solve */     @Test     public void testLeastSquareSolve() {         RealMatrix m =             MatrixUtils.createRealMatrix(new double[][] {                                    { 1.0, 0.0 },                                    { 0.0, 0.0 }                                });         DecompositionSolver solver = new SingularValueDecomposition(m).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {             { 11, 12 }, { 21, 22 }         });         RealMatrix xMatrix = solver.solve(b);         Assert.assertEquals(11, xMatrix.getEntry(0, 0), 1.0e-15);         Assert.assertEquals(12, xMatrix.getEntry(0, 1), 1.0e-15);         Assert.assertEquals(0, xMatrix.getEntry(1, 0), 1.0e-15);         Assert.assertEquals(0, xMatrix.getEntry(1, 1), 1.0e-15);         RealVector xColVec = solver.solve(b.getColumnVector(0));         Assert.assertEquals(11, xColVec.getEntry(0), 1.0e-15);         Assert.assertEquals(0, xColVec.getEntry(1), 1.0e-15);         RealVector xColOtherVec = solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));         Assert.assertEquals(11, xColOtherVec.getEntry(0), 1.0e-15);         Assert.assertEquals(0, xColOtherVec.getEntry(1), 1.0e-15);     }      /** test solve */     @Test     public void testSolve() {         DecompositionSolver solver =             new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                 { 1, 2, 3 }, { 0, -5, 1 }         });         RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                 { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },                 { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }         });          // using RealMatrix         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);          // using ArrayRealVector         for (int i = 0; i < b.getColumnDimension(); ++i) {             Assert.assertEquals(0,                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                          1.0e-13);         }          // using RealVector with an alternate implementation         for (int i = 0; i < b.getColumnDimension(); ++i) {             ArrayRealVectorTest.RealVectorTestImpl v =                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));             Assert.assertEquals(0,                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                          1.0e-13);         }      }      /** test condition number */     @Test     public void testConditionNumber() {         SingularValueDecomposition svd =             new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));         // replace 1.0e-15 with 1.5e-15         Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);     }      @Test     public void testMath320B() {         RealMatrix rm = new Array2DRowRealMatrix(new double[][] {             { 1.0, 2.0 }, { 1.0, 2.0 }         });         SingularValueDecomposition svd =             new SingularValueDecomposition(rm);         RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());         Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);     }      @Test     public void testSingular() {       SingularValueDecomposition svd =           new SingularValueDecomposition(MatrixUtils.createRealMatrix(bigSingular));       RealMatrix pseudoInverse = svd.getSolver().getInverse();       RealMatrix expected = new Array2DRowRealMatrix(new double[][] {           {-0.0355022687,0.0512742236,-0.0001045523,0.0157719549},           {-0.3214992438,0.3162419255,0.0000348508,-0.0052573183},           {0.5437098346,-0.4107754586,-0.0008256918,0.132934376},           {-0.0714905202,0.053808742,0.0006279816,-0.0176817782}       });       Assert.assertEquals(0, expected.subtract(pseudoInverse).getNorm(), 1.0e-9);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert;  public class LUDecompositionTest {     private double[][] testData = {             { 1.0, 2.0, 3.0},             { 2.0, 5.0, 3.0},             { 1.0, 0.0, 8.0}     };     private double[][] testDataMinus = {             { -1.0, -2.0, -3.0},             { -2.0, -5.0, -3.0},             { -1.0,  0.0, -8.0}     };     private double[][] luData = {             { 2.0, 3.0, 3.0 },             { 0.0, 5.0, 7.0 },             { 6.0, 9.0, 8.0 }     };      // singular matrices     private double[][] singular = {             { 2.0, 3.0 },             { 2.0, 3.0 }     };     private double[][] bigSingular = {             { 1.0, 2.0,   3.0,    4.0 },             { 2.0, 5.0,   3.0,    4.0 },             { 7.0, 3.0, 256.0, 1930.0 },             { 3.0, 7.0,   6.0,    8.0 }     }; // 4th row = 1st + 2nd      private static final double entryTolerance = 10e-16;      private static final double normTolerance = 10e-14;      /** test dimensions */     @Test     public void testDimensions() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         LUDecomposition LU = new LUDecomposition(matrix);         Assert.assertEquals(testData.length, LU.getL().getRowDimension());         Assert.assertEquals(testData.length, LU.getL().getColumnDimension());         Assert.assertEquals(testData.length, LU.getU().getRowDimension());         Assert.assertEquals(testData.length, LU.getU().getColumnDimension());         Assert.assertEquals(testData.length, LU.getP().getRowDimension());         Assert.assertEquals(testData.length, LU.getP().getColumnDimension());      }      /** test non-square matrix */     @Test     public void testNonSquare() {         try {             new LUDecomposition(MatrixUtils.createRealMatrix(new double[3][2]));             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ime) {             // expected behavior         }     }      /** test PA = LU */     @Test     public void testPAEqualLU() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         LUDecomposition lu = new LUDecomposition(matrix);         RealMatrix l = lu.getL();         RealMatrix u = lu.getU();         RealMatrix p = lu.getP();         double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();         Assert.assertEquals(0, norm, normTolerance);          matrix = MatrixUtils.createRealMatrix(testDataMinus);         lu = new LUDecomposition(matrix);         l = lu.getL();         u = lu.getU();         p = lu.getP();         norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();         Assert.assertEquals(0, norm, normTolerance);          matrix = MatrixUtils.createRealIdentityMatrix(17);         lu = new LUDecomposition(matrix);         l = lu.getL();         u = lu.getU();         p = lu.getP();         norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();         Assert.assertEquals(0, norm, normTolerance);          matrix = MatrixUtils.createRealMatrix(singular);         lu = new LUDecomposition(matrix);         Assert.assertFalse(lu.getSolver().isNonSingular());         Assert.assertNull(lu.getL());         Assert.assertNull(lu.getU());         Assert.assertNull(lu.getP());          matrix = MatrixUtils.createRealMatrix(bigSingular);         lu = new LUDecomposition(matrix);         Assert.assertFalse(lu.getSolver().isNonSingular());         Assert.assertNull(lu.getL());         Assert.assertNull(lu.getU());         Assert.assertNull(lu.getP());      }      /** test that L is lower triangular with unit diagonal */     @Test     public void testLLowerTriangular() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         RealMatrix l = new LUDecomposition(matrix).getL();         for (int i = 0; i < l.getRowDimension(); i++) {             Assert.assertEquals(l.getEntry(i, i), 1, entryTolerance);             for (int j = i + 1; j < l.getColumnDimension(); j++) {                 Assert.assertEquals(l.getEntry(i, j), 0, entryTolerance);             }         }     }      /** test that U is upper triangular */     @Test     public void testUUpperTriangular() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         RealMatrix u = new LUDecomposition(matrix).getU();         for (int i = 0; i < u.getRowDimension(); i++) {             for (int j = 0; j < i; j++) {                 Assert.assertEquals(u.getEntry(i, j), 0, entryTolerance);             }         }     }      /** test that P is a permutation matrix */     @Test     public void testPPermutation() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         RealMatrix p   = new LUDecomposition(matrix).getP();          RealMatrix ppT = p.multiply(p.transpose());         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());         Assert.assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);          for (int i = 0; i < p.getRowDimension(); i++) {             int zeroCount  = 0;             int oneCount   = 0;             int otherCount = 0;             for (int j = 0; j < p.getColumnDimension(); j++) {                 final double e = p.getEntry(i, j);                 if (e == 0) {                     ++zeroCount;                 } else if (e == 1) {                     ++oneCount;                 } else {                     ++otherCount;                 }             }             Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);             Assert.assertEquals(1, oneCount);             Assert.assertEquals(0, otherCount);         }          for (int j = 0; j < p.getColumnDimension(); j++) {             int zeroCount  = 0;             int oneCount   = 0;             int otherCount = 0;             for (int i = 0; i < p.getRowDimension(); i++) {                 final double e = p.getEntry(i, j);                 if (e == 0) {                     ++zeroCount;                 } else if (e == 1) {                     ++oneCount;                 } else {                     ++otherCount;                 }             }             Assert.assertEquals(p.getRowDimension() - 1, zeroCount);             Assert.assertEquals(1, oneCount);             Assert.assertEquals(0, otherCount);         }      }      /** test singular */     @Test     public void testSingular() {         LUDecomposition lu =             new LUDecomposition(MatrixUtils.createRealMatrix(testData));         Assert.assertTrue(lu.getSolver().isNonSingular());         lu = new LUDecomposition(MatrixUtils.createRealMatrix(singular));         Assert.assertFalse(lu.getSolver().isNonSingular());         lu = new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular));         Assert.assertFalse(lu.getSolver().isNonSingular());     }      /** test matrices values */     @Test     public void testMatricesValues1() {        LUDecomposition lu =             new LUDecomposition(MatrixUtils.createRealMatrix(testData));         RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                 { 1.0, 0.0, 0.0 },                 { 0.5, 1.0, 0.0 },                 { 0.5, 0.2, 1.0 }         });         RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                 { 2.0,  5.0, 3.0 },                 { 0.0, -2.5, 6.5 },                 { 0.0,  0.0, 0.2 }         });         RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                 { 0.0, 1.0, 0.0 },                 { 0.0, 0.0, 1.0 },                 { 1.0, 0.0, 0.0 }         });         int[] pivotRef = { 1, 2, 0 };          // check values against known references         RealMatrix l = lu.getL();         Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);         RealMatrix u = lu.getU();         Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);         RealMatrix p = lu.getP();         Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);         int[] pivot = lu.getPivot();         for (int i = 0; i < pivotRef.length; ++i) {             Assert.assertEquals(pivotRef[i], pivot[i]);         }          // check the same cached instance is returned the second time         Assert.assertTrue(l == lu.getL());         Assert.assertTrue(u == lu.getU());         Assert.assertTrue(p == lu.getP());      }      /** test matrices values */     @Test     public void testMatricesValues2() {        LUDecomposition lu =             new LUDecomposition(MatrixUtils.createRealMatrix(luData));         RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                 {    1.0,    0.0, 0.0 },                 {    0.0,    1.0, 0.0 },                 { 1.0 / 3.0, 0.0, 1.0 }         });         RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                 { 6.0, 9.0,    8.0    },                 { 0.0, 5.0,    7.0    },                 { 0.0, 0.0, 1.0 / 3.0 }         });         RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                 { 0.0, 0.0, 1.0 },                 { 0.0, 1.0, 0.0 },                 { 1.0, 0.0, 0.0 }         });         int[] pivotRef = { 2, 1, 0 };          // check values against known references         RealMatrix l = lu.getL();         Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);         RealMatrix u = lu.getU();         Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);         RealMatrix p = lu.getP();         Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);         int[] pivot = lu.getPivot();         for (int i = 0; i < pivotRef.length; ++i) {             Assert.assertEquals(pivotRef[i], pivot[i]);         }          // check the same cached instance is returned the second time         Assert.assertTrue(l == lu.getL());         Assert.assertTrue(u == lu.getU());         Assert.assertTrue(p == lu.getP());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;   public class CholeskySolverTest {      private double[][] testData = new double[][] {             {  1,  2,   4,   7,  11 },             {  2, 13,  23,  38,  58 },             {  4, 23,  77, 122, 182 },             {  7, 38, 122, 294, 430 },             { 11, 58, 182, 430, 855 }     };      /** test solve dimension errors */     @Test     public void testSolveDimensionErrors() {         DecompositionSolver solver =             new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }     }      /** test solve */     @Test     public void testSolve() {         DecompositionSolver solver =             new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                 {   78,  -13,    1 },                 {  414,  -62,   -1 },                 { 1312, -202,  -37 },                 { 2989, -542,  145 },                 { 5510, -1465, 201 }         });         RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                 { 1,  0,  1 },                 { 0,  1,  1 },                 { 2,  1, -4 },                 { 2,  2,  2 },                 { 5, -3,  0 }         });          // using RealMatrix         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);          // using ArrayRealVector         for (int i = 0; i < b.getColumnDimension(); ++i) {             Assert.assertEquals(0,                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                          1.0e-13);         }          // using RealVector with an alternate implementation         for (int i = 0; i < b.getColumnDimension(); ++i) {             ArrayRealVectorTest.RealVectorTestImpl v =                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));             Assert.assertEquals(0,                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                          1.0e-13);         }      }      /** test determinant */     @Test     public void testDeterminant() {         Assert.assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);     }      private double getDeterminant(RealMatrix m) {         return new CholeskyDecomposition(m).getDeterminant();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.junit.Assert; import org.junit.Test;  public final class OpenMapRealMatrixTest {      @Test(expected=NumberIsTooLargeException.class)     public void testMath679() {         new OpenMapRealMatrix(3, Integer.MAX_VALUE);     }      @Test     public void testMath870() {         // Caveat: This implementation assumes that, for any {@code x},         // the equality {@code x * 0d == 0d} holds. But it is is not true for         // {@code NaN}. Moreover, zero entries will lose their sign.         // Some operations (that involve {@code NaN} and/or infinities) may         // thus give incorrect results.         OpenMapRealMatrix a = new OpenMapRealMatrix(3, 3);         OpenMapRealMatrix x = new OpenMapRealMatrix(3, 1);         x.setEntry(0, 0, Double.NaN);         x.setEntry(2, 0, Double.NEGATIVE_INFINITY);         OpenMapRealMatrix b = a.multiply(x);         for (int i = 0; i < b.getRowDimension(); ++i) {             for (int j = 0; j < b.getColumnDimension(); ++j) {                 // NaNs and infinities have disappeared, this is a limitation of our implementation                 Assert.assertEquals(0.0, b.getEntry(i, j), 1.0e-20);             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Random;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.numbers.core.Precision; import org.junit.Test; import org.junit.Assert;  public class EigenSolverTest {      private double[][] bigSingular = {         { 1.0, 2.0,   3.0,    4.0 },         { 2.0, 5.0,   3.0,    4.0 },         { 7.0, 3.0, 256.0, 1930.0 },         { 3.0, 7.0,   6.0,    8.0 }     }; // 4th row = 1st + 2nd      /** test non invertible matrix */     @Test     public void testNonInvertible() {         Random r = new Random(9994100315209l);         RealMatrix m =             EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });         DecompositionSolver es = new EigenDecomposition(m).getSolver();         Assert.assertFalse(es.isNonSingular());         try {             es.getInverse();             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException ime) {             // expected behavior         }     }      /** test invertible matrix */     @Test     public void testInvertible() {         Random r = new Random(9994100315209l);         RealMatrix m =             EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });         DecompositionSolver es = new EigenDecomposition(m).getSolver();         Assert.assertTrue(es.isNonSingular());         RealMatrix inverse = es.getInverse();         RealMatrix error =             m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));         Assert.assertEquals(0, error.getNorm(), 4.0e-15);     }      /**      * Verifies operation on very small values.      * Matrix with eigenvalues {8e-100, -1e-100, -1e-100}      */     @Test     public void testInvertibleTinyValues() {         final double tiny = 1e-100;         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {                 {3,  2,  4},                 {2,  0,  2},                 {4,  2,  3}         });         m = m.scalarMultiply(tiny);          final EigenDecomposition ed = new EigenDecomposition(m);         RealMatrix inv = ed.getSolver().getInverse();          final RealMatrix id = m.multiply(inv);         for (int i = 0; i < m.getRowDimension(); i++) {             for (int j = 0; j < m.getColumnDimension(); j++) {                 if (i == j) {                     Assert.assertTrue(Precision.equals(1, id.getEntry(i, j), 1e-15));                 } else {                     Assert.assertTrue(Precision.equals(0, id.getEntry(i, j), 1e-15));                 }             }         }     }      @Test(expected=SingularMatrixException.class)     public void testNonInvertibleMath1045() {         EigenDecomposition eigen =             new EigenDecomposition(MatrixUtils.createRealMatrix(bigSingular));         eigen.getSolver().getInverse();     }      @Test(expected=SingularMatrixException.class)     public void testZeroMatrix() {         EigenDecomposition eigen =             new EigenDecomposition(MatrixUtils.createRealMatrix(new double[][] {{0}}));         eigen.getSolver().getInverse();     }      @Test     public void testIsNonSingularTinyOutOfOrderEigenvalue() {         final EigenDecomposition eigen             = new EigenDecomposition(MatrixUtils.createRealMatrix(new double[][] {                         { 1e-13, 0 },                         { 1,     1 },                     }));         Assert.assertFalse("Singular matrix not detected",                            eigen.getSolver().isNonSingular());     }      /** test solve dimension errors */     @Test     public void testSolveDimensionErrors() {         final double[] refValues = new double[] {             2.003, 2.002, 2.001, 1.001, 1.000, 0.001         };         final RealMatrix matrix = EigenDecompositionTest.createTestMatrix(new Random(35992629946426l), refValues);          DecompositionSolver es = new EigenDecomposition(matrix).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);         try {             es.solve(b);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             es.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }     }      /** test solve */     @Test     public void testSolve() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {                 { 91,  5, 29, 32, 40, 14 },                 {  5, 34, -1,  0,  2, -1 },                 { 29, -1, 12,  9, 21,  8 },                 { 32,  0,  9, 14,  9,  0 },                 { 40,  2, 21,  9, 51, 19 },                 { 14, -1,  8,  0, 19, 14 }         });         DecompositionSolver es = new EigenDecomposition(m).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                 { 1561, 269, 188 },                 {   69, -21,  70 },                 {  739, 108,  63 },                 {  324,  86,  59 },                 { 1624, 194, 107 },                 {  796,  69,  36 }         });         RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                 { 1,   2, 1 },                 { 2,  -1, 2 },                 { 4,   2, 3 },                 { 8,  -1, 0 },                 { 16,  2, 0 },                 { 32, -1, 0 }         });          // using RealMatrix         RealMatrix solution=es.solve(b);         Assert.assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);          // using RealVector         for (int i = 0; i < b.getColumnDimension(); ++i) {             Assert.assertEquals(0,                          es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                          2.0e-11);         }          // using RealVector with an alternate implementation         for (int i = 0; i < b.getColumnDimension(); ++i) {             ArrayRealVectorTest.RealVectorTestImpl v =                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));             Assert.assertEquals(0,                          es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                          2.0e-11);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.text.NumberFormat; import java.text.ParsePosition; import java.util.Locale;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.exception.MathParseException;  public abstract class RealVectorFormatAbstractTest {      RealVectorFormat realVectorFormat = null;     RealVectorFormat realVectorFormatSquare = null;      protected abstract Locale getLocale();      protected abstract char getDecimalCharacter();      public RealVectorFormatAbstractTest() {         realVectorFormat = RealVectorFormat.getInstance(getLocale());         final NumberFormat nf = NumberFormat.getInstance(getLocale());         nf.setMaximumFractionDigits(2);         realVectorFormatSquare = new RealVectorFormat("[", "]", " : ", nf);     }      @Test     public void testSimpleNoDecimals() {         ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});         String expected = "{1; 1; 1}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testSimpleWithDecimals() {         ArrayRealVector c = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});         String expected =             "{1"    + getDecimalCharacter() +             "23; 1" + getDecimalCharacter() +             "43; 1" + getDecimalCharacter() +             "63}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testSimpleWithDecimalsTrunc() {         ArrayRealVector c = new ArrayRealVector(new double[] {1.232323232323, 1.43434343434343, 1.633333333333});         String expected =             "{1"    + getDecimalCharacter() +             "2323232323; 1" + getDecimalCharacter() +             "4343434343; 1" + getDecimalCharacter() +             "6333333333}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeX() {         ArrayRealVector c = new ArrayRealVector(new double[] {-1.232323232323, 1.43, 1.63});         String expected =             "{-1"    + getDecimalCharacter() +             "2323232323; 1" + getDecimalCharacter() +             "43; 1" + getDecimalCharacter() +             "63}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeY() {         ArrayRealVector c = new ArrayRealVector(new double[] {1.23, -1.434343434343, 1.63});         String expected =             "{1"    + getDecimalCharacter() +             "23; -1" + getDecimalCharacter() +             "4343434343; 1" + getDecimalCharacter() +             "63}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeZ() {         ArrayRealVector c = new ArrayRealVector(new double[] {1.23, 1.43, -1.633333333333});         String expected =             "{1"    + getDecimalCharacter() +             "23; 1" + getDecimalCharacter() +             "43; -1" + getDecimalCharacter() +             "6333333333}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testNonDefaultSetting() {         ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});         String expected = "[1 : 1 : 1]";         String actual = realVectorFormatSquare.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testDefaultFormatRealVectorImpl() {         Locale defaultLocal = Locale.getDefault();         Locale.setDefault(getLocale());          ArrayRealVector c = new ArrayRealVector(new double[] {232.22222222222, -342.3333333333, 432.44444444444});         String expected =             "{232"    + getDecimalCharacter() +             "2222222222; -342" + getDecimalCharacter() +             "3333333333; 432" + getDecimalCharacter() +             "4444444444}";         String actual = (new RealVectorFormat()).format(c);         Assert.assertEquals(expected, actual);          Locale.setDefault(defaultLocal);     }      @Test     public void testNan() {         ArrayRealVector c = new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN});         String expected = "{(NaN); (NaN); (NaN)}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testPositiveInfinity() {         ArrayRealVector c = new ArrayRealVector(new double[] {                 Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY         });         String expected = "{(Infinity); (Infinity); (Infinity)}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void tesNegativeInfinity() {         ArrayRealVector c = new ArrayRealVector(new double[] {                 Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY         });         String expected = "{(-Infinity); (-Infinity); (-Infinity)}";         String actual = realVectorFormat.format(c);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseSimpleNoDecimals() {         String source = "{1; 1; 1}";         ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseIgnoredWhitespace() {         ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});         ParsePosition pos1 = new ParsePosition(0);         String source1 = "{1;1;1}";         Assert.assertEquals(expected, realVectorFormat.parse(source1, pos1));         Assert.assertEquals(source1.length(), pos1.getIndex());         ParsePosition pos2 = new ParsePosition(0);         String source2 = " { 1 ; 1 ; 1 } ";         Assert.assertEquals(expected, realVectorFormat.parse(source2, pos2));         Assert.assertEquals(source2.length() - 1, pos2.getIndex());     }      @Test     public void testParseSimpleWithDecimals() {         String source =             "{1" + getDecimalCharacter() +             "23; 1" + getDecimalCharacter() +             "43; 1" + getDecimalCharacter() +             "63}";         ArrayRealVector expected = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseSimpleWithDecimalsTrunc() {         String source =             "{1" + getDecimalCharacter() +             "2323; 1" + getDecimalCharacter() +             "4343; 1" + getDecimalCharacter() +             "6333}";         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeX() {         String source =             "{-1" + getDecimalCharacter() +             "2323; 1" + getDecimalCharacter() +             "4343; 1" + getDecimalCharacter() +             "6333}";         ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeY() {         String source =             "{1" + getDecimalCharacter() +             "2323; -1" + getDecimalCharacter() +             "4343; 1" + getDecimalCharacter() +             "6333}";         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeZ() {         String source =             "{1" + getDecimalCharacter() +             "2323; 1" + getDecimalCharacter() +             "4343; -1" + getDecimalCharacter() +             "6333}";         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeAll() {         String source =             "{-1" + getDecimalCharacter() +             "2323; -1" + getDecimalCharacter() +             "4343; -1" + getDecimalCharacter() +             "6333}";         ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, -1.4343, -1.6333});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseZeroX() {         String source =             "{0" + getDecimalCharacter() +             "0; -1" + getDecimalCharacter() +             "4343; 1" + getDecimalCharacter() +             "6333}";         ArrayRealVector expected = new ArrayRealVector(new double[] {0.0, -1.4343, 1.6333});         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNonDefaultSetting() {         String source =             "[1" + getDecimalCharacter() +             "2323 : 1" + getDecimalCharacter() +             "4343 : 1" + getDecimalCharacter() +             "6333]";         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});         ArrayRealVector actual = realVectorFormatSquare.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNan() {         String source = "{(NaN); (NaN); (NaN)}";         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);     }      @Test     public void testParsePositiveInfinity() {         String source = "{(Infinity); (Infinity); (Infinity)}";         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(new ArrayRealVector(new double[] {                 Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY         }), actual);     }      @Test     public void testParseNegativeInfinity() {         String source = "{(-Infinity); (-Infinity); (-Infinity)}";         ArrayRealVector actual = realVectorFormat.parse(source);         Assert.assertEquals(new ArrayRealVector(new double[] {                 Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY         }), actual);     }      @Test     public void testParseNoComponents() {         try {             realVectorFormat.parse("{ }");             Assert.fail("Expecting MathParseException");         } catch (MathParseException pe) {             // expected behavior         }     }      @Test     public void testParseManyComponents() {         ArrayRealVector parsed = realVectorFormat.parse("{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}");         Assert.assertEquals(24, parsed.getDimension());     }      @Test     public void testConstructorSingleFormat() {         NumberFormat nf = NumberFormat.getInstance();         RealVectorFormat cf = new RealVectorFormat(nf);         Assert.assertNotNull(cf);         Assert.assertEquals(nf, cf.getFormat());     }      @Test     public void testForgottenPrefix() {         ParsePosition pos = new ParsePosition(0);         final String source = "1; 1; 1}";         Assert.assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));         Assert.assertEquals(0, pos.getErrorIndex());     }      @Test     public void testForgottenSeparator() {         ParsePosition pos = new ParsePosition(0);         final String source = "{1; 1 1}";         Assert.assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));         Assert.assertEquals(6, pos.getErrorIndex());     }      @Test     public void testForgottenSuffix() {         ParsePosition pos = new ParsePosition(0);         final String source = "{1; 1; 1 ";         Assert.assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));         Assert.assertEquals(8, pos.getErrorIndex());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link ArrayRealVector} class.  *  */ public class ArrayRealVectorTest extends RealVectorAbstractTest {       @Override     public RealVector create(final double[] data) {         return new ArrayRealVector(data, true);     }      @Test     public void testConstructors() {         final double[] vec1 = {1d, 2d, 3d};         final double[] vec3 = {7d, 8d, 9d};         final double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};         final Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};          ArrayRealVector v0 = new ArrayRealVector();         Assert.assertEquals("testData len", 0, v0.getDimension());          ArrayRealVector v1 = new ArrayRealVector(7);         Assert.assertEquals("testData len", 7, v1.getDimension());         Assert.assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6), 0);          ArrayRealVector v2 = new ArrayRealVector(5, 1.23);         Assert.assertEquals("testData len", 5, v2.getDimension());         Assert.assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4), 0);          ArrayRealVector v3 = new ArrayRealVector(vec1);         Assert.assertEquals("testData len", 3, v3.getDimension());         Assert.assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1), 0);          ArrayRealVector v3_bis = new ArrayRealVector(vec1, true);         Assert.assertEquals("testData len", 3, v3_bis.getDimension());         Assert.assertEquals("testData is 2.0 ", 2.0, v3_bis.getEntry(1), 0);         Assert.assertNotSame(v3_bis.getDataRef(), vec1);         Assert.assertNotSame(v3_bis.toArray(), vec1);          ArrayRealVector v3_ter = new ArrayRealVector(vec1, false);         Assert.assertEquals("testData len", 3, v3_ter.getDimension());         Assert.assertEquals("testData is 2.0 ", 2.0, v3_ter.getEntry(1), 0);         Assert.assertSame(v3_ter.getDataRef(), vec1);         Assert.assertNotSame(v3_ter.toArray(), vec1);          ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2);         Assert.assertEquals("testData len", 2, v4.getDimension());         Assert.assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0), 0);         try {             new ArrayRealVector(vec4, 8, 3);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }          RealVector v5_i = new ArrayRealVector(dvec1);         Assert.assertEquals("testData len", 9, v5_i.getDimension());         Assert.assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8), 0);          ArrayRealVector v5 = new ArrayRealVector(dvec1);         Assert.assertEquals("testData len", 9, v5.getDimension());         Assert.assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8), 0);          ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2);         Assert.assertEquals("testData len", 2, v6.getDimension());         Assert.assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0), 0);         try {             new ArrayRealVector(dvec1, 8, 3);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }          ArrayRealVector v7 = new ArrayRealVector(v1);         Assert.assertEquals("testData len", 7, v7.getDimension());         Assert.assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6), 0);          RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);          ArrayRealVector v7_2 = new ArrayRealVector(v7_i);         Assert.assertEquals("testData len", 3, v7_2.getDimension());         Assert.assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1), 0);          ArrayRealVector v8 = new ArrayRealVector(v1, true);         Assert.assertEquals("testData len", 7, v8.getDimension());         Assert.assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6), 0);         Assert.assertNotSame("testData not same object ", v1.getDataRef(), v8.getDataRef());          ArrayRealVector v8_2 = new ArrayRealVector(v1, false);         Assert.assertEquals("testData len", 7, v8_2.getDimension());         Assert.assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6), 0);         Assert.assertEquals("testData same object ", v1.getDataRef(), v8_2.getDataRef());          ArrayRealVector v9 = new ArrayRealVector(v1, v3);         Assert.assertEquals("testData len", 10, v9.getDimension());         Assert.assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7), 0);          ArrayRealVector v10 = new ArrayRealVector(v2, new RealVectorTestImpl(vec3));         Assert.assertEquals("testData len", 8, v10.getDimension());         Assert.assertEquals("testData is 1.23 ", 1.23, v10.getEntry(4), 0);         Assert.assertEquals("testData is 7.0 ", 7.0, v10.getEntry(5), 0);          ArrayRealVector v11 = new ArrayRealVector(new RealVectorTestImpl(vec3), v2);         Assert.assertEquals("testData len", 8, v11.getDimension());         Assert.assertEquals("testData is 9.0 ", 9.0, v11.getEntry(2), 0);         Assert.assertEquals("testData is 1.23 ", 1.23, v11.getEntry(3), 0);          ArrayRealVector v12 = new ArrayRealVector(v2, vec3);         Assert.assertEquals("testData len", 8, v12.getDimension());         Assert.assertEquals("testData is 1.23 ", 1.23, v12.getEntry(4), 0);         Assert.assertEquals("testData is 7.0 ", 7.0, v12.getEntry(5), 0);          ArrayRealVector v13 = new ArrayRealVector(vec3, v2);         Assert.assertEquals("testData len", 8, v13.getDimension());         Assert.assertEquals("testData is 9.0 ", 9.0, v13.getEntry(2), 0);         Assert.assertEquals("testData is 1.23 ", 1.23, v13.getEntry(3), 0);          ArrayRealVector v14 = new ArrayRealVector(vec3, vec4);         Assert.assertEquals("testData len", 12, v14.getDimension());         Assert.assertEquals("testData is 9.0 ", 9.0, v14.getEntry(2), 0);         Assert.assertEquals("testData is 1.0 ", 1.0, v14.getEntry(3), 0);      }      @Test     public void testGetDataRef() {         final double[] data = {1d, 2d, 3d, 4d};         final ArrayRealVector v = new ArrayRealVector(data);         v.getDataRef()[0] = 0d;         Assert.assertEquals("", 0d, v.getEntry(0), 0);     }      @Test     public void testPredicates() {          Assert.assertEquals(create(new double[] { Double.NaN, 1, 2 }).hashCode(),                      create(new double[] { 0, Double.NaN, 2 }).hashCode());          Assert.assertTrue(create(new double[] { Double.NaN, 1, 2 }).hashCode() !=                    create(new double[] { 0, 1, 2 }).hashCode());     }      @Test     public void testZeroVectors() {         Assert.assertEquals(0, new ArrayRealVector(new double[0]).getDimension());         Assert.assertEquals(0, new ArrayRealVector(new double[0], true).getDimension());         Assert.assertEquals(0, new ArrayRealVector(new double[0], false).getDimension());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Arrays; import java.util.Random;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.apache.commons.numbers.core.Precision; import org.apache.commons.rng.simple.RandomSource; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Ignore; import org.junit.Test;  public class EigenDecompositionTest {      private double[] refValues;     private RealMatrix matrix;      @Test     public void testDimension1() {         RealMatrix matrix =             MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);     }      @Test     public void testDimension2() {         RealMatrix matrix =             MatrixUtils.createRealMatrix(new double[][] {                     { 59.0, 12.0 },                     { 12.0, 66.0 }             });         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);         Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);     }      @Test     public void testDimension3() {         RealMatrix matrix =             MatrixUtils.createRealMatrix(new double[][] {                                    {  39632.0, -4824.0, -16560.0 },                                    {  -4824.0,  8693.0,   7920.0 },                                    { -16560.0,  7920.0,  17300.0 }                                });         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);         Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);         Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);     }      @Test     public void testDimension3MultipleRoot() {         RealMatrix matrix =             MatrixUtils.createRealMatrix(new double[][] {                     {  5,   10,   15 },                     { 10,   20,   30 },                     { 15,   30,   45 }             });         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);         Assert.assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);         Assert.assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);     }      @Test     public void testDimension4WithSplit() {         RealMatrix matrix =             MatrixUtils.createRealMatrix(new double[][] {                                    {  0.784, -0.288,  0.000,  0.000 },                                    { -0.288,  0.616,  0.000,  0.000 },                                    {  0.000,  0.000,  0.164, -0.048 },                                    {  0.000,  0.000, -0.048,  0.136 }                                });         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);         Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);         Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);         Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);     }      @Test     public void testDimension4WithoutSplit() {         RealMatrix matrix =             MatrixUtils.createRealMatrix(new double[][] {                                    {  0.5608, -0.2016,  0.1152, -0.2976 },                                    { -0.2016,  0.4432, -0.2304,  0.1152 },                                    {  0.1152, -0.2304,  0.3088, -0.1344 },                                    { -0.2976,  0.1152, -0.1344,  0.3872 }                                });         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);         Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);         Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);         Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);     }      // the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0     @Test     public void testMath308() {          double[] mainTridiagonal = {             22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437         };         double[] secondaryTridiagonal = {             13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225         };          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double[] refEigenValues = {             82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099         };         RealVector[] refEigenVectors = {             new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),             new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),             new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),             new ArrayRealVector(new double[] { -0.713933751051495,  0.190582113553930, -0.671410443368332,  0.056056055955050, -0.006541576993581 }),             new ArrayRealVector(new double[] { -0.584677060845929,  0.367177264979103,  0.721453187784497, -0.052971054621812,  0.005740715188257 })         };          EigenDecomposition decomposition;         decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);          double[] eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i) {             Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);             Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);         }      }      @Test     public void testMathpbx02() {          double[] mainTridiagonal = {               7484.860960227216, 18405.28129035345, 13855.225609560746,              10016.708722343366, 559.8117399576674, 6750.190788301587,                 71.21428769782159         };         double[] secondaryTridiagonal = {              -4175.088570476366,1975.7955858241994,5193.178422374075,               1995.286659169179,75.34535882933804,-234.0808002076056         };          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double[] refEigenValues = {                 20654.744890306974412,16828.208208485466457,                 6893.155912634994820,6757.083016675340332,                 5887.799885688558788,64.309089923240379,                 57.992628792736340         };         RealVector[] refEigenVectors = {                 new ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),                 new ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),                 new ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),                 new ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),                 new ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),                 new ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),                 new ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})         };          // the following line triggers the exception         EigenDecomposition decomposition;         decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);          double[] eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i) {             Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);             if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {                 Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);             } else {                 Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);             }         }      }      @Test     public void testMathpbx03() {          double[] mainTridiagonal = {             1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377,             806.0482458637571,2403.656427234185,28.48691431556015         };         double[] secondaryTridiagonal = {             -656.8932064545833,-469.30804108920734,-1021.7714889369421,             -1152.540497328983,-939.9765163817368,-12.885877015422391         };          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double[] refEigenValues = {             4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764,             1336.797819095331306,30.129865209677519,17.035352085224986         };          RealVector[] refEigenVectors = {             new ArrayRealVector(new double[] {-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}),             new ArrayRealVector(new double[] {-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}),             new ArrayRealVector(new double[] {-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}),             new ArrayRealVector(new double[] {0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}),             new ArrayRealVector(new double[] {0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}),             new ArrayRealVector(new double[] {-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}),             new ArrayRealVector(new double[] {0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266}),         };          // the following line triggers the exception         EigenDecomposition decomposition;         decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);          double[] eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i) {             Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);             if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {                 Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);             } else {                 Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);             }         }      }      /** test a matrix already in tridiagonal form. */     @Test     public void testTridiagonal() {         Random r = new Random(4366663527842l);         double[] ref = new double[30];         for (int i = 0; i < ref.length; ++i) {             if (i < 5) {                 ref[i] = 2 * r.nextDouble() - 1;             } else {                 ref[i] = 0.0001 * r.nextDouble() + 6;             }         }         Arrays.sort(ref);         TriDiagonalTransformer t =             new TriDiagonalTransformer(createTestMatrix(r, ref));         EigenDecomposition ed;         ed = new EigenDecomposition(t.getMainDiagonalRef(), t.getSecondaryDiagonalRef());         double[] eigenValues = ed.getRealEigenvalues();         Assert.assertEquals(ref.length, eigenValues.length);         for (int i = 0; i < ref.length; ++i) {             Assert.assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);         }      }      /** test dimensions */     @Test     public void testDimensions() {         final int m = matrix.getRowDimension();         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         Assert.assertEquals(m, ed.getV().getRowDimension());         Assert.assertEquals(m, ed.getV().getColumnDimension());         Assert.assertEquals(m, ed.getD().getColumnDimension());         Assert.assertEquals(m, ed.getD().getColumnDimension());         Assert.assertEquals(m, ed.getVT().getRowDimension());         Assert.assertEquals(m, ed.getVT().getColumnDimension());     }      /** test eigenvalues */     @Test     public void testEigenvalues() {         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         double[] eigenValues = ed.getRealEigenvalues();         Assert.assertEquals(refValues.length, eigenValues.length);         for (int i = 0; i < refValues.length; ++i) {             Assert.assertEquals(refValues[i], eigenValues[i], 3.0e-15);         }     }      /** test eigenvalues for a big matrix. */     @Test     public void testBigMatrix() {         Random r = new Random(17748333525117l);         double[] bigValues = new double[200];         for (int i = 0; i < bigValues.length; ++i) {             bigValues[i] = 2 * r.nextDouble() - 1;         }         Arrays.sort(bigValues);         EigenDecomposition ed;         ed = new EigenDecomposition(createTestMatrix(r, bigValues));         double[] eigenValues = ed.getRealEigenvalues();         Assert.assertEquals(bigValues.length, eigenValues.length);         for (int i = 0; i < bigValues.length; ++i) {             Assert.assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);         }     }      @Test     public void testSymmetric() {         RealMatrix symmetric = MatrixUtils.createRealMatrix(new double[][] {                 {4, 1, 1},                 {1, 2, 3},                 {1, 3, 6}         });          EigenDecomposition ed;         ed = new EigenDecomposition(symmetric);          RealMatrix d = ed.getD();         RealMatrix v = ed.getV();         RealMatrix vT = ed.getVT();          double norm = v.multiply(d).multiply(vT).subtract(symmetric).getNorm();         Assert.assertEquals(0, norm, 6.0e-13);     }      @Test     public void testSquareRoot() {         final double[][] data = {             { 33, 24,  7 },             { 24, 57, 11 },             {  7, 11,  9 }         };          final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data));         final RealMatrix sqrtM = dec.getSquareRoot();          // Reconstruct initial matrix.         final RealMatrix m = sqrtM.multiply(sqrtM);          final int dim = data.length;         for (int r = 0; r < dim; r++) {             for (int c = 0; c < dim; c++) {                 Assert.assertEquals("m[" + r + "][" + c + "]",                                     data[r][c], m.getEntry(r, c), 1e-13);             }         }     }      @Test(expected=MathUnsupportedOperationException.class)     public void testSquareRootNonSymmetric() {         final double[][] data = {             { 1,  2, 4 },             { 2,  3, 5 },             { 11, 5, 9 }         };          final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data));         @SuppressWarnings("unused")         final RealMatrix sqrtM = dec.getSquareRoot();     }      @Test(expected=MathUnsupportedOperationException.class)     public void testSquareRootNonPositiveDefinite() {         final double[][] data = {             { 1, 2,  4 },             { 2, 3,  5 },             { 4, 5, -9 }         };          final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data));         @SuppressWarnings("unused")         final RealMatrix sqrtM = dec.getSquareRoot();     }      @Test     public void testUnsymmetric() {         // Vandermonde matrix V(x;i,j) = x_i^{n - j} with x = (-1,-2,3,4)         double[][] vData = { { -1.0, 1.0, -1.0, 1.0 },                              { -8.0, 4.0, -2.0, 1.0 },                              { 27.0, 9.0,  3.0, 1.0 },                              { 64.0, 16.0, 4.0, 1.0 } };         checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(vData));          RealMatrix randMatrix = MatrixUtils.createRealMatrix(new double[][] {                 {0,  1,     0,     0},                 {1,  0,     2.e-7, 0},                 {0, -2.e-7, 0,     1},                 {0,  0,     1,     0}         });         checkUnsymmetricMatrix(randMatrix);          // from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html         double[][] randData2 = {                 {  0.680, -0.3300, -0.2700, -0.717, -0.687,  0.0259 },                 { -0.211,  0.5360,  0.0268,  0.214, -0.198,  0.6780 },                 {  0.566, -0.4440,  0.9040, -0.967, -0.740,  0.2250 },                 {  0.597,  0.1080,  0.8320, -0.514, -0.782, -0.4080 },                 {  0.823, -0.0452,  0.2710, -0.726,  0.998,  0.2750 },                 { -0.605,  0.2580,  0.4350,  0.608, -0.563,  0.0486 }         };         checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(randData2));     }      @Test     @Ignore     public void testRandomUnsymmetricMatrix() {         for (int run = 0; run < 100; run++) {             Random r = new Random(System.currentTimeMillis());              // matrix size             int size = r.nextInt(20) + 4;              double[][] data = new double[size][size];             for (int i = 0; i < size; i++) {                 for (int j = 0; j < size; j++) {                     data[i][j] = r.nextInt(100);                 }             }              RealMatrix m = MatrixUtils.createRealMatrix(data);             checkUnsymmetricMatrix(m);         }     }      /**      * Tests the porting of a bugfix in Jama-1.0.3 (from changelog):      *      *  Patched hqr2 method in Jama.EigenvalueDecomposition to avoid infinite loop;      *  Thanks Frederic Devernay <frederic.devernay@m4x.org>      */     @Test     public void testMath1051() {         double[][] data = {                 {0,0,0,0,0},                 {0,0,0,0,1},                 {0,0,0,1,0},                 {1,1,0,0,1},                 {1,0,1,0,1}         };          RealMatrix m = MatrixUtils.createRealMatrix(data);         checkUnsymmetricMatrix(m);     }      @Test     @Ignore     public void testNormalDistributionUnsymmetricMatrix() {         for (int run = 0; run < 100; run++) {             Random r = new Random(System.currentTimeMillis());             ContinuousDistribution.Sampler dist                 = new NormalDistribution(0.0, r.nextDouble() * 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                                     64925784252L));              // matrix size             int size = r.nextInt(20) + 4;              double[][] data = new double[size][size];             for (int i = 0; i < size; i++) {                 for (int j = 0; j < size; j++) {                     data[i][j] = dist.sample();                 }             }              RealMatrix m = MatrixUtils.createRealMatrix(data);             checkUnsymmetricMatrix(m);         }     }      @Test     public void testMath848() {         double[][] data = {                 { 0.1849449280, -0.0646971046,  0.0774755812, -0.0969651755, -0.0692648806,  0.3282344352, -0.0177423074,  0.2063136340},                 {-0.0742700134, -0.0289063030, -0.0017269460, -0.0375550146, -0.0487737922, -0.2616837868, -0.0821201295, -0.2530000167},                 { 0.2549910127,  0.0995733692, -0.0009718388,  0.0149282808,  0.1791878897, -0.0823182816,  0.0582629256,  0.3219545182},                 {-0.0694747557, -0.1880649148, -0.2740630911,  0.0720096468, -0.1800836914, -0.3518996425,  0.2486747833,  0.6257938167},                 { 0.0536360918, -0.1339297778,  0.2241579764, -0.0195327484, -0.0054103808,  0.0347564518,  0.5120802482, -0.0329902864},                 {-0.5933332356, -0.2488721082,  0.2357173629,  0.0177285473,  0.0856630593, -0.3567126300, -0.1600668126, -0.1010899621},                 {-0.0514349819, -0.0854319435,  0.1125050061,  0.0063453560, -0.2250000688, -0.2209343090,  0.1964623477, -0.1512329924},                 { 0.0197395947, -0.1997170581, -0.1425959019, -0.2749477910, -0.0969467073,  0.0603688520, -0.2826905192,  0.1794315473}};         RealMatrix m = MatrixUtils.createRealMatrix(data);         checkUnsymmetricMatrix(m);     }      /**      * Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by      * checking: A*V = V*D      */     private void checkUnsymmetricMatrix(final RealMatrix m) {         try {             EigenDecomposition ed = new EigenDecomposition(m);              RealMatrix d = ed.getD();             RealMatrix v = ed.getV();             //RealMatrix vT = ed.getVT();              RealMatrix x = m.multiply(v);             RealMatrix y = v.multiply(d);              double diffNorm = x.subtract(y).getNorm();             Assert.assertTrue("The norm of (X-Y) is too large: " + diffNorm + ", matrix=" + m.toString(),                     x.subtract(y).getNorm() < 1000 * Precision.EPSILON * FastMath.max(x.getNorm(), y.getNorm()));              RealMatrix invV = new LUDecomposition(v).getSolver().getInverse();             double norm = v.multiply(d).multiply(invV).subtract(m).getNorm();             Assert.assertEquals(0.0, norm, 1.0e-10);         } catch (Exception e) {             Assert.fail("Failed to create EigenDecomposition for matrix " + m.toString() + ", ex=" + e.toString());         }     }      /** test eigenvectors */     @Test     public void testEigenvectors() {         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         for (int i = 0; i < matrix.getRowDimension(); ++i) {             double lambda = ed.getRealEigenvalue(i);             RealVector v  = ed.getEigenvector(i);             RealVector mV = matrix.operate(v);             Assert.assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);         }     }      /** test A = VDVt */     @Test     public void testAEqualVDVt() {         EigenDecomposition ed;         ed = new EigenDecomposition(matrix);         RealMatrix v  = ed.getV();         RealMatrix d  = ed.getD();         RealMatrix vT = ed.getVT();         double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();         Assert.assertEquals(0, norm, 6.0e-13);     }      /** test that V is orthogonal */     @Test     public void testVOrthogonal() {         RealMatrix v = new EigenDecomposition(matrix).getV();         RealMatrix vTv = v.transpose().multiply(v);         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());         Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);     }      /** test diagonal matrix */     @Test     public void testDiagonal() {         double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };         RealMatrix m = MatrixUtils.createRealDiagonalMatrix(diagonal);         EigenDecomposition ed;         ed = new EigenDecomposition(m);         Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);         Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);         Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);         Assert.assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);     }      /**      * Matrix with eigenvalues {8, -1, -1}      */     @Test     public void testRepeatedEigenvalue() {         RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {                 {3,  2,  4},                 {2,  0,  2},                 {4,  2,  3}         });         EigenDecomposition ed;         ed = new EigenDecomposition(repeated);         checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);         checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);     }      /**      * Matrix with eigenvalues {2, 0, 12}      */     @Test     public void testDistinctEigenvalues() {         RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {                 {3, 1, -4},                 {1, 3, -4},                 {-4, -4, 8}         });         EigenDecomposition ed;         ed = new EigenDecomposition(distinct);         checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);         checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);         checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);         checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);     }      /**      * Verifies operation on indefinite matrix      */     @Test     public void testZeroDivide() {         RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] {                 { 0.0, 1.0, -1.0 },                 { 1.0, 1.0, 0.0 },                 { -1.0,0.0, 1.0 }         });         EigenDecomposition ed;         ed = new EigenDecomposition(indefinite);         checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);         double isqrt3 = 1/FastMath.sqrt(3.0);         checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);         double isqrt2 = 1/FastMath.sqrt(2.0);         checkEigenVector((new double[] {0.0,-isqrt2,-isqrt2}), ed, 1E-12);         double isqrt6 = 1/FastMath.sqrt(6.0);         checkEigenVector((new double[] {2*isqrt6,-isqrt6,isqrt6}), ed, 1E-12);     }      /**      * Verifies operation on very small values.      * Matrix with eigenvalues {2e-100, 0, 12e-100}      */     @Test     public void testTinyValues() {         final double tiny = 1e-100;         RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {                 {3, 1, -4},                 {1, 3, -4},                 {-4, -4, 8}         });         distinct = distinct.scalarMultiply(tiny);          final EigenDecomposition ed = new EigenDecomposition(distinct);         checkEigenValues(MathArrays.scale(tiny, new double[] {2, 0, 12}), ed, 1e-12 * tiny);         checkEigenVector(new double[] {1, -1, 0}, ed, 1e-12);         checkEigenVector(new double[] {1, 1, 1}, ed, 1e-12);         checkEigenVector(new double[] {-1, -1, 2}, ed, 1e-12);     }      /**      * Verifies that the given EigenDecomposition has eigenvalues equivalent to      * the targetValues, ignoring the order of the values and allowing      * values to differ by tolerance.      */     protected void checkEigenValues(double[] targetValues,             EigenDecomposition ed, double tolerance) {         double[] observed = ed.getRealEigenvalues();         for (int i = 0; i < observed.length; i++) {             Assert.assertTrue(isIncludedValue(observed[i], targetValues, tolerance));             Assert.assertTrue(isIncludedValue(targetValues[i], observed, tolerance));         }     }       /**      * Returns true iff there is an entry within tolerance of value in      * searchArray.      */     private boolean isIncludedValue(double value, double[] searchArray,             double tolerance) {        boolean found = false;        int i = 0;        while (!found && i < searchArray.length) {            if (FastMath.abs(value - searchArray[i]) < tolerance) {                found = true;            }            i++;        }        return found;     }      /**      * Returns true iff eigenVector is a scalar multiple of one of the columns      * of ed.getV().  Does not try linear combinations - i.e., should only be      * used to find vectors in one-dimensional eigenspaces.      */     protected void checkEigenVector(double[] eigenVector,             EigenDecomposition ed, double tolerance) {         Assert.assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));     }      /**      * Returns true iff there is a column that is a scalar multiple of column      * in searchMatrix (modulo tolerance)      */     private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,             double tolerance) {         boolean found = false;         int i = 0;         while (!found && i < searchMatrix.getColumnDimension()) {             double multiplier = 1.0;             boolean matching = true;             int j = 0;             while (matching && j < searchMatrix.getRowDimension()) {                 double colEntry = searchMatrix.getEntry(j, i);                 // Use the first entry where both are non-zero as scalar                 if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14                         && FastMath.abs(column[j]) > 1e-14) {                     multiplier = colEntry / column[j];                 }                 if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) {                     matching = false;                 }                 j++;             }             found = matching;             i++;         }         return found;     }      @Before     public void setUp() {         refValues = new double[] {                 2.003, 2.002, 2.001, 1.001, 1.000, 0.001         };         matrix = createTestMatrix(new Random(35992629946426l), refValues);     }      @After     public void tearDown() {         refValues = null;         matrix    = null;     }      static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {         final int n = eigenValues.length;         final RealMatrix v = createOrthogonalMatrix(r, n);         final RealMatrix d = MatrixUtils.createRealDiagonalMatrix(eigenValues);         return v.multiply(d).multiply(v.transpose());     }      public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {          final double[][] data = new double[size][size];          for (int i = 0; i < size; ++i) {             final double[] dataI = data[i];             double norm2 = 0;             do {                  // generate randomly row I                 for (int j = 0; j < size; ++j) {                     dataI[j] = 2 * r.nextDouble() - 1;                 }                  // project the row in the subspace orthogonal to previous rows                 for (int k = 0; k < i; ++k) {                     final double[] dataK = data[k];                     double dotProduct = 0;                     for (int j = 0; j < size; ++j) {                         dotProduct += dataI[j] * dataK[j];                     }                     for (int j = 0; j < size; ++j) {                         dataI[j] -= dotProduct * dataK[j];                     }                 }                  // normalize the row                 norm2 = 0;                 for (final double dataIJ : dataI) {                     norm2 += dataIJ * dataIJ;                 }                 final double inv = 1.0 / FastMath.sqrt(norm2);                 for (int j = 0; j < size; ++j) {                     dataI[j] *= inv;                 }              } while (norm2 * size < 0.01);         }          return MatrixUtils.createRealMatrix(data);      } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link DiagonalMatrix} class.  */ public class DiagonalMatrixTest {     @Test     public void testConstructor1() {         final int dim = 3;         final DiagonalMatrix m = new DiagonalMatrix(dim);         Assert.assertEquals(dim, m.getRowDimension());         Assert.assertEquals(dim, m.getColumnDimension());     }      @Test     public void testConstructor2() {         final double[] d = { -1.2, 3.4, 5 };         final DiagonalMatrix m = new DiagonalMatrix(d);         for (int i = 0; i < m.getRowDimension(); i++) {             for (int j = 0; j < m.getRowDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(d[i], m.getEntry(i, j), 0d);                 } else {                     Assert.assertEquals(0d, m.getEntry(i, j), 0d);                 }             }         }          // Check that the underlying was copied.         d[0] = 0;         Assert.assertFalse(d[0] == m.getEntry(0, 0));     }      @Test     public void testConstructor3() {         final double[] d = { -1.2, 3.4, 5 };         final DiagonalMatrix m = new DiagonalMatrix(d, false);         for (int i = 0; i < m.getRowDimension(); i++) {             for (int j = 0; j < m.getRowDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(d[i], m.getEntry(i, j), 0d);                 } else {                     Assert.assertEquals(0d, m.getEntry(i, j), 0d);                 }             }         }          // Check that the underlying is referenced.         d[0] = 0;         Assert.assertTrue(d[0] == m.getEntry(0, 0));      }      @Test(expected=DimensionMismatchException.class)     public void testCreateError() {         final double[] d = { -1.2, 3.4, 5 };         final DiagonalMatrix m = new DiagonalMatrix(d, false);         m.createMatrix(5, 3);     }      @Test     public void testCreate() {         final double[] d = { -1.2, 3.4, 5 };         final DiagonalMatrix m = new DiagonalMatrix(d, false);         final RealMatrix p = m.createMatrix(5, 5);         Assert.assertTrue(p instanceof DiagonalMatrix);         Assert.assertEquals(5, p.getRowDimension());         Assert.assertEquals(5, p.getColumnDimension());     }      @Test     public void testCopy() {         final double[] d = { -1.2, 3.4, 5 };         final DiagonalMatrix m = new DiagonalMatrix(d, false);         final DiagonalMatrix p = (DiagonalMatrix) m.copy();         for (int i = 0; i < m.getRowDimension(); ++i) {             Assert.assertEquals(m.getEntry(i, i), p.getEntry(i, i), 1.0e-20);         }     }      @Test     public void testGetData() {         final double[] data = { -1.2, 3.4, 5 };         final int dim = 3;         final DiagonalMatrix m = new DiagonalMatrix(dim);         for (int i = 0; i < dim; i++) {             m.setEntry(i, i, data[i]);         }          final double[][] out = m.getData();         Assert.assertEquals(dim, out.length);         for (int i = 0; i < m.getRowDimension(); i++) {             Assert.assertEquals(dim, out[i].length);             for (int j = 0; j < m.getRowDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(data[i], out[i][j], 0d);                 } else {                     Assert.assertEquals(0d, out[i][j], 0d);                 }             }         }     }      @Test     public void testAdd() {         final double[] data1 = { -1.2, 3.4, 5 };         final DiagonalMatrix m1 = new DiagonalMatrix(data1);          final double[] data2 = { 10.1, 2.3, 45 };         final DiagonalMatrix m2 = new DiagonalMatrix(data2);          final DiagonalMatrix result = m1.add(m2);         Assert.assertEquals(m1.getRowDimension(), result.getRowDimension());         for (int i = 0; i < result.getRowDimension(); i++) {             for (int j = 0; j < result.getRowDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(data1[i] + data2[i], result.getEntry(i, j), 0d);                 } else {                     Assert.assertEquals(0d, result.getEntry(i, j), 0d);                 }             }         }     }      @Test     public void testSubtract() {         final double[] data1 = { -1.2, 3.4, 5 };         final DiagonalMatrix m1 = new DiagonalMatrix(data1);          final double[] data2 = { 10.1, 2.3, 45 };         final DiagonalMatrix m2 = new DiagonalMatrix(data2);          final DiagonalMatrix result = m1.subtract(m2);         Assert.assertEquals(m1.getRowDimension(), result.getRowDimension());         for (int i = 0; i < result.getRowDimension(); i++) {             for (int j = 0; j < result.getRowDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(data1[i] - data2[i], result.getEntry(i, j), 0d);                 } else {                     Assert.assertEquals(0d, result.getEntry(i, j), 0d);                 }             }         }     }      @Test     public void testAddToEntry() {         final double[] data = { -1.2, 3.4, 5 };         final DiagonalMatrix m = new DiagonalMatrix(data);          for (int i = 0; i < m.getRowDimension(); i++) {             m.addToEntry(i, i, i);             Assert.assertEquals(data[i] + i, m.getEntry(i, i), 0d);         }     }      @Test     public void testMultiplyEntry() {         final double[] data = { -1.2, 3.4, 5 };         final DiagonalMatrix m = new DiagonalMatrix(data);          for (int i = 0; i < m.getRowDimension(); i++) {             m.multiplyEntry(i, i, i);             Assert.assertEquals(data[i] * i, m.getEntry(i, i), 0d);         }     }      @Test     public void testMultiply1() {         final double[] data1 = { -1.2, 3.4, 5 };         final DiagonalMatrix m1 = new DiagonalMatrix(data1);         final double[] data2 = { 10.1, 2.3, 45 };         final DiagonalMatrix m2 = new DiagonalMatrix(data2);          final DiagonalMatrix result = (DiagonalMatrix) m1.multiply((RealMatrix) m2);         Assert.assertEquals(m1.getRowDimension(), result.getRowDimension());         for (int i = 0; i < result.getRowDimension(); i++) {             for (int j = 0; j < result.getRowDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(data1[i] * data2[i], result.getEntry(i, j), 0d);                 } else {                     Assert.assertEquals(0d, result.getEntry(i, j), 0d);                 }             }         }     }      @Test     public void testMultiply2() {         final double[] data1 = { -1.2, 3.4, 5 };         final DiagonalMatrix diag1 = new DiagonalMatrix(data1);          final double[][] data2 = { { -1.2, 3.4 },                                    { -5.6, 7.8 },                                    {  9.1, 2.3 } };         final RealMatrix dense2 = new Array2DRowRealMatrix(data2);         final RealMatrix dense1 = new Array2DRowRealMatrix(diag1.getData());          final RealMatrix diagResult = diag1.multiply(dense2);         final RealMatrix denseResult = dense1.multiply(dense2);          for (int i = 0; i < dense1.getRowDimension(); i++) {             for (int j = 0; j < dense2.getColumnDimension(); j++) {                 Assert.assertEquals(denseResult.getEntry(i, j),                                     diagResult.getEntry(i, j), 0d);             }         }     }      @Test     public void testOperate() {         final double[] data = { -1.2, 3.4, 5 };         final DiagonalMatrix diag = new DiagonalMatrix(data);         final RealMatrix dense = new Array2DRowRealMatrix(diag.getData());          final double[] v = { 6.7, 890.1, 23.4 };         final double[] diagResult = diag.operate(v);         final double[] denseResult = dense.operate(v);          TestUtils.assertEquals(diagResult, denseResult, 0d);     }      @Test     public void testPreMultiply() {         final double[] data = { -1.2, 3.4, 5 };         final DiagonalMatrix diag = new DiagonalMatrix(data);         final RealMatrix dense = new Array2DRowRealMatrix(diag.getData());          final double[] v = { 6.7, 890.1, 23.4 };         final double[] diagResult = diag.preMultiply(v);         final double[] denseResult = dense.preMultiply(v);          TestUtils.assertEquals(diagResult, denseResult, 0d);     }      @Test     public void testPreMultiplyVector() {         final double[] data = { -1.2, 3.4, 5 };         final DiagonalMatrix diag = new DiagonalMatrix(data);         final RealMatrix dense = new Array2DRowRealMatrix(diag.getData());          final double[] v = { 6.7, 890.1, 23.4 };         final RealVector vector = MatrixUtils.createRealVector(v);         final RealVector diagResult = diag.preMultiply(vector);         final RealVector denseResult = dense.preMultiply(vector);          TestUtils.assertEquals("preMultiply(Vector) returns wrong result", diagResult, denseResult, 0d);     }      @Test(expected=NumberIsTooLargeException.class)     public void testSetNonDiagonalEntry() {         final DiagonalMatrix diag = new DiagonalMatrix(3);         diag.setEntry(1, 2, 3.4);     }      @Test     public void testSetNonDiagonalZero() {         final DiagonalMatrix diag = new DiagonalMatrix(3);         diag.setEntry(1, 2, 0.0);         Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);     }      @Test(expected=NumberIsTooLargeException.class)     public void testAddNonDiagonalEntry() {         final DiagonalMatrix diag = new DiagonalMatrix(3);         diag.addToEntry(1, 2, 3.4);     }      @Test     public void testAddNonDiagonalZero() {         final DiagonalMatrix diag = new DiagonalMatrix(3);         diag.addToEntry(1, 2, 0.0);         Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);     }      @Test     public void testMultiplyNonDiagonalEntry() {         final DiagonalMatrix diag = new DiagonalMatrix(3);         diag.multiplyEntry(1, 2, 3.4);         Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);     }      @Test     public void testMultiplyNonDiagonalZero() {         final DiagonalMatrix diag = new DiagonalMatrix(3);         diag.multiplyEntry(1, 2, 0.0);         Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);     }      @Test(expected=OutOfRangeException.class)     public void testSetEntryOutOfRange() {         final DiagonalMatrix diag = new DiagonalMatrix(3);         diag.setEntry(3, 3, 3.4);     }      @Test(expected=NullArgumentException.class)     public void testNull() {         new DiagonalMatrix(null, false);     }      @Test(expected=NumberIsTooLargeException.class)     public void testSetSubMatrixError() {         final double[] data = { -1.2, 3.4, 5 };         final DiagonalMatrix diag = new DiagonalMatrix(data);         diag.setSubMatrix(new double[][] { {1.0, 1.0}, {1.0, 1.0}}, 1, 1);     }      @Test     public void testSetSubMatrix() {         final double[] data = { -1.2, 3.4, 5 };         final DiagonalMatrix diag = new DiagonalMatrix(data);         diag.setSubMatrix(new double[][] { {0.0, 5.0, 0.0}, {0.0, 0.0, 6.0}}, 1, 0);         Assert.assertEquals(-1.2, diag.getEntry(0, 0), 1.0e-20);         Assert.assertEquals( 5.0, diag.getEntry(1, 1), 1.0e-20);         Assert.assertEquals( 6.0, diag.getEntry(2, 2), 1.0e-20);     }      @Test(expected=SingularMatrixException.class)     public void testInverseError() {         final double[] data = { 1, 2, 0 };         final DiagonalMatrix diag = new DiagonalMatrix(data);         diag.inverse();     }      @Test(expected=SingularMatrixException.class)     public void testInverseError2() {         final double[] data = { 1, 2, 1e-6 };         final DiagonalMatrix diag = new DiagonalMatrix(data);         diag.inverse(1e-5);     }      @Test     public void testInverse() {         final double[] data = { 1, 2, 3 };         final DiagonalMatrix m = new DiagonalMatrix(data);         final DiagonalMatrix inverse = m.inverse();          final DiagonalMatrix result = m.multiply(inverse);         TestUtils.assertEquals("DiagonalMatrix.inverse() returns wrong result",                 MatrixUtils.createRealIdentityMatrix(data.length), result, Math.ulp(1d));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Locale;   public class RealMatrixFormatTest extends RealMatrixFormatAbstractTest {      @Override     protected char getDecimalCharacter() {         return '.';     }      @Override     protected Locale getLocale() {         return Locale.US;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.dfp.Dfp;  public class FieldLUDecompositionTest {     private Dfp[][] testData = {             { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)},             { Dfp25.of(2), Dfp25.of(5), Dfp25.of(3)},             { Dfp25.of(1), Dfp25.of(0), Dfp25.of(8)}     };     private Dfp[][] testDataMinus = {             { Dfp25.of(-1), Dfp25.of(-2), Dfp25.of(-3)},             { Dfp25.of(-2), Dfp25.of(-5), Dfp25.of(-3)},             { Dfp25.of(-1),  Dfp25.of(0), Dfp25.of(-8)}     };     private Dfp[][] luData = {             { Dfp25.of(2), Dfp25.of(3), Dfp25.of(3) },             { Dfp25.of(2), Dfp25.of(3), Dfp25.of(7) },             { Dfp25.of(6), Dfp25.of(6), Dfp25.of(8) }     };      // singular matrices     private Dfp[][] singular = {             { Dfp25.of(2), Dfp25.of(3) },             { Dfp25.of(2), Dfp25.of(3) }     };     private Dfp[][] bigSingular = {             { Dfp25.of(1), Dfp25.of(2),   Dfp25.of(3),    Dfp25.of(4) },             { Dfp25.of(2), Dfp25.of(5),   Dfp25.of(3),    Dfp25.of(4) },             { Dfp25.of(7), Dfp25.of(3), Dfp25.of(256), Dfp25.of(1930) },             { Dfp25.of(3), Dfp25.of(7),   Dfp25.of(6),    Dfp25.of(8) }     }; // 4th row = 1st + 2nd      /** test dimensions */     @Test     public void testDimensions() {         FieldMatrix<Dfp> matrix =             new Array2DRowFieldMatrix<>(Dfp25.getField(), testData);         FieldLUDecomposition<Dfp> LU = new FieldLUDecomposition<>(matrix);         Assert.assertEquals(testData.length, LU.getL().getRowDimension());         Assert.assertEquals(testData.length, LU.getL().getColumnDimension());         Assert.assertEquals(testData.length, LU.getU().getRowDimension());         Assert.assertEquals(testData.length, LU.getU().getColumnDimension());         Assert.assertEquals(testData.length, LU.getP().getRowDimension());         Assert.assertEquals(testData.length, LU.getP().getColumnDimension());      }      /** test non-square matrix */     @Test     public void testNonSquare() {         try {             // we don't use Dfp25.getField() for testing purposes             new FieldLUDecomposition<>(new Array2DRowFieldMatrix<>(new Dfp[][] {                     { Dfp25.ZERO, Dfp25.ZERO },                     { Dfp25.ZERO, Dfp25.ZERO },                     { Dfp25.ZERO, Dfp25.ZERO }             }));             Assert.fail("Expected NonSquareMatrixException");         } catch (NonSquareMatrixException ime) {             // expected behavior         }     }      /** test PA = LU */     @Test     public void testPAEqualLU() {         FieldMatrix<Dfp> matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), testData);         FieldLUDecomposition<Dfp> lu = new FieldLUDecomposition<>(matrix);         FieldMatrix<Dfp> l = lu.getL();         FieldMatrix<Dfp> u = lu.getU();         FieldMatrix<Dfp> p = lu.getP();         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));          matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), testDataMinus);         lu = new FieldLUDecomposition<>(matrix);         l = lu.getL();         u = lu.getU();         p = lu.getP();         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));          matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), 17, 17);         for (int i = 0; i < matrix.getRowDimension(); ++i) {             matrix.setEntry(i, i, Dfp25.ONE);         }         lu = new FieldLUDecomposition<>(matrix);         l = lu.getL();         u = lu.getU();         p = lu.getP();         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));          matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), singular);         lu = new FieldLUDecomposition<>(matrix);         Assert.assertFalse(lu.getSolver().isNonSingular());         Assert.assertNull(lu.getL());         Assert.assertNull(lu.getU());         Assert.assertNull(lu.getP());          matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), bigSingular);         lu = new FieldLUDecomposition<>(matrix);         Assert.assertFalse(lu.getSolver().isNonSingular());         Assert.assertNull(lu.getL());         Assert.assertNull(lu.getU());         Assert.assertNull(lu.getP());      }      /** test that L is lower triangular with unit diagonal */     @Test     public void testLLowerTriangular() {         FieldMatrix<Dfp> matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), testData);         FieldMatrix<Dfp> l = new FieldLUDecomposition<>(matrix).getL();         for (int i = 0; i < l.getRowDimension(); i++) {             Assert.assertEquals(Dfp25.ONE, l.getEntry(i, i));             for (int j = i + 1; j < l.getColumnDimension(); j++) {                 Assert.assertEquals(Dfp25.ZERO, l.getEntry(i, j));             }         }     }      /** test that U is upper triangular */     @Test     public void testUUpperTriangular() {         FieldMatrix<Dfp> matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), testData);         FieldMatrix<Dfp> u = new FieldLUDecomposition<>(matrix).getU();         for (int i = 0; i < u.getRowDimension(); i++) {             for (int j = 0; j < i; j++) {                 Assert.assertEquals(Dfp25.ZERO, u.getEntry(i, j));             }         }     }      /** test that P is a permutation matrix */     @Test     public void testPPermutation() {         FieldMatrix<Dfp> matrix = new Array2DRowFieldMatrix<>(Dfp25.getField(), testData);         FieldMatrix<Dfp> p   = new FieldLUDecomposition<>(matrix).getP();          FieldMatrix<Dfp> ppT = p.multiply(p.transpose());         FieldMatrix<Dfp> id  =             new Array2DRowFieldMatrix<>(Dfp25.getField(),                                           p.getRowDimension(), p.getRowDimension());         for (int i = 0; i < id.getRowDimension(); ++i) {             id.setEntry(i, i, Dfp25.ONE);         }         TestUtils.assertEquals(id, ppT);          for (int i = 0; i < p.getRowDimension(); i++) {             int zeroCount  = 0;             int oneCount   = 0;             int otherCount = 0;             for (int j = 0; j < p.getColumnDimension(); j++) {                 final Dfp e = p.getEntry(i, j);                 if (e.equals(Dfp25.ZERO)) {                     ++zeroCount;                 } else if (e.equals(Dfp25.ONE)) {                     ++oneCount;                 } else {                     ++otherCount;                 }             }             Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);             Assert.assertEquals(1, oneCount);             Assert.assertEquals(0, otherCount);         }          for (int j = 0; j < p.getColumnDimension(); j++) {             int zeroCount  = 0;             int oneCount   = 0;             int otherCount = 0;             for (int i = 0; i < p.getRowDimension(); i++) {                 final Dfp e = p.getEntry(i, j);                 if (e.equals(Dfp25.ZERO)) {                     ++zeroCount;                 } else if (e.equals(Dfp25.ONE)) {                     ++oneCount;                 } else {                     ++otherCount;                 }             }             Assert.assertEquals(p.getRowDimension() - 1, zeroCount);             Assert.assertEquals(1, oneCount);             Assert.assertEquals(0, otherCount);         }      }       /** test singular */     @Test     public void testSingular() {         FieldLUDecomposition<Dfp> lu =             new FieldLUDecomposition<>(new Array2DRowFieldMatrix<>(Dfp25.getField(), testData));         Assert.assertTrue(lu.getSolver().isNonSingular());         lu = new FieldLUDecomposition<>(new Array2DRowFieldMatrix<>(Dfp25.getField(), singular));         Assert.assertFalse(lu.getSolver().isNonSingular());         lu = new FieldLUDecomposition<>(new Array2DRowFieldMatrix<>(Dfp25.getField(), bigSingular));         Assert.assertFalse(lu.getSolver().isNonSingular());     }      /** test matrices values */     @Test     public void testMatricesValues1() {        FieldLUDecomposition<Dfp> lu =             new FieldLUDecomposition<>(new Array2DRowFieldMatrix<>(Dfp25.getField(), testData));         FieldMatrix<Dfp> lRef = new Array2DRowFieldMatrix<>(Dfp25.getField(), new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(0), Dfp25.of(0) },                 { Dfp25.of(2), Dfp25.of(1), Dfp25.of(0) },                 { Dfp25.of(1), Dfp25.of(-2), Dfp25.of(1) }         });         FieldMatrix<Dfp> uRef = new Array2DRowFieldMatrix<>(Dfp25.getField(), new Dfp[][] {                 { Dfp25.of(1),  Dfp25.of(2), Dfp25.of(3) },                 { Dfp25.of(0), Dfp25.of(1), Dfp25.of(-3) },                 { Dfp25.of(0),  Dfp25.of(0), Dfp25.of(-1) }         });         FieldMatrix<Dfp> pRef = new Array2DRowFieldMatrix<>(Dfp25.getField(), new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(0), Dfp25.of(0) },                 { Dfp25.of(0), Dfp25.of(1), Dfp25.of(0) },                 { Dfp25.of(0), Dfp25.of(0), Dfp25.of(1) }         });         int[] pivotRef = { 0, 1, 2 };          // check values against known references         FieldMatrix<Dfp> l = lu.getL();         TestUtils.assertEquals(lRef, l);         FieldMatrix<Dfp> u = lu.getU();         TestUtils.assertEquals(uRef, u);         FieldMatrix<Dfp> p = lu.getP();         TestUtils.assertEquals(pRef, p);         int[] pivot = lu.getPivot();         for (int i = 0; i < pivotRef.length; ++i) {             Assert.assertEquals(pivotRef[i], pivot[i]);         }          // check the same cached instance is returned the second time         Assert.assertTrue(l == lu.getL());         Assert.assertTrue(u == lu.getU());         Assert.assertTrue(p == lu.getP());      }      /** test matrices values */     @Test     public void testMatricesValues2() {        FieldLUDecomposition<Dfp> lu =             new FieldLUDecomposition<>(new Array2DRowFieldMatrix<>(Dfp25.getField(), luData));         FieldMatrix<Dfp> lRef = new Array2DRowFieldMatrix<>(Dfp25.getField(), new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(0), Dfp25.of(0) },                 { Dfp25.of(3), Dfp25.of(1), Dfp25.of(0) },                 { Dfp25.of(1), Dfp25.of(0), Dfp25.of(1) }         });         FieldMatrix<Dfp> uRef = new Array2DRowFieldMatrix<>(Dfp25.getField(), new Dfp[][] {                 { Dfp25.of(2), Dfp25.of(3), Dfp25.of(3)    },                 { Dfp25.of(0), Dfp25.of(-3), Dfp25.of(-1)  },                 { Dfp25.of(0), Dfp25.of(0), Dfp25.of(4) }         });         FieldMatrix<Dfp> pRef = new Array2DRowFieldMatrix<>(Dfp25.getField(), new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(0), Dfp25.of(0) },                 { Dfp25.of(0), Dfp25.of(0), Dfp25.of(1) },                 { Dfp25.of(0), Dfp25.of(1), Dfp25.of(0) }         });         int[] pivotRef = { 0, 2, 1 };          // check values against known references         FieldMatrix<Dfp> l = lu.getL();         TestUtils.assertEquals(lRef, l);         FieldMatrix<Dfp> u = lu.getU();         TestUtils.assertEquals(uRef, u);         FieldMatrix<Dfp> p = lu.getP();         TestUtils.assertEquals(pRef, p);         int[] pivot = lu.getPivot();         for (int i = 0; i < pivotRef.length; ++i) {             Assert.assertEquals(pivotRef[i], pivot[i]);         }          // check the same cached instance is returned the second time         Assert.assertTrue(l == lu.getL());         Assert.assertTrue(u == lu.getU());         Assert.assertTrue(p == lu.getP());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  /**  * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for  * unmodifiable views of {@link OpenMapRealVector}.  *  */ public class UnmodifiableOpenMapRealVectorTest     extends UnmodifiableRealVectorAbstractTest {     /** To ensure sufficient sparsity. */     public static final double PROBABILITY_OF_ZERO = 0.5;      /**      * Returns a random vector of type {@link ArrayRealVector}.      *      * @return a new random {@link ArrayRealVector}.      */     @Override     public RealVector createVector() {         OpenMapRealVector v = new OpenMapRealVector(DIM, EPS);         for (int i = 0; i < DIM; i++) {             if (RANDOM.nextDouble() > PROBABILITY_OF_ZERO) {                 v.setEntry(i, RANDOM.nextDouble());             }         }         return v;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Locale;   public class RealVectorFormatTest extends RealVectorFormatAbstractTest {      @Override     protected char getDecimalCharacter() {         return '.';     }      @Override     protected Locale getLocale() {         return Locale.US;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import java.io.Serializable; import java.lang.reflect.Array; import java.util.Arrays;  import org.apache.commons.math4.Field; import org.apache.commons.math4.FieldElement; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.util.BigReal; import org.apache.commons.math4.util.BigRealField; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link ArrayFieldVector} class.  *  */ public class ArrayFieldVectorTest {      //     protected Dfp[][] ma1 = {             {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)},             {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6)},             {Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)}     };     protected Dfp[] vec1 = {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)};     protected Dfp[] vec2 = {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6)};     protected Dfp[] vec3 = {Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)};     protected Dfp[] vec4 = { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3),                                   Dfp25.of(4), Dfp25.of(5), Dfp25.of(6),                                   Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)};     protected Dfp[] vec_null = {Dfp25.ZERO, Dfp25.ZERO, Dfp25.ZERO};     protected Dfp[] dvec1 = {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3),                                   Dfp25.of(4), Dfp25.of(5), Dfp25.of(6),                                   Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)};     protected Dfp[][] mat1 = {             {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)},             {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6)},             {Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)}     };      // Testclass to test the FieldVector<Dfp> interface     // only with enough content to support the test     public static class FieldVectorTestImpl<T extends FieldElement<T>>         implements FieldVector<T>, Serializable {          private static final long serialVersionUID = 3970959016014158539L;          private final Field<T> field;          /** Entries of the vector. */         protected T[] data;          /** Build an array of elements.          * @param length size of the array to build          * @return a new array          */         @SuppressWarnings("unchecked") // field is of type T         private T[] buildArray(final int length) {             return (T[]) Array.newInstance(field.getRuntimeClass(), length);         }          public FieldVectorTestImpl(T[] d) {             field = d[0].getField();             data = d.clone();         }          @Override         public Field<T> getField() {             return field;         }          private UnsupportedOperationException unsupported() {             return new UnsupportedOperationException("Not supported, unneeded for test purposes");         }          @Override         public FieldVector<T> copy() {             throw unsupported();         }          @Override         public FieldVector<T> add(FieldVector<T> v) {             throw unsupported();         }          public FieldVector<T> add(T[] v) {             throw unsupported();         }          @Override         public FieldVector<T> subtract(FieldVector<T> v) {             throw unsupported();         }          public FieldVector<T> subtract(T[] v) {             throw unsupported();         }          @Override         public FieldVector<T> mapAdd(T d) {             throw unsupported();         }          @Override         public FieldVector<T> mapAddToSelf(T d) {             throw unsupported();         }          @Override         public FieldVector<T> mapSubtract(T d) {             throw unsupported();         }          @Override         public FieldVector<T> mapSubtractToSelf(T d) {             throw unsupported();         }          @Override         public FieldVector<T> mapMultiply(T d) {             T[] out = buildArray(data.length);             for (int i = 0; i < data.length; i++) {                 out[i] = data[i].multiply(d);             }             return new FieldVectorTestImpl<>(out);         }          @Override         public FieldVector<T> mapMultiplyToSelf(T d) {             throw unsupported();         }          @Override         public FieldVector<T> mapDivide(T d) {             throw unsupported();         }          @Override         public FieldVector<T> mapDivideToSelf(T d) {             throw unsupported();         }          @Override         public FieldVector<T> mapInv() {             throw unsupported();         }          @Override         public FieldVector<T> mapInvToSelf() {             throw unsupported();         }          @Override         public FieldVector<T> ebeMultiply(FieldVector<T> v) {             throw unsupported();         }          public FieldVector<T> ebeMultiply(T[] v) {             throw unsupported();         }          @Override         public FieldVector<T> ebeDivide(FieldVector<T> v) {             throw unsupported();         }          public FieldVector<T> ebeDivide(T[] v) {             throw unsupported();         }          public T[] getData() {             return data.clone();         }          @Override         public T dotProduct(FieldVector<T> v) {             T dot = field.getZero();             for (int i = 0; i < data.length; i++) {                 dot = dot.add(data[i].multiply(v.getEntry(i)));             }             return dot;         }          public T dotProduct(T[] v) {             T dot = field.getZero();             for (int i = 0; i < data.length; i++) {                 dot = dot.add(data[i].multiply(v[i]));             }             return dot;         }          @Override         public FieldVector<T> projection(FieldVector<T> v) {             throw unsupported();         }          public FieldVector<T> projection(T[] v) {             throw unsupported();         }          @Override         public FieldMatrix<T> outerProduct(FieldVector<T> v) {             throw unsupported();         }          public FieldMatrix<T> outerProduct(T[] v) {             throw unsupported();         }          @Override         public T getEntry(int index) {             return data[index];         }          @Override         public int getDimension() {             return data.length;         }          @Override         public FieldVector<T> append(FieldVector<T> v) {             throw unsupported();         }          @Override         public FieldVector<T> append(T d) {             throw unsupported();         }          public FieldVector<T> append(T[] a) {             throw unsupported();         }          @Override         public FieldVector<T> getSubVector(int index, int n) {             throw unsupported();         }          @Override         public void setEntry(int index, T value) {             throw unsupported();         }          @Override         public void setSubVector(int index, FieldVector<T> v) {             throw unsupported();         }          public void setSubVector(int index, T[] v) {             throw unsupported();         }          @Override         public void set(T value) {             throw unsupported();         }          @Override         public T[] toArray() {             return data.clone();         }      }      @Test     public void testConstructors() {          ArrayFieldVector<Dfp> v0 = new ArrayFieldVector<>(Dfp25.getField());         Assert.assertEquals(0, v0.getDimension());          ArrayFieldVector<Dfp> v1 = new ArrayFieldVector<>(Dfp25.getField(), 7);         Assert.assertEquals(7, v1.getDimension());         Assert.assertEquals(Dfp25.ZERO, v1.getEntry(6));          ArrayFieldVector<Dfp> v2 = new ArrayFieldVector<>(5, Dfp25.of(123, 100));         Assert.assertEquals(5, v2.getDimension());         Assert.assertEquals(Dfp25.of(123, 100), v2.getEntry(4));          ArrayFieldVector<Dfp> v3 = new ArrayFieldVector<>(Dfp25.getField(), vec1);         Assert.assertEquals(3, v3.getDimension());         Assert.assertEquals(Dfp25.of(2), v3.getEntry(1));          ArrayFieldVector<Dfp> v4 = new ArrayFieldVector<>(Dfp25.getField(), vec4, 3, 2);         Assert.assertEquals(2, v4.getDimension());         Assert.assertEquals(Dfp25.of(4), v4.getEntry(0));         try {             new ArrayFieldVector<>(vec4, 8, 3);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }          FieldVector<Dfp> v5_i = new ArrayFieldVector<>(dvec1);         Assert.assertEquals(9, v5_i.getDimension());         Assert.assertEquals(Dfp25.of(9), v5_i.getEntry(8));          ArrayFieldVector<Dfp> v5 = new ArrayFieldVector<>(dvec1);         Assert.assertEquals(9, v5.getDimension());         Assert.assertEquals(Dfp25.of(9), v5.getEntry(8));          ArrayFieldVector<Dfp> v6 = new ArrayFieldVector<>(dvec1, 3, 2);         Assert.assertEquals(2, v6.getDimension());         Assert.assertEquals(Dfp25.of(4), v6.getEntry(0));         try {             new ArrayFieldVector<>(dvec1, 8, 3);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }          ArrayFieldVector<Dfp> v7 = new ArrayFieldVector<>(v1);         Assert.assertEquals(7, v7.getDimension());         Assert.assertEquals(Dfp25.ZERO, v7.getEntry(6));          FieldVectorTestImpl<Dfp> v7_i = new FieldVectorTestImpl<>(vec1);          ArrayFieldVector<Dfp> v7_2 = new ArrayFieldVector<>(v7_i);         Assert.assertEquals(3, v7_2.getDimension());         Assert.assertEquals(Dfp25.of(2), v7_2.getEntry(1));          ArrayFieldVector<Dfp> v8 = new ArrayFieldVector<>(v1, true);         Assert.assertEquals(7, v8.getDimension());         Assert.assertEquals(Dfp25.ZERO, v8.getEntry(6));         Assert.assertNotSame("testData not same object ", v1.getDataRef(), v8.getDataRef());          ArrayFieldVector<Dfp> v8_2 = new ArrayFieldVector<>(v1, false);         Assert.assertEquals(7, v8_2.getDimension());         Assert.assertEquals(Dfp25.ZERO, v8_2.getEntry(6));         Assert.assertArrayEquals(v1.getDataRef(), v8_2.getDataRef());          ArrayFieldVector<Dfp> v9 = new ArrayFieldVector<>((FieldVector<Dfp>) v1, (FieldVector<Dfp>) v3);         Assert.assertEquals(10, v9.getDimension());         Assert.assertEquals(Dfp25.of(1), v9.getEntry(7));      }      @Test     public void testDataInOut() {          ArrayFieldVector<Dfp> v1 = new ArrayFieldVector<>(vec1);         ArrayFieldVector<Dfp> v2 = new ArrayFieldVector<>(vec2);         ArrayFieldVector<Dfp> v4 = new ArrayFieldVector<>(vec4);         FieldVectorTestImpl<Dfp> v2_t = new FieldVectorTestImpl<>(vec2);          FieldVector<Dfp> v_append_1 = v1.append(v2);         Assert.assertEquals(6, v_append_1.getDimension());         Assert.assertEquals(Dfp25.of(4), v_append_1.getEntry(3));          FieldVector<Dfp> v_append_2 = v1.append(Dfp25.of(2));         Assert.assertEquals(4, v_append_2.getDimension());         Assert.assertEquals(Dfp25.of(2), v_append_2.getEntry(3));          FieldVector<Dfp> v_append_4 = v1.append(v2_t);         Assert.assertEquals(6, v_append_4.getDimension());         Assert.assertEquals(Dfp25.of(4), v_append_4.getEntry(3));          FieldVector<Dfp> v_copy = v1.copy();         Assert.assertEquals(3, v_copy.getDimension());         Assert.assertNotSame("testData not same object ", v1.getDataRef(), v_copy.toArray());          Dfp[] a_frac = v1.toArray();         Assert.assertEquals(3, a_frac.length);         Assert.assertNotSame("testData not same object ", v1.getDataRef(), a_frac);   //      ArrayFieldVector<Dfp> vout4 = (ArrayFieldVector<Dfp>) v1.clone(); //      Assert.assertEquals(3, vout4.getDimension()); //      Assert.assertEquals(v1.getDataRef(), vout4.getDataRef());           FieldVector<Dfp> vout5 = v4.getSubVector(3, 3);         Assert.assertEquals(3, vout5.getDimension());         Assert.assertEquals(Dfp25.of(5), vout5.getEntry(1));         try {             v4.getSubVector(3, 7);             Assert.fail("OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected behavior         }          ArrayFieldVector<Dfp> v_set1 = (ArrayFieldVector<Dfp>) v1.copy();         v_set1.setEntry(1, Dfp25.of(11));         Assert.assertEquals(Dfp25.of(11), v_set1.getEntry(1));         try {             v_set1.setEntry(3, Dfp25.of(11));             Assert.fail("OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected behavior         }          ArrayFieldVector<Dfp> v_set2 = (ArrayFieldVector<Dfp>) v4.copy();         v_set2.set(3, v1);         Assert.assertEquals(Dfp25.of(1), v_set2.getEntry(3));         Assert.assertEquals(Dfp25.of(7), v_set2.getEntry(6));         try {             v_set2.set(7, v1);             Assert.fail("OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected behavior         }          ArrayFieldVector<Dfp> v_set3 = (ArrayFieldVector<Dfp>) v1.copy();         v_set3.set(Dfp25.of(13));         Assert.assertEquals(Dfp25.of(13), v_set3.getEntry(2));          try {             v_set3.getEntry(23);             Assert.fail("ArrayIndexOutOfBoundsException expected");         } catch (ArrayIndexOutOfBoundsException ex) {             // expected behavior         }          ArrayFieldVector<Dfp> v_set4 = (ArrayFieldVector<Dfp>) v4.copy();         v_set4.setSubVector(3, v2_t);         Assert.assertEquals(Dfp25.of(4), v_set4.getEntry(3));         Assert.assertEquals(Dfp25.of(7), v_set4.getEntry(6));         try {             v_set4.setSubVector(7, v2_t);             Assert.fail("OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected behavior         }           ArrayFieldVector<Dfp> vout10 = (ArrayFieldVector<Dfp>) v1.copy();         ArrayFieldVector<Dfp> vout10_2 = (ArrayFieldVector<Dfp>) v1.copy();         Assert.assertEquals(vout10, vout10_2);         vout10_2.setEntry(0, Dfp25.of(11, 10));         Assert.assertNotSame(vout10, vout10_2);      }      @Test     public void testMapFunctions() {         ArrayFieldVector<Dfp> v1 = new ArrayFieldVector<>(vec1);          //octave =  v1 .+ 2.0         FieldVector<Dfp> v_mapAdd = v1.mapAdd(Dfp25.of(2));         Dfp[] result_mapAdd = {Dfp25.of(3), Dfp25.of(4), Dfp25.of(5)};         checkArray("compare vectors" ,result_mapAdd,v_mapAdd.toArray());          //octave =  v1 .+ 2.0         FieldVector<Dfp> v_mapAddToSelf = v1.copy();         v_mapAddToSelf.mapAddToSelf(Dfp25.of(2));         Dfp[] result_mapAddToSelf = {Dfp25.of(3), Dfp25.of(4), Dfp25.of(5)};         checkArray("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.toArray());          //octave =  v1 .- 2.0         FieldVector<Dfp> v_mapSubtract = v1.mapSubtract(Dfp25.of(2));         Dfp[] result_mapSubtract = {Dfp25.of(-1), Dfp25.ZERO, Dfp25.of(1)};         checkArray("compare vectors" ,result_mapSubtract,v_mapSubtract.toArray());          //octave =  v1 .- 2.0         FieldVector<Dfp> v_mapSubtractToSelf = v1.copy();         v_mapSubtractToSelf.mapSubtractToSelf(Dfp25.of(2));         Dfp[] result_mapSubtractToSelf = {Dfp25.of(-1), Dfp25.ZERO, Dfp25.of(1)};         checkArray("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.toArray());          //octave =  v1 .* 2.0         FieldVector<Dfp> v_mapMultiply = v1.mapMultiply(Dfp25.of(2));         Dfp[] result_mapMultiply = {Dfp25.of(2), Dfp25.of(4), Dfp25.of(6)};         checkArray("compare vectors" ,result_mapMultiply,v_mapMultiply.toArray());          //octave =  v1 .* 2.0         FieldVector<Dfp> v_mapMultiplyToSelf = v1.copy();         v_mapMultiplyToSelf.mapMultiplyToSelf(Dfp25.of(2));         Dfp[] result_mapMultiplyToSelf = {Dfp25.of(2), Dfp25.of(4), Dfp25.of(6)};         checkArray("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.toArray());          //octave =  v1 ./ 2.0         FieldVector<Dfp> v_mapDivide = v1.mapDivide(Dfp25.of(2));         Dfp[] result_mapDivide = {Dfp25.of(1, 2), Dfp25.of(1), Dfp25.of(3, 2)};         checkArray("compare vectors" ,result_mapDivide,v_mapDivide.toArray());          //octave =  v1 ./ 2.0         FieldVector<Dfp> v_mapDivideToSelf = v1.copy();         v_mapDivideToSelf.mapDivideToSelf(Dfp25.of(2));         Dfp[] result_mapDivideToSelf = {Dfp25.of(1, 2), Dfp25.of(1), Dfp25.of(3, 2)};         checkArray("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.toArray());          //octave =  v1 .^-1         FieldVector<Dfp> v_mapInv = v1.mapInv();         Dfp[] result_mapInv = {Dfp25.of(1),Dfp25.of(1, 2),Dfp25.of(1, 3)};         checkArray("compare vectors" ,result_mapInv,v_mapInv.toArray());          //octave =  v1 .^-1         FieldVector<Dfp> v_mapInvToSelf = v1.copy();         v_mapInvToSelf.mapInvToSelf();         Dfp[] result_mapInvToSelf = {Dfp25.of(1),Dfp25.of(1, 2),Dfp25.of(1, 3)};         checkArray("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.toArray());      }      @Test     public void testBasicFunctions() {         ArrayFieldVector<Dfp> v1 = new ArrayFieldVector<>(vec1);         ArrayFieldVector<Dfp> v2 = new ArrayFieldVector<>(vec2);         new ArrayFieldVector<>(vec_null);          FieldVectorTestImpl<Dfp> v2_t = new FieldVectorTestImpl<>(vec2);          //octave =  v1 + v2         ArrayFieldVector<Dfp> v_add = v1.add(v2);         Dfp[] result_add = {Dfp25.of(5), Dfp25.of(7), Dfp25.of(9)};         checkArray("compare vect" ,v_add.toArray(),result_add);          FieldVectorTestImpl<Dfp> vt2 = new FieldVectorTestImpl<>(vec2);         FieldVector<Dfp> v_add_i = v1.add(vt2);         Dfp[] result_add_i = {Dfp25.of(5), Dfp25.of(7), Dfp25.of(9)};         checkArray("compare vect" ,v_add_i.toArray(),result_add_i);          //octave =  v1 - v2         ArrayFieldVector<Dfp> v_subtract = v1.subtract(v2);         Dfp[] result_subtract = {Dfp25.of(-3), Dfp25.of(-3), Dfp25.of(-3)};         checkArray("compare vect" ,v_subtract.toArray(),result_subtract);          FieldVector<Dfp> v_subtract_i = v1.subtract(vt2);         Dfp[] result_subtract_i = {Dfp25.of(-3), Dfp25.of(-3), Dfp25.of(-3)};         checkArray("compare vect" ,v_subtract_i.toArray(),result_subtract_i);          // octave v1 .* v2         ArrayFieldVector<Dfp>  v_ebeMultiply = v1.ebeMultiply(v2);         Dfp[] result_ebeMultiply = {Dfp25.of(4), Dfp25.of(10), Dfp25.of(18)};         checkArray("compare vect" ,v_ebeMultiply.toArray(),result_ebeMultiply);          FieldVector<Dfp>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);         Dfp[] result_ebeMultiply_2 = {Dfp25.of(4), Dfp25.of(10), Dfp25.of(18)};         checkArray("compare vect" ,v_ebeMultiply_2.toArray(),result_ebeMultiply_2);          // octave v1 ./ v2         ArrayFieldVector<Dfp>  v_ebeDivide = v1.ebeDivide(v2);         Dfp[] result_ebeDivide = {Dfp25.of(1, 4), Dfp25.of(2, 5), Dfp25.of(1, 2)};         checkArray("compare vect" ,v_ebeDivide.toArray(),result_ebeDivide);          FieldVector<Dfp>  v_ebeDivide_2 = v1.ebeDivide(v2_t);         Dfp[] result_ebeDivide_2 = {Dfp25.of(1, 4), Dfp25.of(2, 5), Dfp25.of(1, 2)};         checkArray("compare vect" ,v_ebeDivide_2.toArray(),result_ebeDivide_2);          // octave  dot(v1,v2)         Dfp dot =  v1.dotProduct(v2);         Assert.assertEquals("compare val ",Dfp25.of(32), dot);          // octave  dot(v1,v2_t)         Dfp dot_2 =  v1.dotProduct(v2_t);         Assert.assertEquals("compare val ",Dfp25.of(32), dot_2);          FieldMatrix<Dfp> m_outerProduct = v1.outerProduct(v2);         Assert.assertEquals("compare val ",Dfp25.of(4), m_outerProduct.getEntry(0,0));          FieldMatrix<Dfp> m_outerProduct_2 = v1.outerProduct(v2_t);         Assert.assertEquals("compare val ",Dfp25.of(4), m_outerProduct_2.getEntry(0,0));          ArrayFieldVector<Dfp> v_projection = v1.projection(v2);         Dfp[] result_projection = {Dfp25.of(128, 77), Dfp25.of(160, 77), Dfp25.of(192, 77)};         checkArray("compare vect", v_projection.toArray(), result_projection);          FieldVector<Dfp> v_projection_2 = v1.projection(v2_t);         Dfp[] result_projection_2 = {Dfp25.of(128, 77), Dfp25.of(160, 77), Dfp25.of(192, 77)};         checkArray("compare vect", v_projection_2.toArray(), result_projection_2);      }      @Test     public void testMisc() {         ArrayFieldVector<Dfp> v1 = new ArrayFieldVector<>(vec1);         ArrayFieldVector<Dfp> v4 = new ArrayFieldVector<>(vec4);         FieldVector<Dfp> v4_2 = new ArrayFieldVector<>(vec4);          String out1 = v1.toString();         Assert.assertTrue("some output ",  out1.length()!=0);         /*          Dfp[] dout1 = v1.copyOut();         Assert.assertEquals(3, dout1.length);         assertNotSame("testData not same object ", v1.getDataRef(), dout1);          */         try {             v1.checkVectorDimensions(2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }         try {             v1.checkVectorDimensions(v4);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }          try {             v1.checkVectorDimensions(v4_2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }      }      @Test     public void testSerial()  {         final int n = 2;         ArrayFieldVector<BigReal> v = new ArrayFieldVector<>(BigRealField.getInstance());         for (int i = 0; i < n; i++) {             v.append(new BigReal(Math.random()));         }         Assert.assertEquals(v, TestUtils.serializeAndRecover(v));     }      @Test     public void testZeroVectors() {          // when the field is not specified, array cannot be empty         try {             new ArrayFieldVector<>(new Dfp[0]);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }         try {             new ArrayFieldVector<>(new Dfp[0], true);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }         try {             new ArrayFieldVector<>(new Dfp[0], false);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }          // when the field is specified, array can be empty         Assert.assertEquals(0, new ArrayFieldVector<>(Dfp25.getField(), new Dfp[0]).getDimension());         Assert.assertEquals(0, new ArrayFieldVector<>(Dfp25.getField(), new Dfp[0], true).getDimension());         Assert.assertEquals(0, new ArrayFieldVector<>(Dfp25.getField(), new Dfp[0], false).getDimension());      }      @Test     public void testOuterProduct() {         final ArrayFieldVector<Dfp> u             = new ArrayFieldVector<>(Dfp25.getField(),                                              new Dfp[] {Dfp25.of(1),                                                              Dfp25.of(2),                                                              Dfp25.of(-3)});         final ArrayFieldVector<Dfp> v             = new ArrayFieldVector<>(Dfp25.getField(),                                              new Dfp[] {Dfp25.of(4),                                                              Dfp25.of(-2)});          final FieldMatrix<Dfp> uv = u.outerProduct(v);          final double tol = Math.ulp(1d);         Assert.assertEquals(Dfp25.of(4).toDouble(), uv.getEntry(0, 0).toDouble(), tol);         Assert.assertEquals(Dfp25.of(-2).toDouble(), uv.getEntry(0, 1).toDouble(), tol);         Assert.assertEquals(Dfp25.of(8).toDouble(), uv.getEntry(1, 0).toDouble(), tol);         Assert.assertEquals(Dfp25.of(-4).toDouble(), uv.getEntry(1, 1).toDouble(), tol);         Assert.assertEquals(Dfp25.of(-12).toDouble(), uv.getEntry(2, 0).toDouble(), tol);         Assert.assertEquals(Dfp25.of(6).toDouble(), uv.getEntry(2, 1).toDouble(), tol);     }      /** verifies that two vectors are equals */     protected void checkArray(String msg, Dfp[] m, Dfp[] n) {         if (m.length != n.length) {             Assert.fail("vectors have different lengths");         }         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);         }     }      /*      * TESTS OF THE VISITOR PATTERN      */      /** The whole vector is visited. */     @Test     public void testWalkInDefaultOrderPreservingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              private int expectedIndex;              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 expectedIndex = 0;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor);     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInDefaultOrderPreservingVisitor2() {         final ArrayFieldVector<Dfp> v = create(5);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              @Override             public void visit(int index, Dfp value) {                 // Do nothing             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInDefaultOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInDefaultOrderPreservingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              private int expectedIndex;              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 expectedIndex = expectedStart;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);     }      /** The whole vector is visited. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 visited[actualIndex] = true;                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 Arrays.fill(visited, false);             }              @Override             public Dfp end() {                 for (int i = 0; i < data.length; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor);     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor2() {         final ArrayFieldVector<Dfp> v = create(5);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              @Override             public void visit(int index, Dfp value) {                 // Do nothing             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInOptimizedOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 visited[actualIndex] = true;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 Arrays.fill(visited, true);             }              @Override             public Dfp end() {                 for (int i = expectedStart; i <= expectedEnd; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);     }      /** The whole vector is visited. */     @Test     public void testWalkInDefaultOrderChangingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              private int expectedIndex;              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 expectedIndex = 0;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor);         for (int i = 0; i < data.length; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInDefaultOrderChangingVisitor2() {         final ArrayFieldVector<Dfp> v = create(5);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              @Override             public Dfp visit(int index, Dfp value) {                 return Dfp25.ZERO;             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInDefaultOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInDefaultOrderChangingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              private int expectedIndex;              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 expectedIndex = expectedStart;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);         for (int i = expectedStart; i <= expectedEnd; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      /** The whole vector is visited. */     @Test     public void testWalkInOptimizedOrderChangingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 visited[actualIndex] = true;                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 Arrays.fill(visited, false);             }              @Override             public Dfp end() {                 for (int i = 0; i < data.length; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor);         for (int i = 0; i < data.length; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInOptimizedOrderChangingVisitor2() {         final ArrayFieldVector<Dfp> v = create(5);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              @Override             public Dfp visit(int index, Dfp value) {                 return Dfp25.ZERO;             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInOptimizedOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInOptimizedOrderChangingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final ArrayFieldVector<Dfp> v = new ArrayFieldVector<>(data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 visited[actualIndex] = true;                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 Arrays.fill(visited, true);             }              @Override             public Dfp end() {                 for (int i = expectedStart; i <= expectedEnd; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);         for (int i = expectedStart; i <= expectedEnd; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      private ArrayFieldVector<Dfp> create(int n) {         Dfp[] t = new Dfp[n];         for (int i = 0; i < n; ++i) {             t[i] = Dfp25.ZERO;         }         return new ArrayFieldVector<>(t);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.Field; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.dfp.Dfp;  /**  * Test cases for the {@link SparseFieldMatrix} class.  *  */ public class SparseFieldMatrixTest {     // 3 x 3 identity matrix     protected Dfp[][] id = { {Dfp25.of(1), Dfp25.of(0), Dfp25.of(0) }, { Dfp25.of(0), Dfp25.of(1), Dfp25.of(0) }, { Dfp25.of(0), Dfp25.of(0), Dfp25.of(1) } };     // Test data for group operations     protected Dfp[][] testData = { { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) }, { Dfp25.of(2), Dfp25.of(5), Dfp25.of(3) },             { Dfp25.of(1), Dfp25.of(0), Dfp25.of(8) } };     protected Dfp[][] testDataLU = null;     protected Dfp[][] testDataPlus2 = { { Dfp25.of(3), Dfp25.of(4), Dfp25.of(5) }, { Dfp25.of(4), Dfp25.of(7), Dfp25.of(5) },             { Dfp25.of(3), Dfp25.of(2), Dfp25.of(10) } };     protected Dfp[][] testDataMinus = { { Dfp25.of(-1), Dfp25.of(-2), Dfp25.of(-3) },             { Dfp25.of(-2), Dfp25.of(-5), Dfp25.of(-3) }, { Dfp25.of(-1), Dfp25.of(0), Dfp25.of(-8) } };     protected Dfp[] testDataRow1 = { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) };     protected Dfp[] testDataCol3 = { Dfp25.of(3), Dfp25.of(3), Dfp25.of(8) };     protected Dfp[][] testDataInv = { { Dfp25.of(-40), Dfp25.of(16), Dfp25.of(9) }, { Dfp25.of(13), Dfp25.of(-5), Dfp25.of(-3) },             { Dfp25.of(5), Dfp25.of(-2), Dfp25.of(-1) } };     protected Dfp[] preMultTest = { Dfp25.of(8), Dfp25.of(12), Dfp25.of(33) };     protected Dfp[][] testData2 = { { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) }, { Dfp25.of(2), Dfp25.of(5), Dfp25.of(3) } };     protected Dfp[][] testData2T = { { Dfp25.of(1), Dfp25.of(2) }, { Dfp25.of(2), Dfp25.of(5) }, { Dfp25.of(3), Dfp25.of(3) } };     protected Dfp[][] testDataPlusInv = { { Dfp25.of(-39), Dfp25.of(18), Dfp25.of(12) },             { Dfp25.of(15), Dfp25.of(0), Dfp25.of(0) }, { Dfp25.of(6), Dfp25.of(-2), Dfp25.of(7) } };      // lu decomposition tests     protected Dfp[][] luData = { { Dfp25.of(2), Dfp25.of(3), Dfp25.of(3) }, { Dfp25.of(0), Dfp25.of(5), Dfp25.of(7) }, { Dfp25.of(6), Dfp25.of(9), Dfp25.of(8) } };     protected Dfp[][] luDataLUDecomposition = null;      // singular matrices     protected Dfp[][] singular = { { Dfp25.of(2), Dfp25.of(3) }, { Dfp25.of(2), Dfp25.of(3) } };     protected Dfp[][] bigSingular = { { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) },             { Dfp25.of(2), Dfp25.of(5), Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(7), Dfp25.of(3), Dfp25.of(256), Dfp25.of(1930) }, { Dfp25.of(3), Dfp25.of(7), Dfp25.of(6), Dfp25.of(8) } }; // 4th      // row     // =     // 1st     // +     // 2nd     protected Dfp[][] detData = { { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) }, { Dfp25.of(4), Dfp25.of(5), Dfp25.of(6) },             { Dfp25.of(7), Dfp25.of(8), Dfp25.of(10) } };     protected Dfp[][] detData2 = { { Dfp25.of(1), Dfp25.of(3) }, { Dfp25.of(2), Dfp25.of(4) } };      // vectors     protected Dfp[] testVector = { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) };     protected Dfp[] testVector2 = { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) };      // submatrix accessor tests     protected Dfp[][] subTestData = null;      // array selections     protected Dfp[][] subRows02Cols13 = { {Dfp25.of(2), Dfp25.of(4) }, { Dfp25.of(4), Dfp25.of(8) } };     protected Dfp[][] subRows03Cols12 = { { Dfp25.of(2), Dfp25.of(3) }, { Dfp25.of(5), Dfp25.of(6) } };     protected Dfp[][] subRows03Cols123 = { { Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(5), Dfp25.of(6), Dfp25.of(7) } };      // effective permutations     protected Dfp[][] subRows20Cols123 = { { Dfp25.of(4), Dfp25.of(6), Dfp25.of(8) }, { Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) } };     protected Dfp[][] subRows31Cols31 = null;      // contiguous ranges     protected Dfp[][] subRows01Cols23 = null;     protected Dfp[][] subRows23Cols00 = { { Dfp25.of(2) }, { Dfp25.of(4) } };     protected Dfp[][] subRows00Cols33 = { { Dfp25.of(4) } };      // row matrices     protected Dfp[][] subRow0 = { { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) } };     protected Dfp[][] subRow3 = { { Dfp25.of(4), Dfp25.of(5), Dfp25.of(6), Dfp25.of(7) } };      // column matrices     protected Dfp[][] subColumn1 = null;     protected Dfp[][] subColumn3 = null;      // tolerances     protected double entryTolerance = 10E-16;     protected double normTolerance = 10E-14;     protected Field<Dfp> field = Dfp25.getField();      public SparseFieldMatrixTest() {         testDataLU = new Dfp[][]{ { Dfp25.of(2), Dfp25.of(5), Dfp25.of(3) }, { Dfp25.of(.5d), Dfp25.of(-2.5d), Dfp25.of(6.5d) },                                   { Dfp25.of(0.5d), Dfp25.of(0.2d), Dfp25.of(.2d) } };         luDataLUDecomposition = new Dfp[][]{ { Dfp25.of(6), Dfp25.of(9), Dfp25.of(8) },                                              { Dfp25.of(0), Dfp25.of(5), Dfp25.of(7) }, { Dfp25.of(0.33333333333333), Dfp25.of(0), Dfp25.of(0.33333333333333) } };         subTestData = new Dfp[][]{ { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) },                                    { Dfp25.of(1.5), Dfp25.of(2.5), Dfp25.of(3.5), Dfp25.of(4.5) }, { Dfp25.of(2), Dfp25.of(4), Dfp25.of(6), Dfp25.of(8) }, { Dfp25.of(4), Dfp25.of(5), Dfp25.of(6), Dfp25.of(7) } };         subRows31Cols31 = new Dfp[][]{ { Dfp25.of(7), Dfp25.of(5) }, { Dfp25.of(4.5), Dfp25.of(2.5) } };         subRows01Cols23 = new Dfp[][]{ { Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(3.5), Dfp25.of(4.5) } };         subColumn1 = new Dfp[][]{ { Dfp25.of(2) }, { Dfp25.of(2.5) }, { Dfp25.of(4) }, { Dfp25.of(5) } };         subColumn3 = new Dfp[][]{ { Dfp25.of(4) }, { Dfp25.of(4.5) }, { Dfp25.of(8) }, { Dfp25.of(7) } };     }      /** test dimensions */     @Test     public void testDimensions() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         SparseFieldMatrix<Dfp> m2 = createSparseMatrix(testData2);         Assert.assertEquals("testData row dimension", 3, m.getRowDimension());         Assert.assertEquals("testData column dimension", 3, m.getColumnDimension());         Assert.assertTrue("testData is square", m.isSquare());         Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2);         Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);         Assert.assertTrue("testData2 is not square", !m2.isSquare());     }      /** test copy functions */     @Test     public void testCopyFunctions() {         SparseFieldMatrix<Dfp> m1 = createSparseMatrix(testData);         FieldMatrix<Dfp> m2 = m1.copy();         Assert.assertEquals(m1.getClass(), m2.getClass());         Assert.assertEquals((m2), m1);         SparseFieldMatrix<Dfp> m3 = createSparseMatrix(testData);         FieldMatrix<Dfp> m4 = m3.copy();         Assert.assertEquals(m3.getClass(), m4.getClass());         Assert.assertEquals((m4), m3);     }      /** test add */     @Test     public void testAdd() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         SparseFieldMatrix<Dfp> mInv = createSparseMatrix(testDataInv);         SparseFieldMatrix<Dfp> mDataPlusInv = createSparseMatrix(testDataPlusInv);         FieldMatrix<Dfp> mPlusMInv = m.add(mInv);         for (int row = 0; row < m.getRowDimension(); row++) {             for (int col = 0; col < m.getColumnDimension(); col++) {                 Assert.assertEquals("sum entry entry",                     mDataPlusInv.getEntry(row, col).toDouble(), mPlusMInv.getEntry(row, col).toDouble(),                     entryTolerance);             }         }     }      /** test add failure */     @Test     public void testAddFail() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         SparseFieldMatrix<Dfp> m2 = createSparseMatrix(testData2);         try {             m.add(m2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }       /** test m-n = m + -n */     @Test     public void testPlusMinus() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         SparseFieldMatrix<Dfp> n = createSparseMatrix(testDataInv);         assertClose("m-n = m + -n", m.subtract(n),             n.scalarMultiply(Dfp25.of(-1)).add(m), entryTolerance);         try {             m.subtract(createSparseMatrix(testData2));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test multiply */     @Test     public void testMultiply() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         SparseFieldMatrix<Dfp> mInv = createSparseMatrix(testDataInv);         SparseFieldMatrix<Dfp> identity = createSparseMatrix(id);         SparseFieldMatrix<Dfp> m2 = createSparseMatrix(testData2);         assertClose("inverse multiply", m.multiply(mInv), identity,                 entryTolerance);         assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<>(Dfp25.getField(), testDataInv)), identity,                     entryTolerance);         assertClose("inverse multiply", mInv.multiply(m), identity,                 entryTolerance);         assertClose("identity multiply", m.multiply(identity), m,                 entryTolerance);         assertClose("identity multiply", identity.multiply(mInv), mInv,                 entryTolerance);         assertClose("identity multiply", m2.multiply(identity), m2,                 entryTolerance);         try {             m.multiply(createSparseMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      // Additional Test for Array2DRowRealMatrixTest.testMultiply      private Dfp[][] d3 = new Dfp[][] { { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(5), Dfp25.of(6), Dfp25.of(7), Dfp25.of(8) } };     private Dfp[][] d4 = new Dfp[][] { { Dfp25.of(1) }, { Dfp25.of(2) }, { Dfp25.of(3) }, { Dfp25.of(4) } };     private Dfp[][] d5 = new Dfp[][] { { Dfp25.of(30) }, { Dfp25.of(70) } };      @Test     public void testMultiply2() {         FieldMatrix<Dfp> m3 = createSparseMatrix(d3);         FieldMatrix<Dfp> m4 = createSparseMatrix(d4);         FieldMatrix<Dfp> m5 = createSparseMatrix(d5);         assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);     }      /** test trace */     @Test     public void testTrace() {         FieldMatrix<Dfp> m = createSparseMatrix(id);         Assert.assertEquals("identity trace", 3d, m.getTrace().toDouble(), entryTolerance);         m = createSparseMatrix(testData2);         try {             m.getTrace();             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }     }      /** test scalarAdd */     @Test     public void testScalarAdd() {         FieldMatrix<Dfp> m = createSparseMatrix(testData);         assertClose("scalar add", createSparseMatrix(testDataPlus2),             m.scalarAdd(Dfp25.of(2)), entryTolerance);     }      /** test operate */     @Test     public void testOperate() {         FieldMatrix<Dfp> m = createSparseMatrix(id);         assertClose("identity operate", testVector, m.operate(testVector),                 entryTolerance);         assertClose("identity operate", testVector, m.operate(                 new ArrayFieldVector<>(testVector)).toArray(), entryTolerance);         m = createSparseMatrix(bigSingular);         try {             m.operate(testVector);             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test issue MATH-209 */     @Test     public void testMath209() {         FieldMatrix<Dfp> a = createSparseMatrix(new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(2) }, { Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(5), Dfp25.of(6) } });         Dfp[] b = a.operate(new Dfp[] { Dfp25.of(1), Dfp25.of(1) });         Assert.assertEquals(a.getRowDimension(), b.length);         Assert.assertEquals(3.0, b[0].toDouble(), 1.0e-12);         Assert.assertEquals(7.0, b[1].toDouble(), 1.0e-12);         Assert.assertEquals(11.0, b[2].toDouble(), 1.0e-12);     }      /** test transpose */     @Test     public void testTranspose() {         FieldMatrix<Dfp> m = createSparseMatrix(testData);         FieldMatrix<Dfp> mIT = new FieldLUDecomposition<>(m).getSolver().getInverse().transpose();         FieldMatrix<Dfp> mTI = new FieldLUDecomposition<>(m.transpose()).getSolver().getInverse();         assertClose("inverse-transpose", mIT, mTI, normTolerance);         m = createSparseMatrix(testData2);         FieldMatrix<Dfp> mt = createSparseMatrix(testData2T);         assertClose("transpose",mt,m.transpose(),normTolerance);     }      /** test preMultiply by vector */     @Test     public void testPremultiplyVector() {         FieldMatrix<Dfp> m = createSparseMatrix(testData);         assertClose("premultiply", m.preMultiply(testVector), preMultTest,             normTolerance);         assertClose("premultiply", m.preMultiply(             new ArrayFieldVector<>(testVector).toArray()), preMultTest, normTolerance);         m = createSparseMatrix(bigSingular);         try {             m.preMultiply(testVector);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testPremultiply() {         FieldMatrix<Dfp> m3 = createSparseMatrix(d3);         FieldMatrix<Dfp> m4 = createSparseMatrix(d4);         FieldMatrix<Dfp> m5 = createSparseMatrix(d5);         assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);          SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         SparseFieldMatrix<Dfp> mInv = createSparseMatrix(testDataInv);         SparseFieldMatrix<Dfp> identity = createSparseMatrix(id);         assertClose("inverse multiply", m.preMultiply(mInv), identity,                 entryTolerance);         assertClose("inverse multiply", mInv.preMultiply(m), identity,                 entryTolerance);         assertClose("identity multiply", m.preMultiply(identity), m,                 entryTolerance);         assertClose("identity multiply", identity.preMultiply(mInv), mInv,                 entryTolerance);         try {             m.preMultiply(createSparseMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testGetVectors() {         FieldMatrix<Dfp> m = createSparseMatrix(testData);         assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);         assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);         try {             m.getRow(10);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }         try {             m.getColumn(-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }     }      @Test     public void testGetEntry() {         FieldMatrix<Dfp> m = createSparseMatrix(testData);         Assert.assertEquals("get entry", m.getEntry(0, 1).toDouble(), 2d, entryTolerance);         try {             m.getEntry(10, 4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      /** test examples in user guide */     @Test     public void testExamples() {         // Create a real matrix with two rows and three columns         Dfp[][] matrixData = { { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) }, { Dfp25.of(2), Dfp25.of(5), Dfp25.of(3) } };         FieldMatrix<Dfp> m = createSparseMatrix(matrixData);         // One more with three rows, two columns         Dfp[][] matrixData2 = { { Dfp25.of(1), Dfp25.of(2) }, { Dfp25.of(2), Dfp25.of(5) }, { Dfp25.of(1), Dfp25.of(7) } };         FieldMatrix<Dfp> n = createSparseMatrix(matrixData2);         // Now multiply m by n         FieldMatrix<Dfp> p = m.multiply(n);         Assert.assertEquals(2, p.getRowDimension());         Assert.assertEquals(2, p.getColumnDimension());         // Invert p         FieldMatrix<Dfp> pInverse = new FieldLUDecomposition<>(p).getSolver().getInverse();         Assert.assertEquals(2, pInverse.getRowDimension());         Assert.assertEquals(2, pInverse.getColumnDimension());          // Solve example         Dfp[][] coefficientsData = { { Dfp25.of(2), Dfp25.of(3), Dfp25.of(-2) }, { Dfp25.of(-1), Dfp25.of(7), Dfp25.of(6) },                 { Dfp25.of(4), Dfp25.of(-3), Dfp25.of(-5) } };         FieldMatrix<Dfp> coefficients = createSparseMatrix(coefficientsData);         Dfp[] constants = { Dfp25.of(1), Dfp25.of(-2), Dfp25.of(1) };         Dfp[] solution;         solution = new FieldLUDecomposition<>(coefficients)             .getSolver()             .solve(new ArrayFieldVector<>(constants, false)).toArray();         Assert.assertEquals((Dfp25.of(2).multiply((solution[0])).add(Dfp25.of(3).multiply(solution[1])).subtract(Dfp25.of(2).multiply(solution[2]))).toDouble(),                 constants[0].toDouble(), 1E-12);         Assert.assertEquals(((Dfp25.of(-1).multiply(solution[0])).add(Dfp25.of(7).multiply(solution[1])).add(Dfp25.of(6).multiply(solution[2]))).toDouble(),                 constants[1].toDouble(), 1E-12);         Assert.assertEquals(((Dfp25.of(4).multiply(solution[0])).subtract(Dfp25.of(3).multiply( solution[1])).subtract(Dfp25.of(5).multiply(solution[2]))).toDouble(),                 constants[2].toDouble(), 1E-12);      }      // test submatrix accessors     @Test     public void testSubMatrix() {         FieldMatrix<Dfp> m = createSparseMatrix(subTestData);         FieldMatrix<Dfp> mRows23Cols00 = createSparseMatrix(subRows23Cols00);         FieldMatrix<Dfp> mRows00Cols33 = createSparseMatrix(subRows00Cols33);         FieldMatrix<Dfp> mRows01Cols23 = createSparseMatrix(subRows01Cols23);         FieldMatrix<Dfp> mRows02Cols13 = createSparseMatrix(subRows02Cols13);         FieldMatrix<Dfp> mRows03Cols12 = createSparseMatrix(subRows03Cols12);         FieldMatrix<Dfp> mRows03Cols123 = createSparseMatrix(subRows03Cols123);         FieldMatrix<Dfp> mRows20Cols123 = createSparseMatrix(subRows20Cols123);         FieldMatrix<Dfp> mRows31Cols31 = createSparseMatrix(subRows31Cols31);         Assert.assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));         Assert.assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));         Assert.assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));         Assert.assertEquals("Rows02Cols13", mRows02Cols13,             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));         Assert.assertEquals("Rows03Cols12", mRows03Cols12,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));         Assert.assertEquals("Rows03Cols123", mRows03Cols123,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));         Assert.assertEquals("Rows20Cols123", mRows20Cols123,             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));         Assert.assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));         Assert.assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));          try {             m.getSubMatrix(1, 0, 2, 4);             Assert.fail("Expecting NumberIsTooSmallException");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             m.getSubMatrix(-1, 1, 2, 2);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getSubMatrix(1, 0, 2, 2);             Assert.fail("Expecting NumberIsTooSmallException");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             m.getSubMatrix(1, 0, 2, 4);             Assert.fail("Expecting NumberIsTooSmallException");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             m.getSubMatrix(new int[] {}, new int[] { 0 });             Assert.fail("Expecting NoDataException");         } catch (NoDataException ex) {             // expected         }         try {             m.getSubMatrix(new int[] { 0 }, new int[] { 4 });             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetRowMatrix() {         FieldMatrix<Dfp> m = createSparseMatrix(subTestData);         FieldMatrix<Dfp> mRow0 = createSparseMatrix(subRow0);         FieldMatrix<Dfp> mRow3 = createSparseMatrix(subRow3);         Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));         Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));         try {             m.getRowMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetColumnMatrix() {         FieldMatrix<Dfp> m = createSparseMatrix(subTestData);         FieldMatrix<Dfp> mColumn1 = createSparseMatrix(subColumn1);         FieldMatrix<Dfp> mColumn3 = createSparseMatrix(subColumn3);         Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1));         Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3));         try {             m.getColumnMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetRowVector() {         FieldMatrix<Dfp> m = createSparseMatrix(subTestData);         FieldVector<Dfp> mRow0 = new ArrayFieldVector<>(subRow0[0]);         FieldVector<Dfp> mRow3 = new ArrayFieldVector<>(subRow3[0]);         Assert.assertEquals("Row0", mRow0, m.getRowVector(0));         Assert.assertEquals("Row3", mRow3, m.getRowVector(3));         try {             m.getRowVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetColumnVector() {         FieldMatrix<Dfp> m = createSparseMatrix(subTestData);         FieldVector<Dfp> mColumn1 = columnToVector(subColumn1);         FieldVector<Dfp> mColumn3 = columnToVector(subColumn3);         Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));         Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));         try {             m.getColumnVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      private FieldVector<Dfp> columnToVector(Dfp[][] column) {         Dfp[] data = new Dfp[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return new ArrayFieldVector<>(data, false);     }      @Test     public void testEqualsAndHashCode() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         SparseFieldMatrix<Dfp> m1 = (SparseFieldMatrix<Dfp>) m.copy();         SparseFieldMatrix<Dfp> mt = (SparseFieldMatrix<Dfp>) m.transpose();         Assert.assertTrue(m.hashCode() != mt.hashCode());         Assert.assertEquals(m.hashCode(), m1.hashCode());         Assert.assertEquals(m, m);         Assert.assertEquals(m, m1);         Assert.assertFalse(m.equals(null));         Assert.assertFalse(m.equals(mt));         Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));     }      /* Disable for now     @Test     public void testToString() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         Assert.assertEquals("SparseFieldMatrix<Dfp>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",             m.toString());         m = new SparseFieldMatrix<Dfp>(field, 1, 1);         Assert.assertEquals("SparseFieldMatrix<Dfp>{{0.0}}", m.toString());     }     */      @Test     public void testSetSubMatrix() {         SparseFieldMatrix<Dfp> m = createSparseMatrix(testData);         m.setSubMatrix(detData2, 1, 1);         FieldMatrix<Dfp> expected = createSparseMatrix(new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) }, { Dfp25.of(2), Dfp25.of(1), Dfp25.of(3) }, { Dfp25.of(1), Dfp25.of(2), Dfp25.of(4) } });         Assert.assertEquals(expected, m);          m.setSubMatrix(detData2, 0, 0);         expected = createSparseMatrix(new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(3), Dfp25.of(3) }, { Dfp25.of(2), Dfp25.of(4), Dfp25.of(3) }, { Dfp25.of(1), Dfp25.of(2), Dfp25.of(4) } });         Assert.assertEquals(expected, m);          m.setSubMatrix(testDataPlus2, 0, 0);         expected = createSparseMatrix(new Dfp[][] {                 { Dfp25.of(3), Dfp25.of(4), Dfp25.of(5) }, { Dfp25.of(4), Dfp25.of(7), Dfp25.of(5) }, { Dfp25.of(3), Dfp25.of(2), Dfp25.of(10) } });         Assert.assertEquals(expected, m);          // javadoc example         SparseFieldMatrix<Dfp> matrix =             createSparseMatrix(new Dfp[][] {         { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(5), Dfp25.of(6), Dfp25.of(7), Dfp25.of(8) }, { Dfp25.of(9), Dfp25.of(0), Dfp25.of(1), Dfp25.of(2) } });         matrix.setSubMatrix(new Dfp[][] { { Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(5), Dfp25.of(6) } }, 1, 1);         expected = createSparseMatrix(new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4) }, { Dfp25.of(5), Dfp25.of(3), Dfp25.of(4), Dfp25.of(8) }, { Dfp25.of(9), Dfp25.of(5), Dfp25.of(6), Dfp25.of(2) } });         Assert.assertEquals(expected, matrix);          // dimension overflow         try {             m.setSubMatrix(testData, 1, 1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         // dimension underflow         try {             m.setSubMatrix(testData, -1, 1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         try {             m.setSubMatrix(testData, 1, -1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }          // null         try {             m.setSubMatrix(null, 1, 1);             Assert.fail("expecting NullArgumentException");         } catch (NullArgumentException e) {             // expected         }         try {             new SparseFieldMatrix<>(field, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // ragged         try {             m.setSubMatrix(new Dfp[][] { { Dfp25.of(1) }, { Dfp25.of(2), Dfp25.of(3) } }, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // empty         try {             m.setSubMatrix(new Dfp[][] { {} }, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }     }      // --------------- -----------------Protected methods      /** verifies that two matrices are close (1-norm) */     protected void assertClose(String msg, FieldMatrix<Dfp> m, FieldMatrix<Dfp> n,             double tolerance) {         for(int i=0; i < m.getRowDimension(); i++){             for(int j=0; j < m.getColumnDimension(); j++){                 Assert.assertEquals(msg, m.getEntry(i,j).toDouble(), n.getEntry(i,j).toDouble(), tolerance);             }          }     }      /** verifies that two vectors are close (sup norm) */     protected void assertClose(String msg, Dfp[] m, Dfp[] n,             double tolerance) {         if (m.length != n.length) {             Assert.fail("vectors not same length");         }         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(msg + " " + i + " elements differ", m[i].toDouble(), n[i].toDouble(),                     tolerance);         }     }      private SparseFieldMatrix<Dfp> createSparseMatrix(Dfp[][] data) {         SparseFieldMatrix<Dfp> matrix = new SparseFieldMatrix<>(field, data.length, data[0].length);         for (int row = 0; row < data.length; row++) {             for (int col = 0; col < data[row].length; col++) {                 matrix.setEntry(row, col, data[row][col]);             }         }         return matrix;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.dfp.Dfp; import org.junit.Assert; import org.junit.Test;  public class FieldLUSolverTest {     private int[][] testData = {             { 1, 2, 3},             { 2, 5, 3},             { 1, 0, 8}     };     private int[][] luData = {             { 2, 3, 3 },             { 0, 5, 7 },             { 6, 9, 8 }     };      // singular matrices     private int[][] singular = {             { 2, 3 },             { 2, 3 }     };     private int[][] bigSingular = {             { 1, 2,   3,    4 },             { 2, 5,   3,    4 },             { 7, 3, 256, 1930 },             { 3, 7,   6,    8 }     }; // 4th row = 1st + 2nd      public static FieldMatrix<Dfp> createDfpMatrix(final int[][] data) {         final int numRows = data.length;         final int numCols = data[0].length;         final Array2DRowFieldMatrix<Dfp> m;         m = new Array2DRowFieldMatrix<>(Dfp25.getField(),                                                 numRows, numCols);         for (int i = 0; i < numRows; i++) {             for (int j = 0; j < numCols; j++) {                 m.setEntry(i, j, Dfp25.of(data[i][j], 1));             }         }         return m;     }      /** test singular */     @Test     public void testSingular() {         FieldDecompositionSolver<Dfp> solver;         solver = new FieldLUDecomposition<>(createDfpMatrix(testData))             .getSolver();         Assert.assertTrue(solver.isNonSingular());         solver = new FieldLUDecomposition<>(createDfpMatrix(singular))             .getSolver();         Assert.assertFalse(solver.isNonSingular());         solver = new FieldLUDecomposition<>(createDfpMatrix(bigSingular))             .getSolver();         Assert.assertFalse(solver.isNonSingular());     }      /** test solve dimension errors */     @Test     public void testSolveDimensionErrors() {         FieldDecompositionSolver<Dfp> solver;         solver = new FieldLUDecomposition<>(createDfpMatrix(testData))             .getSolver();         FieldMatrix<Dfp> b = createDfpMatrix(new int[2][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }     }      /** test solve singularity errors */     @Test     public void testSolveSingularityErrors() {         FieldDecompositionSolver<Dfp> solver;         solver = new FieldLUDecomposition<>(createDfpMatrix(singular))             .getSolver();         FieldMatrix<Dfp> b = createDfpMatrix(new int[2][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException ime) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException ime) {             // expected behavior         }     }      /** test solve */     @Test     public void testSolve() {         FieldDecompositionSolver<Dfp> solver;         solver = new FieldLUDecomposition<>(createDfpMatrix(testData))             .getSolver();         FieldMatrix<Dfp> b = createDfpMatrix(new int[][] {                 { 1, 0 }, { 2, -5 }, { 3, 1 }         });         FieldMatrix<Dfp> xRef = createDfpMatrix(new int[][] {                 { 19, -71 }, { -6, 22 }, { -2, 9 }         });          // using FieldMatrix         FieldMatrix<Dfp> x = solver.solve(b);         for (int i = 0; i < x.getRowDimension(); i++){             for (int j = 0; j < x.getColumnDimension(); j++){                 Assert.assertEquals("(" + i + ", " + j + ")",                                     xRef.getEntry(i, j), x.getEntry(i, j));             }         }          // using ArrayFieldVector         for (int j = 0; j < b.getColumnDimension(); j++) {             final FieldVector<Dfp> xj = solver.solve(b.getColumnVector(j));             for (int i = 0; i < xj.getDimension(); i++){                 Assert.assertEquals("(" + i + ", " + j + ")",                                     xRef.getEntry(i, j), xj.getEntry(i));             }         }          // using SparseFieldVector         for (int j = 0; j < b.getColumnDimension(); j++) {             final SparseFieldVector<Dfp> bj;             bj = new SparseFieldVector<>(Dfp25.getField(),                                                  b.getColumn(j));             final FieldVector<Dfp> xj = solver.solve(bj);             for (int i = 0; i < xj.getDimension(); i++) {                 Assert.assertEquals("(" + i + ", " + j + ")",                                     xRef.getEntry(i, j), xj.getEntry(i));             }         }     }      /** test determinant */     @Test     public void testDeterminant() {         Assert.assertEquals( -1, getDeterminant(createDfpMatrix(testData)), 1E-15);         Assert.assertEquals(-10, getDeterminant(createDfpMatrix(luData)), 1E-14);         Assert.assertEquals(  0, getDeterminant(createDfpMatrix(singular)), 1E-15);         Assert.assertEquals(  0, getDeterminant(createDfpMatrix(bigSingular)), 1E-15);     }      private double getDeterminant(final FieldMatrix<Dfp> m) {         return new FieldLUDecomposition<>(m).getDeterminant().toDouble();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert;  public class RectangularCholeskyDecompositionTest {      @Test     public void testDecomposition3x3() {          RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {             { 1,   9,   9 },             { 9, 225, 225 },             { 9, 225, 625 }         });          RectangularCholeskyDecomposition d =                 new RectangularCholeskyDecomposition(m, 1.0e-6);          // as this decomposition permutes lines and columns, the root is NOT triangular         // (in fact here it is the lower right part of the matrix which is zero and         //  the upper left non-zero)         Assert.assertEquals(0.8,  d.getRootMatrix().getEntry(0, 2), 1.0e-15);         Assert.assertEquals(25.0, d.getRootMatrix().getEntry(2, 0), 1.0e-15);         Assert.assertEquals(0.0,  d.getRootMatrix().getEntry(2, 2), 1.0e-15);          RealMatrix root = d.getRootMatrix();         RealMatrix rebuiltM = root.multiply(root.transpose());         Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15);      }      @Test     public void testFullRank() {          RealMatrix base = MatrixUtils.createRealMatrix(new double[][] {             { 0.1159548705,      0.,           0.,           0.      },             { 0.0896442724, 0.1223540781,      0.,           0.      },             { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      },             { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 }         });          RealMatrix m = base.multiply(base.transpose());          RectangularCholeskyDecomposition d =                 new RectangularCholeskyDecomposition(m, 1.0e-10);          RealMatrix root = d.getRootMatrix();         RealMatrix rebuiltM = root.multiply(root.transpose());         Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15);          // the pivoted Cholesky decomposition is *not* unique. Here, the root is         // not equal to the original trianbular base matrix         Assert.assertTrue(root.subtract(base).getNorm() > 0.3);      }      @Test     public void testMath789() {          final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{             {0.013445532, 0.010394690, 0.009881156, 0.010499559},             {0.010394690, 0.023006616, 0.008196856, 0.010732709},             {0.009881156, 0.008196856, 0.019023866, 0.009210099},             {0.010499559, 0.010732709, 0.009210099, 0.019107243}         });         composeAndTest(m1, 4);          final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{             {0.0, 0.0, 0.0, 0.0, 0.0},             {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},             {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},             {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},             {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}         });         composeAndTest(m2, 4);          final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{             {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},             {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},             {0.0, 0.0, 0.0, 0.0, 0.0},             {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},             {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}         });         composeAndTest(m3, 4);      }      private void composeAndTest(RealMatrix m, int expectedRank) {         RectangularCholeskyDecomposition r = new RectangularCholeskyDecomposition(m);         Assert.assertEquals(expectedRank, r.getRank());         RealMatrix root = r.getRootMatrix();         RealMatrix rebuiltMatrix = root.multiply(root.transpose());         Assert.assertEquals(0.0, m.subtract(rebuiltMatrix).getNorm(), 1.0e-16);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Random;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Test; import org.junit.Assert;  public class RRQRSolverTest {     double[][] testData3x3NonSingular = {             { 12, -51,   4 },             {  6, 167, -68 },             { -4,  24, -41 }     };      double[][] testData3x3Singular = {             { 1, 2,  2 },             { 2, 4,  6 },             { 4, 8, 12 }     };      double[][] testData3x4 = {             { 12, -51,   4, 1 },             {  6, 167, -68, 2 },             { -4,  24, -41, 3 }     };      double[][] testData4x3 = {             { 12, -51,   4 },             {  6, 167, -68 },             { -4,  24, -41 },             { -5,  34,   7 }     };      /** test rank */     @Test     public void testRank() {         DecompositionSolver solver =             new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular), 1.0e-16).getSolver();         Assert.assertTrue(solver.isNonSingular());          solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 1.0e-16).getSolver();         Assert.assertFalse(solver.isNonSingular());          solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x4), 1.0e-16).getSolver();         Assert.assertTrue(solver.isNonSingular());          solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData4x3), 1.0e-16).getSolver();         Assert.assertTrue(solver.isNonSingular());      }      /** test solve dimension errors */     @Test     public void testSolveDimensionErrors() {         DecompositionSolver solver =             new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }      }      /** test solve rank errors */     @Test     public void testSolveRankErrors() {         DecompositionSolver solver =             new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 1.0e-16).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException iae) {             // expected behavior         }      }      /** test solve */     @Test     public void testSolve() {         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                 { -102, 12250 }, { 544, 24500 }, { 167, -36750 }         });         RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                 { 1, 2515 }, { 2, 422 }, { -3, 898 }         });           RRQRDecomposition decomposition = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));         DecompositionSolver solver = decomposition.getSolver();          // using RealMatrix         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 3.0e-16 * xRef.getNorm());          // using ArrayRealVector         for (int i = 0; i < b.getColumnDimension(); ++i) {             final RealVector x = solver.solve(b.getColumnVector(i));             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();             Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());         }          // using RealVector with an alternate implementation         for (int i = 0; i < b.getColumnDimension(); ++i) {             ArrayRealVectorTest.RealVectorTestImpl v =                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));             final RealVector x = solver.solve(v);             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();             Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());         }      }      @Test     public void testOverdetermined() {         final Random r    = new Random(5559252868205245l);         int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         RealMatrix   a    = createTestMatrix(r, p, q);         RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);          // build a perturbed system: A.X + noise = B         RealMatrix b = a.multiply(xRef);         final double noise = 0.001;         b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {             @Override             public double visit(int row, int column, double value) {                 return value * (1.0 + noise * (2 * r.nextDouble() - 1));             }         });          // despite perturbation, the least square solution should be pretty good         RealMatrix x = new RRQRDecomposition(a).getSolver().solve(b);         Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);      }      @Test     public void testUnderdetermined() {         final Random r    = new Random(42185006424567123l);         int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         RealMatrix   a    = createTestMatrix(r, p, q);         RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);         RealMatrix   b    = a.multiply(xRef);         RRQRDecomposition rrqrd = new RRQRDecomposition(a);         RealMatrix   x = rrqrd.getSolver().solve(b);          // too many equations, the system cannot be solved at all         Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);          // the last permuted unknown should have been set to 0         RealMatrix permuted = rrqrd.getP().transpose().multiply(x);         Assert.assertEquals(0.0, permuted.getSubMatrix(p, q - 1, 0, permuted.getColumnDimension() - 1).getNorm(), 0);      }      private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {         RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);         m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {                 @Override                     public double visit(int row, int column, double value) {                     return 2.0 * r.nextDouble() - 1.0;                 }             });         return m;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;   import java.util.Arrays;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.dfp.DfpField; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for the {@link SparseFieldVector} class.  *  */ public class SparseFieldVectorTest {      //     protected Dfp[][] ma1 = {{Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)}, {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6)}, {Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)}};     protected Dfp[] vec1 = {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)};     protected Dfp[] vec2 = {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6)};     protected Dfp[] vec3 = {Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)};     protected Dfp[] vec4 = {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4), Dfp25.of(5), Dfp25.of(6), Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)};     protected Dfp[] vec_null = {Dfp25.of(0), Dfp25.of(0), Dfp25.of(0)};     protected Dfp[] dvec1 = {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4), Dfp25.of(5), Dfp25.of(6), Dfp25.of(7), Dfp25.of(8),Dfp25.of(9)};     protected Dfp[][] mat1 = {{Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)}, {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6)},{ Dfp25.of(7), Dfp25.of(8), Dfp25.of(9)}};      // tolerances     protected double entryTolerance = 10E-16;     protected double normTolerance = 10E-14;      protected DfpField field = Dfp25.getField();      @Test     public void testMapFunctions() {         SparseFieldVector<Dfp> v1 = new SparseFieldVector<>(field,vec1);          //octave =  v1 .+ 2.0         FieldVector<Dfp> v_mapAdd = v1.mapAdd(Dfp25.of(2));         Dfp[] result_mapAdd = {Dfp25.of(3), Dfp25.of(4), Dfp25.of(5)};         Assert.assertArrayEquals("compare vectors" ,result_mapAdd,v_mapAdd.toArray());          //octave =  v1 .+ 2.0         FieldVector<Dfp> v_mapAddToSelf = v1.copy();         v_mapAddToSelf.mapAddToSelf(Dfp25.of(2));         Dfp[] result_mapAddToSelf = {Dfp25.of(3), Dfp25.of(4), Dfp25.of(5)};         Assert.assertArrayEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.toArray());          //octave =  v1 .- 2.0         FieldVector<Dfp> v_mapSubtract = v1.mapSubtract(Dfp25.of(2));         Dfp[] result_mapSubtract = {Dfp25.of(-1), Dfp25.of(0), Dfp25.of(1)};         Assert.assertArrayEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.toArray());          //octave =  v1 .- 2.0         FieldVector<Dfp> v_mapSubtractToSelf = v1.copy();         v_mapSubtractToSelf.mapSubtractToSelf(Dfp25.of(2));         Dfp[] result_mapSubtractToSelf = {Dfp25.of(-1), Dfp25.of(0), Dfp25.of(1)};         Assert.assertArrayEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.toArray());          //octave =  v1 .* 2.0         FieldVector<Dfp> v_mapMultiply = v1.mapMultiply(Dfp25.of(2));         Dfp[] result_mapMultiply = {Dfp25.of(2), Dfp25.of(4), Dfp25.of(6)};         Assert.assertArrayEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.toArray());          //octave =  v1 .* 2.0         FieldVector<Dfp> v_mapMultiplyToSelf = v1.copy();         v_mapMultiplyToSelf.mapMultiplyToSelf(Dfp25.of(2));         Dfp[] result_mapMultiplyToSelf = {Dfp25.of(2), Dfp25.of(4), Dfp25.of(6)};         Assert.assertArrayEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.toArray());          //octave =  v1 ./ 2.0         FieldVector<Dfp> v_mapDivide = v1.mapDivide(Dfp25.of(2));         Dfp[] result_mapDivide = {Dfp25.of(.5d), Dfp25.of(1), Dfp25.of(1.5d)};         Assert.assertArrayEquals("compare vectors" ,result_mapDivide,v_mapDivide.toArray());          //octave =  v1 ./ 2.0         FieldVector<Dfp> v_mapDivideToSelf = v1.copy();         v_mapDivideToSelf.mapDivideToSelf(Dfp25.of(2));         Dfp[] result_mapDivideToSelf = {Dfp25.of(.5d), Dfp25.of(1), Dfp25.of(1.5d)};         Assert.assertArrayEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.toArray());          //octave =  v1 .^-1         FieldVector<Dfp> v_mapInv = v1.mapInv();         Dfp[] result_mapInv = {Dfp25.of(1),Dfp25.of(0.5d),Dfp25.of(1, 3)};         Assert.assertArrayEquals("compare vectors" ,result_mapInv,v_mapInv.toArray());          //octave =  v1 .^-1         FieldVector<Dfp> v_mapInvToSelf = v1.copy();         v_mapInvToSelf.mapInvToSelf();         Dfp[] result_mapInvToSelf = {Dfp25.of(1),Dfp25.of(0.5d),Dfp25.of(1, 3)};         Assert.assertArrayEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.toArray());       }      @Test     public void testBasicFunctions() {         SparseFieldVector<Dfp> v1 = new SparseFieldVector<>(field,vec1);         SparseFieldVector<Dfp> v2 = new SparseFieldVector<>(field,vec2);          FieldVector<Dfp> v2_t = new ArrayFieldVectorTest.FieldVectorTestImpl<>(vec2);          //octave =  v1 + v2         FieldVector<Dfp> v_add = v1.add(v2);         Dfp[] result_add = {Dfp25.of(5), Dfp25.of(7), Dfp25.of(9)};         Assert.assertArrayEquals("compare vect" ,v_add.toArray(),result_add);          FieldVector<Dfp> vt2 = new ArrayFieldVectorTest.FieldVectorTestImpl<>(vec2);         FieldVector<Dfp> v_add_i = v1.add(vt2);         Dfp[] result_add_i = {Dfp25.of(5), Dfp25.of(7), Dfp25.of(9)};         Assert.assertArrayEquals("compare vect" ,v_add_i.toArray(),result_add_i);          //octave =  v1 - v2         SparseFieldVector<Dfp> v_subtract = v1.subtract(v2);         Dfp[] result_subtract = {Dfp25.of(-3), Dfp25.of(-3), Dfp25.of(-3)};         assertClose("compare vect" ,v_subtract.toArray(),result_subtract,normTolerance);          FieldVector<Dfp> v_subtract_i = v1.subtract(vt2);         Dfp[] result_subtract_i = {Dfp25.of(-3), Dfp25.of(-3), Dfp25.of(-3)};         assertClose("compare vect" ,v_subtract_i.toArray(),result_subtract_i,normTolerance);          // octave v1 .* v2         FieldVector<Dfp>  v_ebeMultiply = v1.ebeMultiply(v2);         Dfp[] result_ebeMultiply = {Dfp25.of(4), Dfp25.of(10), Dfp25.of(18)};         assertClose("compare vect" ,v_ebeMultiply.toArray(),result_ebeMultiply,normTolerance);          FieldVector<Dfp>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);         Dfp[] result_ebeMultiply_2 = {Dfp25.of(4), Dfp25.of(10), Dfp25.of(18)};         assertClose("compare vect" ,v_ebeMultiply_2.toArray(),result_ebeMultiply_2,normTolerance);          // octave v1 ./ v2         FieldVector<Dfp>  v_ebeDivide = v1.ebeDivide(v2);         Dfp[] result_ebeDivide = {Dfp25.of(0.25d), Dfp25.of(0.4d), Dfp25.of(0.5d)};         assertClose("compare vect" ,v_ebeDivide.toArray(),result_ebeDivide,normTolerance);          FieldVector<Dfp>  v_ebeDivide_2 = v1.ebeDivide(v2_t);         Dfp[] result_ebeDivide_2 = {Dfp25.of(0.25d), Dfp25.of(0.4d), Dfp25.of(0.5d)};         assertClose("compare vect" ,v_ebeDivide_2.toArray(),result_ebeDivide_2,normTolerance);          // octave  dot(v1,v2)         Dfp dot =  v1.dotProduct(v2);         Assert.assertEquals("compare val ",Dfp25.of(32), dot);          // octave  dot(v1,v2_t)         Dfp dot_2 =  v1.dotProduct(v2_t);         Assert.assertEquals("compare val ",Dfp25.of(32), dot_2);          FieldMatrix<Dfp> m_outerProduct = v1.outerProduct(v2);         Assert.assertEquals("compare val ",Dfp25.of(4), m_outerProduct.getEntry(0,0));          FieldMatrix<Dfp> m_outerProduct_2 = v1.outerProduct(v2_t);         Assert.assertEquals("compare val ",Dfp25.of(4), m_outerProduct_2.getEntry(0,0));      }      @Test     public void testOuterProduct() {         final SparseFieldVector<Dfp> u             = new SparseFieldVector<>(Dfp25.getField(),                                               new Dfp[] {Dfp25.of(1),                                                               Dfp25.of(2),                                                               Dfp25.of(-3)});         final SparseFieldVector<Dfp> v             = new SparseFieldVector<>(Dfp25.getField(),                                               new Dfp[] {Dfp25.of(4),                                                               Dfp25.of(-2)});          final FieldMatrix<Dfp> uv = u.outerProduct(v);          final double tol = Math.ulp(1d);         Assert.assertEquals(Dfp25.of(4).toDouble(), uv.getEntry(0, 0).toDouble(), tol);         Assert.assertEquals(Dfp25.of(-2).toDouble(), uv.getEntry(0, 1).toDouble(), tol);         Assert.assertEquals(Dfp25.of(8).toDouble(), uv.getEntry(1, 0).toDouble(), tol);         Assert.assertEquals(Dfp25.of(-4).toDouble(), uv.getEntry(1, 1).toDouble(), tol);         Assert.assertEquals(Dfp25.of(-12).toDouble(), uv.getEntry(2, 0).toDouble(), tol);         Assert.assertEquals(Dfp25.of(6).toDouble(), uv.getEntry(2, 1).toDouble(), tol);     }      @Test     public void testMisc() {         SparseFieldVector<Dfp> v1 = new SparseFieldVector<>(field,vec1);          String out1 = v1.toString();         Assert.assertTrue("some output ",  out1.length()!=0);         try {             v1.checkVectorDimensions(2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected behavior         }       }      @Test     public void testPredicates() {          SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, new Dfp[] { Dfp25.of(0), Dfp25.of(1), Dfp25.of(2) });          v.setEntry(0, field.getZero());         Assert.assertEquals(v, new SparseFieldVector<>(field, new Dfp[] { Dfp25.of(0), Dfp25.of(1), Dfp25.of(2) }));         Assert.assertNotSame(v, new SparseFieldVector<>(field, new Dfp[] { Dfp25.of(0), Dfp25.of(1), Dfp25.of(2), Dfp25.of(3) }));      }      /** verifies that two vectors are close (sup norm) */     protected void assertEquals(String msg, Dfp[] m, Dfp[] n) {         if (m.length != n.length) {             Assert.fail("vectors have different lengths");         }         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);         }     }      /** verifies that two vectors are close (sup norm) */     protected void assertClose(String msg, Dfp[] m, Dfp[] n, double tolerance) {         if (m.length != n.length) {             Assert.fail("vectors have different lengths");         }         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(msg + " " +  i + " elements differ", m[i].toDouble(),n[i].toDouble(), tolerance);         }     }      /*      * TESTS OF THE VISITOR PATTERN      */      /** The whole vector is visited. */     @Test     public void testWalkInDefaultOrderPreservingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              private int expectedIndex;              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 expectedIndex = 0;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor);     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInDefaultOrderPreservingVisitor2() {         final SparseFieldVector<Dfp> v = create(5);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              @Override             public void visit(int index, Dfp value) {                 // Do nothing             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInDefaultOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInDefaultOrderPreservingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              private int expectedIndex;              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 expectedIndex = expectedStart;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);     }      /** The whole vector is visited. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 visited[actualIndex] = true;                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 Arrays.fill(visited, false);             }              @Override             public Dfp end() {                 for (int i = 0; i < data.length; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor);     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor2() {         final SparseFieldVector<Dfp> v = create(5);         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {              @Override             public void visit(int index, Dfp value) {                 // Do nothing             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInOptimizedOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInOptimizedOrderPreservingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorPreservingVisitor<Dfp> visitor;         visitor = new FieldVectorPreservingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public void visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 visited[actualIndex] = true;             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 Arrays.fill(visited, true);             }              @Override             public Dfp end() {                 for (int i = expectedStart; i <= expectedEnd; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);     }      /** The whole vector is visited. */     @Test     public void testWalkInDefaultOrderChangingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              private int expectedIndex;              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 expectedIndex = 0;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor);         for (int i = 0; i < data.length; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInDefaultOrderChangingVisitor2() {         final SparseFieldVector<Dfp> v = create(5);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              @Override             public Dfp visit(int index, Dfp value) {                 return Dfp25.ZERO;             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInDefaultOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInDefaultOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInDefaultOrderChangingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              private int expectedIndex;              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(expectedIndex, actualIndex);                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 ++expectedIndex;                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 expectedIndex = expectedStart;             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);         for (int i = expectedStart; i <= expectedEnd; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      /** The whole vector is visited. */     @Test     public void testWalkInOptimizedOrderChangingVisitor1() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 visited[actualIndex] = true;                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(0, actualStart);                 Assert.assertEquals(data.length - 1, actualEnd);                 Arrays.fill(visited, false);             }              @Override             public Dfp end() {                 for (int i = 0; i < data.length; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor);         for (int i = 0; i < data.length; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      /** Visiting an invalid subvector. */     @Test     public void testWalkInOptimizedOrderChangingVisitor2() {         final SparseFieldVector<Dfp> v = create(5);         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {              @Override             public Dfp visit(int index, Dfp value) {                 return Dfp25.ZERO;             }              @Override             public void start(int dimension, int start, int end) {                 // Do nothing             }              @Override             public Dfp end() {                 return Dfp25.ZERO;             }         };         try {             v.walkInOptimizedOrder(visitor, -1, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 5, 4);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, -1);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 0, 5);             Assert.fail();         } catch (OutOfRangeException e) {             // Expected behavior         }         try {             v.walkInOptimizedOrder(visitor, 4, 0);             Assert.fail();         } catch (NumberIsTooSmallException e) {             // Expected behavior         }     }      /** Visiting a valid subvector. */     @Test     public void testWalkInOptimizedOrderChangingVisitor3() {         final Dfp[] data = new Dfp[] {             Dfp25.ZERO, Dfp25.ONE, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.TWO, Dfp25.ZERO,             Dfp25.ZERO, Dfp25.ZERO, Dfp25.of(3)         };         final SparseFieldVector<Dfp> v = new SparseFieldVector<>(field, data);         final int expectedStart = 2;         final int expectedEnd = 7;         final FieldVectorChangingVisitor<Dfp> visitor;         visitor = new FieldVectorChangingVisitor<Dfp>() {             private final boolean[] visited = new boolean[data.length];              @Override             public Dfp visit(final int actualIndex, final Dfp actualValue) {                 Assert.assertEquals(Integer.toString(actualIndex),                                     data[actualIndex], actualValue);                 visited[actualIndex] = true;                 return actualValue.add(actualIndex);             }              @Override             public void start(final int actualSize, final int actualStart,                               final int actualEnd) {                 Assert.assertEquals(data.length, actualSize);                 Assert.assertEquals(expectedStart, actualStart);                 Assert.assertEquals(expectedEnd, actualEnd);                 Arrays.fill(visited, true);             }              @Override             public Dfp end() {                 for (int i = expectedStart; i <= expectedEnd; i++) {                     Assert.assertTrue("entry " + i + "has not been visited",                                       visited[i]);                 }                 return Dfp25.ZERO;             }         };         v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);         for (int i = expectedStart; i <= expectedEnd; i++) {             Assert.assertEquals("entry " + i, data[i].add(i), v.getEntry(i));         }     }      private SparseFieldVector<Dfp> create(int n) {         Dfp[] t = new Dfp[n];         for (int i = 0; i < n; ++i) {             t[i] = Dfp25.ZERO;         }         return new SparseFieldVector<>(field, t);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import java.util.Arrays; import java.util.Random;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.util.BigReal; import org.apache.commons.math4.util.BigRealField;  /**  * Test cases for the {@link BlockFieldMatrix} class.  *  */  public final class BlockFieldMatrixTest {      // 3 x 3 identity matrix     protected Dfp[][] id = {             {Dfp25.of(1),Dfp25.of(0),Dfp25.of(0)},             {Dfp25.of(0),Dfp25.of(1),Dfp25.of(0)},             {Dfp25.of(0),Dfp25.of(0),Dfp25.of(1)}     };      // Test data for group operations     protected Dfp[][] testData = {             {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)},             {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3)},             {Dfp25.of(1),Dfp25.of(0),Dfp25.of(8)}     };     protected Dfp[][] testDataLU = {             {Dfp25.of(2), Dfp25.of(5), Dfp25.of(3)},             {Dfp25.of(1, 2), Dfp25.of(-5, 2), Dfp25.of(13, 2)},             {Dfp25.of(1, 2), Dfp25.of(1, 5), Dfp25.of(1, 5)}     };     protected Dfp[][] testDataPlus2 = {             {Dfp25.of(3),Dfp25.of(4),Dfp25.of(5)},             {Dfp25.of(4),Dfp25.of(7),Dfp25.of(5)},             {Dfp25.of(3),Dfp25.of(2),Dfp25.of(10)}     };     protected Dfp[][] testDataMinus = {             {Dfp25.of(-1),Dfp25.of(-2),Dfp25.of(-3)},             {Dfp25.of(-2),Dfp25.of(-5),Dfp25.of(-3)},             {Dfp25.of(-1),Dfp25.of(0),Dfp25.of(-8)}     };     protected Dfp[] testDataRow1 = {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)};     protected Dfp[] testDataCol3 = {Dfp25.of(3),Dfp25.of(3),Dfp25.of(8)};     protected Dfp[][] testDataInv = {             {Dfp25.of(-40),Dfp25.of(16),Dfp25.of(9)},             {Dfp25.of(13),Dfp25.of(-5),Dfp25.of(-3)},             {Dfp25.of(5),Dfp25.of(-2),Dfp25.of(-1)}     };     protected Dfp[] preMultTest = {Dfp25.of(8), Dfp25.of(12), Dfp25.of(33)};     protected Dfp[][] testData2 = {             {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)},             {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3)}     };     protected Dfp[][] testData2T = {             {Dfp25.of(1),Dfp25.of(2)},             {Dfp25.of(2),Dfp25.of(5)},             {Dfp25.of(3),Dfp25.of(3)}     };     protected Dfp[][] testDataPlusInv = {             {Dfp25.of(-39),Dfp25.of(18),Dfp25.of(12)},             {Dfp25.of(15),Dfp25.of(0),Dfp25.of(0)},             {Dfp25.of(6),Dfp25.of(-2),Dfp25.of(7)}     };      // lu decomposition tests     protected Dfp[][] luData = {             {Dfp25.of(2),Dfp25.of(3),Dfp25.of(3)},             {Dfp25.of(0),Dfp25.of(5),Dfp25.of(7)},             {Dfp25.of(6),Dfp25.of(9),Dfp25.of(8)}     };     protected Dfp[][] luDataLUDecomposition = {             {Dfp25.of(6),Dfp25.of(9),Dfp25.of(8)},             {Dfp25.of(0),Dfp25.of(5),Dfp25.of(7)},             {Dfp25.of(1, 3),Dfp25.of(0),Dfp25.of(1, 3)}     };      // singular matrices     protected Dfp[][] singular = { {Dfp25.of(2),Dfp25.of(3)}, {Dfp25.of(2),Dfp25.of(3)} };     protected Dfp[][] bigSingular = {             {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)},             {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3),Dfp25.of(4)},             {Dfp25.of(7),Dfp25.of(3),Dfp25.of(256),Dfp25.of(1930)},             {Dfp25.of(3),Dfp25.of(7),Dfp25.of(6),Dfp25.of(8)}     }; // 4th row = 1st + 2nd     protected Dfp[][] detData = {             {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)},             {Dfp25.of(4),Dfp25.of(5),Dfp25.of(6)},             {Dfp25.of(7),Dfp25.of(8),Dfp25.of(10)}     };     protected Dfp[][] detData2 = { {Dfp25.of(1), Dfp25.of(3)}, {Dfp25.of(2), Dfp25.of(4)}};      // vectors     protected Dfp[] testVector = {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)};     protected Dfp[] testVector2 = {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)};      // submatrix accessor tests     protected Dfp[][] subTestData = {             {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4)},             {Dfp25.of(3, 2), Dfp25.of(5, 2), Dfp25.of(7, 2), Dfp25.of(9, 2)},             {Dfp25.of(2), Dfp25.of(4), Dfp25.of(6), Dfp25.of(8)},             {Dfp25.of(4), Dfp25.of(5), Dfp25.of(6), Dfp25.of(7)}     };     // array selections     protected Dfp[][] subRows02Cols13 = { {Dfp25.of(2), Dfp25.of(4)}, {Dfp25.of(4), Dfp25.of(8)}};     protected Dfp[][] subRows03Cols12 = { {Dfp25.of(2), Dfp25.of(3)}, {Dfp25.of(5), Dfp25.of(6)}};     protected Dfp[][] subRows03Cols123 = {             {Dfp25.of(2), Dfp25.of(3), Dfp25.of(4)},             {Dfp25.of(5), Dfp25.of(6), Dfp25.of(7)}     };     // effective permutations     protected Dfp[][] subRows20Cols123 = {             {Dfp25.of(4), Dfp25.of(6), Dfp25.of(8)},             {Dfp25.of(2), Dfp25.of(3), Dfp25.of(4)}     };     protected Dfp[][] subRows31Cols31 = {{Dfp25.of(7), Dfp25.of(5)}, {Dfp25.of(9, 2), Dfp25.of(5, 2)}};     // contiguous ranges     protected Dfp[][] subRows01Cols23 = {{Dfp25.of(3),Dfp25.of(4)} , {Dfp25.of(7, 2), Dfp25.of(9, 2)}};     protected Dfp[][] subRows23Cols00 = {{Dfp25.of(2)} , {Dfp25.of(4)}};     protected Dfp[][] subRows00Cols33 = {{Dfp25.of(4)}};     // row matrices     protected Dfp[][] subRow0 = {{Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)}};     protected Dfp[][] subRow3 = {{Dfp25.of(4),Dfp25.of(5),Dfp25.of(6),Dfp25.of(7)}};     // column matrices     protected Dfp[][] subColumn1 = {{Dfp25.of(2)}, {Dfp25.of(5, 2)}, {Dfp25.of(4)}, {Dfp25.of(5)}};     protected Dfp[][] subColumn3 = {{Dfp25.of(4)}, {Dfp25.of(9, 2)}, {Dfp25.of(8)}, {Dfp25.of(7)}};      // tolerances     protected double entryTolerance = 10E-16;     protected double normTolerance = 10E-14;      /** test dimensions */     @Test     public void testDimensions() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> m2 = new BlockFieldMatrix<>(testData2);         Assert.assertEquals("testData row dimension",3,m.getRowDimension());         Assert.assertEquals("testData column dimension",3,m.getColumnDimension());         Assert.assertTrue("testData is square",m.isSquare());         Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);         Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);         Assert.assertTrue("testData2 is not square",!m2.isSquare());     }      /** test copy functions */     @Test     public void testCopyFunctions() {         Random r = new Random(66636328996002l);         BlockFieldMatrix<Dfp> m1 = createRandomMatrix(r, 47, 83);         BlockFieldMatrix<Dfp> m2 = new BlockFieldMatrix<>(m1.getData());         Assert.assertEquals(m1, m2);         BlockFieldMatrix<Dfp> m3 = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> m4 = new BlockFieldMatrix<>(m3.getData());         Assert.assertEquals(m3, m4);     }      /** test add */     @Test     public void testAdd() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> mInv = new BlockFieldMatrix<>(testDataInv);         FieldMatrix<Dfp> mPlusMInv = m.add(mInv);         Dfp[][] sumEntries = mPlusMInv.getData();         for (int row = 0; row < m.getRowDimension(); row++) {             for (int col = 0; col < m.getColumnDimension(); col++) {                 Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);             }         }     }      /** test add failure */     @Test     public void testAddFail() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> m2 = new BlockFieldMatrix<>(testData2);         try {             m.add(m2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }       /** test m-n = m + -n */     @Test     public void testPlusMinus() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> m2 = new BlockFieldMatrix<>(testDataInv);         TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(Dfp25.of(-1)).add(m));         try {             m.subtract(new BlockFieldMatrix<>(testData2));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test multiply */     @Test     public void testMultiply() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> mInv = new BlockFieldMatrix<>(testDataInv);         BlockFieldMatrix<Dfp> identity = new BlockFieldMatrix<>(id);         BlockFieldMatrix<Dfp> m2 = new BlockFieldMatrix<>(testData2);         TestUtils.assertEquals(m.multiply(mInv), identity);         TestUtils.assertEquals(mInv.multiply(m), identity);         TestUtils.assertEquals(m.multiply(identity), m);         TestUtils.assertEquals(identity.multiply(mInv), mInv);         TestUtils.assertEquals(m2.multiply(identity), m2);         try {             m.multiply(new BlockFieldMatrix<>(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      @Test     public void testSeveralBlocks() {         FieldMatrix<Dfp> m =             new BlockFieldMatrix<>(Dfp25.getField(), 37, 41);         for (int i = 0; i < m.getRowDimension(); ++i) {             for (int j = 0; j < m.getColumnDimension(); ++j) {                 m.setEntry(i, j, Dfp25.of(i * 11 + j, 11));             }         }          FieldMatrix<Dfp> mT = m.transpose();         Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension());         Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension());         for (int i = 0; i < mT.getRowDimension(); ++i) {             for (int j = 0; j < mT.getColumnDimension(); ++j) {                 Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j));             }         }          FieldMatrix<Dfp> mPm = m.add(m);         for (int i = 0; i < mPm.getRowDimension(); ++i) {             for (int j = 0; j < mPm.getColumnDimension(); ++j) {                 Assert.assertEquals(m.getEntry(i, j).multiply(Dfp25.of(2)), mPm.getEntry(i, j));             }         }          FieldMatrix<Dfp> mPmMm = mPm.subtract(m);         for (int i = 0; i < mPmMm.getRowDimension(); ++i) {             for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                 Assert.assertEquals(m.getEntry(i, j).toDouble(),                                     mPmMm.getEntry(i, j).toDouble(),                                     0d);             }         }          FieldMatrix<Dfp> mTm = mT.multiply(m);         for (int i = 0; i < mTm.getRowDimension(); ++i) {             for (int j = 0; j < mTm.getColumnDimension(); ++j) {                 Dfp sum = Dfp25.ZERO;                 for (int k = 0; k < mT.getColumnDimension(); ++k) {                     sum = sum.add(Dfp25.of(k * 11 + i, 11).multiply(Dfp25.of(k * 11 + j, 11)));                 }                 Assert.assertEquals(sum, mTm.getEntry(i, j));             }         }          FieldMatrix<Dfp> mmT = m.multiply(mT);         for (int i = 0; i < mmT.getRowDimension(); ++i) {             for (int j = 0; j < mmT.getColumnDimension(); ++j) {                 Dfp sum = Dfp25.ZERO;                 for (int k = 0; k < m.getColumnDimension(); ++k) {                     sum = sum.add(Dfp25.of(i * 11 + k, 11).multiply(Dfp25.of(j * 11 + k, 11)));                 }                 Assert.assertEquals(sum.toDouble(),                                     mmT.getEntry(i, j).toDouble(),                                     0d);             }         }          FieldMatrix<Dfp> sub1 = m.getSubMatrix(2, 9, 5, 20);         for (int i = 0; i < sub1.getRowDimension(); ++i) {             for (int j = 0; j < sub1.getColumnDimension(); ++j) {                 Assert.assertEquals(Dfp25.of((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));             }         }          FieldMatrix<Dfp> sub2 = m.getSubMatrix(10, 12, 3, 40);         for (int i = 0; i < sub2.getRowDimension(); ++i) {             for (int j = 0; j < sub2.getColumnDimension(); ++j) {                 Assert.assertEquals(Dfp25.of((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));             }         }          FieldMatrix<Dfp> sub3 = m.getSubMatrix(30, 34, 0, 5);         for (int i = 0; i < sub3.getRowDimension(); ++i) {             for (int j = 0; j < sub3.getColumnDimension(); ++j) {                 Assert.assertEquals(Dfp25.of((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));             }         }          FieldMatrix<Dfp> sub4 = m.getSubMatrix(30, 32, 32, 35);         for (int i = 0; i < sub4.getRowDimension(); ++i) {             for (int j = 0; j < sub4.getColumnDimension(); ++j) {                 Assert.assertEquals(Dfp25.of((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));             }         }      }      //Additional Test for BlockFieldMatrix<Dfp>Test.testMultiply      private Dfp[][] d3 = new Dfp[][] {             {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3),Dfp25.of(4)},             {Dfp25.of(5),Dfp25.of(6),Dfp25.of(7),Dfp25.of(8)}     };     private Dfp[][] d4 = new Dfp[][] {             {Dfp25.of(1)},             {Dfp25.of(2)},             {Dfp25.of(3)},             {Dfp25.of(4)}     };     private Dfp[][] d5 = new Dfp[][] {{Dfp25.of(30)},{Dfp25.of(70)}};      @Test     public void testMultiply2() {        FieldMatrix<Dfp> m3 = new BlockFieldMatrix<>(d3);        FieldMatrix<Dfp> m4 = new BlockFieldMatrix<>(d4);        FieldMatrix<Dfp> m5 = new BlockFieldMatrix<>(d5);        TestUtils.assertEquals(m3.multiply(m4), m5);    }      /** test trace */     @Test     public void testTrace() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(id);         Assert.assertEquals(Dfp25.of(3),m.getTrace());         m = new BlockFieldMatrix<>(testData2);         try {             m.getTrace();             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }     }      /** test scalarAdd */     @Test     public void testScalarAdd() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         TestUtils.assertEquals(new BlockFieldMatrix<>(testDataPlus2),                                m.scalarAdd(Dfp25.of(2)));     }      /** test operate */     @Test     public void testOperate() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(id);         TestUtils.assertEquals(testVector, m.operate(testVector));         TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<>(testVector)).toArray());         m = new BlockFieldMatrix<>(bigSingular);         try {             m.operate(testVector);             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testOperateLarge() {         int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;         int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;         int r =  BlockFieldMatrix.BLOCK_SIZE / 2;         Random random = new Random(111007463902334l);         FieldMatrix<Dfp> m1 = createRandomMatrix(random, p, q);         FieldMatrix<Dfp> m2 = createRandomMatrix(random, q, r);         FieldMatrix<Dfp> m1m2 = m1.multiply(m2);         for (int i = 0; i < r; ++i) {             TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));         }     }      @Test     public void testOperatePremultiplyLarge() {         int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;         int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;         int r =  BlockFieldMatrix.BLOCK_SIZE / 2;         Random random = new Random(111007463902334l);         FieldMatrix<Dfp> m1 = createRandomMatrix(random, p, q);         FieldMatrix<Dfp> m2 = createRandomMatrix(random, q, r);         FieldMatrix<Dfp> m1m2 = m1.multiply(m2);         for (int i = 0; i < p; ++i) {             TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));         }     }      /** test issue MATH-209 */     @Test     public void testMath209() {         FieldMatrix<Dfp> a = new BlockFieldMatrix<>(new Dfp[][] {                 { Dfp25.of(1), Dfp25.of(2) },                 { Dfp25.of(3), Dfp25.of(4) },                 { Dfp25.of(5), Dfp25.of(6) }         });         Dfp[] b = a.operate(new Dfp[] { Dfp25.of(1), Dfp25.of(1) });         Assert.assertEquals(a.getRowDimension(), b.length);         Assert.assertEquals( Dfp25.of(3), b[0]);         Assert.assertEquals( Dfp25.of(7), b[1]);         Assert.assertEquals(Dfp25.of(11), b[2]);     }      /** test transpose */     @Test     public void testTranspose() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         FieldMatrix<Dfp> mIT = new FieldLUDecomposition<>(m).getSolver().getInverse().transpose();         FieldMatrix<Dfp> mTI = new FieldLUDecomposition<>(m.transpose()).getSolver().getInverse();         TestUtils.assertEquals(mIT, mTI);         m = new BlockFieldMatrix<>(testData2);         FieldMatrix<Dfp> mt = new BlockFieldMatrix<>(testData2T);         TestUtils.assertEquals(mt, m.transpose());     }      /** test preMultiply by vector */     @Test     public void testPremultiplyVector() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);         TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<>(testVector).toArray()),                                preMultTest);         m = new BlockFieldMatrix<>(bigSingular);         try {             m.preMultiply(testVector);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testPremultiply() {         FieldMatrix<Dfp> m3 = new BlockFieldMatrix<>(d3);         FieldMatrix<Dfp> m4 = new BlockFieldMatrix<>(d4);         FieldMatrix<Dfp> m5 = new BlockFieldMatrix<>(d5);         TestUtils.assertEquals(m4.preMultiply(m3), m5);          BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> mInv = new BlockFieldMatrix<>(testDataInv);         BlockFieldMatrix<Dfp> identity = new BlockFieldMatrix<>(id);         TestUtils.assertEquals(m.preMultiply(mInv), identity);         TestUtils.assertEquals(mInv.preMultiply(m), identity);         TestUtils.assertEquals(m.preMultiply(identity), m);         TestUtils.assertEquals(identity.preMultiply(mInv), mInv);         try {             m.preMultiply(new BlockFieldMatrix<>(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testGetVectors() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         TestUtils.assertEquals(m.getRow(0), testDataRow1);         TestUtils.assertEquals(m.getColumn(2), testDataCol3);         try {             m.getRow(10);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }         try {             m.getColumn(-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }     }      @Test     public void testGetEntry() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         Assert.assertEquals(m.getEntry(0,1),Dfp25.of(2));         try {             m.getEntry(10, 4);             Assert.fail ("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      /** test examples in user guide */     @Test     public void testExamples() {         // Create a real matrix with two rows and three columns         Dfp[][] matrixData = {                 {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)},                 {Dfp25.of(2),Dfp25.of(5),Dfp25.of(3)}         };         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(matrixData);         // One more with three rows, two columns         Dfp[][] matrixData2 = {                 {Dfp25.of(1),Dfp25.of(2)},                 {Dfp25.of(2),Dfp25.of(5)},                 {Dfp25.of(1), Dfp25.of(7)}         };         FieldMatrix<Dfp> n = new BlockFieldMatrix<>(matrixData2);         // Now multiply m by n         FieldMatrix<Dfp> p = m.multiply(n);         Assert.assertEquals(2, p.getRowDimension());         Assert.assertEquals(2, p.getColumnDimension());         // Invert p         FieldMatrix<Dfp> pInverse = new FieldLUDecomposition<>(p).getSolver().getInverse();         Assert.assertEquals(2, pInverse.getRowDimension());         Assert.assertEquals(2, pInverse.getColumnDimension());          // Solve example         Dfp[][] coefficientsData = {                 {Dfp25.of(2), Dfp25.of(3), Dfp25.of(-2)},                 {Dfp25.of(-1), Dfp25.of(7), Dfp25.of(6)},                 {Dfp25.of(4), Dfp25.of(-3), Dfp25.of(-5)}         };         FieldMatrix<Dfp> coefficients = new BlockFieldMatrix<>(coefficientsData);         Dfp[] constants = {             Dfp25.of(1), Dfp25.of(-2), Dfp25.of(1)         };         Dfp[] solution;         solution = new FieldLUDecomposition<>(coefficients)             .getSolver()             .solve(new ArrayFieldVector<>(constants, false)).toArray();         Assert.assertEquals(Dfp25.of(2).multiply(solution[0]).                             add(Dfp25.of(3).multiply(solution[1])).                             subtract(Dfp25.of(2).multiply(solution[2])).toDouble(),                             constants[0].toDouble(),                             0d);         Assert.assertEquals(Dfp25.of(-1).multiply(solution[0]).                             add(Dfp25.of(7).multiply(solution[1])).                             add(Dfp25.of(6).multiply(solution[2])).toDouble(),                             constants[1].toDouble(),                             0d);         Assert.assertEquals(Dfp25.of(4).multiply(solution[0]).                             subtract(Dfp25.of(3).multiply(solution[1])).                             subtract(Dfp25.of(5).multiply(solution[2])).toDouble(),                             constants[2].toDouble(),                             0d);      }      // test submatrix accessors     @Test     public void testGetSubMatrix() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);         checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);         checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });         checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });         checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkGetSubMatrix(m, null,  1, 0, 2, 4);         checkGetSubMatrix(m, null, -1, 1, 2, 2);         checkGetSubMatrix(m, null,  1, 0, 2, 2);         checkGetSubMatrix(m, null,  1, 0, 2, 4);         checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });         checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });     }      private void checkGetSubMatrix(FieldMatrix<Dfp> m, Dfp[][] reference,                                    int startRow, int endRow, int startColumn, int endColumn) {         try {             FieldMatrix<Dfp> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);             if (reference != null) {                 Assert.assertEquals(new BlockFieldMatrix<>(reference), sub);             } else {                 Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException"                      + " or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NotStrictlyPositiveException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      private void checkGetSubMatrix(FieldMatrix<Dfp> m, Dfp[][] reference,                                    int[] selectedRows, int[] selectedColumns) {         try {             FieldMatrix<Dfp> sub = m.getSubMatrix(selectedRows, selectedColumns);             if (reference != null) {                 Assert.assertEquals(new BlockFieldMatrix<>(reference), sub);             } else {                 Assert.fail("Expecting OutOfRangeException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NotStrictlyPositiveException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      @Test     public void testGetSetMatrixLarge() {         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;         FieldMatrix<Dfp> m =             new BlockFieldMatrix<>(Dfp25.getField(), n, n);         FieldMatrix<Dfp> sub =             new BlockFieldMatrix<>(Dfp25.getField(), n - 4, n - 4).scalarAdd(Dfp25.of(1));          m.setSubMatrix(sub.getData(), 2, 2);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                     Assert.assertEquals(Dfp25.of(0), m.getEntry(i, j));                 } else {                     Assert.assertEquals(Dfp25.of(1), m.getEntry(i, j));                 }             }         }         Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));     }      @Test     public void testCopySubMatrix() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);         checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);         checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });         checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });         checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });          checkCopy(m, null,  1, 0, 2, 4);         checkCopy(m, null, -1, 1, 2, 2);         checkCopy(m, null,  1, 0, 2, 2);         checkCopy(m, null,  1, 0, 2, 4);         checkCopy(m, null, new int[] {}, new int[] { 0 });         checkCopy(m, null, new int[] { 0 }, new int[] { 4 });     }      private void checkCopy(FieldMatrix<Dfp> m, Dfp[][] reference,                            int startRow, int endRow, int startColumn, int endColumn) {         try {             Dfp[][] sub = (reference == null) ?                              new Dfp[1][1] :                              new Dfp[reference.length][reference[0].length];             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);             if (reference != null) {                 Assert.assertEquals(new BlockFieldMatrix<>(reference), new BlockFieldMatrix<>(sub));             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      private void checkCopy(FieldMatrix<Dfp> m, Dfp[][] reference,                            int[] selectedRows, int[] selectedColumns) {         try {             Dfp[][] sub = (reference == null) ?                     new Dfp[1][1] :                     new Dfp[reference.length][reference[0].length];             m.copySubMatrix(selectedRows, selectedColumns, sub);             if (reference != null) {                 Assert.assertEquals(new BlockFieldMatrix<>(reference), new BlockFieldMatrix<>(sub));             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      @Test     public void testGetRowMatrix() {         FieldMatrix<Dfp> m     = new BlockFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mRow0 = new BlockFieldMatrix<>(subRow0);         FieldMatrix<Dfp> mRow3 = new BlockFieldMatrix<>(subRow3);         Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));         Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));         try {             m.getRowMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowMatrix() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mRow3 = new BlockFieldMatrix<>(subRow3);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowMatrix(0, mRow3);         Assert.assertEquals(mRow3, m.getRowMatrix(0));         try {             m.setRowMatrix(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetRowMatrixLarge() {         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;         FieldMatrix<Dfp> m =             new BlockFieldMatrix<>(Dfp25.getField(), n, n);         FieldMatrix<Dfp> sub =             new BlockFieldMatrix<>(Dfp25.getField(), 1, n).scalarAdd(Dfp25.of(1));          m.setRowMatrix(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (i != 2) {                     Assert.assertEquals(Dfp25.of(0), m.getEntry(i, j));                 } else {                     Assert.assertEquals(Dfp25.of(1), m.getEntry(i, j));                 }             }         }         Assert.assertEquals(sub, m.getRowMatrix(2));      }      @Test     public void testGetColumnMatrix() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mColumn1 = new BlockFieldMatrix<>(subColumn1);         FieldMatrix<Dfp> mColumn3 = new BlockFieldMatrix<>(subColumn3);         Assert.assertEquals(mColumn1, m.getColumnMatrix(1));         Assert.assertEquals(mColumn3, m.getColumnMatrix(3));         try {             m.getColumnMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnMatrix() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         FieldMatrix<Dfp> mColumn3 = new BlockFieldMatrix<>(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));         m.setColumnMatrix(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnMatrix(1));         try {             m.setColumnMatrix(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetColumnMatrixLarge() {         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;         FieldMatrix<Dfp> m =             new BlockFieldMatrix<>(Dfp25.getField(), n, n);         FieldMatrix<Dfp> sub =             new BlockFieldMatrix<>(Dfp25.getField(), n, 1).scalarAdd(Dfp25.of(1));          m.setColumnMatrix(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (j != 2) {                     Assert.assertEquals(Dfp25.of(0), m.getEntry(i, j));                 } else {                     Assert.assertEquals(Dfp25.of(1), m.getEntry(i, j));                 }             }         }         Assert.assertEquals(sub, m.getColumnMatrix(2));      }      @Test     public void testGetRowVector() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         FieldVector<Dfp> mRow0 = new ArrayFieldVector<>(subRow0[0]);         FieldVector<Dfp> mRow3 = new ArrayFieldVector<>(subRow3[0]);         Assert.assertEquals(mRow0, m.getRowVector(0));         Assert.assertEquals(mRow3, m.getRowVector(3));         try {             m.getRowVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowVector() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         FieldVector<Dfp> mRow3 = new ArrayFieldVector<>(subRow3[0]);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowVector(0, mRow3);         Assert.assertEquals(mRow3, m.getRowVector(0));         try {             m.setRowVector(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowVector(0, new ArrayFieldVector<>(Dfp25.getField(), 5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetRowVectorLarge() {         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(Dfp25.getField(), n, n);         FieldVector<Dfp> sub = new ArrayFieldVector<>(n, Dfp25.of(1));          m.setRowVector(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (i != 2) {                     Assert.assertEquals(Dfp25.of(0), m.getEntry(i, j));                 } else {                     Assert.assertEquals(Dfp25.of(1), m.getEntry(i, j));                 }             }         }         Assert.assertEquals(sub, m.getRowVector(2));      }      @Test     public void testGetColumnVector() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         FieldVector<Dfp> mColumn1 = columnToVector(subColumn1);         FieldVector<Dfp> mColumn3 = columnToVector(subColumn3);         Assert.assertEquals(mColumn1, m.getColumnVector(1));         Assert.assertEquals(mColumn3, m.getColumnVector(3));         try {             m.getColumnVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnVector() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         FieldVector<Dfp> mColumn3 = columnToVector(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnVector(1));         m.setColumnVector(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnVector(1));         try {             m.setColumnVector(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnVector(0, new ArrayFieldVector<>(Dfp25.getField(), 5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetColumnVectorLarge() {         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(Dfp25.getField(), n, n);         FieldVector<Dfp> sub = new ArrayFieldVector<>(n, Dfp25.of(1));          m.setColumnVector(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (j != 2) {                     Assert.assertEquals(Dfp25.of(0), m.getEntry(i, j));                 } else {                     Assert.assertEquals(Dfp25.of(1), m.getEntry(i, j));                 }             }         }         Assert.assertEquals(sub, m.getColumnVector(2));      }      private FieldVector<Dfp> columnToVector(Dfp[][] column) {         Dfp[] data = new Dfp[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return new ArrayFieldVector<>(data, false);     }      @Test     public void testGetRow() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         checkArrays(subRow0[0], m.getRow(0));         checkArrays(subRow3[0], m.getRow(3));         try {             m.getRow(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRow(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRow() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);         m.setRow(0, subRow3[0]);         checkArrays(subRow3[0], m.getRow(0));         try {             m.setRow(-1, subRow3[0]);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRow(0, new Dfp[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetRowLarge() {         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(Dfp25.getField(), n, n);         Dfp[] sub = new Dfp[n];         Arrays.fill(sub, Dfp25.of(1));          m.setRow(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (i != 2) {                     Assert.assertEquals(Dfp25.of(0), m.getEntry(i, j));                 } else {                     Assert.assertEquals(Dfp25.of(1), m.getEntry(i, j));                 }             }         }         checkArrays(sub, m.getRow(2));      }      @Test     public void testGetColumn() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         Dfp[] mColumn1 = columnToArray(subColumn1);         Dfp[] mColumn3 = columnToArray(subColumn3);         checkArrays(mColumn1, m.getColumn(1));         checkArrays(mColumn3, m.getColumn(3));         try {             m.getColumn(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumn(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumn() {         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(subTestData);         Dfp[] mColumn3 = columnToArray(subColumn3);         Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);         m.setColumn(1, mColumn3);         checkArrays(mColumn3, m.getColumn(1));         try {             m.setColumn(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumn(0, new Dfp[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetColumnLarge() {         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;         FieldMatrix<Dfp> m = new BlockFieldMatrix<>(Dfp25.getField(), n, n);         Dfp[] sub = new Dfp[n];         Arrays.fill(sub, Dfp25.of(1));          m.setColumn(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (j != 2) {                     Assert.assertEquals(Dfp25.of(0), m.getEntry(i, j));                 } else {                     Assert.assertEquals(Dfp25.of(1), m.getEntry(i, j));                 }             }         }         checkArrays(sub, m.getColumn(2));      }      private Dfp[] columnToArray(Dfp[][] column) {         Dfp[] data = new Dfp[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return data;     }      private void checkArrays(Dfp[] expected, Dfp[] actual) {         Assert.assertEquals(expected.length, actual.length);         for (int i = 0; i < expected.length; ++i) {             Assert.assertEquals(expected[i], actual[i]);         }     }      @Test     public void testEqualsAndHashCode() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         BlockFieldMatrix<Dfp> m1 = (BlockFieldMatrix<Dfp>) m.copy();         BlockFieldMatrix<Dfp> mt = (BlockFieldMatrix<Dfp>) m.transpose();         Assert.assertTrue(m.hashCode() != mt.hashCode());         Assert.assertEquals(m.hashCode(), m1.hashCode());         Assert.assertEquals(m, m);         Assert.assertEquals(m, m1);         Assert.assertFalse(m.equals(null));         Assert.assertFalse(m.equals(mt));         Assert.assertFalse(m.equals(new BlockFieldMatrix<>(bigSingular)));     }      @Test     public void testToString() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         Assert.assertEquals("BlockFieldMatrix{{1.,2.,3.},{2.,5.,3.},{1.,0.,8.}}", m.toString());     }      @Test     public void testSetSubMatrix() {         BlockFieldMatrix<Dfp> m = new BlockFieldMatrix<>(testData);         m.setSubMatrix(detData2,1,1);         FieldMatrix<Dfp> expected = new BlockFieldMatrix<>             (new Dfp[][] {{Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)},{Dfp25.of(2),Dfp25.of(1),Dfp25.of(3)},{Dfp25.of(1),Dfp25.of(2),Dfp25.of(4)}});         Assert.assertEquals(expected, m);          m.setSubMatrix(detData2,0,0);         expected = new BlockFieldMatrix<>             (new Dfp[][] {{Dfp25.of(1),Dfp25.of(3),Dfp25.of(3)},{Dfp25.of(2),Dfp25.of(4),Dfp25.of(3)},{Dfp25.of(1),Dfp25.of(2),Dfp25.of(4)}});         Assert.assertEquals(expected, m);          m.setSubMatrix(testDataPlus2,0,0);         expected = new BlockFieldMatrix<>             (new Dfp[][] {{Dfp25.of(3),Dfp25.of(4),Dfp25.of(5)},{Dfp25.of(4),Dfp25.of(7),Dfp25.of(5)},{Dfp25.of(3),Dfp25.of(2),Dfp25.of(10)}});         Assert.assertEquals(expected, m);          // javadoc example         BlockFieldMatrix<Dfp> matrix =             new BlockFieldMatrix<>(new Dfp[][] {                     {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3), Dfp25.of(4)},                     {Dfp25.of(5), Dfp25.of(6), Dfp25.of(7), Dfp25.of(8)},                     {Dfp25.of(9), Dfp25.of(0), Dfp25.of(1) , Dfp25.of(2)}             });         matrix.setSubMatrix(new Dfp[][] {                 {Dfp25.of(3), Dfp25.of(4)},                 {Dfp25.of(5), Dfp25.of(6)}         }, 1, 1);         expected =             new BlockFieldMatrix<>(new Dfp[][] {                     {Dfp25.of(1), Dfp25.of(2), Dfp25.of(3),Dfp25.of(4)},                     {Dfp25.of(5), Dfp25.of(3), Dfp25.of(4), Dfp25.of(8)},                     {Dfp25.of(9), Dfp25.of(5) ,Dfp25.of(6), Dfp25.of(2)}             });         Assert.assertEquals(expected, matrix);          // dimension overflow         try {             m.setSubMatrix(testData,1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         // dimension underflow         try {             m.setSubMatrix(testData,-1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         try {             m.setSubMatrix(testData,1,-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }          // null         try {             m.setSubMatrix(null,1,1);             Assert.fail("expecting NullArgumentException");         } catch (NullArgumentException e) {             // expected         }          // ragged         try {             m.setSubMatrix(new Dfp[][] {{Dfp25.of(1)}, {Dfp25.of(2), Dfp25.of(3)}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // empty         try {             m.setSubMatrix(new Dfp[][] {{}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }     }      @Test     public void testWalk() {         int rows    = 150;         int columns = 75;          FieldMatrix<Dfp> m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInRowOrder(new SetVisitor());         GetVisitor getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }          m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInColumnOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }          m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }          m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, 0));             Assert.assertEquals(Dfp25.of(0), m.getEntry(i, columns - 1));         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(Dfp25.of(0), m.getEntry(0, j));             Assert.assertEquals(Dfp25.of(0), m.getEntry(rows - 1, j));         }      }      @Test     public void testSerial()  {         final int r = 2;         final int c = 3;         BlockFieldMatrix<BigReal> m = new BlockFieldMatrix<>(BigRealField.getInstance(), r, c);         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 m.setEntry(i, j, new BigReal(Math.random()));             }         }         Assert.assertEquals(m,TestUtils.serializeAndRecover(m));     }      private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Dfp> {         public SetVisitor() {             super(Dfp25.ZERO);         }         @Override         public Dfp visit(int i, int j, Dfp value) {             return Dfp25.of(i * 11 + j, 11);         }     }      private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Dfp> {         private int count;         public GetVisitor() {             super(Dfp25.ZERO);             count = 0;         }         @Override         public void visit(int i, int j, Dfp value) {             ++count;             Assert.assertEquals(Dfp25.of(i * 11 + j, 11), value);         }         public int getCount() {             return count;         }     }      private BlockFieldMatrix<Dfp> createRandomMatrix(Random r, int rows, int columns) {         BlockFieldMatrix<Dfp> m =             new BlockFieldMatrix<>(Dfp25.getField(), rows, columns);         for (int i = 0; i < rows; ++i) {             for (int j = 0; j < columns; ++j) {                 int p = r.nextInt(20) - 10;                 int q = r.nextInt(20) - 10;                 if (q == 0) {                     q = 1;                 }                 m.setEntry(i, j, Dfp25.of(p, q));             }         }         return m;     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert;  public class CholeskyDecompositionTest {      private double[][] testData = new double[][] {             {  1,  2,   4,   7,  11 },             {  2, 13,  23,  38,  58 },             {  4, 23,  77, 122, 182 },             {  7, 38, 122, 294, 430 },             { 11, 58, 182, 430, 855 }     };      /** test dimensions */     @Test     public void testDimensions() {         CholeskyDecomposition llt =             new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData));         Assert.assertEquals(testData.length, llt.getL().getRowDimension());         Assert.assertEquals(testData.length, llt.getL().getColumnDimension());         Assert.assertEquals(testData.length, llt.getLT().getRowDimension());         Assert.assertEquals(testData.length, llt.getLT().getColumnDimension());     }      /** test non-square matrix */     @Test(expected = NonSquareMatrixException.class)     public void testNonSquare() {         new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[3][2]));     }      /** test non-symmetric matrix */     @Test(expected = NonSymmetricMatrixException.class)     public void testNotSymmetricMatrixException() {         double[][] changed = testData.clone();         changed[0][changed[0].length - 1] += 1.0e-5;         new CholeskyDecomposition(MatrixUtils.createRealMatrix(changed));     }      /** test non positive definite matrix */     @Test(expected = NonPositiveDefiniteMatrixException.class)     public void testNotPositiveDefinite() {         new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] {                 { 14, 11, 13, 15, 24 },                 { 11, 34, 13, 8,  25 },                 { 13, 13, 14, 15, 21 },                 { 15, 8,  15, 18, 23 },                 { 24, 25, 21, 23, 45 }         }));     }      @Test(expected = NonPositiveDefiniteMatrixException.class)     public void testMath274() {         new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] {                 { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },                 {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },                 { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },                 { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }          }));     }      /** test A = LLT */     @Test     public void testAEqualLLT() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         CholeskyDecomposition llt = new CholeskyDecomposition(matrix);         RealMatrix l  = llt.getL();         RealMatrix lt = llt.getLT();         double norm = l.multiply(lt).subtract(matrix).getNorm();         Assert.assertEquals(0, norm, 1.0e-15);     }      /** test that L is lower triangular */     @Test     public void testLLowerTriangular() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         RealMatrix l = new CholeskyDecomposition(matrix).getL();         for (int i = 0; i < l.getRowDimension(); i++) {             for (int j = i + 1; j < l.getColumnDimension(); j++) {                 Assert.assertEquals(0.0, l.getEntry(i, j), 0.0);             }         }     }      /** test that LT is transpose of L */     @Test     public void testLTTransposed() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);         CholeskyDecomposition llt = new CholeskyDecomposition(matrix);         RealMatrix l  = llt.getL();         RealMatrix lt = llt.getLT();         double norm = l.subtract(lt.transpose()).getNorm();         Assert.assertEquals(0, norm, 1.0e-15);     }      /** test matrices values */     @Test     public void testMatricesValues() {         RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                 {  1,  0,  0,  0,  0 },                 {  2,  3,  0,  0,  0 },                 {  4,  5,  6,  0,  0 },                 {  7,  8,  9, 10,  0 },                 { 11, 12, 13, 14, 15 }         });        CholeskyDecomposition llt =             new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData));          // check values against known references         RealMatrix l = llt.getL();         Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);         RealMatrix lt = llt.getLT();         Assert.assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);          // check the same cached instance is returned the second time         Assert.assertTrue(l  == llt.getL());         Assert.assertTrue(lt == llt.getLT());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Iterator;  import org.apache.commons.math4.linear.RealVector.Entry; import org.junit.Assert; import org.junit.Ignore; import org.junit.Test;  /**  * Tests for {@link RealVector}.  */ public class RealVectorTest extends RealVectorAbstractTest{      @Override     public RealVector create(final double[] data) {         return new RealVectorTestImpl(data);     }      @Test     @Ignore("Abstract class RealVector does not implement append(RealVector).")     @Override     public void testAppendVector() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement append(double)")     @Override     public void testAppendScalar() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement getSubvector(int, int)")     @Override     public void testGetSubVector() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement getSubvector(int, int)")     @Override     public void testGetSubVectorInvalidIndex1() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement getSubvector(int, int)")     @Override     public void testGetSubVectorInvalidIndex2() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement getSubvector(int, int)")     @Override     public void testGetSubVectorInvalidIndex3() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement getSubvector(int, int)")     @Override     public void testGetSubVectorInvalidIndex4() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)")     @Override     public void testSetSubVectorSameType() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)")     @Override     public void testSetSubVectorMixedType() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)")     @Override     public void testSetSubVectorInvalidIndex1() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)")     @Override     public void testSetSubVectorInvalidIndex2() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)")     @Override     public void testSetSubVectorInvalidIndex3() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement isNaN()")     @Override     public void testIsNaN() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement isNaN()")     @Override     public void testIsInfinite() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement ebeMultiply(RealVector)")     @Override     public void testEbeMultiplySameType() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement ebeMultiply(RealVector)")     @Override     public void testEbeMultiplyMixedTypes() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement ebeMultiply(RealVector)")     @Override     public void testEbeMultiplyDimensionMismatch() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement ebeDivide(RealVector)")     @Override     public void testEbeDivideSameType() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement ebeDivide(RealVector)")     @Override     public void testEbeDivideMixedTypes() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement ebeDivide(RealVector)")     @Override     public void testEbeDivideDimensionMismatch() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement getL1Norm()")     @Override     public void testGetL1Norm() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not implement getLInfNorm()")     @Override     public void testGetLInfNorm() {         // Do nothing     }      @Test     public void testSparseIterator() {         /*          * For non-default values, use x + 1, x + 2, etc... to make sure that          * these values are really different from x.          */         final double x = getPreferredEntryValue();         final double[] data = {             x, x + 1d, x, x, x + 2d, x + 3d, x + 4d, x, x, x, x + 5d, x + 6d, x         };          RealVector v = create(data);         Entry e;         int i = 0;         final double[] nonDefault = {             x + 1d, x + 2d, x + 3d, x + 4d, x + 5d, x + 6d         };         for (Iterator<Entry> it = v.sparseIterator(); it.hasNext(); i++) {             e = it.next();             Assert.assertEquals(nonDefault[i], e.getValue(), 0);         }         double [] onlyOne = {x, x + 1d, x};         v = create(onlyOne);         for(Iterator<Entry> it = v.sparseIterator(); it.hasNext(); ) {             e = it.next();             Assert.assertEquals(onlyOne[1], e.getValue(), 0);         }     }      @Test     @Ignore("Abstract class RealVector is not serializable.")     @Override     public void testSerial() {         // Do nothing     }      @Test     @Ignore("Abstract class RealVector does not override equals(Object).")     @Override     public void testEquals() {         // Do nothing     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import java.util.Arrays;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.exception.MaxCountExceededException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.IterationEvent; import org.apache.commons.math4.util.IterationListener; import org.junit.Assert; import org.junit.Test;  public class ConjugateGradientTest {      @Test(expected = NonSquareOperatorException.class)     public void testNonSquareOperator() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 3);         final IterativeLinearSolver solver;         solver = new ConjugateGradient(10, 0., false);         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());         final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension());         solver.solve(a, b, x);     }      @Test(expected = DimensionMismatchException.class)     public void testDimensionMismatchRightHandSide() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);         final IterativeLinearSolver solver;         solver = new ConjugateGradient(10, 0., false);         final ArrayRealVector b = new ArrayRealVector(2);         final ArrayRealVector x = new ArrayRealVector(3);         solver.solve(a, b, x);     }      @Test(expected = DimensionMismatchException.class)     public void testDimensionMismatchSolution() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);         final IterativeLinearSolver solver;         solver = new ConjugateGradient(10, 0., false);         final ArrayRealVector b = new ArrayRealVector(3);         final ArrayRealVector x = new ArrayRealVector(2);         solver.solve(a, b, x);     }      @Test(expected = NonPositiveDefiniteOperatorException.class)     public void testNonPositiveDefiniteLinearOperator() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);         a.setEntry(0, 0, -1.);         a.setEntry(0, 1, 2.);         a.setEntry(1, 0, 3.);         a.setEntry(1, 1, 4.);         final IterativeLinearSolver solver;         solver = new ConjugateGradient(10, 0., true);         final ArrayRealVector b = new ArrayRealVector(2);         b.setEntry(0, -1.);         b.setEntry(1, -1.);         final ArrayRealVector x = new ArrayRealVector(2);         solver.solve(a, b, x);     }      @Test     public void testUnpreconditionedSolution() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final IterativeLinearSolver solver;         solver = new ConjugateGradient(maxIterations, 1E-10, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x = solver.solve(a, b);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-10 * FastMath.abs(expected);                 final String msg = String.format("entry[%d][%d]", i, j);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testUnpreconditionedInPlaceSolutionWithInitialGuess() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final IterativeLinearSolver solver;         solver = new ConjugateGradient(maxIterations, 1E-10, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x0 = new ArrayRealVector(n);             x0.set(1.);             final RealVector x = solver.solveInPlace(a, b, x0);             Assert.assertSame("x should be a reference to x0", x0, x);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-10 * FastMath.abs(expected);                 final String msg = String.format("entry[%d][%d)", i, j);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testUnpreconditionedSolutionWithInitialGuess() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final IterativeLinearSolver solver;         solver = new ConjugateGradient(maxIterations, 1E-10, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x0 = new ArrayRealVector(n);             x0.set(1.);             final RealVector x = solver.solve(a, b, x0);             Assert.assertNotSame("x should not be a reference to x0", x0, x);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-10 * FastMath.abs(expected);                 final String msg = String.format("entry[%d][%d]", i, j);                 Assert.assertEquals(msg, expected, actual, delta);                 Assert.assertEquals(msg, x0.getEntry(i), 1., Math.ulp(1.));             }         }     }      /**      * Check whether the estimate of the (updated) residual corresponds to the      * exact residual. This fails to be true for a large number of iterations,      * due to the loss of orthogonality of the successive search directions.      * Therefore, in the present test, the number of iterations is limited.      */     @Test     public void testUnpreconditionedResidual() {         final int n = 10;         final int maxIterations = n;         final RealLinearOperator a = new HilbertMatrix(n);         final ConjugateGradient solver;         solver = new ConjugateGradient(maxIterations, 1E-15, true);         final RealVector r = new ArrayRealVector(n);         final RealVector x = new ArrayRealVector(n);         final IterationListener listener = new IterationListener() {              @Override             public void terminationPerformed(final IterationEvent e) {                 // Do nothing             }              @Override             public void iterationStarted(final IterationEvent e) {                 // Do nothing             }              @Override             public void iterationPerformed(final IterationEvent e) {                 final IterativeLinearSolverEvent evt;                 evt = (IterativeLinearSolverEvent) e;                 RealVector v = evt.getResidual();                 r.setSubVector(0, v);                 v = evt.getSolution();                 x.setSubVector(0, v);             }              @Override             public void initializationPerformed(final IterationEvent e) {                 // Do nothing             }         };         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);              boolean caught = false;             try {                 solver.solve(a, b);             } catch (MaxCountExceededException e) {                 caught = true;                 final RealVector y = a.operate(x);                 for (int i = 0; i < n; i++) {                     final double actual = b.getEntry(i) - y.getEntry(i);                     final double expected = r.getEntry(i);                     final double delta = 1E-6 * FastMath.abs(expected);                     final String msg = String                         .format("column %d, residual %d", i, j);                     Assert.assertEquals(msg, expected, actual, delta);                 }             }             Assert                 .assertTrue("MaxCountExceededException should have been caught",                             caught);         }     }      @Test(expected = NonSquareOperatorException.class)     public void testNonSquarePreconditioner() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);         final RealLinearOperator m = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 throw new UnsupportedOperationException();             }              @Override             public int getRowDimension() {                 return 2;             }              @Override             public int getColumnDimension() {                 return 3;             }         };         final PreconditionedIterativeLinearSolver solver;         solver = new ConjugateGradient(10, 0d, false);         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());         solver.solve(a, m, b);     }      @Test(expected = DimensionMismatchException.class)     public void testMismatchedOperatorDimensions() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);         final RealLinearOperator m = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 throw new UnsupportedOperationException();             }              @Override             public int getRowDimension() {                 return 3;             }              @Override             public int getColumnDimension() {                 return 3;             }         };         final PreconditionedIterativeLinearSolver solver;         solver = new ConjugateGradient(10, 0d, false);         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());         solver.solve(a, m, b);     }      @Test(expected = NonPositiveDefiniteOperatorException.class)     public void testNonPositiveDefinitePreconditioner() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);         a.setEntry(0, 0, 1d);         a.setEntry(0, 1, 2d);         a.setEntry(1, 0, 3d);         a.setEntry(1, 1, 4d);         final RealLinearOperator m = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 final ArrayRealVector y = new ArrayRealVector(2);                 y.setEntry(0, -x.getEntry(0));                 y.setEntry(1, x.getEntry(1));                 return y;             }              @Override             public int getRowDimension() {                 return 2;             }              @Override             public int getColumnDimension() {                 return 2;             }         };         final PreconditionedIterativeLinearSolver solver;         solver = new ConjugateGradient(10, 0d, true);         final ArrayRealVector b = new ArrayRealVector(2);         b.setEntry(0, -1d);         b.setEntry(1, -1d);         solver.solve(a, m, b);     }      @Test     public void testPreconditionedSolution() {         final int n = 8;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final RealLinearOperator m = JacobiPreconditioner.create(a);         final PreconditionedIterativeLinearSolver solver;         solver = new ConjugateGradient(maxIterations, 1E-15, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x = solver.solve(a, m, b);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-6 * FastMath.abs(expected);                 final String msg = String.format("coefficient (%d, %d)", i, j);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testPreconditionedResidual() {         final int n = 10;         final int maxIterations = n;         final RealLinearOperator a = new HilbertMatrix(n);         final RealLinearOperator m = JacobiPreconditioner.create(a);         final ConjugateGradient solver;         solver = new ConjugateGradient(maxIterations, 1E-15, true);         final RealVector r = new ArrayRealVector(n);         final RealVector x = new ArrayRealVector(n);         final IterationListener listener = new IterationListener() {              @Override             public void terminationPerformed(final IterationEvent e) {                 // Do nothing             }              @Override             public void iterationStarted(final IterationEvent e) {                 // Do nothing             }              @Override             public void iterationPerformed(final IterationEvent e) {                 final IterativeLinearSolverEvent evt;                 evt = (IterativeLinearSolverEvent) e;                 RealVector v = evt.getResidual();                 r.setSubVector(0, v);                 v = evt.getSolution();                 x.setSubVector(0, v);             }              @Override             public void initializationPerformed(final IterationEvent e) {                 // Do nothing             }         };         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);          for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);              boolean caught = false;             try {                 solver.solve(a, m, b);             } catch (MaxCountExceededException e) {                 caught = true;                 final RealVector y = a.operate(x);                 for (int i = 0; i < n; i++) {                     final double actual = b.getEntry(i) - y.getEntry(i);                     final double expected = r.getEntry(i);                     final double delta = 1E-6 * FastMath.abs(expected);                     final String msg = String.format("column %d, residual %d", i, j);                     Assert.assertEquals(msg, expected, actual, delta);                 }             }             Assert.assertTrue("MaxCountExceededException should have been caught", caught);         }     }      @Test     public void testPreconditionedSolution2() {         final int n = 100;         final int maxIterations = 100000;         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(n, n);         double daux = 1.;         for (int i = 0; i < n; i++) {             a.setEntry(i, i, daux);             daux *= 1.2;             for (int j = i + 1; j < n; j++) {                 if (i == j) {                 } else {                     final double value = 1.0;                     a.setEntry(i, j, value);                     a.setEntry(j, i, value);                 }             }         }         final RealLinearOperator m = JacobiPreconditioner.create(a);         final PreconditionedIterativeLinearSolver pcg;         final IterativeLinearSolver cg;         pcg = new ConjugateGradient(maxIterations, 1E-6, true);         cg = new ConjugateGradient(maxIterations, 1E-6, true);         final RealVector b = new ArrayRealVector(n);         final String pattern = "preconditioned gradient (%d iterations) should"                                + " have been faster than unpreconditioned (%d iterations)";         String msg;         for (int j = 0; j < 1; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector px = pcg.solve(a, m, b);             final RealVector x = cg.solve(a, b);             final int npcg = pcg.getIterationManager().getIterations();             final int ncg = cg.getIterationManager().getIterations();             msg = String.format(pattern, npcg, ncg);             Assert.assertTrue(msg, npcg < ncg);             for (int i = 0; i < n; i++) {                 msg = String.format("row %d, column %d", i, j);                 final double expected = x.getEntry(i);                 final double actual = px.getEntry(i);                 final double delta = 1E-6 * FastMath.abs(expected);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testEventManagement() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final IterativeLinearSolver solver;         /*          * count[0] = number of calls to initializationPerformed          * count[1] = number of calls to iterationStarted          * count[2] = number of calls to iterationPerformed          * count[3] = number of calls to terminationPerformed          */         final int[] count = new int[] {0, 0, 0, 0};         final IterationListener listener = new IterationListener() {             private void doTestVectorsAreUnmodifiable(final IterationEvent e) {                 final IterativeLinearSolverEvent evt;                 evt = (IterativeLinearSolverEvent) e;                 try {                     evt.getResidual().set(0.0);                     Assert.fail("r is modifiable");                 } catch (MathUnsupportedOperationException exc){                     // Expected behavior                 }                 try {                     evt.getRightHandSideVector().set(0.0);                     Assert.fail("b is modifiable");                 } catch (MathUnsupportedOperationException exc){                     // Expected behavior                 }                 try {                     evt.getSolution().set(0.0);                     Assert.fail("x is modifiable");                 } catch (MathUnsupportedOperationException exc){                     // Expected behavior                 }             }              @Override             public void initializationPerformed(final IterationEvent e) {                 ++count[0];                 doTestVectorsAreUnmodifiable(e);             }              @Override             public void iterationPerformed(final IterationEvent e) {                 ++count[2];                 Assert.assertEquals("iteration performed",                     count[2], e.getIterations() - 1);                 doTestVectorsAreUnmodifiable(e);             }              @Override             public void iterationStarted(final IterationEvent e) {                 ++count[1];                 Assert.assertEquals("iteration started",                     count[1], e.getIterations() - 1);                 doTestVectorsAreUnmodifiable(e);             }              @Override             public void terminationPerformed(final IterationEvent e) {                 ++count[3];                 doTestVectorsAreUnmodifiable(e);             }         };         solver = new ConjugateGradient(maxIterations, 1E-10, true);         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             Arrays.fill(count, 0);             b.set(0.);             b.setEntry(j, 1.);             solver.solve(a, b);             String msg = String.format("column %d (initialization)", j);             Assert.assertEquals(msg, 1, count[0]);             msg = String.format("column %d (finalization)", j);             Assert.assertEquals(msg, 1, count[3]);         }     }      @Test     public void testUnpreconditionedNormOfResidual() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final IterativeLinearSolver solver;         final IterationListener listener = new IterationListener() {              private void doTestNormOfResidual(final IterationEvent e) {                 final IterativeLinearSolverEvent evt;                 evt = (IterativeLinearSolverEvent) e;                 final RealVector x = evt.getSolution();                 final RealVector b = evt.getRightHandSideVector();                 final RealVector r = b.subtract(a.operate(x));                 final double rnorm = r.getNorm();                 Assert.assertEquals("iteration performed (residual)",                     rnorm, evt.getNormOfResidual(),                     FastMath.max(1E-5 * rnorm, 1E-10));             }              @Override             public void initializationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationStarted(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void terminationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }         };         solver = new ConjugateGradient(maxIterations, 1E-10, true);         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             solver.solve(a, b);         }     }      @Test     public void testPreconditionedNormOfResidual() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final RealLinearOperator m = JacobiPreconditioner.create(a);         final PreconditionedIterativeLinearSolver solver;         final IterationListener listener = new IterationListener() {              private void doTestNormOfResidual(final IterationEvent e) {                 final IterativeLinearSolverEvent evt;                 evt = (IterativeLinearSolverEvent) e;                 final RealVector x = evt.getSolution();                 final RealVector b = evt.getRightHandSideVector();                 final RealVector r = b.subtract(a.operate(x));                 final double rnorm = r.getNorm();                 Assert.assertEquals("iteration performed (residual)",                     rnorm, evt.getNormOfResidual(),                     FastMath.max(1E-5 * rnorm, 1E-10));             }              @Override             public void initializationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationStarted(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void terminationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }         };         solver = new ConjugateGradient(maxIterations, 1E-10, true);         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             solver.solve(a, m, b);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import java.math.BigDecimal;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.dfp.Dfp; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link MatrixUtils} class.  *  */  public final class MatrixUtilsTest {      protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };     protected double[][] testData3x3Singular = { { 1, 4, 7, }, { 2, 5, 8, }, { 3, 6, 9, } };     protected double[][] testData3x4 = { { 12, -51, 4, 1 }, { 6, 167, -68, 2 }, { -4, 24, -41, 3 } };     protected double[][] nullMatrix = null;     protected double[] row = {1,2,3};     protected BigDecimal[] bigRow =         {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)};     protected String[] stringRow = {"1", "2", "3"};     protected Dfp[] fractionRow =         {Dfp25.of(1),Dfp25.of(2),Dfp25.of(3)};     protected double[][] rowMatrix = {{1,2,3}};     protected BigDecimal[][] bigRowMatrix =         {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}};     protected String[][] stringRowMatrix = {{"1", "2", "3"}};     protected Dfp[][] fractionRowMatrix =         {{Dfp25.of(1), Dfp25.of(2), Dfp25.of(3)}};     protected double[] col = {0,4,6};     protected BigDecimal[] bigCol =         {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)};     protected String[] stringCol = {"0","4","6"};     protected Dfp[] fractionCol =         {Dfp25.of(0),Dfp25.of(4),Dfp25.of(6)};     protected double[] nullDoubleArray = null;     protected double[][] colMatrix = {{0},{4},{6}};     protected BigDecimal[][] bigColMatrix =         {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}};     protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}};     protected Dfp[][] fractionColMatrix =         {{Dfp25.of(0)},{Dfp25.of(4)},{Dfp25.of(6)}};      @Test     public void testCreateRealMatrix() {         Assert.assertEquals(new BlockRealMatrix(testData),                 MatrixUtils.createRealMatrix(testData));         try {             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MatrixUtils.createRealMatrix(null);  // null             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testcreateFieldMatrix() {         Assert.assertEquals(new Array2DRowFieldMatrix<>(asDfp(testData)),                      MatrixUtils.createFieldMatrix(asDfp(testData)));         Assert.assertEquals(new Array2DRowFieldMatrix<>(Dfp25.getField(), fractionColMatrix),                      MatrixUtils.createFieldMatrix(fractionColMatrix));         try {             MatrixUtils.createFieldMatrix(asDfp(new double[][] {{1}, {1,2}}));  // ragged             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MatrixUtils.createFieldMatrix(asDfp(new double[][] {{}, {}}));  // no columns             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MatrixUtils.createFieldMatrix((Dfp[][])null);  // null             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testCreateRowRealMatrix() {         Assert.assertEquals(MatrixUtils.createRowRealMatrix(row),                      new BlockRealMatrix(rowMatrix));         try {             MatrixUtils.createRowRealMatrix(new double[] {});  // empty             Assert.fail("Expecting NotStrictlyPositiveException");         } catch (NotStrictlyPositiveException ex) {             // expected         }         try {             MatrixUtils.createRowRealMatrix(null);  // null             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testCreateRowFieldMatrix() {         Assert.assertEquals(MatrixUtils.createRowFieldMatrix(asDfp(row)),                      new Array2DRowFieldMatrix<>(asDfp(rowMatrix)));         Assert.assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),                      new Array2DRowFieldMatrix<>(fractionRowMatrix));         try {             MatrixUtils.createRowFieldMatrix(new Dfp[] {});  // empty             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MatrixUtils.createRowFieldMatrix((Dfp[]) null);  // null             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testCreateColumnRealMatrix() {         Assert.assertEquals(MatrixUtils.createColumnRealMatrix(col),                      new BlockRealMatrix(colMatrix));         try {             MatrixUtils.createColumnRealMatrix(new double[] {});  // empty             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MatrixUtils.createColumnRealMatrix(null);  // null             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testCreateColumnFieldMatrix() {         Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(asDfp(col)),                      new Array2DRowFieldMatrix<>(asDfp(colMatrix)));         Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),                      new Array2DRowFieldMatrix<>(fractionColMatrix));          try {             MatrixUtils.createColumnFieldMatrix(new Dfp[] {});  // empty             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             MatrixUtils.createColumnFieldMatrix((Dfp[]) null);  // null             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }     }      /**      * Verifies that the matrix is an identity matrix      */     protected void checkIdentityMatrix(RealMatrix m) {         for (int i = 0; i < m.getRowDimension(); i++) {             for (int j =0; j < m.getColumnDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(m.getEntry(i, j), 1d, 0);                 } else {                     Assert.assertEquals(m.getEntry(i, j), 0d, 0);                 }             }         }     }      @Test     public void testCreateIdentityMatrix() {         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));         try {             MatrixUtils.createRealIdentityMatrix(0);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      /**      * Verifies that the matrix is an identity matrix      */     protected void checkIdentityFieldMatrix(FieldMatrix<Dfp> m) {         for (int i = 0; i < m.getRowDimension(); i++) {             for (int j =0; j < m.getColumnDimension(); j++) {                 if (i == j) {                     Assert.assertEquals(m.getEntry(i, j), Dfp25.ONE);                 } else {                     Assert.assertEquals(m.getEntry(i, j), Dfp25.ZERO);                 }             }         }     }      @Test     public void testcreateFieldIdentityMatrix() {         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(Dfp25.getField(), 3));         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(Dfp25.getField(), 2));         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(Dfp25.getField(), 1));         try {             MatrixUtils.createRealIdentityMatrix(0);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      public static final Dfp[][] asDfp(double[][] data) {         Dfp d[][] = new Dfp[data.length][];         for (int i = 0; i < data.length; ++i) {             double[] dataI = data[i];             Dfp[] dI  = new Dfp[dataI.length];             for (int j = 0; j < dataI.length; ++j) {                 dI[j] = Dfp25.of(dataI[j]);             }             d[i] = dI;         }         return d;     }      public static final Dfp[] asDfp(double[] data) {         Dfp d[] = new Dfp[data.length];         for (int i = 0; i < data.length; ++i) {             d[i] = Dfp25.of(data[i]);         }          return d;     }      @Test     public void testSolveLowerTriangularSystem(){         RealMatrix rm = new Array2DRowRealMatrix(                 new double[][] { {2,0,0,0 }, { 1,1,0,0 }, { 3,3,3,0 }, { 3,3,3,4 } },                        false);         RealVector b = new ArrayRealVector(new double[] { 2,3,4,8 }, false);         MatrixUtils.solveLowerTriangularSystem(rm, b);         TestUtils.assertEquals( new double[]{1,2,-1.66666666666667, 1.0}  , b.toArray() , 1.0e-12);     }       /*      * Taken from R manual http://stat.ethz.ch/R-manual/R-patched/library/base/html/backsolve.html      */     @Test     public void testSolveUpperTriangularSystem(){         RealMatrix rm = new Array2DRowRealMatrix(                 new double[][] { {1,2,3 }, { 0,1,1 }, { 0,0,2 } },                        false);         RealVector b = new ArrayRealVector(new double[] { 8,4,2 }, false);         MatrixUtils.solveUpperTriangularSystem(rm, b);         TestUtils.assertEquals( new double[]{-1,3,1}  , b.toArray() , 1.0e-12);     }      /**      * This test should probably be replaced by one that could show      * whether this algorithm can sometimes perform better (precision- or      * performance-wise) than the direct inversion of the whole matrix.      */     @Test     public void testBlockInverse() {         final double[][] data = {             { -1, 0, 123, 4 },             { -56, 78.9, -0.1, -23.4 },             { 5.67, 8, -9, 1011 },             { 12, 345, -67.8, 9 },         };          final RealMatrix m = new Array2DRowRealMatrix(data);         final int len = data.length;         final double tol = 1e-14;          for (int splitIndex = 0; splitIndex < 3; splitIndex++) {             final RealMatrix mInv = MatrixUtils.blockInverse(m, splitIndex);             final RealMatrix id = m.multiply(mInv);              // Check that we recovered the identity matrix.             for (int i = 0; i < len; i++) {                 for (int j = 0; j < len; j++) {                     final double entry = id.getEntry(i, j);                     if (i == j) {                         Assert.assertEquals("[" + i + "][" + j + "]",                                             1, entry, tol);                     } else {                         Assert.assertEquals("[" + i + "][" + j + "]",                                             0, entry, tol);                     }                 }             }         }     }      @Test(expected=SingularMatrixException.class)     public void testBlockInverseNonInvertible() {         final double[][] data = {             { -1, 0, 123, 4 },             { -56, 78.9, -0.1, -23.4 },             { 5.67, 8, -9, 1011 },             { 5.67, 8, -9, 1011 },         };          MatrixUtils.blockInverse(new Array2DRowRealMatrix(data), 2);     }      @Test     public void testIsSymmetric() {         final double eps = Math.ulp(1d);          final double[][] dataSym = {             { 1, 2, 3 },             { 2, 2, 5 },             { 3, 5, 6 },         };         Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym), eps));          final double[][] dataNonSym = {             { 1, 2, -3 },             { 2, 2, 5 },             { 3, 5, 6 },         };         Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym), eps));     }      @Test     public void testIsSymmetricTolerance() {         final double eps = 1e-4;          final double[][] dataSym1 = {             { 1,   1, 1.00009 },             { 1,   1, 1       },             { 1.0, 1, 1       },         };         Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym1), eps));         final double[][] dataSym2 = {             { 1,   1, 0.99990 },             { 1,   1, 1       },             { 1.0, 1, 1       },         };         Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym2), eps));          final double[][] dataNonSym1 = {             { 1,   1, 1.00011 },             { 1,   1, 1       },             { 1.0, 1, 1       },         };         Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym1), eps));         final double[][] dataNonSym2 = {             { 1,   1, 0.99989 },             { 1,   1, 1       },             { 1.0, 1, 1       },         };         Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym2), eps));     }      @Test     public void testCheckSymmetric1() {         final double[][] dataSym = {             { 1, 2, 3 },             { 2, 2, 5 },             { 3, 5, 6 },         };         MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataSym), Math.ulp(1d));     }      @Test(expected=NonSymmetricMatrixException.class)     public void testCheckSymmetric2() {         final double[][] dataNonSym = {             { 1, 2, -3 },             { 2, 2, 5 },             { 3, 5, 6 },         };         MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataNonSym), Math.ulp(1d));     }      @Test(expected=SingularMatrixException.class)     public void testInverseSingular() {         RealMatrix m = MatrixUtils.createRealMatrix(testData3x3Singular);         MatrixUtils.inverse(m);     }      @Test(expected=NonSquareMatrixException.class)     public void testInverseNonSquare() {         RealMatrix m = MatrixUtils.createRealMatrix(testData3x4);         MatrixUtils.inverse(m);     }      @Test     public void testInverseDiagonalMatrix() {         final double[] data = { 1, 2, 3 };         final RealMatrix m = new DiagonalMatrix(data);         final RealMatrix inverse = MatrixUtils.inverse(m);          final RealMatrix result = m.multiply(inverse);         TestUtils.assertEquals("MatrixUtils.inverse() returns wrong result",                 MatrixUtils.createRealIdentityMatrix(data.length), result, Math.ulp(1d));     }      @Test     public void testInverseRealMatrix() {         RealMatrix m = MatrixUtils.createRealMatrix(testData);         final RealMatrix inverse = MatrixUtils.inverse(m);          final RealMatrix result = m.multiply(inverse);         TestUtils.assertEquals("MatrixUtils.inverse() returns wrong result",                 MatrixUtils.createRealIdentityMatrix(testData.length), result, 1e-12);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Random;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.rng.simple.RandomSource; import org.junit.Test; import org.junit.Assert;  public class HessenbergTransformerTest {      private double[][] testSquare5 = {             { 5, 4, 3, 2, 1 },             { 1, 4, 0, 3, 3 },             { 2, 0, 3, 0, 0 },             { 3, 2, 1, 2, 5 },             { 4, 2, 1, 4, 1 }     };      private double[][] testSquare3 = {             {  2, -1, 1 },             { -1,  2, 1 },             {  1, -1, 2 }     };      // from http://eigen.tuxfamily.org/dox/classEigen_1_1HessenbergDecomposition.html      private double[][] testRandom = {             {  0.680,  0.823, -0.4440, -0.2700 },             { -0.211, -0.605,  0.1080,  0.0268 },             {  0.566, -0.330, -0.0452,  0.9040 },             {  0.597,  0.536,  0.2580,  0.8320 }     };      @Test     public void testNonSquare() {         try {             new HessenbergTransformer(MatrixUtils.createRealMatrix(new double[3][2]));             Assert.fail("an exception should have been thrown");         } catch (NonSquareMatrixException ime) {             // expected behavior         }     }      @Test     public void testAEqualPHPt() {         checkAEqualPHPt(MatrixUtils.createRealMatrix(testSquare5));         checkAEqualPHPt(MatrixUtils.createRealMatrix(testSquare3));         checkAEqualPHPt(MatrixUtils.createRealMatrix(testRandom));    }      @Test     public void testPOrthogonal() {         checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getP());         checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getP());     }      @Test     public void testPTOrthogonal() {         checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getPT());         checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getPT());     }      @Test     public void testHessenbergForm() {         checkHessenbergForm(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getH());         checkHessenbergForm(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getH());     }      @Test     public void testRandomData() {         for (int run = 0; run < 100; run++) {             Random r = new Random(System.currentTimeMillis());              // matrix size             int size = r.nextInt(20) + 4;              double[][] data = new double[size][size];             for (int i = 0; i < size; i++) {                 for (int j = 0; j < size; j++) {                     data[i][j] = r.nextInt(100);                 }             }              RealMatrix m = MatrixUtils.createRealMatrix(data);             RealMatrix h = checkAEqualPHPt(m);             checkHessenbergForm(h);         }     }      @Test     public void testRandomDataNormalDistribution() {         for (int run = 0; run < 100; run++) {             Random r = new Random(System.currentTimeMillis());             ContinuousDistribution.Sampler dist                  = new NormalDistribution(0.0, r.nextDouble() * 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                                     64925784252L));              // matrix size             int size = r.nextInt(20) + 4;              double[][] data = new double[size][size];             for (int i = 0; i < size; i++) {                 for (int j = 0; j < size; j++) {                     data[i][j] = dist.sample();                 }             }              RealMatrix m = MatrixUtils.createRealMatrix(data);             RealMatrix h = checkAEqualPHPt(m);             checkHessenbergForm(h);         }     }      @Test     public void testMatricesValues5() {         checkMatricesValues(testSquare5,                             new double[][] {                                 { 1.0,  0.0,                0.0,                0.0,                0.0               },                                 { 0.0, -0.182574185835055,  0.784218758628863,  0.395029040913988, -0.442289115981669 },                                 { 0.0, -0.365148371670111, -0.337950625265477, -0.374110794088820, -0.782621974707823 },                                 { 0.0, -0.547722557505166,  0.402941130124223, -0.626468266309003,  0.381019628053472 },                                 { 0.0, -0.730296743340221, -0.329285224617644,  0.558149336547665,  0.216118545309225 }                             },                             new double[][] {                                 {  5.0,              -3.65148371670111,  2.59962019434982, -0.237003414680848, -3.13886458663398  },                                 { -5.47722557505166,  6.9,              -2.29164066120599,  0.207283564429169,  0.703858369151728 },                                 {  0.0,              -4.21386600008432,  2.30555659846067,  2.74935928725112,   0.857569835914113 },                                 {  0.0,               0.0,               2.86406180891882, -1.11582249161595,   0.817995267184158 },                                 {  0.0,               0.0,               0.0,               0.683518597386085,  1.91026589315528  }                             });     }      @Test     public void testMatricesValues3() {         checkMatricesValues(testSquare3,                             new double[][] {                                 {  1.0,  0.0,               0.0               },                                 {  0.0, -0.707106781186547, 0.707106781186547 },                                 {  0.0,  0.707106781186547, 0.707106781186548 },                             },                             new double[][] {                                 {  2.0,              1.41421356237309,  0.0 },                                 {  1.41421356237310, 2.0,              -1.0 },                                 {  0.0,              1.0,               2.0 },                             });     }      ///////////////////////////////////////////////////////////////////////////     // Test helpers     ///////////////////////////////////////////////////////////////////////////      private RealMatrix checkAEqualPHPt(RealMatrix matrix) {         HessenbergTransformer transformer = new HessenbergTransformer(matrix);         RealMatrix p  = transformer.getP();         RealMatrix pT = transformer.getPT();         RealMatrix h  = transformer.getH();          RealMatrix result = p.multiply(h).multiply(pT);         double norm = result.subtract(matrix).getNorm();         Assert.assertEquals(0, norm, 1.0e-10);          for (int i = 0; i < matrix.getRowDimension(); ++i) {             for (int j = 0; j < matrix.getColumnDimension(); ++j) {                 if (i > j + 1) {                     Assert.assertEquals(matrix.getEntry(i, j), result.getEntry(i, j), 1.0e-12);                 }             }         }          return transformer.getH();     }      private void checkOrthogonal(RealMatrix m) {         RealMatrix mTm = m.transpose().multiply(m);         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());         Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);     }      private void checkHessenbergForm(RealMatrix m) {         final int rows = m.getRowDimension();         final int cols = m.getColumnDimension();         for (int i = 0; i < rows; ++i) {             for (int j = 0; j < cols; ++j) {                 if (i > j + 1) {                     Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                 }             }         }     }      private void checkMatricesValues(double[][] matrix, double[][] pRef, double[][] hRef) {         HessenbergTransformer transformer =             new HessenbergTransformer(MatrixUtils.createRealMatrix(matrix));          // check values against known references         RealMatrix p = transformer.getP();         Assert.assertEquals(0, p.subtract(MatrixUtils.createRealMatrix(pRef)).getNorm(), 1.0e-14);          RealMatrix h = transformer.getH();         Assert.assertEquals(0, h.subtract(MatrixUtils.createRealMatrix(hRef)).getNorm(), 1.0e-14);          // check the same cached instance is returned the second time         Assert.assertTrue(p == transformer.getP());         Assert.assertTrue(h == transformer.getH());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import java.util.Arrays; import java.util.Random;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.util.FastMath;  /**  * Test cases for the {@link BlockRealMatrix} class.  *  */  public final class BlockRealMatrixTest {      // 3 x 3 identity matrix     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };      // Test data for group operations     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };     protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};     protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };     protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };     protected double[] testDataRow1 = {1d,2d,3d};     protected double[] testDataCol3 = {3d,3d,8d};     protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };     protected double[] preMultTest = {8,12,33};     protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};     protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};     protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };      // lu decomposition tests     protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };     protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},             {0.33333333333333,0d,0.33333333333333} };      // singular matrices     protected double[][] singular = { {2d,3d}, {2d,3d} };     protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},         {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd     protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };     protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};      // vectors     protected double[] testVector = {1,2,3};     protected double[] testVector2 = {1,2,3,4};      // submatrix accessor tests     protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},             {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections     protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};     protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};     protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};     // effective permutations     protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};     protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};     // contiguous ranges     protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};     protected double[][] subRows23Cols00 = {{2} , {4}};     protected double[][] subRows00Cols33 = {{4}};     // row matrices     protected double[][] subRow0 = {{1,2,3,4}};     protected double[][] subRow3 = {{4,5,6,7}};     // column matrices     protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};     protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};      // tolerances     protected double entryTolerance = 10E-16;     protected double normTolerance = 10E-14;      /** test dimensions */     @Test     public void testDimensions() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix m2 = new BlockRealMatrix(testData2);         Assert.assertEquals("testData row dimension",3,m.getRowDimension());         Assert.assertEquals("testData column dimension",3,m.getColumnDimension());         Assert.assertTrue("testData is square",m.isSquare());         Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);         Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);         Assert.assertTrue("testData2 is not square",!m2.isSquare());     }      /** test copy functions */     @Test     public void testCopyFunctions() {         Random r = new Random(66636328996002l);         BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);         BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());         Assert.assertEquals(m1, m2);         BlockRealMatrix m3 = new BlockRealMatrix(testData);         BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());         Assert.assertEquals(m3, m4);     }      /** test add */     @Test     public void testAdd() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);         RealMatrix mPlusMInv = m.add(mInv);         double[][] sumEntries = mPlusMInv.getData();         for (int row = 0; row < m.getRowDimension(); row++) {             for (int col = 0; col < m.getColumnDimension(); col++) {                 Assert.assertEquals("sum entry entry",                     testDataPlusInv[row][col],sumEntries[row][col],                         entryTolerance);             }         }     }      /** test add failure */     @Test     public void testAddFail() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix m2 = new BlockRealMatrix(testData2);         try {             m.add(m2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test norm */     @Test     public void testNorm() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix m2 = new BlockRealMatrix(testData2);         Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance);         Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);     }      /** test Frobenius norm */     @Test     public void testFrobeniusNorm() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix m2 = new BlockRealMatrix(testData2);         Assert.assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);         Assert.assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);     }      /** test m-n = m + -n */     @Test     public void testPlusMinus() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);         assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);         try {             m.subtract(new BlockRealMatrix(testData2));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test multiply */     @Test     public void testMultiply() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);         BlockRealMatrix identity = new BlockRealMatrix(id);         BlockRealMatrix m2 = new BlockRealMatrix(testData2);         assertClose(m.multiply(mInv), identity, entryTolerance);         assertClose(mInv.multiply(m), identity, entryTolerance);         assertClose(m.multiply(identity), m, entryTolerance);         assertClose(identity.multiply(mInv), mInv, entryTolerance);         assertClose(m2.multiply(identity), m2, entryTolerance);         try {             m.multiply(new BlockRealMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      @Test     public void testSeveralBlocks() {         RealMatrix m = new BlockRealMatrix(35, 71);         for (int i = 0; i < m.getRowDimension(); ++i) {             for (int j = 0; j < m.getColumnDimension(); ++j) {                 m.setEntry(i, j, i + j / 1024.0);             }         }          RealMatrix mT = m.transpose();         Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension());         Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension());         for (int i = 0; i < mT.getRowDimension(); ++i) {             for (int j = 0; j < mT.getColumnDimension(); ++j) {                 Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);             }         }          RealMatrix mPm = m.add(m);         for (int i = 0; i < mPm.getRowDimension(); ++i) {             for (int j = 0; j < mPm.getColumnDimension(); ++j) {                 Assert.assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);             }         }          RealMatrix mPmMm = mPm.subtract(m);         for (int i = 0; i < mPmMm.getRowDimension(); ++i) {             for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                 Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);             }         }          RealMatrix mTm = mT.multiply(m);         for (int i = 0; i < mTm.getRowDimension(); ++i) {             for (int j = 0; j < mTm.getColumnDimension(); ++j) {                 double sum = 0;                 for (int k = 0; k < mT.getColumnDimension(); ++k) {                     sum += (k + i / 1024.0) * (k + j / 1024.0);                 }                 Assert.assertEquals(sum, mTm.getEntry(i, j), 0);             }         }          RealMatrix mmT = m.multiply(mT);         for (int i = 0; i < mmT.getRowDimension(); ++i) {             for (int j = 0; j < mmT.getColumnDimension(); ++j) {                 double sum = 0;                 for (int k = 0; k < m.getColumnDimension(); ++k) {                     sum += (i + k / 1024.0) * (j + k / 1024.0);                 }                 Assert.assertEquals(sum, mmT.getEntry(i, j), 0);             }         }          RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);         for (int i = 0; i < sub1.getRowDimension(); ++i) {             for (int j = 0; j < sub1.getColumnDimension(); ++j) {                 Assert.assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);             }         }          RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);         for (int i = 0; i < sub2.getRowDimension(); ++i) {             for (int j = 0; j < sub2.getColumnDimension(); ++j) {                 Assert.assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);             }         }          RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);         for (int i = 0; i < sub3.getRowDimension(); ++i) {             for (int j = 0; j < sub3.getColumnDimension(); ++j) {                 Assert.assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);             }         }          RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);         for (int i = 0; i < sub4.getRowDimension(); ++i) {             for (int j = 0; j < sub4.getColumnDimension(); ++j) {                 Assert.assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);             }         }      }      //Additional Test for BlockRealMatrixTest.testMultiply      private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};     private double[][] d4 = new double[][] {{1},{2},{3},{4}};     private double[][] d5 = new double[][] {{30},{70}};      @Test     public void testMultiply2() {         RealMatrix m3 = new BlockRealMatrix(d3);         RealMatrix m4 = new BlockRealMatrix(d4);         RealMatrix m5 = new BlockRealMatrix(d5);         assertClose(m3.multiply(m4), m5, entryTolerance);     }      /** test trace */     @Test     public void testTrace() {         RealMatrix m = new BlockRealMatrix(id);         Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance);         m = new BlockRealMatrix(testData2);         try {             m.getTrace();             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }     }      /** test scalarAdd */     @Test     public void testScalarAdd() {         RealMatrix m = new BlockRealMatrix(testData);         assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);     }      /** test operate */     @Test     public void testOperate() {         RealMatrix m = new BlockRealMatrix(id);         assertClose(testVector, m.operate(testVector), entryTolerance);         assertClose(testVector, m.operate(new ArrayRealVector(testVector)).toArray(), entryTolerance);         m = new BlockRealMatrix(bigSingular);         try {             m.operate(testVector);             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testOperateLarge() {         int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;         int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;         int r =  3 * BlockRealMatrix.BLOCK_SIZE;         Random random = new Random(111007463902334l);         RealMatrix m1 = createRandomMatrix(random, p, q);         RealMatrix m2 = createRandomMatrix(random, q, r);         RealMatrix m1m2 = m1.multiply(m2);         for (int i = 0; i < r; ++i) {             checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));         }     }      @Test     public void testOperatePremultiplyLarge() {         int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;         int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;         int r =  3 * BlockRealMatrix.BLOCK_SIZE;         Random random = new Random(111007463902334l);         RealMatrix m1 = createRandomMatrix(random, p, q);         RealMatrix m2 = createRandomMatrix(random, q, r);         RealMatrix m1m2 = m1.multiply(m2);         for (int i = 0; i < p; ++i) {             checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));         }     }      /** test issue MATH-209 */     @Test     public void testMath209() {         RealMatrix a = new BlockRealMatrix(new double[][] {                 { 1, 2 }, { 3, 4 }, { 5, 6 }         });         double[] b = a.operate(new double[] { 1, 1 });         Assert.assertEquals(a.getRowDimension(), b.length);         Assert.assertEquals( 3.0, b[0], 1.0e-12);         Assert.assertEquals( 7.0, b[1], 1.0e-12);         Assert.assertEquals(11.0, b[2], 1.0e-12);     }      /** test transpose */     @Test     public void testTranspose() {         RealMatrix m = new BlockRealMatrix(testData);         RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose();         RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse();         assertClose(mIT, mTI, normTolerance);         m = new BlockRealMatrix(testData2);         RealMatrix mt = new BlockRealMatrix(testData2T);         assertClose(mt, m.transpose(), normTolerance);     }      /** test preMultiply by vector */     @Test     public void testPremultiplyVector() {         RealMatrix m = new BlockRealMatrix(testData);         assertClose(m.preMultiply(testVector), preMultTest, normTolerance);         assertClose(m.preMultiply(new ArrayRealVector(testVector).toArray()),                     preMultTest, normTolerance);         m = new BlockRealMatrix(bigSingular);         try {             m.preMultiply(testVector);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testPremultiply() {         RealMatrix m3 = new BlockRealMatrix(d3);         RealMatrix m4 = new BlockRealMatrix(d4);         RealMatrix m5 = new BlockRealMatrix(d5);         assertClose(m4.preMultiply(m3), m5, entryTolerance);          BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);         BlockRealMatrix identity = new BlockRealMatrix(id);         assertClose(m.preMultiply(mInv), identity, entryTolerance);         assertClose(mInv.preMultiply(m), identity, entryTolerance);         assertClose(m.preMultiply(identity), m, entryTolerance);         assertClose(identity.preMultiply(mInv), mInv, entryTolerance);         try {             m.preMultiply(new BlockRealMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testGetVectors() {         RealMatrix m = new BlockRealMatrix(testData);         assertClose(m.getRow(0), testDataRow1, entryTolerance);         assertClose(m.getColumn(2), testDataCol3, entryTolerance);         try {             m.getRow(10);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }         try {             m.getColumn(-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }     }      @Test     public void testGetEntry() {         RealMatrix m = new BlockRealMatrix(testData);         Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);         try {             m.getEntry(10, 4);             Assert.fail ("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      /** test examples in user guide */     @Test     public void testExamples() {         // Create a real matrix with two rows and three columns         double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};         RealMatrix m = new BlockRealMatrix(matrixData);         // One more with three rows, two columns         double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};         RealMatrix n = new BlockRealMatrix(matrixData2);         // Now multiply m by n         RealMatrix p = m.multiply(n);         Assert.assertEquals(2, p.getRowDimension());         Assert.assertEquals(2, p.getColumnDimension());         // Invert p         RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse();         Assert.assertEquals(2, pInverse.getRowDimension());         Assert.assertEquals(2, pInverse.getColumnDimension());          // Solve example         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};         RealMatrix coefficients = new BlockRealMatrix(coefficientsData);         RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false);         RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants);         final double cst0 = constants.getEntry(0);         final double cst1 = constants.getEntry(1);         final double cst2 = constants.getEntry(2);         final double sol0 = solution.getEntry(0);         final double sol1 = solution.getEntry(1);         final double sol2 = solution.getEntry(2);         Assert.assertEquals(2 * sol0 + 3 * sol1 -2 * sol2, cst0, 1E-12);         Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12);         Assert.assertEquals(4 * sol0 - 3 * sol1 -5 * sol2, cst2, 1E-12);     }      // test submatrix accessors     @Test     public void testGetSubMatrix() {         RealMatrix m = new BlockRealMatrix(subTestData);         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);         checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);         checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });         checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });         checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkGetSubMatrix(m, null,  1, 0, 2, 4);         checkGetSubMatrix(m, null, -1, 1, 2, 2);         checkGetSubMatrix(m, null,  1, 0, 2, 2);         checkGetSubMatrix(m, null,  1, 0, 2, 4);         checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });         checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });     }      private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                    int startRow, int endRow, int startColumn, int endColumn) {         try {             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);             if (reference != null) {                 Assert.assertEquals(new BlockRealMatrix(reference), sub);             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                    int[] selectedRows, int[] selectedColumns) {         try {             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);             if (reference != null) {                 Assert.assertEquals(new BlockRealMatrix(reference), sub);             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      @Test     public void testGetSetMatrixLarge() {         int n = 3 * BlockRealMatrix.BLOCK_SIZE;         RealMatrix m = new BlockRealMatrix(n, n);         RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1);          m.setSubMatrix(sub.getData(), 2, 2);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                     Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                 } else {                     Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                 }             }         }         Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));      }      @Test     public void testCopySubMatrix() {         RealMatrix m = new BlockRealMatrix(subTestData);         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);         checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);         checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });         checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });         checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });          checkCopy(m, null,  1, 0, 2, 4);         checkCopy(m, null, -1, 1, 2, 2);         checkCopy(m, null,  1, 0, 2, 2);         checkCopy(m, null,  1, 0, 2, 4);         checkCopy(m, null, new int[] {},    new int[] { 0 });         checkCopy(m, null, new int[] { 0 }, new int[] { 4 });     }      private void checkCopy(RealMatrix m, double[][] reference,                            int startRow, int endRow, int startColumn, int endColumn) {         try {             double[][] sub = (reference == null) ?                              new double[1][1] :                              new double[reference.length][reference[0].length];             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);             if (reference != null) {                 Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      private void checkCopy(RealMatrix m, double[][] reference,                            int[] selectedRows, int[] selectedColumns) {         try {             double[][] sub = (reference == null) ?                     new double[1][1] :                     new double[reference.length][reference[0].length];             m.copySubMatrix(selectedRows, selectedColumns, sub);             if (reference != null) {                 Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));             } else {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (reference != null) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (reference != null) {                 throw e;             }         } catch (NoDataException e) {             if (reference != null) {                 throw e;             }         }     }      @Test     public void testGetRowMatrix() {         RealMatrix m     = new BlockRealMatrix(subTestData);         RealMatrix mRow0 = new BlockRealMatrix(subRow0);         RealMatrix mRow3 = new BlockRealMatrix(subRow3);         Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));         Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));         try {             m.getRowMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowMatrix() {         RealMatrix m = new BlockRealMatrix(subTestData);         RealMatrix mRow3 = new BlockRealMatrix(subRow3);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowMatrix(0, mRow3);         Assert.assertEquals(mRow3, m.getRowMatrix(0));         try {             m.setRowMatrix(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetRowMatrixLarge() {         int n = 3 * BlockRealMatrix.BLOCK_SIZE;         RealMatrix m = new BlockRealMatrix(n, n);         RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1);          m.setRowMatrix(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (i != 2) {                     Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                 } else {                     Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                 }             }         }         Assert.assertEquals(sub, m.getRowMatrix(2));     }      @Test     public void testGetColumnMatrix() {         RealMatrix m = new BlockRealMatrix(subTestData);         RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);         RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);         Assert.assertEquals(mColumn1, m.getColumnMatrix(1));         Assert.assertEquals(mColumn3, m.getColumnMatrix(3));         try {             m.getColumnMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnMatrix() {         RealMatrix m = new BlockRealMatrix(subTestData);         RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));         m.setColumnMatrix(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnMatrix(1));         try {             m.setColumnMatrix(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetColumnMatrixLarge() {         int n = 3 * BlockRealMatrix.BLOCK_SIZE;         RealMatrix m = new BlockRealMatrix(n, n);         RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1);          m.setColumnMatrix(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (j != 2) {                     Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                 } else {                     Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                 }             }         }         Assert.assertEquals(sub, m.getColumnMatrix(2));      }      @Test     public void testGetRowVector() {         RealMatrix m = new BlockRealMatrix(subTestData);         RealVector mRow0 = new ArrayRealVector(subRow0[0]);         RealVector mRow3 = new ArrayRealVector(subRow3[0]);         Assert.assertEquals(mRow0, m.getRowVector(0));         Assert.assertEquals(mRow3, m.getRowVector(3));         try {             m.getRowVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowVector() {         RealMatrix m = new BlockRealMatrix(subTestData);         RealVector mRow3 = new ArrayRealVector(subRow3[0]);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowVector(0, mRow3);         Assert.assertEquals(mRow3, m.getRowVector(0));         try {             m.setRowVector(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowVector(0, new ArrayRealVector(5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetRowVectorLarge() {         int n = 3 * BlockRealMatrix.BLOCK_SIZE;         RealMatrix m = new BlockRealMatrix(n, n);         RealVector sub = new ArrayRealVector(n, 1.0);          m.setRowVector(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (i != 2) {                     Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                 } else {                     Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                 }             }         }         Assert.assertEquals(sub, m.getRowVector(2));     }      @Test     public void testGetColumnVector() {         RealMatrix m = new BlockRealMatrix(subTestData);         RealVector mColumn1 = columnToVector(subColumn1);         RealVector mColumn3 = columnToVector(subColumn3);         Assert.assertEquals(mColumn1, m.getColumnVector(1));         Assert.assertEquals(mColumn3, m.getColumnVector(3));         try {             m.getColumnVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnVector() {         RealMatrix m = new BlockRealMatrix(subTestData);         RealVector mColumn3 = columnToVector(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnVector(1));         m.setColumnVector(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnVector(1));         try {             m.setColumnVector(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnVector(0, new ArrayRealVector(5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetColumnVectorLarge() {         int n = 3 * BlockRealMatrix.BLOCK_SIZE;         RealMatrix m = new BlockRealMatrix(n, n);         RealVector sub = new ArrayRealVector(n, 1.0);          m.setColumnVector(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (j != 2) {                     Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                 } else {                     Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                 }             }         }         Assert.assertEquals(sub, m.getColumnVector(2));     }      private RealVector columnToVector(double[][] column) {         double[] data = new double[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return new ArrayRealVector(data, false);     }      @Test     public void testGetRow() {         RealMatrix m = new BlockRealMatrix(subTestData);         checkArrays(subRow0[0], m.getRow(0));         checkArrays(subRow3[0], m.getRow(3));         try {             m.getRow(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRow(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRow() {         RealMatrix m = new BlockRealMatrix(subTestData);         Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);         m.setRow(0, subRow3[0]);         checkArrays(subRow3[0], m.getRow(0));         try {             m.setRow(-1, subRow3[0]);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRow(0, new double[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetRowLarge() {         int n = 3 * BlockRealMatrix.BLOCK_SIZE;         RealMatrix m = new BlockRealMatrix(n, n);         double[] sub = new double[n];         Arrays.fill(sub, 1.0);          m.setRow(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (i != 2) {                     Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                 } else {                     Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                 }             }         }         checkArrays(sub, m.getRow(2));     }      @Test     public void testGetColumn() {         RealMatrix m = new BlockRealMatrix(subTestData);         double[] mColumn1 = columnToArray(subColumn1);         double[] mColumn3 = columnToArray(subColumn3);         checkArrays(mColumn1, m.getColumn(1));         checkArrays(mColumn3, m.getColumn(3));         try {             m.getColumn(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumn(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumn() {         RealMatrix m = new BlockRealMatrix(subTestData);         double[] mColumn3 = columnToArray(subColumn3);         Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);         m.setColumn(1, mColumn3);         checkArrays(mColumn3, m.getColumn(1));         try {             m.setColumn(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumn(0, new double[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetSetColumnLarge() {         int n = 3 * BlockRealMatrix.BLOCK_SIZE;         RealMatrix m = new BlockRealMatrix(n, n);         double[] sub = new double[n];         Arrays.fill(sub, 1.0);          m.setColumn(2, sub);         for (int i = 0; i < n; ++i) {             for (int j = 0; j < n; ++j) {                 if (j != 2) {                     Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                 } else {                     Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                 }             }         }         checkArrays(sub, m.getColumn(2));     }      private double[] columnToArray(double[][] column) {         double[] data = new double[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return data;     }      private void checkArrays(double[] expected, double[] actual) {         Assert.assertEquals(expected.length, actual.length);         for (int i = 0; i < expected.length; ++i) {             Assert.assertEquals(expected[i], actual[i], 0);         }     }      @Test     public void testEqualsAndHashCode() {         BlockRealMatrix m = new BlockRealMatrix(testData);         BlockRealMatrix m1 = m.copy();         BlockRealMatrix mt = m.transpose();         Assert.assertTrue(m.hashCode() != mt.hashCode());         Assert.assertEquals(m.hashCode(), m1.hashCode());         Assert.assertEquals(m, m);         Assert.assertEquals(m, m1);         Assert.assertFalse(m.equals(null));         Assert.assertFalse(m.equals(mt));         Assert.assertFalse(m.equals(new BlockRealMatrix(bigSingular)));     }      @Test     public void testToString() {         BlockRealMatrix m = new BlockRealMatrix(testData);         Assert.assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                 m.toString());     }      @Test     public void testSetSubMatrix() {         BlockRealMatrix m = new BlockRealMatrix(testData);         m.setSubMatrix(detData2,1,1);         RealMatrix expected = new BlockRealMatrix             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});         Assert.assertEquals(expected, m);          m.setSubMatrix(detData2,0,0);         expected = new BlockRealMatrix             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});         Assert.assertEquals(expected, m);          m.setSubMatrix(testDataPlus2,0,0);         expected = new BlockRealMatrix             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});         Assert.assertEquals(expected, m);          // javadoc example         BlockRealMatrix matrix = new BlockRealMatrix             (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});         matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);         expected = new BlockRealMatrix             (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});         Assert.assertEquals(expected, matrix);          // dimension overflow         try {             m.setSubMatrix(testData,1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         // dimension underflow         try {             m.setSubMatrix(testData,-1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         try {             m.setSubMatrix(testData,1,-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }          // null         try {             m.setSubMatrix(null,1,1);             Assert.fail("expecting NullArgumentException");         } catch (NullArgumentException e) {             // expected         }          // ragged         try {             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // empty         try {             m.setSubMatrix(new double[][] {{}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }     }      @Test     public void testWalk() {         int rows    = 150;         int columns = 75;          RealMatrix m = new BlockRealMatrix(rows, columns);         m.walkInRowOrder(new SetVisitor());         GetVisitor getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockRealMatrix(rows, columns);         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }          m = new BlockRealMatrix(rows, columns);         m.walkInColumnOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockRealMatrix(rows, columns);         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }          m = new BlockRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }          m = new BlockRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new BlockRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }      }      @Test     public void testSerial()  {         BlockRealMatrix m = new BlockRealMatrix(testData);         Assert.assertEquals(m,TestUtils.serializeAndRecover(m));     }      private static class SetVisitor extends DefaultRealMatrixChangingVisitor {         @Override         public double visit(int i, int j, double value) {             return i + j / 1024.0;         }     }      private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {         private int count = 0;         @Override         public void visit(int i, int j, double value) {             ++count;             Assert.assertEquals(i + j / 1024.0, value, 0.0);         }         public int getCount() {             return count;         }     }      //--------------- -----------------Protected methods      /** verifies that two matrices are close (1-norm) */     protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {         Assert.assertTrue(m.subtract(n).getNorm() < tolerance);     }      /** verifies that two vectors are close (sup norm) */     protected void assertClose(double[] m, double[] n, double tolerance) {         if (m.length != n.length) {             Assert.fail("vectors not same length");         }         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(m[i], n[i], tolerance);         }     }      private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) {         BlockRealMatrix m = new BlockRealMatrix(rows, columns);         for (int i = 0; i < rows; ++i) {             for (int j = 0; j < columns; ++j) {                 m.setEntry(i, j, 200 * r.nextDouble() - 100);             }         }         return m;     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import java.util.Arrays;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.IterationEvent; import org.apache.commons.math4.util.IterationListener; import org.junit.Assert; import org.junit.Test;  public class SymmLQTest {      public void saundersTest(final int n, final boolean goodb,                              final boolean precon, final double shift,                              final double pertbn) {         final RealLinearOperator a = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 if (x.getDimension() != n) {                     throw new DimensionMismatchException(x.getDimension(), n);                 }                 final double[] y = new double[n];                 for (int i = 0; i < n; i++) {                     y[i] = (i + 1) * 1.1 / n * x.getEntry(i);                 }                 return new ArrayRealVector(y, false);             }              @Override             public int getRowDimension() {                 return n;             }              @Override             public int getColumnDimension() {                 return n;             }         };         final double shiftm = shift;         final double pertm = FastMath.abs(pertbn);         final RealLinearOperator minv;         if (precon) {             minv = new RealLinearOperator() {                 @Override                 public int getRowDimension() {                     return n;                 }                  @Override                 public int getColumnDimension() {                     return n;                 }                  @Override                 public RealVector operate(final RealVector x) {                     if (x.getDimension() != n) {                         throw new DimensionMismatchException(x.getDimension(),                                                              n);                     }                     final double[] y = new double[n];                     for (int i = 0; i < n; i++) {                         double d = (i + 1) * 1.1 / n;                         d = FastMath.abs(d - shiftm);                         if (i % 10 == 0) {                             d += pertm;                         }                         y[i] = x.getEntry(i) / d;                     }                     return new ArrayRealVector(y, false);                 }             };         } else {             minv = null;         }         final RealVector xtrue = new ArrayRealVector(n);         for (int i = 0; i < n; i++) {             xtrue.setEntry(i, n - i);         }         final RealVector b = a.operate(xtrue);         b.combineToSelf(1.0, -shift, xtrue);         final SymmLQ solver = new SymmLQ(2 * n, 1E-12, true);         final RealVector x = solver.solve(a, minv, b, goodb, shift);         final RealVector y = a.operate(x);         final RealVector r1 = new ArrayRealVector(n);         for (int i = 0; i < n; i++) {             final double bi = b.getEntry(i);             final double yi = y.getEntry(i);             final double xi = x.getEntry(i);             r1.setEntry(i, bi - yi + shift * xi);         }         final double enorm = x.subtract(xtrue).getNorm() / xtrue.getNorm();         final double etol = 1E-5;         Assert.assertTrue("enorm=" + enorm + ", " +         solver.getIterationManager().getIterations(), enorm <= etol);     }      @Test     public void testSolveSaunders1() {         saundersTest(1, false, false, 0., 0.);     }      @Test     public void testSolveSaunders2() {         saundersTest(2, false, false, 0., 0.);     }      @Test     public void testSolveSaunders3() {         saundersTest(1, false, true, 0., 0.);     }      @Test     public void testSolveSaunders4() {         saundersTest(2, false, true, 0., 0.);     }      @Test     public void testSolveSaunders5() {         saundersTest(5, false, true, 0., 0.);     }      @Test     public void testSolveSaunders6() {         saundersTest(5, false, true, 0.25, 0.);     }      @Test     public void testSolveSaunders7() {         saundersTest(50, false, false, 0., 0.);     }      @Test     public void testSolveSaunders8() {         saundersTest(50, false, false, 0.25, 0.);     }      @Test     public void testSolveSaunders9() {         saundersTest(50, false, true, 0., 0.10);     }      @Test     public void testSolveSaunders10() {         saundersTest(50, false, true, 0.25, 0.10);     }      @Test     public void testSolveSaunders11() {         saundersTest(1, true, false, 0., 0.);     }      @Test     public void testSolveSaunders12() {         saundersTest(2, true, false, 0., 0.);     }      @Test     public void testSolveSaunders13() {         saundersTest(1, true, true, 0., 0.);     }      @Test     public void testSolveSaunders14() {         saundersTest(2, true, true, 0., 0.);     }      @Test     public void testSolveSaunders15() {         saundersTest(5, true, true, 0., 0.);     }      @Test     public void testSolveSaunders16() {         saundersTest(5, true, true, 0.25, 0.);     }      @Test     public void testSolveSaunders17() {         saundersTest(50, true, false, 0., 0.);     }      @Test     public void testSolveSaunders18() {         saundersTest(50, true, false, 0.25, 0.);     }      @Test     public void testSolveSaunders19() {         saundersTest(50, true, true, 0., 0.10);     }      @Test     public void testSolveSaunders20() {         saundersTest(50, true, true, 0.25, 0.10);     }      @Test(expected = NonSquareOperatorException.class)     public void testNonSquareOperator() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 3);         final IterativeLinearSolver solver;         solver = new SymmLQ(10, 0., false);         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());         final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension());         solver.solve(a, b, x);     }      @Test(expected = DimensionMismatchException.class)     public void testDimensionMismatchRightHandSide() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);         final IterativeLinearSolver solver;         solver = new SymmLQ(10, 0., false);         final ArrayRealVector b = new ArrayRealVector(2);         solver.solve(a, b);     }      @Test(expected = DimensionMismatchException.class)     public void testDimensionMismatchSolution() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);         final IterativeLinearSolver solver;         solver = new SymmLQ(10, 0., false);         final ArrayRealVector b = new ArrayRealVector(3);         final ArrayRealVector x = new ArrayRealVector(2);         solver.solve(a, b, x);     }      @Test     public void testUnpreconditionedSolution() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final IterativeLinearSolver solver;         solver = new SymmLQ(maxIterations, 1E-10, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x = solver.solve(a, b);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-6 * FastMath.abs(expected);                 final String msg = String.format("entry[%d][%d]", i, j);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testUnpreconditionedInPlaceSolutionWithInitialGuess() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final IterativeLinearSolver solver;         solver = new SymmLQ(maxIterations, 1E-10, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x0 = new ArrayRealVector(n);             x0.set(1.);             final RealVector x = solver.solveInPlace(a, b, x0);             Assert.assertSame("x should be a reference to x0", x0, x);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-6 * FastMath.abs(expected);                 final String msg = String.format("entry[%d][%d)", i, j);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testUnpreconditionedSolutionWithInitialGuess() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final IterativeLinearSolver solver;         solver = new SymmLQ(maxIterations, 1E-10, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x0 = new ArrayRealVector(n);             x0.set(1.);             final RealVector x = solver.solve(a, b, x0);             Assert.assertNotSame("x should not be a reference to x0", x0, x);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-6 * FastMath.abs(expected);                 final String msg = String.format("entry[%d][%d]", i, j);                 Assert.assertEquals(msg, expected, actual, delta);                 Assert.assertEquals(msg, x0.getEntry(i), 1., Math.ulp(1.));             }         }     }      @Test(expected = NonSquareOperatorException.class)     public void testNonSquarePreconditioner() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);         final RealLinearOperator m = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 throw new UnsupportedOperationException();             }              @Override             public int getRowDimension() {                 return 2;             }              @Override             public int getColumnDimension() {                 return 3;             }         };         final PreconditionedIterativeLinearSolver solver;         solver = new SymmLQ(10, 0., false);         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());         solver.solve(a, m, b);     }      @Test(expected = DimensionMismatchException.class)     public void testMismatchedOperatorDimensions() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);         final RealLinearOperator m = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 throw new UnsupportedOperationException();             }              @Override             public int getRowDimension() {                 return 3;             }              @Override             public int getColumnDimension() {                 return 3;             }         };         final PreconditionedIterativeLinearSolver solver;         solver = new SymmLQ(10, 0d, false);         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());         solver.solve(a, m, b);     }      @Test(expected = NonPositiveDefiniteOperatorException.class)     public void testNonPositiveDefinitePreconditioner() {         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);         a.setEntry(0, 0, 1d);         a.setEntry(0, 1, 2d);         a.setEntry(1, 0, 3d);         a.setEntry(1, 1, 4d);         final RealLinearOperator m = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 final ArrayRealVector y = new ArrayRealVector(2);                 y.setEntry(0, -x.getEntry(0));                 y.setEntry(1, -x.getEntry(1));                 return y;             }              @Override             public int getRowDimension() {                 return 2;             }              @Override             public int getColumnDimension() {                 return 2;             }         };         final PreconditionedIterativeLinearSolver solver;         solver = new SymmLQ(10, 0d, true);         final ArrayRealVector b = new ArrayRealVector(2);         b.setEntry(0, -1d);         b.setEntry(1, -1d);         solver.solve(a, m, b);     }      @Test     public void testPreconditionedSolution() {         final int n = 8;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);         final RealLinearOperator m = JacobiPreconditioner.create(a);         final PreconditionedIterativeLinearSolver solver;         solver = new SymmLQ(maxIterations, 1E-15, true);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector x = solver.solve(a, m, b);             for (int i = 0; i < n; i++) {                 final double actual = x.getEntry(i);                 final double expected = ainv.getEntry(i, j);                 final double delta = 1E-6 * FastMath.abs(expected);                 final String msg = String.format("coefficient (%d, %d)", i, j);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testPreconditionedSolution2() {         final int n = 100;         final int maxIterations = 100000;         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(n, n);         double daux = 1.;         for (int i = 0; i < n; i++) {             a.setEntry(i, i, daux);             daux *= 1.2;             for (int j = i + 1; j < n; j++) {                 if (i == j) {                 } else {                     final double value = 1.0;                     a.setEntry(i, j, value);                     a.setEntry(j, i, value);                 }             }         }         final RealLinearOperator m = JacobiPreconditioner.create(a);         final PreconditionedIterativeLinearSolver prec;         final IterativeLinearSolver unprec;         prec = new SymmLQ(maxIterations, 1E-15, true);         unprec = new SymmLQ(maxIterations, 1E-15, true);         final RealVector b = new ArrayRealVector(n);         final String pattern = "preconditioned SymmLQ (%d iterations) should"                                + " have been faster than unpreconditioned (%d iterations)";         String msg;         for (int j = 0; j < 1; j++) {             b.set(0.);             b.setEntry(j, 1.);             final RealVector px = prec.solve(a, m, b);             final RealVector x = unprec.solve(a, b);             final int np = prec.getIterationManager().getIterations();             final int nup = unprec.getIterationManager().getIterations();             msg = String.format(pattern, np, nup);             for (int i = 0; i < n; i++) {                 msg = String.format("row %d, column %d", i, j);                 final double expected = x.getEntry(i);                 final double actual = px.getEntry(i);                 final double delta = 5E-5 * FastMath.abs(expected);                 Assert.assertEquals(msg, expected, actual, delta);             }         }     }      @Test     public void testEventManagement() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final IterativeLinearSolver solver;         /*          * count[0] = number of calls to initializationPerformed          * count[1] = number of calls to iterationStarted          * count[2] = number of calls to iterationPerformed          * count[3] = number of calls to terminationPerformed          */         final int[] count = new int[] {0, 0, 0, 0};         final RealVector xFromListener = new ArrayRealVector(n);         final IterationListener listener = new IterationListener() {              @Override             public void initializationPerformed(final IterationEvent e) {                 ++count[0];             }              @Override             public void iterationPerformed(final IterationEvent e) {                 ++count[2];                 Assert.assertEquals("iteration performed",                                     count[2],                                     e.getIterations() - 1);             }              @Override             public void iterationStarted(final IterationEvent e) {                 ++count[1];                 Assert.assertEquals("iteration started",                                     count[1],                                     e.getIterations() - 1);             }              @Override             public void terminationPerformed(final IterationEvent e) {                 ++count[3];                 final IterativeLinearSolverEvent ilse;                 ilse = (IterativeLinearSolverEvent) e;                 xFromListener.setSubVector(0, ilse.getSolution());             }         };         solver = new SymmLQ(maxIterations, 1E-10, true);         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             Arrays.fill(count, 0);             b.set(0.);             b.setEntry(j, 1.);             final RealVector xFromSolver = solver.solve(a, b);             String msg = String.format("column %d (initialization)", j);             Assert.assertEquals(msg, 1, count[0]);             msg = String.format("column %d (finalization)", j);             Assert.assertEquals(msg, 1, count[3]);             /*              *  Check that solution is not "over-refined". When the last              *  iteration has occurred, no further refinement should be              *  performed.              */             for (int i = 0; i < n; i++){                 msg = String.format("row %d, column %d", i, j);                 final double expected = xFromSolver.getEntry(i);                 final double actual = xFromListener.getEntry(i);                 Assert.assertEquals(msg, expected, actual, 0.0);             }         }     }      @Test(expected = NonSelfAdjointOperatorException.class)     public void testNonSelfAdjointOperator() {         final RealLinearOperator a;         a = new Array2DRowRealMatrix(new double[][] {             {1., 2., 3.},             {2., 4., 5.},             {2.999, 5., 6.}         });         final RealVector b;         b = new ArrayRealVector(new double[] {1., 1., 1.});         new SymmLQ(100, 1., true).solve(a, b);     }      @Test(expected = NonSelfAdjointOperatorException.class)     public void testNonSelfAdjointPreconditioner() {         final RealLinearOperator a = new Array2DRowRealMatrix(new double[][] {             {1., 2., 3.},             {2., 4., 5.},             {3., 5., 6.}         });         final Array2DRowRealMatrix mMat;         mMat = new Array2DRowRealMatrix(new double[][] {             {1., 0., 1.},             {0., 1., 0.},             {0., 0., 1.}         });         final DecompositionSolver mSolver;         mSolver = new LUDecomposition(mMat).getSolver();         final RealLinearOperator minv = new RealLinearOperator() {              @Override             public RealVector operate(final RealVector x) {                 return mSolver.solve(x);             }              @Override             public int getRowDimension() {                 return mMat.getRowDimension();             }              @Override             public int getColumnDimension() {                 return mMat.getColumnDimension();             }         };         final RealVector b = new ArrayRealVector(new double[] {             1., 1., 1.         });         new SymmLQ(100, 1., true).solve(a, minv, b);     }      @Test     public void testUnpreconditionedNormOfResidual() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final IterativeLinearSolver solver;         final IterationListener listener = new IterationListener() {              private void doTestNormOfResidual(final IterationEvent e) {                 final IterativeLinearSolverEvent evt;                 evt = (IterativeLinearSolverEvent) e;                 final RealVector x = evt.getSolution();                 final RealVector b = evt.getRightHandSideVector();                 final RealVector r = b.subtract(a.operate(x));                 final double rnorm = r.getNorm();                 Assert.assertEquals("iteration performed (residual)",                     rnorm, evt.getNormOfResidual(),                     FastMath.max(1E-5 * rnorm, 1E-10));             }              @Override             public void initializationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationStarted(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void terminationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }         };         solver = new SymmLQ(maxIterations, 1E-10, true);         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             solver.solve(a, b);         }     }      @Test     public void testPreconditionedNormOfResidual() {         final int n = 5;         final int maxIterations = 100;         final RealLinearOperator a = new HilbertMatrix(n);         final JacobiPreconditioner m = JacobiPreconditioner.create(a);         final RealLinearOperator p = m.sqrt();         final PreconditionedIterativeLinearSolver solver;         final IterationListener listener = new IterationListener() {              private void doTestNormOfResidual(final IterationEvent e) {                 final IterativeLinearSolverEvent evt;                 evt = (IterativeLinearSolverEvent) e;                 final RealVector x = evt.getSolution();                 final RealVector b = evt.getRightHandSideVector();                 final RealVector r = b.subtract(a.operate(x));                 final double rnorm = p.operate(r).getNorm();                 Assert.assertEquals("iteration performed (residual)",                     rnorm, evt.getNormOfResidual(),                     FastMath.max(1E-5 * rnorm, 1E-10));             }              @Override             public void initializationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void iterationStarted(final IterationEvent e) {                 doTestNormOfResidual(e);             }              @Override             public void terminationPerformed(final IterationEvent e) {                 doTestNormOfResidual(e);             }         };         solver = new SymmLQ(maxIterations, 1E-10, true);         solver.getIterationManager().addIterationListener(listener);         final RealVector b = new ArrayRealVector(n);         for (int j = 0; j < n; j++) {             b.set(0.);             b.setEntry(j, 1.);             solver.solve(a, m, b);         }     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.DimensionMismatchException;  /** This class implements Hilbert Matrices as {@link RealLinearOperator}. */ public class HilbertMatrix     extends RealLinearOperator {      /** The size of the matrix. */     private final int n;      /**      * Creates a new instance of this class.      *      * @param n Size of the matrix to be created..      */     public HilbertMatrix(final int n) {         this.n = n;     }      /** {@inheritDoc} */     @Override     public int getColumnDimension() {         return n;     }      /** {@inheritDoc} */     @Override     public int getRowDimension() {         return n;     }      /** {@inheritDoc} */     @Override     public RealVector operate(final RealVector x) {         if (x.getDimension() != n) {             throw new DimensionMismatchException(x.getDimension(), n);         }         final double[] y = new double[n];         for (int i = 0; i < n; i++) {             double pos = 0.;             double neg = 0.;             for (int j = 0; j < n; j++) {                 final double xj = x.getEntry(j);                 final double coeff = 1. / (i + j + 1.);                 // Positive and negative values are sorted out in order to limit                 // catastrophic cancellations (do not forget that Hilbert                 // matrices are *very* ill-conditioned!                 if (xj > 0.) {                     pos += coeff * xj;                 } else {                     neg += coeff * xj;                 }             }             y[i] = pos + neg;         }         return new ArrayRealVector(y, false);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.text.NumberFormat; import java.text.ParsePosition; import java.util.Locale;  import org.junit.Ignore; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.exception.MathParseException;  public abstract class RealMatrixFormatAbstractTest {      RealMatrixFormat realMatrixFormat = null;     RealMatrixFormat realMatrixFormatOctave = null;      protected abstract Locale getLocale();      protected abstract char getDecimalCharacter();      public RealMatrixFormatAbstractTest() {         realMatrixFormat = RealMatrixFormat.getInstance(getLocale());         final NumberFormat nf = NumberFormat.getInstance(getLocale());         nf.setMaximumFractionDigits(2);         realMatrixFormatOctave = new RealMatrixFormat("[", "]", "", "", "; ", ", ", nf);     }      @Test     public void testSimpleNoDecimals() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});         String expected = "{{1,1,1},{1,1,1}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testSimpleWithDecimals() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.23, 1.43, 1.63}, {2.46, 2.46, 2.66}});         String expected =             "{{1"    + getDecimalCharacter() +             "23,1" + getDecimalCharacter() +             "43,1" + getDecimalCharacter() +             "63},{2" + getDecimalCharacter() +             "46,2" + getDecimalCharacter() +             "46,2" + getDecimalCharacter() +             "66}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testSimpleWithDecimalsTrunc() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.232323232323, 1.43, 1.63},                                                                     {2.46, 2.46, 2.666666666666}});         String expected =                 "{{1"    + getDecimalCharacter() +                 "2323232323,1" + getDecimalCharacter() +                 "43,1" + getDecimalCharacter() +                 "63},{2" + getDecimalCharacter() +                 "46,2" + getDecimalCharacter() +                 "46,2" + getDecimalCharacter() +                 "6666666667}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeComponent() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{-1.232323232323, 1.43, 1.63},                                                                     {2.46, 2.46, 2.66}});         String expected =                 "{{-1"    + getDecimalCharacter() +                 "2323232323,1" + getDecimalCharacter() +                 "43,1" + getDecimalCharacter() +                 "63},{2" + getDecimalCharacter() +                 "46,2" + getDecimalCharacter() +                 "46,2" + getDecimalCharacter() +                 "66}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeComponent2() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.23, -1.434343434343, 1.63},                                                                     {2.46, 2.46, 2.66}});         String expected =                 "{{1"    + getDecimalCharacter() +                 "23,-1" + getDecimalCharacter() +                 "4343434343,1" + getDecimalCharacter() +                 "63},{2" + getDecimalCharacter() +                 "46,2" + getDecimalCharacter() +                 "46,2" + getDecimalCharacter() +                 "66}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testNegativeSecondRow() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.23, 1.43, 1.63},                                                                     {-2.66666666666, 2.46, 2.66}});         String expected =                 "{{1"    + getDecimalCharacter() +                 "23,1" + getDecimalCharacter() +                 "43,1" + getDecimalCharacter() +                 "63},{-2" + getDecimalCharacter() +                 "6666666667,2" + getDecimalCharacter() +                 "46,2" + getDecimalCharacter() +                 "66}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testNonDefaultSetting() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});         String expected = "[1, 1, 1; 1, 1, 1]";         String actual = realMatrixFormatOctave.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testDefaultFormat() {         Locale defaultLocale = Locale.getDefault();         Locale.setDefault(getLocale());          RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{232.2222222222, -342.33333333333, 432.44444444444}});         String expected =             "{{232"    + getDecimalCharacter() +             "2222222222,-342" + getDecimalCharacter() +             "3333333333,432" + getDecimalCharacter() +             "4444444444}}";         String actual = (new RealMatrixFormat()).format(m);         Assert.assertEquals(expected, actual);          Locale.setDefault(defaultLocale);     }      @Test     public void testNan() {         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{Double.NaN, Double.NaN, Double.NaN}});         String expected = "{{(NaN),(NaN),(NaN)}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testPositiveInfinity() {         RealMatrix m = MatrixUtils.createRealMatrix(                 new double[][] {{Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY}});         String expected = "{{(Infinity),(Infinity),(Infinity)}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void tesNegativeInfinity() {         RealMatrix m = MatrixUtils.createRealMatrix(                 new double[][] {{Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY}});         String expected = "{{(-Infinity),(-Infinity),(-Infinity)}}";         String actual = realMatrixFormat.format(m);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseSimpleNoDecimals() {         String source = "{{1, 1, 1}, {1, 1, 1}}";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});         RealMatrix actual = realMatrixFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     @Ignore     public void testParseSimpleWithClosingRowSeparator() {         String source = "{{1, 1, 1},{1, 1, 1}, }}";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});         RealMatrix actual = realMatrixFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseIgnoredWhitespace() {         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});         ParsePosition pos1 = new ParsePosition(0);         String source1 = "{{1,1,1},{1,1,1}}";         Assert.assertEquals(expected, realMatrixFormat.parse(source1, pos1));         Assert.assertEquals(source1.length(), pos1.getIndex());         ParsePosition pos2 = new ParsePosition(0);         String source2 = " { { 1 , 1 , 1 } , { 1 , 1 , 1 } } ";         Assert.assertEquals(expected, realMatrixFormat.parse(source2, pos2));         Assert.assertEquals(source2.length() - 1, pos2.getIndex());     }      @Test     public void testParseSimpleWithDecimals() {         String source =             "{{1" + getDecimalCharacter() +             "23,1" + getDecimalCharacter() +             "43,1" + getDecimalCharacter() +             "63}}";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1.23, 1.43, 1.63}});         RealMatrix actual = realMatrixFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseSimpleWithDecimalsTrunc() {         String source =             "{{1" + getDecimalCharacter() +             "2323,1" + getDecimalCharacter() +             "4343,1" + getDecimalCharacter() +             "6333}}";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1.2323, 1.4343, 1.6333}});         RealMatrix actual = realMatrixFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeComponent() {         String source =             "{{-1" + getDecimalCharacter() +             "2323,1" + getDecimalCharacter() +             "4343,1" + getDecimalCharacter() +             "6333}}";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{-1.2323, 1.4343, 1.6333}});         RealMatrix actual = realMatrixFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeAll() {         String source =             "{{-1" + getDecimalCharacter() +             "2323,-1" + getDecimalCharacter() +             "4343,-1" + getDecimalCharacter() +             "6333}}";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{-1.2323, -1.4343, -1.6333}});         RealMatrix actual = realMatrixFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseZeroComponent() {         String source =             "{{0" + getDecimalCharacter() +             "0,-1" + getDecimalCharacter() +             "4343,1" + getDecimalCharacter() +             "6333}}";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{0.0, -1.4343, 1.6333}});         RealMatrix actual = realMatrixFormat.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNonDefaultSetting() {         String source =             "[1" + getDecimalCharacter() +             "2323, 1" + getDecimalCharacter() +             "4343, 1" + getDecimalCharacter() +             "6333]";         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1.2323, 1.4343, 1.6333}});         RealMatrix actual = realMatrixFormatOctave.parse(source);         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNan() {         String source = "{{(NaN), (NaN), (NaN)}}";         RealMatrix actual = realMatrixFormat.parse(source);         RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{Double.NaN, Double.NaN, Double.NaN}});         for (int i = 0; i < expected.getRowDimension(); i++) {             for (int j = 0; j < expected.getColumnDimension(); j++) {                 Assert.assertTrue(Double.isNaN(actual.getEntry(i, j)));             }         }     }      @Test     public void testParsePositiveInfinity() {         String source = "{{(Infinity), (Infinity), (Infinity)}}";         RealMatrix actual = realMatrixFormat.parse(source);         RealMatrix expected = MatrixUtils.createRealMatrix(                 new double[][] {{Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY}});         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNegativeInfinity() {         String source = "{{(-Infinity), (-Infinity), (-Infinity)}}";         RealMatrix actual = realMatrixFormat.parse(source);         RealMatrix expected = MatrixUtils.createRealMatrix(                 new double[][] {{Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY}});         Assert.assertEquals(expected, actual);     }      @Test     public void testParseNoComponents() {         try {             realMatrixFormat.parse("{{ }}");             Assert.fail("Expecting MathParseException");         } catch (MathParseException pe) {             // expected behavior         }     }      @Test     public void testParseManyComponents() {         RealMatrix parsed = realMatrixFormat.parse("{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}");         Assert.assertEquals(24, parsed.getColumnDimension());     }      @Test     public void testConstructorSingleFormat() {         NumberFormat nf = NumberFormat.getInstance();         RealMatrixFormat mf = new RealMatrixFormat(nf);         Assert.assertNotNull(mf);         Assert.assertEquals(nf, mf.getFormat());     }      @Test     public void testForgottenPrefix() {         ParsePosition pos = new ParsePosition(0);         final String source = "1; 1; 1]";         Assert.assertNull("Should not parse <"+source+">", realMatrixFormat.parse(source, pos));         Assert.assertEquals(0, pos.getErrorIndex());     }      @Test     public void testForgottenSeparator() {         ParsePosition pos = new ParsePosition(0);         final String source = "{{1, 1 1}}";         Assert.assertNull("Should not parse <"+source+">", realMatrixFormat.parse(source, pos));         Assert.assertEquals(7, pos.getErrorIndex());     }      @Test     public void testForgottenSuffix() {         ParsePosition pos = new ParsePosition(0);         final String source = "{{1, 1, 1 ";         Assert.assertNull("Should not parse <"+source+">", realMatrixFormat.parse(source, pos));         Assert.assertEquals(9, pos.getErrorIndex());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.io.BufferedReader; import java.io.DataInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.util.Random;  import org.junit.Assert; import org.junit.Test;   public class SingularValueDecompositionTest {      private double[][] testSquare = {             { 24.0 / 25.0, 43.0 / 25.0 },             { 57.0 / 25.0, 24.0 / 25.0 }     };      private double[][] testNonSquare = {         {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },         { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },         {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },         {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },     };      private static final double normTolerance = 10e-14;      @Test     public void testMoreRows() {         final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };         final int rows    = singularValues.length + 2;         final int columns = singularValues.length;         Random r = new Random(15338437322523l);         SingularValueDecomposition svd =             new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues));         double[] computedSV = svd.getSingularValues();         Assert.assertEquals(singularValues.length, computedSV.length);         for (int i = 0; i < singularValues.length; ++i) {             Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);         }     }      @Test     public void testMoreColumns() {         final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };         final int rows    = singularValues.length;         final int columns = singularValues.length + 2;         Random r = new Random(732763225836210l);         SingularValueDecomposition svd =             new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues));         double[] computedSV = svd.getSingularValues();         Assert.assertEquals(singularValues.length, computedSV.length);         for (int i = 0; i < singularValues.length; ++i) {             Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);         }     }      /** test dimensions */     @Test     public void testDimensions() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);         final int m = matrix.getRowDimension();         final int n = matrix.getColumnDimension();         SingularValueDecomposition svd = new SingularValueDecomposition(matrix);         Assert.assertEquals(m, svd.getU().getRowDimension());         Assert.assertEquals(m, svd.getU().getColumnDimension());         Assert.assertEquals(m, svd.getS().getColumnDimension());         Assert.assertEquals(n, svd.getS().getColumnDimension());         Assert.assertEquals(n, svd.getV().getRowDimension());         Assert.assertEquals(n, svd.getV().getColumnDimension());      }      /** Test based on a dimension 4 Hadamard matrix. */     @Test     public void testHadamard() {         RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {                 {15.0 / 2.0,  5.0 / 2.0,  9.0 / 2.0,  3.0 / 2.0 },                 { 5.0 / 2.0, 15.0 / 2.0,  3.0 / 2.0,  9.0 / 2.0 },                 { 9.0 / 2.0,  3.0 / 2.0, 15.0 / 2.0,  5.0 / 2.0 },                 { 3.0 / 2.0,  9.0 / 2.0,  5.0 / 2.0, 15.0 / 2.0 }         }, false);         SingularValueDecomposition svd = new SingularValueDecomposition(matrix);         Assert.assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);         Assert.assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14);         Assert.assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14);         Assert.assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14);          RealMatrix fullCovariance = new Array2DRowRealMatrix(new double[][] {                 {  85.0 / 1024, -51.0 / 1024, -75.0 / 1024,  45.0 / 1024 },                 { -51.0 / 1024,  85.0 / 1024,  45.0 / 1024, -75.0 / 1024 },                 { -75.0 / 1024,  45.0 / 1024,  85.0 / 1024, -51.0 / 1024 },                 {  45.0 / 1024, -75.0 / 1024, -51.0 / 1024,  85.0 / 1024 }         }, false);         Assert.assertEquals(0.0,                      fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(),                      1.0e-14);          RealMatrix halfCovariance = new Array2DRowRealMatrix(new double[][] {                 {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },                 {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 },                 {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },                 {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 }         }, false);         Assert.assertEquals(0.0,                      halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(),                      1.0e-14);      }      /** test A = USVt */     @Test     public void testAEqualUSVt() {         checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));         checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));         checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());     }      public void checkAEqualUSVt(final RealMatrix matrix) {         SingularValueDecomposition svd = new SingularValueDecomposition(matrix);         RealMatrix u = svd.getU();         RealMatrix s = svd.getS();         RealMatrix v = svd.getV();         double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();         Assert.assertEquals(0, norm, normTolerance);      }      /** test that U is orthogonal */     @Test     public void testUOrthogonal() {         checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getU());         checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getU());         checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());     }      /** test that V is orthogonal */     @Test     public void testVOrthogonal() {         checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getV());         checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getV());         checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());     }      public void checkOrthogonal(final RealMatrix m) {         RealMatrix mTm = m.transpose().multiply(m);         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());         Assert.assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);     }      /** test matrices values */     // This test is useless since whereas the columns of U and V are linked     // together, the actual triplet (U,S,V) is not uniquely defined.     public void testMatricesValues1() {        SingularValueDecomposition svd =             new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));         RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                 { 3.0 / 5.0, -4.0 / 5.0 },                 { 4.0 / 5.0,  3.0 / 5.0 }         });         RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {                 { 3.0, 0.0 },                 { 0.0, 1.0 }         });         RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                 { 4.0 / 5.0,  3.0 / 5.0 },                 { 3.0 / 5.0, -4.0 / 5.0 }         });          // check values against known references         RealMatrix u = svd.getU();         Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);         RealMatrix s = svd.getS();         Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);         RealMatrix v = svd.getV();         Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);          // check the same cached instance is returned the second time         Assert.assertTrue(u == svd.getU());         Assert.assertTrue(s == svd.getS());         Assert.assertTrue(v == svd.getV());      }      /** test matrices values */     // This test is useless since whereas the columns of U and V are linked     // together, the actual triplet (U,S,V) is not uniquely defined.     public void useless_testMatricesValues2() {          RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {             {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },             { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },             {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },             { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }         });         RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {             { 4.0, 0.0, 0.0 },             { 0.0, 3.0, 0.0 },             { 0.0, 0.0, 2.0 }         });         RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {             {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },             {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },             { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }         });          // check values against known references         SingularValueDecomposition svd =             new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare));         RealMatrix u = svd.getU();         Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);         RealMatrix s = svd.getS();         Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);         RealMatrix v = svd.getV();         Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);          // check the same cached instance is returned the second time         Assert.assertTrue(u == svd.getU());         Assert.assertTrue(s == svd.getS());         Assert.assertTrue(v == svd.getV());      }       /** test MATH-465 */     @Test     public void testRank() {         double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } };         RealMatrix m = new Array2DRowRealMatrix(d);         SingularValueDecomposition svd = new SingularValueDecomposition(m);         Assert.assertEquals(2, svd.getRank());     }      /** test MATH-583 */     @Test     public void testStability1() {         RealMatrix m = new Array2DRowRealMatrix(201, 201);         loadRealMatrix(m,"matrix1.csv");         try {             new SingularValueDecomposition(m);         } catch (Exception e) {             Assert.fail("Exception whilst constructing SVD");         }     }      /** test MATH-327 */     @Test     public void testStability2() {         RealMatrix m = new Array2DRowRealMatrix(7, 168);         loadRealMatrix(m,"matrix2.csv");         try {             new SingularValueDecomposition(m);         } catch (Throwable e) {             Assert.fail("Exception whilst constructing SVD");         }     }      private void loadRealMatrix(RealMatrix m, String resourceName) {         try {             DataInputStream in = new DataInputStream(getClass().getResourceAsStream(resourceName));             BufferedReader br = new BufferedReader(new InputStreamReader(in));             String strLine;             int row = 0;             while ((strLine = br.readLine()) != null) {                 if (!strLine.startsWith("#")) {                     int col = 0;                     for (String entry : strLine.split(",")) {                         m.setEntry(row, col++, Double.parseDouble(entry));                     }                     row++;                 }             }             in.close();         } catch (IOException e) {}     }      /** test condition number */     @Test     public void testConditionNumber() {         SingularValueDecomposition svd =             new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));         // replace 1.0e-15 with 1.5e-15         Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);     }      @Test     public void testInverseConditionNumber() {         SingularValueDecomposition svd =             new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));         Assert.assertEquals(1.0/3.0, svd.getInverseConditionNumber(), 1.5e-15);     }      private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,                                         final double[] singularValues) {         final RealMatrix u = EigenDecompositionTest.createOrthogonalMatrix(r, rows);         final RealMatrix d = new Array2DRowRealMatrix(rows, columns);         d.setSubMatrix(MatrixUtils.createRealDiagonalMatrix(singularValues).getData(), 0, 0);         final RealMatrix v = EigenDecompositionTest.createOrthogonalMatrix(r, columns);         return u.multiply(d).multiply(v);     }      @Test     public void testIssue947() {         double[][] nans = new double[][] {             { Double.NaN, Double.NaN },             { Double.NaN, Double.NaN }         };         RealMatrix m = new Array2DRowRealMatrix(nans, false);         SingularValueDecomposition svd = new SingularValueDecomposition(m);         Assert.assertTrue(Double.isNaN(svd.getSingularValues()[0]));         Assert.assertTrue(Double.isNaN(svd.getSingularValues()[1]));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Random;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Test; import org.junit.Assert;  public class QRSolverTest {     double[][] testData3x3NonSingular = {             { 12, -51,   4 },             {  6, 167, -68 },             { -4,  24, -41 }     };      double[][] testData3x3Singular = {             { 1, 2,  2 },             { 2, 4,  6 },             { 4, 8, 12 }     };      double[][] testData3x4 = {             { 12, -51,   4, 1 },             {  6, 167, -68, 2 },             { -4,  24, -41, 3 }     };      double[][] testData4x3 = {             { 12, -51,   4 },             {  6, 167, -68 },             { -4,  24, -41 },             { -5,  34,   7 }     };      /** test rank */     @Test     public void testRank() {         DecompositionSolver solver =             new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();         Assert.assertTrue(solver.isNonSingular());          solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();         Assert.assertFalse(solver.isNonSingular());          solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x4)).getSolver();         Assert.assertTrue(solver.isNonSingular());          solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData4x3)).getSolver();         Assert.assertTrue(solver.isNonSingular());      }      /** test solve dimension errors */     @Test     public void testSolveDimensionErrors() {         DecompositionSolver solver =             new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected behavior         }     }      /** test solve rank errors */     @Test     public void testSolveRankErrors() {         DecompositionSolver solver =             new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);         try {             solver.solve(b);             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException iae) {             // expected behavior         }         try {             solver.solve(b.getColumnVector(0));             Assert.fail("an exception should have been thrown");         } catch (SingularMatrixException iae) {             // expected behavior         }     }      /** test solve */     @Test     public void testSolve() {         QRDecomposition decomposition =             new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));         DecompositionSolver solver = decomposition.getSolver();         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                 { -102, 12250 }, { 544, 24500 }, { 167, -36750 }         });         RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                 { 1, 2515 }, { 2, 422 }, { -3, 898 }         });          // using RealMatrix         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());          // using ArrayRealVector         for (int i = 0; i < b.getColumnDimension(); ++i) {             final RealVector x = solver.solve(b.getColumnVector(i));             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();             Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());         }          // using RealVector with an alternate implementation         for (int i = 0; i < b.getColumnDimension(); ++i) {             ArrayRealVectorTest.RealVectorTestImpl v =                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));             final RealVector x = solver.solve(v);             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();             Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());         }      }      @Test     public void testOverdetermined() {         final Random r    = new Random(5559252868205245l);         int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         RealMatrix   a    = createTestMatrix(r, p, q);         RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);          // build a perturbed system: A.X + noise = B         RealMatrix b = a.multiply(xRef);         final double noise = 0.001;         b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {             @Override             public double visit(int row, int column, double value) {                 return value * (1.0 + noise * (2 * r.nextDouble() - 1));             }         });          // despite perturbation, the least square solution should be pretty good         RealMatrix x = new QRDecomposition(a).getSolver().solve(b);         Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);      }      @Test     public void testUnderdetermined() {         final Random r    = new Random(42185006424567123l);         int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         RealMatrix   a    = createTestMatrix(r, p, q);         RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);         RealMatrix   b    = a.multiply(xRef);         RealMatrix   x = new QRDecomposition(a).getSolver().solve(b);          // too many equations, the system cannot be solved at all         Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);          // the last unknown should have been set to 0         Assert.assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm(), 0);     }      private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {         RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);         m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {                 @Override                     public double visit(int row, int column, double value) {                     return 2.0 * r.nextDouble() - 1.0;                 }             });         return m;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */ package org.apache.commons.math4.linear;  import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Set; import java.util.HashSet; import java.util.Iterator; import java.util.Random;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.MathUnsupportedOperationException; import org.apache.commons.math4.linear.RealVector.Entry; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * This is an abstract test of the {@link  * RealVector#unmodifiableRealVector(RealVector) unmodifiable vector}  * implementation. These unmodifiable vectors decorate a (modifiable)  * {@link RealVector}; therefore, a new implementation of this abstract  * test should be considered for each implementation of  * {@link RealVector}.  *  *  */ public abstract class UnmodifiableRealVectorAbstractTest {     /** The dimension of the randomly generated vectors. */     protected static final int DIM = 100;     /** Absolute tolerance. */     protected static final double EPS = 10 * Math.ulp(1d);     /**      * The list of methods which are excluded from the general test      * {@link #testAllButExcluded()}.      */     protected static final Set<String> EXCLUDE = new HashSet<>();     /** The random number generator (always initialized with the same seed. */     protected static final Random RANDOM;      static {         EXCLUDE.add("getEntry");         EXCLUDE.add("setEntry");         EXCLUDE.add("addToEntry");         EXCLUDE.add("getSubVector");         EXCLUDE.add("setSubVector");         EXCLUDE.add("iterator");         EXCLUDE.add("sparseIterator");         EXCLUDE.add("walkInDefaultOrder");         EXCLUDE.add("walkInOptimizedOrder");         EXCLUDE.add("ebeDivide");         EXCLUDE.add("ebeMultiply");          // Excluded because they are inherited from "Object".         for (Method m : Object.class.getMethods()) {             EXCLUDE.add(m.getName());         }         RANDOM = new Random(20110813);     }      /**      * Returns {@code true} if the specified {@code double} are equal (within a      * given tolerance).      *      * @param x First {@code double}.      * @param y Second {@code double}.      * @return {@code true} if {@code x} and {@code y} are equal.      */     public static boolean equals(final double x, final double y) {         if (x == y) {             return true;         } else if (FastMath.abs(x) <= EPS) {             return FastMath.abs(y) <= EPS;         } else if (FastMath.abs(y) <= EPS) {             return FastMath.abs(x) <= EPS;         } else {             return FastMath.abs(x - y) <= EPS * FastMath.min(FastMath.abs(x), FastMath.abs(y));         }     }      /**      * Returns {@code true} if the specified {@code double} arrays are equal      * (within a given tolerance).      *      * @param x First array.      * @param y Second array.      * @return {@code true} if {@code x} and {@code y} are equal.      */     public static boolean equals(final double[] x, final double[] y) {         if (x.length != y.length) {             return false;         }         final int n = x.length;         for (int i = 0; i < n; i++) {             if (!equals(x[i], y[i])) {                 return false;             }         }         return true;     }      /**      * Returns {@code true} if the specified {@code RealVector} are equal      * (within a given tolerance).      *      * @param x First vector.      * @param y Second vector.      * @return {@code true} if {@code x} and {@code y} are equal.      */     public static boolean equals(final RealVector x, final RealVector y) {         if (x.getDimension() != y.getDimension()) {             return false;         }         final int n = x.getDimension();         for (int i = 0; i < n; i++) {             if (!equals(x.getEntry(i), y.getEntry(i))) {                 return false;             }         }         return true;     }      /**      * Returns {@code true} if the specified {@code RealVector} is equal to the      * specified {@code double} array (within a given tolerance).      *      * @param x Vector.      * @param y Array.      * @return {@code true} if {@code x} and {@code y} are equal.      */     public static boolean equals(final RealVector x, final double[] y) {         if (x.getDimension() != y.length) {             return false;         }         final int n = x.getDimension();         for (int i = 0; i < n; i++) {             if (!equals(x.getEntry(i), y[i])) {                 return false;             }         }         return true;     }      /**      * Returns {@code true} if the specified {@code RealMatrix} are equal      * (within a given tolerance).      *      * @param x First matrix.      * @param y Second matrix.      * @return {@code true} if {@code x} and {@code y} are equal.      */     public static boolean equals(final RealMatrix x, final RealMatrix y) {         if (x.getRowDimension() != y.getRowDimension()) {             return false;         }         if (x.getColumnDimension() != y.getColumnDimension()) {             return false;         }         final int rows = x.getRowDimension();         final int cols = x.getColumnDimension();         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (!equals(x.getEntry(i, j), y.getEntry(i, j))) {                     return false;                 }             }         }         return true;     }      /**      * Returns {@code true} if the specified {@code Object} are equal.      *      * @param x First object.      * @param y Second object.      * @return {@code true} if {@code x} and {@code y} are equal.      * @throws IllegalArgumentException if {@code x} and {@code y} could      * not be compared.      */     public static boolean equals(final Object x, final Object y) {         if (x instanceof Boolean) {             if (y instanceof Boolean) {                 return ((Boolean) x).booleanValue() == ((Boolean) y)                         .booleanValue();             } else {                 return false;             }         }         if (x instanceof Integer) {             if (y instanceof Integer) {                 return ((Integer) x).intValue() == ((Integer) y).intValue();             } else {                 return false;             }         } else if (x instanceof Double) {             if (y instanceof Double) {                 return equals(((Double) x).doubleValue(),                         ((Double) y).doubleValue());             } else {                 return false;             }         } else if (x instanceof double[]) {             if (y instanceof double[]) {                 return equals((double[]) x, (double[]) y);             } else if (y instanceof RealVector) {                 return equals((RealVector) y, (double[]) x);             } else {                 return false;             }         } else if (x instanceof RealVector) {             if (y instanceof double[]) {                 return equals((RealVector) x, (double[]) y);             } else if (y instanceof RealVector) {                 return equals((RealVector) x, (RealVector) y);             } else {                 return false;             }         } else if (x instanceof RealMatrix) {             if (y instanceof RealMatrix) {                 return equals((RealMatrix) x, (RealMatrix) y);             } else {                 return false;             }         } else {             throw new IllegalArgumentException("could not compare " + x + ", "                     + y);         }     }      /**      * Creates a new random vector of a specified type. This vector is then to      * be wrapped in an unmodifiable vector.      *      * @return a new random vector.      */     public abstract RealVector createVector();      /**      * Creates a new random object of the specified type.      *      * @param c Class of the object to be created.      * @return a new random object.      * @throws IllegalArgumentException if the specified class is not      * recognized by this method.      */     public Object createParameter(final Class<?> c) {         if (c == Integer.TYPE) {             return Integer.valueOf(RANDOM.nextInt());         } else if (c == Double.TYPE) {             return Double.valueOf(RANDOM.nextDouble());         } else if (c == double[].class) {             final double[] v = new double[DIM];             for (int i = 0; i < DIM; i++) {                 v[i] = RANDOM.nextDouble();             }             return v;         } else if (c.isAssignableFrom(RealVector.class)) {             return createVector();         } else if (c.isAssignableFrom(UnivariateFunction.class)) {             return new Sin();         } else {             throw new IllegalArgumentException("could not create " + c);         }     }      /**      * This is the general test of most methods in the      * {@link RealVector#unmodifiableRealVector(RealVector) unmodifiable vector}.      * It works as follows.      * First, an unmodifiable view of a copy of the specified random vector      * {@code u} is created: this defines {@code v}. Then the <em>same</em>      * method {@code m} is invoked on {@code u} and {@code v}, with randomly      * generated parameters {@code args}.      * If it turns out that {@code u} has changed after the call of method      * {@code m}, then this test checks that the call of this method on      * {@code v} resulted in a {@link MathUnsupportedOperationException}. If      * {@code u} was not modified, then this test checks that the results      * returned by the call of method {@code m} on {@code u} and {@code v}      * returned the same result.      *      * @param m Method to be tested.      * @param u Random vector from which the unmodifiable view is to be      *constructed.      * @param args Arguments to be passed to method {@code m}.      */     private void callMethod(final Method m,                             final RealVector u,                             final Object... args)         throws IllegalAccessException,                IllegalArgumentException,                InvocationTargetException {         final RealVector uu = u.copy();         final RealVector v = RealVector.unmodifiableRealVector(u.copy());         Object exp = m.invoke(u, args);         if (equals(uu, u)) {             Object act = m.invoke(v, args);             Assert.assertTrue(m.toGenericString() + ", unmodifiable vector has changed",                               equals(uu, v));             Assert.assertTrue(m.toGenericString() + ", wrong result",                               equals(exp, act));          } else {             boolean flag = false;             try {                 m.invoke(v, args);             } catch (InvocationTargetException e) {                 if (e.getCause() instanceof MathUnsupportedOperationException) {                     flag = true;                 }             }             Assert.assertTrue(m.toGenericString()+", exception should have been thrown", flag);         }     }      /**      * This test calls {@link #callMethod(Method, RealVector, Object...)} on      * every method defined in interface {@link RealVector}. It generates the      * appropriate random arguments. Some methods are manually excluded (see      * {@link #EXCLUDE}), they must be handled by separate tests.      */     @Test     public void testAllButExcluded()         throws IllegalAccessException,                IllegalArgumentException,                InvocationTargetException {         Method[] method = RealVector.class.getMethods();         for (int i = 0; i < method.length; i++) {             Method m = method[i];             if (!EXCLUDE.contains(m.getName())) {                 RealVector u = (RealVector) createParameter(RealVector.class);                 Class<?>[] paramType = m.getParameterTypes();                 Object[] param = new Object[paramType.length];                 for (int j = 0; j < paramType.length; j++) {                     param[j] = createParameter(paramType[j]);                 }                 callMethod(m, u, param);             }         }     }      @Test     public void testGetEntry() {         RealVector u = createVector();         RealVector v = RealVector.unmodifiableRealVector(u);         for (int i = 0; i < DIM; i++) {             Assert.assertTrue(equals(u.getEntry(i), v.getEntry(i)));         }     }      @Test(expected = MathUnsupportedOperationException.class)     public void testSetEntry() {         RealVector u = createVector();         RealVector v = RealVector.unmodifiableRealVector(u);         for (int i = 0; i < DIM; i++) {             v.setEntry(i, 0d);         }     }      @Test(expected = MathUnsupportedOperationException.class)     public void testAddToEntry() {         RealVector u = createVector();         RealVector v = RealVector.unmodifiableRealVector(u);         for (int i = 0; i < DIM; i++) {             v.addToEntry(i, 0d);         }     }      @Test     public void testGetSubVector() {         RealVector u = createVector();         RealVector v = RealVector.unmodifiableRealVector(u);         for (int i = 0; i < DIM; i++) {             for (int n = 1; n < DIM - i; n++) {                 RealVector exp = u.getSubVector(i, n);                 RealVector act = v.getSubVector(i, n);                 Assert.assertTrue(equals(exp, act));             }         }     }      @Test(expected = MathUnsupportedOperationException.class)     public void testSetSubVector() {         RealVector u = createVector();         RealVector v = RealVector.unmodifiableRealVector(u);         v.setSubVector(0, new ArrayRealVector());     }      @Test     public void testIterator() {         RealVector u = createVector();         Iterator<Entry> i = u.iterator();         RealVector v = RealVector.unmodifiableRealVector(u.copy());         Iterator<Entry> j = v.iterator();         boolean flag;         while (i.hasNext()) {             Assert.assertTrue(j.hasNext());             Entry exp = i.next();             Entry act = j.next();             Assert.assertTrue(equals(exp.getIndex(), act.getIndex()));             Assert.assertTrue(equals(exp.getValue(), act.getValue()));             exp.setIndex(RANDOM.nextInt(DIM));             act.setIndex(RANDOM.nextInt(DIM));             flag = false;             try {                 act.setValue(RANDOM.nextDouble());             } catch (MathUnsupportedOperationException e) {                 flag = true;             }             Assert.assertTrue("exception should have been thrown", flag);         }         Assert.assertFalse(j.hasNext());     }      @Test     public void testSparseIterator() {         RealVector u = createVector();         Iterator<Entry> i = u.sparseIterator();         RealVector v = RealVector.unmodifiableRealVector(u.copy());         Iterator<Entry> j = v.sparseIterator();         boolean flag;         while (i.hasNext()) {             Assert.assertTrue(j.hasNext());             Entry exp = i.next();             Entry act = j.next();             Assert.assertTrue(equals(exp.getIndex(), act.getIndex()));             Assert.assertTrue(equals(exp.getValue(), act.getValue()));             exp.setIndex(RANDOM.nextInt(DIM));             act.setIndex(RANDOM.nextInt(DIM));             flag = false;             try {                 act.setValue(RANDOM.nextDouble());             } catch (MathUnsupportedOperationException e) {                 flag = true;             }             Assert.assertTrue("exception should have been thrown", flag);         }         Assert.assertFalse(j.hasNext());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class BiDiagonalTransformerTest {      private double[][] testSquare = {             { 24.0 / 25.0, 43.0 / 25.0 },             { 57.0 / 25.0, 24.0 / 25.0 }     };      private double[][] testNonSquare = {         {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },         { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },         {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },         {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },     };      @Test     public void testDimensions() {         checkDimensions(MatrixUtils.createRealMatrix(testSquare));         checkDimensions(MatrixUtils.createRealMatrix(testNonSquare));         checkDimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose());     }      private void checkDimensions(RealMatrix matrix) {         final int m = matrix.getRowDimension();         final int n = matrix.getColumnDimension();         BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);         Assert.assertEquals(m, transformer.getU().getRowDimension());         Assert.assertEquals(m, transformer.getU().getColumnDimension());         Assert.assertEquals(m, transformer.getB().getRowDimension());         Assert.assertEquals(n, transformer.getB().getColumnDimension());         Assert.assertEquals(n, transformer.getV().getRowDimension());         Assert.assertEquals(n, transformer.getV().getColumnDimension());      }      @Test     public void testAEqualUSVt() {         checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));         checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));         checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());     }      private void checkAEqualUSVt(RealMatrix matrix) {         BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);         RealMatrix u = transformer.getU();         RealMatrix b = transformer.getB();         RealMatrix v = transformer.getV();         double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();         Assert.assertEquals(0, norm, 1.0e-14);     }      @Test     public void testUOrthogonal() {         checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU());         checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU());         checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());     }      @Test     public void testVOrthogonal() {         checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV());         checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV());         checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());     }      private void checkOrthogonal(RealMatrix m) {         RealMatrix mTm = m.transpose().multiply(m);         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());         Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);     }      @Test     public void testBBiDiagonal() {         checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB());         checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB());         checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB());     }      private void checkBiDiagonal(RealMatrix m) {         final int rows = m.getRowDimension();         final int cols = m.getColumnDimension();         for (int i = 0; i < rows; ++i) {             for (int j = 0; j < cols; ++j) {                 if (rows < cols) {                     if ((i < j) || (i > j + 1)) {                         Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                     }                 } else {                     if ((i < j - 1) || (i > j)) {                         Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                     }                 }             }         }     }      @Test     public void testSingularMatrix() {        BiDiagonalTransformer transformer =             new BiDiagonalTransformer(MatrixUtils.createRealMatrix(new double[][] {                 { 1.0, 2.0, 3.0 },                 { 2.0, 3.0, 4.0 },                 { 3.0, 5.0, 7.0 }             }));        final double s3  = FastMath.sqrt(3.0);        final double s14 = FastMath.sqrt(14.0);        final double s1553 = FastMath.sqrt(1553.0);        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {            {  -1.0 / s14,  5.0 / (s3 * s14),  1.0 / s3 },            {  -2.0 / s14, -4.0 / (s3 * s14),  1.0 / s3 },            {  -3.0 / s14,  1.0 / (s3 * s14), -1.0 / s3 }        });        RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {            { -s14, s1553 / s14,   0.0 },            {  0.0, -87 * s3 / (s14 * s1553), -s3 * s14 / s1553 },            {  0.0, 0.0, 0.0 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {            { 1.0,   0.0,         0.0        },            { 0.0,  -23 / s1553,  32 / s1553 },            { 0.0,  -32 / s1553, -23 / s1553 }        });         // check values against known references        RealMatrix u = transformer.getU();        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);        RealMatrix b = transformer.getB();        Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);        RealMatrix v = transformer.getV();        Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);         // check the same cached instance is returned the second time        Assert.assertTrue(u == transformer.getU());        Assert.assertTrue(b == transformer.getB());        Assert.assertTrue(v == transformer.getV());      }      @Test     public void testMatricesValues() {        BiDiagonalTransformer transformer =             new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));        final double s17 = FastMath.sqrt(17.0);         RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                 {  -8 / (5 * s17), 19 / (5 * s17) },                 { -19 / (5 * s17), -8 / (5 * s17) }         });         RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {                 { -3 * s17 / 5, 32 * s17 / 85 },                 {      0.0,     -5 * s17 / 17 }         });         RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                 { 1.0,  0.0 },                 { 0.0, -1.0 }         });          // check values against known references         RealMatrix u = transformer.getU();         Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);         RealMatrix b = transformer.getB();         Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);         RealMatrix v = transformer.getV();         Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);          // check the same cached instance is returned the second time         Assert.assertTrue(u == transformer.getU());         Assert.assertTrue(b == transformer.getB());         Assert.assertTrue(v == transformer.getV());      }      @Test     public void testUpperOrLower() {         Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal());         Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal());         Assert.assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException;  /**  * Test cases for the {@link OpenMapRealMatrix} class.  *  */ public final class SparseRealMatrixTest {      // 3 x 3 identity matrix     protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } };     // Test data for group operations     protected double[][] testData = { { 1d, 2d, 3d }, { 2d, 5d, 3d },             { 1d, 0d, 8d } };     protected double[][] testDataLU = { { 2d, 5d, 3d }, { .5d, -2.5d, 6.5d },             { 0.5d, 0.2d, .2d } };     protected double[][] testDataPlus2 = { { 3d, 4d, 5d }, { 4d, 7d, 5d },             { 3d, 2d, 10d } };     protected double[][] testDataMinus = { { -1d, -2d, -3d },             { -2d, -5d, -3d }, { -1d, 0d, -8d } };     protected double[] testDataRow1 = { 1d, 2d, 3d };     protected double[] testDataCol3 = { 3d, 3d, 8d };     protected double[][] testDataInv = { { -40d, 16d, 9d }, { 13d, -5d, -3d },             { 5d, -2d, -1d } };     protected double[] preMultTest = { 8, 12, 33 };     protected double[][] testData2 = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };     protected double[][] testData2T = { { 1d, 2d }, { 2d, 5d }, { 3d, 3d } };     protected double[][] testDataPlusInv = { { -39d, 18d, 12d },             { 15d, 0d, 0d }, { 6d, -2d, 7d } };      // lu decomposition tests     protected double[][] luData = { { 2d, 3d, 3d }, { 0d, 5d, 7d }, { 6d, 9d, 8d } };     protected double[][] luDataLUDecomposition = { { 6d, 9d, 8d },             { 0d, 5d, 7d }, { 0.33333333333333, 0d, 0.33333333333333 } };      // singular matrices     protected double[][] singular = { { 2d, 3d }, { 2d, 3d } };     protected double[][] bigSingular = { { 1d, 2d, 3d, 4d },             { 2d, 5d, 3d, 4d }, { 7d, 3d, 256d, 1930d }, { 3d, 7d, 6d, 8d } }; // 4th      // row     // =     // 1st     // +     // 2nd     protected double[][] detData = { { 1d, 2d, 3d }, { 4d, 5d, 6d },             { 7d, 8d, 10d } };     protected double[][] detData2 = { { 1d, 3d }, { 2d, 4d } };      // vectors     protected double[] testVector = { 1, 2, 3 };     protected double[] testVector2 = { 1, 2, 3, 4 };      // submatrix accessor tests     protected double[][] subTestData = { { 1, 2, 3, 4 },             { 1.5, 2.5, 3.5, 4.5 }, { 2, 4, 6, 8 }, { 4, 5, 6, 7 } };      // array selections     protected double[][] subRows02Cols13 = { { 2, 4 }, { 4, 8 } };     protected double[][] subRows03Cols12 = { { 2, 3 }, { 5, 6 } };     protected double[][] subRows03Cols123 = { { 2, 3, 4 }, { 5, 6, 7 } };      // effective permutations     protected double[][] subRows20Cols123 = { { 4, 6, 8 }, { 2, 3, 4 } };     protected double[][] subRows31Cols31 = { { 7, 5 }, { 4.5, 2.5 } };      // contiguous ranges     protected double[][] subRows01Cols23 = { { 3, 4 }, { 3.5, 4.5 } };     protected double[][] subRows23Cols00 = { { 2 }, { 4 } };     protected double[][] subRows00Cols33 = { { 4 } };      // row matrices     protected double[][] subRow0 = { { 1, 2, 3, 4 } };     protected double[][] subRow3 = { { 4, 5, 6, 7 } };      // column matrices     protected double[][] subColumn1 = { { 2 }, { 2.5 }, { 4 }, { 5 } };     protected double[][] subColumn3 = { { 4 }, { 4.5 }, { 8 }, { 7 } };      // tolerances     protected double entryTolerance = 10E-16;     protected double normTolerance = 10E-14;      /** test dimensions */     @Test     public void testDimensions() {         OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix m2 = createSparseMatrix(testData2);         Assert.assertEquals("testData row dimension", 3, m.getRowDimension());         Assert.assertEquals("testData column dimension", 3, m.getColumnDimension());         Assert.assertTrue("testData is square", m.isSquare());         Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2);         Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);         Assert.assertTrue("testData2 is not square", !m2.isSquare());     }      /** test copy functions */     @Test     public void testCopyFunctions() {         OpenMapRealMatrix m1 = createSparseMatrix(testData);         RealMatrix m2 = m1.copy();         Assert.assertEquals(m1.getClass(), m2.getClass());         Assert.assertEquals((m2), m1);         OpenMapRealMatrix m3 = createSparseMatrix(testData);         RealMatrix m4 = m3.copy();         Assert.assertEquals(m3.getClass(), m4.getClass());         Assert.assertEquals((m4), m3);     }      /** test add */     @Test     public void testAdd() {         OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);         OpenMapRealMatrix mDataPlusInv = createSparseMatrix(testDataPlusInv);         RealMatrix mPlusMInv = m.add(mInv);         for (int row = 0; row < m.getRowDimension(); row++) {             for (int col = 0; col < m.getColumnDimension(); col++) {                 Assert.assertEquals("sum entry entry",                     mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col),                     entryTolerance);             }         }     }      /** test add failure */     @Test     public void testAddFail() {         OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix m2 = createSparseMatrix(testData2);         try {             m.add(m2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test norm */     @Test     public void testNorm() {         OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix m2 = createSparseMatrix(testData2);         Assert.assertEquals("testData norm", 14d, m.getNorm(), entryTolerance);         Assert.assertEquals("testData2 norm", 7d, m2.getNorm(), entryTolerance);     }      /** test m-n = m + -n */     @Test     public void testPlusMinus() {         OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix n = createSparseMatrix(testDataInv);         assertClose("m-n = m + -n", m.subtract(n),             n.scalarMultiply(-1d).add(m), entryTolerance);         try {             m.subtract(createSparseMatrix(testData2));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test multiply */     @Test     public void testMultiply() {         OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);         OpenMapRealMatrix identity = createSparseMatrix(id);         OpenMapRealMatrix m2 = createSparseMatrix(testData2);         assertClose("inverse multiply", m.multiply(mInv), identity,                 entryTolerance);         assertClose("inverse multiply", m.multiply(new BlockRealMatrix(testDataInv)), identity,                     entryTolerance);         assertClose("inverse multiply", mInv.multiply(m), identity,                 entryTolerance);         assertClose("identity multiply", m.multiply(identity), m,                 entryTolerance);         assertClose("identity multiply", identity.multiply(mInv), mInv,                 entryTolerance);         assertClose("identity multiply", m2.multiply(identity), m2,                 entryTolerance);         try {             m.multiply(createSparseMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      // Additional Test for Array2DRowRealMatrixTest.testMultiply      private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };     private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };     private double[][] d5 = new double[][] { { 30 }, { 70 } };      @Test     public void testMultiply2() {         RealMatrix m3 = createSparseMatrix(d3);         RealMatrix m4 = createSparseMatrix(d4);         RealMatrix m5 = createSparseMatrix(d5);         assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);     }      /** test trace */     @Test     public void testTrace() {         RealMatrix m = createSparseMatrix(id);         Assert.assertEquals("identity trace", 3d, m.getTrace(), entryTolerance);         m = createSparseMatrix(testData2);         try {             m.getTrace();             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }     }      /** test scalarAdd */     @Test     public void testScalarAdd() {         RealMatrix m = createSparseMatrix(testData);         assertClose("scalar add", createSparseMatrix(testDataPlus2),             m.scalarAdd(2d), entryTolerance);     }      /** test operate */     @Test     public void testOperate() {         RealMatrix m = createSparseMatrix(id);         assertClose("identity operate", testVector, m.operate(testVector),                 entryTolerance);         assertClose("identity operate", testVector, m.operate(                 new ArrayRealVector(testVector)).toArray(), entryTolerance);         m = createSparseMatrix(bigSingular);         try {             m.operate(testVector);             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test issue MATH-209 */     @Test     public void testMath209() {         RealMatrix a = createSparseMatrix(new double[][] {                 { 1, 2 }, { 3, 4 }, { 5, 6 } });         double[] b = a.operate(new double[] { 1, 1 });         Assert.assertEquals(a.getRowDimension(), b.length);         Assert.assertEquals(3.0, b[0], 1.0e-12);         Assert.assertEquals(7.0, b[1], 1.0e-12);         Assert.assertEquals(11.0, b[2], 1.0e-12);     }      /** test transpose */     @Test     public void testTranspose() {         RealMatrix m = createSparseMatrix(testData);         RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose();         RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse();         assertClose("inverse-transpose", mIT, mTI, normTolerance);         m = createSparseMatrix(testData2);         RealMatrix mt = createSparseMatrix(testData2T);         assertClose("transpose",mt,m.transpose(),normTolerance);     }      /** test preMultiply by vector */     @Test     public void testPremultiplyVector() {         RealMatrix m = createSparseMatrix(testData);         assertClose("premultiply", m.preMultiply(testVector), preMultTest,             normTolerance);         assertClose("premultiply", m.preMultiply(             new ArrayRealVector(testVector).toArray()), preMultTest, normTolerance);         m = createSparseMatrix(bigSingular);         try {             m.preMultiply(testVector);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testPremultiply() {         RealMatrix m3 = createSparseMatrix(d3);         RealMatrix m4 = createSparseMatrix(d4);         RealMatrix m5 = createSparseMatrix(d5);         assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);          OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);         OpenMapRealMatrix identity = createSparseMatrix(id);         assertClose("inverse multiply", m.preMultiply(mInv), identity,                 entryTolerance);         assertClose("inverse multiply", mInv.preMultiply(m), identity,                 entryTolerance);         assertClose("identity multiply", m.preMultiply(identity), m,                 entryTolerance);         assertClose("identity multiply", identity.preMultiply(mInv), mInv,                 entryTolerance);         try {             m.preMultiply(createSparseMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testGetVectors() {         RealMatrix m = createSparseMatrix(testData);         assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);         assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);         try {             m.getRow(10);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }         try {             m.getColumn(-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }     }      @Test     public void testGetEntry() {         RealMatrix m = createSparseMatrix(testData);         Assert.assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance);         try {             m.getEntry(10, 4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      /** test examples in user guide */     @Test     public void testExamples() {         // Create a real matrix with two rows and three columns         double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };         RealMatrix m = createSparseMatrix(matrixData);         // One more with three rows, two columns         double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } };         RealMatrix n = createSparseMatrix(matrixData2);         // Now multiply m by n         RealMatrix p = m.multiply(n);         Assert.assertEquals(2, p.getRowDimension());         Assert.assertEquals(2, p.getColumnDimension());         // Invert p         RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse();         Assert.assertEquals(2, pInverse.getRowDimension());         Assert.assertEquals(2, pInverse.getColumnDimension());          // Solve example         double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 },                 { 4, -3, -5 } };         RealMatrix coefficients = createSparseMatrix(coefficientsData);         RealVector constants = new ArrayRealVector(new double[]{ 1, -2, 1 }, false);         RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants);         final double cst0 = constants.getEntry(0);         final double cst1 = constants.getEntry(1);         final double cst2 = constants.getEntry(2);         final double sol0 = solution.getEntry(0);         final double sol1 = solution.getEntry(1);         final double sol2 = solution.getEntry(2);         Assert.assertEquals(2 * sol0 + 3 * sol1 - 2 * sol2, cst0, 1E-12);         Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12);         Assert.assertEquals(4 * sol0 - 3 * sol1 - 5 * sol2, cst2, 1E-12);      }      // test submatrix accessors     @Test     public void testSubMatrix() {         RealMatrix m = createSparseMatrix(subTestData);         RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00);         RealMatrix mRows00Cols33 = createSparseMatrix(subRows00Cols33);         RealMatrix mRows01Cols23 = createSparseMatrix(subRows01Cols23);         RealMatrix mRows02Cols13 = createSparseMatrix(subRows02Cols13);         RealMatrix mRows03Cols12 = createSparseMatrix(subRows03Cols12);         RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123);         RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123);         RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31);         Assert.assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));         Assert.assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));         Assert.assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));         Assert.assertEquals("Rows02Cols13", mRows02Cols13,             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));         Assert.assertEquals("Rows03Cols12", mRows03Cols12,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));         Assert.assertEquals("Rows03Cols123", mRows03Cols123,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));         Assert.assertEquals("Rows20Cols123", mRows20Cols123,             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));         Assert.assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));         Assert.assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));          try {             m.getSubMatrix(1, 0, 2, 4);             Assert.fail("Expecting NumberIsTooSmallException");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             m.getSubMatrix(-1, 1, 2, 2);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getSubMatrix(1, 0, 2, 2);             Assert.fail("Expecting NumberIsTooSmallException");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             m.getSubMatrix(1, 0, 2, 4);             Assert.fail("Expecting NumberIsTooSmallException");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             m.getSubMatrix(new int[] {}, new int[] { 0 });             Assert.fail("Expecting NoDataException");         } catch (NoDataException ex) {             // expected         }         try {             m.getSubMatrix(new int[] { 0 }, new int[] { 4 });             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetRowMatrix() {         RealMatrix m = createSparseMatrix(subTestData);         RealMatrix mRow0 = createSparseMatrix(subRow0);         RealMatrix mRow3 = createSparseMatrix(subRow3);         Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));         Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));         try {             m.getRowMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetColumnMatrix() {         RealMatrix m = createSparseMatrix(subTestData);         RealMatrix mColumn1 = createSparseMatrix(subColumn1);         RealMatrix mColumn3 = createSparseMatrix(subColumn3);         Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1));         Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3));         try {             m.getColumnMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetRowVector() {         RealMatrix m = createSparseMatrix(subTestData);         RealVector mRow0 = new ArrayRealVector(subRow0[0]);         RealVector mRow3 = new ArrayRealVector(subRow3[0]);         Assert.assertEquals("Row0", mRow0, m.getRowVector(0));         Assert.assertEquals("Row3", mRow3, m.getRowVector(3));         try {             m.getRowVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testGetColumnVector() {         RealMatrix m = createSparseMatrix(subTestData);         RealVector mColumn1 = columnToVector(subColumn1);         RealVector mColumn3 = columnToVector(subColumn3);         Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));         Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));         try {             m.getColumnVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      private RealVector columnToVector(double[][] column) {         double[] data = new double[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return new ArrayRealVector(data, false);     }      @Test     public void testEqualsAndHashCode() {         OpenMapRealMatrix m = createSparseMatrix(testData);         OpenMapRealMatrix m1 = m.copy();         OpenMapRealMatrix mt = (OpenMapRealMatrix) m.transpose();         Assert.assertTrue(m.hashCode() != mt.hashCode());         Assert.assertEquals(m.hashCode(), m1.hashCode());         Assert.assertEquals(m, m);         Assert.assertEquals(m, m1);         Assert.assertFalse(m.equals(null));         Assert.assertFalse(m.equals(mt));         Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));     }      @Test     public void testToString() {         OpenMapRealMatrix m = createSparseMatrix(testData);         Assert.assertEquals("OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",             m.toString());         m = new OpenMapRealMatrix(1, 1);         Assert.assertEquals("OpenMapRealMatrix{{0.0}}", m.toString());     }      @Test     public void testSetSubMatrix() {         OpenMapRealMatrix m = createSparseMatrix(testData);         m.setSubMatrix(detData2, 1, 1);         RealMatrix expected = createSparseMatrix(new double[][] {                 { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } });         Assert.assertEquals(expected, m);          m.setSubMatrix(detData2, 0, 0);         expected = createSparseMatrix(new double[][] {                 { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } });         Assert.assertEquals(expected, m);          m.setSubMatrix(testDataPlus2, 0, 0);         expected = createSparseMatrix(new double[][] {                 { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } });         Assert.assertEquals(expected, m);          // javadoc example         OpenMapRealMatrix matrix =             createSparseMatrix(new double[][] {         { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } });         matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);         expected = createSparseMatrix(new double[][] {                 { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } });         Assert.assertEquals(expected, matrix);          // dimension overflow         try {             m.setSubMatrix(testData, 1, 1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         // dimension underflow         try {             m.setSubMatrix(testData, -1, 1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         try {             m.setSubMatrix(testData, 1, -1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }          // null         try {             m.setSubMatrix(null, 1, 1);             Assert.fail("expecting NullArgumentException");         } catch (NullArgumentException e) {             // expected         }         try {             new OpenMapRealMatrix(0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // ragged         try {             m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // empty         try {             m.setSubMatrix(new double[][] { {} }, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }      }      @Test     public void testSerial()  {         OpenMapRealMatrix m = createSparseMatrix(testData);         Assert.assertEquals(m,TestUtils.serializeAndRecover(m));     }      // --------------- -----------------Protected methods      /** verifies that two matrices are close (1-norm) */     protected void assertClose(String msg, RealMatrix m, RealMatrix n,             double tolerance) {         Assert.assertTrue(msg, m.subtract(n).getNorm() < tolerance);     }      /** verifies that two vectors are close (sup norm) */     protected void assertClose(String msg, double[] m, double[] n,             double tolerance) {         if (m.length != n.length) {             Assert.fail("vectors not same length");         }         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(msg + " " + i + " elements differ", m[i], n[i],                     tolerance);         }     }      private OpenMapRealMatrix createSparseMatrix(double[][] data) {         OpenMapRealMatrix matrix = new OpenMapRealMatrix(data.length, data[0].length);         for (int row = 0; row < data.length; row++) {             for (int col = 0; col < data[row].length; col++) {                 matrix.setEntry(row, col, data[row][col]);             }         }         return matrix;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.numbers.combinatorics.BinomialCoefficient;  /**  * This class implements inverses of Hilbert Matrices as  * {@link RealLinearOperator}.  */ public class InverseHilbertMatrix     extends RealLinearOperator {      /** The size of the matrix. */     private final int n;      /**      * Creates a new instance of this class.      *      * @param n Size of the matrix to be created.      */     public InverseHilbertMatrix(final int n) {         this.n = n;     }      /** {@inheritDoc} */     @Override     public int getColumnDimension() {         return n;     }      /**      * Returns the {@code (i, j)} entry of the inverse Hilbert matrix. Exact      * arithmetic is used; in case of overflow, an exception is thrown.      *      * @param i Row index (starts at 0).      * @param j Column index (starts at 0).      * @return The coefficient of the inverse Hilbert matrix.      */     public long getEntry(final int i, final int j) {         long val = i + j + 1;         long aux = BinomialCoefficient.value(n + i, n - j - 1);         val = Math.multiplyExact(val, aux);         aux = BinomialCoefficient.value(n + j, n - i - 1);         val = Math.multiplyExact(val, aux);         aux = BinomialCoefficient.value(i + j, i);         val = Math.multiplyExact(val, aux);         val = Math.multiplyExact(val, aux);         return ((i + j) & 1) == 0 ? val : -val;     }      /** {@inheritDoc} */     @Override     public int getRowDimension() {         return n;     }      /** {@inheritDoc} */     @Override     public RealVector operate(final RealVector x) {         if (x.getDimension() != n) {             throw new DimensionMismatchException(x.getDimension(), n);         }         final double[] y = new double[n];         for (int i = 0; i < n; i++) {             double pos = 0.;             double neg = 0.;             for (int j = 0; j < n; j++) {                 final double xj = x.getEntry(j);                 final long coeff = getEntry(i, j);                 final double daux = coeff * xj;                 // Positive and negative values are sorted out in order to limit                 // catastrophic cancellations (do not forget that Hilbert                 // matrices are *very* ill-conditioned!                 if (daux > 0.) {                     pos += daux;                 } else {                     neg += daux;                 }             }             y[i] = pos + neg;         }         return new ArrayRealVector(y, false);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  /**  * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for  * unmodifiable views of {@link ArrayRealVectorTest}.  *  */ public class UnmodifiableArrayRealVectorTest     extends UnmodifiableRealVectorAbstractTest {     /**      * Returns a random vector of type {@link ArrayRealVector}.      *      * @return a new random {@link ArrayRealVector}.      */     @Override     public RealVector createVector() {         ArrayRealVector v = new ArrayRealVector(DIM);         for (int i = 0; i < DIM; i++) {             v.setEntry(i, RANDOM.nextDouble());         }         return v;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.dfp.DfpField;  /**  * Dummy class for testing {@link org.apache.commons.math4.Field} functionalities.  */ public class Dfp25 {     private static final DfpField FIELD = new DfpField(25);     public static final Dfp ZERO = FIELD.newDfp(0d);     public static final Dfp ONE = of(1d);     public static final Dfp TWO = of(2d);      public static Dfp of(double x) {         return ZERO.newInstance(x);     }     public static Dfp of(double x, double y) {         return of(x).divide(of(y));     }      public static DfpField getField() {         return FIELD;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Abs; import org.apache.commons.math4.analysis.function.Acos; import org.apache.commons.math4.analysis.function.Asin; import org.apache.commons.math4.analysis.function.Atan; import org.apache.commons.math4.analysis.function.Cbrt; import org.apache.commons.math4.analysis.function.Ceil; import org.apache.commons.math4.analysis.function.Cos; import org.apache.commons.math4.analysis.function.Cosh; import org.apache.commons.math4.analysis.function.Exp; import org.apache.commons.math4.analysis.function.Expm1; import org.apache.commons.math4.analysis.function.Floor; import org.apache.commons.math4.analysis.function.Log1p; import org.apache.commons.math4.analysis.function.Power; import org.apache.commons.math4.analysis.function.Rint; import org.apache.commons.math4.analysis.function.Signum; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.Sinh; import org.apache.commons.math4.analysis.function.Sqrt; import org.apache.commons.math4.analysis.function.Tan; import org.apache.commons.math4.analysis.function.Tanh; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link OpenMapRealVector} class.  *  */ public class SparseRealVectorTest extends RealVectorAbstractTest {      @Override     public RealVector create(double[] data) {         return new OpenMapRealVector(data);     }      @Test     public void testConstructors() {         final double[] vec1 = {1d, 2d, 3d};         final Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};          OpenMapRealVector v0 = new OpenMapRealVector();         Assert.assertEquals("testData len", 0, v0.getDimension());          OpenMapRealVector v1 = new OpenMapRealVector(7);         Assert.assertEquals("testData len", 7, v1.getDimension());         Assert.assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6), 0);          OpenMapRealVector v3 = new OpenMapRealVector(vec1);         Assert.assertEquals("testData len", 3, v3.getDimension());         Assert.assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1), 0);          //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2);         //Assert.assertEquals("testData len", 2, v4.getDimension());         //Assert.assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));         //try {         //    new SparseRealVector(vec4, 8, 3);         //    Assert.fail("MathIllegalArgumentException expected");         //} catch (MathIllegalArgumentException ex) {             // expected behavior         //}          RealVector v5_i = new OpenMapRealVector(dvec1);         Assert.assertEquals("testData len", 9, v5_i.getDimension());         Assert.assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8), 0);          OpenMapRealVector v5 = new OpenMapRealVector(dvec1);         Assert.assertEquals("testData len", 9, v5.getDimension());         Assert.assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8), 0);          OpenMapRealVector v7 = new OpenMapRealVector(v1);         Assert.assertEquals("testData len", 7, v7.getDimension());         Assert.assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6), 0);          RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);          OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i);         Assert.assertEquals("testData len", 3, v7_2.getDimension());         Assert.assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1), 0);          OpenMapRealVector v8 = new OpenMapRealVector(v1);         Assert.assertEquals("testData len", 7, v8.getDimension());         Assert.assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6), 0);      }      /* Check that the operations do not throw an exception (cf. MATH-645). */     @Test     public void testConcurrentModification() {         final RealVector u = new OpenMapRealVector(3, 1e-6);         u.setEntry(0, 1);         u.setEntry(1, 0);         u.setEntry(2, 2);          final RealVector v1 = new OpenMapRealVector(3, 1e-6);         v1.setEntry(0, 0);         v1.setEntry(1, 3);         v1.setEntry(2, 0);          u.ebeMultiply(v1);         u.ebeDivide(v1);     }      @Test     @Override     public void testEbeMultiplyMixedTypes() {         doTestEbeBinaryOperation(BinaryOperation.MUL, true, true);     }      @Test     @Override     public void testEbeMultiplySameType() {         doTestEbeBinaryOperation(BinaryOperation.MUL, false, true);     }      @Test     @Override     public void testEbeDivideSameType() {         doTestEbeBinaryOperation(BinaryOperation.DIV, false, true);     }      @Override     protected UnivariateFunction[] createFunctions() {         return new UnivariateFunction[] {             new Power(2.0), new Exp(), new Expm1(),             new Log1p(), new Cosh(), new Sinh(), new Tanh(), new Cos(),             new Sin(), new Tan(), new Acos(), new Asin(), new Atan(),             new Abs(), new Sqrt(), new Cbrt(), new Ceil(),             new Floor(), new Rint(), new Signum()         };     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link MatrixDimensionMismatchException}.  *  */ public class MatrixDimensionMismatchExceptionTest {     @Test     public void testAccessors() {         final MatrixDimensionMismatchException e             = new MatrixDimensionMismatchException(1, 2, 3, 4);         Assert.assertEquals(1, e.getWrongRowDimension());         Assert.assertEquals(2, e.getWrongColumnDimension());         Assert.assertEquals(3, e.getExpectedRowDimension());         Assert.assertEquals(4, e.getExpectedColumnDimension());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Random;  import org.junit.Assert; import org.junit.Test;   public class QRDecompositionTest {     private double[][] testData3x3NonSingular = {             { 12, -51, 4 },             { 6, 167, -68 },             { -4, 24, -41 }, };      private double[][] testData3x3Singular = {             { 1, 4, 7, },             { 2, 5, 8, },             { 3, 6, 9, }, };      private double[][] testData3x4 = {             { 12, -51, 4, 1 },             { 6, 167, -68, 2 },             { -4, 24, -41, 3 }, };      private double[][] testData4x3 = {             { 12, -51, 4, },             { 6, 167, -68, },             { -4, 24, -41, },             { -5, 34, 7, }, };      private static final double entryTolerance = 10e-16;      private static final double normTolerance = 10e-14;      /** test dimensions */     @Test     public void testDimensions() {         checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));          checkDimension(MatrixUtils.createRealMatrix(testData4x3));          checkDimension(MatrixUtils.createRealMatrix(testData3x4));          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         checkDimension(createTestMatrix(r, p, q));         checkDimension(createTestMatrix(r, q, p));      }      private void checkDimension(RealMatrix m) {         int rows = m.getRowDimension();         int columns = m.getColumnDimension();         QRDecomposition qr = new QRDecomposition(m);         Assert.assertEquals(rows,    qr.getQ().getRowDimension());         Assert.assertEquals(rows,    qr.getQ().getColumnDimension());         Assert.assertEquals(rows,    qr.getR().getRowDimension());         Assert.assertEquals(columns, qr.getR().getColumnDimension());     }      /** test A = QR */     @Test     public void testAEqualQR() {         checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));          checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));          checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));          checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         checkAEqualQR(createTestMatrix(r, p, q));          checkAEqualQR(createTestMatrix(r, q, p));      }      private void checkAEqualQR(RealMatrix m) {         QRDecomposition qr = new QRDecomposition(m);         double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();         Assert.assertEquals(0, norm, normTolerance);     }      /** test the orthogonality of Q */     @Test     public void testQOrthogonal() {         checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));          checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));          checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));          checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         checkQOrthogonal(createTestMatrix(r, p, q));          checkQOrthogonal(createTestMatrix(r, q, p));      }      private void checkQOrthogonal(RealMatrix m) {         QRDecomposition qr = new QRDecomposition(m);         RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());         double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();         Assert.assertEquals(0, norm, normTolerance);     }      /** test that R is upper triangular */     @Test     public void testRUpperTriangular() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);         checkUpperTriangular(new QRDecomposition(matrix).getR());          matrix = MatrixUtils.createRealMatrix(testData3x3Singular);         checkUpperTriangular(new QRDecomposition(matrix).getR());          matrix = MatrixUtils.createRealMatrix(testData3x4);         checkUpperTriangular(new QRDecomposition(matrix).getR());          matrix = MatrixUtils.createRealMatrix(testData4x3);         checkUpperTriangular(new QRDecomposition(matrix).getR());          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         matrix = createTestMatrix(r, p, q);         checkUpperTriangular(new QRDecomposition(matrix).getR());          matrix = createTestMatrix(r, p, q);         checkUpperTriangular(new QRDecomposition(matrix).getR());      }      private void checkUpperTriangular(RealMatrix m) {         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {             @Override             public void visit(int row, int column, double value) {                 if (column < row) {                     Assert.assertEquals(0.0, value, entryTolerance);                 }             }         });     }      /** test that H is trapezoidal */     @Test     public void testHTrapezoidal() {         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);         checkTrapezoidal(new QRDecomposition(matrix).getH());          matrix = MatrixUtils.createRealMatrix(testData3x3Singular);         checkTrapezoidal(new QRDecomposition(matrix).getH());          matrix = MatrixUtils.createRealMatrix(testData3x4);         checkTrapezoidal(new QRDecomposition(matrix).getH());          matrix = MatrixUtils.createRealMatrix(testData4x3);         checkTrapezoidal(new QRDecomposition(matrix).getH());          Random r = new Random(643895747384642l);         int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;         int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;         matrix = createTestMatrix(r, p, q);         checkTrapezoidal(new QRDecomposition(matrix).getH());          matrix = createTestMatrix(r, p, q);         checkTrapezoidal(new QRDecomposition(matrix).getH());      }      private void checkTrapezoidal(RealMatrix m) {         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {             @Override             public void visit(int row, int column, double value) {                 if (column > row) {                     Assert.assertEquals(0.0, value, entryTolerance);                 }             }         });     }     /** test matrices values */     @Test     public void testMatricesValues() {         QRDecomposition qr =             new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));         RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {                 { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },                 {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },                 {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }         });         RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {                 { -14.0,  -21.0, 14.0 },                 {   0.0, -175.0, 70.0 },                 {   0.0,    0.0, 35.0 }         });         RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {                 { 26.0 / 14.0, 0.0, 0.0 },                 {  6.0 / 14.0, 648.0 / 325.0, 0.0 },                 { -4.0 / 14.0,  36.0 / 325.0, 2.0 }         });          // check values against known references         RealMatrix q = qr.getQ();         Assert.assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);         RealMatrix qT = qr.getQT();         Assert.assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);         RealMatrix r = qr.getR();         Assert.assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);         RealMatrix h = qr.getH();         Assert.assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);          // check the same cached instance is returned the second time         Assert.assertTrue(q == qr.getQ());         Assert.assertTrue(r == qr.getR());         Assert.assertTrue(h == qr.getH());      }      @Test(expected=SingularMatrixException.class)     public void testNonInvertible() {         QRDecomposition qr =             new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular));         qr.getSolver().getInverse();     }      @Test     public void testInvertTallSkinny() {         RealMatrix a     = MatrixUtils.createRealMatrix(testData4x3);         RealMatrix pinv  = new QRDecomposition(a).getSolver().getInverse();         Assert.assertEquals(0, pinv.multiply(a).subtract(MatrixUtils.createRealIdentityMatrix(3)).getNorm(), 1.0e-6);     }      @Test     public void testInvertShortWide() {         RealMatrix a = MatrixUtils.createRealMatrix(testData3x4);         RealMatrix pinv  = new QRDecomposition(a).getSolver().getInverse();         Assert.assertEquals(0, a.multiply(pinv).subtract(MatrixUtils.createRealIdentityMatrix(3)).getNorm(), 1.0e-6);         Assert.assertEquals(0, pinv.multiply(a).getSubMatrix(0, 2, 0, 2).subtract(MatrixUtils.createRealIdentityMatrix(3)).getNorm(), 1.0e-6);     }      private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {         RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);         m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){             @Override             public double visit(int row, int column, double value) {                 return 2.0 * r.nextDouble() - 1.0;             }         });         return m;     }      @Test(expected=SingularMatrixException.class)     public void testQRSingular() {         final RealMatrix a = MatrixUtils.createRealMatrix(new double[][] {             { 1, 6, 4 }, { 2, 4, -1 }, { -1, 2, 5 }         });         final RealVector b = new ArrayRealVector(new double[]{ 5, 6, 1 });         new QRDecomposition(a, 1.0e-15).getSolver().solve(b);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Arrays;  import org.apache.commons.math4.util.FastMath; import org.junit.Test; import org.junit.Assert;  public class TriDiagonalTransformerTest {      private double[][] testSquare5 = {             { 1, 2, 3, 1, 1 },             { 2, 1, 1, 3, 1 },             { 3, 1, 1, 1, 2 },             { 1, 3, 1, 2, 1 },             { 1, 1, 2, 1, 3 }     };      private double[][] testSquare3 = {             { 1, 3, 4 },             { 3, 2, 2 },             { 4, 2, 0 }     };      @Test     public void testNonSquare() {         try {             new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));             Assert.fail("an exception should have been thrown");         } catch (NonSquareMatrixException ime) {             // expected behavior         }     }      @Test     public void testAEqualQTQt() {         checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));         checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));     }      private void checkAEqualQTQt(RealMatrix matrix) {         TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);         RealMatrix q  = transformer.getQ();         RealMatrix qT = transformer.getQT();         RealMatrix t  = transformer.getT();         double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();         Assert.assertEquals(0, norm, 4.0e-15);     }      @Test     public void testNoAccessBelowDiagonal() {         checkNoAccessBelowDiagonal(testSquare5);         checkNoAccessBelowDiagonal(testSquare3);     }      private void checkNoAccessBelowDiagonal(double[][] data) {         double[][] modifiedData = new double[data.length][];         for (int i = 0; i < data.length; ++i) {             modifiedData[i] = data[i].clone();             Arrays.fill(modifiedData[i], 0, i, Double.NaN);         }         RealMatrix matrix = MatrixUtils.createRealMatrix(modifiedData);         TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);         RealMatrix q  = transformer.getQ();         RealMatrix qT = transformer.getQT();         RealMatrix t  = transformer.getT();         double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm();         Assert.assertEquals(0, norm, 4.0e-15);     }      @Test     public void testQOrthogonal() {         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());     }      @Test     public void testQTOrthogonal() {         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());     }      private void checkOrthogonal(RealMatrix m) {         RealMatrix mTm = m.transpose().multiply(m);         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());         Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);     }      @Test     public void testTTriDiagonal() {         checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());         checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());     }      private void checkTriDiagonal(RealMatrix m) {         final int rows = m.getRowDimension();         final int cols = m.getColumnDimension();         for (int i = 0; i < rows; ++i) {             for (int j = 0; j < cols; ++j) {                 if ((i < j - 1) || (i > j + 1)) {                     Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                 }             }         }     }      @Test     public void testMatricesValues5() {         checkMatricesValues(testSquare5,                             new double[][] {                                 { 1.0,  0.0,                 0.0,                  0.0,                   0.0 },                                 { 0.0, -0.5163977794943222,  0.016748280772542083, 0.839800693771262,     0.16669620021405473 },                                 { 0.0, -0.7745966692414833, -0.4354553000860955,  -0.44989322880603355,  -0.08930153582895772 },                                 { 0.0, -0.2581988897471611,  0.6364346693566014,  -0.30263204032131164,   0.6608313651342882 },                                 { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }                             },                             new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },                             new double[] { -FastMath.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });     }      @Test     public void testMatricesValues3() {         checkMatricesValues(testSquare3,                             new double[][] {                                 {  1.0,  0.0,  0.0 },                                 {  0.0, -0.6,  0.8 },                                 {  0.0, -0.8, -0.6 },                             },                             new double[] { 1, 2.64, -0.64 },                             new double[] { -5, -1.52 });     }      private void checkMatricesValues(double[][] matrix, double[][] qRef,                                      double[] mainDiagnonal,                                      double[] secondaryDiagonal) {         TriDiagonalTransformer transformer =             new TriDiagonalTransformer(MatrixUtils.createRealMatrix(matrix));          // check values against known references         RealMatrix q = transformer.getQ();         Assert.assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);          RealMatrix t = transformer.getT();         double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];         for (int i = 0; i < mainDiagnonal.length; ++i) {             tData[i][i] = mainDiagnonal[i];             if (i > 0) {                 tData[i][i - 1] = secondaryDiagonal[i - 1];             }             if (i < secondaryDiagonal.length) {                 tData[i][i + 1] = secondaryDiagonal[i];             }         }         Assert.assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);          // check the same cached instance is returned the second time         Assert.assertTrue(q == transformer.getQ());         Assert.assertTrue(t == transformer.getT());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.linear;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.util.FastMath;  /**  * Test cases for the {@link Array2DRowRealMatrix} class.  *  */  public final class Array2DRowRealMatrixTest {      // 3 x 3 identity matrix     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };      // Test data for group operations     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };     protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};     protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };     protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };     protected double[] testDataRow1 = {1d,2d,3d};     protected double[] testDataCol3 = {3d,3d,8d};     protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };     protected double[] preMultTest = {8,12,33};     protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};     protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};     protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };      // lu decomposition tests     protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };     protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},             {0.33333333333333,0d,0.33333333333333} };      // singular matrices     protected double[][] singular = { {2d,3d}, {2d,3d} };     protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},         {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd     protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };     protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};      // vectors     protected double[] testVector = {1,2,3};     protected double[] testVector2 = {1,2,3,4};      // submatrix accessor tests     protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},             {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections     protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};     protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};     protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};     // effective permutations     protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};     protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};     // contiguous ranges     protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};     protected double[][] subRows23Cols00 = {{2} , {4}};     protected double[][] subRows00Cols33 = {{4}};     // row matrices     protected double[][] subRow0 = {{1,2,3,4}};     protected double[][] subRow3 = {{4,5,6,7}};     // column matrices     protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};     protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};      // tolerances     protected double entryTolerance = 10E-16;     protected double normTolerance = 10E-14;     protected double powerTolerance = 10E-16;      /** test dimensions */     @Test     public void testDimensions() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);         Assert.assertEquals("testData row dimension",3,m.getRowDimension());         Assert.assertEquals("testData column dimension",3,m.getColumnDimension());         Assert.assertTrue("testData is square",m.isSquare());         Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);         Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);         Assert.assertTrue("testData2 is not square",!m2.isSquare());     }      /** test copy functions */     @Test     public void testCopyFunctions() {         Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData());         Assert.assertEquals(m2,m1);         Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);         Assert.assertEquals(m4,m3);     }      /** test add */     @Test     public void testAdd() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);         RealMatrix mPlusMInv = m.add(mInv);         double[][] sumEntries = mPlusMInv.getData();         for (int row = 0; row < m.getRowDimension(); row++) {             for (int col = 0; col < m.getColumnDimension(); col++) {                 Assert.assertEquals("sum entry entry",                     testDataPlusInv[row][col],sumEntries[row][col],                         entryTolerance);             }         }     }      /** test add failure */     @Test     public void testAddFail() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);         try {             m.add(m2);             Assert.fail("MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test norm */     @Test     public void testNorm() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);         Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance);         Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);     }      /** test Frobenius norm */     @Test     public void testFrobeniusNorm() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);         Assert.assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);         Assert.assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);     }       /** test m-n = m + -n */     @Test     public void testPlusMinus() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);         TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),             m2.scalarMultiply(-1d).add(m),entryTolerance);         try {             m.subtract(new Array2DRowRealMatrix(testData2));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test multiply */     @Test     public void testMultiply() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);         Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);         TestUtils.assertEquals("inverse multiply",m.multiply(mInv),             identity,entryTolerance);         TestUtils.assertEquals("inverse multiply",mInv.multiply(m),             identity,entryTolerance);         TestUtils.assertEquals("identity multiply",m.multiply(identity),             m,entryTolerance);         TestUtils.assertEquals("identity multiply",identity.multiply(mInv),             mInv,entryTolerance);         TestUtils.assertEquals("identity multiply",m2.multiply(identity),             m2,entryTolerance);         try {             m.multiply(new Array2DRowRealMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      //Additional Test for Array2DRowRealMatrixTest.testMultiply      private final double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};     private final double[][] d4 = new double[][] {{1},{2},{3},{4}};     private final double[][] d5 = new double[][] {{30},{70}};      @Test     public void testMultiply2() {        RealMatrix m3 = new Array2DRowRealMatrix(d3);        RealMatrix m4 = new Array2DRowRealMatrix(d4);        RealMatrix m5 = new Array2DRowRealMatrix(d5);        TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);    }      @Test     public void testPower() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);         Array2DRowRealMatrix mPlusInv = new Array2DRowRealMatrix(testDataPlusInv);         Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);          TestUtils.assertEquals("m^0", m.power(0),             identity, entryTolerance);         TestUtils.assertEquals("mInv^0", mInv.power(0),                 identity, entryTolerance);         TestUtils.assertEquals("mPlusInv^0", mPlusInv.power(0),                 identity, entryTolerance);          TestUtils.assertEquals("m^1", m.power(1),                 m, entryTolerance);         TestUtils.assertEquals("mInv^1", mInv.power(1),                 mInv, entryTolerance);         TestUtils.assertEquals("mPlusInv^1", mPlusInv.power(1),                 mPlusInv, entryTolerance);          RealMatrix C1 = m.copy();         RealMatrix C2 = mInv.copy();         RealMatrix C3 = mPlusInv.copy();          for (int i = 2; i <= 10; ++i) {             C1 = C1.multiply(m);             C2 = C2.multiply(mInv);             C3 = C3.multiply(mPlusInv);              TestUtils.assertEquals("m^" + i, m.power(i),                     C1, entryTolerance);             TestUtils.assertEquals("mInv^" + i, mInv.power(i),                     C2, entryTolerance);             TestUtils.assertEquals("mPlusInv^" + i, mPlusInv.power(i),                     C3, entryTolerance);         }          try {             Array2DRowRealMatrix mNotSquare = new Array2DRowRealMatrix(testData2T);             mNotSquare.power(2);             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }          try {             m.power(-1);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test trace */     @Test     public void testTrace() {         RealMatrix m = new Array2DRowRealMatrix(id);         Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance);         m = new Array2DRowRealMatrix(testData2);         try {             m.getTrace();             Assert.fail("Expecting NonSquareMatrixException");         } catch (NonSquareMatrixException ex) {             // ignored         }     }      /** test scalarAdd */     @Test     public void testScalarAdd() {         RealMatrix m = new Array2DRowRealMatrix(testData);         TestUtils.assertEquals("scalar add",new Array2DRowRealMatrix(testDataPlus2),             m.scalarAdd(2d),entryTolerance);     }      /** test operate */     @Test     public void testOperate() {         RealMatrix m = new Array2DRowRealMatrix(id);         TestUtils.assertEquals("identity operate", testVector,                     m.operate(testVector), entryTolerance);         TestUtils.assertEquals("identity operate", testVector,                     m.operate(new ArrayRealVector(testVector)).toArray(), entryTolerance);         m = new Array2DRowRealMatrix(bigSingular);         try {             m.operate(testVector);             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      /** test issue MATH-209 */     @Test     public void testMath209() {         RealMatrix a = new Array2DRowRealMatrix(new double[][] {                 { 1, 2 }, { 3, 4 }, { 5, 6 }         }, false);         double[] b = a.operate(new double[] { 1, 1 });         Assert.assertEquals(a.getRowDimension(), b.length);         Assert.assertEquals( 3.0, b[0], 1.0e-12);         Assert.assertEquals( 7.0, b[1], 1.0e-12);         Assert.assertEquals(11.0, b[2], 1.0e-12);     }      /** test transpose */     @Test     public void testTranspose() {         RealMatrix m = new Array2DRowRealMatrix(testData);         RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose();         RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse();         TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance);         m = new Array2DRowRealMatrix(testData2);         RealMatrix mt = new Array2DRowRealMatrix(testData2T);         TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);     }      /** test preMultiply by vector */     @Test     public void testPremultiplyVector() {         RealMatrix m = new Array2DRowRealMatrix(testData);         TestUtils.assertEquals("premultiply", m.preMultiply(testVector),                     preMultTest, normTolerance);         TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).toArray()),                     preMultTest, normTolerance);         m = new Array2DRowRealMatrix(bigSingular);         try {             m.preMultiply(testVector);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testPremultiply() {         RealMatrix m3 = new Array2DRowRealMatrix(d3);         RealMatrix m4 = new Array2DRowRealMatrix(d4);         RealMatrix m5 = new Array2DRowRealMatrix(d5);         TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);          Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);         Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);         TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),                 identity,entryTolerance);         TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),                 identity,entryTolerance);         TestUtils.assertEquals("identity multiply",m.preMultiply(identity),                 m,entryTolerance);         TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),                 mInv,entryTolerance);         try {             m.preMultiply(new Array2DRowRealMatrix(bigSingular));             Assert.fail("Expecting illegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // ignored         }     }      @Test     public void testGetVectors() {         RealMatrix m = new Array2DRowRealMatrix(testData);         TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);         TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);         try {             m.getRow(10);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }         try {             m.getColumn(-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // ignored         }     }      @Test     public void testGetEntry() {         RealMatrix m = new Array2DRowRealMatrix(testData);         Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);         try {             m.getEntry(10, 4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      /** test examples in user guide */     @Test     public void testExamples() {         // Create a real matrix with two rows and three columns         double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};         RealMatrix m = new Array2DRowRealMatrix(matrixData);         // One more with three rows, two columns         double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};         RealMatrix n = new Array2DRowRealMatrix(matrixData2);         // Now multiply m by n         RealMatrix p = m.multiply(n);         Assert.assertEquals(2, p.getRowDimension());         Assert.assertEquals(2, p.getColumnDimension());         // Invert p         RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse();         Assert.assertEquals(2, pInverse.getRowDimension());         Assert.assertEquals(2, pInverse.getColumnDimension());          // Solve example         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};         RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);         RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false);         RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants);         final double cst0 = constants.getEntry(0);         final double cst1 = constants.getEntry(1);         final double cst2 = constants.getEntry(2);         final double sol0 = solution.getEntry(0);         final double sol1 = solution.getEntry(1);         final double sol2 = solution.getEntry(2);         Assert.assertEquals(2 * sol0 + 3 * sol1 -2 * sol2, cst0, 1E-12);         Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12);         Assert.assertEquals(4 * sol0 - 3 * sol1 -5 * sol2, cst2, 1E-12);     }      // test submatrix accessors     @Test     public void testGetSubMatrix() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);         checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);         checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);         checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);         checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);         checkGetSubMatrix(m, null, -1, 1, 2, 2, true);         checkGetSubMatrix(m, null,  1, 0, 2, 2, true);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);         checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);         checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);     }      private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                    int startRow, int endRow, int startColumn, int endColumn,                                    boolean mustFail) {         try {             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);             Assert.assertEquals(new Array2DRowRealMatrix(reference), sub);             if (mustFail) {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (!mustFail) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (!mustFail) {                 throw e;             }         } catch (NoDataException e) {             if (!mustFail) {                 throw e;             }         }     }      private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                    int[] selectedRows, int[] selectedColumns,                                    boolean mustFail) {         try {             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);             Assert.assertEquals(new Array2DRowRealMatrix(reference), sub);             if (mustFail) {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (!mustFail) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (!mustFail) {                 throw e;             }         } catch (NoDataException e) {             if (!mustFail) {                 throw e;             }         }     }      @Test     public void testCopySubMatrix() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);         checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);         checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);         checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);         checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);          checkCopy(m, null,  1, 0, 2, 4, true);         checkCopy(m, null, -1, 1, 2, 2, true);         checkCopy(m, null,  1, 0, 2, 2, true);         checkCopy(m, null,  1, 0, 2, 4, true);         checkCopy(m, null, new int[] {},    new int[] { 0 }, true);         checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);          // rectangular check         double[][] copy = new double[][] { { 0, 0, 0 }, { 0, 0 } };         checkCopy(m, copy, 0, 1, 0, 2, true);         checkCopy(m, copy, new int[] { 0, 1 }, new int[] { 0, 1, 2 }, true);     }      private void checkCopy(RealMatrix m, double[][] reference,                            int startRow, int endRow, int startColumn, int endColumn,                            boolean mustFail) {         try {             double[][] sub = (reference == null) ?                              new double[1][1] : createIdenticalCopy(reference);             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);             Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));             if (mustFail) {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (!mustFail) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (!mustFail) {                 throw e;             }         } catch (NoDataException e) {             if (!mustFail) {                 throw e;             }         } catch (MatrixDimensionMismatchException e) {             if (!mustFail) {                 throw e;             }         }     }      private void checkCopy(RealMatrix m, double[][] reference,                            int[] selectedRows, int[] selectedColumns,                            boolean mustFail) {         try {             double[][] sub = (reference == null) ?                     new double[1][1] : createIdenticalCopy(reference);             m.copySubMatrix(selectedRows, selectedColumns, sub);             Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));             if (mustFail) {                 Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");             }         } catch (OutOfRangeException e) {             if (!mustFail) {                 throw e;             }         } catch (NumberIsTooSmallException e) {             if (!mustFail) {                 throw e;             }         } catch (NoDataException e) {             if (!mustFail) {                 throw e;             }         } catch (MatrixDimensionMismatchException e) {             if (!mustFail) {                 throw e;             }         }     }      private double[][] createIdenticalCopy(final double[][] matrix) {         final double[][] matrixCopy = new double[matrix.length][];         for (int i = 0; i < matrixCopy.length; i++) {             matrixCopy[i] = new double[matrix[i].length];         }         return matrixCopy;     }      @Test     public void testGetRowMatrix() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);         RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);         Assert.assertEquals("Row0", mRow0,                 m.getRowMatrix(0));         Assert.assertEquals("Row3", mRow3,                 m.getRowMatrix(3));         try {             m.getRowMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowMatrix() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowMatrix(0, mRow3);         Assert.assertEquals(mRow3, m.getRowMatrix(0));         try {             m.setRowMatrix(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetColumnMatrix() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);         RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);         Assert.assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));         Assert.assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));         try {             m.getColumnMatrix(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnMatrix(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnMatrix() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));         m.setColumnMatrix(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnMatrix(1));         try {             m.setColumnMatrix(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnMatrix(0, m);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetRowVector() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealVector mRow0 = new ArrayRealVector(subRow0[0]);         RealVector mRow3 = new ArrayRealVector(subRow3[0]);         Assert.assertEquals("Row0", mRow0, m.getRowVector(0));         Assert.assertEquals("Row3", mRow3, m.getRowVector(3));         try {             m.getRowVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRowVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRowVector() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealVector mRow3 = new ArrayRealVector(subRow3[0]);         Assert.assertNotSame(mRow3, m.getRowMatrix(0));         m.setRowVector(0, mRow3);         Assert.assertEquals(mRow3, m.getRowVector(0));         try {             m.setRowVector(-1, mRow3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRowVector(0, new ArrayRealVector(5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetColumnVector() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealVector mColumn1 = columnToVector(subColumn1);         RealVector mColumn3 = columnToVector(subColumn3);         Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));         Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));         try {             m.getColumnVector(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumnVector(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumnVector() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         RealVector mColumn3 = columnToVector(subColumn3);         Assert.assertNotSame(mColumn3, m.getColumnVector(1));         m.setColumnVector(1, mColumn3);         Assert.assertEquals(mColumn3, m.getColumnVector(1));         try {             m.setColumnVector(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumnVector(0, new ArrayRealVector(5));             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      private RealVector columnToVector(double[][] column) {         double[] data = new double[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return new ArrayRealVector(data, false);     }      @Test     public void testGetRow() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         checkArrays(subRow0[0], m.getRow(0));         checkArrays(subRow3[0], m.getRow(3));         try {             m.getRow(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getRow(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetRow() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);         m.setRow(0, subRow3[0]);         checkArrays(subRow3[0], m.getRow(0));         try {             m.setRow(-1, subRow3[0]);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setRow(0, new double[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      @Test     public void testGetColumn() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         double[] mColumn1 = columnToArray(subColumn1);         double[] mColumn3 = columnToArray(subColumn3);         checkArrays(mColumn1, m.getColumn(1));         checkArrays(mColumn3, m.getColumn(3));         try {             m.getColumn(-1);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.getColumn(4);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testSetColumn() {         RealMatrix m = new Array2DRowRealMatrix(subTestData);         double[] mColumn3 = columnToArray(subColumn3);         Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);         m.setColumn(1, mColumn3);         checkArrays(mColumn3, m.getColumn(1));         try {             m.setColumn(-1, mColumn3);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }         try {             m.setColumn(0, new double[5]);             Assert.fail("Expecting MatrixDimensionMismatchException");         } catch (MatrixDimensionMismatchException ex) {             // expected         }     }      private double[] columnToArray(double[][] column) {         double[] data = new double[column.length];         for (int i = 0; i < data.length; ++i) {             data[i] = column[i][0];         }         return data;     }      private void checkArrays(double[] expected, double[] actual) {         Assert.assertEquals(expected.length, actual.length);         for (int i = 0; i < expected.length; ++i) {             Assert.assertEquals(expected[i], actual[i], 0);         }     }      @Test     public void testEqualsAndHashCode() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();         Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose();         Assert.assertTrue(m.hashCode() != mt.hashCode());         Assert.assertEquals(m.hashCode(), m1.hashCode());         Assert.assertEquals(m, m);         Assert.assertEquals(m, m1);         Assert.assertFalse(m.equals(null));         Assert.assertFalse(m.equals(mt));         Assert.assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));     }      @Test     public void testToString() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Assert.assertEquals("Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                 m.toString());         m = new Array2DRowRealMatrix();         Assert.assertEquals("Array2DRowRealMatrix{}",                 m.toString());     }      @Test     public void testSetSubMatrix() {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         m.setSubMatrix(detData2,1,1);         RealMatrix expected = MatrixUtils.createRealMatrix             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});         Assert.assertEquals(expected, m);          m.setSubMatrix(detData2,0,0);         expected = MatrixUtils.createRealMatrix             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});         Assert.assertEquals(expected, m);          m.setSubMatrix(testDataPlus2,0,0);         expected = MatrixUtils.createRealMatrix             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});         Assert.assertEquals(expected, m);          // dimension overflow         try {             m.setSubMatrix(testData,1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         // dimension underflow         try {             m.setSubMatrix(testData,-1,1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }         try {             m.setSubMatrix(testData,1,-1);             Assert.fail("expecting OutOfRangeException");         } catch (OutOfRangeException e) {             // expected         }          // null         try {             m.setSubMatrix(null,1,1);             Assert.fail("expecting NullArgumentException");         } catch (NullArgumentException e) {             // expected         }         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();         try {             m2.setSubMatrix(testData,0,1);             Assert.fail("expecting MathIllegalStateException");         } catch (MathIllegalStateException e) {             // expected         }         try {             m2.setSubMatrix(testData,1,0);             Assert.fail("expecting MathIllegalStateException");         } catch (MathIllegalStateException e) {             // expected         }          // ragged         try {             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }          // empty         try {             m.setSubMatrix(new double[][] {{}}, 0, 0);             Assert.fail("expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException e) {             // expected         }     }      @Test     public void testWalk() {         int rows    = 150;         int columns = 75;          RealMatrix m = new Array2DRowRealMatrix(rows, columns);         m.walkInRowOrder(new SetVisitor());         GetVisitor getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowRealMatrix(rows, columns);         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }          m = new Array2DRowRealMatrix(rows, columns);         m.walkInColumnOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowRealMatrix(rows, columns);         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }          m = new Array2DRowRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }          m = new Array2DRowRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor());         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor);         Assert.assertEquals(rows * columns, getVisitor.getCount());          m = new Array2DRowRealMatrix(rows, columns);         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);         getVisitor = new GetVisitor();         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);         Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());         for (int i = 0; i < rows; ++i) {             Assert.assertEquals(0.0, m.getEntry(i, 0), 0);             Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);         }         for (int j = 0; j < columns; ++j) {             Assert.assertEquals(0.0, m.getEntry(0, j), 0);             Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);         }     }      @Test     public void testSerial()  {         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);         Assert.assertEquals(m,TestUtils.serializeAndRecover(m));     }       private static class SetVisitor extends DefaultRealMatrixChangingVisitor {         @Override         public double visit(int i, int j, double value) {             return i + j / 1024.0;         }     }      private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {         private int count = 0;         @Override         public void visit(int i, int j, double value) {             ++count;             Assert.assertEquals(i + j / 1024.0, value, 0.0);         }         public int getCount() {             return count;         }     }      //--------------- -----------------Protected methods      /** extracts the l  and u matrices from compact lu representation */     protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) {         if (!lu.isSquare()) {             throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension());         }         if (lowerData.length != lowerData[0].length) {             throw new DimensionMismatchException(lowerData.length, lowerData[0].length);         }         if (upperData.length != upperData[0].length) {             throw new DimensionMismatchException(upperData.length, upperData[0].length);         }         if (lowerData.length != upperData.length) {             throw new DimensionMismatchException(lowerData.length, upperData.length);         }         if (lowerData.length != lu.getRowDimension()) {             throw new DimensionMismatchException(lowerData.length, lu.getRowDimension());         }          int n = lu.getRowDimension();         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 if (j < i) {                     lowerData[i][j] = lu.getEntry(i, j);                     upperData[i][j] = 0d;                 } else if (i == j) {                     lowerData[i][j] = 1d;                     upperData[i][j] = lu.getEntry(i, j);                 } else {                     lowerData[i][j] = 0d;                     upperData[i][j] = lu.getEntry(i, j);                 }             }         }     }      /** Returns the result of applying the given row permutation to the matrix */     protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {         if (!matrix.isSquare()) {             throw new NonSquareMatrixException(matrix.getRowDimension(),                                                matrix.getColumnDimension());         }         if (matrix.getRowDimension() != permutation.length) {             throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length);         }          int n = matrix.getRowDimension();         int m = matrix.getColumnDimension();         double out[][] = new double[m][n];         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 out[i][j] = matrix.getEntry(permutation[i], j);             }         }         return new Array2DRowRealMatrix(out);     }  //    /** Useful for debugging */ //    private void dumpMatrix(RealMatrix m) { //          for (int i = 0; i < m.getRowDimension(); i++) { //              String os = ""; //              for (int j = 0; j < m.getColumnDimension(); j++) { //                  os += m.getEntry(i, j) + " "; //              } //              System.out.println(os); //          } //    } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.linear;  import java.util.Locale;   public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {      @Override     protected char getDecimalCharacter() {         return ',';     }      @Override     protected Locale getLocale() {         return Locale.FRENCH;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.text.DecimalFormat;  import org.apache.commons.numbers.complex.Complex; import org.apache.commons.numbers.core.Precision; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.math4.complex.ComplexFormat; import org.apache.commons.math4.linear.FieldMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.stat.inference.ChiSquareTest; import org.apache.commons.math4.util.FastMath; import org.junit.Assert;  /**  */ public class TestUtils {     /**      * Collection of static methods used in math unit tests.      */     private TestUtils() {         super();     }      /**      * Verifies that expected and actual are within delta, or are both NaN or      * infinities of the same sign.      */     public static void assertEquals(double expected, double actual, double delta) {         Assert.assertEquals(null, expected, actual, delta);     }      /**      * Verifies that expected and actual are within delta, or are both NaN or      * infinities of the same sign.      */     public static void assertEquals(String msg, double expected, double actual, double delta) {         // check for NaN         if(Double.isNaN(expected)){             Assert.assertTrue("" + actual + " is not NaN.",                 Double.isNaN(actual));         } else {             Assert.assertEquals(msg, expected, actual, delta);         }     }      /**      * Verifies that the two arguments are exactly the same, either      * both NaN or infinities of same sign, or identical floating point values.      */     public static void assertSame(double expected, double actual) {      Assert.assertEquals(expected, actual, 0);     }      /**      * Verifies that real and imaginary parts of the two complex arguments      * are exactly the same.  Also ensures that NaN / infinite components match.      */     public static void assertSame(Complex expected, Complex actual) {         assertSame(expected.getReal(), actual.getReal());         assertSame(expected.getImaginary(), actual.getImaginary());     }      /**      * Verifies that real and imaginary parts of the two complex arguments      * differ by at most delta.  Also ensures that NaN / infinite components match.      */     public static void assertEquals(Complex expected, Complex actual, double delta) {         Assert.assertEquals(expected.getReal(), actual.getReal(), delta);         Assert.assertEquals(expected.getImaginary(), actual.getImaginary(), delta);     }      /**      * Verifies that two double arrays have equal entries, up to tolerance      */     public static void assertEquals(double expected[], double observed[], double tolerance) {         assertEquals("Array comparison failure", expected, observed, tolerance);     }      /**      * Serializes an object to a bytes array and then recovers the object from the bytes array.      * Returns the deserialized object.      *      * @param o  object to serialize and recover      * @return  the recovered, deserialized object      */     public static Object serializeAndRecover(Object o) {         try {             // serialize the Object             ByteArrayOutputStream bos = new ByteArrayOutputStream();             ObjectOutputStream so = new ObjectOutputStream(bos);             so.writeObject(o);              // deserialize the Object             ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());             ObjectInputStream si = new ObjectInputStream(bis);             return si.readObject();         } catch (Exception e) {             throw new RuntimeException(e);         }     }      /**      * Verifies that serialization preserves equals and hashCode.      * Serializes the object, then recovers it and checks equals and hash code.      *      * @param object  the object to serialize and recover      */     public static void checkSerializedEquality(Object object) {         Object object2 = serializeAndRecover(object);         Assert.assertEquals("Equals check", object, object2);         Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());     }      /**      * Verifies that the relative error in actual vs. expected is less than or      * equal to relativeError.  If expected is infinite or NaN, actual must be      * the same (NaN or infinity of the same sign).      *      * @param expected expected value      * @param actual  observed value      * @param relativeError  maximum allowable relative error      */     public static void assertRelativelyEquals(double expected, double actual,             double relativeError) {         assertRelativelyEquals(null, expected, actual, relativeError);     }      /**      * Verifies that the relative error in actual vs. expected is less than or      * equal to relativeError.  If expected is infinite or NaN, actual must be      * the same (NaN or infinity of the same sign).      *      * @param msg  message to return with failure      * @param expected expected value      * @param actual  observed value      * @param relativeError  maximum allowable relative error      */     public static void assertRelativelyEquals(String msg, double expected,             double actual, double relativeError) {         if (Double.isNaN(expected)) {             Assert.assertTrue(msg, Double.isNaN(actual));         } else if (Double.isNaN(actual)) {             Assert.assertTrue(msg, Double.isNaN(expected));         } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {             Assert.assertEquals(expected, actual, relativeError);         } else if (expected == 0.0) {             Assert.assertEquals(msg, actual, expected, relativeError);         } else {             double absError = FastMath.abs(expected) * relativeError;             Assert.assertEquals(msg, expected, actual, absError);         }     }      /**      * Fails iff values does not contain a number within epsilon of z.      *      * @param msg  message to return with failure      * @param values complex array to search      * @param z  value sought      * @param epsilon  tolerance      */     public static void assertContains(String msg, Complex[] values,                                       Complex z, double epsilon) {         for (Complex value : values) {             if (Precision.equals(value.getReal(), z.getReal(), epsilon) &&                 Precision.equals(value.getImaginary(), z.getImaginary(), epsilon)) {                 return;             }         }         Assert.fail(msg + " Unable to find " + (new ComplexFormat()).format(z));     }      /**      * Fails iff values does not contain a number within epsilon of z.      *      * @param values complex array to search      * @param z  value sought      * @param epsilon  tolerance      */     public static void assertContains(Complex[] values,             Complex z, double epsilon) {         assertContains(null, values, z, epsilon);     }      /**      * Fails iff values does not contain a number within epsilon of x.      *      * @param msg  message to return with failure      * @param values double array to search      * @param x value sought      * @param epsilon  tolerance      */     public static void assertContains(String msg, double[] values,             double x, double epsilon) {         for (double value : values) {             if (Precision.equals(value, x, epsilon)) {                 return;             }         }         Assert.fail(msg + " Unable to find " + x);     }      /**      * Fails iff values does not contain a number within epsilon of x.      *      * @param values double array to search      * @param x value sought      * @param epsilon  tolerance      */     public static void assertContains(double[] values, double x,             double epsilon) {        assertContains(null, values, x, epsilon);     }      /**      * Asserts that all entries of the specified vectors are equal to within a      * positive {@code delta}.      *      * @param message the identifying message for the assertion error (can be      * {@code null})      * @param expected expected value      * @param actual actual value      * @param delta the maximum difference between the entries of the expected      * and actual vectors for which both entries are still considered equal      */     public static void assertEquals(final String message,         final double[] expected, final RealVector actual, final double delta) {         final String msgAndSep = message.equals("") ? "" : message + ", ";         Assert.assertEquals(msgAndSep + "dimension", expected.length,             actual.getDimension());         for (int i = 0; i < expected.length; i++) {             Assert.assertEquals(msgAndSep + "entry #" + i, expected[i],                 actual.getEntry(i), delta);         }     }      /**      * Asserts that all entries of the specified vectors are equal to within a      * positive {@code delta}.      *      * @param message the identifying message for the assertion error (can be      * {@code null})      * @param expected expected value      * @param actual actual value      * @param delta the maximum difference between the entries of the expected      * and actual vectors for which both entries are still considered equal      */     public static void assertEquals(final String message,         final RealVector expected, final RealVector actual, final double delta) {         final String msgAndSep = message.equals("") ? "" : message + ", ";         Assert.assertEquals(msgAndSep + "dimension", expected.getDimension(),             actual.getDimension());         final int dim = expected.getDimension();         for (int i = 0; i < dim; i++) {             Assert.assertEquals(msgAndSep + "entry #" + i,                 expected.getEntry(i), actual.getEntry(i), delta);         }     }      /** verifies that two matrices are close (1-norm) */     public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed, double tolerance) {          Assert.assertNotNull(msg + "\nObserved should not be null",observed);          if (expected.getColumnDimension() != observed.getColumnDimension() ||                 expected.getRowDimension() != observed.getRowDimension()) {             StringBuilder messageBuffer = new StringBuilder(msg);             messageBuffer.append("\nObserved has incorrect dimensions.");             messageBuffer.append("\nobserved is " + observed.getRowDimension() +                     " x " + observed.getColumnDimension());             messageBuffer.append("\nexpected " + expected.getRowDimension() +                     " x " + expected.getColumnDimension());             Assert.fail(messageBuffer.toString());         }          RealMatrix delta = expected.subtract(observed);         if (delta.getNorm() >= tolerance) {             StringBuilder messageBuffer = new StringBuilder(msg);             messageBuffer.append("\nExpected: " + expected);             messageBuffer.append("\nObserved: " + observed);             messageBuffer.append("\nexpected - observed: " + delta);             Assert.fail(messageBuffer.toString());         }     }      /** verifies that two matrices are equal */     public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,                                     FieldMatrix<? extends FieldElement<?>> observed) {          Assert.assertNotNull("Observed should not be null",observed);          if (expected.getColumnDimension() != observed.getColumnDimension() ||                 expected.getRowDimension() != observed.getRowDimension()) {             StringBuilder messageBuffer = new StringBuilder();             messageBuffer.append("Observed has incorrect dimensions.");             messageBuffer.append("\nobserved is " + observed.getRowDimension() +                     " x " + observed.getColumnDimension());             messageBuffer.append("\nexpected " + expected.getRowDimension() +                     " x " + expected.getColumnDimension());             Assert.fail(messageBuffer.toString());         }          for (int i = 0; i < expected.getRowDimension(); ++i) {             for (int j = 0; j < expected.getColumnDimension(); ++j) {                 FieldElement<?> eij = expected.getEntry(i, j);                 FieldElement<?> oij = observed.getEntry(i, j);                 Assert.assertEquals(eij, oij);             }         }     }      /** verifies that two arrays are close (sup norm) */     public static void assertEquals(String msg, double[] expected, double[] observed, double tolerance) {         StringBuilder out = new StringBuilder(msg);         if (expected.length != observed.length) {             out.append("\n Arrays not same length. \n");             out.append("expected has length ");             out.append(expected.length);             out.append(" observed length = ");             out.append(observed.length);             Assert.fail(out.toString());         }         boolean failure = false;         for (int i=0; i < expected.length; i++) {             if (!Precision.equalsIncludingNaN(expected[i], observed[i], tolerance)) {                 failure = true;                 out.append("\n Elements at index ");                 out.append(i);                 out.append(" differ. ");                 out.append(" expected = ");                 out.append(expected[i]);                 out.append(" observed = ");                 out.append(observed[i]);             }         }         if (failure) {             Assert.fail(out.toString());         }     }          /** verifies that two arrays are close (sup norm) */     public static void assertEquals(String msg, float[] expected, float[] observed, float tolerance) {         StringBuilder out = new StringBuilder(msg);         if (expected.length != observed.length) {             out.append("\n Arrays not same length. \n");             out.append("expected has length ");             out.append(expected.length);             out.append(" observed length = ");             out.append(observed.length);             Assert.fail(out.toString());         }         boolean failure = false;         for (int i=0; i < expected.length; i++) {             if (!Precision.equalsIncludingNaN(expected[i], observed[i], tolerance)) {                 failure = true;                 out.append("\n Elements at index ");                 out.append(i);                 out.append(" differ. ");                 out.append(" expected = ");                 out.append(expected[i]);                 out.append(" observed = ");                 out.append(observed[i]);             }         }         if (failure) {             Assert.fail(out.toString());         }     }         /** verifies that two arrays are close (sup norm) */     public static void assertEquals(String msg, Complex[] expected, Complex[] observed, double tolerance) {         StringBuilder out = new StringBuilder(msg);         if (expected.length != observed.length) {             out.append("\n Arrays not same length. \n");             out.append("expected has length ");             out.append(expected.length);             out.append(" observed length = ");             out.append(observed.length);             Assert.fail(out.toString());         }         boolean failure = false;         for (int i=0; i < expected.length; i++) {             if (!Precision.equalsIncludingNaN(expected[i].getReal(), observed[i].getReal(), tolerance)) {                 failure = true;                 out.append("\n Real elements at index ");                 out.append(i);                 out.append(" differ. ");                 out.append(" expected = ");                 out.append(expected[i].getReal());                 out.append(" observed = ");                 out.append(observed[i].getReal());             }             if (!Precision.equalsIncludingNaN(expected[i].getImaginary(), observed[i].getImaginary(), tolerance)) {                 failure = true;                 out.append("\n Imaginary elements at index ");                 out.append(i);                 out.append(" differ. ");                 out.append(" expected = ");                 out.append(expected[i].getImaginary());                 out.append(" observed = ");                 out.append(observed[i].getImaginary());             }         }         if (failure) {             Assert.fail(out.toString());         }     }      /** verifies that two arrays are equal */     public static <T extends FieldElement<T>> void assertEquals(T[] m, T[] n) {         if (m.length != n.length) {             Assert.fail("vectors not same length");         }         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(m[i],n[i]);         }     }      /**      * Computes the sum of squared deviations of <values> from <target>      * @param values array of deviates      * @param target value to compute deviations from      *      * @return sum of squared deviations      */     public static double sumSquareDev(double[] values, double target) {         double sumsq = 0d;         for (int i = 0; i < values.length; i++) {             final double dev = values[i] - target;             sumsq += (dev * dev);         }         return sumsq;     }      /**      * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test      * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%      *      * @param valueLabels labels for the values of the discrete distribution under test      * @param expected expected counts      * @param observed observed counts      * @param alpha significance level of the test      */     public static void assertChiSquareAccept(String[] valueLabels, double[] expected, long[] observed, double alpha) {         ChiSquareTest chiSquareTest = new ChiSquareTest();          // Fail if we can reject null hypothesis that distributions are the same         if (chiSquareTest.chiSquareTest(expected, observed, alpha)) {             StringBuilder msgBuffer = new StringBuilder();             DecimalFormat df = new DecimalFormat("#.##");             msgBuffer.append("Chisquare test failed");             msgBuffer.append(" p-value = ");             msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));             msgBuffer.append(" chisquare statistic = ");             msgBuffer.append(chiSquareTest.chiSquare(expected, observed));             msgBuffer.append(". \n");             msgBuffer.append("value\texpected\tobserved\n");             for (int i = 0; i < expected.length; i++) {                 msgBuffer.append(valueLabels[i]);                 msgBuffer.append("\t");                 msgBuffer.append(df.format(expected[i]));                 msgBuffer.append("\t\t");                 msgBuffer.append(observed[i]);                 msgBuffer.append("\n");             }             msgBuffer.append("This test can fail randomly due to sampling error with probability ");             msgBuffer.append(alpha);             msgBuffer.append(".");             Assert.fail(msgBuffer.toString());         }     }      /**      * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test      * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%      *      * @param values integer values whose observed and expected counts are being compared      * @param expected expected counts      * @param observed observed counts      * @param alpha significance level of the test      */     public static void assertChiSquareAccept(int[] values, double[] expected, long[] observed, double alpha) {         String[] labels = new String[values.length];         for (int i = 0; i < values.length; i++) {             labels[i] = Integer.toString(values[i]);         }         assertChiSquareAccept(labels, expected, observed, alpha);     }      /**      * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test      * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%      *      * @param expected expected counts      * @param observed observed counts      * @param alpha significance level of the test      */     public static void assertChiSquareAccept(double[] expected, long[] observed, double alpha) {         String[] labels = new String[expected.length];         for (int i = 0; i < labels.length; i++) {             labels[i] = Integer.toString(i + 1);         }         assertChiSquareAccept(labels, expected, observed, alpha);     }      /**      * Computes the 25th, 50th and 75th percentiles of the given distribution and returns      * these values in an array.      */     public static double[] getDistributionQuartiles(ContinuousDistribution distribution) {         double[] quantiles = new double[3];         quantiles[0] = distribution.inverseCumulativeProbability(0.25d);         quantiles[1] = distribution.inverseCumulativeProbability(0.5d);         quantiles[2] = distribution.inverseCumulativeProbability(0.75d);         return quantiles;     }      /**      * Updates observed counts of values in quartiles.      * counts[0] <-> 1st quartile ... counts[3] <-> top quartile      */     public static void updateCounts(double value, long[] counts, double[] quartiles) {         if (value < quartiles[0]) {             counts[0]++;         } else if (value > quartiles[2]) {             counts[3]++;         } else if (value > quartiles[1]) {             counts[2]++;         } else {             counts[1]++;         }     }      /**      * Eliminates points with zero mass from densityPoints and densityValues parallel      * arrays.  Returns the number of positive mass points and collapses the arrays so      * that the first <returned value> elements of the input arrays represent the positive      * mass points.      */     public static int eliminateZeroMassPoints(int[] densityPoints, double[] densityValues) {         int positiveMassCount = 0;         for (int i = 0; i < densityValues.length; i++) {             if (densityValues[i] > 0) {                 positiveMassCount++;             }         }         if (positiveMassCount < densityValues.length) {             int[] newPoints = new int[positiveMassCount];             double[] newValues = new double[positiveMassCount];             int j = 0;             for (int i = 0; i < densityValues.length; i++) {                 if (densityValues[i] > 0) {                     newPoints[j] = densityPoints[i];                     newValues[j] = densityValues[i];                     j++;                 }             }             System.arraycopy(newPoints,0,densityPoints,0,positiveMassCount);             System.arraycopy(newValues,0,densityValues,0,positiveMassCount);         }         return positiveMassCount;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.transform;  import java.util.Arrays; import java.util.Collection;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.Sinc; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  /**  * Test case for fast cosine transformer.  * <p>  * FCT algorithm is exact, the small tolerance number is used only to account  * for round-off errors.  *  */ @RunWith(value = Parameterized.class) public final class FastCosineTransformerTest     extends RealTransformerAbstractTest {      private final DctNormalization normalization;      private final int[] invalidDataSize;      private final double[] relativeTolerance;      private final int[] validDataSize;      public FastCosineTransformerTest(final DctNormalization normalization) {         this.normalization = normalization;         this.validDataSize = new int[] {             2, 3, 5, 9, 17, 33, 65, 129         };         this.invalidDataSize = new int[] {             128         };         this.relativeTolerance = new double[] {             1E-15, 1E-15, 1E-14, 1E-13, 1E-13, 1E-12, 1E-11, 1E-10         };     }      /**      * Returns an array containing {@code true, false} in order to check both      * standard and orthogonal DCTs.      *      * @return an array of parameters for this parameterized test      */     @Parameters     public static Collection<Object[]> data() {         final DctNormalization[] normalization = DctNormalization.values();         final Object[][] data = new DctNormalization[normalization.length][1];         for (int i = 0; i < normalization.length; i++){             data[i][0] = normalization[i];         }         return Arrays.asList(data);     }      @Override     RealTransformer createRealTransformer() {         return new FastCosineTransformer(normalization);     }      @Override     int getInvalidDataSize(final int i) {         return invalidDataSize[i];     }      @Override     int getNumberOfInvalidDataSizes() {         return invalidDataSize.length;     }      @Override     int getNumberOfValidDataSizes() {         return validDataSize.length;     }      @Override     double getRelativeTolerance(final int i) {         return relativeTolerance[i];     }      @Override     int getValidDataSize(final int i) {         return validDataSize[i];     }      @Override     UnivariateFunction getValidFunction() {         return new Sinc();     }      @Override     double getValidLowerBound() {         return 0.0;     }      @Override     double getValidUpperBound() {         return FastMath.PI;     }      @Override     double[] transform(final double[] x, final TransformType type) {         final int n = x.length;         final double[] y = new double[n];         final double[] cos = new double[2 * (n - 1)];         for (int i = 0; i < cos.length; i++) {             cos[i] = FastMath.cos(FastMath.PI * i / (n - 1.0));         }         int sgn = 1;         for (int j = 0; j < n; j++) {             double yj = 0.5 * (x[0] + sgn * x[n - 1]);             for (int i = 1; i < n - 1; i++) {                 yj += x[i] * cos[(i * j) % cos.length];             }             y[j] = yj;             sgn *= -1;         }         final double s;         if (type == TransformType.FORWARD) {             if (normalization == DctNormalization.STANDARD_DCT_I) {                 s = 1.0;             } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) {                 s = FastMath.sqrt(2.0 / (n - 1.0));             } else {                 throw new MathIllegalStateException();             }         } else if (type == TransformType.INVERSE) {             if (normalization == DctNormalization.STANDARD_DCT_I) {                 s = 2.0 / (n - 1.0);             } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) {                 s = FastMath.sqrt(2.0 / (n - 1.0));             } else {                 throw new MathIllegalStateException();             }         } else {             /*              * Should never occur. This clause is a safeguard in case other              * types are used to TransformType (which should not be done).              */             throw new MathIllegalStateException();         }         TransformUtils.scaleArray(y, s);         return y;     }      /*      * Additional tests.      */      /** Test of transformer for the ad hoc data. */     @Test     public void testAdHocData() {         FastCosineTransformer transformer;         transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I);         double result[], tolerance = 1E-12;          double x[] = {             0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0         };         double y[] =             {                 172.0, -105.096569476353, 27.3137084989848, -12.9593152353742,                 8.0, -5.78585076868676, 4.68629150101524, -4.15826451958632,                 4.0             };          result = transformer.transform(x, TransformType.FORWARD);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(y[i], result[i], tolerance);         }          result = transformer.transform(y, TransformType.INVERSE);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(x[i], result[i], tolerance);         }          TransformUtils.scaleArray(x, FastMath.sqrt(0.5 * (x.length - 1)));          transformer = new FastCosineTransformer(DctNormalization.ORTHOGONAL_DCT_I);         result = transformer.transform(y, TransformType.FORWARD);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(x[i], result[i], tolerance);         }          result = transformer.transform(x, TransformType.INVERSE);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(y[i], result[i], tolerance);         }     }      /** Test of parameters for the transformer. */     @Test     public void testParameters()         throws Exception {         UnivariateFunction f = new Sin();         FastCosineTransformer transformer;         transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I);          try {             // bad interval             transformer.transform(f, 1, -1, 65, TransformType.FORWARD);             Assert.fail("Expecting MathIllegalArgumentException - bad interval");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             // bad samples number             transformer.transform(f, -1, 1, 1, TransformType.FORWARD);             Assert.fail("Expecting MathIllegalArgumentException - bad samples number");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             // bad samples number             transformer.transform(f, -1, 1, 64, TransformType.FORWARD);             Assert.fail("Expecting MathIllegalArgumentException - bad samples number");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      /** Test of transformer for the sine function. */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         FastCosineTransformer transformer;         transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I);         double min, max, result[], tolerance = 1E-12;         int N = 9;          double expected[] =             {                 0.0, 3.26197262739567, 0.0, -2.17958042710327, 0.0,                 -0.648846697642915, 0.0, -0.433545502649478, 0.0             };         min = 0.0;         max = 2.0 * FastMath.PI * N / (N - 1);         result = transformer.transform(f, min, max, N, TransformType.FORWARD);         for (int i = 0; i < N; i++) {             Assert.assertEquals(expected[i], result[i], tolerance);         }          min = -FastMath.PI;         max = FastMath.PI * (N + 1) / (N - 1);         result = transformer.transform(f, min, max, N, TransformType.FORWARD);         for (int i = 0; i < N; i++) {             Assert.assertEquals(-expected[i], result[i], tolerance);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.transform;  import java.util.Arrays; import java.util.Collection;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.Sinc; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  /**  * Test case for fast sine transformer.  * <p>  * FST algorithm is exact, the small tolerance number is used only  * to account for round-off errors.  *  */ @RunWith(value = Parameterized.class) public final class FastSineTransformerTest extends RealTransformerAbstractTest {      private final DstNormalization normalization;      private final int[] invalidDataSize;      private final double[] relativeTolerance;      private final int[] validDataSize;      public FastSineTransformerTest(final DstNormalization normalization) {         this.normalization = normalization;         this.validDataSize = new int[] {             1, 2, 4, 8, 16, 32, 64, 128         };         this.invalidDataSize = new int[] {             129         };         this.relativeTolerance = new double[] {             1E-15, 1E-15, 1E-14, 1E-14, 1E-13, 1E-12, 1E-11, 1E-11         };     }      /**      * Returns an array containing {@code true, false} in order to check both      * standard and orthogonal DSTs.      *      * @return an array of parameters for this parameterized test      */     @Parameters     public static Collection<Object[]> data() {         final DstNormalization[] normalization = DstNormalization.values();         final Object[][] data = new DstNormalization[normalization.length][1];         for (int i = 0; i < normalization.length; i++) {             data[i][0] = normalization[i];         }         return Arrays.asList(data);     }      /**      * {@inheritDoc}      *      * Overriding the default implementation allows to ensure that the first      * element of the data set is zero.      */     @Override     double[] createRealData(final int n) {         final double[] data = super.createRealData(n);         data[0] = 0.0;         return data;     }      @Override     RealTransformer createRealTransformer() {         return new FastSineTransformer(normalization);     }      @Override     int getInvalidDataSize(final int i) {         return invalidDataSize[i];     }      @Override     int getNumberOfInvalidDataSizes() {         return invalidDataSize.length;     }      @Override     int getNumberOfValidDataSizes() {         return validDataSize.length;     }      @Override     double getRelativeTolerance(final int i) {         return relativeTolerance[i];     }      @Override     int getValidDataSize(final int i) {         return validDataSize[i];     }      @Override     UnivariateFunction getValidFunction() {         return new Sinc();     }      @Override     double getValidLowerBound() {         return 0.0;     }      @Override     double getValidUpperBound() {         return FastMath.PI;     }      @Override     double[] transform(final double[] x, final TransformType type) {         final int n = x.length;         final double[] y = new double[n];         final double[] sin = new double[2 * n];         for (int i = 0; i < sin.length; i++) {             sin[i] = FastMath.sin(FastMath.PI * i / n);         }         for (int j = 0; j < n; j++) {             double yj = 0.0;             for (int i = 0; i < n; i++) {                 yj += x[i] * sin[(i * j) % sin.length];             }             y[j] = yj;         }         final double s;         if (type == TransformType.FORWARD) {             if (normalization == DstNormalization.STANDARD_DST_I) {                 s = 1.0;             } else if (normalization == DstNormalization.ORTHOGONAL_DST_I) {                 s = FastMath.sqrt(2.0 / n);             } else {                 throw new MathIllegalStateException();             }         } else if (type == TransformType.INVERSE) {             if (normalization == DstNormalization.STANDARD_DST_I) {                 s = 2.0 / n;             } else if (normalization == DstNormalization.ORTHOGONAL_DST_I) {                 s = FastMath.sqrt(2.0 / n);             } else {                 throw new MathIllegalStateException();             }         } else {             /*              * Should never occur. This clause is a safeguard in case other              * types are used to TransformType (which should not be done).              */             throw new MathIllegalStateException();         }         TransformUtils.scaleArray(y, s);         return y;     }      /*      * Additional tests.      */     @Test     public void testTransformRealFirstElementNotZero() {         final TransformType[] type = TransformType.values();         final double[] data = new double[] {             1.0, 1.0, 1.0, 1.0         };         final RealTransformer transformer = createRealTransformer();         for (int j = 0; j < type.length; j++) {             try {                 transformer.transform(data, type[j]);                 Assert.fail(type[j].toString());             } catch (MathIllegalArgumentException e) {                 // Expected: do nothing             }         }     }      /*      * Additional (legacy) tests.      */      /**      * Test of transformer for the ad hoc data.      */     @Test     public void testAdHocData() {         FastSineTransformer transformer;         transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I);         double result[], tolerance = 1E-12;          double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };         double y[] = { 0.0, 20.1093579685034, -9.65685424949238,                        5.98642305066196, -4.0, 2.67271455167720,                       -1.65685424949238, 0.795649469518633 };          result = transformer.transform(x, TransformType.FORWARD);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(y[i], result[i], tolerance);         }          result = transformer.transform(y, TransformType.INVERSE);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(x[i], result[i], tolerance);         }          TransformUtils.scaleArray(x, FastMath.sqrt(x.length / 2.0));         transformer = new FastSineTransformer(DstNormalization.ORTHOGONAL_DST_I);          result = transformer.transform(y, TransformType.FORWARD);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(x[i], result[i], tolerance);         }          result = transformer.transform(x, TransformType.INVERSE);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(y[i], result[i], tolerance);         }     }      /**      * Test of transformer for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         FastSineTransformer transformer;         transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I);         double min, max, result[], tolerance = 1E-12; int N = 1 << 8;          min = 0.0; max = 2.0 * FastMath.PI;         result = transformer.transform(f, min, max, N, TransformType.FORWARD);         Assert.assertEquals(N >> 1, result[2], tolerance);         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {             Assert.assertEquals(0.0, result[i], tolerance);         }          min = -FastMath.PI; max = FastMath.PI;         result = transformer.transform(f, min, max, N, TransformType.FORWARD);         Assert.assertEquals(-(N >> 1), result[2], tolerance);         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {             Assert.assertEquals(0.0, result[i], tolerance);         }     }      /**      * Test of parameters for the transformer.      */     @Test     public void testParameters() throws Exception {         UnivariateFunction f = new Sin();         FastSineTransformer transformer;         transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I);          try {             // bad interval             transformer.transform(f, 1, -1, 64, TransformType.FORWARD);             Assert.fail("Expecting MathIllegalArgumentException - bad interval");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             // bad samples number             transformer.transform(f, -1, 1, 0, TransformType.FORWARD);             Assert.fail("Expecting MathIllegalArgumentException - bad samples number");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             // bad samples number             transformer.transform(f, -1, 1, 100, TransformType.FORWARD);             Assert.fail("Expecting MathIllegalArgumentException - bad samples number");         } catch (MathIllegalArgumentException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.transform;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;   /**  * JUnit Test for HadamardTransformerTest  * @see org.apache.commons.math4.transform.FastHadamardTransformer  */ public final class FastHadamardTransformerTest {      /**      * Test of transformer for the a 8-point FHT (means n=8)      */     @Test     public void test8Points() {         checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 },                        new int[] { 10, -4, 2, -4, 2, -12, 6, 8 });     }      /**      * Test of transformer for the a 4-points FHT (means n=4)      */     @Test     public void test4Points() {         checkAllTransforms(new int[] { 1, 2, 3, 4 },                            new int[] { 10, -2, -4, 0 });     }      /**      * Test the inverse transform of an integer vector is not always an integer vector      */     @Test     public void testNoIntInverse() {         FastHadamardTransformer transformer = new FastHadamardTransformer();         double[] x = transformer.transform(new double[] { 0, 1, 0, 1}, TransformType.INVERSE);         Assert.assertEquals( 0.5, x[0], 0);         Assert.assertEquals(-0.5, x[1], 0);         Assert.assertEquals( 0.0, x[2], 0);         Assert.assertEquals( 0.0, x[3], 0);     }      /**      * Test of transformer for wrong number of points      */     @Test     public void test3Points() {         try {             new FastHadamardTransformer().transform(new double[3], TransformType.FORWARD);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected         }     }      private void checkAllTransforms(int[]x, int[] y) {         checkDoubleTransform(x, y);         checkInverseDoubleTransform(x, y);         checkIntTransform(x, y);     }      private void checkDoubleTransform(int[]x, int[] y) {         // Initiate the transformer         FastHadamardTransformer transformer = new FastHadamardTransformer();          // check double transform         double[] dX = new double[x.length];         for (int i = 0; i < dX.length; ++i) {             dX[i] = x[i];         }         double dResult[] = transformer.transform(dX, TransformType.FORWARD);         for (int i = 0; i < dResult.length; i++) {             // compare computed results to precomputed results             Assert.assertTrue(Precision.equals(y[i], dResult[i], 1));         }     }      private void checkIntTransform(int[]x, int[] y) {         // Initiate the transformer         FastHadamardTransformer transformer = new FastHadamardTransformer();          // check integer transform         int iResult[] = transformer.transform(x);         for (int i = 0; i < iResult.length; i++) {             // compare computed results to precomputed results             Assert.assertEquals(y[i], iResult[i]);         }      }      private void checkInverseDoubleTransform(int[]x, int[] y) {         // Initiate the transformer         FastHadamardTransformer transformer = new FastHadamardTransformer();          // check double transform         double[] dY = new double[y.length];         for (int i = 0; i < dY.length; ++i) {             dY[i] = y[i];         }         double dResult[] = transformer.transform(dY, TransformType.INVERSE);         for (int i = 0; i < dResult.length; i++) {             // compare computed results to precomputed results             Assert.assertTrue(Precision.equals(x[i], dResult[i], 1));         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.transform;  import java.util.Random;  import org.apache.commons.numbers.complex.Complex; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.Sinc; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for fast Fourier transformer.  * <p>  * FFT algorithm is exact, the small tolerance number is used only  * to account for round-off errors.  *  */ public final class FastFourierTransformerTest {     /** The common seed of all random number generators used in this test. */     private final static long SEED = 20110111L;      /*      * Precondition checks.      */      @Test     public void testTransformComplexSizeNotAPowerOfTwo() {         final int n = 127;         final Complex[] x = createComplexData(n);         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 final FastFourierTransformer fft;                 fft = new FastFourierTransformer(norm[i]);                 try {                     fft.transform(x, type[j]);                     Assert.fail(norm[i] + ", " + type[j] +                         ": MathIllegalArgumentException was expected");                 } catch (MathIllegalArgumentException e) {                     // Expected behaviour                 }             }         }     }      @Test     public void testTransformRealSizeNotAPowerOfTwo() {         final int n = 127;         final double[] x = createRealData(n);         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 final FastFourierTransformer fft;                 fft = new FastFourierTransformer(norm[i]);                 try {                     fft.transform(x, type[j]);                     Assert.fail(norm[i] + ", " + type[j] +                         ": MathIllegalArgumentException was expected");                 } catch (MathIllegalArgumentException e) {                     // Expected behaviour                 }             }         }     }      @Test     public void testTransformFunctionSizeNotAPowerOfTwo() {         final int n = 127;         final UnivariateFunction f = new Sin();         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 final FastFourierTransformer fft;                 fft = new FastFourierTransformer(norm[i]);                 try {                     fft.transform(f, 0.0, Math.PI, n, type[j]);                     Assert.fail(norm[i] + ", " + type[j] +                         ": MathIllegalArgumentException was expected");                 } catch (MathIllegalArgumentException e) {                     // Expected behaviour                 }             }         }     }      @Test     public void testTransformFunctionNotStrictlyPositiveNumberOfSamples() {         final int n = -128;         final UnivariateFunction f = new Sin();         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 final FastFourierTransformer fft;                 fft = new FastFourierTransformer(norm[i]);                 try {                     fft.transform(f, 0.0, Math.PI, n, type[j]);                     fft.transform(f, 0.0, Math.PI, n, type[j]);                     Assert.fail(norm[i] + ", " + type[j] +                         ": NotStrictlyPositiveException was expected");                 } catch (NotStrictlyPositiveException e) {                     // Expected behaviour                 }             }         }     }      @Test     public void testTransformFunctionInvalidBounds() {         final int n = 128;         final UnivariateFunction f = new Sin();         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 final FastFourierTransformer fft;                 fft = new FastFourierTransformer(norm[i]);                 try {                     fft.transform(f, Math.PI, 0.0, n, type[j]);                     Assert.fail(norm[i] + ", " + type[j] +                         ": NumberIsTooLargeException was expected");                 } catch (NumberIsTooLargeException e) {                     // Expected behaviour                 }             }         }     }      /*      * Utility methods for checking (successful) transforms.      */      private static Complex[] createComplexData(final int n) {         final Random random = new Random(SEED);         final Complex[] data = new Complex[n];         for (int i = 0; i < n; i++) {             final double re = 2.0 * random.nextDouble() - 1.0;             final double im = 2.0 * random.nextDouble() - 1.0;             data[i] = Complex.ofCartesian(re, im);         }         return data;     }      private static double[] createRealData(final int n) {         final Random random = new Random(SEED);         final double[] data = new double[n];         for (int i = 0; i < n; i++) {             data[i] = 2.0 * random.nextDouble() - 1.0;         }         return data;     }      /** Naive implementation of DFT, for reference. */     private static Complex[] dft(final Complex[] x, final int sgn) {         final int n = x.length;         final double[] cos = new double[n];         final double[] sin = new double[n];         final Complex[] y = new Complex[n];         for (int i = 0; i < n; i++) {             final double arg = 2.0 * FastMath.PI * i / n;             cos[i] = FastMath.cos(arg);             sin[i] = FastMath.sin(arg);         }         for (int i = 0; i < n; i++) {             double yr = 0.0;             double yi = 0.0;             for (int j = 0; j < n; j++) {                 final int index = (i * j) % n;                 final double c = cos[index];                 final double s = sin[index];                 final double xr = x[j].getReal();                 final double xi = x[j].getImaginary();                 yr += c * xr - sgn * s * xi;                 yi += sgn * s * xr + c * xi;             }             y[i] = Complex.ofCartesian(yr, yi);         }         return y;     }      private static void doTestTransformComplex(final int n, final double tol,         final DftNormalization normalization,         final TransformType type) {         final FastFourierTransformer fft;         fft = new FastFourierTransformer(normalization);         final Complex[] x = createComplexData(n);         final Complex[] expected;         final double s;         if (type==TransformType.FORWARD) {             expected = dft(x, -1);             if (normalization == DftNormalization.STANDARD){                 s = 1.0;             } else {                 s = 1.0 / FastMath.sqrt(n);             }         } else {             expected = dft(x, 1);             if (normalization == DftNormalization.STANDARD) {                 s = 1.0 / n;             } else {                 s = 1.0 / FastMath.sqrt(n);             }         }         final Complex[] actual = fft.transform(x, type);         for (int i = 0; i < n; i++) {             final String msg;             msg = String.format("%s, %s, %d, %d", normalization, type, n, i);             final double re = s * expected[i].getReal();             Assert.assertEquals(msg, re, actual[i].getReal(),                 tol * FastMath.abs(re));             final double im = s * expected[i].getImaginary();             Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *                 FastMath.abs(re));         }     }      private static void doTestTransformReal(final int n, final double tol,         final DftNormalization normalization,         final TransformType type) {         final FastFourierTransformer fft;         fft = new FastFourierTransformer(normalization);         final double[] x = createRealData(n);         final Complex[] xc = new Complex[n];         for (int i = 0; i < n; i++) {             xc[i] = Complex.ofCartesian(x[i], 0.0);         }         final Complex[] expected;         final double s;         if (type == TransformType.FORWARD) {             expected = dft(xc, -1);             if (normalization == DftNormalization.STANDARD) {                 s = 1.0;             } else {                 s = 1.0 / FastMath.sqrt(n);             }         } else {             expected = dft(xc, 1);             if (normalization == DftNormalization.STANDARD) {                 s = 1.0 / n;             } else {                 s = 1.0 / FastMath.sqrt(n);             }         }         final Complex[] actual = fft.transform(x, type);         for (int i = 0; i < n; i++) {             final String msg;             msg = String.format("%s, %s, %d, %d", normalization, type, n, i);             final double re = s * expected[i].getReal();             Assert.assertEquals(msg, re, actual[i].getReal(),                 tol * FastMath.abs(re));             final double im = s * expected[i].getImaginary();             Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *                 FastMath.abs(re));         }     }      private static void doTestTransformFunction(final UnivariateFunction f,         final double min, final double max, int n, final double tol,         final DftNormalization normalization,         final TransformType type) {         final FastFourierTransformer fft;         fft = new FastFourierTransformer(normalization);         final Complex[] x = new Complex[n];         for (int i = 0; i < n; i++) {             final double t = min + i * (max - min) / n;             x[i] = Complex.ofCartesian(f.value(t), 0);         }         final Complex[] expected;         final double s;         if (type == TransformType.FORWARD) {             expected = dft(x, -1);             if (normalization == DftNormalization.STANDARD) {                 s = 1.0;             } else {                 s = 1.0 / FastMath.sqrt(n);             }         } else {             expected = dft(x, 1);             if (normalization == DftNormalization.STANDARD) {                 s = 1.0 / n;             } else {                 s = 1.0 / FastMath.sqrt(n);             }         }         final Complex[] actual = fft.transform(f, min, max, n, type);         for (int i = 0; i < n; i++) {             final String msg = String.format("%d, %d", n, i);             final double re = s * expected[i].getReal();             Assert.assertEquals(msg, re, actual[i].getReal(),                 tol * FastMath.abs(re));             final double im = s * expected[i].getImaginary();             Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *                 FastMath.abs(re));         }     }      /*      * Tests of standard transform (when data is valid).      */      @Test     public void testTransformComplex() {         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 doTestTransformComplex(2, 1.0E-15, norm[i], type[j]);                 doTestTransformComplex(4, 1.0E-14, norm[i], type[j]);                 doTestTransformComplex(8, 1.0E-14, norm[i], type[j]);                 doTestTransformComplex(16, 1.0E-13, norm[i], type[j]);                 doTestTransformComplex(32, 1.0E-13, norm[i], type[j]);                 doTestTransformComplex(64, 1.0E-12, norm[i], type[j]);                 doTestTransformComplex(128, 1.0E-12, norm[i], type[j]);             }         }     }      @Test     public void testStandardTransformReal() {         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 doTestTransformReal(2, 1.0E-15, norm[i], type[j]);                 doTestTransformReal(4, 1.0E-14, norm[i], type[j]);                 doTestTransformReal(8, 1.0E-14, norm[i], type[j]);                 doTestTransformReal(16, 1.0E-13, norm[i], type[j]);                 doTestTransformReal(32, 1.0E-13, norm[i], type[j]);                 doTestTransformReal(64, 1.0E-13, norm[i], type[j]);                 doTestTransformReal(128, 1.0E-11, norm[i], type[j]);             }         }     }      @Test     public void testStandardTransformFunction() {         final UnivariateFunction f = new Sinc();         final double min = -FastMath.PI;         final double max = FastMath.PI;         final DftNormalization[] norm;         norm = DftNormalization.values();         final TransformType[] type;         type = TransformType.values();         for (int i = 0; i < norm.length; i++) {             for (int j = 0; j < type.length; j++) {                 doTestTransformFunction(f, min, max, 2, 1.0E-15, norm[i], type[j]);                 doTestTransformFunction(f, min, max, 4, 1.0E-14, norm[i], type[j]);                 doTestTransformFunction(f, min, max, 8, 1.0E-14, norm[i], type[j]);                 doTestTransformFunction(f, min, max, 16, 1.0E-13, norm[i], type[j]);                 doTestTransformFunction(f, min, max, 32, 1.0E-13, norm[i], type[j]);                 doTestTransformFunction(f, min, max, 64, 1.0E-12, norm[i], type[j]);                 doTestTransformFunction(f, min, max, 128, 1.0E-11, norm[i], type[j]);             }         }     }      /*      * Additional tests for 1D data.      */      /**      * Test of transformer for the ad hoc data taken from Mathematica.      */     @Test     public void testAdHocData() {         FastFourierTransformer transformer;         transformer = new FastFourierTransformer(DftNormalization.STANDARD);         Complex result[]; double tolerance = 1E-12;          double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};         Complex y[] = {             Complex.ofCartesian(21.9, 0.0),             Complex.ofCartesian(-2.09497474683058, 1.91507575950825),             Complex.ofCartesian(-2.6, 2.7),             Complex.ofCartesian(-1.10502525316942, -4.88492424049175),             Complex.ofCartesian(0.1, 0.0),             Complex.ofCartesian(-1.10502525316942, 4.88492424049175),             Complex.ofCartesian(-2.6, -2.7),             Complex.ofCartesian(-2.09497474683058, -1.91507575950825)};          result = transformer.transform(x, TransformType.FORWARD);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(y[i].getReal(), result[i].getReal(), tolerance);             Assert.assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);         }          result = transformer.transform(y, TransformType.INVERSE);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(x[i], result[i].getReal(), tolerance);             Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);         }          double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};         TransformUtils.scaleArray(x2, 1.0 / FastMath.sqrt(x2.length));         Complex y2[] = y;          transformer = new FastFourierTransformer(DftNormalization.UNITARY);         result = transformer.transform(y2, TransformType.FORWARD);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(x2[i], result[i].getReal(), tolerance);             Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);         }          result = transformer.transform(x2, TransformType.INVERSE);         for (int i = 0; i < result.length; i++) {             Assert.assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);             Assert.assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);         }     }      /**      * Test of transformer for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         FastFourierTransformer transformer;         transformer = new FastFourierTransformer(DftNormalization.STANDARD);         Complex result[]; int N = 1 << 8;         double min, max, tolerance = 1E-12;          min = 0.0; max = 2.0 * FastMath.PI;         result = transformer.transform(f, min, max, N, TransformType.FORWARD);         Assert.assertEquals(0.0, result[1].getReal(), tolerance);         Assert.assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);         Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);         Assert.assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);         for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {             Assert.assertEquals(0.0, result[i].getReal(), tolerance);             Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);         }          min = -FastMath.PI; max = FastMath.PI;         result = transformer.transform(f, min, max, N, TransformType.INVERSE);         Assert.assertEquals(0.0, result[1].getReal(), tolerance);         Assert.assertEquals(-0.5, result[1].getImaginary(), tolerance);         Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);         Assert.assertEquals(0.5, result[N-1].getImaginary(), tolerance);         for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {             Assert.assertEquals(0.0, result[i].getReal(), tolerance);             Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.transform;  import java.util.Random;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Abstract test for classes implementing the {@link RealTransformer} interface.  * This abstract test handles the automatic generation of random data of various  * sizes. For each generated data array, actual values (returned by the  * transformer to be tested) are compared to expected values, returned by the  * {@link #transform(double[], TransformType)} (to be implemented by the user:  * a naive method may be used). Methods are also provided to test that invalid  * parameters throw the expected exceptions.  *  * @since 3.0  */ public abstract class RealTransformerAbstractTest {      /** The common seed of all random number generators used in this test. */     private final static long SEED = 20110119L;      /**      * Returns a new instance of the {@link RealTransformer} to be tested.      *      * @return a the transformer to be tested      */     abstract RealTransformer createRealTransformer();      /**      * Returns an invalid data size. Transforms with this data size should      * trigger a {@link MathIllegalArgumentException}.      *      * @param i the index of the invalid data size ({@code 0 <= i <}      * {@link #getNumberOfInvalidDataSizes()}      * @return an invalid data size      */     abstract int getInvalidDataSize(int i);      /**      * Returns the total number of invalid data sizes to be tested. If data      * array of any      * size can be handled by the {@link RealTransformer} to be tested, this      * method should return {@code 0}.      *      * @return the total number of invalid data sizes      */     abstract int getNumberOfInvalidDataSizes();      /**      * Returns the total number of valid data sizes to be tested.      *      * @return the total number of valid data sizes      */     abstract int getNumberOfValidDataSizes();      /**      * Returns the expected relative accuracy for data arrays of size      * {@code getValidDataSize(i)}.      *      * @param i the index of the valid data size      * @return the expected relative accuracy      */     abstract double getRelativeTolerance(int i);      /**      * Returns a valid data size. This method allows for data arrays of various      * sizes to be automatically tested (by allowing multiple values of the      * specified index).      *      * @param i the index of the valid data size ({@code 0 <= i <}      * {@link #getNumberOfValidDataSizes()}      * @return a valid data size      */     abstract int getValidDataSize(int i);      /**      * Returns a function for the accuracy check of      * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}.      * This function should be valid. In other words, none of the above methods      * should throw an exception when passed this function.      *      * @return a valid function      */     abstract UnivariateFunction getValidFunction();      /**      * Returns a sampling lower bound for the accuracy check of      * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}.      * This lower bound should be valid. In other words, none of the above      * methods should throw an exception when passed this bound.      *      * @return a valid lower bound      */     abstract double getValidLowerBound();      /**      * Returns a sampling upper bound for the accuracy check of      * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}.      * This upper bound should be valid. In other words, none of the above      * methods should throw an exception when passed this bound.      *      * @return a valid bound      */     abstract double getValidUpperBound();      /**      * Returns the expected transform of the specified real data array.      *      * @param x the real data array to be transformed      * @param type the type of transform (forward, inverse) to be performed      * @return the expected transform      */     abstract double[] transform(double[] x, TransformType type);      /*      * Check of preconditions.      */      /**      * {@link RealTransformer#transform(double[], TransformType)} should throw a      * {@link MathIllegalArgumentException} if data size is invalid.      */     @Test     public void testTransformRealInvalidDataSize() {         final TransformType[] type = TransformType.values();         final RealTransformer transformer = createRealTransformer();         for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {             final int n = getInvalidDataSize(i);             for (int j = 0; j < type.length; j++) {                 try {                     transformer.transform(createRealData(n), type[j]);                     Assert.fail(type[j] + ", " + n);                 } catch (MathIllegalArgumentException e) {                     // Expected: do nothing                 }             }         }     }      /**      * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}      * should throw a {@link MathIllegalArgumentException} if number of samples      * is invalid.      */     @Test     public void testTransformFunctionInvalidDataSize() {         final TransformType[] type = TransformType.values();         final RealTransformer transformer = createRealTransformer();         final UnivariateFunction f = getValidFunction();         final double a = getValidLowerBound();         final double b = getValidUpperBound();         for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {             final int n = getInvalidDataSize(i);             for (int j = 0; j < type.length; j++) {                 try {                     transformer.transform(f, a, b, n, type[j]);                     Assert.fail(type[j] + ", " + n);                 } catch (MathIllegalArgumentException e) {                     // Expected: do nothing                 }             }         }     }      /**      * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}      * should throw a {@link NotStrictlyPositiveException} if number of samples      * is not strictly positive.      */     @Test     public void testTransformFunctionNotStrictlyPositiveNumberOfSamples() {         final TransformType[] type = TransformType.values();         final RealTransformer transformer = createRealTransformer();         final UnivariateFunction f = getValidFunction();         final double a = getValidLowerBound();         final double b = getValidUpperBound();         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {             final int n = getValidDataSize(i);             for (int j = 0; j < type.length; j++) {                 try {                     transformer.transform(f, a, b, -n, type[j]);                     Assert.fail(type[j] + ", " + (-n));                 } catch (NotStrictlyPositiveException e) {                     // Expected: do nothing                 }             }         }     }      /**      * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}      * should throw a {@link NumberIsTooLargeException} if sampling bounds are      * not correctly ordered.      */     @Test     public void testTransformFunctionInvalidBounds() {         final TransformType[] type = TransformType.values();         final RealTransformer transformer = createRealTransformer();         final UnivariateFunction f = getValidFunction();         final double a = getValidLowerBound();         final double b = getValidUpperBound();         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {             final int n = getValidDataSize(i);             for (int j = 0; j < type.length; j++) {                 try {                     transformer.transform(f, b, a, n, type[j]);                     Assert.fail(type[j] + ", " + b + ", " + a);                 } catch (NumberIsTooLargeException e) {                     // Expected: do nothing                 }             }         }     }      /*      * Accuracy tests of transform of valid data.      */      /**      * Accuracy check of {@link RealTransformer#transform(double[], TransformType)}.      * For each valid data size returned by      * {@link #getValidDataSize(int) getValidDataSize(i)},      * a random data array is generated with      * {@link #createRealData(int) createRealData(i)}. The actual      * transform is computed and compared to the expected transform, return by      * {@link #transform(double[], TransformType)}. Actual and expected values      * should be equal to within the relative error returned by      * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.      */     @Test     public void testTransformReal() {         final TransformType[] type = TransformType.values();         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {             final int n = getValidDataSize(i);             final double tol = getRelativeTolerance(i);             for (int j = 0; j < type.length; j++) {                 doTestTransformReal(n, tol, type[j]);             }         }     }      /**      * Accuracy check of      * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}.      * For each valid data size returned by      * {@link #getValidDataSize(int) getValidDataSize(i)},      * the {@link UnivariateFunction} returned by {@link #getValidFunction()} is      * sampled. The actual transform is computed and compared to the expected      * transform, return by {@link #transform(double[], TransformType)}. Actual      * and expected values should be equal to within the relative error returned      * by {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.      */     @Test     public void testTransformFunction() {         final TransformType[] type = TransformType.values();         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {             final int n = getValidDataSize(i);             final double tol = getRelativeTolerance(i);             for (int j = 0; j < type.length; j++) {                 doTestTransformFunction(n, tol, type[j]);             }         }     }      /*      * Utility methods.      */      /**      * Returns a random array of doubles. Random generator always uses the same      * seed.      *      * @param n the size of the array to be returned      * @return a random array of specified size      */     double[] createRealData(final int n) {         final Random random = new Random(SEED);         final double[] data = new double[n];         for (int i = 0; i < n; i++) {             data[i] = 2.0 * random.nextDouble() - 1.0;         }         return data;     }      /*      * The tests per se.      */      private void doTestTransformReal(final int n, final double tol,         final TransformType type) {         final RealTransformer transformer = createRealTransformer();         final double[] x = createRealData(n);         final double[] expected = transform(x, type);         final double[] actual = transformer.transform(x, type);         for (int i = 0; i < n; i++) {             final String msg = String.format("%d, %d", n, i);             final double delta = tol * FastMath.abs(expected[i]);             Assert.assertEquals(msg, expected[i], actual[i], delta);         }     }      private void doTestTransformFunction(final int n, final double tol,         final TransformType type) {         final RealTransformer transformer = createRealTransformer();         final UnivariateFunction f = getValidFunction();         final double a = getValidLowerBound();         final double b = getValidUpperBound();         final double[] x = createRealData(n);         for (int i = 0; i < n; i++) {             final double t = a + i * (b - a) / n;             x[i] = f.value(t);         }         final double[] expected = transform(x, type);         final double[] actual = transformer.transform(f, a, b, n, type);         for (int i = 0; i < n; i++) {             final String msg = String.format("%d, %d", n, i);             final double delta = tol * FastMath.abs(expected[i]);             Assert.assertEquals(msg, expected[i], actual[i], delta);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4;  import java.util.Random;  import org.apache.commons.math4.exception.MathIllegalStateException; import org.junit.Test; import org.junit.runner.RunWith;  /**  * Test for the "Retry" functionality (retrying Junit test methods).  */ @RunWith(RetryRunner.class) public class RetryRunnerTest {     final Random rng = new Random();      /**      * Shows that an always failing test will fail even if it is retried.      */     @Test(expected=MathIllegalStateException.class)     @Retry     public void testRetryFailAlways() {         throw new MathIllegalStateException();     }      /**      * Shows that a test that sometimes fail might succeed if it is retried.      * In this case the high number of retries makes it quite unlikely that      * the exception will be thrown by all of the calls.      */     @Test     @Retry(100)     public void testRetryFailSometimes() {         if (rng.nextBoolean()) {             throw new MathIllegalStateException();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import java.text.MessageFormat;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link TooManyEvaluationsException}.  *  */ public class TooManyEvaluationsExceptionTest {     @Test     public void testMessage() {         final int max = 12345;         final TooManyEvaluationsException e = new TooManyEvaluationsException(max);         final String msg = e.getLocalizedMessage();         Assert.assertTrue(msg,                           msg.matches(".*?" +                                       MessageFormat.format("{0}", max) +                                       ".*"));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link NotStrictlyPositiveException}.  *  */ public class NotStrictlyPositiveExceptionTest {     @Test     public void testAccessors() {         final NotStrictlyPositiveException e = new NotStrictlyPositiveException(0);         Assert.assertEquals(0, e.getArgument());         Assert.assertEquals(0, e.getMin());         Assert.assertFalse(e.getBoundIsAllowed());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link NumberIsTooLargeException}.  *  */ public class NumberIsTooLargeExceptionTest {     @Test     public void testAccessors() {         final NumberIsTooLargeException e = new NumberIsTooLargeException(1, 0, true);         Assert.assertEquals(1, e.getArgument());         Assert.assertEquals(0, e.getMax());         Assert.assertTrue(e.getBoundIsAllowed());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link OutOfRangeException}.  *  */ public class OutOfRangeExceptionTest {     @Test     public void testAccessors() {         final OutOfRangeException e = new OutOfRangeException(-1, 0, 2);         Assert.assertEquals(-1, e.getArgument());         Assert.assertEquals(0, e.getLo());         Assert.assertEquals(2, e.getHi());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception.util;  import java.util.Locale; import java.util.Arrays; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link ExceptionContext}.  *  */ public class ExceptionContextTest {     @Test     public void testMessageChain() {         final ExceptionContext c = new ExceptionContext(new Exception("oops"));         final String sep = " | "; // Non-default separator.         final String m1 = "column index (0)";         c.addMessage(LocalizedFormats.COLUMN_INDEX, 0);         final String m2 = "got 1x2 but expected 3x4";         c.addMessage(LocalizedFormats.DIMENSIONS_MISMATCH_2x2, 1, 2, 3, 4);         final String m3 = "It didn't work out";         c.addMessage(LocalizedFormats.SIMPLE_MESSAGE, m3);          Assert.assertEquals(c.getMessage(Locale.US, sep),                             m1 + sep + m2 + sep + m3);     }      @Test     public void testNoArgAddMessage() {         final ExceptionContext c = new ExceptionContext(new Exception("hello"));         c.addMessage(LocalizedFormats.SIMPLE_MESSAGE);         Assert.assertEquals(c.getMessage(), "{0}");     }      @Test     public void testContext() {         final ExceptionContext c = new ExceptionContext(new Exception("bye"));          final String[] keys = {"Key 1", "Key 2"};         final Object[] values = {"Value 1", Integer.valueOf(2)};          for (int i = 0; i < keys.length; i++) {             c.setValue(keys[i], values[i]);         }          // Check that all keys are present.         Assert.assertTrue(c.getKeys().containsAll(Arrays.asList(keys)));          // Check that all values are correctly stored.         for (int i = 0; i < keys.length; i++) {             Assert.assertEquals(values[i], c.getValue(keys[i]));         }          // Check behaviour on missing key.         Assert.assertNull(c.getValue("xyz"));     }      @Test     public void testSerialize()         throws IOException,                ClassNotFoundException {         final ExceptionContext cOut = new ExceptionContext(new Exception("Apache"));         cOut.addMessage(LocalizedFormats.COLUMN_INDEX, 0);         cOut.setValue("Key 1", Integer.valueOf(0));          ByteArrayOutputStream bos = new ByteArrayOutputStream();         ObjectOutputStream oos = new ObjectOutputStream(bos);         oos.writeObject(cOut);          ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());         ObjectInputStream ois = new ObjectInputStream(bis);         ExceptionContext cIn = (ExceptionContext) ois.readObject();          Assert.assertTrue(cOut.getMessage().equals(cIn.getMessage()));         for (String key : cIn.getKeys()) {             Assert.assertTrue(cOut.getValue(key).equals(cIn.getValue(key)));         }     }      @Test     public void testSerializeUnserializable() throws Exception {         final ExceptionContext cOut = new ExceptionContext(new Exception("Apache Commons Math"));         cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, "OK");         cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, new Unserializable());         String key = "Key 1";         cOut.setValue(key, new Unserializable());          {             ByteArrayOutputStream bos = new ByteArrayOutputStream();             ObjectOutputStream oos = new ObjectOutputStream(bos);             oos.writeObject(cOut);              ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());             ObjectInputStream ois = new ObjectInputStream(bis);             ExceptionContext cIn = (ExceptionContext) ois.readObject();              String nsObjStr = (String) cIn.getValue(key);             Assert.assertTrue(nsObjStr.matches(".*could not be serialized.*"));         }     }      /**      * Class used by {@link #testSerializeUnserializable()}.      */     private static class Unserializable {         Unserializable() {}     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception.util;  import java.util.List; import java.util.ArrayList;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link ArgUtils}.  *  */ public class ArgUtilsTest {     @Test     public void testFlatten() {         final List<Object> orig = new ArrayList<>();          final Object[] struct = new Object[] {             new Object[] {                 new Object[] {                     create(orig),                     create(orig),                 },                 create(orig),                 new Object[] {                     create(orig),                 }             },             create(orig),             new Object[] {                 create(orig),                 new Object[] {                     create(orig),                     create(orig),                 }             },             create(orig),         };          Object[] flat = ArgUtils.flatten(struct);         Assert.assertEquals(flat.length, orig.size());          for (int i = 0, max = orig.size(); i < max; i++) {             Assert.assertEquals(orig.get(i), flat[i]);         }     }      /**      * Create and store an {@code Object}.      *      * @param list List to store to.      * @return the stored object.      */     private Object create(List<Object> list) {         final Object o = new Object();         list.add(o);         return o;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception.util;   import java.text.MessageFormat; import java.util.Enumeration; import java.util.Locale; import java.util.ResourceBundle;  import org.junit.Assert; import org.junit.Test;  public class LocalizedFormatsTest {      @Test     public void testMessageNumber() {         Assert.assertEquals(328, LocalizedFormats.values().length);     }      @Test     public void testAllKeysPresentInPropertiesFiles() {         final String path = LocalizedFormats.class.getName().replaceAll("\\.", "/");         for (final String language : new String[] { "fr" } ) {             ResourceBundle bundle =                 ResourceBundle.getBundle("assets/" + path, new Locale(language));             for (LocalizedFormats message : LocalizedFormats.values()) {                 final String messageKey = message.toString();                 boolean keyPresent = false;                 for (final Enumeration<String> keys = bundle.getKeys(); keys.hasMoreElements();) {                     keyPresent |= messageKey.equals(keys.nextElement());                 }                 Assert.assertTrue("missing key \"" + message.name() + "\" for language " + language,                                   keyPresent);             }             Assert.assertEquals(language, bundle.getLocale().getLanguage());         }      }      @Test     public void testAllPropertiesCorrespondToKeys() {         final String path = LocalizedFormats.class.getName().replaceAll("\\.", "/");         for (final String language : new String[] { "fr" } ) {             ResourceBundle bundle =                 ResourceBundle.getBundle("assets/" + path, new Locale(language));             for (final Enumeration<String> keys = bundle.getKeys(); keys.hasMoreElements();) {                 final String propertyKey = keys.nextElement();                 try {                     Assert.assertNotNull(LocalizedFormats.valueOf(propertyKey));                 } catch (IllegalArgumentException iae) {                     Assert.fail("unknown key \"" + propertyKey + "\" in language " + language);                 }             }             Assert.assertEquals(language, bundle.getLocale().getLanguage());         }      }      @Test     public void testNoMissingFrenchTranslation() {         for (LocalizedFormats message : LocalizedFormats.values()) {             String translated = message.getLocalizedString(Locale.FRENCH);             Assert.assertFalse(message.name(), translated.toLowerCase().contains("missing translation"));         }     }      @Test     public void testNoOpEnglishTranslation() {         for (LocalizedFormats message : LocalizedFormats.values()) {             String translated = message.getLocalizedString(Locale.ENGLISH);             Assert.assertEquals(message.getSourceString(), translated);         }     }      @Test     public void testVariablePartsConsistency() {         for (final String language : new String[] { "fr" } ) {             Locale locale = new Locale(language);             for (LocalizedFormats message : LocalizedFormats.values()) {                 MessageFormat source     = new MessageFormat(message.getSourceString());                 MessageFormat translated = new MessageFormat(message.getLocalizedString(locale));                 Assert.assertEquals(message.name() + " (" + language + ")",                                     source.getFormatsByArgumentIndex().length,                                     translated.getFormatsByArgumentIndex().length);             }         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link NotPositiveException}.  *  */ public class NotPositiveExceptionTest {     @Test     public void testAccessors() {         final NotPositiveException e = new NotPositiveException(-1);         Assert.assertEquals(-1, e.getArgument());         Assert.assertEquals(0, e.getMin());         Assert.assertTrue(e.getBoundIsAllowed());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link DimensionMismatchException}.  *  */ public class DimensionMismatchExceptionTest {     @Test     public void testAccessors() {         final DimensionMismatchException e = new DimensionMismatchException(1, 2);         Assert.assertEquals(1, e.getArgument());         Assert.assertEquals(2, e.getDimension());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link NonMonotonicSequenceException}.  *  */ public class NonMonotonicSequenceExceptionTest {     @Test     public void testAccessors() {         NonMonotonicSequenceException e             = new NonMonotonicSequenceException(0, -1, 1, MathArrays.OrderDirection.DECREASING, false);         Assert.assertEquals(0, e.getArgument());         Assert.assertEquals(-1, e.getPrevious());         Assert.assertEquals(1, e.getIndex());         Assert.assertTrue(e.getDirection() == MathArrays.OrderDirection.DECREASING);         Assert.assertFalse(e.getStrict());          e = new NonMonotonicSequenceException(-1, 0, 1);         Assert.assertEquals(-1, e.getArgument());         Assert.assertEquals(0, e.getPrevious());         Assert.assertEquals(1, e.getIndex());         Assert.assertTrue(e.getDirection() == MathArrays.OrderDirection.INCREASING);         Assert.assertTrue(e.getStrict());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link NumberIsTooSmallException}.  *  */ public class NumberIsTooSmallExceptionTest {     @Test     public void testAccessors() {         final NumberIsTooSmallException e = new NumberIsTooSmallException(0, 0, false);         Assert.assertEquals(0, e.getArgument());         Assert.assertEquals(0, e.getMin());         Assert.assertFalse(e.getBoundIsAllowed());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.exception;  import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link MaxCountExceededException}.  *  */ public class MaxCountExceededExceptionTest {     @Test     public void testAccessors() {         final MaxCountExceededException e = new MaxCountExceededException(10);         Assert.assertEquals(10, e.getMax());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4;  import org.apache.commons.numbers.arrays.LinearCombination; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  public abstract class ExtendedFieldElementAbstractTest<T extends RealFieldElement<T>> {      protected abstract T build(double x);      @Test     public void testAddField() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(x + y, build(x).add(build(y)));             }         }     }      @Test     public void testAddDouble() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(x + y, build(x).add(y));             }         }     }      @Test     public void testSubtractField() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(x - y, build(x).subtract(build(y)));             }         }     }      @Test     public void testSubtractDouble() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(x - y, build(x).subtract(y));             }         }     }      @Test     public void testMultiplyField() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(x * y, build(x).multiply(build(y)));             }         }     }      @Test     public void testMultiplyDouble() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(x * y, build(x).multiply(y));             }         }     }      @Test     public void testMultiplyInt() {         for (double x = -3; x < 3; x += 0.2) {             for (int y = -10; y < 10; y += 1) {                 checkRelative(x * y, build(x).multiply(y));             }         }     }      @Test     public void testDivideField() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(x / y, build(x).divide(build(y)));             }         }     }      @Test     public void testDivideDouble() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                     checkRelative(x / y, build(x).divide(y));             }         }     }      @Test     public void testRemainderField() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(FastMath.IEEEremainder(x, y), build(x).remainder(build(y)));             }         }     }      @Test     public void testRemainderDouble() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3.2; y < 3.2; y += 0.25) {                 checkRelative(FastMath.IEEEremainder(x, y), build(x).remainder(y));             }         }     }      @Test     public void testCos() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.cos(x), build(x).cos());         }     }      @Test     public void testAcos() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.acos(x), build(x).acos());         }     }      @Test     public void testSin() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.sin(x), build(x).sin());         }     }      @Test     public void testAsin() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.asin(x), build(x).asin());         }     }      @Test     public void testTan() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.tan(x), build(x).tan());         }     }      @Test     public void testAtan() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.atan(x), build(x).atan());         }     }      @Test     public void testAtan2() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(FastMath.atan2(x, y), build(x).atan2(build(y)));             }         }     }      @Test     public void testCosh() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.cosh(x), build(x).cosh());         }     }      @Test     public void testAcosh() {         for (double x = 1.1; x < 5.0; x += 0.05) {             checkRelative(FastMath.acosh(x), build(x).acosh());         }     }      @Test     public void testSinh() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.sinh(x), build(x).sinh());         }     }      @Test     public void testAsinh() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.asinh(x), build(x).asinh());         }     }      @Test     public void testTanh() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.tanh(x), build(x).tanh());         }     }      @Test     public void testAtanh() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.atanh(x), build(x).atanh());         }     }      @Test     public void testSqrt() {         for (double x = 0.01; x < 0.9; x += 0.05) {             checkRelative(FastMath.sqrt(x), build(x).sqrt());         }     }      @Test     public void testCbrt() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.cbrt(x), build(x).cbrt());         }     }      @Test     public void testHypot() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(FastMath.hypot(x, y), build(x).hypot(build(y)));             }         }     }      @Test     public void testRootN() {         for (double x = -0.9; x < 0.9; x += 0.05) {             for (int n = 1; n < 5; ++n) {                 if (x < 0) {                     if (n % 2 == 1) {                         checkRelative(-FastMath.pow(-x, 1.0 / n), build(x).rootN(n));                     }                 } else {                     checkRelative(FastMath.pow(x, 1.0 / n), build(x).rootN(n));                 }             }         }     }      @Test     public void testPowField() {         for (double x = -0.9; x < 0.9; x += 0.05) {             for (double y = 0.1; y < 4; y += 0.2) {                 checkRelative(FastMath.pow(x, y), build(x).pow(build(y)));             }         }     }      @Test     public void testPowDouble() {         for (double x = -0.9; x < 0.9; x += 0.05) {             for (double y = 0.1; y < 4; y += 0.2) {                 checkRelative(FastMath.pow(x, y), build(x).pow(y));             }         }     }      @Test     public void testPowInt() {         for (double x = -0.9; x < 0.9; x += 0.05) {             for (int n = 0; n < 5; ++n) {                 checkRelative(FastMath.pow(x, n), build(x).pow(n));             }         }     }      @Test     public void testExp() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.exp(x), build(x).exp());         }     }      @Test     public void testExpm1() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.expm1(x), build(x).expm1());         }     }      @Test     public void testLog() {         for (double x = 0.01; x < 0.9; x += 0.05) {             checkRelative(FastMath.log(x), build(x).log());         }     }      @Test     public void testLog1p() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.log1p(x), build(x).log1p());         }     }  //  TODO: add this test in 4.0, as it is not possible to do it in 3.2 //  due to incompatibility of the return type in the Dfp class //    @Test //    public void testLog10() { //        for (double x = -0.9; x < 0.9; x += 0.05) { //            checkRelative(FastMath.log10(x), build(x).log10()); //        } //    }      @Test     public void testAbs() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.abs(x), build(x).abs());         }     }      @Test     public void testCeil() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.ceil(x), build(x).ceil());         }     }      @Test     public void testFloor() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.floor(x), build(x).floor());         }     }      @Test     public void testRint() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.rint(x), build(x).rint());         }     }      @Test     public void testRound() {         for (double x = -0.9; x < 0.9; x += 0.05) {             Assert.assertEquals(FastMath.round(x), build(x).round());         }     }      @Test     public void testSignum() {         for (double x = -0.9; x < 0.9; x += 0.05) {             checkRelative(FastMath.signum(x), build(x).signum());         }     }      @Test     public void testCopySignField() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(FastMath.copySign(x, y), build(x).copySign(build(y)));             }         }     }      @Test     public void testCopySignDouble() {         for (double x = -3; x < 3; x += 0.2) {             for (double y = -3; y < 3; y += 0.2) {                 checkRelative(FastMath.copySign(x, y), build(x).copySign(y));             }         }     }      @Test     public void testScalb() {         for (double x = -0.9; x < 0.9; x += 0.05) {             for (int n = -100; n < 100; ++n) {                 checkRelative(FastMath.scalb(x, n), build(x).scalb(n));             }         }     }      @Test     public void testLinearCombinationFaFa() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xfafal);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 10);             double[] bD = generateDouble(r, 10);             T[] aF      = toFieldArray(aD);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD, bD),                           aF[0].linearCombination(aF, bF));         }     }      @Test     public void testLinearCombinationDaFa() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xdafal);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 10);             double[] bD = generateDouble(r, 10);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD, bD),                           bF[0].linearCombination(aD, bF));         }     }      @Test     public void testLinearCombinationFF2() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xff2l);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 2);             double[] bD = generateDouble(r, 2);             T[] aF      = toFieldArray(aD);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD[0], bD[0], aD[1], bD[1]),                           aF[0].linearCombination(aF[0], bF[0], aF[1], bF[1]));         }     }      @Test     public void testLinearCombinationDF2() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xdf2l);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 2);             double[] bD = generateDouble(r, 2);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD[0], bD[0], aD[1], bD[1]),                           bF[0].linearCombination(aD[0], bF[0], aD[1], bF[1]));         }     }      @Test     public void testLinearCombinationFF3() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xff3l);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 3);             double[] bD = generateDouble(r, 3);             T[] aF      = toFieldArray(aD);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2]),                           aF[0].linearCombination(aF[0], bF[0], aF[1], bF[1], aF[2], bF[2]));         }     }      @Test     public void testLinearCombinationDF3() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xdf3l);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 3);             double[] bD = generateDouble(r, 3);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2]),                           bF[0].linearCombination(aD[0], bF[0], aD[1], bF[1], aD[2], bF[2]));         }     }      @Test     public void testLinearCombinationFF4() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xff4l);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 4);             double[] bD = generateDouble(r, 4);             T[] aF      = toFieldArray(aD);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2], aD[3], bD[3]),                           aF[0].linearCombination(aF[0], bF[0], aF[1], bF[1], aF[2], bF[2], aF[3], bF[3]));         }     }      @Test     public void testLinearCombinationDF4() {         UniformRandomProvider r = RandomSource.create(RandomSource.WELL_1024_A, 0xdf4l);         for (int i = 0; i < 50; ++i) {             double[] aD = generateDouble(r, 4);             double[] bD = generateDouble(r, 4);             T[] bF      = toFieldArray(bD);             checkRelative(LinearCombination.value(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2], aD[3], bD[3]),                           bF[0].linearCombination(aD[0], bF[0], aD[1], bF[1], aD[2], bF[2], aD[3], bF[3]));         }     }      @Test     public void testGetField() {         checkRelative(1.0, build(-10).getField().getOne());         checkRelative(0.0, build(-10).getField().getZero());     }      private void checkRelative(double expected, T obtained) {         Assert.assertEquals(expected, obtained.getReal(), 1.0e-15 * (1 + FastMath.abs(expected)));     }      @Test     public void testEquals() {         T t1a = build(1.0);         T t1b = build(1.0);         T t2  = build(2.0);         Assert.assertTrue(t1a.equals(t1a));         Assert.assertTrue(t1a.equals(t1b));         Assert.assertFalse(t1a.equals(t2));         Assert.assertFalse(t1a.equals(new Object()));     }      @Test     public void testHash() {         T t1a = build(1.0);         T t1b = build(1.0);         T t2  = build(2.0);         Assert.assertEquals(t1a.hashCode(), t1b.hashCode());         Assert.assertTrue(t1a.hashCode() != t2.hashCode());     }      private double[] generateDouble (final UniformRandomProvider r, int n) {         double[] a = new double[n];         for (int i = 0; i < n; ++i) {             a[i] = r.nextDouble();         }         return a;     }      private T[] toFieldArray (double[] a) {         T[] f = MathArrays.buildArray(build(0).getField(), a.length);         for (int i = 0; i < a.length; ++i) {             f[i] = build(a[i]);         }         return f;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import java.util.Arrays;  import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum; import org.apache.commons.math4.linear.DiagonalMatrix; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * <p>Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a  * href="http://www.netlib.org/minpack/disclaimer">here</a>, for  * convenience, it is reproduced below.</p>   * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0">  * <tr><td>  *    Minpack Copyright Notice (1999) University of Chicago.  *    All rights reserved  * </td></tr>  * <tr><td>  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * <ol>  *  <li>Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.</li>  * <li>Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.</li>  * <li>The end-user documentation included with the redistribution, if any,  *     must include the following acknowledgment:  *     <code>This product includes software developed by the University of  *           Chicago, as Operator of Argonne National Laboratory.</code>  *     Alternately, this acknowledgment may appear in the software itself,  *     if and wherever such third-party acknowledgments normally appear.</li>  * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"  *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE  *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND  *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR  *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES  *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE  *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY  *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR  *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF  *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)  *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION  *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL  *     BE CORRECTED.</strong></li>  * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT  *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF  *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,  *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF  *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF  *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER  *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT  *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,  *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE  *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>  * <ol></td></tr>  * </table>   * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)  * @author Burton S. Garbow (original fortran minpack tests)  * @author Kenneth E. Hillstrom (original fortran minpack tests)  * @author Jorge J. More (original fortran minpack tests)  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)  */ public class MinpackTest {      @Test     public void testMinpackLinearFullRank() {         minpackTest(new LinearFullRankFunction(10, 5, 1.0,                                                5.0, 2.23606797749979), false);         minpackTest(new LinearFullRankFunction(50, 5, 1.0,                                                8.06225774829855, 6.70820393249937), false);     }      @Test     public void testMinpackLinearRank1() {         minpackTest(new LinearRank1Function(10, 5, 1.0,                                             291.521868819476, 1.4638501094228), false);         minpackTest(new LinearRank1Function(50, 5, 1.0,                                             3101.60039334535, 3.48263016573496), false);     }      @Test     public void testMinpackLinearRank1ZeroColsAndRows() {         minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);         minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);     }      @Test     public void testMinpackRosenbrok() {         minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },                                            FastMath.sqrt(24.2)), false);         minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },                                            FastMath.sqrt(1795769.0)), false);         minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },                                            11.0 * FastMath.sqrt(169000121.0)), false);     }      @Test     public void testMinpackHelicalValley() {         minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },                                               50.0), false);         minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },                                               102.95630140987), false);         minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},                                               991.261822123701), false);     }      @Test     public void testMinpackPowellSingular() {         minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },                                                14.6628782986152), false);         minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },                                                1270.9838708654), false);         minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },                                                126887.903284750), false);     }      @Test     public void testMinpackFreudensteinRoth() {         minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },                                                  20.0124960961895, 6.99887517584575,                                                  new double[] {                                                      11.4124844654993,                                                      -0.896827913731509                                                  }), false);         minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                                  12432.833948863, 6.9988751744895,                                                  new double[] {                                                      11.41300466147456,                                                      -0.896796038685959                                                  }), false);         minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },                                                  11426454.595762, 6.99887517242903,                                                  new double[] {                                                      11.412781785788564,                                                      -0.8968051074920405                                                  }), false);     }      @Test     public void testMinpackBard() {         minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,                                      new double[] {                                          0.0824105765758334,                                          1.1330366534715,                                          2.34369463894115                                      }), false);         minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,                                      new double[] {                                          0.840666673818329,                                          -158848033.259565,                                          -164378671.653535                                      }), false);         minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,                                      new double[] {                                          0.840666673867645,                                          -158946167.205518,                                          -164464906.857771                                      }), false);     }      @Test     public void testMinpackKowalikOsborne() {         minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },                                                0.0728915102882945,                                                0.017535837721129,                                                new double[] {                                                    0.192807810476249,                                                    0.191262653354071,                                                    0.123052801046931,                                                    0.136053221150517                                                }), false);         minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },                                                2.97937007555202,                                                0.032052192917937,                                                new double[] {                                                    728675.473768287,                                                    -14.0758803129393,                                                    -32977797.7841797,                                                    -20571594.1977912                                                }), false);         minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },                                                29.9590617016037,                                                0.0175364017658228,                                                new double[] {                                                    0.192948328597594,                                                    0.188053165007911,                                                    0.122430604321144,                                                    0.134575665392506                                                }), false);     }      @Test     public void testMinpackMeyer() {         minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },                                       41153.4665543031, 9.37794514651874,                                       new double[] {                                           0.00560963647102661,                                           6181.34634628659,                                           345.223634624144                                       }), false);         minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },                                       4168216.89130846, 792.917871779501,                                       new double[] {                                           1.42367074157994e-11,                                           33695.7133432541,                                           901.268527953801                                       }), true);     }      @Test     public void testMinpackWatson() {         minpackTest(new WatsonFunction(6, 0.0,                                        5.47722557505166, 0.0478295939097601,                                        new double[] {                                            -0.0157249615083782, 1.01243488232965,                                            -0.232991722387673,  1.26043101102818,                                            -1.51373031394421,   0.99299727291842                                        }), false);         minpackTest(new WatsonFunction(6, 10.0,                                        6433.12578950026, 0.0478295939096951,                                        new double[] {                                            -0.0157251901386677, 1.01243485860105,                                            -0.232991545843829,  1.26042932089163,                                            -1.51372776706575,   0.99299573426328                                        }), false);         minpackTest(new WatsonFunction(6, 100.0,                                        674256.040605213, 0.047829593911544,                                        new double[] {                                            -0.0157247019712586, 1.01243490925658,                                            -0.232991922761641,  1.26043292929555,                                            -1.51373320452707,   0.99299901922322                                        }), false);         minpackTest(new WatsonFunction(9, 0.0,                                        5.47722557505166, 0.00118311459212420,                                        new double[] {                                            -0.153070644166722e-4, 0.999789703934597,                                            0.0147639634910978,   0.146342330145992,                                            1.00082109454817,    -2.61773112070507,                                            4.10440313943354,    -3.14361226236241,                                            1.05262640378759                                        }), false);         minpackTest(new WatsonFunction(9, 10.0,                                        12088.127069307, 0.00118311459212513,                                        new double[] {                                            -0.153071334849279e-4, 0.999789703941234,                                            0.0147639629786217,   0.146342334818836,                                            1.00082107321386,    -2.61773107084722,                                            4.10440307655564,    -3.14361222178686,                                            1.05262639322589                                        }), false);         minpackTest(new WatsonFunction(9, 100.0,                                        1269109.29043834, 0.00118311459212384,                                        new double[] {                                            -0.153069523352176e-4, 0.999789703958371,                                            0.0147639625185392,   0.146342341096326,                                            1.00082104729164,    -2.61773101573645,                                            4.10440301427286,    -3.14361218602503,                                            1.05262638516774                                        }), false);         minpackTest(new WatsonFunction(12, 0.0,                                        5.47722557505166, 0.217310402535861e-4,                                        new double[] {                                            -0.660266001396382e-8, 1.00000164411833,                                            -0.000563932146980154, 0.347820540050756,                                            -0.156731500244233,    1.05281515825593,                                            -3.24727109519451,     7.2884347837505,                                            -10.271848098614,       9.07411353715783,                                            -4.54137541918194,     1.01201187975044                                        }), false);         minpackTest(new WatsonFunction(12, 10.0,                                        19220.7589790951, 0.217310402518509e-4,                                        new double[] {                                            -0.663710223017410e-8, 1.00000164411787,                                            -0.000563932208347327, 0.347820540486998,                                            -0.156731503955652,    1.05281517654573,                                            -3.2472711515214,      7.28843489430665,                                            -10.2718482369638,      9.07411364383733,                                            -4.54137546533666,     1.01201188830857                                        }), false);         minpackTest(new WatsonFunction(12, 100.0,                                        2018918.04462367, 0.217310402539845e-4,                                        new double[] {                                            -0.663806046485249e-8, 1.00000164411786,                                            -0.000563932210324959, 0.347820540503588,                                            -0.156731504091375,    1.05281517718031,                                            -3.24727115337025,     7.28843489775302,                                            -10.2718482410813,      9.07411364688464,                                            -4.54137546660822,     1.0120118885369                                        }), false);     }      @Test     public void testMinpackBox3Dimensional() {         minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },                                                 32.1115837449572), false);     }      @Test     public void testMinpackJennrichSampson() {         minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                                 64.5856498144943, 11.1517793413499,                                                 new double[] { //                                                     0.2578330049, 0.257829976764542                                                     0.2578199266368004, 0.25782997676455244                                                 }), false);     }      @Test     public void testMinpackBrownDennis() {         minpackTest(new BrownDennisFunction(20,                                             new double[] { 25.0, 5.0, -5.0, -1.0 },                                             2815.43839161816, 292.954288244866,                                             new double[] {                                                 -11.59125141003, 13.2024883984741,                                                 -0.403574643314272, 0.236736269844604                                             }), false);         minpackTest(new BrownDennisFunction(20,                                             new double[] { 250.0, 50.0, -50.0, -10.0 },                                             555073.354173069, 292.954270581415,                                             new double[] {                                                 -11.5959274272203, 13.2041866926242,                                                 -0.403417362841545, 0.236771143410386                                             }), false);         minpackTest(new BrownDennisFunction(20,                                             new double[] { 2500.0, 500.0, -500.0, -100.0 },                                             61211252.2338581, 292.954306151134,                                             new double[] {                                                 -11.5902596937374, 13.2020628854665,                                                 -0.403688070279258, 0.236665033746463                                             }), false);     }      @Test     public void testMinpackChebyquad() {         minpackTest(new ChebyquadFunction(1, 8, 1.0,                                           1.88623796907732, 1.88623796907732,                                           new double[] { 0.5 }), false);         minpackTest(new ChebyquadFunction(1, 8, 10.0,                                           5383344372.34005, 1.88424820499951,                                           new double[] { 0.9817314924684 }), false);         minpackTest(new ChebyquadFunction(1, 8, 100.0,                                           0.118088726698392e19, 1.88424820499347,                                           new double[] { 0.9817314852934 }), false);         minpackTest(new ChebyquadFunction(8, 8, 1.0,                                           0.196513862833975, 0.0593032355046727,                                           new double[] {                                               0.0431536648587336, 0.193091637843267,                                               0.266328593812698,  0.499999334628884,                                               0.500000665371116,  0.733671406187302,                                               0.806908362156733,  0.956846335141266                                           }), false);         minpackTest(new ChebyquadFunction(9, 9, 1.0,                                           0.16994993465202, 0.0,                                           new double[] {                                               0.0442053461357828, 0.199490672309881,                                               0.23561910847106,   0.416046907892598,                                               0.5,                0.583953092107402,                                               0.764380891528940,  0.800509327690119,                                               0.955794653864217                                           }), false);         minpackTest(new ChebyquadFunction(10, 10, 1.0,                                           0.183747831178711, 0.0806471004038253,                                           new double[] {                                               0.0596202671753563, 0.166708783805937,                                               0.239171018813509,  0.398885290346268,                                               0.398883667870681,  0.601116332129320,                                               0.60111470965373,   0.760828981186491,                                               0.833291216194063,  0.940379732824644                                           }), false);     }      @Test     public void testMinpackBrownAlmostLinear() {         minpackTest(new BrownAlmostLinearFunction(10, 0.5,                                                   16.5302162063499, 0.0,                                                   new double[] {                                                       0.979430303349862, 0.979430303349862,                                                       0.979430303349862, 0.979430303349862,                                                       0.979430303349862, 0.979430303349862,                                                       0.979430303349862, 0.979430303349862,                                                       0.979430303349862, 1.20569696650138                                                   }), false);         minpackTest(new BrownAlmostLinearFunction(10, 5.0,                                                   9765624.00089211, 0.0,                                                   new double[] {                                                       0.979430303349865, 0.979430303349865,                                                       0.979430303349865, 0.979430303349865,                                                       0.979430303349865, 0.979430303349865,                                                       0.979430303349865, 0.979430303349865,                                                       0.979430303349865, 1.20569696650135                                                   }), false);         minpackTest(new BrownAlmostLinearFunction(10, 50.0,                                                   0.9765625e17, 0.0,                                                   new double[] {                                                       1.0, 1.0, 1.0, 1.0, 1.0,                                                       1.0, 1.0, 1.0, 1.0, 1.0                                                   }), false);         minpackTest(new BrownAlmostLinearFunction(30, 0.5,                                                   83.476044467848, 0.0,                                                   new double[] {                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 0.997754216442807,                                                       0.997754216442807, 1.06737350671578                                                   }), false);         minpackTest(new BrownAlmostLinearFunction(40, 0.5,                                                   128.026364472323, 0.0,                                                   new double[] {                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       1.00000000000002, 1.00000000000002,                                                       0.999999999999121                                                   }), false);     }      @Test     public void testMinpackOsborne1() {         minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },                                          0.937564021037838, 0.00739249260904843,                                          new double[] {                                              0.375410049244025, 1.93584654543108,                                              -1.46468676748716, 0.0128675339110439,                                              0.0221227011813076                                          }), false);     }      @Test     public void testMinpackOsborne2() {         minpackTest(new Osborne2Function(new double[] {                     1.3, 0.65, 0.65, 0.7, 0.6,                     3.0, 5.0, 7.0, 2.0, 4.5, 5.5                 },                 1.44686540984712, 0.20034404483314,                 new double[] {                     1.30997663810096,  0.43155248076,                     0.633661261602859, 0.599428560991695,                     0.754179768272449, 0.904300082378518,                     1.36579949521007, 4.82373199748107,                     2.39868475104871, 4.56887554791452,                     5.67534206273052                 }), false);     }      private void minpackTest(MinpackFunction function, boolean exceptionExpected) {         final double tol = 2.22044604926e-16;         final double sqrtTol = FastMath.sqrt(tol);          LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer()             .withCostRelativeTolerance(sqrtTol)             .withParameterRelativeTolerance(sqrtTol)             .withOrthoTolerance(tol);          LeastSquaresProblem problem = new LeastSquaresBuilder()                 .maxEvaluations(400 * (function.getN() + 1))                 .maxIterations(2000)                 .model(function.getModelFunction(), function.getModelFunctionJacobian())                 .target(function.getTarget())                 .weight(new DiagonalMatrix(function.getWeight()))                 .start(function.getStartPoint())                 .build();          try {             final Optimum optimum = optimizer.optimize(problem);             Assert.assertFalse(exceptionExpected);             function.checkTheoreticalMinCost(optimum.getRMS());             function.checkTheoreticalMinParams(optimum.getPoint().toArray());         } catch (TooManyEvaluationsException e) {             Assert.assertTrue(exceptionExpected);         }     }      private static abstract class MinpackFunction {         protected int      n;         protected int      m;         protected double[] startParams;         protected double   theoreticalMinCost;         protected double[] theoreticalMinParams;         protected double   costAccuracy;         protected double   paramsAccuracy;          protected MinpackFunction(int m, double[] startParams,                                   double theoreticalMinCost,                                   double[] theoreticalMinParams) {             this.m = m;             this.n = startParams.length;             this.startParams          = startParams.clone();             this.theoreticalMinCost   = theoreticalMinCost;             this.theoreticalMinParams = theoreticalMinParams;             this.costAccuracy         = 1.0e-8;             this.paramsAccuracy       = 1.0e-5;         }          protected static double[] buildArray(int n, double x) {             double[] array = new double[n];             Arrays.fill(array, x);             return array;         }          public double[] getTarget() {             return buildArray(m, 0.0);         }          public double[] getWeight() {             return buildArray(m, 1.0);         }          public double[] getStartPoint() {             return startParams.clone();         }          protected void setCostAccuracy(double costAccuracy) {             this.costAccuracy = costAccuracy;         }          protected void setParamsAccuracy(double paramsAccuracy) {             this.paramsAccuracy = paramsAccuracy;         }          public int getN() {             return startParams.length;         }          public void checkTheoreticalMinCost(double rms) {             double threshold = costAccuracy * (1.0 + theoreticalMinCost);             Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);         }          public void checkTheoreticalMinParams(double[] params) {             if (theoreticalMinParams != null) {                 for (int i = 0; i < theoreticalMinParams.length; ++i) {                     double mi = theoreticalMinParams[i];                     double vi = params[i];                     Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi)));                 }             }         }          public MultivariateVectorFunction getModelFunction() {             return new MultivariateVectorFunction() {                 @Override                 public double[] value(double[] point) {                     return computeValue(point);                 }             };         }          public MultivariateMatrixFunction getModelFunctionJacobian() {             return new MultivariateMatrixFunction() {                 @Override                 public double[][] value(double[] point) {                     return computeJacobian(point);                 }             };         }          public abstract double[][] computeJacobian(double[] variables);         public abstract double[] computeValue(double[] variables);     }      private static class LinearFullRankFunction extends MinpackFunction {          public LinearFullRankFunction(int m, int n, double x0,                                       double theoreticalStartCost,                                       double theoreticalMinCost) {             super(m, buildArray(n, x0), theoreticalMinCost,                   buildArray(n, -1.0));         }          @Override         public double[][] computeJacobian(double[] variables) {             double t = 2.0 / m;             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 jacobian[i] = new double[n];                 for (int j = 0; j < n; ++j) {                     jacobian[i][j] = (i == j) ? (1 - t) : -t;                 }             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double sum = 0;             for (int i = 0; i < n; ++i) {                 sum += variables[i];             }             double t  = 1 + 2 * sum / m;             double[] f = new double[m];             for (int i = 0; i < n; ++i) {                 f[i] = variables[i] - t;             }             Arrays.fill(f, n, m, -t);             return f;         }     }      private static class LinearRank1Function extends MinpackFunction {          public LinearRank1Function(int m, int n, double x0,                                    double theoreticalStartCost,                                    double theoreticalMinCost) {             super(m, buildArray(n, x0), theoreticalMinCost, null);         }          @Override         public double[][] computeJacobian(double[] variables) {             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 jacobian[i] = new double[n];                 for (int j = 0; j < n; ++j) {                     jacobian[i][j] = (i + 1) * (j + 1);                 }             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double[] f = new double[m];             double sum = 0;             for (int i = 0; i < n; ++i) {                 sum += (i + 1) * variables[i];             }             for (int i = 0; i < m; ++i) {                 f[i] = (i + 1) * sum - 1;             }             return f;         }     }      private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {          public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {             super(m, buildArray(n, x0),                   FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),                   null);         }          @Override         public double[][] computeJacobian(double[] variables) {             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 jacobian[i] = new double[n];                 jacobian[i][0] = 0;                 for (int j = 1; j < (n - 1); ++j) {                     if (i == 0) {                         jacobian[i][j] = 0;                     } else if (i != (m - 1)) {                         jacobian[i][j] = i * (j + 1);                     } else {                         jacobian[i][j] = 0;                     }                 }                 jacobian[i][n - 1] = 0;             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double[] f = new double[m];             double sum = 0;             for (int i = 1; i < (n - 1); ++i) {                 sum += (i + 1) * variables[i];             }             for (int i = 0; i < (m - 1); ++i) {                 f[i] = i * sum - 1;             }             f[m - 1] = -1;             return f;         }     }      private static class RosenbrockFunction extends MinpackFunction {         public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {             super(2, startParams, 0.0, buildArray(2, 1.0));         }          @Override         public double[][] computeJacobian(double[] variables) {             double x1 = variables[0];             return new double[][] { { -20 * x1, 10 }, { -1, 0 } };         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };         }     }      private static class HelicalValleyFunction extends MinpackFunction {         public HelicalValleyFunction(double[] startParams,                                      double theoreticalStartCost) {             super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });         }          @Override         public double[][] computeJacobian(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double tmpSquare = x1 * x1 + x2 * x2;             double tmp1 = twoPi * tmpSquare;             double tmp2 = FastMath.sqrt(tmpSquare);             return new double[][] {                 {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },                 { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },                 { 0, 0, 1 }             };         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double tmp1;             if (x1 == 0) {                 tmp1 = (x2 >= 0) ? 0.25 : -0.25;             } else {                 tmp1 = FastMath.atan(x2 / x1) / twoPi;                 if (x1 < 0) {                     tmp1 += 0.5;                 }             }             double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2);             return new double[] {                 10.0 * (x3 - 10 * tmp1),                 10.0 * (tmp2 - 1),                 x3             };         }          private static final double twoPi = 2.0 * FastMath.PI;     }      private static class PowellSingularFunction extends MinpackFunction {          public PowellSingularFunction(double[] startParams,                                       double theoreticalStartCost) {             super(4, startParams, 0.0, buildArray(4, 0.0));         }          @Override         public double[][] computeJacobian(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double x4 = variables[3];             return new double[][] {                 { 1, 10, 0, 0 },                 { 0, 0, sqrt5, -sqrt5 },                 { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },                 { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }             };         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double x4 = variables[3];             return new double[] {                 x1 + 10 * x2,                 sqrt5 * (x3 - x4),                 (x2 - 2 * x3) * (x2 - 2 * x3),                 sqrt10 * (x1 - x4) * (x1 - x4)             };         }          private static final double sqrt5  = FastMath.sqrt( 5.0);         private static final double sqrt10 = FastMath.sqrt(10.0);   }      private static class FreudensteinRothFunction extends MinpackFunction {          public FreudensteinRothFunction(double[] startParams,                                         double theoreticalStartCost,                                         double theoreticalMinCost,                                         double[] theoreticalMinParams) {             super(2, startParams, theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double x2 = variables[1];             return new double[][] {                 { 1, x2 * (10 - 3 * x2) -  2 },                 { 1, x2 * ( 2 + 3 * x2) - 14, }             };         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             return new double[] {                 -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,                 -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2             };         }     }      private static class BardFunction extends MinpackFunction {          public BardFunction(double x0,                             double theoreticalStartCost,                             double theoreticalMinCost,                             double[] theoreticalMinParams) {             super(15, buildArray(3, x0), theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x2 = variables[1];             double   x3 = variables[2];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double tmp1 = i  + 1;                 double tmp2 = 15 - i;                 double tmp3 = (i <= 7) ? tmp1 : tmp2;                 double tmp4 = x2 * tmp2 + x3 * tmp3;                 tmp4 *= tmp4;                 jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double   x1 = variables[0];             double   x2 = variables[1];             double   x3 = variables[2];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 double tmp1 = i + 1;                 double tmp2 = 15 - i;                 double tmp3 = (i <= 7) ? tmp1 : tmp2;                 f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));             }             return f;         }          private static final double[] y = {             0.14, 0.18, 0.22, 0.25, 0.29,             0.32, 0.35, 0.39, 0.37, 0.58,             0.73, 0.96, 1.34, 2.10, 4.39         };     }      private static class KowalikOsborneFunction extends MinpackFunction {          public KowalikOsborneFunction(double[] startParams,                                       double theoreticalStartCost,                                       double theoreticalMinCost,                                       double[] theoreticalMinParams) {             super(11, startParams, theoreticalMinCost,                   theoreticalMinParams);             if (theoreticalStartCost > 20.0) {                 setCostAccuracy(2.0e-4);                 setParamsAccuracy(5.0e-3);             }         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x1 = variables[0];             double   x2 = variables[1];             double   x3 = variables[2];             double   x4 = variables[3];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double tmp = v[i] * (v[i] + x3) + x4;                 double j1  = -v[i] * (v[i] + x2) / tmp;                 double j2  = -v[i] * x1 / tmp;                 double j3  = j1 * j2;                 double j4  = j3 / v[i];                 jacobian[i] = new double[] { j1, j2, j3, j4 };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double x4 = variables[3];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);             }             return f;         }          private static final double[] v = {             4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625         };          private static final double[] y = {             0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,             0.0456, 0.0342, 0.0323, 0.0235, 0.0246         };     }      private static class MeyerFunction extends MinpackFunction {          public MeyerFunction(double[] startParams,                              double theoreticalStartCost,                              double theoreticalMinCost,                              double[] theoreticalMinParams) {             super(16, startParams, theoreticalMinCost,                   theoreticalMinParams);             if (theoreticalStartCost > 1.0e6) {                 setCostAccuracy(7.0e-3);                 setParamsAccuracy(2.0e-2);             }         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x1 = variables[0];             double   x2 = variables[1];             double   x3 = variables[2];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double temp = 5.0 * (i + 1) + 45.0 + x3;                 double tmp1 = x2 / temp;                 double tmp2 = FastMath.exp(tmp1);                 double tmp3 = x1 * tmp2 / temp;                 jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];             }             return f;         }          private static final double[] y = {             34780.0, 28610.0, 23650.0, 19630.0,             16370.0, 13720.0, 11540.0,  9744.0,             8261.0,  7030.0,  6005.0,  5147.0,             4427.0,  3820.0,  3307.0,  2872.0         };     }      private static class WatsonFunction extends MinpackFunction {          public WatsonFunction(int n, double x0,                               double theoreticalStartCost,                               double theoreticalMinCost,                               double[] theoreticalMinParams) {             super(31, buildArray(n, x0), theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double[][] jacobian = new double[m][];              for (int i = 0; i < (m - 2); ++i) {                 double div = (i + 1) / 29.0;                 double s2  = 0.0;                 double dx  = 1.0;                 for (int j = 0; j < n; ++j) {                     s2 += dx * variables[j];                     dx *= div;                 }                 double temp= 2 * div * s2;                 dx = 1.0 / div;                 jacobian[i] = new double[n];                 for (int j = 0; j < n; ++j) {                     jacobian[i][j] = dx * (j - temp);                     dx *= div;                 }             }              jacobian[m - 2]    = new double[n];             jacobian[m - 2][0] = 1;              jacobian[m - 1]   = new double[n];             jacobian[m - 1][0]= -2 * variables[0];             jacobian[m - 1][1]= 1;              return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double[] f = new double[m];             for (int i = 0; i < (m - 2); ++i) {                 double div = (i + 1) / 29.0;                 double s1 = 0;                 double dx = 1;                 for (int j = 1; j < n; ++j) {                     s1 += j * dx * variables[j];                     dx *= div;                 }                 double s2 = 0;                 dx = 1;                 for (int j = 0; j < n; ++j) {                     s2 += dx * variables[j];                     dx *= div;                 }                 f[i] = s1 - s2 * s2 - 1;             }              double x1 = variables[0];             double x2 = variables[1];             f[m - 2] = x1;             f[m - 1] = x2 - x1 * x1 - 1;              return f;         }     }      private static class Box3DimensionalFunction extends MinpackFunction {          public Box3DimensionalFunction(int m, double[] startParams,                                        double theoreticalStartCost) {             super(m, startParams, 0.0,                   new double[] { 1.0, 10.0, 1.0 });         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x1 = variables[0];             double   x2 = variables[1];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double tmp = (i + 1) / 10.0;                 jacobian[i] = new double[] {                     -tmp * FastMath.exp(-tmp * x1),                     tmp * FastMath.exp(-tmp * x2),                     FastMath.exp(-i - 1) - FastMath.exp(-tmp)                 };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 double tmp = (i + 1) / 10.0;                 f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2)                     + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3;             }             return f;         }     }      private static class JennrichSampsonFunction extends MinpackFunction {          public JennrichSampsonFunction(int m, double[] startParams,                                        double theoreticalStartCost,                                        double theoreticalMinCost,                                        double[] theoreticalMinParams) {             super(m, startParams, theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x1 = variables[0];             double   x2 = variables[1];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double t = i + 1;                 jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 double temp = i + 1;                 f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2);             }             return f;         }     }      private static class BrownDennisFunction extends MinpackFunction {          public BrownDennisFunction(int m, double[] startParams,                                    double theoreticalStartCost,                                    double theoreticalMinCost,                                    double[] theoreticalMinParams) {             super(m, startParams, theoreticalMinCost,                 theoreticalMinParams);             setCostAccuracy(2.5e-8);         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x1 = variables[0];             double   x2 = variables[1];             double   x3 = variables[2];             double   x4 = variables[3];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double temp = (i + 1) / 5.0;                 double ti   = FastMath.sin(temp);                 double tmp1 = x1 + temp * x2 - FastMath.exp(temp);                 double tmp2 = x3 + ti   * x4 - FastMath.cos(temp);                 jacobian[i] = new double[] {                     2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2                 };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double x4 = variables[3];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 double temp = (i + 1) / 5.0;                 double tmp1 = x1 + temp * x2 - FastMath.exp(temp);                 double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp);                 f[i] = tmp1 * tmp1 + tmp2 * tmp2;             }             return f;         }     }      private static class ChebyquadFunction extends MinpackFunction {          private static double[] buildChebyquadArray(int n, double factor) {             double[] array = new double[n];             double inv = factor / (n + 1);             for (int i = 0; i < n; ++i) {                 array[i] = (i + 1) * inv;             }             return array;         }          public ChebyquadFunction(int n, int m, double factor,                                  double theoreticalStartCost,                                  double theoreticalMinCost,                                  double[] theoreticalMinParams) {             super(m, buildChebyquadArray(n, factor), theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 jacobian[i] = new double[n];             }              double dx = 1.0 / n;             for (int j = 0; j < n; ++j) {                 double tmp1 = 1;                 double tmp2 = 2 * variables[j] - 1;                 double temp = 2 * tmp2;                 double tmp3 = 0;                 double tmp4 = 2;                 for (int i = 0; i < m; ++i) {                     jacobian[i][j] = dx * tmp4;                     double ti = 4 * tmp2 + temp * tmp4 - tmp3;                     tmp3 = tmp4;                     tmp4 = ti;                     ti   = temp * tmp2 - tmp1;                     tmp1 = tmp2;                     tmp2 = ti;                 }             }              return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double[] f = new double[m];              for (int j = 0; j < n; ++j) {                 double tmp1 = 1;                 double tmp2 = 2 * variables[j] - 1;                 double temp = 2 * tmp2;                 for (int i = 0; i < m; ++i) {                     f[i] += tmp2;                     double ti = temp * tmp2 - tmp1;                     tmp1 = tmp2;                     tmp2 = ti;                 }             }              double dx = 1.0 / n;             boolean iev = false;             for (int i = 0; i < m; ++i) {                 f[i] *= dx;                 if (iev) {                     f[i] += 1.0 / (i * (i + 2));                 }                 iev = ! iev;             }              return f;         }     }      private static class BrownAlmostLinearFunction extends MinpackFunction {          public BrownAlmostLinearFunction(int m, double factor,                                          double theoreticalStartCost,                                          double theoreticalMinCost,                                          double[] theoreticalMinParams) {             super(m, buildArray(m, factor), theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 jacobian[i] = new double[n];             }              double prod = 1;             for (int j = 0; j < n; ++j) {                 prod *= variables[j];                 for (int i = 0; i < n; ++i) {                     jacobian[i][j] = 1;                 }                 jacobian[j][j] = 2;             }              for (int j = 0; j < n; ++j) {                 double temp = variables[j];                 if (temp == 0) {                     temp = 1;                     prod = 1;                     for (int k = 0; k < n; ++k) {                         if (k != j) {                             prod *= variables[k];                         }                     }                 }                 jacobian[n - 1][j] = prod / temp;             }              return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double[] f = new double[m];             double sum  = -(n + 1);             double prod = 1;             for (int j = 0; j < n; ++j) {                 sum  += variables[j];                 prod *= variables[j];             }             for (int i = 0; i < n; ++i) {                 f[i] = variables[i] + sum;             }             f[n - 1] = prod - 1;             return f;         }     }      private static class Osborne1Function extends MinpackFunction {          public Osborne1Function(double[] startParams,                                 double theoreticalStartCost,                                 double theoreticalMinCost,                                 double[] theoreticalMinParams) {             super(33, startParams, theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x2 = variables[1];             double   x3 = variables[2];             double   x4 = variables[3];             double   x5 = variables[4];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double temp = 10.0 * i;                 double tmp1 = FastMath.exp(-temp * x4);                 double tmp2 = FastMath.exp(-temp * x5);                 jacobian[i] = new double[] {                     -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2                 };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double x1 = variables[0];             double x2 = variables[1];             double x3 = variables[2];             double x4 = variables[3];             double x5 = variables[4];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 double temp = 10.0 * i;                 double tmp1 = FastMath.exp(-temp * x4);                 double tmp2 = FastMath.exp(-temp * x5);                 f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);             }             return f;         }          private static final double[] y = {             0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,             0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,             0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406         };     }      private static class Osborne2Function extends MinpackFunction {          public Osborne2Function(double[] startParams,                                 double theoreticalStartCost,                                 double theoreticalMinCost,                                 double[] theoreticalMinParams) {             super(65, startParams, theoreticalMinCost,                   theoreticalMinParams);         }          @Override         public double[][] computeJacobian(double[] variables) {             double   x01 = variables[0];             double   x02 = variables[1];             double   x03 = variables[2];             double   x04 = variables[3];             double   x05 = variables[4];             double   x06 = variables[5];             double   x07 = variables[6];             double   x08 = variables[7];             double   x09 = variables[8];             double   x10 = variables[9];             double   x11 = variables[10];             double[][] jacobian = new double[m][];             for (int i = 0; i < m; ++i) {                 double temp = i / 10.0;                 double tmp1 = FastMath.exp(-x05 * temp);                 double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));                 double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));                 double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));                 jacobian[i] = new double[] {                     -tmp1,                     -tmp2,                     -tmp3,                     -tmp4,                     temp * x01 * tmp1,                     x02 * (temp - x09) * (temp - x09) * tmp2,                     x03 * (temp - x10) * (temp - x10) * tmp3,                     x04 * (temp - x11) * (temp - x11) * tmp4,                     -2 * x02 * x06 * (temp - x09) * tmp2,                     -2 * x03 * x07 * (temp - x10) * tmp3,                     -2 * x04 * x08 * (temp - x11) * tmp4                 };             }             return jacobian;         }          @Override         public double[] computeValue(double[] variables) {             double x01 = variables[0];             double x02 = variables[1];             double x03 = variables[2];             double x04 = variables[3];             double x05 = variables[4];             double x06 = variables[5];             double x07 = variables[6];             double x08 = variables[7];             double x09 = variables[8];             double x10 = variables[9];             double x11 = variables[10];             double[] f = new double[m];             for (int i = 0; i < m; ++i) {                 double temp = i / 10.0;                 double tmp1 = FastMath.exp(-x05 * temp);                 double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));                 double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));                 double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));                 f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);             }             return f;         }          private static final double[] y = {             1.366, 1.191, 1.112, 1.013, 0.991,             0.885, 0.831, 0.847, 0.786, 0.725,             0.746, 0.679, 0.608, 0.655, 0.616,             0.606, 0.602, 0.626, 0.651, 0.724,             0.649, 0.649, 0.694, 0.644, 0.624,             0.661, 0.612, 0.558, 0.533, 0.495,             0.500, 0.423, 0.395, 0.375, 0.372,             0.391, 0.396, 0.405, 0.428, 0.429,             0.523, 0.562, 0.607, 0.653, 0.672,             0.708, 0.633, 0.668, 0.645, 0.632,             0.591, 0.559, 0.597, 0.625, 0.739,             0.710, 0.729, 0.720, 0.636, 0.581,             0.428, 0.292, 0.162, 0.098, 0.054         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import java.io.BufferedReader; import java.io.IOException; import java.util.ArrayList; import java.util.Arrays;  import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction;  /**  * This class gives access to the statistical reference datasets provided by the  * NIST (available  * <a href="http://www.itl.nist.gov/div898/strd/general/dataarchive.html">here</a>).  * Instances of this class can be created by invocation of the  * {@link StatisticalReferenceDatasetFactory}.  */ public abstract class StatisticalReferenceDataset {     /** The name of this dataset. */     private final String name;     /** The total number of observations (data points). */     private final int numObservations;     /** The total number of parameters. */     private final int numParameters;     /** The total number of starting points for the optimizations. */     private final int numStartingPoints;     /** The values of the predictor. */     private final double[] x;     /** The values of the response. */     private final double[] y;     /**      * The starting values. {@code startingValues[j][i]} is the value of the      * {@code i}-th parameter in the {@code j}-th set of starting values.      */     private final double[][] startingValues;     /** The certified values of the parameters. */     private final double[] a;     /** The certified values of the standard deviation of the parameters. */     private final double[] sigA;     /** The certified value of the residual sum of squares. */     private double residualSumOfSquares;     /** The least-squares problem. */     private final LeastSquaresProblem problem;      /**      * Creates a new instance of this class from the specified data file. The      * file must follow the StRD format.      *      * @param in the data file      * @throws IOException if an I/O error occurs      */     public StatisticalReferenceDataset(final BufferedReader in)         throws IOException {          final ArrayList<String> lines = new ArrayList<>();         for (String line = in.readLine(); line != null; line = in.readLine()) {             lines.add(line);         }         int[] index = findLineNumbers("Data", lines);         if (index == null) {             throw new AssertionError("could not find line indices for data");         }         this.numObservations = index[1] - index[0] + 1;         this.x = new double[this.numObservations];         this.y = new double[this.numObservations];         for (int i = 0; i < this.numObservations; i++) {             final String line = lines.get(index[0] + i - 1);             final String[] tokens = line.trim().split(" ++");             // Data columns are in reverse order!!!             this.y[i] = Double.parseDouble(tokens[0]);             this.x[i] = Double.parseDouble(tokens[1]);         }          index = findLineNumbers("Starting Values", lines);         if (index == null) {             throw new AssertionError(                                      "could not find line indices for starting values");         }         this.numParameters = index[1] - index[0] + 1;          double[][] start = null;         this.a = new double[numParameters];         this.sigA = new double[numParameters];         for (int i = 0; i < numParameters; i++) {             final String line = lines.get(index[0] + i - 1);             final String[] tokens = line.trim().split(" ++");             if (start == null) {                 start = new double[tokens.length - 4][numParameters];             }             for (int j = 2; j < tokens.length - 2; j++) {                 start[j - 2][i] = Double.parseDouble(tokens[j]);             }             this.a[i] = Double.parseDouble(tokens[tokens.length - 2]);             this.sigA[i] = Double.parseDouble(tokens[tokens.length - 1]);         }         if (start == null) {             throw new IOException("could not find starting values");         }         this.numStartingPoints = start.length;         this.startingValues = start;          double dummyDouble = Double.NaN;         String dummyString = null;         for (String line : lines) {             if (line.contains("Dataset Name:")) {                 dummyString = line                     .substring(line.indexOf("Dataset Name:") + 13,                                line.indexOf("(")).trim();             }             if (line.contains("Residual Sum of Squares")) {                 final String[] tokens = line.split(" ++");                 dummyDouble = Double.parseDouble(tokens[4].trim());             }         }         if (Double.isNaN(dummyDouble)) {             throw new IOException(                                   "could not find certified value of residual sum of squares");         }         this.residualSumOfSquares = dummyDouble;          if (dummyString == null) {             throw new IOException("could not find dataset name");         }         this.name = dummyString;          this.problem = new LeastSquaresProblem();     }      class LeastSquaresProblem {         public MultivariateVectorFunction getModelFunction() {             return new MultivariateVectorFunction() {                 @Override                 public double[] value(final double[] a) {                     final int n = getNumObservations();                     final double[] yhat = new double[n];                     for (int i = 0; i < n; i++) {                         yhat[i] = getModelValue(getX(i), a);                     }                     return yhat;                 }             };         }          public MultivariateMatrixFunction getModelFunctionJacobian() {             return new MultivariateMatrixFunction() {                 @Override                 public double[][] value(final double[] a)                     throws IllegalArgumentException {                     final int n = getNumObservations();                     final double[][] j = new double[n][];                     for (int i = 0; i < n; i++) {                         j[i] = getModelDerivatives(getX(i), a);                     }                     return j;                 }             };         }     }      /**      * Returns the name of this dataset.      *      * @return the name of the dataset      */     public String getName() {         return name;     }      /**      * Returns the total number of observations (data points).      *      * @return the number of observations      */     public int getNumObservations() {         return numObservations;     }      /**      * Returns a copy of the data arrays. The data is laid out as follows <li>      * {@code data[0][i] = x[i]},</li> <li>{@code data[1][i] = y[i]},</li>      *      * @return the array of data points.      */     public double[][] getData() {         return new double[][] {             Arrays.copyOf(x, x.length), Arrays.copyOf(y, y.length)         };     }      /**      * Returns the x-value of the {@code i}-th data point.      *      * @param i the index of the data point      * @return the x-value      */     public double getX(final int i) {         return x[i];     }      /**      * Returns the y-value of the {@code i}-th data point.      *      * @param i the index of the data point      * @return the y-value      */     public double getY(final int i) {         return y[i];     }      /**      * Returns the total number of parameters.      *      * @return the number of parameters      */     public int getNumParameters() {         return numParameters;     }      /**      * Returns the certified values of the paramters.      *      * @return the values of the parameters      */     public double[] getParameters() {         return Arrays.copyOf(a, a.length);     }      /**      * Returns the certified value of the {@code i}-th parameter.      *      * @param i the index of the parameter      * @return the value of the parameter      */     public double getParameter(final int i) {         return a[i];     }      /**      * Reurns the certified values of the standard deviations of the parameters.      *      * @return the standard deviations of the parameters      */     public double[] getParametersStandardDeviations() {         return Arrays.copyOf(sigA, sigA.length);     }      /**      * Returns the certified value of the standard deviation of the {@code i}-th      * parameter.      *      * @param i the index of the parameter      * @return the standard deviation of the parameter      */     public double getParameterStandardDeviation(final int i) {         return sigA[i];     }      /**      * Returns the certified value of the residual sum of squares.      *      * @return the residual sum of squares      */     public double getResidualSumOfSquares() {         return residualSumOfSquares;     }      /**      * Returns the total number of starting points (initial guesses for the      * optimization process).      *      * @return the number of starting points      */     public int getNumStartingPoints() {         return numStartingPoints;     }      /**      * Returns the {@code i}-th set of initial values of the parameters.      *      * @param i the index of the starting point      * @return the starting point      */     public double[] getStartingPoint(final int i) {         return Arrays.copyOf(startingValues[i], startingValues[i].length);     }      /**      * Returns the least-squares problem corresponding to fitting the model to      * the specified data.      *      * @return the least-squares problem      */     public LeastSquaresProblem getLeastSquaresProblem() {         return problem;     }      /**      * Returns the value of the model for the specified values of the predictor      * variable and the parameters.      *      * @param x the predictor variable      * @param a the parameters      * @return the value of the model      */     public abstract double getModelValue(final double x, final double[] a);      /**      * Returns the values of the partial derivatives of the model with respect      * to the parameters.      *      * @param x the predictor variable      * @param a the parameters      * @return the partial derivatives      */     public abstract double[] getModelDerivatives(final double x,                                                  final double[] a);      /**      * <p>      * Parses the specified text lines, and extracts the indices of the first      * and last lines of the data defined by the specified {@code key}. This key      * must be one of      * </p>      * <ul>      * <li>{@code "Starting Values"},</li>      * <li>{@code "Certified Values"},</li>      * <li>{@code "Data"}.</li>      * </ul>      * <p>      * In the NIST data files, the line indices are separated by the keywords      * {@code "lines"} and {@code "to"}.      * </p>      *      * @param lines the line of text to be parsed      * @return an array of two {@code int}s. First value is the index of the      *         first line, second value is the index of the last line.      *         {@code null} if the line could not be parsed.      */     private static int[] findLineNumbers(final String key,                                          final Iterable<String> lines) {         for (String text : lines) {             boolean flag = text.contains(key) && text.contains("lines") &&                            text.contains("to") && text.contains(")");             if (flag) {                 final int[] numbers = new int[2];                 final String from = text.substring(text.indexOf("lines") + 5,                                                    text.indexOf("to"));                 numbers[0] = Integer.parseInt(from.trim());                 final String to = text.substring(text.indexOf("to") + 2,                                                  text.indexOf(")"));                 numbers[1] = Integer.parseInt(to.trim());                 return numbers;             }         }         return null;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader;  import org.apache.commons.math4.util.FastMath;  /**  * A factory to create instances of {@link StatisticalReferenceDataset} from  * available resources.  */ public class StatisticalReferenceDatasetFactory {      private StatisticalReferenceDatasetFactory() {         // Do nothing     }      /**      * Creates a new buffered reader from the specified resource name.      *      * @param name the name of the resource      * @return a buffered reader      * @throws IOException if an I/O error occured      */     public static BufferedReader createBufferedReaderFromResource(final String name)         throws IOException {         final InputStream resourceAsStream;         resourceAsStream = StatisticalReferenceDatasetFactory.class             .getResourceAsStream(name);         if (resourceAsStream == null) {             throw new IOException("could not find resource " + name);         }         return new BufferedReader(new InputStreamReader(resourceAsStream));     }      public static StatisticalReferenceDataset createKirby2()         throws IOException {         final BufferedReader in = createBufferedReaderFromResource("Kirby2.dat");         StatisticalReferenceDataset dataset = null;         try {             dataset = new StatisticalReferenceDataset(in) {                  @Override                 public double getModelValue(final double x, final double[] a) {                     final double p = a[0] + x * (a[1] + x * a[2]);                     final double q = 1.0 + x * (a[3] + x * a[4]);                     return p / q;                 }                  @Override                 public double[] getModelDerivatives(final double x,                                                     final double[] a) {                     final double[] dy = new double[5];                     final double p = a[0] + x * (a[1] + x * a[2]);                     final double q = 1.0 + x * (a[3] + x * a[4]);                     dy[0] = 1.0 / q;                     dy[1] = x / q;                     dy[2] = x * dy[1];                     dy[3] = -x * p / (q * q);                     dy[4] = x * dy[3];                     return dy;                 }             };         } finally {             in.close();         }         return dataset;     }      public static StatisticalReferenceDataset createHahn1()         throws IOException {         final BufferedReader in = createBufferedReaderFromResource("Hahn1.dat");         StatisticalReferenceDataset dataset = null;         try {             dataset = new StatisticalReferenceDataset(in) {                  @Override                 public double getModelValue(final double x, final double[] a) {                     final double p = a[0] + x * (a[1] + x * (a[2] + x * a[3]));                     final double q = 1.0 + x * (a[4] + x * (a[5] + x * a[6]));                     return p / q;                 }                  @Override                 public double[] getModelDerivatives(final double x,                                                     final double[] a) {                     final double[] dy = new double[7];                     final double p = a[0] + x * (a[1] + x * (a[2] + x * a[3]));                     final double q = 1.0 + x * (a[4] + x * (a[5] + x * a[6]));                     dy[0] = 1.0 / q;                     dy[1] = x * dy[0];                     dy[2] = x * dy[1];                     dy[3] = x * dy[2];                     dy[4] = -x * p / (q * q);                     dy[5] = x * dy[4];                     dy[6] = x * dy[5];                     return dy;                 }             };         } finally {             in.close();         }         return dataset;     }      public static StatisticalReferenceDataset createMGH17()         throws IOException {         final BufferedReader in = createBufferedReaderFromResource("MGH17.dat");         StatisticalReferenceDataset dataset = null;         try {             dataset = new StatisticalReferenceDataset(in) {                  @Override                 public double getModelValue(final double x, final double[] a) {                     return a[0] + a[1] * FastMath.exp(-a[3] * x) + a[2] *                            FastMath.exp(-a[4] * x);                 }                  @Override                 public double[] getModelDerivatives(final double x,                                                     final double[] a) {                     final double[] dy = new double[5];                     dy[0] = 1.0;                     dy[1] = FastMath.exp(-x * a[3]);                     dy[2] = FastMath.exp(-x * a[4]);                     dy[3] = -x * a[1] * dy[1];                     dy[4] = -x * a[2] * dy[2];                     return dy;                 }             };         } finally {             in.close();         }         return dataset;     }      public static StatisticalReferenceDataset createLanczos1()         throws IOException {         final BufferedReader in =             createBufferedReaderFromResource("Lanczos1.dat");         StatisticalReferenceDataset dataset = null;         try {             dataset = new StatisticalReferenceDataset(in) {                  @Override                 public double getModelValue(final double x, final double[] a) {                     System.out.println(a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]);                     return a[0] * FastMath.exp(-a[3] * x) +                            a[1] * FastMath.exp(-a[4] * x) +                            a[2] * FastMath.exp(-a[5] * x);                 }                  @Override                 public double[] getModelDerivatives(final double x,                     final double[] a) {                     final double[] dy = new double[6];                     dy[0] = FastMath.exp(-x * a[3]);                     dy[1] = FastMath.exp(-x * a[4]);                     dy[2] = FastMath.exp(-x * a[5]);                     dy[3] = -x * a[0] * dy[0];                     dy[4] = -x * a[1] * dy[1];                     dy[5] = -x * a[2] * dy[2];                     return dy;                 }             };         } finally {             in.close();         }         return dataset;     }      /**      * Returns an array with all available reference datasets.      *      * @return the array of datasets      * @throws IOException if an I/O error occurs      */     public StatisticalReferenceDataset[] createAll()         throws IOException {         return new StatisticalReferenceDataset[] {             createKirby2(), createMGH17()         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import java.util.ArrayList;  import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathUtils;  /**  * Class that models a circle.  * The parameters of problem are:  * <ul>  *  <li>the x-coordinate of the circle center,</li>  *  <li>the y-coordinate of the circle center,</li>  *  <li>the radius of the circle.</li>  * </ul>  * The model functions are:  * <ul>  *  <li>for each triplet (cx, cy, r), the (x, y) coordinates of a point on the  *   corresponding circle.</li>  * </ul>  */ class CircleProblem {     /** Cloud of points assumed to be fitted by a circle. */     private final ArrayList<double[]> points;     /** Error on the x-coordinate of the points. */     private final double xSigma;     /** Error on the y-coordinate of the points. */     private final double ySigma;     /** Number of points on the circumference (when searching which         model point is closest to a given "observation". */     private final int resolution;      /**      * @param xError Assumed error for the x-coordinate of the circle points.      * @param yError Assumed error for the y-coordinate of the circle points.      * @param searchResolution Number of points to try when searching the one      * that is closest to a given "observed" point.      */     public CircleProblem(double xError,                          double yError,                          int searchResolution) {         points = new ArrayList<>();         xSigma = xError;         ySigma = yError;         resolution = searchResolution;     }      /**      * @param xError Assumed error for the x-coordinate of the circle points.      * @param yError Assumed error for the y-coordinate of the circle points.      */     public CircleProblem(double xError,                          double yError) {         this(xError, yError, 500);     }      public void addPoint(double px, double py) {         points.add(new double[] { px, py });     }      public double[] target() {         final double[] t = new double[points.size() * 2];         for (int i = 0; i < points.size(); i++) {             final double[] p = points.get(i);             final int index = i * 2;             t[index] = p[0];             t[index + 1] = p[1];         }          return t;     }      public double[] weight() {         final double wX = 1 / (xSigma * xSigma);         final double wY = 1 / (ySigma * ySigma);         final double[] w = new double[points.size() * 2];         for (int i = 0; i < points.size(); i++) {             final int index = i * 2;             w[index] = wX;             w[index + 1] = wY;         }          return w;     }      public MultivariateVectorFunction getModelFunction() {         return new MultivariateVectorFunction() {             @Override             public double[] value(double[] params) {                 final double cx = params[0];                 final double cy = params[1];                 final double r = params[2];                  final double[] model = new double[points.size() * 2];                  final double deltaTheta = MathUtils.TWO_PI / resolution;                 for (int i = 0; i < points.size(); i++) {                     final double[] p = points.get(i);                     final double px = p[0];                     final double py = p[1];                      double bestX = 0;                     double bestY = 0;                     double dMin = Double.POSITIVE_INFINITY;                      // Find the angle for which the circle passes closest to the                     // current point (using a resolution of 100 points along the                     // circumference).                     for (double theta = 0; theta <= MathUtils.TWO_PI; theta += deltaTheta) {                         final double currentX = cx + r * FastMath.cos(theta);                         final double currentY = cy + r * FastMath.sin(theta);                         final double dX = currentX - px;                         final double dY = currentY - py;                         final double d = dX * dX + dY * dY;                         if (d < dMin) {                             dMin = d;                             bestX = currentX;                             bestY = currentY;                         }                     }                      final int index = i * 2;                     model[index] = bestX;                     model[index + 1] = bestY;                 }                  return model;             }         };     }      public MultivariateMatrixFunction getModelFunctionJacobian() {         return new MultivariateMatrixFunction() {             @Override             public double[][] value(double[] point) {                 return jacobian(point);             }         };     }      private double[][] jacobian(double[] params) {         final double[][] jacobian = new double[points.size() * 2][3];          for (int i = 0; i < points.size(); i++) {             final int index = i * 2;             // Partial derivative wrt x-coordinate of center.             jacobian[index][0] = 1;             jacobian[index + 1][0] = 0;             // Partial derivative wrt y-coordinate of center.             jacobian[index][1] = 0;             jacobian[index + 1][1] = 1;             // Partial derivative wrt radius.             final double[] p = points.get(i);             jacobian[index][2] = (p[0] - params[0]) / params[2];             jacobian[index + 1][2] = (p[1] - params[1]) / params[2];         }          return jacobian;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.geometry.euclidean.twod.Vector2D; import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum; import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.ArrayRealVector; import org.apache.commons.math4.linear.BlockRealMatrix; import org.apache.commons.math4.linear.DiagonalMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.optim.ConvergenceChecker; import org.apache.commons.math4.optim.SimpleVectorValueChecker; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.Pair; import org.junit.Assert; import org.junit.Test;  import java.io.IOException; import java.util.Arrays;  import static org.hamcrest.CoreMatchers.is; import static org.hamcrest.CoreMatchers.not; import static org.hamcrest.CoreMatchers.sameInstance;  /**  * Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. The  * redistribution policy for MINPACK is available <a href="http://www.netlib.org/minpack/disclaimer">here</a>.  * <p>  * <T> Concrete implementation of an optimizer.  *  */ public abstract class AbstractLeastSquaresOptimizerAbstractTest {      /** default absolute tolerance of comparisons */     public static final double TOl = 1e-10;      public LeastSquaresBuilder base() {         return new LeastSquaresBuilder()                 .checkerPair(new SimpleVectorValueChecker(1e-6, 1e-6))                 .maxEvaluations(100)                 .maxIterations(getMaxIterations());     }      public LeastSquaresBuilder builder(CircleVectorial c) {         final double[] weights = new double[c.getN()];         Arrays.fill(weights, 1.0);         return base()                 .model(c.getModelFunction(), c.getModelFunctionJacobian())                 .target(new double[c.getN()])                 .weight(new DiagonalMatrix(weights));     }      public LeastSquaresBuilder builder(StatisticalReferenceDataset dataset) {         StatisticalReferenceDataset.LeastSquaresProblem problem                 = dataset.getLeastSquaresProblem();         final double[] weights = new double[dataset.getNumObservations()];         Arrays.fill(weights, 1.0);         return base()                 .model(problem.getModelFunction(), problem.getModelFunctionJacobian())                 .target(dataset.getData()[1])                 .weight(new DiagonalMatrix(weights))                 .start(dataset.getStartingPoint(0));     }      public void fail(LeastSquaresOptimizer optimizer) {         Assert.fail("Expected Exception from: " + optimizer.toString());     }      /**      * Check the value of a vector.      * @param tolerance the absolute tolerance of comparisons      * @param actual the vector to test      * @param expected the expected values      */     public void assertEquals(double tolerance, RealVector actual, double... expected){         for (int i = 0; i < expected.length; i++) {             Assert.assertEquals(expected[i], actual.getEntry(i), tolerance);         }         Assert.assertEquals(expected.length, actual.getDimension());     }      /**      * @return the default number of allowed iterations (which will be used when not      *         specified otherwise).      */     public abstract int getMaxIterations();      /**      * Get an instance of the optimizer under test.      *      * @return the subject under test.      */     public abstract LeastSquaresOptimizer getOptimizer();      /**      * The subject under test.      */     public final LeastSquaresOptimizer optimizer = this.getOptimizer();      @Test     public void testGetIterations() {         LeastSquaresProblem lsp = base()                 .target(new double[]{1})                 .weight(new DiagonalMatrix(new double[]{1}))                 .start(new double[]{3})                 .model(new MultivariateJacobianFunction() {                     @Override                     public Pair<RealVector, RealMatrix> value(final RealVector point) {                         return new Pair<RealVector, RealMatrix>(                                 new ArrayRealVector(                                         new double[]{                                                 FastMath.pow(point.getEntry(0), 4)                                         },                                         false),                                 new Array2DRowRealMatrix(                                         new double[][]{                                                 {0.25 * FastMath.pow(point.getEntry(0), 3)}                                         },                                         false)                         );                     }                 })                 .build();          Optimum optimum = optimizer.optimize(lsp);          //TODO more specific test? could pass with 'return 1;'         Assert.assertTrue(optimum.getIterations() > 0);     }      @Test     public void testTrivial() {         LinearProblem problem                 = new LinearProblem(new double[][]{{2}},                 new double[]{3});         LeastSquaresProblem ls = problem.getBuilder().build();          Optimum optimum = optimizer.optimize(ls);          Assert.assertEquals(0, optimum.getRMS(), TOl);         assertEquals(TOl, optimum.getPoint(), 1.5);         Assert.assertEquals(0.0, optimum.getResiduals().getEntry(0), TOl);     }      @Test     public void testQRColumnsPermutation() {         LinearProblem problem                 = new LinearProblem(new double[][]{{1, -1}, {0, 2}, {1, -2}},                 new double[]{4, 6, 1});          Optimum optimum = optimizer.optimize(problem.getBuilder().build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         assertEquals(TOl, optimum.getPoint(), 7, 3);         assertEquals(TOl, optimum.getResiduals(), 0, 0, 0);     }      @Test     public void testNoDependency() {         LinearProblem problem = new LinearProblem(new double[][]{                 {2, 0, 0, 0, 0, 0},                 {0, 2, 0, 0, 0, 0},                 {0, 0, 2, 0, 0, 0},                 {0, 0, 0, 2, 0, 0},                 {0, 0, 0, 0, 2, 0},                 {0, 0, 0, 0, 0, 2}         }, new double[]{0, 1.1, 2.2, 3.3, 4.4, 5.5});          Optimum optimum = optimizer.optimize(problem.getBuilder().build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         for (int i = 0; i < problem.target.length; ++i) {             Assert.assertEquals(0.55 * i, optimum.getPoint().getEntry(i), TOl);         }     }      @Test     public void testOneSet() {         LinearProblem problem = new LinearProblem(new double[][]{                 {1, 0, 0},                 {-1, 1, 0},                 {0, -1, 1}         }, new double[]{1, 1, 1});          Optimum optimum = optimizer.optimize(problem.getBuilder().build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         assertEquals(TOl, optimum.getPoint(), 1, 2, 3);     }      @Test     public void testTwoSets() {         double epsilon = 1e-7;         LinearProblem problem = new LinearProblem(new double[][]{                 {2, 1, 0, 4, 0, 0},                 {-4, -2, 3, -7, 0, 0},                 {4, 1, -2, 8, 0, 0},                 {0, -3, -12, -1, 0, 0},                 {0, 0, 0, 0, epsilon, 1},                 {0, 0, 0, 0, 1, 1}         }, new double[]{2, -9, 2, 2, 1 + epsilon * epsilon, 2});          Optimum optimum = optimizer.optimize(problem.getBuilder().build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         assertEquals(TOl, optimum.getPoint(), 3, 4, -1, -2, 1 + epsilon, 1 - epsilon);     }      @Test     public void testNonInvertible() throws Exception {         try {             LinearProblem problem = new LinearProblem(new double[][]{                     {1, 2, -3},                     {2, 1, 3},                     {-3, 0, -9}             }, new double[]{1, 1, 1});              optimizer.optimize(problem.getBuilder().build());              fail(optimizer);         } catch (ConvergenceException e) {             //expected         }     }      @Test     public void testIllConditioned() {         LinearProblem problem1 = new LinearProblem(new double[][]{                 {10, 7, 8, 7},                 {7, 5, 6, 5},                 {8, 6, 10, 9},                 {7, 5, 9, 10}         }, new double[]{32, 23, 33, 31});         final double[] start = {0, 1, 2, 3};          Optimum optimum = optimizer                 .optimize(problem1.getBuilder().start(start).build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         assertEquals(TOl, optimum.getPoint(), 1, 1, 1, 1);          LinearProblem problem2 = new LinearProblem(new double[][]{                 {10.00, 7.00, 8.10, 7.20},                 {7.08, 5.04, 6.00, 5.00},                 {8.00, 5.98, 9.89, 9.00},                 {6.99, 4.99, 9.00, 9.98}         }, new double[]{32, 23, 33, 31});          optimum = optimizer.optimize(problem2.getBuilder().start(start).build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         assertEquals(1e-8, optimum.getPoint(), -81, 137, -34, 22);     }      @Test     public void testMoreEstimatedParametersSimple() {         LinearProblem problem = new LinearProblem(new double[][]{                 {3, 2, 0, 0},                 {0, 1, -1, 1},                 {2, 0, 1, 0}         }, new double[]{7, 3, 5});          Optimum optimum = optimizer                 .optimize(problem.getBuilder().start(new double[]{7, 6, 5, 4}).build());          Assert.assertEquals(0, optimum.getRMS(), TOl);     }      @Test     public void testMoreEstimatedParametersUnsorted() {         LinearProblem problem = new LinearProblem(new double[][]{                 {1, 1, 0, 0, 0, 0},                 {0, 0, 1, 1, 1, 0},                 {0, 0, 0, 0, 1, -1},                 {0, 0, -1, 1, 0, 1},                 {0, 0, 0, -1, 1, 0}         }, new double[]{3, 12, -1, 7, 1});          Optimum optimum = optimizer.optimize(                 problem.getBuilder().start(new double[]{2, 2, 2, 2, 2, 2}).build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         RealVector point = optimum.getPoint();         //the first two elements are under constrained         //check first two elements obey the constraint: sum to 3         Assert.assertEquals(3, point.getEntry(0) + point.getEntry(1), TOl);         //#constrains = #states fro the last 4 elements         assertEquals(TOl, point.getSubVector(2, 4), 3, 4, 5, 6);     }      @Test     public void testRedundantEquations() {         LinearProblem problem = new LinearProblem(new double[][]{                 {1, 1},                 {1, -1},                 {1, 3}         }, new double[]{3, 1, 5});          Optimum optimum = optimizer                 .optimize(problem.getBuilder().start(new double[]{1, 1}).build());          Assert.assertEquals(0, optimum.getRMS(), TOl);         assertEquals(TOl, optimum.getPoint(), 2, 1);     }      @Test     public void testInconsistentEquations() {         LinearProblem problem = new LinearProblem(new double[][]{                 {1, 1},                 {1, -1},                 {1, 3}         }, new double[]{3, 1, 4});          Optimum optimum = optimizer                 .optimize(problem.getBuilder().start(new double[]{1, 1}).build());          //TODO what is this actually testing?         Assert.assertTrue(optimum.getRMS() > 0.1);     }      @Test     public void testInconsistentSizes1() {         try {             LinearProblem problem                     = new LinearProblem(new double[][]{{1, 0},                     {0, 1}},                     new double[]{-1, 1});              //TODO why is this part here? hasn't it been tested already?             Optimum optimum = optimizer.optimize(problem.getBuilder().build());              Assert.assertEquals(0, optimum.getRMS(), TOl);             assertEquals(TOl, optimum.getPoint(), -1, 1);              //TODO move to builder test             optimizer.optimize(                     problem.getBuilder().weight(new DiagonalMatrix(new double[]{1})).build());              fail(optimizer);         } catch (DimensionMismatchException e) {             //expected         }     }      @Test     public void testInconsistentSizes2() {         try {             LinearProblem problem                     = new LinearProblem(new double[][]{{1, 0}, {0, 1}},                     new double[]{-1, 1});              Optimum optimum = optimizer.optimize(problem.getBuilder().build());              Assert.assertEquals(0, optimum.getRMS(), TOl);             assertEquals(TOl, optimum.getPoint(), -1, 1);              //TODO move to builder test             optimizer.optimize(                     problem.getBuilder()                             .target(new double[]{1})                             .weight(new DiagonalMatrix(new double[]{1}))                             .build()             );              fail(optimizer);         } catch (DimensionMismatchException e) {             //expected         }     }      @Test     public void testCircleFitting() {         CircleVectorial circle = new CircleVectorial();         circle.addPoint(30, 68);         circle.addPoint(50, -6);         circle.addPoint(110, -20);         circle.addPoint(35, 15);         circle.addPoint(45, 97);         final double[] start = {98.680, 47.345};          Optimum optimum = optimizer.optimize(builder(circle).start(start).build());          Assert.assertTrue(optimum.getEvaluations() < 10);          double rms = optimum.getRMS();         Assert.assertEquals(1.768262623567235, FastMath.sqrt(circle.getN()) * rms, TOl);          Vector2D center = Vector2D.of(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));         Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1e-6);         Assert.assertEquals(96.07590211815305, center.getX(), 1e-6);         Assert.assertEquals(48.13516790438953, center.getY(), 1e-6);          double[][] cov = optimum.getCovariances(1e-14).getData();         Assert.assertEquals(1.839, cov[0][0], 0.001);         Assert.assertEquals(0.731, cov[0][1], 0.001);         Assert.assertEquals(cov[0][1], cov[1][0], 1e-14);         Assert.assertEquals(0.786, cov[1][1], 0.001);          // add perfect measurements and check formal errors are reduced         double r = circle.getRadius(center);         for (double d = 0; d < 2 * FastMath.PI; d += 0.01) {             circle.addPoint(center.getX() + r * FastMath.cos(d), center.getY() + r * FastMath.sin(d));         }          double[] weights = new double[circle.getN()];         Arrays.fill(weights, 2);          optimum = optimizer.optimize(                 builder(circle).weight(new DiagonalMatrix(weights)).start(start).build());          cov = optimum.getCovariances(1e-14).getData();         Assert.assertEquals(0.0016, cov[0][0], 0.001);         Assert.assertEquals(3.2e-7, cov[0][1], 1e-9);         Assert.assertEquals(cov[0][1], cov[1][0], 1e-14);         Assert.assertEquals(0.0016, cov[1][1], 0.001);     }      @Test     public void testCircleFittingBadInit() {         CircleVectorial circle = new CircleVectorial();         double[][] points = circlePoints;         double[] weights = new double[points.length];         final double[] start = {-12, -12};         Arrays.fill(weights, 2);         for (int i = 0; i < points.length; ++i) {             circle.addPoint(points[i][0], points[i][1]);         }          Optimum optimum = optimizer.optimize(builder(circle).weight(new DiagonalMatrix(weights)).start(start).build());          Vector2D center = Vector2D.of(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));         Assert.assertTrue(optimum.getEvaluations() < 25);         Assert.assertEquals(0.043, optimum.getRMS(), 1e-3);         Assert.assertEquals(0.292235, circle.getRadius(center), 1e-6);         Assert.assertEquals(-0.151738, center.getX(), 1e-6);         Assert.assertEquals(0.2075001, center.getY(), 1e-6);     }      @Test     public void testCircleFittingGoodInit() {         CircleVectorial circle = new CircleVectorial();         double[][] points = circlePoints;         double[] weights = new double[points.length];         Arrays.fill(weights, 2);         for (int i = 0; i < points.length; ++i) {             circle.addPoint(points[i][0], points[i][1]);         }         final double[] start = {0, 0};          Optimum optimum = optimizer.optimize(                 builder(circle).weight(new DiagonalMatrix(weights)).start(start).build());          assertEquals(1e-6, optimum.getPoint(), -0.1517383071957963, 0.2074999736353867);         Assert.assertEquals(0.04268731682389561, optimum.getRMS(), 1e-8);     }      private final double[][] circlePoints = new double[][]{             {-0.312967, 0.072366}, {-0.339248, 0.132965}, {-0.379780, 0.202724},             {-0.390426, 0.260487}, {-0.361212, 0.328325}, {-0.346039, 0.392619},             {-0.280579, 0.444306}, {-0.216035, 0.470009}, {-0.149127, 0.493832},             {-0.075133, 0.483271}, {-0.007759, 0.452680}, {0.060071, 0.410235},             {0.103037, 0.341076}, {0.118438, 0.273884}, {0.131293, 0.192201},             {0.115869, 0.129797}, {0.072223, 0.058396}, {0.022884, 0.000718},             {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},             {-0.278592, -0.005008}, {-0.337655, 0.056658}, {-0.385899, 0.112526},             {-0.405517, 0.186957}, {-0.415374, 0.262071}, {-0.387482, 0.343398},             {-0.347322, 0.397943}, {-0.287623, 0.458425}, {-0.223502, 0.475513},             {-0.135352, 0.478186}, {-0.061221, 0.483371}, {0.003711, 0.422737},             {0.065054, 0.375830}, {0.108108, 0.297099}, {0.123882, 0.222850},             {0.117729, 0.134382}, {0.085195, 0.056820}, {0.029800, -0.019138},             {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},             {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561, 0.014926},             {-0.471036, 0.074716}, {-0.488638, 0.182508}, {-0.485990, 0.254068},             {-0.463943, 0.338438}, {-0.406453, 0.404704}, {-0.334287, 0.466119},             {-0.254244, 0.503188}, {-0.161548, 0.495769}, {-0.075733, 0.495560},             {0.001375, 0.434937}, {0.082787, 0.385806}, {0.115490, 0.323807},             {0.141089, 0.223450}, {0.138693, 0.131703}, {0.126415, 0.049174},             {0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},             {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},             {-0.405195, -0.000895}, {-0.444937, 0.085456}, {-0.484357, 0.175597},             {-0.472453, 0.248681}, {-0.438580, 0.347463}, {-0.402304, 0.422428},             {-0.326777, 0.479438}, {-0.247797, 0.505581}, {-0.152676, 0.519380},             {-0.071754, 0.516264}, {0.015942, 0.472802}, {0.076608, 0.419077},             {0.127673, 0.330264}, {0.159951, 0.262150}, {0.153530, 0.172681},             {0.140653, 0.089229}, {0.078666, 0.024981}, {0.023807, -0.037022},             {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}     };      public void doTestStRD(final StatisticalReferenceDataset dataset,                            final LeastSquaresOptimizer optimizer,                            final double errParams,                            final double errParamsSd) {          final Optimum optimum = optimizer.optimize(builder(dataset).build());          final RealVector actual = optimum.getPoint();         for (int i = 0; i < actual.getDimension(); i++) {             double expected = dataset.getParameter(i);             double delta = FastMath.abs(errParams * expected);             Assert.assertEquals(dataset.getName() + ", param #" + i,                     expected, actual.getEntry(i), delta);         }     }      @Test     public void testKirby2() throws IOException {         doTestStRD(StatisticalReferenceDatasetFactory.createKirby2(), optimizer, 1E-7, 1E-7);     }      @Test     public void testHahn1() throws IOException {         doTestStRD(StatisticalReferenceDatasetFactory.createHahn1(), optimizer, 1E-7, 1E-4);     }      @Test     public void testPointCopy() {         LinearProblem problem = new LinearProblem(new double[][]{                 {1, 0, 0},                 {-1, 1, 0},                 {0, -1, 1}         }, new double[]{1, 1, 1});         //mutable boolean         final boolean[] checked = {false};          final LeastSquaresBuilder builder = problem.getBuilder()                 .checker(new ConvergenceChecker<Evaluation>() {                     @Override                     public boolean converged(int iteration, Evaluation previous, Evaluation current) {                         Assert.assertThat(                                 previous.getPoint(),                                 not(sameInstance(current.getPoint())));                         Assert.assertArrayEquals(new double[3], previous.getPoint().toArray(), 0);                         Assert.assertArrayEquals(new double[] {1, 2, 3}, current.getPoint().toArray(), TOl);                         checked[0] = true;                         return true;                     }                 });         optimizer.optimize(builder.build());          Assert.assertThat(checked[0], is(true));     }      class LinearProblem {         private final RealMatrix factors;         private final double[] target;          public LinearProblem(double[][] factors, double[] target) {             this.factors = new BlockRealMatrix(factors);             this.target = target;         }          public double[] getTarget() {             return target;         }          public MultivariateVectorFunction getModelFunction() {             return new MultivariateVectorFunction() {                 @Override                 public double[] value(double[] params) {                     return factors.operate(params);                 }             };         }          public MultivariateMatrixFunction getModelFunctionJacobian() {             return new MultivariateMatrixFunction() {                 @Override                 public double[][] value(double[] params) {                     return factors.getData();                 }             };         }          public LeastSquaresBuilder getBuilder() {             final double[] weights = new double[target.length];             Arrays.fill(weights, 1.0);             return base()                     .model(getModelFunction(), getModelFunctionJacobian())                     .target(target)                     .weight(new DiagonalMatrix(weights))                     .start(new double[factors.getColumnDimension()]);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.Decomposition; import org.apache.commons.math4.optim.SimpleVectorValueChecker; import org.junit.Test;  import java.io.IOException;  /**  * <p>Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a  * href="http://www.netlib.org/minpack/disclaimer">here</a>/  *  */ public class GaussNewtonOptimizerWithLUTest     extends AbstractLeastSquaresOptimizerAbstractTest {      @Override     public int getMaxIterations() {         return 1000;     }      @Override     public LeastSquaresOptimizer getOptimizer() {         return new GaussNewtonOptimizer(Decomposition.LU);     }      @Override     @Test     public void testMoreEstimatedParametersSimple() {         /*          * Exception is expected with this optimizer          */         try {             super.testMoreEstimatedParametersSimple();             fail(optimizer);         } catch (ConvergenceException e) {             //expected         }     }      @Override     @Test     public void testMoreEstimatedParametersUnsorted() {         /*          * Exception is expected with this optimizer          */         try{             super.testMoreEstimatedParametersUnsorted();             fail(optimizer);         }catch (ConvergenceException e){             //expected         }     }      @Test     public void testMaxEvaluations() throws Exception {         try{         CircleVectorial circle = new CircleVectorial();         circle.addPoint( 30.0,  68.0);         circle.addPoint( 50.0,  -6.0);         circle.addPoint(110.0, -20.0);         circle.addPoint( 35.0,  15.0);         circle.addPoint( 45.0,  97.0);          LeastSquaresProblem lsp = builder(circle)                 .checkerPair(new SimpleVectorValueChecker(1e-30, 1e-30))                 .maxIterations(Integer.MAX_VALUE)                 .start(new double[]{98.680, 47.345})                 .build();          optimizer.optimize(lsp);              fail(optimizer);         }catch (TooManyEvaluationsException e){             //expected         }     }      @Override     @Test     public void testCircleFittingBadInit() {         /*          * This test does not converge with this optimizer.          */         try{             super.testCircleFittingBadInit();             fail(optimizer);         }catch (ConvergenceException e){             //expected         }     }      @Override     @Test     public void testHahn1()         throws IOException {         /*          * TODO This test leads to a singular problem with the Gauss-Newton          * optimizer. This should be inquired.          */         try{             super.testHahn1();             fail(optimizer);         } catch (ConvergenceException e){             //expected for LU         } catch (TooManyEvaluationsException e){             //expected for QR         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.Decomposition; import org.apache.commons.math4.optim.SimpleVectorValueChecker; import org.junit.Test;  import java.io.IOException;  /**  * <p>Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a  * href="http://www.netlib.org/minpack/disclaimer">here</a>/  *  */ public class GaussNewtonOptimizerWithQRTest     extends AbstractLeastSquaresOptimizerAbstractTest {      @Override     public int getMaxIterations() {         return 1000;     }      @Override     public LeastSquaresOptimizer getOptimizer() {         return new GaussNewtonOptimizer(Decomposition.QR);     }      @Override     @Test     public void testMoreEstimatedParametersUnsorted() {         /*          * Exception is expected with this optimizer          */         try{             super.testMoreEstimatedParametersUnsorted();             fail(optimizer);         }catch (ConvergenceException e){             //expected         }     }      @Test     public void testMaxEvaluations() throws Exception {         try{         CircleVectorial circle = new CircleVectorial();         circle.addPoint( 30.0,  68.0);         circle.addPoint( 50.0,  -6.0);         circle.addPoint(110.0, -20.0);         circle.addPoint( 35.0,  15.0);         circle.addPoint( 45.0,  97.0);          LeastSquaresProblem lsp = builder(circle)                 .checkerPair(new SimpleVectorValueChecker(1e-30, 1e-30))                 .maxIterations(Integer.MAX_VALUE)                 .start(new double[]{98.680, 47.345})                 .build();          optimizer.optimize(lsp);              fail(optimizer);         }catch (TooManyEvaluationsException e){             //expected         }     }      @Override     @Test     public void testCircleFittingBadInit() {         /*          * This test does not converge with this optimizer.          */         try{             super.testCircleFittingBadInit();             fail(optimizer);         }catch (ConvergenceException e){             //expected         }     }      @Override     @Test     public void testHahn1()         throws IOException {         /*          * TODO This test leads to a singular problem with the Gauss-Newton          * optimizer. This should be inquired.          */         try{             super.testHahn1();             fail(optimizer);         } catch (ConvergenceException e){             //expected for LU         } catch (TooManyEvaluationsException e){             //expected for QR         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.optim.ConvergenceChecker; import org.junit.Assert; import org.junit.Test;  /** Unit tests for {@link EvaluationRmsChecker}. */ public class EvaluationRmsCheckerTest {      /** check {@link ConvergenceChecker#converged(int, Object, Object)}. */     @Test     public void testConverged() {         //setup         ConvergenceChecker<Evaluation> checker = new EvaluationRmsChecker(0.1, 1);         Evaluation e200 = mockEvaluation(200);         Evaluation e1 = mockEvaluation(1);          //action + verify         //just matches rel tol         Assert.assertEquals(true, checker.converged(0, e200, mockEvaluation(210)));         //just matches abs tol         Assert.assertEquals(true, checker.converged(0, e1, mockEvaluation(1.9)));         //matches both         Assert.assertEquals(true, checker.converged(0, e1, mockEvaluation(1.01)));         //matches neither         Assert.assertEquals(false, checker.converged(0, e200, mockEvaluation(300)));     }      /**      * Create a mock {@link Evaluation}.      *      * @param rms the evaluation's rms.      * @return a new mock evaluation.      */     private static Evaluation mockEvaluation(final double rms) {         return new Evaluation() {             @Override             public RealMatrix getCovariances(double threshold) {                 return null;             }              @Override             public RealVector getSigma(double covarianceSingularityThreshold) {                 return null;             }              @Override             public double getRMS() {                 return rms;             }              @Override             public RealMatrix getJacobian() {                 return null;             }              @Override             public double getCost() {                 return 0;             }              @Override             public double getChiSquare() {                 return 0;             }              @Override             public double getReducedChiSquare(int n) {                 return 0;             }              @Override             public RealVector getResiduals() {                 return null;             }              @Override             public RealVector getPoint() {                 return null;             }         };     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.Decomposition; import org.apache.commons.math4.optim.SimpleVectorValueChecker; import org.junit.Test;  import java.io.IOException;  /**  * <p>Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a  * href="http://www.netlib.org/minpack/disclaimer">here</a>/  *  */ public class GaussNewtonOptimizerWithCholeskyTest     extends AbstractLeastSquaresOptimizerAbstractTest {      @Override     public int getMaxIterations() {         return 1000;     }      @Override     public LeastSquaresOptimizer getOptimizer() {         return new GaussNewtonOptimizer(Decomposition.CHOLESKY);     }      @Override     @Test     public void testMoreEstimatedParametersSimple() {         /*          * Exception is expected with this optimizer          */         try {             super.testMoreEstimatedParametersSimple();             fail(optimizer);         } catch (ConvergenceException e) {             //expected         }     }      @Override     @Test     public void testMoreEstimatedParametersUnsorted() {         /*          * Exception is expected with this optimizer          */         try{             super.testMoreEstimatedParametersUnsorted();             fail(optimizer);         }catch (ConvergenceException e){             //expected         }     }      @Test     public void testMaxEvaluations() throws Exception {         try{         CircleVectorial circle = new CircleVectorial();         circle.addPoint( 30.0,  68.0);         circle.addPoint( 50.0,  -6.0);         circle.addPoint(110.0, -20.0);         circle.addPoint( 35.0,  15.0);         circle.addPoint( 45.0,  97.0);          LeastSquaresProblem lsp = builder(circle)                 .checkerPair(new SimpleVectorValueChecker(1e-30, 1e-30))                 .maxIterations(Integer.MAX_VALUE)                 .start(new double[]{98.680, 47.345})                 .build();          optimizer.optimize(lsp);              fail(optimizer);         }catch (TooManyEvaluationsException e){             //expected         }     }      @Override     @Test     public void testCircleFittingBadInit() {         /*          * This test does not converge with this optimizer.          */         try{             super.testCircleFittingBadInit();             fail(optimizer);         }catch (ConvergenceException e){             //expected         }     }      @Override     @Test     public void testHahn1()         throws IOException {         /*          * TODO This test leads to a singular problem with the Gauss-Newton          * optimizer. This should be inquired.          */         try{             super.testHahn1();             fail(optimizer);         } catch (ConvergenceException e){             //expected for LU         } catch (TooManyEvaluationsException e){             //expected for QR         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import java.util.ArrayList;  import org.apache.commons.geometry.euclidean.twod.Vector2D; import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction;  /**  * Class used in the tests.  */ class CircleVectorial {     private ArrayList<Vector2D> points;      public CircleVectorial() {         points  = new ArrayList<>();     }      public void addPoint(double px, double py) {         points.add(Vector2D.of(px, py));     }      public int getN() {         return points.size();     }      public double getRadius(Vector2D center) {         double r = 0;         for (Vector2D point : points) {             r += point.distance(center);         }         return r / points.size();     }      public MultivariateVectorFunction getModelFunction() {         return new MultivariateVectorFunction() {             @Override             public double[] value(double[] params) {                 Vector2D center = Vector2D.of(params[0], params[1]);                 double radius = getRadius(center);                 double[] residuals = new double[points.size()];                 for (int i = 0; i < residuals.length; i++) {                     residuals[i] = points.get(i).distance(center) - radius;                 }                  return residuals;             }         };     }      public MultivariateMatrixFunction getModelFunctionJacobian() {         return new MultivariateMatrixFunction() {             @Override             public double[][] value(double[] params) {                 final int n = points.size();                 final Vector2D center = Vector2D.of(params[0], params[1]);                  double dRdX = 0;                 double dRdY = 0;                 for (Vector2D pk : points) {                     double dk = pk.distance(center);                     dRdX += (center.getX() - pk.getX()) / dk;                     dRdY += (center.getY() - pk.getY()) / dk;                 }                 dRdX /= n;                 dRdY /= n;                  // Jacobian of the radius residuals.                 double[][] jacobian = new double[n][2];                 for (int i = 0; i < n; i++) {                     final Vector2D pi = points.get(i);                     final double di = pi.distance(center);                     jacobian[i][0] = (center.getX() - pi.getX()) / di - dRdX;                     jacobian[i][1] = (center.getY() - pi.getY()) / di - dRdY;                 }                  return jacobian;             }         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.util.FastMath;  import java.util.ArrayList; import java.util.List;  class BevingtonProblem {     private List<Double> time;     private List<Double> count;      public BevingtonProblem() {         time = new ArrayList<>();         count = new ArrayList<>();     }      public void addPoint(double t, double c) {         time.add(t);         count.add(c);     }      public MultivariateVectorFunction getModelFunction() {         return new MultivariateVectorFunction() {             @Override             public double[] value(double[] params) {                 double[] values = new double[time.size()];                 for (int i = 0; i < values.length; ++i) {                     final double t = time.get(i);                     values[i] = params[0] +                         params[1] * FastMath.exp(-t / params[3]) +                         params[2] * FastMath.exp(-t / params[4]);                 }                 return values;             }         };     }      public MultivariateMatrixFunction getModelFunctionJacobian() {         return new MultivariateMatrixFunction() {             @Override             public double[][] value(double[] params) {                 double[][] jacobian = new double[time.size()][5];                  for (int i = 0; i < jacobian.length; ++i) {                     final double t = time.get(i);                     jacobian[i][0] = 1;                      final double p3 =  params[3];                     final double p4 =  params[4];                     final double tOp3 = t / p3;                     final double tOp4 = t / p4;                     jacobian[i][1] = FastMath.exp(-tOp3);                     jacobian[i][2] = FastMath.exp(-tOp4);                     jacobian[i][3] = params[1] * FastMath.exp(-tOp3) * tOp3 / p3;                     jacobian[i][4] = params[2] * FastMath.exp(-tOp4) * tOp4 / p4;                 }                 return jacobian;             }         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation; import org.apache.commons.math4.linear.ArrayRealVector; import org.apache.commons.math4.linear.DiagonalMatrix; import org.apache.commons.math4.linear.MatrixUtils; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.linear.SingularMatrixException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.Pair; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  import java.io.IOException; import java.util.Arrays;  /**  * The only features tested here are utility methods defined  * in {@link LeastSquaresProblem.Evaluation} that compute the  * chi-square and parameters standard-deviations.  */ public class EvaluationTest {      /**      * Create a {@link LeastSquaresBuilder} from a {@link StatisticalReferenceDataset}.      *      * @param dataset the source data      * @return a builder for further customization.      */     public LeastSquaresBuilder builder(StatisticalReferenceDataset dataset) {         StatisticalReferenceDataset.LeastSquaresProblem problem                 = dataset.getLeastSquaresProblem();         final double[] start = dataset.getParameters();         final double[] observed = dataset.getData()[1];         final double[] weights = new double[observed.length];         Arrays.fill(weights, 1d);          return new LeastSquaresBuilder()                 .model(problem.getModelFunction(), problem.getModelFunctionJacobian())                 .target(observed)                 .weight(new DiagonalMatrix(weights))                 .start(start);     }      @Test     public void testComputeResiduals() {         //setup         RealVector point = new ArrayRealVector(2);         Evaluation evaluation = new LeastSquaresBuilder()                 .target(new ArrayRealVector(new double[]{3,-1}))                 .model(new MultivariateJacobianFunction() {                     @Override                     public Pair<RealVector, RealMatrix> value(RealVector point) {                         return new Pair<RealVector, RealMatrix>(                                 new ArrayRealVector(new double[]{1, 2}),                                 MatrixUtils.createRealIdentityMatrix(2)                         );                     }                 })                 .weight(MatrixUtils.createRealIdentityMatrix(2))                 .build()                 .evaluate(point);          //action + verify         Assert.assertArrayEquals(                 evaluation.getResiduals().toArray(),                 new double[]{2, -3},                 Precision.EPSILON);     }      @Test     public void testComputeCovariance() throws IOException {         //setup         RealVector point = new ArrayRealVector(2);         Evaluation evaluation = new LeastSquaresBuilder()                 .model(new MultivariateJacobianFunction() {                     @Override                     public Pair<RealVector, RealMatrix> value(RealVector point) {                         return new Pair<RealVector, RealMatrix>(                                 new ArrayRealVector(2),                                 MatrixUtils.createRealDiagonalMatrix(new double[]{1, 1e-2})                         );                     }                 })                 .weight(MatrixUtils.createRealDiagonalMatrix(new double[]{1, 1}))                 .target(new ArrayRealVector(2))                 .build()                 .evaluate(point);          //action         TestUtils.assertEquals(                 "covariance",                 evaluation.getCovariances(FastMath.nextAfter(1e-4, 0.0)),                 MatrixUtils.createRealMatrix(new double[][]{{1, 0}, {0, 1e4}}),                 Precision.EPSILON         );          //singularity fail         try {             evaluation.getCovariances(FastMath.nextAfter(1e-4, 1.0));             Assert.fail("Expected Exception");         } catch (SingularMatrixException e) {             //expected         }     }      @Test     public void testComputeValueAndJacobian() {         //setup         final RealVector point = new ArrayRealVector(new double[]{1, 2});         Evaluation evaluation = new LeastSquaresBuilder()                 .weight(new DiagonalMatrix(new double[]{16, 4}))                 .model(new MultivariateJacobianFunction() {                     @Override                     public Pair<RealVector, RealMatrix> value(RealVector actualPoint) {                         //verify correct values passed in                         Assert.assertArrayEquals(                                 point.toArray(), actualPoint.toArray(), Precision.EPSILON);                         //return values                         return new Pair<RealVector, RealMatrix>(                                 new ArrayRealVector(new double[]{3, 4}),                                 MatrixUtils.createRealMatrix(new double[][]{{5, 6}, {7, 8}})                         );                     }                 })                 .target(new double[2])                 .build()                 .evaluate(point);          //action         RealVector residuals = evaluation.getResiduals();         RealMatrix jacobian = evaluation.getJacobian();          //verify         Assert.assertArrayEquals(evaluation.getPoint().toArray(), point.toArray(), 0);         Assert.assertArrayEquals(new double[]{-12, -8}, residuals.toArray(), Precision.EPSILON);         TestUtils.assertEquals(                 "jacobian",                 jacobian,                 MatrixUtils.createRealMatrix(new double[][]{{20, 24},{14, 16}}),                 Precision.EPSILON);     }      @Test     public void testComputeCost() throws IOException {         final StatisticalReferenceDataset dataset             = StatisticalReferenceDatasetFactory.createKirby2();          final LeastSquaresProblem lsp = builder(dataset).build();          final double expected = dataset.getResidualSumOfSquares();         final double cost = lsp.evaluate(lsp.getStart()).getCost();         final double actual = cost * cost;         Assert.assertEquals(dataset.getName(), expected, actual, 1e-11 * expected);     }      @Test     public void testComputeRMS() throws IOException {         final StatisticalReferenceDataset dataset             = StatisticalReferenceDatasetFactory.createKirby2();          final LeastSquaresProblem lsp = builder(dataset).build();          final double expected = FastMath.sqrt(dataset.getResidualSumOfSquares() /                                               dataset.getNumObservations());         final double actual = lsp.evaluate(lsp.getStart()).getRMS();         Assert.assertEquals(dataset.getName(), expected, actual, 1e-11 * expected);     }      @Test     public void testComputeSigma() throws IOException {         final StatisticalReferenceDataset dataset             = StatisticalReferenceDatasetFactory.createKirby2();          final LeastSquaresProblem lsp = builder(dataset).build();          final double[] expected = dataset.getParametersStandardDeviations();          final Evaluation evaluation = lsp.evaluate(lsp.getStart());         final double cost = evaluation.getCost();         final RealVector sig = evaluation.getSigma(1e-14);         final int dof = lsp.getObservationSize() - lsp.getParameterSize();         for (int i = 0; i < sig.getDimension(); i++) {             final double actual = FastMath.sqrt(cost * cost / dof) * sig.getEntry(i);             Assert.assertEquals(dataset.getName() + ", parameter #" + i,                                 expected[i], actual, 1e-6 * expected[i]);         }     }      @Test     public void testEvaluateCopiesPoint() throws IOException {         //setup         StatisticalReferenceDataset dataset                 = StatisticalReferenceDatasetFactory.createKirby2();         LeastSquaresProblem lsp = builder(dataset).build();         RealVector point = new ArrayRealVector(lsp.getParameterSize());          //action         Evaluation evaluation = lsp.evaluate(point);          //verify         Assert.assertNotSame(point, evaluation.getPoint());         point.setEntry(0, 1);         Assert.assertEquals(evaluation.getPoint().getEntry(0), 0, 0);     }      @Test     public void testLazyEvaluation() {         final RealVector dummy = new ArrayRealVector(new double[] { 0 });          final LeastSquaresProblem p             = LeastSquaresFactory.create(LeastSquaresFactory.model(dummyModel(), dummyJacobian()),                                          dummy, dummy, null, null, 0, 0, true, null);          // Should not throw because actual evaluation is deferred.         final Evaluation eval = p.evaluate(dummy);          try {             eval.getResiduals();             Assert.fail("Exception expected");         } catch (RuntimeException e) {             // Expecting exception.             Assert.assertEquals("dummyModel", e.getMessage());         }          try {             eval.getJacobian();             Assert.fail("Exception expected");         } catch (RuntimeException e) {             // Expecting exception.             Assert.assertEquals("dummyJacobian", e.getMessage());         }     }      // MATH-1151     @Test     public void testLazyEvaluationPrecondition() {         final RealVector dummy = new ArrayRealVector(new double[] { 0 });          // "ValueAndJacobianFunction" is required but we implement only         // "MultivariateJacobianFunction".         final MultivariateJacobianFunction m1 = new MultivariateJacobianFunction() {                 @Override                 public Pair<RealVector, RealMatrix> value(RealVector notUsed) {                     return new Pair<>(null, null);                 }             };          try {             // Should throw.             LeastSquaresFactory.create(m1, dummy, dummy, null, null, 0, 0, true, null);             Assert.fail("Expecting MathIllegalStateException");         } catch (MathIllegalStateException e) {             // Expected.         }          final MultivariateJacobianFunction m2 = new ValueAndJacobianFunction() {                 @Override                 public Pair<RealVector, RealMatrix> value(RealVector notUsed) {                     return new Pair<>(null, null);                 }                 @Override                 public RealVector computeValue(final double[] params) {                     return null;                 }                 @Override                 public RealMatrix computeJacobian(final double[] params) {                     return null;                 }             };          // Should pass.         LeastSquaresFactory.create(m2, dummy, dummy, null, null, 0, 0, true, null);     }      @Test     public void testDirectEvaluation() {         final RealVector dummy = new ArrayRealVector(new double[] { 0 });          final LeastSquaresProblem p             = LeastSquaresFactory.create(LeastSquaresFactory.model(dummyModel(), dummyJacobian()),                                          dummy, dummy, null, null, 0, 0, false, null);          try {             // Should throw.             p.evaluate(dummy);             Assert.fail("Exception expected");         } catch (RuntimeException e) {             // Expecting exception.             // Whether it is model or Jacobian that caused it is not significant.             final String msg = e.getMessage();             Assert.assertTrue(msg.equals("dummyModel") ||                               msg.equals("dummyJacobian"));         }     }      /** Used for testing direct vs lazy evaluation. */     private MultivariateVectorFunction dummyModel() {         return new MultivariateVectorFunction() {             @Override             public double[] value(double[] p) {                 throw new RuntimeException("dummyModel");             }         };     }      /** Used for testing direct vs lazy evaluation. */     private MultivariateMatrixFunction dummyJacobian() {         return new MultivariateMatrixFunction() {             @Override             public double[][] value(double[] p) {                 throw new RuntimeException("dummyJacobian");             }         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import java.awt.geom.Point2D;  import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource;  /**  * Factory for generating a cloud of points that approximate a straight line.  */ public class RandomStraightLinePointGenerator {     /** Slope. */     private final double slope;     /** Intercept. */     private final double intercept;     /** RNG for the x-coordinate. */     private final ContinuousDistribution.Sampler x;     /** RNG for the error on the y-coordinate. */     private final ContinuousDistribution.Sampler error;      /**      * The generator will create a cloud of points whose x-coordinates      * will be randomly sampled between {@code xLo} and {@code xHi}, and      * the corresponding y-coordinates will be computed as      * <pre><code>      *  y = a x + b + N(0, error)      * </code></pre>      * where {@code N(mean, sigma)} is a Gaussian distribution with the      * given mean and standard deviation.      *      * @param a Slope.      * @param b Intercept.      * @param sigma Standard deviation on the y-coordinate of the point.      * @param lo Lowest value of the x-coordinate.      * @param hi Highest value of the x-coordinate.      * @param seed RNG seed.      */     public RandomStraightLinePointGenerator(double a,                                             double b,                                             double sigma,                                             double lo,                                             double hi,                                             long seed) {         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_44497_B, seed);         slope = a;         intercept = b;         error = new NormalDistribution(0, sigma).createSampler(rng);         x = new UniformContinuousDistribution(lo, hi).createSampler(rng);     }      /**      * Point generator.      *      * @param n Number of points to create.      * @return the cloud of {@code n} points.      */     public Point2D.Double[] generate(int n) {         final Point2D.Double[] cloud = new Point2D.Double[n];         for (int i = 0; i < n; i++) {             cloud[i] = create();         }         return cloud;     }      /**      * Create one point.      *      * @return a point.      */     private Point2D.Double create() {         final double abscissa = x.sample();         final double yModel = slope * abscissa + intercept;         final double ordinate = yModel + error.sample();          return new Point2D.Double(abscissa, ordinate);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.geometry.euclidean.threed.Plane; import org.apache.commons.geometry.euclidean.threed.Planes; import org.apache.commons.geometry.euclidean.threed.Vector3D; import org.apache.commons.geometry.core.precision.EpsilonDoublePrecisionContext; import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.Decomposition; import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum; import org.apache.commons.math4.optim.SimpleVectorValueChecker; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  import java.io.IOException;  /**  * <p>Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a  * href="http://www.netlib.org/minpack/disclaimer">here</a>/  *  */ public class GaussNewtonOptimizerWithSVDTest     extends AbstractLeastSquaresOptimizerAbstractTest {      @Override     public int getMaxIterations() {         return 1000;     }      @Override     public LeastSquaresOptimizer getOptimizer() {         return new GaussNewtonOptimizer(Decomposition.SVD);     }      @Test     public void testMaxEvaluations() throws Exception {         try{         CircleVectorial circle = new CircleVectorial();         circle.addPoint( 30.0,  68.0);         circle.addPoint( 50.0,  -6.0);         circle.addPoint(110.0, -20.0);         circle.addPoint( 35.0,  15.0);         circle.addPoint( 45.0,  97.0);          LeastSquaresProblem lsp = builder(circle)                 .checkerPair(new SimpleVectorValueChecker(1e-30, 1e-30))                 .maxIterations(Integer.MAX_VALUE)                 .start(new double[]{98.680, 47.345})                 .build();          optimizer.optimize(lsp);              fail(optimizer);         }catch (TooManyEvaluationsException e){             //expected         }     }      @Override     @Test     public void testCircleFittingBadInit() {         /*          * This test converged to the wrong solution with this optimizer.          * It seems that the state becomes so large that the convergence          * checker's relative tolerance test passes.          */         try {             super.testCircleFittingBadInit();             fail(optimizer);         } catch (AssertionError e) {             //expected         }     }      @Override     @Test     public void testHahn1()         throws IOException {         /*          * TODO This test leads to a singular problem with the Gauss-Newton          * optimizer. This should be inquired.          */         try{             super.testHahn1();             fail(optimizer);         } catch (ConvergenceException e){             //expected for LU         } catch (TooManyEvaluationsException e){             //expected for QR         }     }      @Test     @Override     public void testGetIterations() {         /* this diverges with SVD */         try {             super.testGetIterations();             fail(optimizer);         } catch (TooManyEvaluationsException e) {             //expected         }     }      @Test     @Override     public void testNonInvertible() throws Exception {         /*  SVD can compute a solution to singular problems.          *  In this case the target vector, b, is not in the          *  span of the jacobian matrix, A. The closes point          *  to b on the plane spanned by A is computed.          */         LinearProblem problem = new LinearProblem(new double[][]{                 {1, 2, -3},                 {2, 1, 3},                 {-3, 0, -9}         }, new double[]{1, 1, 1});          Optimum optimum = optimizer.optimize(problem.getBuilder().build());          Plane span = Planes.fromPoints(Vector3D.ZERO, Vector3D.of(1, 2, -3), Vector3D.of(2, 1, 0),                                        new EpsilonDoublePrecisionContext(TOl));         double expected = FastMath.abs(span.offset(Vector3D.of(1, 1, 1)));         double actual = optimum.getResiduals().getNorm();          //verify         Assert.assertEquals(expected, actual, TOl);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.geometry.euclidean.twod.Vector2D; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum; import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation; import org.apache.commons.math4.linear.DiagonalMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.linear.SingularMatrixException; import org.apache.commons.math4.optim.ConvergenceChecker; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  import static org.hamcrest.CoreMatchers.is;  /**  * <p>Some of the unit tests are re-implementations of the MINPACK <a  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a  * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a  * href="http://www.netlib.org/minpack/disclaimer">here</a>.  *  */ public class LevenbergMarquardtOptimizerTest     extends AbstractLeastSquaresOptimizerAbstractTest{      public LeastSquaresBuilder builder(BevingtonProblem problem){         return base()                 .model(problem.getModelFunction(), problem.getModelFunctionJacobian());     }      public LeastSquaresBuilder builder(CircleProblem problem){         return base()                 .model(problem.getModelFunction(), problem.getModelFunctionJacobian())                 .target(problem.target())                 .weight(new DiagonalMatrix(problem.weight()));     }      @Override     public int getMaxIterations() {         return 25;     }      @Override     public LeastSquaresOptimizer getOptimizer() {         return new LevenbergMarquardtOptimizer();     }      @Override     @Test     public void testNonInvertible() {         try{             /*              * Overrides the method from parent class, since the default singularity              * threshold (1e-14) does not trigger the expected exception.              */             LinearProblem problem = new LinearProblem(new double[][] {                     {  1, 2, -3 },                     {  2, 1,  3 },                     { -3, 0, -9 }             }, new double[] { 1, 1, 1 });              final Optimum optimum = optimizer.optimize(                     problem.getBuilder().maxIterations(20).build());              //TODO check that it is a bad fit? Why the extra conditions?             Assert.assertTrue(FastMath.sqrt(problem.getTarget().length) * optimum.getRMS() > 0.6);              optimum.getCovariances(1.5e-14);              fail(optimizer);         }catch (SingularMatrixException e){             //expected         }     }      @Test     public void testControlParameters() {         CircleVectorial circle = new CircleVectorial();         circle.addPoint( 30.0,  68.0);         circle.addPoint( 50.0,  -6.0);         circle.addPoint(110.0, -20.0);         circle.addPoint( 35.0,  15.0);         circle.addPoint( 45.0,  97.0);         checkEstimate(                 circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);         checkEstimate(                 circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, false);         checkEstimate(                 circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);         circle.addPoint(300, -300);         //wardev I changed true => false         //TODO why should this fail? It uses 15 evaluations.         checkEstimate(                 circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, false);     }      private void checkEstimate(CircleVectorial circle,                                double initialStepBoundFactor, int maxCostEval,                                double costRelativeTolerance, double parRelativeTolerance,                                double orthoTolerance, boolean shouldFail) {         try {             final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer()                 .withInitialStepBoundFactor(initialStepBoundFactor)                 .withCostRelativeTolerance(costRelativeTolerance)                 .withParameterRelativeTolerance(parRelativeTolerance)                 .withOrthoTolerance(orthoTolerance)                 .withRankingThreshold(Precision.SAFE_MIN);              final LeastSquaresProblem problem = builder(circle)                     .maxEvaluations(maxCostEval)                     .maxIterations(100)                     .start(new double[] { 98.680, 47.345 })                     .build();              optimizer.optimize(problem);              Assert.assertTrue(!shouldFail);             //TODO check it got the right answer          } catch (DimensionMismatchException ee) {             Assert.assertTrue(shouldFail);         } catch (TooManyEvaluationsException ee) {             Assert.assertTrue(shouldFail);         }     }      /**      * Non-linear test case: fitting of decay curve (from Chapter 8 of      * Bevington's textbook, "Data reduction and analysis for the physical sciences").      * XXX The expected ("reference") values may not be accurate and the tolerance too      * relaxed for this test to be currently really useful (the issue is under      * investigation).      */     @Test     public void testBevington() {         final double[][] dataPoints = {             // column 1 = times             { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150,               165, 180, 195, 210, 225, 240, 255, 270, 285, 300,               315, 330, 345, 360, 375, 390, 405, 420, 435, 450,               465, 480, 495, 510, 525, 540, 555, 570, 585, 600,               615, 630, 645, 660, 675, 690, 705, 720, 735, 750,               765, 780, 795, 810, 825, 840, 855, 870, 885, },             // column 2 = measured counts             { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89,               74, 61, 66, 68, 48, 54, 51, 46, 55, 29,               28, 37, 49, 26, 35, 29, 31, 24, 25, 35,               24, 30, 26, 28, 21, 18, 20, 27, 17, 17,               14, 17, 24, 11, 22, 17, 12, 10, 13, 16,               9, 9, 14, 21, 17, 13, 12, 18, 10, },         };         final double[] start = {10, 900, 80, 27, 225};          final BevingtonProblem problem = new BevingtonProblem();          final int len = dataPoints[0].length;         final double[] weights = new double[len];         for (int i = 0; i < len; i++) {             problem.addPoint(dataPoints[0][i],                              dataPoints[1][i]);              weights[i] = 1 / dataPoints[1][i];         }          final Optimum optimum = optimizer.optimize(                 builder(problem)                         .target(dataPoints[1])                         .weight(new DiagonalMatrix(weights))                         .start(start)                         .maxIterations(20)                         .build()         );          final RealVector solution = optimum.getPoint();         final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 };          final RealMatrix covarMatrix = optimum.getCovariances(1e-14);         final double[][] expectedCovarMatrix = {             { 3.38, -3.69, 27.98, -2.34, -49.24 },             { -3.69, 2492.26, 81.89, -69.21, -8.9 },             { 27.98, 81.89, 468.99, -44.22, -615.44 },             { -2.34, -69.21, -44.22, 6.39, 53.80 },             { -49.24, -8.9, -615.44, 53.8, 929.45 }         };          final int numParams = expectedSolution.length;          // Check that the computed solution is within the reference error range.         for (int i = 0; i < numParams; i++) {             final double error = FastMath.sqrt(expectedCovarMatrix[i][i]);             Assert.assertEquals("Parameter " + i, expectedSolution[i], solution.getEntry(i), error);         }          // Check that each entry of the computed covariance matrix is within 10%         // of the reference matrix entry.         for (int i = 0; i < numParams; i++) {             for (int j = 0; j < numParams; j++) {                 Assert.assertEquals("Covariance matrix [" + i + "][" + j + "]",                                     expectedCovarMatrix[i][j],                                     covarMatrix.getEntry(i, j),                                     FastMath.abs(0.1 * expectedCovarMatrix[i][j]));             }         }          // Check various measures of goodness-of-fit.         final double chi2 = optimum.getChiSquare();         final double cost = optimum.getCost();         final double rms = optimum.getRMS();         final double reducedChi2 = optimum.getReducedChiSquare(start.length);          // XXX Values computed by the CM code: It would be better to compare         // with the results from another library.         final double expectedChi2 = 66.07852350839286;         final double expectedReducedChi2 = 1.2014277001525975;         final double expectedCost = 8.128869755900439;         final double expectedRms = 1.0582887010256337;          final double tol = 1e-14;         Assert.assertEquals(expectedChi2, chi2, tol);         Assert.assertEquals(expectedReducedChi2, reducedChi2, tol);         Assert.assertEquals(expectedCost, cost, tol);         Assert.assertEquals(expectedRms, rms, tol);     }      @Test     public void testCircleFitting2() {         final double xCenter = 123.456;         final double yCenter = 654.321;         final double xSigma = 10;         final double ySigma = 15;         final double radius = 111.111;         // The test is extremely sensitive to the seed.         final long seed = 59321761419L;         final RandomCirclePointGenerator factory             = new RandomCirclePointGenerator(xCenter, yCenter, radius,                                              xSigma, ySigma,                                              seed);         final CircleProblem circle = new CircleProblem(xSigma, ySigma);          final int numPoints = 10;         for (Vector2D p : factory.generate(numPoints)) {             circle.addPoint(p.getX(), p.getY());         }          // First guess for the center's coordinates and radius.         final double[] init = { 90, 659, 115 };          final Optimum optimum = optimizer.optimize(                 builder(circle).maxIterations(50).start(init).build());          final double[] paramFound = optimum.getPoint().toArray();          // Retrieve errors estimation.         final double[] asymptoticStandardErrorFound = optimum.getSigma(1e-14).toArray();          // Check that the parameters are found within the assumed error bars.         Assert.assertEquals(xCenter, paramFound[0], asymptoticStandardErrorFound[0]);         Assert.assertEquals(yCenter, paramFound[1], asymptoticStandardErrorFound[1]);         Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]);     }      @Test     public void testParameterValidator() {         // Setup.         final double xCenter = 123.456;         final double yCenter = 654.321;         final double xSigma = 10;         final double ySigma = 15;         final double radius = 111.111;         final long seed = 3456789L;         final RandomCirclePointGenerator factory             = new RandomCirclePointGenerator(xCenter, yCenter, radius,                                              xSigma, ySigma,                                              seed);         final CircleProblem circle = new CircleProblem(xSigma, ySigma);          final int numPoints = 10;         for (Vector2D p : factory.generate(numPoints)) {             circle.addPoint(p.getX(), p.getY());         }          // First guess for the center's coordinates and radius.         final double[] init = { 90, 659, 115 };         final Optimum optimum             = optimizer.optimize(builder(circle).maxIterations(50).start(init).build());         final int numEval = optimum.getEvaluations();         Assert.assertTrue(numEval > 1);          // Build a new problem with a validator that amounts to cheating.         final ParameterValidator cheatValidator             = new ParameterValidator() {                     @Override                     public RealVector validate(RealVector params) {                         // Cheat: return the optimum found previously.                         return optimum.getPoint();                     }                 };          final Optimum cheatOptimum             = optimizer.optimize(builder(circle).maxIterations(50).start(init).parameterValidator(cheatValidator).build());         final int cheatNumEval = cheatOptimum.getEvaluations();         Assert.assertTrue(cheatNumEval < numEval);         // System.out.println("n=" + numEval + " nc=" + cheatNumEval);     }      @Test     public void testEvaluationCount() {         //setup         LeastSquaresProblem lsp = new LinearProblem(new double[][] {{1}}, new double[] {1})                 .getBuilder()                 .checker(new ConvergenceChecker<Evaluation>() {                     @Override                     public boolean converged(int iteration, Evaluation previous, Evaluation current) {                         return true;                     }                 })                 .build();          //action         Optimum optimum = optimizer.optimize(lsp);          //verify         //check iterations and evaluations are not switched.         Assert.assertThat(optimum.getIterations(), is(1));         Assert.assertThat(optimum.getEvaluations(), is(2));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator; import org.apache.commons.math4.analysis.differentiation.UnivariateVectorFunctionDifferentiator; import org.apache.commons.math4.linear.DiagonalMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.optim.SimpleVectorValueChecker; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class DifferentiatorVectorMultivariateJacobianFunctionTest {      private static final int POINTS = 20;     private static final double STEP_SIZE = 0.2;      private final UnivariateVectorFunctionDifferentiator differentiator = new FiniteDifferencesDifferentiator(POINTS, STEP_SIZE);     private final LeastSquaresOptimizer optimizer = this.getOptimizer();      public LeastSquaresBuilder base() {         return new LeastSquaresBuilder()                 .checkerPair(new SimpleVectorValueChecker(1e-6, 1e-6))                 .maxEvaluations(100)                 .maxIterations(getMaxIterations());     }      public LeastSquaresBuilder builder(BevingtonProblem problem, boolean automatic){         if(automatic) {             return base()                     .model(new DifferentiatorVectorMultivariateJacobianFunction(problem.getModelFunction(), differentiator));         }         else {             return base()                     .model(problem.getModelFunction(), problem.getModelFunctionJacobian());         }     }      public int getMaxIterations() {         return 25;     }      public LeastSquaresOptimizer getOptimizer() {         return new LevenbergMarquardtOptimizer();     }      /**      * Non-linear test case: fitting of decay curve (from Chapter 8 of      * Bevington's textbook, "Data reduction and analysis for the physical sciences").      */     @Test     public void testBevington() {          // the analytical optimum to compare to         final LeastSquaresOptimizer.Optimum analyticalOptimum = findBevington(false);         final RealVector analyticalSolution = analyticalOptimum.getPoint();         final RealMatrix analyticalCovarianceMatrix = analyticalOptimum.getCovariances(1e-14);          // the automatic DifferentiatorVectorMultivariateJacobianFunction optimum         final LeastSquaresOptimizer.Optimum automaticOptimum = findBevington(true);         final RealVector automaticSolution = automaticOptimum.getPoint();         final RealMatrix automaticCovarianceMatrix = automaticOptimum.getCovariances(1e-14);          final int numParams = analyticalOptimum.getPoint().getDimension();          // Check that the automatic solution is within the reference error range.         for (int i = 0; i < numParams; i++) {             final double error = FastMath.sqrt(analyticalCovarianceMatrix.getEntry(i, i));             Assert.assertEquals("Parameter " + i, analyticalSolution.getEntry(i), automaticSolution.getEntry(i), error);         }          // Check that each entry of the computed covariance matrix is within 1%         // of the reference analytical matrix entry.         for (int i = 0; i < numParams; i++) {             for (int j = 0; j < numParams; j++) {                 Assert.assertEquals("Covariance matrix [" + i + "][" + j + "]",                         analyticalCovarianceMatrix.getEntry(i, j),                         automaticCovarianceMatrix.getEntry(i, j),                         FastMath.abs(0.01 * analyticalCovarianceMatrix.getEntry(i, j)));             }         }          // Check various measures of goodness-of-fit.         final double tol = 1e-40;         Assert.assertEquals(analyticalOptimum.getChiSquare(), automaticOptimum.getChiSquare(), tol);         Assert.assertEquals(analyticalOptimum.getCost(), automaticOptimum.getCost(), tol);         Assert.assertEquals(analyticalOptimum.getRMS(), automaticOptimum.getRMS(), tol);         Assert.assertEquals(analyticalOptimum.getReducedChiSquare(automaticOptimum.getPoint().getDimension()), automaticOptimum.getReducedChiSquare(automaticOptimum.getPoint().getDimension()), tol);     }      /**      * Build the problem and return the optimum, doesn't actually test the results.      *      * Pass in if you want to test using analytical derivatives,      * or the automatic {@link DifferentiatorVectorMultivariateJacobianFunction}      *      * @param automatic automatic {@link DifferentiatorVectorMultivariateJacobianFunction}, as opposed to analytical      * @return the optimum for this test      */     private LeastSquaresOptimizer.Optimum findBevington(boolean automatic) {         final double[][] dataPoints = {                 // column 1 = times                 { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150,                         165, 180, 195, 210, 225, 240, 255, 270, 285, 300,                         315, 330, 345, 360, 375, 390, 405, 420, 435, 450,                         465, 480, 495, 510, 525, 540, 555, 570, 585, 600,                         615, 630, 645, 660, 675, 690, 705, 720, 735, 750,                         765, 780, 795, 810, 825, 840, 855, 870, 885, },                 // column 2 = measured counts                 { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89,                         74, 61, 66, 68, 48, 54, 51, 46, 55, 29,                         28, 37, 49, 26, 35, 29, 31, 24, 25, 35,                         24, 30, 26, 28, 21, 18, 20, 27, 17, 17,                         14, 17, 24, 11, 22, 17, 12, 10, 13, 16,                         9, 9, 14, 21, 17, 13, 12, 18, 10, },         };         final double[] start = {10, 900, 80, 27, 225};          final BevingtonProblem problem = new BevingtonProblem();          final int len = dataPoints[0].length;         final double[] weights = new double[len];         for (int i = 0; i < len; i++) {             problem.addPoint(dataPoints[0][i],                     dataPoints[1][i]);              weights[i] = 1 / dataPoints[1][i];         }          return optimizer.optimize(                 builder(problem, automatic)                         .target(dataPoints[1])                         .weight(new DiagonalMatrix(weights))                         .start(start)                         .build()         );     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting.leastsquares;  import org.apache.commons.geometry.euclidean.twod.Vector2D; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathUtils;  /**  * Factory for generating a cloud of points that approximate a circle.  */ public class RandomCirclePointGenerator {     /** RNG for the x-coordinate of the center. */     private final ContinuousDistribution.Sampler cX;     /** RNG for the y-coordinate of the center. */     private final ContinuousDistribution.Sampler cY;     /** RNG for the parametric position of the point. */     private final ContinuousDistribution.Sampler tP;     /** Radius of the circle. */     private final double radius;      /**      * @param x Abscissa of the circle center.      * @param y Ordinate of the circle center.      * @param radius Radius of the circle.      * @param xSigma Error on the x-coordinate of the circumference points.      * @param ySigma Error on the y-coordinate of the circumference points.      * @param seed RNG seed.      */     public RandomCirclePointGenerator(double x,                                       double y,                                       double radius,                                       double xSigma,                                       double ySigma,                                       long seed) {         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_44497_B, seed);         this.radius = radius;         cX = new NormalDistribution(x, xSigma).createSampler(rng);         cY = new NormalDistribution(y, ySigma).createSampler(rng);         tP = new UniformContinuousDistribution(0, MathUtils.TWO_PI).createSampler(rng);     }      /**      * Point generator.      *      * @param n Number of points to create.      * @return the cloud of {@code n} points.      */     public Vector2D[] generate(int n) {         final Vector2D[] cloud = new Vector2D[n];         for (int i = 0; i < n; i++) {             cloud[i] = create();         }         return cloud;     }      /**      * Create one point.      *      * @return a point.      */     private Vector2D create() {         final double t = tP.sample();         final double pX = cX.sample() + radius * FastMath.cos(t);         final double pY = cY.sample() + radius * FastMath.sin(t);          return Vector2D.of(pX, pY);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.fitting.leastsquares;  import java.util.ArrayList;  import org.apache.commons.math4.analysis.MultivariateMatrixFunction; import org.apache.commons.math4.analysis.MultivariateVectorFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.stat.regression.SimpleRegression;  /**  * Class that models a straight line defined as {@code y = a x + b}.  * The parameters of problem are:  * <ul>  *  <li>{@code a}</li>  *  <li>{@code b}</li>  * </ul>  * The model functions are:  * <ul>  *  <li>for each pair (a, b), the y-coordinate of the line.</li>  * </ul>  */ class StraightLineProblem {     /** Cloud of points assumed to be fitted by a straight line. */     private final ArrayList<double[]> points;     /** Error (on the y-coordinate of the points). */     private final double sigma;      /**      * @param error Assumed error for the y-coordinate.      */     public StraightLineProblem(double error) {         points = new ArrayList<>();         sigma = error;     }      public void addPoint(double px, double py) {         points.add(new double[] { px, py });     }      /**      * @return the list of x-coordinates.      */     public double[] x() {         final double[] v = new double[points.size()];         for (int i = 0; i < points.size(); i++) {             final double[] p = points.get(i);             v[i] = p[0]; // x-coordinate.         }          return v;     }      /**      * @return the list of y-coordinates.      */     public double[] y() {         final double[] v = new double[points.size()];         for (int i = 0; i < points.size(); i++) {             final double[] p = points.get(i);             v[i] = p[1]; // y-coordinate.         }          return v;     }      public double[] target() {         return y();     }      public double[] weight() {         final double weight = 1 / (sigma * sigma);         final double[] w = new double[points.size()];         for (int i = 0; i < points.size(); i++) {             w[i] = weight;         }          return w;     }      public MultivariateVectorFunction getModelFunction() {         return new MultivariateVectorFunction() {             @Override             public double[] value(double[] params) {                 final Model line = new Model(params[0], params[1]);                  final double[] model = new double[points.size()];                 for (int i = 0; i < points.size(); i++) {                     final double[] p = points.get(i);                     model[i] = line.value(p[0]);                 }                  return model;             }         };     }      public MultivariateMatrixFunction getModelFunctionJacobian() {         return new MultivariateMatrixFunction() {             @Override             public double[][] value(double[] point) {                 return jacobian(point);             }         };     }      /**      * Directly solve the linear problem, using the {@link SimpleRegression}      * class.      */     public double[] solve() {         final SimpleRegression regress = new SimpleRegression(true);         for (double[] d : points) {             regress.addData(d[0], d[1]);         }          final double[] result = { regress.getSlope(), regress.getIntercept() };         return result;     }      private double[][] jacobian(double[] params) {         final double[][] jacobian = new double[points.size()][2];          for (int i = 0; i < points.size(); i++) {             final double[] p = points.get(i);             // Partial derivative wrt "a".             jacobian[i][0] = p[0];             // Partial derivative wrt "b".             jacobian[i][1] = 1;         }          return jacobian;     }      /**      * Linear function.      */     public static class Model implements UnivariateFunction {         final double a;         final double b;          public Model(double a,                      double b) {             this.a = a;             this.b = b;         }          @Override         public double value(double x) {             return a * x + b;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting;  import java.util.ArrayList; import java.util.List; import java.util.Random;  import org.apache.commons.numbers.angle.PlaneAngleRadians; import org.apache.commons.math4.analysis.function.HarmonicOscillator; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class HarmonicCurveFitterTest {     /**      * Zero points is not enough observed points.      */     @Test(expected=NumberIsTooSmallException.class)     public void testPreconditions1() {         HarmonicCurveFitter.create().fit(new WeightedObservedPoints().toList());     }      @Test     public void testNoError() {         final double a = 0.2;         final double w = 3.4;         final double p = 4.1;         final HarmonicOscillator f = new HarmonicOscillator(a, w, p);          final WeightedObservedPoints points = new WeightedObservedPoints();         for (double x = 0.0; x < 1.3; x += 0.01) {             points.add(1, x, f.value(x));         }          final HarmonicCurveFitter fitter = HarmonicCurveFitter.create();         final double[] fitted = fitter.fit(points.toList());         Assert.assertEquals(a, fitted[0], 1.0e-13);         Assert.assertEquals(w, fitted[1], 1.0e-13);         Assert.assertEquals(p, PlaneAngleRadians.normalize(fitted[2], p), 1e-13);          final HarmonicOscillator ff = new HarmonicOscillator(fitted[0], fitted[1], fitted[2]);         for (double x = -1.0; x < 1.0; x += 0.01) {             Assert.assertTrue(FastMath.abs(f.value(x) - ff.value(x)) < 1e-13);         }     }      @Test     public void test1PercentError() {         final Random randomizer = new Random(64925784252L);         final double a = 0.2;         final double w = 3.4;         final double p = 4.1;         final HarmonicOscillator f = new HarmonicOscillator(a, w, p);          final WeightedObservedPoints points = new WeightedObservedPoints();         for (double x = 0.0; x < 10.0; x += 0.1) {             points.add(1, x, f.value(x) + 0.01 * randomizer.nextGaussian());         }          final HarmonicCurveFitter fitter = HarmonicCurveFitter.create();         final double[] fitted = fitter.fit(points.toList());         Assert.assertEquals(a, fitted[0], 7.6e-4);         Assert.assertEquals(w, fitted[1], 2.7e-3);         Assert.assertEquals(p, PlaneAngleRadians.normalize(fitted[2], p), 1.3e-2);     }      @Test     public void testTinyVariationsData() {         final Random randomizer = new Random(64925784252L);          final WeightedObservedPoints points = new WeightedObservedPoints();         for (double x = 0.0; x < 10.0; x += 0.1) {             points.add(1, x, 1e-7 * randomizer.nextGaussian());         }          final HarmonicCurveFitter fitter = HarmonicCurveFitter.create();         fitter.fit(points.toList());          // This test serves to cover the part of the code of "guessAOmega"         // when the algorithm using integrals fails.     }      @Test     public void testInitialGuess() {         final Random randomizer = new Random(45314242L);         final double a = 0.2;         final double w = 3.4;         final double p = 4.1;         final HarmonicOscillator f = new HarmonicOscillator(a, w, p);          final WeightedObservedPoints points = new WeightedObservedPoints();         for (double x = 0.0; x < 10.0; x += 0.1) {             points.add(1, x, f.value(x) + 0.01 * randomizer.nextGaussian());         }          final HarmonicCurveFitter fitter = HarmonicCurveFitter.create()             .withStartPoint(new double[] { 0.15, 3.6, 4.5 });         final double[] fitted = fitter.fit(points.toList());         Assert.assertEquals(a, fitted[0], 1.2e-3);         Assert.assertEquals(w, fitted[1], 3.3e-3);         Assert.assertEquals(p, PlaneAngleRadians.normalize(fitted[2], p), 1.7e-2);     }      @Test     public void testUnsorted() {         Random randomizer = new Random(64925784252L);         final double a = 0.2;         final double w = 3.4;         final double p = 4.1;         final HarmonicOscillator f = new HarmonicOscillator(a, w, p);          // Build a regularly spaced array of measurements.         final int size = 100;         final double[] xTab = new double[size];         final double[] yTab = new double[size];         for (int i = 0; i < size; i++) {             xTab[i] = 0.1 * i;             yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian();         }          // shake it         for (int i = 0; i < size; i++) {             int i1 = randomizer.nextInt(size);             int i2 = randomizer.nextInt(size);             double xTmp = xTab[i1];             double yTmp = yTab[i1];             xTab[i1] = xTab[i2];             yTab[i1] = yTab[i2];             xTab[i2] = xTmp;             yTab[i2] = yTmp;         }          // Pass it to the fitter.         final WeightedObservedPoints points = new WeightedObservedPoints();         for (int i = 0; i < size; ++i) {             points.add(1, xTab[i], yTab[i]);         }          final HarmonicCurveFitter fitter = HarmonicCurveFitter.create();         final double[] fitted = fitter.fit(points.toList());         Assert.assertEquals(a, fitted[0], 7.6e-4);         Assert.assertEquals(w, fitted[1], 3.5e-3);         Assert.assertEquals(p, PlaneAngleRadians.normalize(fitted[2], p), 1.5e-2);     }      @Test(expected=MathIllegalStateException.class)     public void testMath844() {         final double[] y = { 0, 1, 2, 3, 2, 1,                              0, -1, -2, -3, -2, -1,                              0, 1, 2, 3, 2, 1,                              0, -1, -2, -3, -2, -1,                              0, 1, 2, 3, 2, 1, 0 };         final List<WeightedObservedPoint> points = new ArrayList<>();         for (int i = 0; i < y.length; i++) {             points.add(new WeightedObservedPoint(1, i, y[i]));         }          // The guesser fails because the function is far from an harmonic         // function: It is a triangular periodic function with amplitude 3         // and period 12, and all sample points are taken at integer abscissae         // so function values all belong to the integer subset {-3, -2, -1, 0,         // 1, 2, 3}.         new HarmonicCurveFitter.ParameterGuesser(points);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting;  import java.util.List;  import org.junit.Assert; import org.junit.Test; import org.apache.commons.numbers.core.Precision;  /**  * Tests {@link WeightedObservedPoints}.  *  */ public class WeightedObservedPointsTest {     @Test     public void testAdd1() {         final WeightedObservedPoints store = new WeightedObservedPoints();          final double x = 1.2;         final double y = 34.56;         final double w = 0.789;          store.add(w, x, y);          Assert.assertTrue(lastElementIsSame(store, new WeightedObservedPoint(w, x, y)));     }      @Test     public void testAdd2() {         final WeightedObservedPoints store = new WeightedObservedPoints();          final double x = 1.2;         final double y = 34.56;         final double w = 0.789;          store.add(new WeightedObservedPoint(w, x, y));          Assert.assertTrue(lastElementIsSame(store, new WeightedObservedPoint(w, x, y)));     }      @Test     public void testAdd3() {         final WeightedObservedPoints store = new WeightedObservedPoints();          final double x = 1.2;         final double y = 34.56;          store.add(x, y);          Assert.assertTrue(lastElementIsSame(store, new WeightedObservedPoint(1, x, y)));     }      @Test     public void testClear() {         final WeightedObservedPoints store = new WeightedObservedPoints();          store.add(new WeightedObservedPoint(1, 2, 3));         store.add(new WeightedObservedPoint(2, -1, -2));         Assert.assertTrue(store.toList().size() == 2);          store.clear();         Assert.assertTrue(store.toList().size() == 0);     }      // Ensure that an instance returned by "toList()" is independent from     // the original container.     @Test     public void testToListCopy() {         final WeightedObservedPoints store = new WeightedObservedPoints();          store.add(new WeightedObservedPoint(1, 2, 3));         store.add(new WeightedObservedPoint(2, -3, -4));          final List<WeightedObservedPoint> list = store.toList();         Assert.assertTrue(list.size() == 2);          // Adding an element to "list" has no impact on "store".         list.add(new WeightedObservedPoint(1.2, 3.4, 5.6));         Assert.assertFalse(list.size() == store.toList().size());          // Clearing "store" has no impact on "list".         store.clear();         Assert.assertFalse(list.size() == 0);     }      /**      * Checks that the contents of the last element is equal to the      * contents of {@code p}.      *      * @param store Container.      * @param point Observation.      * @return {@code true} if both elements have the same contents.      */     private boolean lastElementIsSame(WeightedObservedPoints store,                                       WeightedObservedPoint point) {         final List<WeightedObservedPoint> list = store.toList();         final WeightedObservedPoint lastPoint = list.get(list.size() - 1);          if (!Precision.equals(lastPoint.getX(), point.getX())) {             return false;         }         if (!Precision.equals(lastPoint.getY(), point.getY())) {             return false;         }         if (!Precision.equals(lastPoint.getWeight(), point.getWeight())) {             return false;         }          return true;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting;  import java.util.Random;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.ParametricUnivariateFunction; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.rng.simple.RandomSource; import org.junit.Test;  /**  * Test for class {@link SimpleCurveFitter}.  */ public class SimpleCurveFitterTest {     @Test     public void testPolynomialFit() {         final Random randomizer = new Random(53882150042L);         final ContinuousDistribution.Sampler rng             = new UniformContinuousDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                        64925784253L));          final double[] coeff = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2         final PolynomialFunction f = new PolynomialFunction(coeff);          // Collect data from a known polynomial.         final WeightedObservedPoints obs = new WeightedObservedPoints();         for (int i = 0; i < 100; i++) {             final double x = rng.sample();             obs.add(x, f.value(x) + 0.1 * randomizer.nextGaussian());         }          final ParametricUnivariateFunction function = new PolynomialFunction.Parametric();         // Start fit from initial guesses that are far from the optimal values.         final SimpleCurveFitter fitter             = SimpleCurveFitter.create(function,                                        new double[] { -1e20, 3e15, -5e25 });         final double[] best = fitter.fit(obs.toList());          TestUtils.assertEquals("best != coeff", coeff, best, 2e-2);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting;  import java.util.Random;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link PolynomialCurveFitter}.  */ public class PolynomialCurveFitterTest {     @Test     public void testFit() {         final ContinuousDistribution.Sampler rng             = new UniformContinuousDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                        64925784252L));         final double[] coeff = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2         final PolynomialFunction f = new PolynomialFunction(coeff);          // Collect data from a known polynomial.         final WeightedObservedPoints obs = new WeightedObservedPoints();         for (int i = 0; i < 100; i++) {             final double x = rng.sample();             obs.add(x, f.value(x));         }          // Start fit from initial guesses that are far from the optimal values.         final PolynomialCurveFitter fitter             = PolynomialCurveFitter.create(0).withStartPoint(new double[] { -1e-20, 3e15, -5e25 });         final double[] best = fitter.fit(obs.toList());          TestUtils.assertEquals("best != coeff", coeff, best, 1e-12);     }      @Test     public void testNoError() {         final Random randomizer = new Random(64925784252l);         for (int degree = 1; degree < 10; ++degree) {             final PolynomialFunction p = buildRandomPolynomial(degree, randomizer);             final PolynomialCurveFitter fitter = PolynomialCurveFitter.create(degree);              final WeightedObservedPoints obs = new WeightedObservedPoints();             for (int i = 0; i <= degree; ++i) {                 obs.add(1.0, i, p.value(i));             }              final PolynomialFunction fitted = new PolynomialFunction(fitter.fit(obs.toList()));              for (double x = -1.0; x < 1.0; x += 0.01) {                 final double error = FastMath.abs(p.value(x) - fitted.value(x)) /                     (1.0 + FastMath.abs(p.value(x)));                 Assert.assertEquals(0.0, error, 1.0e-6);             }         }     }      @Test     public void testSmallError() {         final Random randomizer = new Random(53882150042l);         double maxError = 0;         for (int degree = 0; degree < 10; ++degree) {             final PolynomialFunction p = buildRandomPolynomial(degree, randomizer);             final PolynomialCurveFitter fitter = PolynomialCurveFitter.create(degree);              final WeightedObservedPoints obs = new WeightedObservedPoints();             for (double x = -1.0; x < 1.0; x += 0.01) {                 obs.add(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian());             }              final PolynomialFunction fitted = new PolynomialFunction(fitter.fit(obs.toList()));              for (double x = -1.0; x < 1.0; x += 0.01) {                 final double error = FastMath.abs(p.value(x) - fitted.value(x)) /                     (1.0 + FastMath.abs(p.value(x)));                 maxError = FastMath.max(maxError, error);                 Assert.assertTrue(FastMath.abs(error) < 0.1);             }         }         Assert.assertTrue(maxError > 0.01);     }      @Test     public void testRedundantSolvable() {         // Levenberg-Marquardt should handle redundant information gracefully         checkUnsolvableProblem(true);     }      @Test     public void testLargeSample() {         final Random randomizer = new Random(0x5551480dca5b369bl);         double maxError = 0;         for (int degree = 0; degree < 10; ++degree) {             final PolynomialFunction p = buildRandomPolynomial(degree, randomizer);             final PolynomialCurveFitter fitter = PolynomialCurveFitter.create(degree);              final WeightedObservedPoints obs = new WeightedObservedPoints();             for (int i = 0; i < 40000; ++i) {                 final double x = -1.0 + i / 20000.0;                 obs.add(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian());             }              final PolynomialFunction fitted = new PolynomialFunction(fitter.fit(obs.toList()));             for (double x = -1.0; x < 1.0; x += 0.01) {                 final double error = FastMath.abs(p.value(x) - fitted.value(x)) /                     (1.0 + FastMath.abs(p.value(x)));                 maxError = FastMath.max(maxError, error);                 Assert.assertTrue(FastMath.abs(error) < 0.01);             }         }         Assert.assertTrue(maxError > 0.001);     }      private void checkUnsolvableProblem(boolean solvable) {         final Random randomizer = new Random(1248788532l);          for (int degree = 0; degree < 10; ++degree) {             final PolynomialFunction p = buildRandomPolynomial(degree, randomizer);             final PolynomialCurveFitter fitter = PolynomialCurveFitter.create(degree);             final WeightedObservedPoints obs = new WeightedObservedPoints();             // reusing the same point over and over again does not bring             // information, the problem cannot be solved in this case for             // degrees greater than 1 (but one point is sufficient for             // degree 0)             for (double x = -1.0; x < 1.0; x += 0.01) {                 obs.add(1.0, 0.0, p.value(0.0));             }              try {                 fitter.fit(obs.toList());                 Assert.assertTrue(solvable || (degree == 0));             } catch(ConvergenceException e) {                 Assert.assertTrue((! solvable) && (degree > 0));             }         }     }      private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) {         final double[] coefficients = new double[degree + 1];         for (int i = 0; i <= degree; ++i) {             coefficients[i] = randomizer.nextGaussian();         }         return new PolynomialFunction(coefficients);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.fitting;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.TooManyIterationsException; import org.junit.Assert; import org.junit.Test;  /**  * Tests {@link GaussianCurveFitter}.  *  */ public class GaussianCurveFitterTest {     /** Good data. */     protected static final double[][] DATASET1 = new double[][] {         {4.0254623,  531026.0},         {4.02804905, 664002.0},         {4.02934242, 787079.0},         {4.03128248, 984167.0},         {4.03386923, 1294546.0},         {4.03580929, 1560230.0},         {4.03839603, 1887233.0},         {4.0396894,  2113240.0},         {4.04162946, 2375211.0},         {4.04421621, 2687152.0},         {4.04550958, 2862644.0},         {4.04744964, 3078898.0},         {4.05003639, 3327238.0},         {4.05132976, 3461228.0},         {4.05326982, 3580526.0},         {4.05585657, 3576946.0},         {4.05779662, 3439750.0},         {4.06038337, 3220296.0},         {4.06167674, 3070073.0},         {4.0636168,  2877648.0},         {4.06620355, 2595848.0},         {4.06749692, 2390157.0},         {4.06943698, 2175960.0},         {4.07202373, 1895104.0},         {4.0733171,  1687576.0},         {4.07525716, 1447024.0},         {4.0778439,  1130879.0},         {4.07978396, 904900.0},         {4.08237071, 717104.0},         {4.08366408, 620014.0}     };     /** Poor data: right of peak not symmetric with left of peak. */     protected static final double[][] DATASET2 = new double[][] {         {-20.15,   1523.0},         {-19.65,   1566.0},         {-19.15,   1592.0},         {-18.65,   1927.0},         {-18.15,   3089.0},         {-17.65,   6068.0},         {-17.15,  14239.0},         {-16.65,  34124.0},         {-16.15,  64097.0},         {-15.65, 110352.0},         {-15.15, 164742.0},         {-14.65, 209499.0},         {-14.15, 267274.0},         {-13.65, 283290.0},         {-13.15, 275363.0},         {-12.65, 258014.0},         {-12.15, 225000.0},         {-11.65, 200000.0},         {-11.15, 190000.0},         {-10.65, 185000.0},         {-10.15, 180000.0},         { -9.65, 179000.0},         { -9.15, 178000.0},         { -8.65, 177000.0},         { -8.15, 176000.0},         { -7.65, 175000.0},         { -7.15, 174000.0},         { -6.65, 173000.0},         { -6.15, 172000.0},         { -5.65, 171000.0},         { -5.15, 170000.0}     };     /** Poor data: long tails. */     protected static final double[][] DATASET3 = new double[][] {         {-90.15,   1513.0},         {-80.15,   1514.0},         {-70.15,   1513.0},         {-60.15,   1514.0},         {-50.15,   1513.0},         {-40.15,   1514.0},         {-30.15,   1513.0},         {-20.15,   1523.0},         {-19.65,   1566.0},         {-19.15,   1592.0},         {-18.65,   1927.0},         {-18.15,   3089.0},         {-17.65,   6068.0},         {-17.15,  14239.0},         {-16.65,  34124.0},         {-16.15,  64097.0},         {-15.65, 110352.0},         {-15.15, 164742.0},         {-14.65, 209499.0},         {-14.15, 267274.0},         {-13.65, 283290.0},         {-13.15, 275363.0},         {-12.65, 258014.0},         {-12.15, 214073.0},         {-11.65, 182244.0},         {-11.15, 136419.0},         {-10.65,  97823.0},         {-10.15,  58930.0},         { -9.65,  35404.0},         { -9.15,  16120.0},         { -8.65,   9823.0},         { -8.15,   5064.0},         { -7.65,   2575.0},         { -7.15,   1642.0},         { -6.65,   1101.0},         { -6.15,    812.0},         { -5.65,    690.0},         { -5.15,    565.0},         {  5.15,    564.0},         { 15.15,    565.0},         { 25.15,    564.0},         { 35.15,    565.0},         { 45.15,    564.0},         { 55.15,    565.0},         { 65.15,    564.0},         { 75.15,    565.0}     };     /** Poor data: right of peak is missing. */     protected static final double[][] DATASET4 = new double[][] {         {-20.15,   1523.0},         {-19.65,   1566.0},         {-19.15,   1592.0},         {-18.65,   1927.0},         {-18.15,   3089.0},         {-17.65,   6068.0},         {-17.15,  14239.0},         {-16.65,  34124.0},         {-16.15,  64097.0},         {-15.65, 110352.0},         {-15.15, 164742.0},         {-14.65, 209499.0},         {-14.15, 267274.0},         {-13.65, 283290.0}     };     /** Good data, but few points. */     protected static final double[][] DATASET5 = new double[][] {         {4.0254623,  531026.0},         {4.03128248, 984167.0},         {4.03839603, 1887233.0},         {4.04421621, 2687152.0},         {4.05132976, 3461228.0},         {4.05326982, 3580526.0},         {4.05779662, 3439750.0},         {4.0636168,  2877648.0},         {4.06943698, 2175960.0},         {4.07525716, 1447024.0},         {4.08237071, 717104.0},         {4.08366408, 620014.0}     };      /**      * Basic.      */     @Test     public void testFit01() {         GaussianCurveFitter fitter = GaussianCurveFitter.create();         double[] parameters = fitter.fit(createDataset(DATASET1).toList());          Assert.assertEquals(3496978.1837704973, parameters[0], 1e-7);         Assert.assertEquals(4.054933085999146, parameters[1], 1e-16);         Assert.assertEquals(0.015039355620304326, parameters[2], 1e-15);     }      @Test     public void testDataset1LargeXShift() {         final GaussianCurveFitter fitter = GaussianCurveFitter.create();         final double xShift = 1e8;         final double[] parameters = fitter.fit(createDataset(DATASET1, xShift, 0).toList());          Assert.assertEquals(1, parameters[0] / 3496978.1837704973, 1e-2);         Assert.assertEquals(1, parameters[1] / (xShift + 4.054933085999146), 1e-6);         Assert.assertEquals(1, parameters[2] / 0.015039355620304326, 1e-2);     }      @Test     public void testWithMaxIterations1() {         final int maxIter = 20;         final double[] init = { 3.5e6, 4.2, 0.1 };          GaussianCurveFitter fitter = GaussianCurveFitter.create();         double[] parameters = fitter             .withMaxIterations(maxIter)             .withStartPoint(init)             .fit(createDataset(DATASET1).toList());          Assert.assertEquals(3496978.1837704973, parameters[0], 1e-2);         Assert.assertEquals(4.054933085999146, parameters[1], 1e-4);         Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4);     }      @Test(expected=TooManyIterationsException.class)     public void testWithMaxIterations2() {         final int maxIter = 1; // Too few iterations.         final double[] init = { 3.5e6, 4.2, 0.1 };          GaussianCurveFitter fitter = GaussianCurveFitter.create();         fitter.withMaxIterations(maxIter)               .withStartPoint(init)               .fit(createDataset(DATASET1).toList());     }      @Test     public void testWithStartPoint() {         final double[] init = { 3.5e6, 4.2, 0.1 };          GaussianCurveFitter fitter = GaussianCurveFitter.create();         double[] parameters = fitter             .withStartPoint(init)             .fit(createDataset(DATASET1).toList());          Assert.assertEquals(3496978.1837704973, parameters[0], 1e-2);         Assert.assertEquals(4.054933085999146, parameters[1], 1e-4);         Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4);     }      /**      * Zero points is not enough observed points.      */     @Test(expected=MathIllegalArgumentException.class)     public void testFit02() {         GaussianCurveFitter.create().fit(new WeightedObservedPoints().toList());     }      /**      * Two points is not enough observed points.      */     @Test(expected=MathIllegalArgumentException.class)     public void testFit03() {         GaussianCurveFitter fitter = GaussianCurveFitter.create();         fitter.fit(createDataset(new double[][] {                     {4.0254623,  531026.0},                     {4.02804905, 664002.0}                 }).toList());     }      /**      * Poor data: right of peak not symmetric with left of peak.      */     @Test     public void testFit04() {         GaussianCurveFitter fitter = GaussianCurveFitter.create();         double[] parameters = fitter.fit(createDataset(DATASET2).toList());          Assert.assertEquals(233003.2967252038, parameters[0], 1e-4);         Assert.assertEquals(-10.654887521095983, parameters[1], 1e-4);         Assert.assertEquals(4.335937353196641, parameters[2], 1e-4);     }      /**      * Poor data: long tails.      */     @Test     public void testFit05() {         GaussianCurveFitter fitter = GaussianCurveFitter.create();         double[] parameters = fitter.fit(createDataset(DATASET3).toList());          Assert.assertEquals(283863.81929180305, parameters[0], 1e-4);         Assert.assertEquals(-13.29641995105174, parameters[1], 1e-4);         Assert.assertEquals(1.7297330293549908, parameters[2], 1e-4);     }      /**      * Poor data: right of peak is missing.      */     @Test     public void testFit06() {         GaussianCurveFitter fitter = GaussianCurveFitter.create();         double[] parameters = fitter.fit(createDataset(DATASET4).toList());          Assert.assertEquals(285250.66754309234, parameters[0], 1e-4);         Assert.assertEquals(-13.528375695228455, parameters[1], 1e-4);         Assert.assertEquals(1.5204344894331614, parameters[2], 1e-4);     }      /**      * Basic with smaller dataset.      */     @Test     public void testFit07() {         GaussianCurveFitter fitter = GaussianCurveFitter.create();         double[] parameters = fitter.fit(createDataset(DATASET5).toList());          Assert.assertEquals(3514384.729342235, parameters[0], 1e-4);         Assert.assertEquals(4.054970307455625, parameters[1], 1e-4);         Assert.assertEquals(0.015029412832160017, parameters[2], 1e-4);     }      @Test     public void testMath519() {         // The optimizer will try negative sigma values but "GaussianCurveFitter"         // will catch the raised exceptions and return NaN values instead.          final double[] data = {             1.1143831578403364E-29,             4.95281403484594E-28,             1.1171347211930288E-26,             1.7044813962636277E-25,             1.9784716574832164E-24,             1.8630236407866774E-23,             1.4820532905097742E-22,             1.0241963854632831E-21,             6.275077366673128E-21,             3.461808994532493E-20,             1.7407124684715706E-19,             8.056687953553974E-19,             3.460193945992071E-18,             1.3883326374011525E-17,             5.233894983671116E-17,             1.8630791465263745E-16,             6.288759227922111E-16,             2.0204433920597856E-15,             6.198768938576155E-15,             1.821419346860626E-14,             5.139176445538471E-14,             1.3956427429045787E-13,             3.655705706448139E-13,             9.253753324779779E-13,             2.267636001476696E-12,             5.3880460095836855E-12,             1.2431632654852931E-11         };          final WeightedObservedPoints obs = new WeightedObservedPoints();         for (int i = 0; i < data.length; i++) {             obs.add(i, data[i]);         }         final double[] p = GaussianCurveFitter.create().fit(obs.toList());          Assert.assertEquals(53.1572792, p[1], 1e-7);         Assert.assertEquals(5.75214622, p[2], 1e-8);     }      @Test     public void testMath798() {         // When the data points are not commented out below, the fit stalls.         // This is expected however, since the whole dataset hardly looks like         // a Gaussian.         // When commented out, the fit proceeds fine.          final WeightedObservedPoints obs = new WeightedObservedPoints();          obs.add(0.23, 395.0);         //obs.add(0.68, 0.0);         obs.add(1.14, 376.0);         //obs.add(1.59, 0.0);         obs.add(2.05, 163.0);         //obs.add(2.50, 0.0);         obs.add(2.95, 49.0);         //obs.add(3.41, 0.0);         obs.add(3.86, 16.0);         //obs.add(4.32, 0.0);         obs.add(4.77, 1.0);          final double[] p = GaussianCurveFitter.create().fit(obs.toList());          // Values are copied from a previous run of this test.         Assert.assertEquals(420.8397296167364, p[0], 1e-12);         Assert.assertEquals(0.603770729862231, p[1], 1e-15);         Assert.assertEquals(1.0786447936766612, p[2], 1e-14);     }      /**      * Adds the specified points to specified <code>GaussianCurveFitter</code>      * instance.      *      * @param points Data points where first dimension is a point index and      *        second dimension is an array of length two representing the point      *        with the first value corresponding to X and the second value      *        corresponding to Y.      * @param xShift Offset added to the abscissae.      * @param yShift Offset added to the ordinates.      * @return the collection of observed points.      */     private static WeightedObservedPoints createDataset(double[][] points,                                                         double xShift,                                                         double yShift) {         final WeightedObservedPoints obs = new WeightedObservedPoints();         for (int i = 0; i < points.length; i++) {             obs.add(points[i][0] + xShift, points[i][1] + yShift);         }         return obs;     }      /**      * Adds the specified points to specified <code>GaussianCurveFitter</code>      * instance.      *      * @param points Data points where first dimension is a point index and      *        second dimension is an array of length two representing the point      *        with the first value corresponding to X and the second value      *        corresponding to Y.      * @return the collection of observed points.      */     private static WeightedObservedPoints createDataset(double[][] points) {         return createDataset(points, 0, 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.field.linalg;  import org.junit.Test; import org.junit.Assert; import org.apache.commons.numbers.fraction.Fraction; import org.apache.commons.numbers.field.FractionField; import org.apache.commons.math4.linear.SingularMatrixException; import org.apache.commons.math4.exception.DimensionMismatchException;  public class FieldLUDecompositionTest {     private final int[][] testData = {         { 1, 2, 3 },         { 2, 5, 3 },         { 1, 0, 8 }     };     private final int[][] testDataMinus = {         { -1, -2, -3 },         { -2, -5, -3 },         { -1, 0, -8 }     };     private final int[][] luData = {         { 2, 3, 3 },         { 2, 3, 7 },         { 6, 6, 8 }     };     private final int[][] luData2 = {         { 2, 3, 3 },         { 0, 5, 7 },         { 6, 9, 8 }     };      // singular matrices     private int[][] singular = {         { 2, 3 },         { 2, 3 }     };     private final int[][] bigSingular = {         { 1, 2,   3,    4 },         { 2, 5,   3,    4 },         { 7, 3, 256, 1930 },         { 3, 7,   6,    8 }     }; // 4th row = 1st + 2nd      @Test     public void testDimensions() {         FieldDenseMatrix<Fraction> matrix = create(testData);         FieldLUDecomposition<Fraction> LU = FieldLUDecomposition.of(matrix);         Assert.assertEquals(testData.length, LU.getL().getRowDimension());         Assert.assertEquals(testData.length, LU.getU().getRowDimension());         Assert.assertEquals(testData.length, LU.getP().getRowDimension());     }      @Test     public void testPAEqualLU() {         FieldDenseMatrix<Fraction> matrix = create(testData);         FieldLUDecomposition<Fraction> lu = FieldLUDecomposition.of(matrix);         FieldDenseMatrix<Fraction> l = lu.getL();         FieldDenseMatrix<Fraction> u = lu.getU();         FieldDenseMatrix<Fraction> p = lu.getP();         Assert.assertEquals(p.multiply(matrix), l.multiply(u));          matrix = create(testDataMinus);         lu = FieldLUDecomposition.of(matrix);         l = lu.getL();         u = lu.getU();         p = lu.getP();         Assert.assertEquals(p.multiply(matrix), l.multiply(u));          matrix = FieldDenseMatrix.identity(FractionField.get(), 17);         lu = FieldLUDecomposition.of(matrix);         l = lu.getL();         u = lu.getU();         p = lu.getP();         Assert.assertEquals(p.multiply(matrix), l.multiply(u));     }      /* L is lower triangular with unit diagonal */     @Test     public void testLLowerTriangular() {         FieldDenseMatrix<Fraction> matrix = create(testData);         FieldDenseMatrix<Fraction> l = FieldLUDecomposition.of(matrix).getL();         for (int i = 0; i < l.getRowDimension(); i++) {             Assert.assertEquals(Fraction.ONE, l.get(i, i));             for (int j = i + 1; j < l.getColumnDimension(); j++) {                 Assert.assertEquals(Fraction.ZERO, l.get(i, j));             }         }     }      /* U is upper triangular */     @Test     public void testUUpperTriangular() {         FieldDenseMatrix<Fraction> matrix = create(testData);         FieldDenseMatrix<Fraction> u = FieldLUDecomposition.of(matrix).getU();         for (int i = 0; i < u.getRowDimension(); i++) {             for (int j = 0; j < i; j++) {                 Assert.assertEquals(Fraction.ZERO, u.get(i, j));             }         }     }      /* P is a permutation matrix */     @Test     public void testPPermutation() {         FieldDenseMatrix<Fraction> matrix = create(testData);         FieldDenseMatrix<Fraction> p = FieldLUDecomposition.of(matrix).getP();          FieldDenseMatrix<Fraction> ppT = p.multiply(p.transpose());         FieldDenseMatrix<Fraction> id = FieldDenseMatrix.identity(FractionField.get(),                                                                   p.getRowDimension());         Assert.assertEquals(id, ppT);          for (int i = 0; i < p.getRowDimension(); i++) {             int zeroCount = 0;             int oneCount = 0;             int otherCount = 0;             for (int j = 0; j < p.getColumnDimension(); j++) {                 final Fraction e = p.get(i, j);                 if (e.equals(Fraction.ZERO)) {                     ++zeroCount;                 } else if (e.equals(Fraction.ONE)) {                     ++oneCount;                 } else {                     ++otherCount;                 }             }             Assert.assertEquals(p.getRowDimension() - 1, zeroCount);             Assert.assertEquals(1, oneCount);             Assert.assertEquals(0, otherCount);         }          for (int j = 0; j < p.getRowDimension(); j++) {             int zeroCount = 0;             int oneCount = 0;             int otherCount = 0;             for (int i = 0; i < p.getColumnDimension(); i++) {                 final Fraction e = p.get(i, j);                 if (e.equals(Fraction.ZERO)) {                     ++zeroCount;                 } else if (e.equals(Fraction.ONE)) {                     ++oneCount;                 } else {                     ++otherCount;                 }             }             Assert.assertEquals(p.getRowDimension() - 1, zeroCount);             Assert.assertEquals(1, oneCount);             Assert.assertEquals(0, otherCount);         }     }      @Test     public void testIsSingular1() {         FieldLUDecomposition<Fraction> lu = FieldLUDecomposition.of(create(testData));         Assert.assertFalse(lu.isSingular());         lu.getSolver();     }     @Test(expected=SingularMatrixException.class)     public void testIsSingular2() {         FieldLUDecomposition<Fraction> lu = FieldLUDecomposition.of(create(singular));         Assert.assertTrue(lu.isSingular());         lu.getSolver();     }     @Test(expected=SingularMatrixException.class)     public void testIsSingular3() {         FieldLUDecomposition<Fraction> lu = FieldLUDecomposition.of(create(bigSingular));         Assert.assertTrue(lu.isSingular());         lu.getSolver();     }      @Test     public void testMatricesValues1() {         FieldLUDecomposition<Fraction> lu = FieldLUDecomposition.of(create(testData));         FieldDenseMatrix<Fraction> lRef = create(new int[][] {                 { 1, 0, 0 },                 { 2, 1, 0 },                 { 1, -2, 1 }             });         FieldDenseMatrix<Fraction> uRef = create(new int[][] {                 { 1,  2, 3 },                 { 0, 1, -3 },                 { 0,  0, -1 }             });         FieldDenseMatrix<Fraction> pRef = create(new int[][] {                 { 1, 0, 0 },                 { 0, 1, 0 },                 { 0, 0, 1 }             });         int[] pivotRef = { 0, 1, 2 };          // check values against known references         FieldDenseMatrix<Fraction> l = lu.getL();         Assert.assertEquals(lRef, l);         FieldDenseMatrix<Fraction> u = lu.getU();         Assert.assertEquals(uRef, u);         FieldDenseMatrix<Fraction> p = lu.getP();         Assert.assertEquals(pRef, p);         int[] pivot = lu.getPivot();         for (int i = 0; i < pivotRef.length; ++i) {             Assert.assertEquals(pivotRef[i], pivot[i]);         }     }      @Test     public void testMatricesValues2() {         final FieldLUDecomposition<Fraction> lu = FieldLUDecomposition.of(create(luData));         final FieldDenseMatrix<Fraction> lRef = create(new int[][] {                 { 1, 0, 0 },                 { 3, 1, 0 },                 { 1, 0, 1 }             });         final FieldDenseMatrix<Fraction> uRef = create(new int[][] {                 { 2, 3, 3 },                 { 0, -3, -1 },                 { 0, 0, 4 }             });         final FieldDenseMatrix<Fraction> pRef = create(new int[][] {                 { 1, 0, 0 },                 { 0, 0, 1 },                 { 0, 1, 0 }             });         int[] pivotRef = { 0, 2, 1 };          // check values against known references         final FieldDenseMatrix<Fraction> l = lu.getL();         Assert.assertEquals(lRef, l);         final FieldDenseMatrix<Fraction> u = lu.getU();         Assert.assertEquals(uRef, u);         final FieldDenseMatrix<Fraction> p = lu.getP();         Assert.assertEquals(pRef, p);         int[] pivot = lu.getPivot();         for (int i = 0; i < pivotRef.length; i++) {             Assert.assertEquals(pivotRef[i], pivot[i]);         }     }      @Test(expected=DimensionMismatchException.class)     public void testSolveDimensionErrors() {         FieldLUDecomposition             .of(create(testData))             .getSolver()             .solve(create(new int[2][2]));     }      @Test     public void testSolve() {         final FieldDecompositionSolver<Fraction> solver = FieldLUDecomposition             .of(create(testData))             .getSolver();         final FieldDenseMatrix<Fraction> b = create(new int[][] {                 { 1, 0 },                 { 2, -5 },                 { 3, 1 }             });         final FieldDenseMatrix<Fraction> xRef = create(new int[][] {                 { 19, -71 },                 { -6, 22 },                 { -2, 9 }             });          final FieldDenseMatrix<Fraction> x = solver.solve(b);         for (int i = 0; i < x.getRowDimension(); i++){             for (int j = 0; j < x.getColumnDimension(); j++){                 Assert.assertEquals("(" + i + ", " + j + ")",                                     xRef.get(i, j), x.get(i, j));             }         }     }      @Test     public void testDeterminant() {         Assert.assertEquals(-1, determinant(testData), 1e-15);         Assert.assertEquals(24, determinant(luData), 1e-14);         Assert.assertEquals(-10, determinant(luData2), 1e-14);         Assert.assertEquals(0, determinant(singular), 1e-15);         Assert.assertEquals(0, determinant(bigSingular), 1e-15);     }      private static double determinant(int[][] data) {         return FieldLUDecomposition.of(create(data)).getDeterminant().doubleValue();     }      private static FieldDenseMatrix<Fraction> create(final int[][] data) {         final int numRows = data.length;         final int numCols = data[0].length;         final FieldDenseMatrix<Fraction> m = FieldDenseMatrix             .create(FractionField.get(), numRows, numCols);          for (int i = 0; i < numRows; i++) {             for (int j = 0; j < numCols; j++) {                 m.set(i, j, Fraction.of(data[i][j], 1));             }         }          return m;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.field.linalg;  import org.junit.Assert; import org.junit.Test; import org.apache.commons.numbers.field.FP64; import org.apache.commons.numbers.field.FP64Field; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.util.Pair;  /**  * Tests for {@link FieldDenseMatrix} (using {@link FP64} as field elements).  */ public class FP64FieldDenseMatrixTest {     @Test     public void testGetRowDimension() {         final int r = 6;         final int c = 9;         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), r, c);         Assert.assertEquals(r, a.getRowDimension());     }      @Test     public void testGetColumnDimension() {         final int r = 6;         final int c = 9;         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), r, c);         Assert.assertEquals(c, a.getColumnDimension());     }      @Test     public void testSetGet() {         final int r = 17;         final int c = 20;         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), r, c);          int count = 0;         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 a.set(i, j, FP64.of(count++));             }         }         Assert.assertEquals(r * c, count);          count = 0;         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 Assert.assertEquals((double) count++,                                     a.get(i, j).doubleValue(),                                     0d);             }         }     }      @Test     public void testAdd() {         final int r = 5;         final int c = 3;         final double scale = 1e3;         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p1 = createRandom(r, c, scale);         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p2 = createRandom(r, c, scale);          assertEquals(p1.getFirst().add(p2.getFirst()),                      p1.getSecond().add(p2.getSecond()),                      0d);     }      @Test     public void testSubtract() {         final int r = 2;         final int c = 6;         final double scale = 1e3;         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p1 = createRandom(r, c, scale);         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p2 = createRandom(r, c, scale);          assertEquals(p1.getFirst().subtract(p2.getFirst()),                      p1.getSecond().subtract(p2.getSecond()),                      0d);     }      @Test     public void testMultiply() {         final int r = 7;         final int c1 = 4;         final int c2 = 5;         final double scale = 1e2;         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p1 = createRandom(r, c1, scale);         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p2 = createRandom(c1, c2, scale);          assertEquals(p1.getFirst().multiply(p2.getFirst()),                      p1.getSecond().multiply(p2.getSecond()),                      0d);     }      @Test     public void testNegate() {         final int dim = 13;         final double scale = 1;         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p = createRandom(dim, dim, scale);          assertEquals(p.getFirst().negate(),                      p.getSecond().scalarMultiply(-1),                      0d);     }      @Test     public void testPowZero() {         final int dim = 5;         final double scale = 1e100;         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p = createRandom(dim, dim, scale);          final int exp = 0;         assertEquals(p.getFirst().pow(exp),                      p.getSecond().power(exp),                      0d);     }      @Test     public void testPowOne() {         final int dim = 5;         final double scale = 1e100;         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p = createRandom(dim, dim, scale);          final int exp = 1;         assertEquals(p.getFirst().pow(exp),                      p.getSecond().power(exp),                      0d);     }      @Test     public void testPow() {         final int dim = 5;         final double scale = 1e2;         final Pair<FieldDenseMatrix<FP64>, RealMatrix> p = createRandom(dim, dim, scale);          final int exp = 4;         assertEquals(p.getFirst().pow(exp),                      p.getSecond().power(exp),                      0d);     }      @Test     public void testGetField() {         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), 7, 5);         Assert.assertEquals(FP64Field.get(), a.getField());     }      @Test     public void testEquals() {         // Reference equality.         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), 7, 2);         Assert.assertEquals(a, a);          // Dimension mismatch         final FieldDenseMatrix<FP64> b = FieldDenseMatrix.create(FP64Field.get(), 7, 3);         Assert.assertNotEquals(a, b);         final FieldDenseMatrix<FP64> c = FieldDenseMatrix.create(FP64Field.get(), 6, 2);         Assert.assertNotEquals(a, c);          // Contents.                 final FieldDenseMatrix<FP64> d = FieldDenseMatrix.create(FP64Field.get(), 7, 2);         Assert.assertEquals(a, d); // Unitialized contents.         a.fill(FP64.of(1.23456789));         d.fill(FP64.of(1.23456789));         Assert.assertEquals(a, d); // Initialized contents.         d.set(6, 1, d.get(6, 1).add(FP64.of(1e-15)));         Assert.assertNotEquals(a, d);     }      @Test     public void testCopy() {         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), 7, 3)             .fill(FP64Field.get().one());         final FieldDenseMatrix<FP64> b = a.copy();         Assert.assertEquals(a, b);          b.set(0, 0, FP64Field.get().zero());         Assert.assertNotEquals(a, b);     }      @Test     public void testTranspose() {         final int r = 4;         final int c = 5;         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), r, c);         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 final double j2 = j * j;                 a.set(i, j,                       FP64.of(1.2 * i + 3.4 * j2));             }         }          final FieldDenseMatrix<FP64> b = a.transpose();         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 Assert.assertEquals(a.get(i, j), b.get(j, i));             }         }          Assert.assertEquals(a, b.transpose());     }      @Test     public void testIdentity() {         final int dim = 3;         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.identity(FP64Field.get(), dim);         for (int i = 0; i < dim; i++) {             for (int j = 0; j < dim; j++) {                 if (i == j) {                     Assert.assertEquals(FP64Field.get().one(),                                        a.get(i, j));                 } else {                     Assert.assertEquals(FP64Field.get().zero(),                                         a.get(i, j));                 }             }         }     }      /**      * Compares with result obtained from "Commons Math".      *      * @param a "o.a.c.m.field.linalg" result.      * @param b "o.a.c.m.linear" result.      * @param tol Tolerance.      */     private void assertEquals(FieldDenseMatrix<FP64> a,                               RealMatrix b,                               double tol) {         if (a.getRowDimension() != b.getRowDimension() ||             a.getColumnDimension() != b.getColumnDimension()) {             Assert.fail("Dimension mismatch");          }          for (int i = 0; i < a.getRowDimension(); i++) {             for (int j = 0; j < a.getColumnDimension(); j++) {                 Assert.assertEquals("(" + i + ", " + j + ")",                                     a.get(i, j).doubleValue(),                                     b.getEntry(i, j),                                     tol);             }         }     }      /**      * Creates test matrices with random entries.      *      * @param r Rows.      * @param c Columns.      * @param scale Range of the entries.      * @return a pair of matrices whose entries are in the interval      * {@code [-scale, scale]}.      */     private Pair<FieldDenseMatrix<FP64>, RealMatrix> createRandom(int r,                                                                   int c,                                                                   double scale) {         final FieldDenseMatrix<FP64> a = FieldDenseMatrix.create(FP64Field.get(), r, c);         final RealMatrix b = new Array2DRowRealMatrix(r, c);         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 final double v = scale * (2 * Math.random() - 1);                 a.set(i, j, FP64.of(v));                 b.setEntry(i, j, v);             }         }          return new Pair<>(a, b);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4;  import org.junit.runners.BlockJUnit4ClassRunner; import org.junit.runners.model.FrameworkMethod; import org.junit.runners.model.InitializationError; import org.junit.runners.model.Statement;   /**  * A test runner that retries tests when assertions fail.  */ public class RetryRunner extends BlockJUnit4ClassRunner {     /**      * Simple constructor.      *      * @param testClass Class to test.      * @throws InitializationError if default runner cannot be built.      */     public RetryRunner(final Class<?> testClass)         throws InitializationError {         super(testClass);     }      @Override     public Statement methodInvoker(final FrameworkMethod method,                                    Object test) {         final Statement singleTryStatement = super.methodInvoker(method, test);         return new Statement() {             /**              * Evaluate the statement.              * We attempt several runs for the test, at most MAX_ATTEMPTS.              * if one attempt succeeds, we succeed, if all attempts fail, we              * fail with the reason corresponding to the last attempt              */             @Override             public void evaluate() throws Throwable {                 Throwable failureReason = null;                  final Retry retry = method.getAnnotation(Retry.class);                 if (retry == null) {                     // Do a single test run attempt.                     singleTryStatement.evaluate();                 } else {                     final int numRetries = retry.value();                      for (int i = 0; i < numRetries; ++i) {                         try {                             // Do a single test run attempt.                             singleTryStatement.evaluate();                             // Attempt succeeded, stop evaluation here.                             return;                         } catch (Throwable t) {                             // Attempt failed, store the reason.                             failureReason = t;                         }                     }                      // All attempts failed.                     throw failureReason;                 }             }         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.interval;  import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the AgrestiCoullInterval class.  *  */ public class AgrestiCoullIntervalTest extends BinomialConfidenceIntervalAbstractTest {      @Override     protected BinomialConfidenceInterval createBinomialConfidenceInterval() {         return new AgrestiCoullInterval();     }      @Test     public void testStandardInterval() {         ConfidenceInterval confidenceInterval = createStandardTestInterval();         Assert.assertEquals(0.07993521, confidenceInterval.getLowerBound(), 1E-5);         Assert.assertEquals(0.1243704, confidenceInterval.getUpperBound(), 1E-5);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.interval;  import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the IntervalUtils class.  *  */ public class IntervalUtilsTest {      private final int successes = 50;     private final int trials = 500;     private final double confidenceLevel = 0.9;      // values to test must be exactly the same     private final double eps = 0.0;      @Test     public void testAgrestiCoull() {         checkConfidenceIntervals(new AgrestiCoullInterval().createInterval(trials, successes, confidenceLevel),                                  IntervalUtils.getAgrestiCoullInterval(trials, successes, confidenceLevel));     }      @Test     public void testClopperPearson() {         checkConfidenceIntervals(new ClopperPearsonInterval().createInterval(trials, successes, confidenceLevel),                                  IntervalUtils.getClopperPearsonInterval(trials, successes, confidenceLevel));     }      @Test     public void testNormalApproximation() {         checkConfidenceIntervals(new NormalApproximationInterval().createInterval(trials, successes, confidenceLevel),                                  IntervalUtils.getNormalApproximationInterval(trials, successes, confidenceLevel));     }      @Test     public void testWilsonScore() {         checkConfidenceIntervals(new WilsonScoreInterval().createInterval(trials, successes, confidenceLevel),                                  IntervalUtils.getWilsonScoreInterval(trials, successes, confidenceLevel));     }      private void checkConfidenceIntervals(ConfidenceInterval expected, ConfidenceInterval actual) {         Assert.assertEquals(expected.getLowerBound(), actual.getLowerBound(), eps);         Assert.assertEquals(expected.getUpperBound(), actual.getUpperBound(), eps);         Assert.assertEquals(expected.getConfidenceLevel(), actual.getConfidenceLevel(), eps);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.interval;  import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the ClopperPearsonInterval class.  *  */ public class ClopperPearsonIntervalTest extends BinomialConfidenceIntervalAbstractTest {      @Override     protected BinomialConfidenceInterval createBinomialConfidenceInterval() {         return new ClopperPearsonInterval();     }      @Test     public void testStandardInterval() {         ConfidenceInterval confidenceInterval = createStandardTestInterval();         Assert.assertEquals(0.07873857, confidenceInterval.getLowerBound(), 1E-5);         Assert.assertEquals(0.1248658, confidenceInterval.getUpperBound(), 1E-5);     }      @Test     public void testMath1401() {         ConfidenceInterval interval = new ClopperPearsonInterval().createInterval(1, 1, 0.95);         Assert.assertEquals(0.025, interval.getLowerBound(), 1e-16);         Assert.assertEquals(1, interval.getUpperBound(), 0d);     }      // number of successes = 0, number of trials = N     @Test     public void testCase1() {         // Check correctness against values obtained with the Python statsmodels.stats.proportion.proportion_confint         final int successes = 0;         final int trials = 10;         final double confidenceLevel = 0.95;          // proportion_confint(0,10,method='beta') = (0, 0.3084971078187608)         final ConfidenceInterval expected = new ConfidenceInterval(0,                                                                    0.3084971078187608,                                                                    confidenceLevel);          check(expected, createBinomialConfidenceInterval().createInterval(trials, successes, confidenceLevel));     }      // number of successes = number of trials = N     @Test     public void testCase2() {         // Check correctness against values obtained with the Python statsmodels.stats.proportion.proportion_confint         final int successes = 10;         final int trials = 10;         final double confidenceLevel = 0.95;          // prop.proportion_confint(10,10,method='beta') = (0.6915028921812392, 1)         final ConfidenceInterval expected = new ConfidenceInterval(0.6915028921812392,                                                                    1,                                                                    confidenceLevel);          check(expected, createBinomialConfidenceInterval().createInterval(trials, successes, confidenceLevel));     }      // number of successes = k, number of trials = N, 0 < k < N     @Test     public void testCase3() {         // Check correctness against values obtained with the Python statsmodels.stats.proportion.proportion_confint         final int successes = 3;         final int trials = 10;         final double confidenceLevel = 0.95;          // prop.proportion_confint(3,10,method='beta') = (0.06673951117773447, 0.6524528500599972)         final ConfidenceInterval expected = new ConfidenceInterval(0.06673951117773447,                                                                    0.6524528500599972,                                                                    confidenceLevel);          check(expected, createBinomialConfidenceInterval().createInterval(trials, successes, confidenceLevel));     }      private void check(ConfidenceInterval expected,                        ConfidenceInterval actual) {         final double relTol = 1.0e-6; // Reasonable relative tolerance for floating point comparison         // Compare bounds using a relative tolerance         Assert.assertEquals(expected.getLowerBound(),                             actual.getLowerBound(),                             relTol * (1.0 + Math.abs(expected.getLowerBound())));         Assert.assertEquals(expected.getUpperBound(),                             actual.getUpperBound(),                             relTol * (1.0 + Math.abs(expected.getUpperBound())));         // The confidence level must be exact         Assert.assertEquals(expected.getConfidenceLevel(),                             actual.getConfidenceLevel(),                             0.0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.interval;  import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the NormalApproximationInterval class.  *  */ public class NormalApproximationIntervalTest extends BinomialConfidenceIntervalAbstractTest {      @Override     protected BinomialConfidenceInterval createBinomialConfidenceInterval() {         return new NormalApproximationInterval();     }      @Test     public void testStandardInterval() {         ConfidenceInterval confidenceInterval = createStandardTestInterval();         Assert.assertEquals(0.07793197, confidenceInterval.getLowerBound(), 1E-5);         Assert.assertEquals(0.1220680, confidenceInterval.getUpperBound(), 1E-5);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.interval;  import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the WilsonScoreInterval class.  *  */ public class WilsonScoreIntervalTest extends BinomialConfidenceIntervalAbstractTest {      @Override     protected BinomialConfidenceInterval createBinomialConfidenceInterval() {         return new WilsonScoreInterval();     }      @Test     public void testStandardInterval() {         ConfidenceInterval confidenceInterval = createStandardTestInterval();         Assert.assertEquals(0.08003919, confidenceInterval.getLowerBound(), 1E-5);         Assert.assertEquals(0.1242664, confidenceInterval.getUpperBound(), 1E-5);     }      @Test     public void testMath1421() {         double lo = new WilsonScoreInterval().createInterval(19436, 0, 0.95).getLowerBound();         Assert.assertTrue(lo + " < 0", lo >= 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.interval;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Before; import org.junit.Test;  /**  * Test cases for the BinomialConfidenceInterval implementations.  *  */ public abstract class BinomialConfidenceIntervalAbstractTest {      protected BinomialConfidenceInterval testStatistic;      private final int successes = 50;     private final int trials = 500;     private final double confidenceLevel = 0.9;      protected abstract BinomialConfidenceInterval createBinomialConfidenceInterval();      /**      * Returns the confidence interval for the given statistic with the following values:      *      * <ul>      *  <li>trials: 500</li>      *  <li>successes: 50</li>      *  <li>confidenceLevel: 0.9</li>      * </ul>      * @return the Confidence Interval for the given values      */     protected ConfidenceInterval createStandardTestInterval() {         return testStatistic.createInterval(trials, successes, confidenceLevel);     }      @Before     public void setUp() {         testStatistic = createBinomialConfidenceInterval();     }      @Test(expected = MathIllegalArgumentException.class)     public void testZeroConfidencelevel() {         testStatistic.createInterval(trials, successes, 0d);     }      @Test(expected = MathIllegalArgumentException.class)     public void testOneConfidencelevel() {         testStatistic.createInterval(trials, successes, 1d);     }      @Test(expected = MathIllegalArgumentException.class)     public void testZeroTrials() {         testStatistic.createInterval(0, 0, confidenceLevel);     }      @Test(expected = MathIllegalArgumentException.class)     public void testNegativeSuccesses() {         testStatistic.createInterval(trials, -1, confidenceLevel);     }      @Test(expected = MathIllegalArgumentException.class)     public void testSuccessesExceedingTrials() {         testStatistic.createInterval(trials, trials + 1, confidenceLevel);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.correlation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.stat.descriptive.moment.Variance; import org.junit.Assert; import org.junit.Test;   public class CovarianceTest {      protected final double[] longleyData = new double[] {             60323,83.0,234289,2356,1590,107608,1947,             61122,88.5,259426,2325,1456,108632,1948,             60171,88.2,258054,3682,1616,109773,1949,             61187,89.5,284599,3351,1650,110929,1950,             63221,96.2,328975,2099,3099,112075,1951,             63639,98.1,346999,1932,3594,113270,1952,             64989,99.0,365385,1870,3547,115094,1953,             63761,100.0,363112,3578,3350,116219,1954,             66019,101.2,397469,2904,3048,117388,1955,             67857,104.6,419180,2822,2857,118734,1956,             68169,108.4,442769,2936,2798,120445,1957,             66513,110.8,444546,4681,2637,121950,1958,             68655,112.6,482704,3813,2552,123366,1959,             69564,114.2,502601,3931,2514,125368,1960,             69331,115.7,518173,4806,2572,127852,1961,             70551,116.9,554894,4007,2827,130081,1962         };      protected final double[] swissData = new double[] {             80.2,17.0,15,12,9.96,             83.1,45.1,6,9,84.84,             92.5,39.7,5,5,93.40,             85.8,36.5,12,7,33.77,             76.9,43.5,17,15,5.16,             76.1,35.3,9,7,90.57,             83.8,70.2,16,7,92.85,             92.4,67.8,14,8,97.16,             82.4,53.3,12,7,97.67,             82.9,45.2,16,13,91.38,             87.1,64.5,14,6,98.61,             64.1,62.0,21,12,8.52,             66.9,67.5,14,7,2.27,             68.9,60.7,19,12,4.43,             61.7,69.3,22,5,2.82,             68.3,72.6,18,2,24.20,             71.7,34.0,17,8,3.30,             55.7,19.4,26,28,12.11,             54.3,15.2,31,20,2.15,             65.1,73.0,19,9,2.84,             65.5,59.8,22,10,5.23,             65.0,55.1,14,3,4.52,             56.6,50.9,22,12,15.14,             57.4,54.1,20,6,4.20,             72.5,71.2,12,1,2.40,             74.2,58.1,14,8,5.23,             72.0,63.5,6,3,2.56,             60.5,60.8,16,10,7.72,             58.3,26.8,25,19,18.46,             65.4,49.5,15,8,6.10,             75.5,85.9,3,2,99.71,             69.3,84.9,7,6,99.68,             77.3,89.7,5,2,100.00,             70.5,78.2,12,6,98.96,             79.4,64.9,7,3,98.22,             65.0,75.9,9,9,99.06,             92.2,84.6,3,3,99.46,             79.3,63.1,13,13,96.83,             70.4,38.4,26,12,5.62,             65.7,7.7,29,11,13.79,             72.7,16.7,22,13,11.22,             64.4,17.6,35,32,16.92,             77.6,37.6,15,7,4.97,             67.6,18.7,25,7,8.65,             35.0,1.2,37,53,42.34,             44.7,46.6,16,29,50.43,             42.8,27.7,22,29,58.33         };       /**      * Test Longley dataset against R.      * Data Source: J. Longley (1967) "An Appraisal of Least Squares      * Programs for the Electronic Computer from the Point of View of the User"      * Journal of the American Statistical Association, vol. 62. September,      * pp. 819-841.      *      * Data are from NIST:      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat      */     @Test     public void testLongley() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);         RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();         double[] rData = new double[] {          12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,          1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,          36796.66000000000, 1.164576250000000e+02, 1063604.115416667,          6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,          343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,          56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,          1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,          873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,          1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,          -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,          23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,          4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,          16240.93333333333, 5.092333333333334e+01, 470977.900000000,          2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667         };          TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-9);      }      /**      * Test R Swiss fertility dataset against R.      * Data Source: R datasets package      */     @Test     public void testSwissFertility() {          RealMatrix matrix = createRealMatrix(swissData, 47, 5);          RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();          double[] rData = new double[] {            156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,            100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,            -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,            -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,             241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890          };           TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);     }      /**      * Constant column      */     @Test     public void testConstant() {         double[] noVariance = new double[] {1, 1, 1, 1};         double[] values = new double[] {1, 2, 3, 4};         Assert.assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);         Assert.assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);     }      /**      * One column      */     @Test     public void testOneColumn() {         RealMatrix cov = new Covariance(new double[][] {{1}, {2}}, false).getCovarianceMatrix();         Assert.assertEquals(1, cov.getRowDimension());         Assert.assertEquals(1, cov.getColumnDimension());         Assert.assertEquals(0.25, cov.getEntry(0, 0), 1.0e-15);     }      /**      * Insufficient data      */     @Test     public void testInsufficientData() {         double[] one = new double[] {1};         double[] two = new double[] {2};         try {             new Covariance().covariance(one, two, false);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // Expected         }         try {             new Covariance(new double[][] {{},{}});             Assert.fail("Expecting NotStrictlyPositiveException");         } catch (NotStrictlyPositiveException ex) {             // Expected         }     }      /**      * Verify that diagonal entries are consistent with Variance computation and matrix matches      * column-by-column covariances      */     @Test     public void testConsistency() {         final RealMatrix matrix = createRealMatrix(swissData, 47, 5);         final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();          // Variances on the diagonal         Variance variance = new Variance();         for (int i = 0; i < 5; i++) {             Assert.assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);         }          // Symmetry, column-consistency         Assert.assertEquals(covarianceMatrix.getEntry(2, 3),                 new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14);         Assert.assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);          // All columns same -> all entries = column variance         RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);         for (int i = 0; i < 3; i++) {             repeatedColumns.setColumnMatrix(i, matrix.getColumnMatrix(0));         }         RealMatrix repeatedCovarianceMatrix = new Covariance(repeatedColumns).getCovarianceMatrix();         double columnVariance = variance.evaluate(matrix.getColumn(0));         for (int i = 0; i < 3; i++) {             for (int j = 0; j < 3; j++) {                 Assert.assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);             }         }          // Check bias-correction defaults         double[][] data = matrix.getData();         TestUtils.assertEquals("Covariances",                 covarianceMatrix, new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE);         TestUtils.assertEquals("Covariances",                 covarianceMatrix, new Covariance().computeCovarianceMatrix(data, true),Double.MIN_VALUE);          double[] x = data[0];         double[] y = data[1];         Assert.assertEquals(new Covariance().covariance(x, y),                 new Covariance().covariance(x, y, true), Double.MIN_VALUE);     }      protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {         double[][] matrixData = new double[nRows][nCols];         int ptr = 0;         for (int i = 0; i < nRows; i++) {             System.arraycopy(data, ptr, matrixData[i], 0, nCols);             ptr += nCols;         }         return new Array2DRowRealMatrix(matrixData);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.correlation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.statistics.distribution.TDistribution; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.linear.BlockRealMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   public class PearsonsCorrelationTest {      protected final double[] longleyData = new double[] {             60323,83.0,234289,2356,1590,107608,1947,             61122,88.5,259426,2325,1456,108632,1948,             60171,88.2,258054,3682,1616,109773,1949,             61187,89.5,284599,3351,1650,110929,1950,             63221,96.2,328975,2099,3099,112075,1951,             63639,98.1,346999,1932,3594,113270,1952,             64989,99.0,365385,1870,3547,115094,1953,             63761,100.0,363112,3578,3350,116219,1954,             66019,101.2,397469,2904,3048,117388,1955,             67857,104.6,419180,2822,2857,118734,1956,             68169,108.4,442769,2936,2798,120445,1957,             66513,110.8,444546,4681,2637,121950,1958,             68655,112.6,482704,3813,2552,123366,1959,             69564,114.2,502601,3931,2514,125368,1960,             69331,115.7,518173,4806,2572,127852,1961,             70551,116.9,554894,4007,2827,130081,1962         };      protected final double[] swissData = new double[] {             80.2,17.0,15,12,9.96,             83.1,45.1,6,9,84.84,             92.5,39.7,5,5,93.40,             85.8,36.5,12,7,33.77,             76.9,43.5,17,15,5.16,             76.1,35.3,9,7,90.57,             83.8,70.2,16,7,92.85,             92.4,67.8,14,8,97.16,             82.4,53.3,12,7,97.67,             82.9,45.2,16,13,91.38,             87.1,64.5,14,6,98.61,             64.1,62.0,21,12,8.52,             66.9,67.5,14,7,2.27,             68.9,60.7,19,12,4.43,             61.7,69.3,22,5,2.82,             68.3,72.6,18,2,24.20,             71.7,34.0,17,8,3.30,             55.7,19.4,26,28,12.11,             54.3,15.2,31,20,2.15,             65.1,73.0,19,9,2.84,             65.5,59.8,22,10,5.23,             65.0,55.1,14,3,4.52,             56.6,50.9,22,12,15.14,             57.4,54.1,20,6,4.20,             72.5,71.2,12,1,2.40,             74.2,58.1,14,8,5.23,             72.0,63.5,6,3,2.56,             60.5,60.8,16,10,7.72,             58.3,26.8,25,19,18.46,             65.4,49.5,15,8,6.10,             75.5,85.9,3,2,99.71,             69.3,84.9,7,6,99.68,             77.3,89.7,5,2,100.00,             70.5,78.2,12,6,98.96,             79.4,64.9,7,3,98.22,             65.0,75.9,9,9,99.06,             92.2,84.6,3,3,99.46,             79.3,63.1,13,13,96.83,             70.4,38.4,26,12,5.62,             65.7,7.7,29,11,13.79,             72.7,16.7,22,13,11.22,             64.4,17.6,35,32,16.92,             77.6,37.6,15,7,4.97,             67.6,18.7,25,7,8.65,             35.0,1.2,37,53,42.34,             44.7,46.6,16,29,50.43,             42.8,27.7,22,29,58.33         };       /**      * Test Longley dataset against R.      */     @Test     public void testLongley() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {                 1.000000000000000, 0.9708985250610560, 0.9835516111796693, 0.5024980838759942,                 0.4573073999764817, 0.960390571594376, 0.9713294591921188,                 0.970898525061056, 1.0000000000000000, 0.9915891780247822, 0.6206333925590966,                 0.4647441876006747, 0.979163432977498, 0.9911491900672053,                 0.983551611179669, 0.9915891780247822, 1.0000000000000000, 0.6042609398895580,                 0.4464367918926265, 0.991090069458478, 0.9952734837647849,                 0.502498083875994, 0.6206333925590966, 0.6042609398895580, 1.0000000000000000,                 -0.1774206295018783, 0.686551516365312, 0.6682566045621746,                 0.457307399976482, 0.4647441876006747, 0.4464367918926265, -0.1774206295018783,                 1.0000000000000000, 0.364416267189032, 0.4172451498349454,                 0.960390571594376, 0.9791634329774981, 0.9910900694584777, 0.6865515163653120,                 0.3644162671890320, 1.000000000000000, 0.9939528462329257,                 0.971329459192119, 0.9911491900672053, 0.9952734837647849, 0.6682566045621746,                 0.4172451498349454, 0.993952846232926, 1.0000000000000000         };         TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);          double[] rPvalues = new double[] {                 4.38904690369668e-10,                 8.36353208910623e-12, 7.8159700933611e-14,                 0.0472894097790304, 0.01030636128354301, 0.01316878049026582,                 0.0749178049642416, 0.06971758330341182, 0.0830166169296545, 0.510948586323452,                 3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684,                 3.95834476307755e-10, 1.114663916723657e-13, 1.332267629550188e-15, 0.00466039138541463, 0.1078477071581498, 7.771561172376096e-15         };         RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 7);         fillUpper(rPMatrix, 0d);         TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);     }      /**      * Test R Swiss fertility dataset against R.      */     @Test     public void testSwissFertility() {          RealMatrix matrix = createRealMatrix(swissData, 47, 5);          PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);          RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();          double[] rData = new double[] {                1.0000000000000000, 0.3530791836199747, -0.6458827064572875, -0.6637888570350691,  0.4636847006517939,                  0.3530791836199747, 1.0000000000000000,-0.6865422086171366, -0.6395225189483201, 0.4010950530487398,                 -0.6458827064572875, -0.6865422086171366, 1.0000000000000000, 0.6984152962884830, -0.5727418060641666,                 -0.6637888570350691, -0.6395225189483201, 0.6984152962884830, 1.0000000000000000, -0.1538589170909148,                  0.4636847006517939, 0.4010950530487398, -0.5727418060641666, -0.1538589170909148, 1.0000000000000000          };          TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);           double[] rPvalues = new double[] {                  0.01491720061472623,                  9.45043734069043e-07, 9.95151527133974e-08,                  3.658616965962355e-07, 1.304590105694471e-06, 4.811397236181847e-08,                  0.001028523190118147, 0.005204433539191644, 2.588307925380906e-05, 0.301807756132683          };          RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 5);          fillUpper(rPMatrix, 0d);          TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);     }      /**      * Test p-value near 0. JIRA: MATH-371      */     @Test     public void testPValueNearZero() {         /*          * Create a dataset that has r -> 1, p -> 0 as dimension increases.          * Prior to the fix for MATH-371, p vanished for dimension >= 14.          * Post fix, p-values diminish smoothly, vanishing at dimension = 127.          * Tested value is ~1E-303.          */         int dimension = 120;         double[][] data = new double[dimension][2];         for (int i = 0; i < dimension; i++) {             data[i][0] = i;             data[i][1] = i + 1/((double)i + 1);         }         PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);         Assert.assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);     }       /**      * Constant column      */     @Test     public void testConstant() {         double[] noVariance = new double[] {1, 1, 1, 1};         double[] values = new double[] {1, 2, 3, 4};         Assert.assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));         Assert.assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(values, noVariance)));     }       /**      * Insufficient data      */      @Test     public void testInsufficientData() {         double[] one = new double[] {1};         double[] two = new double[] {2};         try {             new PearsonsCorrelation().correlation(one, two);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // Expected         }         RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});         try {             new PearsonsCorrelation(matrix);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // Expected         }     }      /**      * Verify that direct t-tests using standard error estimates are consistent      * with reported p-values      */     @Test     public void testStdErrorConsistency() {         TDistribution tDistribution = new TDistribution(45);         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         RealMatrix rValues = corrInstance.getCorrelationMatrix();         RealMatrix pValues = corrInstance.getCorrelationPValues();         RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors();         for (int i = 0; i < 5; i++) {             for (int j = 0; j < i; j++) {                 double t = FastMath.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);                 double p = 2 * (1 - tDistribution.cumulativeProbability(t));                 Assert.assertEquals(p, pValues.getEntry(i, j), 10E-15);             }         }     }      /**      * Verify that creating correlation from covariance gives same results as      * direct computation from the original matrix      */     @Test     public void testCovarianceConsistency() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         Covariance covInstance = new Covariance(matrix);         PearsonsCorrelation corrFromCovInstance = new PearsonsCorrelation(covInstance);         TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                 corrFromCovInstance.getCorrelationMatrix(), 10E-15);         TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                 corrFromCovInstance.getCorrelationPValues(), 10E-15);         TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                 corrFromCovInstance.getCorrelationStandardErrors(), 10E-15);          PearsonsCorrelation corrFromCovInstance2 =             new PearsonsCorrelation(covInstance.getCovarianceMatrix(), 16);         TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                 corrFromCovInstance2.getCorrelationMatrix(), 10E-15);         TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                 corrFromCovInstance2.getCorrelationPValues(), 10E-15);         TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                 corrFromCovInstance2.getCorrelationStandardErrors(), 10E-15);     }       @Test     public void testConsistency() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         double[][] data = matrix.getData();         double[] x = matrix.getColumn(0);         double[] y = matrix.getColumn(1);         Assert.assertEquals(new PearsonsCorrelation().correlation(x, y),                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);         TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                 new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);     }      protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {         double[][] matrixData = new double[nRows][nCols];         int ptr = 0;         for (int i = 0; i < nRows; i++) {             System.arraycopy(data, ptr, matrixData[i], 0, nCols);             ptr += nCols;         }         return new BlockRealMatrix(matrixData);     }      protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) {         int ptr = 0;         RealMatrix result = new BlockRealMatrix(dimension, dimension);         for (int i = 1; i < dimension; i++) {             for (int j = 0; j < i; j++) {                 result.setEntry(i, j, data[ptr]);                 ptr++;             }         }         return result;     }      protected void fillUpper(RealMatrix matrix, double diagonalValue) {         int dimension = matrix.getColumnDimension();         for (int i = 0; i < dimension; i++) {             matrix.setEntry(i, i, diagonalValue);             for (int j = i+1; j < dimension; j++) {                 matrix.setEntry(i, j, matrix.getEntry(j, i));             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.correlation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  public class StorelessCovarianceTest {      protected final double[] longleyData = new double[] {             60323,83.0,234289,2356,1590,107608,1947,             61122,88.5,259426,2325,1456,108632,1948,             60171,88.2,258054,3682,1616,109773,1949,             61187,89.5,284599,3351,1650,110929,1950,             63221,96.2,328975,2099,3099,112075,1951,             63639,98.1,346999,1932,3594,113270,1952,             64989,99.0,365385,1870,3547,115094,1953,             63761,100.0,363112,3578,3350,116219,1954,             66019,101.2,397469,2904,3048,117388,1955,             67857,104.6,419180,2822,2857,118734,1956,             68169,108.4,442769,2936,2798,120445,1957,             66513,110.8,444546,4681,2637,121950,1958,             68655,112.6,482704,3813,2552,123366,1959,             69564,114.2,502601,3931,2514,125368,1960,             69331,115.7,518173,4806,2572,127852,1961,             70551,116.9,554894,4007,2827,130081,1962         };      protected final double[] swissData = new double[] {             80.2,17.0,15,12,9.96,             83.1,45.1,6,9,84.84,             92.5,39.7,5,5,93.40,             85.8,36.5,12,7,33.77,             76.9,43.5,17,15,5.16,             76.1,35.3,9,7,90.57,             83.8,70.2,16,7,92.85,             92.4,67.8,14,8,97.16,             82.4,53.3,12,7,97.67,             82.9,45.2,16,13,91.38,             87.1,64.5,14,6,98.61,             64.1,62.0,21,12,8.52,             66.9,67.5,14,7,2.27,             68.9,60.7,19,12,4.43,             61.7,69.3,22,5,2.82,             68.3,72.6,18,2,24.20,             71.7,34.0,17,8,3.30,             55.7,19.4,26,28,12.11,             54.3,15.2,31,20,2.15,             65.1,73.0,19,9,2.84,             65.5,59.8,22,10,5.23,             65.0,55.1,14,3,4.52,             56.6,50.9,22,12,15.14,             57.4,54.1,20,6,4.20,             72.5,71.2,12,1,2.40,             74.2,58.1,14,8,5.23,             72.0,63.5,6,3,2.56,             60.5,60.8,16,10,7.72,             58.3,26.8,25,19,18.46,             65.4,49.5,15,8,6.10,             75.5,85.9,3,2,99.71,             69.3,84.9,7,6,99.68,             77.3,89.7,5,2,100.00,             70.5,78.2,12,6,98.96,             79.4,64.9,7,3,98.22,             65.0,75.9,9,9,99.06,             92.2,84.6,3,3,99.46,             79.3,63.1,13,13,96.83,             70.4,38.4,26,12,5.62,             65.7,7.7,29,11,13.79,             72.7,16.7,22,13,11.22,             64.4,17.6,35,32,16.92,             77.6,37.6,15,7,4.97,             67.6,18.7,25,7,8.65,             35.0,1.2,37,53,42.34,             44.7,46.6,16,29,50.43,             42.8,27.7,22,29,58.33         };      protected final double[][] longleyDataSimple = {         {60323, 83.0},         {61122,88.5},         {60171, 88.2},         {61187, 89.5},         {63221, 96.2},         {63639, 98.1},         {64989, 99.0},         {63761, 100.0},         {66019, 101.2},         {67857, 104.6},         {68169, 108.4},         {66513, 110.8},         {68655, 112.6},         {69564, 114.2},         {69331, 115.7},         {70551, 116.9}     };      @Test     public void testLongleySimpleVar(){         double rCov = 12333921.73333333246;         StorelessBivariateCovariance cov = new StorelessBivariateCovariance();         for(int i=0;i<longleyDataSimple.length;i++){             cov.increment(longleyDataSimple[i][0],longleyDataSimple[i][0]);         }         TestUtils.assertEquals("simple covariance test", rCov, cov.getResult(), 10E-7);     }      @Test     public void testLongleySimpleCov(){         double rCov = 36796.660000;         StorelessBivariateCovariance cov = new StorelessBivariateCovariance();         for(int i=0;i<longleyDataSimple.length;i++){             cov.increment(longleyDataSimple[i][0], longleyDataSimple[i][1]);         }         TestUtils.assertEquals("simple covariance test", rCov, cov.getResult(), 10E-7);     }      /**      * Test Longley dataset against R.      * Data Source: J. Longley (1967) "An Appraisal of Least Squares      * Programs for the Electronic Computer from the Point of View of the User"      * Journal of the American Statistical Association, vol. 62. September,      * pp. 819-841.      *      * Data are from NIST:      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat      */     @Test     public void testLongleyByRow() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);          double[] rData = new double[] {          12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,          1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,          36796.66000000000, 1.164576250000000e+02, 1063604.115416667,          6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,          343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,          56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,          1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,          873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,          1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,          -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,          23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,          4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,          16240.93333333333, 5.092333333333334e+01, 470977.900000000,          2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667         };          StorelessCovariance covMatrix = new StorelessCovariance(7);         for(int i=0;i<matrix.getRowDimension();i++){             covMatrix.increment(matrix.getRow(i));         }          RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix();          TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-7);      }      /**      * Test R Swiss fertility dataset against R.      * Data Source: R datasets package      */     @Test     public void testSwissFertilityByRow() {          RealMatrix matrix = createRealMatrix(swissData, 47, 5);           double[] rData = new double[] {            156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,            100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,            -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,            -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,             241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890          };          StorelessCovariance covMatrix = new StorelessCovariance(5);         for(int i=0;i<matrix.getRowDimension();i++){             covMatrix.increment(matrix.getRow(i));         }          RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix();          TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);     }      /**      * Test symmetry of the covariance matrix      */     @Test     public void testSymmetry() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);          final int dimension = 5;         StorelessCovariance storelessCov = new StorelessCovariance(dimension);         for(int i=0;i<matrix.getRowDimension();i++){             storelessCov.increment(matrix.getRow(i));         }          double[][] covMatrix = storelessCov.getData();         for (int i = 0; i < dimension; i++) {             for (int j = i; j < dimension; j++) {                 Assert.assertEquals(covMatrix[i][j], covMatrix[j][i], 10e-9);             }         }     }      /**      * Test equality of covariance. chk: covariance of two      * samples separately and adds them together. cov: computes      * covariance of the combined sample showing both are equal.      */     @Test     public void testEquivalence() {         int num_sets = 2;         StorelessBivariateCovariance cov = new StorelessBivariateCovariance();// covariance of the superset         StorelessBivariateCovariance chk = new StorelessBivariateCovariance();// check covariance made by appending covariance of subsets          final UniformRandomProvider rand = RandomSource.create(RandomSource.ISAAC, 10L);// Seed can be changed         for (int s = 0; s < num_sets; s++) {// loop through sets of samlpes             StorelessBivariateCovariance covs = new StorelessBivariateCovariance();             for (int i = 0; i < 5; i++) { // loop through individual samlpes.                 double x = rand.nextDouble();                 double y = rand.nextDouble();                 covs.increment(x, y);// add sample to the subset                 cov.increment(x, y);// add sample to the superset             }            chk.append(covs);         }          TestUtils.assertEquals("covariance subset test", chk.getResult(), cov.getResult(), 10E-7);     }      protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {         double[][] matrixData = new double[nRows][nCols];         int ptr = 0;         for (int i = 0; i < nRows; i++) {             System.arraycopy(data, ptr, matrixData[i], 0, nCols);             ptr += nCols;         }         return new Array2DRowRealMatrix(matrixData);     }   }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.correlation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.linear.BlockRealMatrix; import org.apache.commons.math4.linear.MatrixUtils; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.stat.ranking.NaNStrategy; import org.apache.commons.math4.stat.ranking.NaturalRanking; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for Spearman's rank correlation  *  * @since 2.0  */ public class SpearmansRankCorrelationTest extends PearsonsCorrelationTest {      /**      * Test Longley dataset against R.      */     @Override     @Test     public void testLongley() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);         SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {                 1, 0.982352941176471, 0.985294117647059, 0.564705882352941, 0.2264705882352941, 0.976470588235294,                 0.976470588235294, 0.982352941176471, 1, 0.997058823529412, 0.664705882352941, 0.2205882352941176,                 0.997058823529412, 0.997058823529412, 0.985294117647059, 0.997058823529412, 1, 0.638235294117647,                 0.2235294117647059, 0.9941176470588236, 0.9941176470588236, 0.564705882352941, 0.664705882352941,                 0.638235294117647, 1, -0.3411764705882353, 0.685294117647059, 0.685294117647059, 0.2264705882352941,                 0.2205882352941176, 0.2235294117647059, -0.3411764705882353, 1, 0.2264705882352941, 0.2264705882352941,                 0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1,                 0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1         };         TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);     }      /**      * Test R swiss fertility dataset.      */     @Test     public void testSwiss() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {                 1, 0.2426642769364176, -0.660902996352354, -0.443257690360988, 0.4136455623012432,                 0.2426642769364176, 1, -0.598859938748963, -0.650463814145816, 0.2886878090882852,                -0.660902996352354, -0.598859938748963, 1, 0.674603831406147, -0.4750575257171745,                -0.443257690360988, -0.650463814145816, 0.674603831406147, 1, -0.1444163088302244,                 0.4136455623012432, 0.2886878090882852, -0.4750575257171745, -0.1444163088302244, 1         };         TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);     }      /**      * Constant column      */     @Override     @Test     public void testConstant() {         double[] noVariance = new double[] {1, 1, 1, 1};         double[] values = new double[] {1, 2, 3, 4};         Assert.assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));     }      /**      * Insufficient data      */     @Override     @Test     public void testInsufficientData() {         double[] one = new double[] {1};         double[] two = new double[] {2};         try {             new SpearmansCorrelation().correlation(one, two);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // Expected         }         RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});         try {             new SpearmansCorrelation(matrix);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // Expected         }     }      @Override     @Test     public void testConsistency() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);         SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);         double[][] data = matrix.getData();         double[] x = matrix.getColumn(0);         double[] y = matrix.getColumn(1);         Assert.assertEquals(new SpearmansCorrelation().correlation(x, y),                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);         TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                 new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);     }      @Test(expected = MathIllegalArgumentException.class)     public void testMath891Array() {         // NaNStrategy.REMOVED is not supported since 4.0         final double[] xArray = new double[] { Double.NaN, 1.9, 2, 100, 3 };         final double[] yArray = new double[] { 10, 2, 10, Double.NaN, 4 };          NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED);         SpearmansCorrelation spearman = new SpearmansCorrelation(ranking);          Assert.assertEquals(0.5, spearman.correlation(xArray, yArray), Double.MIN_VALUE);     }      @Test(expected = MathIllegalArgumentException.class)     public void testMath891Matrix() {         // NaNStrategy.REMOVED is not supported since 4.0         final double[] xArray = new double[] { Double.NaN, 1.9, 2, 100, 3 };         final double[] yArray = new double[] { 10, 2, 10, Double.NaN, 4 };          RealMatrix matrix = MatrixUtils.createRealMatrix(xArray.length, 2);         for (int i = 0; i < xArray.length; i++) {             matrix.addToEntry(i, 0, xArray[i]);             matrix.addToEntry(i, 1, yArray[i]);         }          // compute correlation         NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED);         SpearmansCorrelation spearman = new SpearmansCorrelation(matrix, ranking);          Assert.assertEquals(0.5, spearman.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);     }      // Not relevant here     @Override     @Test     public void testStdErrorConsistency() {}     @Override     @Test     public void testCovarianceConsistency() {}  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.correlation;  import java.util.Arrays;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.linear.BlockRealMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Test cases for Kendall's Tau rank correlation.  */ public class KendallsCorrelationTest extends PearsonsCorrelationTest {      private KendallsCorrelation correlation;      @Before     public void setUp() {         correlation = new KendallsCorrelation();     }      /**      * Test Longley dataset against R.      */     @Override     @Test     public void testLongley() {         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);         KendallsCorrelation corrInstance = new KendallsCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {                 1, 0.9166666666666666, 0.9333333333333332, 0.3666666666666666, 0.05, 0.8999999999999999,                 0.8999999999999999, 0.9166666666666666, 1, 0.9833333333333333, 0.45, 0.03333333333333333,                 0.9833333333333333, 0.9833333333333333, 0.9333333333333332, 0.9833333333333333, 1,                 0.4333333333333333, 0.05, 0.9666666666666666, 0.9666666666666666, 0.3666666666666666,                 0.45, 0.4333333333333333, 1, -0.2166666666666666, 0.4666666666666666, 0.4666666666666666, 0.05,                 0.03333333333333333, 0.05, -0.2166666666666666, 1, 0.05, 0.05, 0.8999999999999999, 0.9833333333333333,                 0.9666666666666666, 0.4666666666666666, 0.05, 1, 0.9999999999999999, 0.8999999999999999,                 0.9833333333333333, 0.9666666666666666, 0.4666666666666666, 0.05, 0.9999999999999999, 1         };         TestUtils.assertEquals("Kendall's correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);     }      /**      * Test R swiss fertility dataset.      */     @Test     public void testSwiss() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         KendallsCorrelation corrInstance = new KendallsCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {                 1, 0.1795465254708308, -0.4762437404200669, -0.3306111613580587, 0.2453703703703704,                 0.1795465254708308, 1, -0.4505221560842292, -0.4761645631778491, 0.2054604569820847,                 -0.4762437404200669, -0.4505221560842292, 1, 0.528943683925829, -0.3212755391722673,                 -0.3306111613580587, -0.4761645631778491, 0.528943683925829, 1, -0.08479652265379604,                 0.2453703703703704, 0.2054604569820847, -0.3212755391722673, -0.08479652265379604, 1         };         TestUtils.assertEquals("Kendall's correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);     }      @Test     public void testSimpleOrdered() {         final int length = 10;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         for (int i = 0; i < length; i++) {             xArray[i] = i;             yArray[i] = i;         }         Assert.assertEquals(1.0, correlation.correlation(xArray, yArray), Double.MIN_VALUE);     }      @Test     public void testSimpleReversed() {         final int length = 10;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         for (int i = 0; i < length; i++) {             xArray[length - i - 1] = i;             yArray[i] = i;         }         Assert.assertEquals(-1.0, correlation.correlation(xArray, yArray), Double.MIN_VALUE);     }      @Test     public void testSimpleOrderedPowerOf2() {         final int length = 16;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         for (int i = 0; i < length; i++) {             xArray[i] = i;             yArray[i] = i;         }         Assert.assertEquals(1.0, correlation.correlation(xArray, yArray), Double.MIN_VALUE);     }      @Test     public void testSimpleReversedPowerOf2() {         final int length = 16;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         for (int i = 0; i < length; i++) {             xArray[length - i - 1] = i;             yArray[i] = i;         }         Assert.assertEquals(-1.0, correlation.correlation(xArray, yArray), Double.MIN_VALUE);     }      @Test     public void testSimpleJumble() {         //                                     A    B    C    D         final double[] xArray = new double[] {1.0, 2.0, 3.0, 4.0};         final double[] yArray = new double[] {1.0, 3.0, 2.0, 4.0};          // 6 pairs: (A,B) (A,C) (A,D) (B,C) (B,D) (C,D)         // (B,C) is discordant, the other 5 are concordant          Assert.assertEquals((5 - 1) / (double) 6,                 correlation.correlation(xArray, yArray),                 Double.MIN_VALUE);     }      @Test     public void testBalancedJumble() {         //                                     A    B    C    D         final double[] xArray = new double[] {1.0, 2.0, 3.0, 4.0};         final double[] yArray = new double[] {1.0, 4.0, 3.0, 2.0};          // 6 pairs: (A,B) (A,C) (A,D) (B,C) (B,D) (C,D)         // (A,B) (A,C), (A,D) are concordant, the other 3 are discordant          Assert.assertEquals(0.0,                 correlation.correlation(xArray, yArray),                 Double.MIN_VALUE);     }      @Test     public void testOrderedTies() {         final int length = 10;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         for (int i = 0; i < length; i++) {             xArray[i] = i / 2;             yArray[i] = i / 2;         }         // 5 pairs of points that are tied in both values.         // 16 + 12 + 8 + 4 = 40 concordant         // (40 - 0) / Math.sqrt((45 - 5) * (45 - 5)) = 1         Assert.assertEquals(1.0, correlation.correlation(xArray, yArray), Double.MIN_VALUE);     }       @Test     public void testAllTiesInBoth() {         final int length = 10;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         Assert.assertEquals(Double.NaN, correlation.correlation(xArray, yArray), 0);     }      @Test     public void testAllTiesInX() {         final int length = 10;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         for (int i = 0; i < length; i++) {             xArray[i] = i;         }         Assert.assertEquals(Double.NaN, correlation.correlation(xArray, yArray), 0);     }      @Test     public void testAllTiesInY() {         final int length = 10;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         for (int i = 0; i < length; i++) {             yArray[i] = i;         }         Assert.assertEquals(Double.NaN, correlation.correlation(xArray, yArray), 0);     }      @Test     public void testSingleElement() {         final int length = 1;         final double[] xArray = new double[length];         final double[] yArray = new double[length];         Assert.assertEquals(Double.NaN, correlation.correlation(xArray, yArray), 0);     }      @Test     public void testTwoElements() {         final double[] xArray = new double[] {2.0, 1.0};         final double[] yArray = new double[] {1.0, 2.0};         Assert.assertEquals(-1.0, correlation.correlation(xArray, yArray), Double.MIN_VALUE);     }      @Test     public void test2dDoubleArray() {         final double[][] input = new double[][] {                 new double[] {2.0, 1.0, 2.0},                 new double[] {1.0, 2.0, 1.0},                 new double[] {0.0, 0.0, 0.0}         };          final double[][] expected = new double[][] {                 new double[] {1.0, 1.0 / 3.0, 1.0},                 new double[] {1.0 / 3.0, 1.0, 1.0 / 3.0},                 new double[] {1.0, 1.0 / 3.0, 1.0}};          Assert.assertEquals(correlation.computeCorrelationMatrix(input),                 new BlockRealMatrix(expected));      }      @Test     public void testBlockMatrix() {         final double[][] input = new double[][] {                 new double[] {2.0, 1.0, 2.0},                 new double[] {1.0, 2.0, 1.0},                 new double[] {0.0, 0.0, 0.0}         };          final double[][] expected = new double[][] {                 new double[] {1.0, 1.0 / 3.0, 1.0},                 new double[] {1.0 / 3.0, 1.0, 1.0 / 3.0},                 new double[] {1.0, 1.0 / 3.0, 1.0}};          Assert.assertEquals(                 correlation.computeCorrelationMatrix(new BlockRealMatrix(input)),                 new BlockRealMatrix(expected));     }      @Test     public void testLargeArray() {         // test integer overflow detected in MATH-1068         double[] xArray = new double[100000];         Arrays.fill(xArray, 0, 2500, 1.0);          Assert.assertEquals(1.0, correlation.correlation(xArray, xArray), 1e-6);     }      @Test     public void testMath1277() {         // example that led to a correlation coefficient outside of [-1, 1]         // due to a bug reported in MATH-1277         UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_1024_A, 0);         double[] xArray = new double[120000];         double[] yArray = new double[120000];         for (int i = 0; i < xArray.length; ++i) {             xArray[i] =  rng.nextDouble();         }         for (int i = 0; i < yArray.length; ++i) {             yArray[i] =  rng.nextDouble();         }         double coefficient = correlation.correlation(xArray, yArray);         Assert.assertTrue(1.0 >= coefficient && -1.0 <= coefficient);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.ranking;  import org.junit.Assert; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.NotANumberException; import org.junit.Test; import org.junit.Ignore; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource;   /**  * Test cases for NaturalRanking class  *  * @since 2.0  */ public class NaturalRankingTest {      private final double[] exampleData = { 20, 17, 30, 42.3, 17, 50,             Double.NaN, Double.NEGATIVE_INFINITY, 17 };     private final double[] tiesFirst = { 0, 0, 2, 1, 4 };     private final double[] tiesLast = { 4, 4, 1, 0 };     private final double[] multipleNaNs = { 0, 1, Double.NaN, Double.NaN };     private final double[] multipleTies = { 3, 2, 5, 5, 6, 6, 1 };     private final double[] allSame = { 0, 0, 0, 0 };      @Test     public void testDefault() { // Ties averaged, NaNs failed         NaturalRanking ranking = new NaturalRanking();         double[] ranks;          try {             ranks = ranking.rank(exampleData);             Assert.fail("expected NotANumberException due to NaNStrategy.FAILED");         } catch (NotANumberException e) {             // expected         }          ranks = ranking.rank(tiesFirst);         double[] correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesLast);         correctRanks = new double[] { 3.5, 3.5, 2, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);          try {             ranks = ranking.rank(multipleNaNs);             Assert.fail("expected NotANumberException due to NaNStrategy.FAILED");         } catch (NotANumberException e) {             // expected         }          ranks = ranking.rank(multipleTies);         correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(allSame);         correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);     }      @Test     public void testNaNsMaximalTiesMinimum() {         NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL, TiesStrategy.MINIMUM);         double[] ranks = ranking.rank(exampleData);         double[] correctRanks = { 5, 2, 6, 7, 2, 8, 9, 1, 2 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesFirst);         correctRanks = new double[] { 1, 1, 4, 3, 5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesLast);         correctRanks = new double[] { 3, 3, 2, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleNaNs);         correctRanks = new double[] { 1, 2, 3, 3 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleTies);         correctRanks = new double[] { 3, 2, 4, 4, 6, 6, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(allSame);         correctRanks = new double[] { 1, 1, 1, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);     }      @Test     public void testNaNsRemovedTiesSequential() {         NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED,                 TiesStrategy.SEQUENTIAL);         double[] ranks = ranking.rank(exampleData);         double[] correctRanks = { 5, 2, 6, 7, 3, 8, 1, 4 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesFirst);         correctRanks = new double[] { 1, 2, 4, 3, 5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesLast);         correctRanks = new double[] { 3, 4, 2, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleNaNs);         correctRanks = new double[] { 1, 2 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleTies);         correctRanks = new double[] { 3, 2, 4, 5, 6, 7, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(allSame);         correctRanks = new double[] { 1, 2, 3, 4 };         TestUtils.assertEquals(correctRanks, ranks, 0d);     }      @Test     public void testNaNsMinimalTiesMaximum() {         NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,                 TiesStrategy.MAXIMUM);         double[] ranks = ranking.rank(exampleData);         double[] correctRanks = { 6, 5, 7, 8, 5, 9, 2, 2, 5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesFirst);         correctRanks = new double[] { 2, 2, 4, 3, 5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesLast);         correctRanks = new double[] { 4, 4, 2, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleNaNs);         correctRanks = new double[] { 3, 4, 2, 2 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleTies);         correctRanks = new double[] { 3, 2, 5, 5, 7, 7, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(allSame);         correctRanks = new double[] { 4, 4, 4, 4 };         TestUtils.assertEquals(correctRanks, ranks, 0d);     }      @Test     public void testNaNsMinimalTiesAverage() {         NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL);         double[] ranks = ranking.rank(exampleData);         double[] correctRanks = { 6, 4, 7, 8, 4, 9, 1.5, 1.5, 4 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesFirst);         correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesLast);         correctRanks = new double[] { 3.5, 3.5, 2, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleNaNs);         correctRanks = new double[] { 3, 4, 1.5, 1.5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleTies);         correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(allSame);         correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);     }      /*      * Cf. MATH-1361      * XXX To be removed when issue is fixed.      */     @Ignore     @Test     public void testNaNsFixedTiesRandomDEBUG() {         int count = 0;         final long start = 0;         final int num = 10000000;         final long max = start + num;         for (long i = start; i <= max; i++) {             UniformRandomProvider randomGenerator = RandomSource.create(RandomSource.MT, i);             NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,                                                         randomGenerator);             double[] ranks = ranking.rank(exampleData);             double[] correctRanks = { 5, 3, 6, 7, 3, 8, Double.NaN, 1, 2 };             if (!org.apache.commons.math4.util.MathArrays.equalsIncludingNaN(correctRanks, ranks)) continue;              ranks = ranking.rank(tiesFirst);             correctRanks = new double[] { 1, 2, 4, 3, 5 };             if (!org.apache.commons.math4.util.MathArrays.equalsIncludingNaN(correctRanks, ranks)) continue;              ranks = ranking.rank(tiesLast);             correctRanks = new double[] { 3, 3, 2, 1 };             if (!org.apache.commons.math4.util.MathArrays.equalsIncludingNaN(correctRanks, ranks)) continue;              ranks = ranking.rank(multipleNaNs);             correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN };             if (!org.apache.commons.math4.util.MathArrays.equalsIncludingNaN(correctRanks, ranks)) continue;              ranks = ranking.rank(multipleTies);             correctRanks = new double[] { 3, 2, 4, 4, 6, 7, 1 };             if (!org.apache.commons.math4.util.MathArrays.equalsIncludingNaN(correctRanks, ranks)) continue;              ranks = ranking.rank(allSame);             correctRanks = new double[] { 2, 3, 3, 3 };             if (!org.apache.commons.math4.util.MathArrays.equalsIncludingNaN(correctRanks, ranks)) continue;              ++count;             //System.out.println("seed = " + i);             //break;         }         System.out.println("success rate = " + count + " / " + num);     }      @Test     public void testNaNsFixedTiesRandom() {         UniformRandomProvider randomGenerator = RandomSource.create(RandomSource.JDK, 1000L);         NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,                                                     randomGenerator);         double[] ranks = ranking.rank(exampleData);         double[] correctRanks = { 5, 3, 6, 7, 3, 8, Double.NaN, 1, 2 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesFirst);         correctRanks = new double[] { 1, 2, 4, 3, 5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(tiesLast);         correctRanks = new double[] { 3, 3, 2, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleNaNs);         correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(multipleTies);         correctRanks = new double[] { 3, 2, 4, 4, 6, 7, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranks = ranking.rank(allSame);         correctRanks = new double[] { 2, 3, 3, 3 };         TestUtils.assertEquals(correctRanks, ranks, 0d);     }      @Test     public void testNaNsAndInfs() {         double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN,                 Double.NEGATIVE_INFINITY };         NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL);         double[] ranks = ranking.rank(data);         double[] correctRanks = new double[] { 2, 3.5, 3.5, 1 };         TestUtils.assertEquals(correctRanks, ranks, 0d);         ranking = new NaturalRanking(NaNStrategy.MINIMAL);         ranks = ranking.rank(data);         correctRanks = new double[] { 3, 4, 1.5, 1.5 };         TestUtils.assertEquals(correctRanks, ranks, 0d);     }      @Test(expected=NotANumberException.class)     public void testNaNsFailed() {         double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN, Double.NEGATIVE_INFINITY };         NaturalRanking ranking = new NaturalRanking(NaNStrategy.FAILED);         ranking.rank(data);     }      @Test     public void testNoNaNsFailed() {         double[] data = { 1, 2, 3, 4 };         NaturalRanking ranking = new NaturalRanking(NaNStrategy.FAILED);         double[] ranks = ranking.rank(data);         TestUtils.assertEquals(data, ranks, 0d);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.stat.data;  /**  */ public class LewTest extends CertifiedDataAbstractTest {      @Override     protected String getResourceName() {         return "org/apache/commons/math4/stat/data/Lew.txt";     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.stat.data;  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.net.URL; import java.util.HashMap; import java.util.Map;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math4.stat.descriptive.SummaryStatistics; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  */ public abstract class CertifiedDataAbstractTest {      private DescriptiveStatistics descriptives;      private SummaryStatistics summaries;      private Map<String, Double> certifiedValues;      @Before     public void setUp() throws IOException {         descriptives = new DescriptiveStatistics();         summaries = new SummaryStatistics();         certifiedValues = new HashMap<>();          loadData();     }      private void loadData() throws IOException {         BufferedReader in = null;          try {             URL resourceURL = getClass().getClassLoader().getResource(getResourceName());             in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));              String line = in.readLine();             while (line != null) {                  /* this call to StringUtils did little for the                  * following conditional structure                  */                 line = line.trim();                  // not empty line or comment                 if (!("".equals(line) || line.startsWith("#"))) {                     int n = line.indexOf('=');                     if (n == -1) {                         // data value                         double value = Double.parseDouble(line);                         descriptives.addValue(value);                         summaries.addValue(value);                     } else {                         // certified value                         String name = line.substring(0, n).trim();                         String valueString = line.substring(n + 1).trim();                         Double value = Double.valueOf(valueString);                         certifiedValues.put(name, value);                     }                 }                 line = in.readLine();             }         } finally {             if (in != null) {                 in.close();             }         }     }      protected abstract String getResourceName();      protected double getMaximumAbsoluteError() {         return 1.0e-5;     }      @After     public void tearDown() {         descriptives.clear();         descriptives = null;          summaries.clear();         summaries = null;          certifiedValues.clear();         certifiedValues = null;     }      @Test     public void testCertifiedValues() {         for (String name : certifiedValues.keySet()) {             Double expectedValue = certifiedValues.get(name);              Double summariesValue = getProperty(summaries, name);             if (summariesValue != null) {                 TestUtils.assertEquals("summary value for " + name + " is incorrect.",                                        summariesValue.doubleValue(), expectedValue.doubleValue(),                                        getMaximumAbsoluteError());             }              Double descriptivesValue = getProperty(descriptives, name);             if (descriptivesValue != null) {                 TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",                                        descriptivesValue.doubleValue(), expectedValue.doubleValue(),                                        getMaximumAbsoluteError());             }         }     }       protected Double getProperty(Object bean, String name) {         try {             // Get the value of prop             String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1);             Method meth = bean.getClass().getMethod(prop, new Class[0]);             Object property = meth.invoke(bean, new Object[0]);             if (meth.getReturnType().equals(Double.TYPE)) {                 return (Double) property;             } else if (meth.getReturnType().equals(Long.TYPE)) {                 return Double.valueOf(((Long) property).doubleValue());             } else {                 Assert.fail("wrong type: " + meth.getReturnType().getName());             }         } catch (NoSuchMethodException nsme) {             // ignored         } catch (InvocationTargetException ite) {             Assert.fail(ite.getMessage());         } catch (IllegalAccessException iae) {             Assert.fail(iae.getMessage());         }         return null;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.stat.data;  /**  */ public class LotteryTest extends CertifiedDataAbstractTest {      @Override     protected String getResourceName() {         return "org/apache/commons/math4/stat/data/Lottery.txt";     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;  import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for the MannWhitneyUTestImpl class.  *  */  public class MannWhitneyUTestTest {      protected MannWhitneyUTest testStatistic = new MannWhitneyUTest();      @Test     public void testMannWhitneyUSimple() {         /* Target values computed using R version 2.11.1          * x <- c(19, 22, 16, 29, 24)          * y <- c(20, 11, 17, 12)          * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = FALSE, exact = FALSE, correct = FALSE)          * W = 17, p-value = 0.08641          */         final double x[] = {19, 22, 16, 29, 24};         final double y[] = {20, 11, 17, 12};          Assert.assertEquals(17, testStatistic.mannWhitneyU(x, y), 1e-10);         Assert.assertEquals(0.08641, testStatistic.mannWhitneyUTest(x, y), 1e-5);     }       @Test     public void testMannWhitneyUInputValidation() {         /* Samples must be present, i.e. length > 0          */         try {             testStatistic.mannWhitneyUTest(new double[] { }, new double[] { 1.0 });             Assert.fail("x does not contain samples (exact), NoDataException expected");         } catch (NoDataException ex) {             // expected         }          try {             testStatistic.mannWhitneyUTest(new double[] { 1.0 }, new double[] { });             Assert.fail("y does not contain samples (exact), NoDataException expected");         } catch (NoDataException ex) {             // expected         }          /*          * x and y is null          */         try {             testStatistic.mannWhitneyUTest(null, null);             Assert.fail("x and y is null (exact), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.mannWhitneyUTest(null, null);             Assert.fail("x and y is null (asymptotic), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          /*          * x or y is null          */         try {             testStatistic.mannWhitneyUTest(null, new double[] { 1.0 });             Assert.fail("x is null (exact), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.mannWhitneyUTest(new double[] { 1.0 }, null);             Assert.fail("y is null (exact), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testBigDataSet() {         double[] d1 = new double[1500];         double[] d2 = new double[1500];         for (int i = 0; i < 1500; i++) {             d1[i] = 2 * i;             d2[i] = 2 * i + 1;         }         double result = testStatistic.mannWhitneyUTest(d1, d2);         Assert.assertTrue(result > 0.1);     }      @Test     public void testBigDataSetOverflow() {         // MATH-1145         double[] d1 = new double[110000];         double[] d2 = new double[110000];         for (int i = 0; i < 110000; i++) {             d1[i] = i;             d2[i] = i;         }         double result = testStatistic.mannWhitneyUTest(d1, d2);         Assert.assertTrue(result == 1.0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.exception.ZeroException; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for the ChiSquareTestImpl class.  *  */  public class ChiSquareTestTest {      protected ChiSquareTest testStatistic = new ChiSquareTest();      @Test     public void testChiSquare() {          // Target values computed using R version 1.8.1         // Some assembly required ;-)         //      Use sum((obs - exp)^2/exp) for the chi-square statistic and         //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value          long[] observed = {10, 9, 11};         double[] expected = {10, 10, 10};         Assert.assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);         Assert.assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);          long[] observed1 = { 500, 623, 72, 70, 31 };         double[] expected1 = { 485, 541, 82, 61, 37 };         Assert.assertEquals( "chi-square test statistic", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);         Assert.assertEquals("chi-square p-value", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);         Assert.assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.08));         Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.05));          try {             testStatistic.chiSquareTest(expected1, observed1, 95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          long[] tooShortObs = { 0 };         double[] tooShortEx = { 1 };         try {             testStatistic.chiSquare(tooShortEx, tooShortObs);             Assert.fail("arguments too short, DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }          // unmatched arrays         long[] unMatchedObs = { 0, 1, 2, 3 };         double[] unMatchedEx = { 1, 1, 2 };         try {             testStatistic.chiSquare(unMatchedEx, unMatchedObs);             Assert.fail("arrays have different lengths, DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }          // 0 expected count         expected[0] = 0;         try {             testStatistic.chiSquareTest(expected, observed, .01);             Assert.fail("bad expected count, NotStrictlyPositiveException expected");         } catch (NotStrictlyPositiveException ex) {             // expected         }          // negative observed count         expected[0] = 1;         observed[0] = -1;         try {             testStatistic.chiSquareTest(expected, observed, .01);             Assert.fail("bad expected count, NotPositiveException expected");         } catch (NotPositiveException ex) {             // expected         }      }      @Test     public void testChiSquareIndependence() {          // Target values computed using R version 1.8.1          long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};         Assert.assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9);         Assert.assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);         Assert.assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));         Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));          long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };         Assert.assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);         Assert.assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);         Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1));          // ragged input array         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};         try {             testStatistic.chiSquare(counts3);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // expected         }          // insufficient data         long[][] counts4 = {{40, 22, 43}};         try {             testStatistic.chiSquare(counts4);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // expected         }         long[][] counts5 = {{40}, {40}, {30}, {10}};         try {             testStatistic.chiSquare(counts5);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // expected         }          // negative counts         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };         try {             testStatistic.chiSquare(counts6);             Assert.fail("Expecting NotPositiveException");         } catch (NotPositiveException ex) {             // expected         }          // bad alpha         try {             testStatistic.chiSquareTest(counts, 0);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testChiSquareLargeTestStatistic() {         double[] exp = new double[] {             3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,             232921.0, 437665.75         };          long[] obs = new long[] {             2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899         };         org.apache.commons.math4.stat.inference.ChiSquareTest csti =             new org.apache.commons.math4.stat.inference.ChiSquareTest();         double cst = csti.chiSquareTest(exp, obs);         Assert.assertEquals("chi-square p-value", 0.0, cst, 1E-3);         Assert.assertEquals( "chi-square test statistic",                 114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);     }      /** Contingency table containing zeros - PR # 32531 */     @Test     public void testChiSquareZeroCount() {         // Target values computed using R version 1.8.1         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};         Assert.assertEquals( "chi-square test statistic", 9.67444662263,                 testStatistic.chiSquare(counts), 1E-9);         Assert.assertEquals("chi-square p-value", 0.0462835770603,                 testStatistic.chiSquareTest(counts), 1E-9);     }      /** Target values verified using DATAPLOT version 2006.3 */     @Test     public void testChiSquareDataSetsComparisonEqualCounts()         {         long[] observed1 = {10, 12, 12, 10};         long[] observed2 = {5, 15, 14, 10};         Assert.assertEquals("chi-square p value", 0.541096,                 testStatistic.chiSquareTestDataSetsComparison(                 observed1, observed2), 1E-6);         Assert.assertEquals("chi-square test statistic", 2.153846,                 testStatistic.chiSquareDataSetsComparison(                 observed1, observed2), 1E-6);         Assert.assertFalse("chi-square test result",                 testStatistic.chiSquareTestDataSetsComparison(                 observed1, observed2, 0.4));     }      /** Target values verified using DATAPLOT version 2006.3 */     @Test     public void testChiSquareDataSetsComparisonUnEqualCounts()         {         long[] observed1 = {10, 12, 12, 10, 15};         long[] observed2 = {15, 10, 10, 15, 5};         Assert.assertEquals("chi-square p value", 0.124115,                 testStatistic.chiSquareTestDataSetsComparison(                 observed1, observed2), 1E-6);         Assert.assertEquals("chi-square test statistic", 7.232189,                 testStatistic.chiSquareDataSetsComparison(                 observed1, observed2), 1E-6);         Assert.assertTrue("chi-square test result",                 testStatistic.chiSquareTestDataSetsComparison(                 observed1, observed2, 0.13));         Assert.assertFalse("chi-square test result",                 testStatistic.chiSquareTestDataSetsComparison(                 observed1, observed2, 0.12));     }      @Test     public void testChiSquareDataSetsComparisonBadCounts()         {         long[] observed1 = {10, -1, 12, 10, 15};         long[] observed2 = {15, 10, 10, 15, 5};         try {             testStatistic.chiSquareTestDataSetsComparison(                     observed1, observed2);             Assert.fail("Expecting NotPositiveException - negative count");         } catch (NotPositiveException ex) {             // expected         }         long[] observed3 = {10, 0, 12, 10, 15};         long[] observed4 = {15, 0, 10, 15, 5};         try {             testStatistic.chiSquareTestDataSetsComparison(                     observed3, observed4);             Assert.fail("Expecting ZeroException - double 0's");         } catch (ZeroException ex) {             // expected         }         long[] observed5 = {10, 10, 12, 10, 15};         long[] observed6 = {0, 0, 0, 0, 0};         try {             testStatistic.chiSquareTestDataSetsComparison(                     observed5, observed6);             Assert.fail("Expecting ZeroException - vanishing counts");         } catch (ZeroException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NotPositiveException; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the BinomialTest class.  */ public class BinomialTestTest {      protected BinomialTest testStatistic = new BinomialTest();      private static int successes = 51;     private static int trials = 235;     private static double probability = 1.0 / 6.0;      @Test     public void testBinomialTestPValues() {         Assert.assertEquals(0.04375, testStatistic.binomialTest(             trials, successes, probability, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.02654, testStatistic.binomialTest(             trials, successes, probability, AlternativeHypothesis.GREATER_THAN), 1E-4);         Assert.assertEquals(0.982, testStatistic.binomialTest(             trials, successes, probability, AlternativeHypothesis.LESS_THAN), 1E-4);          // for special boundary conditions         Assert.assertEquals(1, testStatistic.binomialTest(             3, 3, 1, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(1, testStatistic.binomialTest(             3, 3, 0.9, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(1, testStatistic.binomialTest(             3, 3, 0.8, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.559, testStatistic.binomialTest(             3, 3, 0.7, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.28, testStatistic.binomialTest(             3, 3, 0.6, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.25, testStatistic.binomialTest(             3, 3, 0.5, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.064, testStatistic.binomialTest(             3, 3, 0.4, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.027, testStatistic.binomialTest(             3, 3, 0.3, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.008, testStatistic.binomialTest(             3, 3, 0.2, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.001, testStatistic.binomialTest(             3, 3, 0.1, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0, testStatistic.binomialTest(             3, 3, 0.0, AlternativeHypothesis.TWO_SIDED), 1E-4);          Assert.assertEquals(0, testStatistic.binomialTest(             3, 0, 1, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.001, testStatistic.binomialTest(             3, 0, 0.9, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.008, testStatistic.binomialTest(             3, 0, 0.8, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.027, testStatistic.binomialTest(             3, 0, 0.7, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.064, testStatistic.binomialTest(             3, 0, 0.6, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.25, testStatistic.binomialTest(             3, 0, 0.5, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.28, testStatistic.binomialTest(             3, 0, 0.4, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(0.559, testStatistic.binomialTest(             3, 0, 0.3, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(1, testStatistic.binomialTest(             3, 0, 0.2, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(1, testStatistic.binomialTest(             3, 0, 0.1, AlternativeHypothesis.TWO_SIDED), 1E-4);         Assert.assertEquals(1, testStatistic.binomialTest(             3, 0, 0.0, AlternativeHypothesis.TWO_SIDED), 1E-4);      }      @Test     public void testBinomialTestExceptions() {         try {             testStatistic.binomialTest(10, -1, 0.5, AlternativeHypothesis.TWO_SIDED);             Assert.fail("Expected not positive exception");         } catch (NotPositiveException e) {             // expected exception;         }          try {             testStatistic.binomialTest(10, 11, 0.5, AlternativeHypothesis.TWO_SIDED);             Assert.fail("Expected illegal argument exception");         } catch (MathIllegalArgumentException e) {             // expected exception;         }         try {             testStatistic.binomialTest(10, 11, 0.5, null);             Assert.fail("Expected illegal argument exception");         } catch (MathIllegalArgumentException e) {             // expected exception;         }     }      @Test     public void testBinomialTestAcceptReject() {         double alpha05 = 0.05;         double alpha01 = 0.01;          Assert.assertTrue(testStatistic.binomialTest(trials, successes, probability, AlternativeHypothesis.TWO_SIDED, alpha05));         Assert.assertTrue(testStatistic.binomialTest(trials, successes, probability, AlternativeHypothesis.GREATER_THAN, alpha05));         Assert.assertFalse(testStatistic.binomialTest(trials, successes, probability, AlternativeHypothesis.LESS_THAN, alpha05));          Assert.assertFalse(testStatistic.binomialTest(trials, successes, probability, AlternativeHypothesis.TWO_SIDED, alpha01));         Assert.assertFalse(testStatistic.binomialTest(trials, successes, probability, AlternativeHypothesis.GREATER_THAN, alpha01));         Assert.assertFalse(testStatistic.binomialTest(trials, successes, probability, AlternativeHypothesis.LESS_THAN, alpha05));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;   import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.stat.descriptive.SummaryStatistics; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Test cases for the TTestImpl class.  *  */ public class TTestTest {      protected TTest testStatistic = new TTest();      private double[] tooShortObs = { 1.0 };     private double[] emptyObs = {};     private SummaryStatistics emptyStats = new SummaryStatistics();    SummaryStatistics tooShortStats = null;      @Before     public void setUp() {         tooShortStats = new SummaryStatistics();         tooShortStats.addValue(0d);     }      @Test     public void testOneSampleT() {         double[] observed =             {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };         double mu = 100.0;         SummaryStatistics sampleStats = null;         sampleStats = new SummaryStatistics();         for (int i = 0; i < observed.length; i++) {             sampleStats.addValue(observed[i]);         }          // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("t statistic",  -2.81976445346,                 testStatistic.t(mu, observed), 10E-10);         Assert.assertEquals("t statistic",  -2.81976445346,                 testStatistic.t(mu, sampleStats), 10E-10);         Assert.assertEquals("p value", 0.0136390585873,                 testStatistic.tTest(mu, observed), 10E-10);         Assert.assertEquals("p value", 0.0136390585873,                 testStatistic.tTest(mu, sampleStats), 10E-10);          try {             testStatistic.t(mu, (double[]) null);             Assert.fail("arguments too short, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.t(mu, (SummaryStatistics) null);             Assert.fail("arguments too short, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.t(mu, emptyObs);             Assert.fail("arguments too short, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             testStatistic.t(mu, emptyStats);             Assert.fail("arguments too short, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             testStatistic.t(mu, tooShortObs);             Assert.fail("insufficient data to compute t statistic, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             testStatistic.tTest(mu, tooShortObs);             Assert.fail("insufficient data to perform t test, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {            // expected         }          try {             testStatistic.t(mu, tooShortStats);             Assert.fail("insufficient data to compute t statistic, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             testStatistic.tTest(mu, tooShortStats);             Assert.fail("insufficient data to perform t test, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }     }      @Test     public void testOneSampleTTest() {         double[] oneSidedP =             {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };         SummaryStatistics oneSidedPStats = new SummaryStatistics();         for (int i = 0; i < oneSidedP.length; i++) {             oneSidedPStats.addValue(oneSidedP[i]);         }         // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("one sample t stat", 3.86485535541,                 testStatistic.t(0d, oneSidedP), 10E-10);         Assert.assertEquals("one sample t stat", 3.86485535541,                 testStatistic.t(0d, oneSidedPStats),1E-10);         Assert.assertEquals("one sample p value", 0.000521637019637,                 testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);         Assert.assertEquals("one sample p value", 0.000521637019637,                 testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);         Assert.assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));         Assert.assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));         Assert.assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));         Assert.assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));          try {             testStatistic.tTest(0d, oneSidedP, 95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          try {             testStatistic.tTest(0d, oneSidedPStats, 95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }      }      @Test     public void testTwoSampleTHeterscedastic() {         double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };         double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };         SummaryStatistics sampleStats1 = new SummaryStatistics();         for (int i = 0; i < sample1.length; i++) {             sampleStats1.addValue(sample1[i]);         }         SummaryStatistics sampleStats2 = new SummaryStatistics();         for (int i = 0; i < sample2.length; i++) {             sampleStats2.addValue(sample2[i]);         }          // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 testStatistic.t(sample1, sample2), 1E-10);         Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 testStatistic.t(sampleStats1, sampleStats2), 1E-10);         Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                 testStatistic.tTest(sample1, sample2), 1E-10);         Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                 testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);         Assert.assertTrue("two sample heteroscedastic t-test reject",                 testStatistic.tTest(sample1, sample2, 0.2));         Assert.assertTrue("two sample heteroscedastic t-test reject",                 testStatistic.tTest(sampleStats1, sampleStats2, 0.2));         Assert.assertTrue("two sample heteroscedastic t-test accept",                 !testStatistic.tTest(sample1, sample2, 0.1));         Assert.assertTrue("two sample heteroscedastic t-test accept",                 !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));          try {             testStatistic.tTest(sample1, sample2, .95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          try {             testStatistic.tTest(sampleStats1, sampleStats2, .95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          try {             testStatistic.tTest(sample1, tooShortObs, .01);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             testStatistic.tTest(sampleStats1, tooShortStats, .01);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             testStatistic.tTest(sample1, tooShortObs);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {            // expected         }          try {             testStatistic.tTest(sampleStats1, tooShortStats);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             testStatistic.t(sample1, tooShortObs);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             testStatistic.t(sampleStats1, tooShortStats);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {            // expected         }     }     @Test     public void testTwoSampleTHomoscedastic() {         double[] sample1 ={2, 4, 6, 8, 10, 97};         double[] sample2 = {4, 6, 8, 10, 16};         SummaryStatistics sampleStats1 = new SummaryStatistics();         for (int i = 0; i < sample1.length; i++) {             sampleStats1.addValue(sample1[i]);         }         SummaryStatistics sampleStats2 = new SummaryStatistics();         for (int i = 0; i < sample2.length; i++) {             sampleStats2.addValue(sample2[i]);         }          // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("two sample homoscedastic t stat", 0.73096310086,               testStatistic.homoscedasticT(sample1, sample2), 10E-11);         Assert.assertEquals("two sample homoscedastic p value", 0.4833963785,                 testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);         Assert.assertTrue("two sample homoscedastic t-test reject",                 testStatistic.homoscedasticTTest(sample1, sample2, 0.49));         Assert.assertTrue("two sample homoscedastic t-test accept",                 !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));     }      @Test     public void testSmallSamples() {         double[] sample1 = {1d, 3d};         double[] sample2 = {4d, 5d};          // Target values computed using R, version 1.8.1 (linux version)         Assert.assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),                 1E-10);         Assert.assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),                 1E-10);     }      @Test     public void testPaired() {         double[] sample1 = {1d, 3d, 5d, 7d};         double[] sample2 = {0d, 6d, 11d, 2d};         double[] sample3 = {5d, 7d, 8d, 10d};          // Target values computed using R, version 1.8.1 (linux version)         Assert.assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);         Assert.assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);         Assert.assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);         Assert.assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));         Assert.assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.stat.descriptive.SummaryStatistics; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for the TestUtils class.  *  */ public class InferenceTestUtilsTest {     @Test     public void testChiSquare() {          // Target values computed using R version 1.8.1         // Some assembly required ;-)         //      Use sum((obs - exp)^2/exp) for the chi-square statistic and         //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value          long[] observed = {10, 9, 11};         double[] expected = {10, 10, 10};         Assert.assertEquals("chi-square statistic", 0.2,  InferenceTestUtils.chiSquare(expected, observed), 10E-12);         Assert.assertEquals("chi-square p-value", 0.904837418036, InferenceTestUtils.chiSquareTest(expected, observed), 1E-10);          long[] observed1 = { 500, 623, 72, 70, 31 };         double[] expected1 = { 485, 541, 82, 61, 37 };         Assert.assertEquals( "chi-square test statistic", 9.023307936427388, InferenceTestUtils.chiSquare(expected1, observed1), 1E-10);         Assert.assertEquals("chi-square p-value", 0.06051952647453607, InferenceTestUtils.chiSquareTest(expected1, observed1), 1E-9);         Assert.assertTrue("chi-square test reject", InferenceTestUtils.chiSquareTest(expected1, observed1, 0.07));         Assert.assertTrue("chi-square test accept", !InferenceTestUtils.chiSquareTest(expected1, observed1, 0.05));          try {             InferenceTestUtils.chiSquareTest(expected1, observed1, 95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          long[] tooShortObs = { 0 };         double[] tooShortEx = { 1 };         try {             InferenceTestUtils.chiSquare(tooShortEx, tooShortObs);             Assert.fail("arguments too short, DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }          // unmatched arrays         long[] unMatchedObs = { 0, 1, 2, 3 };         double[] unMatchedEx = { 1, 1, 2 };         try {             InferenceTestUtils.chiSquare(unMatchedEx, unMatchedObs);             Assert.fail("arrays have different lengths, DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }          // 0 expected count         expected[0] = 0;         try {             InferenceTestUtils.chiSquareTest(expected, observed, .01);             Assert.fail("bad expected count, NotStrictlyPositiveException expected");         } catch (NotStrictlyPositiveException ex) {             // expected         }          // negative observed count         expected[0] = 1;         observed[0] = -1;         try {             InferenceTestUtils.chiSquareTest(expected, observed, .01);             Assert.fail("bad expected count, NotPositiveException expected");         } catch (NotPositiveException ex) {             // expected         }      }      @Test     public void testChiSquareIndependence() {          // Target values computed using R version 1.8.1          long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};         Assert.assertEquals( "chi-square test statistic", 22.709027688, InferenceTestUtils.chiSquare(counts), 1E-9);         Assert.assertEquals("chi-square p-value", 0.000144751460134, InferenceTestUtils.chiSquareTest(counts), 1E-9);         Assert.assertTrue("chi-square test reject", InferenceTestUtils.chiSquareTest(counts, 0.0002));         Assert.assertTrue("chi-square test accept", !InferenceTestUtils.chiSquareTest(counts, 0.0001));          long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };         Assert.assertEquals( "chi-square test statistic", 0.168965517241, InferenceTestUtils.chiSquare(counts2), 1E-9);         Assert.assertEquals("chi-square p-value",0.918987499852, InferenceTestUtils.chiSquareTest(counts2), 1E-9);         Assert.assertTrue("chi-square test accept", !InferenceTestUtils.chiSquareTest(counts2, 0.1));          // ragged input array         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};         try {             InferenceTestUtils.chiSquare(counts3);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // expected         }          // insufficient data         long[][] counts4 = {{40, 22, 43}};         try {             InferenceTestUtils.chiSquare(counts4);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // expected         }         long[][] counts5 = {{40}, {40}, {30}, {10}};         try {             InferenceTestUtils.chiSquare(counts5);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException ex) {             // expected         }          // negative counts         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };         try {             InferenceTestUtils.chiSquare(counts6);             Assert.fail("Expecting NotPositiveException");         } catch (NotPositiveException ex) {             // expected         }          // bad alpha         try {             InferenceTestUtils.chiSquareTest(counts, 0);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testChiSquareLargeTestStatistic() {         double[] exp = new double[] {                 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,                 232921.0, 437665.75         };          long[] obs = new long[] {                 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899         };         org.apache.commons.math4.stat.inference.ChiSquareTest csti =             new org.apache.commons.math4.stat.inference.ChiSquareTest();         double cst = csti.chiSquareTest(exp, obs);         Assert.assertEquals("chi-square p-value", 0.0, cst, 1E-3);         Assert.assertEquals( "chi-square test statistic",                 114875.90421929007, InferenceTestUtils.chiSquare(exp, obs), 1E-9);     }      /** Contingency table containing zeros - PR # 32531 */     @Test     public void testChiSquareZeroCount() {         // Target values computed using R version 1.8.1         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};         Assert.assertEquals( "chi-square test statistic", 9.67444662263,                 InferenceTestUtils.chiSquare(counts), 1E-9);         Assert.assertEquals("chi-square p-value", 0.0462835770603,                 InferenceTestUtils.chiSquareTest(counts), 1E-9);     }      private double[] tooShortObs = { 1.0 };     private double[] emptyObs = {};     private SummaryStatistics emptyStats = new SummaryStatistics();      @Test     public void testOneSampleT() {         double[] observed =             {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };         double mu = 100.0;         SummaryStatistics sampleStats = null;         sampleStats = new SummaryStatistics();         for (int i = 0; i < observed.length; i++) {             sampleStats.addValue(observed[i]);         }          // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("t statistic",  -2.81976445346,                 InferenceTestUtils.t(mu, observed), 10E-10);         Assert.assertEquals("t statistic",  -2.81976445346,                 InferenceTestUtils.t(mu, sampleStats), 10E-10);         Assert.assertEquals("p value", 0.0136390585873,                 InferenceTestUtils.tTest(mu, observed), 10E-10);         Assert.assertEquals("p value", 0.0136390585873,                 InferenceTestUtils.tTest(mu, sampleStats), 10E-10);          try {             InferenceTestUtils.t(mu, (double[]) null);             Assert.fail("arguments too short, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             InferenceTestUtils.t(mu, (SummaryStatistics) null);             Assert.fail("arguments too short, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             InferenceTestUtils.t(mu, emptyObs);             Assert.fail("arguments too short, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             InferenceTestUtils.t(mu, emptyStats);             Assert.fail("arguments too short, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             InferenceTestUtils.t(mu, tooShortObs);             Assert.fail("insufficient data to compute t statistic, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             InferenceTestUtils.tTest(mu, tooShortObs);             Assert.fail("insufficient data to perform t test, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             InferenceTestUtils.t(mu, (SummaryStatistics) null);             Assert.fail("insufficient data to compute t statistic, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }         try {             InferenceTestUtils.tTest(mu, (SummaryStatistics) null);             Assert.fail("insufficient data to perform t test, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }     }      @Test     public void testOneSampleTTest() {         double[] oneSidedP =             {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };         SummaryStatistics oneSidedPStats = new SummaryStatistics();         for (int i = 0; i < oneSidedP.length; i++) {             oneSidedPStats.addValue(oneSidedP[i]);         }         // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("one sample t stat", 3.86485535541,                 InferenceTestUtils.t(0d, oneSidedP), 10E-10);         Assert.assertEquals("one sample t stat", 3.86485535541,                 InferenceTestUtils.t(0d, oneSidedPStats),1E-10);         Assert.assertEquals("one sample p value", 0.000521637019637,                 InferenceTestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);         Assert.assertEquals("one sample p value", 0.000521637019637,                 InferenceTestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);         Assert.assertTrue("one sample t-test reject", InferenceTestUtils.tTest(0d, oneSidedP, 0.01));         Assert.assertTrue("one sample t-test reject", InferenceTestUtils.tTest(0d, oneSidedPStats, 0.01));         Assert.assertTrue("one sample t-test accept", !InferenceTestUtils.tTest(0d, oneSidedP, 0.0001));         Assert.assertTrue("one sample t-test accept", !InferenceTestUtils.tTest(0d, oneSidedPStats, 0.0001));          try {             InferenceTestUtils.tTest(0d, oneSidedP, 95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          try {             InferenceTestUtils.tTest(0d, oneSidedPStats, 95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }      }      @Test     public void testTwoSampleTHeterscedastic() {         double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };         double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };         SummaryStatistics sampleStats1 = new SummaryStatistics();         for (int i = 0; i < sample1.length; i++) {             sampleStats1.addValue(sample1[i]);         }         SummaryStatistics sampleStats2 = new SummaryStatistics();         for (int i = 0; i < sample2.length; i++) {             sampleStats2.addValue(sample2[i]);         }          // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 InferenceTestUtils.t(sample1, sample2), 1E-10);         Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 InferenceTestUtils.t(sampleStats1, sampleStats2), 1E-10);         Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                 InferenceTestUtils.tTest(sample1, sample2), 1E-10);         Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                 InferenceTestUtils.tTest(sampleStats1, sampleStats2), 1E-10);         Assert.assertTrue("two sample heteroscedastic t-test reject",                 InferenceTestUtils.tTest(sample1, sample2, 0.2));         Assert.assertTrue("two sample heteroscedastic t-test reject",                 InferenceTestUtils.tTest(sampleStats1, sampleStats2, 0.2));         Assert.assertTrue("two sample heteroscedastic t-test accept",                 !InferenceTestUtils.tTest(sample1, sample2, 0.1));         Assert.assertTrue("two sample heteroscedastic t-test accept",                 !InferenceTestUtils.tTest(sampleStats1, sampleStats2, 0.1));          try {             InferenceTestUtils.tTest(sample1, sample2, .95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          try {             InferenceTestUtils.tTest(sampleStats1, sampleStats2, .95);             Assert.fail("alpha out of range, OutOfRangeException expected");         } catch (OutOfRangeException ex) {             // expected         }          try {             InferenceTestUtils.tTest(sample1, tooShortObs, .01);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             InferenceTestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);             Assert.fail("insufficient data, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             InferenceTestUtils.tTest(sample1, tooShortObs);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             InferenceTestUtils.tTest(sampleStats1, (SummaryStatistics) null);             Assert.fail("insufficient data, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             InferenceTestUtils.t(sample1, tooShortObs);             Assert.fail("insufficient data, NumberIsTooSmallException expected");         } catch (NumberIsTooSmallException ex) {             // expected         }          try {             InferenceTestUtils.t(sampleStats1, (SummaryStatistics) null);             Assert.fail("insufficient data, NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }     }     @Test     public void testTwoSampleTHomoscedastic() {         double[] sample1 ={2, 4, 6, 8, 10, 97};         double[] sample2 = {4, 6, 8, 10, 16};         SummaryStatistics sampleStats1 = new SummaryStatistics();         for (int i = 0; i < sample1.length; i++) {             sampleStats1.addValue(sample1[i]);         }         SummaryStatistics sampleStats2 = new SummaryStatistics();         for (int i = 0; i < sample2.length; i++) {             sampleStats2.addValue(sample2[i]);         }          // Target comparison values computed using R version 1.8.1 (Linux version)         Assert.assertEquals("two sample homoscedastic t stat", 0.73096310086,                 InferenceTestUtils.homoscedasticT(sample1, sample2), 10E-11);         Assert.assertEquals("two sample homoscedastic p value", 0.4833963785,                 InferenceTestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);         Assert.assertTrue("two sample homoscedastic t-test reject",                 InferenceTestUtils.homoscedasticTTest(sample1, sample2, 0.49));         Assert.assertTrue("two sample homoscedastic t-test accept",                 !InferenceTestUtils.homoscedasticTTest(sample1, sample2, 0.48));     }      @Test     public void testSmallSamples() {         double[] sample1 = {1d, 3d};         double[] sample2 = {4d, 5d};          // Target values computed using R, version 1.8.1 (linux version)         Assert.assertEquals(-2.2360679775, InferenceTestUtils.t(sample1, sample2),                 1E-10);         Assert.assertEquals(0.198727388935, InferenceTestUtils.tTest(sample1, sample2),                 1E-10);     }      @Test     public void testPaired() {         double[] sample1 = {1d, 3d, 5d, 7d};         double[] sample2 = {0d, 6d, 11d, 2d};         double[] sample3 = {5d, 7d, 8d, 10d};          // Target values computed using R, version 1.8.1 (linux version)         Assert.assertEquals(-0.3133, InferenceTestUtils.pairedT(sample1, sample2), 1E-4);         Assert.assertEquals(0.774544295819, InferenceTestUtils.pairedTTest(sample1, sample2), 1E-10);         Assert.assertEquals(0.001208, InferenceTestUtils.pairedTTest(sample1, sample3), 1E-6);         Assert.assertFalse(InferenceTestUtils.pairedTTest(sample1, sample3, .001));         Assert.assertTrue(InferenceTestUtils.pairedTTest(sample1, sample3, .002));     }      private double[] classA =       {93.0, 103.0, 95.0, 101.0};     private double[] classB =       {99.0, 92.0, 102.0, 100.0, 102.0};     private double[] classC =       {110.0, 115.0, 111.0, 117.0, 128.0};      private List<double[]> classes = new ArrayList<>();     private OneWayAnova oneWayAnova = new OneWayAnova();      @Test     public void testOneWayAnovaUtils() {         classes.add(classA);         classes.add(classB);         classes.add(classC);         Assert.assertEquals(oneWayAnova.anovaFValue(classes),                 InferenceTestUtils.oneWayAnovaFValue(classes), 10E-12);         Assert.assertEquals(oneWayAnova.anovaPValue(classes),                 InferenceTestUtils.oneWayAnovaPValue(classes), 10E-12);         Assert.assertEquals(oneWayAnova.anovaTest(classes, 0.01),                 InferenceTestUtils.oneWayAnovaTest(classes, 0.01));     }     @Test     public void testGTestGoodnesOfFit() throws Exception {         double[] exp = new double[]{             0.54d, 0.40d, 0.05d, 0.01d         };          long[] obs = new long[]{             70, 79, 3, 4         };         Assert.assertEquals("G test statistic",                 13.144799, InferenceTestUtils.g(exp, obs), 1E-5);         double p_gtgf = InferenceTestUtils.gTest(exp, obs);         Assert.assertEquals("g-Test p-value", 0.004333, p_gtgf, 1E-5);          Assert.assertTrue(InferenceTestUtils.gTest(exp, obs, 0.05)); }      @Test     public void testGTestIndependence() throws Exception {         long[] obs1 = new long[]{             268, 199, 42         };          long[] obs2 = new long[]{             807, 759, 184         };          double g = InferenceTestUtils.gDataSetsComparison(obs1, obs2);          Assert.assertEquals("G test statistic",                 7.3008170, g, 1E-4);         double p_gti = InferenceTestUtils.gTestDataSetsComparison(obs1, obs2);          Assert.assertEquals("g-Test p-value", 0.0259805, p_gti, 1E-4);         Assert.assertTrue(InferenceTestUtils.gTestDataSetsComparison(obs1, obs2, 0.05));     }      @Test     public void testRootLogLikelihood() {         // positive where k11 is bigger than expected.         Assert.assertTrue(InferenceTestUtils.rootLogLikelihoodRatio(904, 21060, 1144, 283012) > 0.0);          // negative because k11 is lower than expected         Assert.assertTrue(InferenceTestUtils.rootLogLikelihoodRatio(36, 21928, 60280, 623876) < 0.0);          Assert.assertEquals(FastMath.sqrt(2.772589), InferenceTestUtils.rootLogLikelihoodRatio(1, 0, 0, 1), 0.000001);         Assert.assertEquals(-FastMath.sqrt(2.772589), InferenceTestUtils.rootLogLikelihoodRatio(0, 1, 1, 0), 0.000001);         Assert.assertEquals(FastMath.sqrt(27.72589), InferenceTestUtils.rootLogLikelihoodRatio(10, 0, 0, 10), 0.00001);          Assert.assertEquals(FastMath.sqrt(39.33052), InferenceTestUtils.rootLogLikelihoodRatio(5, 1995, 0, 100000), 0.00001);         Assert.assertEquals(-FastMath.sqrt(39.33052), InferenceTestUtils.rootLogLikelihoodRatio(0, 100000, 5, 1995), 0.00001);          Assert.assertEquals(FastMath.sqrt(4730.737), InferenceTestUtils.rootLogLikelihoodRatio(1000, 1995, 1000, 100000), 0.001);         Assert.assertEquals(-FastMath.sqrt(4730.737), InferenceTestUtils.rootLogLikelihoodRatio(1000, 100000, 1000, 1995), 0.001);          Assert.assertEquals(FastMath.sqrt(5734.343), InferenceTestUtils.rootLogLikelihoodRatio(1000, 1000, 1000, 100000), 0.001);         Assert.assertEquals(FastMath.sqrt(5714.932), InferenceTestUtils.rootLogLikelihoodRatio(1000, 1000, 1000, 99000), 0.001);     }      @Test     public void testKSOneSample() throws Exception {        final NormalDistribution unitNormal = new NormalDistribution(0d, 1d);        final double[] sample = KolmogorovSmirnovTestTest.gaussian;        final double tol = 1e-10;        Assert.assertEquals(0.3172069207622391, InferenceTestUtils.kolmogorovSmirnovTest(unitNormal, sample), tol);        Assert.assertEquals(0.0932947561266756, InferenceTestUtils.kolmogorovSmirnovStatistic(unitNormal, sample), tol);     }      @Test     public void testKSTwoSample() throws Exception {         final double tol = 1e-10;         final double[] smallSample1 = {             6, 7, 9, 13, 19, 21, 22, 23, 24         };         final double[] smallSample2 = {             10, 11, 12, 16, 20, 27, 28, 32, 44, 54         };         Assert.assertEquals(0.105577085453247, InferenceTestUtils.kolmogorovSmirnovTest(smallSample1, smallSample2, false), tol);         final double d = InferenceTestUtils.kolmogorovSmirnovStatistic(smallSample1, smallSample2);         Assert.assertEquals(0.5, d, tol);         Assert.assertEquals(0.105577085453247, InferenceTestUtils.exactP(d, smallSample1.length, smallSample2.length, false), tol);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.stat.inference;  import java.lang.reflect.Method; import java.util.Arrays;  import org.apache.commons.math4.TestUtils; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.numbers.combinatorics.BinomialCoefficient; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.MathArrays; import org.apache.commons.math4.exception.NotANumberException; import org.apache.commons.math4.exception.InsufficientDataException; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore;  /**  * Test cases for {@link KolmogorovSmirnovTest}.  *  * @since 3.3  */ public class KolmogorovSmirnovTestTest {     private static final double TOLERANCE = 1e-10;     private static final int MONTE_CARLO_ITERATIONS = 1000000;     private static final int LARGE_SAMPLE_PRODUCT = 10000;      // Random N(0,1) values generated using R rnorm     protected static final double[] gaussian = {         0.26055895, -0.63665233, 1.51221323, 0.61246988, -0.03013003, -1.73025682, -0.51435805, 0.70494168, 0.18242945,         0.94734336, -0.04286604, -0.37931719, -1.07026403, -2.05861425, 0.11201862, 0.71400136, -0.52122185,         -0.02478725, -1.86811649, -1.79907688, 0.15046279, 1.32390193, 1.55889719, 1.83149171, -0.03948003,         -0.98579207, -0.76790540, 0.89080682, 0.19532153, 0.40692841, 0.15047336, -0.58546562, -0.39865469, 0.77604271,         -0.65188221, -1.80368554, 0.65273365, -0.75283102, -1.91022150, -0.07640869, -1.08681188, -0.89270600,         2.09017508, 0.43907981, 0.10744033, -0.70961218, 1.15707300, 0.44560525, -2.04593349, 0.53816843, -0.08366640,         0.24652218, 1.80549401, -0.99220707, -1.14589408, -0.27170290, -0.49696855, 0.00968353, -1.87113545,         -1.91116529, 0.97151891, -0.73576115, -0.59437029, 0.72148436, 0.01747695, -0.62601157, -1.00971538,         -1.42691397, 1.03250131, -0.30672627, -0.15353992, -1.19976069, -0.68364218, 0.37525652, -0.46592881,         -0.52116168, -0.17162202, 1.04679215, 0.25165971, -0.04125231, -0.23756244, -0.93389975, 0.75551407,         0.08347445, -0.27482228, -0.4717632, -0.1867746, -0.1166976, 0.5763333, 0.1307952, 0.7630584, -0.3616248,         2.1383790, -0.7946630, 0.0231885, 0.7919195, 1.6057144, -0.3802508, 0.1229078, 1.5252901, -0.8543149, 0.3025040     };      // Random N(0, 1.6) values generated using R rnorm     protected static final double[] gaussian2 = {         2.88041498038308, -0.632349445671017, 0.402121295225571, 0.692626364613243, 1.30693446815426,         -0.714176317131286, -0.233169206599583, 1.09113298322107, -1.53149079994305, 1.23259966205809,         1.01389927412503, 0.0143898711497477, -0.512813545447559, 2.79364360835469, 0.662008875538092,         1.04861546834788, -0.321280099931466, 0.250296656278743, 1.75820367603736, -2.31433523590905,         -0.462694696086403, 0.187725700950191, -2.24410950019152, 2.83473751105445, 0.252460174391016,         1.39051945380281, -1.56270144203134, 0.998522814471644, -1.50147469080896, 0.145307533554146,         0.469089457043406, -0.0914780723809334, -0.123446939266548, -0.610513388160565, -3.71548343891957,         -0.329577317349478, -0.312973794075871, 2.02051909758923, 2.85214308266271, 0.0193222002327237,         -0.0322422268266562, 0.514736012106768, 0.231484953375887, -2.22468798953629, 1.42197716075595,         2.69988043856357, 0.0443757119128293, 0.721536984407798, -0.0445688839903234, -0.294372724550705,         0.234041580912698, -0.868973119365727, 1.3524893453845, -0.931054600134503, -0.263514296006792,         0.540949457402918, -0.882544288773685, -0.34148675747989, 1.56664494810034, 2.19850536566584,         -0.667972122928022, -0.70889669526203, -0.00251758193079668, 2.39527162977682, -2.7559594317269,         -0.547393502656671, -2.62144031572617, 2.81504147017922, -1.02036850201042, -1.00713927602786,         -0.520197775122254, 1.00625480138649, 2.46756916531313, 1.64364743727799, 0.704545210648595,         -0.425885789416992, -1.78387854908546, -0.286783886710481, 0.404183648369076, -0.369324280845769,         -0.0391185138840443, 2.41257787857293, 2.49744281317859, -0.826964496939021, -0.792555379958975,         1.81097685787403, -0.475014580016638, 1.23387615291805, 0.646615294802053, 1.88496377454523, 1.20390698380814,         -0.27812153371728, 2.50149494533101, 0.406964323253817, -1.72253451309982, 1.98432494184332, 2.2223658560333,         0.393086362404685, -0.504073151377089, -0.0484610869883821     };      // Random uniform (0, 1) generated using R runif     protected static final double[] uniform = {         0.7930305, 0.6424382, 0.8747699, 0.7156518, 0.1845909, 0.2022326, 0.4877206, 0.8928752, 0.2293062, 0.4222006,         0.1610459, 0.2830535, 0.9946345, 0.7329499, 0.26411126, 0.87958133, 0.29827437, 0.39185988, 0.38351185,         0.36359611, 0.48646472, 0.05577866, 0.56152250, 0.52672013, 0.13171783, 0.95864085, 0.03060207, 0.33514887,         0.72508148, 0.38901437, 0.9978665, 0.5981300, 0.1065388, 0.7036991, 0.1071584, 0.4423963, 0.1107071, 0.6437221,         0.58523872, 0.05044634, 0.65999539, 0.37367260, 0.73270024, 0.47473755, 0.74661163, 0.50765549, 0.05377347,         0.40998009, 0.55235182, 0.21361998, 0.63117971, 0.18109222, 0.89153510, 0.23203248, 0.6177106, 0.6856418,         0.2158557, 0.9870501, 0.2036914, 0.2100311, 0.9065020, 0.7459159, 0.56631790, 0.06753629, 0.39684629,         0.52504615, 0.14199103, 0.78551120, 0.90503321, 0.80452362, 0.9960115, 0.8172592, 0.5831134, 0.8794187,         0.2021501, 0.2923505, 0.9561824, 0.8792248, 0.85201008, 0.02945562, 0.26200374, 0.11382818, 0.17238856,         0.36449473, 0.69688273, 0.96216330, 0.4859432, 0.4503438, 0.1917656, 0.8357845, 0.9957812, 0.4633570,         0.8654599, 0.4597996, 0.68190289, 0.58887855, 0.09359396, 0.98081979, 0.73659533, 0.89344777, 0.18903099,         0.97660425     };      /** Unit normal distribution, unit normal data */     @Test     public void testOneSampleGaussianGaussian() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final NormalDistribution unitNormal = new NormalDistribution(0d, 1d);         // Uncomment to run exact test - takes about a minute. Same value is used in R tests and for         // approx.         // Assert.assertEquals(0.3172069207622391, test.kolmogorovSmirnovTest(unitNormal, gaussian,         // true), TOLERANCE);         Assert.assertEquals(0.3172069207622391, test.kolmogorovSmirnovTest(unitNormal, gaussian, false), TOLERANCE);         Assert.assertFalse(test.kolmogorovSmirnovTest(unitNormal, gaussian, 0.05));         Assert.assertEquals(0.0932947561266756, test.kolmogorovSmirnovStatistic(unitNormal, gaussian), TOLERANCE);     }      /** Unit normal distribution, unit normal data, small dataset */     @Test     public void testOneSampleGaussianGaussianSmallSample() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final NormalDistribution unitNormal = new NormalDistribution(0d, 1d);         final double[] shortGaussian = new double[50];         System.arraycopy(gaussian, 0, shortGaussian, 0, 50);         Assert.assertEquals(0.683736463728347, test.kolmogorovSmirnovTest(unitNormal, shortGaussian, false), TOLERANCE);         Assert.assertFalse(test.kolmogorovSmirnovTest(unitNormal, gaussian, 0.05));         Assert.assertEquals(0.09820779969463278, test.kolmogorovSmirnovStatistic(unitNormal, shortGaussian), TOLERANCE);     }      /** Unit normal distribution, uniform data */     @Test     public void testOneSampleGaussianUniform() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final NormalDistribution unitNormal = new NormalDistribution(0d, 1d);         // Uncomment to run exact test - takes a long time. Same value is used in R tests and for         // approx.         // Assert.assertEquals(0.3172069207622391, test.kolmogorovSmirnovTest(unitNormal, uniform,         // true), TOLERANCE);         Assert.assertEquals(8.881784197001252E-16, test.kolmogorovSmirnovTest(unitNormal, uniform, false), TOLERANCE);         Assert.assertFalse(test.kolmogorovSmirnovTest(unitNormal, gaussian, 0.05));         Assert.assertEquals(0.5117493931609258, test.kolmogorovSmirnovStatistic(unitNormal, uniform), TOLERANCE);     }      /** Uniform distribution, uniform data */     // @Test - takes about 6 seconds, uncomment for     public void testOneSampleUniformUniform() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformContinuousDistribution unif = new UniformContinuousDistribution(-0.5, 0.5);         Assert.assertEquals(8.881784197001252E-16, test.kolmogorovSmirnovTest(unif, uniform, false), TOLERANCE);         Assert.assertTrue(test.kolmogorovSmirnovTest(unif, uniform, 0.05));         Assert.assertEquals(0.5400666982352942, test.kolmogorovSmirnovStatistic(unif, uniform), TOLERANCE);     }      /** Uniform distribution, uniform data, small dataset */     @Test     public void testOneSampleUniformUniformSmallSample() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformContinuousDistribution unif = new UniformContinuousDistribution(-0.5, 0.5);         final double[] shortUniform = new double[20];         System.arraycopy(uniform, 0, shortUniform, 0, 20);         Assert.assertEquals(4.117594598618268E-9, test.kolmogorovSmirnovTest(unif, shortUniform, false), TOLERANCE);         Assert.assertTrue(test.kolmogorovSmirnovTest(unif, shortUniform, 0.05));         Assert.assertEquals(0.6610459, test.kolmogorovSmirnovStatistic(unif, shortUniform), TOLERANCE);     }      /** Uniform distribution, unit normal dataset */     @Test     public void testOneSampleUniformGaussian() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformContinuousDistribution unif = new UniformContinuousDistribution(-0.5, 0.5);         // Value was obtained via exact test, validated against R. Running exact test takes a long         // time.         Assert.assertEquals(4.9405812774239166E-11, test.kolmogorovSmirnovTest(unif, gaussian, false), TOLERANCE);         Assert.assertTrue(test.kolmogorovSmirnovTest(unif, gaussian, 0.05));         Assert.assertEquals(0.3401058049019608, test.kolmogorovSmirnovStatistic(unif, gaussian), TOLERANCE);     }      /** Small samples - exact p-value, checked against R */     @Test     public void testTwoSampleSmallSampleExact() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final double[] smallSample1 = {             6, 7, 9, 13, 19, 21, 22, 23, 24         };         final double[] smallSample2 = {             10, 11, 12, 16, 20, 27, 28, 32, 44, 54         };         // Reference values from R, version 3.2.0 - R uses non-strict inequality in null hypothesis         Assert             .assertEquals(0.105577085453247, test.kolmogorovSmirnovTest(smallSample1, smallSample2, false), TOLERANCE);         Assert.assertEquals(0.5, test.kolmogorovSmirnovStatistic(smallSample1, smallSample2), TOLERANCE);     }      /** Small samples - exact p-value, checked against R */     @Test     public void testTwoSampleSmallSampleExact2() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final double[] smallSample1 = {             6, 7, 9, 13, 19, 21, 22, 23, 24, 29, 30, 34, 36, 41, 45, 47, 51, 63, 33, 91         };         final double[] smallSample2 = {             10, 11, 12, 16, 20, 27, 28, 32, 44, 54, 56, 57, 64, 69, 71, 80, 81, 88, 90         };         // Reference values from R, version 3.2.0 - R uses non-strict inequality in null hypothesis         Assert             .assertEquals(0.0462986609, test.kolmogorovSmirnovTest(smallSample1, smallSample2, false), TOLERANCE);         Assert.assertEquals(0.4263157895, test.kolmogorovSmirnovStatistic(smallSample1, smallSample2), TOLERANCE);     }      /** Small samples - exact p-value, checked against R */     @Test     public void testTwoSampleSmallSampleExact3() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final double[] smallSample1 = {             -10, -5, 17, 21, 22, 23, 24, 30, 44, 50, 56, 57, 59, 67, 73, 75, 77, 78, 79, 80, 81, 83, 84, 85, 88, 90,             92, 93, 94, 95, 98, 100, 101, 103, 105, 110         };         final double[] smallSample2 = {             -2, -1, 0, 10, 14, 15, 16, 20, 25, 26, 27, 31, 32, 33, 34, 45, 47, 48, 51, 52, 53, 54, 60, 61, 62, 63,             74, 82, 106, 107, 109, 11, 112, 113, 114         };         // Reference values from R, version 3.2.0 - R uses non-strict inequality in null hypothesis         Assert             .assertEquals(0.00300743602, test.kolmogorovSmirnovTest(smallSample1, smallSample2, false), TOLERANCE);         Assert.assertEquals(0.4103174603, test.kolmogorovSmirnovStatistic(smallSample1, smallSample2), TOLERANCE);         Assert         .assertEquals(0.00300743602, test.kolmogorovSmirnovTest(smallSample2, smallSample1, false), TOLERANCE);     }      /**      * Checks exact p-value computations using critical values from Table 9 in V.K Rohatgi, An      * Introduction to Probability and Mathematical Statistics, Wiley, 1976, ISBN 0-471-73135-8.      */     @Test     public void testTwoSampleExactP() {         checkExactTable(4, 6, 5d / 6d, 0.01d);         checkExactTable(4, 7, 17d / 28d, 0.2d);         checkExactTable(6, 7, 29d / 42d, 0.05d);         checkExactTable(4, 10, 7d / 10d, 0.05d);         checkExactTable(5, 15, 11d / 15d, 0.02d);         checkExactTable(9, 10, 31d / 45d, 0.01d);         checkExactTable(7, 10, 43d / 70d, 0.05d);     }      @Test     public void testTwoSampleApproximateCritialValues() {         final double tol = .01;         final double[] alpha = {             0.10, 0.05, 0.025, 0.01, 0.005, 0.001         };         // From Wikipedia KS article - TODO: get (and test) more precise values         final double[] c = {             1.22, 1.36, 1.48, 1.63, 1.73, 1.95         };         final int k[] = {             60, 100, 500         };         double n;         double m;         for (int i = 0; i < k.length; i++) {             for (int j = 0; j < i; j++) {                 n = k[i];                 m = k[j];                 for (int l = 0; l < alpha.length; l++) {                     final double dCrit = c[l] * FastMath.sqrt((n + m) / (n * m));                     checkApproximateTable(k[i], k[j], dCrit, alpha[l], tol);                 }             }         }     }      @Test     public void testPelzGoodApproximation() {         KolmogorovSmirnovTest ksTest = new KolmogorovSmirnovTest();         final double d[] = {0.15, 0.20, 0.25, 0.3, 0.35, 0.4};         final int n[] = {141, 150, 180, 220, 1000};         // Reference values computed using the Pelz method from         // http://simul.iro.umontreal.ca/ksdir/KolmogorovSmirnovDist.java         final double ref[] = {             0.9968940168727819, 0.9979326624184857, 0.9994677598604506, 0.9999128354780209, 0.9999999999998661,             0.9999797514476236, 0.9999902122242081, 0.9999991327060908, 0.9999999657681911, 0.9999999999977929,             0.9999999706444976, 0.9999999906571532, 0.9999999997949596, 0.999999999998745, 0.9999999999993876,             0.9999999999916627, 0.9999999999984447, 0.9999999999999936, 0.999999999999341, 0.9999999999971508,             0.9999999999999877, 0.9999999999999191, 0.9999999999999254, 0.9999999999998178, 0.9999999999917788,             0.9999999999998556, 0.9999999999992014, 0.9999999999988859, 0.9999999999999325, 0.9999999999821726         };          final double tol = 10e-15;         int k = 0;         for (int i = 0; i < 6; i++) {             for (int j = 0; j < 5; j++, k++) {                 Assert.assertEquals(ref[k], ksTest.pelzGood(d[i], n[j]), tol);             }         }     }      /** Verifies large sample approximate p values against R */     @Test     public void testTwoSampleApproximateP() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         // Reference values from R, version 2.15.3         Assert.assertEquals(0.0319983962391632, test.kolmogorovSmirnovTest(gaussian, gaussian2), TOLERANCE);         Assert.assertEquals(0.202352941176471, test.kolmogorovSmirnovStatistic(gaussian, gaussian2), TOLERANCE);     }      /**      * MATH-1181      * Verify that large sample method is selected for sample product > Integer.MAX_VALUE      * (integer overflow in sample product)      */     @Test(timeout=5000)     public void testTwoSampleProductSizeOverflow() {         final int n = 50000;         Assert.assertTrue(n * n < 0);         double[] x = new double[n];         double[] y = new double[n];         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertFalse(Double.isNaN(test.kolmogorovSmirnovTest(x, y)));     }      /**      * Verifies that Monte Carlo simulation gives results close to exact p values.      */     @Test     public void testTwoSampleMonteCarlo() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);         final int sampleSize = 14;         final double tol = .001;         final double[] shortUniform = new double[sampleSize];         System.arraycopy(uniform, 0, shortUniform, 0, sampleSize);         final double[] shortGaussian = new double[sampleSize];         final double[] shortGaussian2 = new double[sampleSize];         System.arraycopy(gaussian, 0, shortGaussian, 0, sampleSize);         System.arraycopy(gaussian, 10, shortGaussian2, 0, sampleSize);         final double[] d = {             test.kolmogorovSmirnovStatistic(shortGaussian, shortUniform),             test.kolmogorovSmirnovStatistic(shortGaussian2, shortGaussian)         };         for (double dv : d) {             double exactPStrict = test.exactP(dv, sampleSize, sampleSize, true);             double exactPNonStrict = test.exactP(dv, sampleSize, sampleSize, false);             double montePStrict = test.monteCarloP(dv, sampleSize, sampleSize, true,                                                    MONTE_CARLO_ITERATIONS, rng);             double montePNonStrict = test.monteCarloP(dv, sampleSize, sampleSize, false,                                                       MONTE_CARLO_ITERATIONS, rng);             Assert.assertEquals(exactPStrict, montePStrict, tol);             Assert.assertEquals(exactPNonStrict, montePNonStrict, tol);         }     }      @Test     public void testTwoSampleMonteCarloDifferentSampleSizes() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);         final int sampleSize1 = 14;         final int sampleSize2 = 7;         final double d = 0.3;         final boolean strict = false;         final double tol = 1e-2;         Assert.assertEquals(test.exactP(d, sampleSize1, sampleSize2, strict),                             test.monteCarloP(d, sampleSize1, sampleSize2, strict,                                              MONTE_CARLO_ITERATIONS, rng),                             tol);     }      /**      * Performance test for monteCarlo method. Disabled by default.      */     // @Test     public void testTwoSampleMonteCarloPerformance() {         int numIterations = 100_000;         int N = (int)Math.sqrt(LARGE_SAMPLE_PRODUCT);         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);         for (int n = 2; n <= N; ++n) {             long startMillis = System.currentTimeMillis();             int m = LARGE_SAMPLE_PRODUCT/n;             Assert.assertEquals(0d, test.monteCarloP(Double.POSITIVE_INFINITY, n, m, true, numIterations, rng), 0d);             long endMillis = System.currentTimeMillis();             System.out.println("n=" + n + ", m=" + m + ", time=" + (endMillis-startMillis)/1000d + "s");         }     }      @Test     public void testTwoSampleWithManyTies() {         // MATH-1197         final double[] x = {             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,             2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,             2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,             2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,             2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,             2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,             3.181199, 3.181199, 3.181199, 3.181199, 3.181199, 3.181199,             3.723539, 3.723539, 3.723539, 3.723539, 4.383482, 4.383482,             4.383482, 4.383482, 5.320671, 5.320671, 5.320671, 5.717284,             6.964001, 7.352165, 8.710510, 8.710510, 8.710510, 8.710510,             8.710510, 8.710510, 9.539004, 9.539004, 10.720619, 17.726077,             17.726077, 17.726077, 17.726077, 22.053875, 23.799144, 27.355308,             30.584960, 30.584960, 30.584960, 30.584960, 30.751808         };          final double[] y = {             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,             0.000000, 0.000000, 0.000000, 2.202653, 2.202653, 2.202653,             2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 3.061758,             3.723539, 5.628420, 5.628420, 5.628420, 5.628420, 5.628420,             6.916982, 6.916982, 6.916982, 10.178538, 10.178538, 10.178538,             10.178538, 10.178538         };          final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();          Assert.assertEquals(0.0640394088, test.kolmogorovSmirnovStatistic(x, y), 1e-6);         Assert.assertEquals(0.9792777290, test.kolmogorovSmirnovTest(x, y), 1e-6);      }      @Test     public void testTwoSampleWithManyTiesAndVerySmallDelta() {         // Cf. MATH-1405          final double[] x = {             0.0, 0.0,             1.0, 1.0,             1.5,             1.6,             1.7,             1.8,             1.9,             2.0,             2.000000000000001         };          final double[] y = {             0.0, 0.0,             10.0, 10.0,             11.0, 11.0, 11.0,             15.0,             16.0,             17.0,             18.0,             19.0,             20.0,             20.000000000000001         };          final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertEquals(1.12173015e-5, test.kolmogorovSmirnovTest(x, y), 1e-6);     }      @Ignore@Test     public void testTwoSampleWithManyTiesAndExtremeValues() {         // Cf. MATH-1405          final double[] largeX = {             Double.MAX_VALUE, Double.MAX_VALUE,             1e40, 1e40,             2e40, 2e40,             1e30,             2e30,             3e30,             4e30,             5e10,             6e10,             7e10,             8e10         };          final double[] smallY = {             Double.MIN_VALUE,             2 * Double.MIN_VALUE,             1e-40, 1e-40,             2e-40, 2e-40,             1e-30,             2e-30,             3e-30,             4e-30,             5e-10,             6e-10,             7e-10,             8e-10         };          final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertEquals(0, test.kolmogorovSmirnovTest(largeX, smallY), 1e-10);     }      @Ignore@Test     public void testTwoSamplesWithInfinitiesAndTies() {         final double[] x = {             1, 1,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY         };          final double[] y = {             1, 1,             3, 3,             Double.NEGATIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY         };          final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertEquals(0, test.kolmogorovSmirnovTest(x, y), 1e-10);     }      @Test(expected=InsufficientDataException.class)     public void testTwoSamplesWithOnlyInfinities() {         final double[] x = {             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY         };          final double[] y = {             Double.NEGATIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY         };          final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertEquals(0, test.kolmogorovSmirnovTest(x, y), 1e-10);     }      @Test(expected=NotANumberException.class)     public void testTwoSampleWithTiesAndNaN1() {         // Cf. MATH-1405          final double[] x = { 1, Double.NaN, 3, 4 };         final double[] y = { 1, 2, 3, 4 };         new KolmogorovSmirnovTest().kolmogorovSmirnovTest(x, y);     }      @Test(expected=NotANumberException.class)     public void testTwoSampleWithTiesAndNaN2() {         // Cf. MATH-1405          final double[] x = { 1, 2, 3, 4 };         final double[] y = { 1, 2, Double.NaN, 4 };          new KolmogorovSmirnovTest().kolmogorovSmirnovTest(x, y);     }      @Test     public void testTwoSamplesAllEqual() {         int iterations = 10_000;         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);         for (int i = 2; i < 30; ++i) {             // testing values with ties             double[] values = new double[i];             Arrays.fill(values, i);             // testing values without ties             double[] ascendingValues = new double[i];             for (int j = 0; j < ascendingValues.length; j++) {                 ascendingValues[j] = j;             }              Assert.assertEquals(0., test.kolmogorovSmirnovStatistic(values, values), 0.);             Assert.assertEquals(0., test.kolmogorovSmirnovStatistic(ascendingValues, ascendingValues), 0.);              if (i < 10) {                 Assert.assertEquals(1.0, test.exactP(0, values.length, values.length, true), 0.);                 Assert.assertEquals(1.0, test.exactP(0, values.length, values.length, false), 0.);             }              Assert.assertEquals(1.0, test.monteCarloP(0, values.length, values.length, true, iterations, rng), 0.);             Assert.assertEquals(1.0, test.monteCarloP(0, values.length, values.length, false, iterations, rng), 0.);              Assert.assertEquals(1.0, test.approximateP(0, values.length, values.length), 0.);             Assert.assertEquals(1.0, test.approximateP(0, values.length, values.length), 0.);         }     }      /**      * JIRA: MATH-1245      *      * Verify that D-values are not viewed as distinct when they are mathematically equal      * when computing p-statistics for small sample tests. Reference values are from R 3.2.0.      */     @Test     public void testDRounding() {         final double tol = 1e-12;         final double[] x = {0, 2, 3, 4, 5, 6, 7, 8, 9, 12};         final double[] y = {1, 10, 11, 13, 14, 15, 16, 17, 18};         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertEquals(0.0027495724090154106, test.kolmogorovSmirnovTest(x, y,false), tol);          final double[] x1 = {2, 4, 6, 8, 9, 10, 11, 12, 13};         final double[] y1 = {0, 1, 3, 5, 7};         Assert.assertEquals(0.085914085914085896, test.kolmogorovSmirnovTest(x1, y1, false), tol);          final double[] x2 = {4, 6, 7, 8, 9, 10, 11};         final double[] y2 = {0, 1, 2, 3, 5};         Assert.assertEquals(0.015151515151515027, test.kolmogorovSmirnovTest(x2, y2, false), tol);     }      /**      * JIRA: MATH-1245      *      * Verify that D-values are not viewed as distinct when they are mathematically equal      * when computing p-statistics for small sample tests. Reference values are from R 3.2.0.      */     @Test     public void testDRoundingMonteCarlo() {         final double tol = 1e-2;         final int iterations = 1000000;         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);          final double[] x = {0, 2, 3, 4, 5, 6, 7, 8, 9, 12};         final double[] y = {1, 10, 11, 13, 14, 15, 16, 17, 18};         double d = test.kolmogorovSmirnovStatistic(x, y);         Assert.assertEquals(0.0027495724090154106, test.monteCarloP(d, x.length, y.length, false, iterations, rng), tol);          final double[] x1 = {2, 4, 6, 8, 9, 10, 11, 12, 13};         final double[] y1 = {0, 1, 3, 5, 7};         d = test.kolmogorovSmirnovStatistic(x1, y1);         Assert.assertEquals(0.085914085914085896, test.monteCarloP(d, x1.length, y1.length, false, iterations, rng), tol);          final double[] x2 = {4, 6, 7, 8, 9, 10, 11};         final double[] y2 = {0, 1, 2, 3, 5};         d = test.kolmogorovSmirnovStatistic(x2, y2);         Assert.assertEquals(0.015151515151515027, test.monteCarloP(d, x2.length, y2.length, false, iterations, rng), tol);     }      @Test     public void testFillBooleanArrayRandomlyWithFixedNumberTrueValues() throws Exception {         Method method = KolmogorovSmirnovTest.class.getDeclaredMethod("fillBooleanArrayRandomlyWithFixedNumberTrueValues",                                                                       boolean[].class, Integer.TYPE, UniformRandomProvider.class);         method.setAccessible(true);          final int[][] parameters = {{5, 1}, {5, 2}, {5, 3}, {5, 4}, {8, 1}, {8, 2}, {8, 3}, {8, 4}, {8, 5}, {8, 6}, {8, 7}};          final double alpha = 0.001;         final int numIterations = 1000000;          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 0);          for (final int[] parameter : parameters) {              final int arraySize = parameter[0];             final int numberOfTrueValues = parameter[1];              final boolean[] b = new boolean[arraySize];             final long[] counts = new long[1 << arraySize];              for (int i = 0; i < numIterations; ++i) {                 method.invoke(KolmogorovSmirnovTest.class, b, numberOfTrueValues, rng);                 int x = 0;                 for (int j = 0; j < arraySize; ++j) {                     x = ((x << 1) | ((b[j])?1:0));                 }                 counts[x] += 1;             }              final int numCombinations = (int) BinomialCoefficient.value(arraySize, numberOfTrueValues);              final long[] observed = new long[numCombinations];             final double[] expected = new double[numCombinations];             Arrays.fill(expected, numIterations / (double) numCombinations);              int observedIdx = 0;              for (int i = 0; i < (1 << arraySize); ++i) {                 if (Integer.bitCount(i) == numberOfTrueValues) {                     observed[observedIdx] = counts[i];                     observedIdx += 1;                 }                 else {                     Assert.assertEquals(0, counts[i]);                 }             }              Assert.assertEquals(numCombinations, observedIdx);             TestUtils.assertChiSquareAccept(expected, observed, alpha);         }     }      /**      * Test an example with ties in the data.  Reference data is R 3.2.0,      * ks.boot implemented in Matching (Version 4.8-3.4, Build Date: 2013/10/28)      */     @Test     public void testBootstrapSmallSamplesWithTies() {         final double[] x = {0, 2, 4, 6, 8, 8, 10, 15, 22, 30, 33, 36, 38};         final double[] y = {9, 17, 20, 33, 40, 51, 60, 60, 72, 90, 101};         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 2000);         Assert.assertEquals(0.0059, test.bootstrap(x, y, 10000, false, rng), 1E-3);     }      /**      * Reference data is R 3.2.0, ks.boot implemented in      * Matching (Version 4.8-3.4, Build Date: 2013/10/28)      */     @Test     public void testBootstrapLargeSamples() {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);         Assert.assertEquals(0.0237, test.bootstrap(gaussian, gaussian2, 10000, true, rng), 1E-2);     }      /**      * Test an example where D-values are close (subject to rounding).      * Reference data is R 3.2.0, ks.boot implemented in      * Matching (Version 4.8-3.4, Build Date: 2013/10/28)      */     @Test     public void testBootstrapRounding() {         final double[] x = {2,4,6,8,9,10,11,12,13};         final double[] y = {0,1,3,5,7};         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);         Assert.assertEquals(0.06303, test.bootstrap(x, y, 10000, false, rng), 1E-2);     }      @Test     public void testFixTiesNoOp() throws Exception {         final double[] x = {0, 1, 2, 3, 4};         final double[] y = {5, 6, 7, 8};         final double[] origX = Arrays.copyOf(x, x.length);         final double[] origY = Arrays.copyOf(y, y.length);         fixTies(x,y);         Assert.assertArrayEquals(origX, x, 0);         Assert.assertArrayEquals(origY, y, 0);     }      /**      * Verify that fixTies is deterministic, i.e,      * x = x', y = y' => fixTies(x,y) = fixTies(x', y')      */     @Test     public void testFixTiesConsistency() throws Exception {         final double[] x = {0, 1, 2, 3, 4, 2};         final double[] y = {5, 6, 7, 8, 1, 2};         final double[] xP = Arrays.copyOf(x, x.length);         final double[] yP = Arrays.copyOf(y, y.length);         checkFixTies(x, y);         final double[] fixedX = Arrays.copyOf(x, x.length);         final double[] fixedY = Arrays.copyOf(y, y.length);         checkFixTies(xP, yP);         Assert.assertArrayEquals(fixedX, xP, 0);         Assert.assertArrayEquals(fixedY, yP, 0);     }      @Test     public void testFixTies() throws Exception {         checkFixTies(new double[] {0, 1, 1, 4, 0}, new double[] {0, 5, 0.5, 0.55, 7});         checkFixTies(new double[] {1, 1, 1, 1, 1}, new double[] {1, 1});         checkFixTies(new double[] {1, 2, 3}, new double[] {1});         checkFixTies(new double[] {1, 1, 0, 1, 0}, new double[] {});     }      @Test     public void testMath1475() throws Exception {         // MATH-1475         double[] x = new double[] { 0.12350159883499146, -0.2601194679737091, -1.322849988937378, 0.379696249961853,                                     0.3987586498260498, -0.06924121081829071, -0.13951236009597778, 0.3213207423686981,                                     0.7949811816215515, -0.15811105072498322, 0.19912190735340118, -0.46363770961761475,                                     -0.20019817352294922, 0.3062838613986969, -0.3872813880443573, 0.10733723640441895,                                     0.10910066962242126, 0.625770092010498, 0.2824835777282715, 0.3107619881629944,                                     0.1432388722896576, -0.08056988567113876, -0.5816712379455566, -0.09488576650619507,                                     -0.2154506891965866, 0.2509046196937561, -0.06600788980722427, -0.01133995596319437,                                     -0.22642627358436584, -0.12150175869464874, -0.21109570562839508, -0.17732949554920197,                                     -0.2769380807876587, -0.3607368767261505, -0.07842907309532166, -0.2518743574619293,                                     0.035517483949661255, -0.6556509137153625, -0.360045850276947, -0.09371964633464813,                                     -0.7284095883369446, -0.22719840705394745, -1.5540679693222046, -0.008972732350230217,                                     -0.09106933325529099, -0.6465389132499695, 0.036245591938495636, 0.657580554485321,                                     0.32453101873397827, 0.6105462908744812, 0.25256943702697754, -0.194427490234375,                                     0.6238796710968018, 0.5203511118888855, -0.2708645761013031, 0.07761227339506149,                                     0.5315862894058228, 0.44320303201675415, 0.6283767819404602, 0.2618369162082672,                                     0.47253096103668213, 0.3889777660369873, 0.6856100559234619, 0.3007083833217621,                                     0.4963226914405823, 0.08229698985815048, 0.6170856952667236, 0.7501978874206543,                                     0.5744063258171082, 0.5233180522918701, 0.32654184103012085, 0.3014495372772217,                                     0.4082445800304413, -0.1075737327337265, -0.018864337354898453, 0.34642550349235535,                                     0.6414541602134705, 0.16678297519683838, 0.46028634905815125, 0.4151197075843811,                                     0.14407725632190704, 0.41751566529273987, -0.054958608001470566, 0.4995657801628113,                                     0.4485369324684143, 0.5600396990776062, 0.4098612368106842, 0.2748555839061737,                                     0.2562614381313324, 0.4324824810028076 };         double[] y = new double[] { 2.6881366763426717, 2.685469965655465, 2.261888917462379, -2.1933598759641226,                                     -2.4279488152810145, -3.159389495849609, -2.3150004548153444, 2.468029206047388,                                     2.9442494682288953, 2.653360013462529, -2.1189940659194835, -2.121635289903703,                                     -2.103092459792032, -2.737034221468073, -2.203389332350286, 2.1985949039005512,                                     -2.5021604073154737, 2.2732754920764533, -2.3867025598454346, 2.135919387338413,                                     2.338120776050672, 2.2579794509726874, 2.083329059799027, -2.209733724709957,                                     2.297192240399189, -2.201703830825843, -3.460208691996806, 2.428839296615834,                                     -3.2944259224581574, 2.0654875493620883, -2.743948930837782, -2.2240674680805212,                                     -3.646366778182357, -2.12513198437294, 2.979166188824589, -2.6275491570089033,                                     -2.3818176136461338, 2.882096356968376, -2.2147229261558334, -3.159389495849609,                                     2.312428759406432, 2.3313864098846477, -2.72802504046371, -2.4216068225364245,                                     3.0119599306499123, 2.5753099009496783, -2.9200121783556843, -2.519352725437922,                                     -4.133932580227538, -2.30496316762808, 2.5381353678521363, 2.4818233632136697,                                     2.5277451177925685, -2.166465445816232, -2.1193897819471563, -2.109654332722425,                                     3.260211545834851, -3.9527673876059013, -2.199885089466947, 2.152573429747697,                                     -3.1593894958496094, 2.5479522823226795, 3.342810742466116, -2.8197184957304007,                                     -2.3407900299253765, -2.3303967152728537, 2.1760131201015565, 2.143930552944634,                                     2.33336231754409, 2.9126278362420575, -2.121169134387265, -2.2980208408109095,                                     -2.285400411434817, -2.0742764640932903, 2.304178664095016, -2.2893825538911634,                                     -3.7714771984158806, -2.7153698816026886, 2.8995011276220226, -2.158787087333056,                                     -2.1045987952052547, 2.8478762016468147, -2.694578565956955, -2.696014432856399,                                     -2.3190122657403496, -2.48225194403028, 3.3393947563371764, 2.7775468034263517,                                     -3.396526561479875, -2.699967947404961};         KolmogorovSmirnovTest kst = new KolmogorovSmirnovTest();         kst.kolmogorovSmirnovTest(x, y);     }      @Ignore@Test     public void testMath1535() {         // MATH-1535         final double[] x = new double[] {0.8767630865438496, 0.9998809418147052, 0.9999999715463531, 0.9999985849345421,                                          0.973584315883326, 0.9999999875782982, 0.999999999999994, 0.9999999999908233,                                          1.0, 0.9999999890925574, 0.9999998345734327, 0.9999999350772448,                                          0.999999999999426, 0.9999147040688201, 0.9999999999999922, 1.0,                                          1.0, 0.9919050954798272, 0.8649014770687263, 0.9990869497973084,                                          0.9993222540990464, 0.999999999998189, 0.9999999999999365, 0.9790934801762917,                                          0.9999578695006303, 0.9999999999999998, 0.999999999996166, 0.9999999999995546,                                          0.9999999999908036, 0.99999999999744, 0.9999998802655555, 0.9079334221214075,                                          0.9794398308007372, 0.9999044231134367, 0.9999999999999813, 0.9999957841707683,                                          0.9277678892094009, 0.999948269893843, 0.9999999886132888, 0.9999998909699096,                                          0.9999099536620326, 0.9999999962217623, 0.9138936987350447, 0.9999999999779976,                                          0.999999999998822, 0.999979247207911, 0.9926904388316407, 1.0,                                          0.9999999999998814, 1.0, 0.9892505696426215, 0.9999996514123723,                                          0.9999999999999429, 0.9999999995399116, 0.999999999948221, 0.7358264887843119,                                          0.9999999994098534, 1.0, 0.9999986456748472, 1.0,                                          0.9999999999921501, 0.9999999999999996, 0.9999999999999944, 0.9473070068606853,                                          0.9993714060209042, 0.9999999409098718, 0.9999999592791519, 0.9999999999999805};         final double[] y = new double[x.length];         Arrays.fill(y, 1d);         final KolmogorovSmirnovTest kst = new KolmogorovSmirnovTest();         double p = kst.kolmogorovSmirnovTest(x, y);     }      /**      * Checks that fixTies eliminates ties in the data but does not otherwise      * perturb the ordering.      */     private void checkFixTies(double[] x, double[] y) throws Exception {         final double[] origCombined = MathArrays.concatenate(x, y);         fixTies(x, y);         Assert.assertFalse(hasTies(x, y));         final double[] combined = MathArrays.concatenate(x, y);         for (int i = 0; i < combined.length; i++) {             for (int j = 0; j < i; j++) {                 Assert.assertTrue(combined[i] != combined[j]);                 if (combined[i] < combined[j]) {                     Assert.assertTrue(origCombined[i] < origCombined[j]                                       || origCombined[i] == origCombined[j]);                 }             }          }     }      /**      * Verifies the inequality exactP(criticalValue, n, m, true) < alpha < exactP(criticalValue, n,      * m, false).      *      * Note that the validity of this check depends on the fact that alpha lies strictly between two      * attained values of the distribution and that criticalValue is one of the attained values. The      * critical value table (reference below) uses attained values. This test therefore also      * verifies that criticalValue is attained.      *      * @param n first sample size      * @param m second sample size      * @param criticalValue critical value      * @param alpha significance level      */     private void checkExactTable(int n, int m, double criticalValue, double alpha) {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertTrue(test.exactP(criticalValue, n, m, true) < alpha);         Assert.assertTrue(test.exactP(criticalValue, n, m, false) > alpha);     }      /**      * Verifies that approximateP(criticalValue, n, m) is within epsilon of alpha.      *      * @param n first sample size      * @param m second sample size      * @param criticalValue critical value (from table)      * @param alpha significance level      * @param epsilon tolerance      */     private void checkApproximateTable(int n, int m, double criticalValue, double alpha, double epsilon) {         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();         Assert.assertEquals(alpha, test.approximateP(criticalValue, n, m), epsilon);     }      /**      * Reflection hack to expose private fixTies method for testing.      */     private static void fixTies(double[] x, double[] y) throws Exception {         Method method = KolmogorovSmirnovTest.class.getDeclaredMethod("fixTies",                                                                       double[].class, double[].class);         method.setAccessible(true);         method.invoke(KolmogorovSmirnovTest.class, x, y);     }      /**      * Reflection hack to expose private hasTies method.      */     private static boolean hasTies(double[] x, double[] y) throws Exception {         Method method = KolmogorovSmirnovTest.class.getDeclaredMethod("hasTies",                                                                       double[].class, double[].class);         method.setAccessible(true);         return (boolean) method.invoke(KolmogorovSmirnovTest.class, x, y);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.stat.descriptive.SummaryStatistics; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for the OneWayAnovaImpl class.  *  */  public class OneWayAnovaTest {      protected OneWayAnova testStatistic = new OneWayAnova();      private double[] emptyArray = {};      private double[] classA =             {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };     private double[] classB =             {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };     private double[] classC =             {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };      @Test     public void testAnovaFValue() {         // Target comparison values computed using R version 2.6.0 (Linux version)         List<double[]> threeClasses = new ArrayList<>();         threeClasses.add(classA);         threeClasses.add(classB);         threeClasses.add(classC);          Assert.assertEquals("ANOVA F-value",  24.67361709460624,                  testStatistic.anovaFValue(threeClasses), 1E-12);          List<double[]> twoClasses = new ArrayList<>();         twoClasses.add(classA);         twoClasses.add(classB);          Assert.assertEquals("ANOVA F-value",  0.0150579150579,                  testStatistic.anovaFValue(twoClasses), 1E-12);          List<double[]> emptyContents = new ArrayList<>();         emptyContents.add(emptyArray);         emptyContents.add(classC);         try {             testStatistic.anovaFValue(emptyContents);             Assert.fail("empty array for key classX, MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected         }          List<double[]> tooFew = new ArrayList<>();         tooFew.add(classA);         try {             testStatistic.anovaFValue(tooFew);             Assert.fail("less than two classes, MathIllegalArgumentException expected");         } catch (MathIllegalArgumentException ex) {             // expected         }     }       @Test     public void testAnovaPValue() {         // Target comparison values computed using R version 2.6.0 (Linux version)         List<double[]> threeClasses = new ArrayList<>();         threeClasses.add(classA);         threeClasses.add(classB);         threeClasses.add(classC);          Assert.assertEquals("ANOVA P-value", 6.959446E-06,                  testStatistic.anovaPValue(threeClasses), 1E-12);          List<double[]> twoClasses = new ArrayList<>();         twoClasses.add(classA);         twoClasses.add(classB);          Assert.assertEquals("ANOVA P-value",  0.904212960464,                  testStatistic.anovaPValue(twoClasses), 1E-12);      }      @Test     public void testAnovaPValueSummaryStatistics() {         // Target comparison values computed using R version 2.6.0 (Linux version)         List<SummaryStatistics> threeClasses = new ArrayList<>();         SummaryStatistics statsA = new SummaryStatistics();         for (double a : classA) {             statsA.addValue(a);         }         threeClasses.add(statsA);         SummaryStatistics statsB = new SummaryStatistics();         for (double b : classB) {             statsB.addValue(b);         }         threeClasses.add(statsB);         SummaryStatistics statsC = new SummaryStatistics();         for (double c : classC) {             statsC.addValue(c);         }         threeClasses.add(statsC);          Assert.assertEquals("ANOVA P-value", 6.959446E-06,                  testStatistic.anovaPValue(threeClasses, true), 1E-12);          List<SummaryStatistics> twoClasses = new ArrayList<>();         twoClasses.add(statsA);         twoClasses.add(statsB);          Assert.assertEquals("ANOVA P-value",  0.904212960464,                  testStatistic.anovaPValue(twoClasses, false), 1E-12);      }      @Test     public void testAnovaTest() {         // Target comparison values computed using R version 2.3.1 (Linux version)         List<double[]> threeClasses = new ArrayList<>();         threeClasses.add(classA);         threeClasses.add(classB);         threeClasses.add(classC);          Assert.assertTrue("ANOVA Test P<0.01", testStatistic.anovaTest(threeClasses, 0.01));          List<double[]> twoClasses = new ArrayList<>();         twoClasses.add(classA);         twoClasses.add(classB);          Assert.assertFalse("ANOVA Test P>0.01", testStatistic.anovaTest(twoClasses, 0.01));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.exception.ZeroException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the GTest class.  *  * Data for the tests are from p64-69 in: McDonald, J.H. 2009. Handbook of  * Biological Statistics (2nd ed.). Sparky House Publishing, Baltimore,  * Maryland.  *  */ public class GTestTest {      protected GTest testStatistic = new GTest();      @Test     public void testGTestGoodnesOfFit1() throws Exception {         final double[] exp = new double[]{             3d, 1d         };          final long[] obs = new long[]{             423, 133         };          Assert.assertEquals("G test statistic",                 0.348721, testStatistic.g(exp, obs), 1E-6);         final double p_gtgf = testStatistic.gTest(exp, obs);         Assert.assertEquals("g-Test p-value", 0.55483, p_gtgf, 1E-5);          Assert.assertFalse(testStatistic.gTest(exp, obs, 0.05));     }      @Test     public void testGTestGoodnesOfFit2() throws Exception {         final double[] exp = new double[]{             0.54d, 0.40d, 0.05d, 0.01d         };          final long[] obs = new long[]{             70, 79, 3, 4         };         Assert.assertEquals("G test statistic",                 13.144799, testStatistic.g(exp, obs), 1E-6);         final double p_gtgf = testStatistic.gTest(exp, obs);         Assert.assertEquals("g-Test p-value", 0.004333, p_gtgf, 1E-5);          Assert.assertTrue(testStatistic.gTest(exp, obs, 0.05));     }      @Test     public void testGTestGoodnesOfFit3() throws Exception {         final double[] exp = new double[]{             0.167d, 0.483d, 0.350d         };          final long[] obs = new long[]{             14, 21, 25         };          Assert.assertEquals("G test statistic",                 4.5554, testStatistic.g(exp, obs), 1E-4);         // Intrinisic (Hardy-Weinberg proportions) P-Value should be 0.033         final double p_gtgf = testStatistic.gTestIntrinsic(exp, obs);         Assert.assertEquals("g-Test p-value", 0.0328, p_gtgf, 1E-4);          Assert.assertFalse(testStatistic.gTest(exp, obs, 0.05));     }      @Test     public void testGTestIndependence1() throws Exception {         final long[] obs1 = new long[]{             268, 199, 42         };          final long[] obs2 = new long[]{             807, 759, 184         };          final double g = testStatistic.gDataSetsComparison(obs1, obs2);          Assert.assertEquals("G test statistic",                 7.3008170, g, 1E-6);         final double p_gti = testStatistic.gTestDataSetsComparison(obs1, obs2);          Assert.assertEquals("g-Test p-value", 0.0259805, p_gti, 1E-6);         Assert.assertTrue(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05));     }      @Test     public void testGTestIndependence2() throws Exception {         final long[] obs1 = new long[]{             127, 99, 264         };          final long[] obs2 = new long[]{             116, 67, 161         };          final double g = testStatistic.gDataSetsComparison(obs1, obs2);          Assert.assertEquals("G test statistic",                 6.227288, g, 1E-6);         final double p_gti = testStatistic.gTestDataSetsComparison(obs1, obs2);          Assert.assertEquals("g-Test p-value", 0.04443, p_gti, 1E-5);         Assert.assertTrue(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05));     }      @Test     public void testGTestIndependence3() throws Exception {         final long[] obs1 = new long[]{             190, 149         };          final long[] obs2 = new long[]{             42, 49         };          final double g = testStatistic.gDataSetsComparison(obs1, obs2);         Assert.assertEquals("G test statistic",                 2.8187, g, 1E-4);         final double p_gti = testStatistic.gTestDataSetsComparison(obs1, obs2);         Assert.assertEquals("g-Test p-value", 0.09317325, p_gti, 1E-6);          Assert.assertFalse(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05));     }      @Test     public void testGTestSetsComparisonBadCounts() {         long[] observed1 = {10, -1, 12, 10, 15};         long[] observed2 = {15, 10, 10, 15, 5};         try {             testStatistic.gTestDataSetsComparison(                     observed1, observed2);             Assert.fail("Expecting NotPositiveException - negative count");         } catch (NotPositiveException ex) {             // expected         }         long[] observed3 = {10, 0, 12, 10, 15};         long[] observed4 = {15, 0, 10, 15, 5};         try {             testStatistic.gTestDataSetsComparison(                     observed3, observed4);             Assert.fail("Expecting ZeroException - double 0's");         } catch (ZeroException ex) {             // expected         }         long[] observed5 = {10, 10, 12, 10, 15};         long[] observed6 = {0, 0, 0, 0, 0};         try {             testStatistic.gTestDataSetsComparison(                     observed5, observed6);             Assert.fail("Expecting ZeroException - vanishing counts");         } catch (ZeroException ex) {             // expected         }     }      @Test     public void testUnmatchedArrays() {         final long[] observed = { 0, 1, 2, 3 };         final double[] expected = { 1, 1, 2 };         final long[] observed2 = {3, 4};         try {             testStatistic.gTest(expected, observed);             Assert.fail("arrays have different lengths, DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }         try {             testStatistic.gTestDataSetsComparison(observed, observed2);             Assert.fail("arrays have different lengths, DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }     }      @Test     public void testNegativeObservedCounts() {         final long[] observed = { 0, 1, 2, -3 };         final double[] expected = { 1, 1, 2, 3};         final long[] observed2 = {3, 4, 5, 0};         try {             testStatistic.gTest(expected, observed);             Assert.fail("negative observed count, NotPositiveException expected");         } catch (NotPositiveException ex) {             // expected         }         try {             testStatistic.gTestDataSetsComparison(observed, observed2);             Assert.fail("negative observed count, NotPositiveException expected");         } catch (NotPositiveException ex) {             // expected         }     }      @Test     public void testZeroExpectedCounts() {         final long[] observed = { 0, 1, 2, -3 };         final double[] expected = { 1, 0, 2, 3};         try {             testStatistic.gTest(expected, observed);             Assert.fail("zero expected count, NotStrictlyPositiveException expected");         } catch (NotStrictlyPositiveException ex) {             // expected         }     }      @Test     public void testBadAlpha() {         final long[] observed = { 0, 1, 2, 3 };         final double[] expected = { 1, 2, 2, 3};         final long[] observed2 = { 0, 2, 2, 3 };         try {             testStatistic.gTest(expected, observed, 0.8);             Assert.fail("zero expected count, NotStrictlyPositiveException expected");         } catch (OutOfRangeException ex) {             // expected         }         try {             testStatistic.gTestDataSetsComparison(observed, observed2, -0.5);             Assert.fail("zero expected count, NotStrictlyPositiveException expected");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testScaling() {       final long[] observed = {9, 11, 10, 8, 12};       final double[] expected1 = {10, 10, 10, 10, 10};       final double[] expected2 = {1000, 1000, 1000, 1000, 1000};       final double[] expected3 = {1, 1, 1, 1, 1};       final double tol = 1E-15;       Assert.assertEquals(               testStatistic.gTest(expected1, observed),               testStatistic.gTest(expected2, observed),               tol);       Assert.assertEquals(               testStatistic.gTest(expected1, observed),               testStatistic.gTest(expected3, observed),               tol);     }      @Test     public void testRootLogLikelihood() {         // positive where k11 is bigger than expected.         Assert.assertTrue(testStatistic.rootLogLikelihoodRatio(904, 21060, 1144, 283012) > 0.0);          // negative because k11 is lower than expected         Assert.assertTrue(testStatistic.rootLogLikelihoodRatio(36, 21928, 60280, 623876) < 0.0);          Assert.assertEquals(FastMath.sqrt(2.772589), testStatistic.rootLogLikelihoodRatio(1, 0, 0, 1), 0.000001);         Assert.assertEquals(-FastMath.sqrt(2.772589), testStatistic.rootLogLikelihoodRatio(0, 1, 1, 0), 0.000001);         Assert.assertEquals(FastMath.sqrt(27.72589), testStatistic.rootLogLikelihoodRatio(10, 0, 0, 10), 0.00001);          Assert.assertEquals(FastMath.sqrt(39.33052), testStatistic.rootLogLikelihoodRatio(5, 1995, 0, 100000), 0.00001);         Assert.assertEquals(-FastMath.sqrt(39.33052), testStatistic.rootLogLikelihoodRatio(0, 100000, 5, 1995), 0.00001);          Assert.assertEquals(FastMath.sqrt(4730.737), testStatistic.rootLogLikelihoodRatio(1000, 1995, 1000, 100000), 0.001);         Assert.assertEquals(-FastMath.sqrt(4730.737), testStatistic.rootLogLikelihoodRatio(1000, 100000, 1000, 1995), 0.001);          Assert.assertEquals(FastMath.sqrt(5734.343), testStatistic.rootLogLikelihoodRatio(1000, 1000, 1000, 100000), 0.001);         Assert.assertEquals(FastMath.sqrt(5714.932), testStatistic.rootLogLikelihoodRatio(1000, 1000, 1000, 99000), 0.001);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.inference;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for the WilcoxonSignedRangTest class.  *  */  public class WilcoxonSignedRankTestTest {      protected WilcoxonSignedRankTest testStatistic = new WilcoxonSignedRankTest();      @Test     public void testWilcoxonSignedRankSimple() {         /* Target values computed using R version 2.11.1          * x <- c(1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30)          * y <- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29)          */         final double x[] = {1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30};         final double y[] = {0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29};          /* EXACT:          * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = TRUE, correct = FALSE)          * V = 40, p-value = 0.03906          *          * Corresponds to the value obtained in R.          */         Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);         Assert.assertEquals(0.03906, testStatistic.wilcoxonSignedRankTest(x, y, true), 1e-5);          /* ASYMPTOTIC:          * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = FALSE, correct = FALSE)          * V = 40, p-value = 0.03815          *          * This is not entirely the same due to different corrects,          * e.g. http://mlsc.lboro.ac.uk/resources/statistics/wsrt.pdf          * and src/library/stats/R/wilcox.test.R in the R source          */         Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);         Assert.assertEquals(0.0329693812, testStatistic.wilcoxonSignedRankTest(x, y, false), 1e-10);     }      @Test     public void testWilcoxonSignedRankInputValidation() {         /*          * Exact only for sample size <= 30          */         final double[] x1 = new double[30];         final double[] x2 = new double[31];         final double[] y1 = new double[30];         final double[] y2 = new double[31];         for (int i = 0; i < 30; ++i) {             x1[i] = x2[i] = y1[i] = y2[i] = i;         }          // Exactly 30 is okay         //testStatistic.wilcoxonSignedRankTest(x1, y1, true);          try {             testStatistic.wilcoxonSignedRankTest(x2, y2, true);             Assert.fail("More than 30 samples and exact chosen, NumberIsTooLargeException expected");         } catch (NumberIsTooLargeException ex) {             // expected         }          /* Samples must be present, i.e. length > 0          */         try {             testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, true);             Assert.fail("x does not contain samples (exact), NoDataException expected");         } catch (NoDataException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, false);             Assert.fail("x does not contain samples (asymptotic), NoDataException expected");         } catch (NoDataException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, true);             Assert.fail("y does not contain samples (exact), NoDataException expected");         } catch (NoDataException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, false);             Assert.fail("y does not contain samples (asymptotic), NoDataException expected");         } catch (NoDataException ex) {             // expected         }          /* Samples not same size, i.e. cannot be paired          */         try {             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, true);             Assert.fail("x and y not same size (exact), DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, false);             Assert.fail("x and y not same size (asymptotic), DimensionMismatchException expected");         } catch (DimensionMismatchException ex) {             // expected         }          /*          * x and y is null          */         try {             testStatistic.wilcoxonSignedRankTest(null, null, true);             Assert.fail("x and y is null (exact), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(null, null, false);             Assert.fail("x and y is null (asymptotic), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          /*          * x or y is null          */         try {             testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, true);             Assert.fail("x is null (exact), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, false);             Assert.fail("x is null (asymptotic), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, true);             Assert.fail("y is null (exact), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }          try {             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, false);             Assert.fail("y is null (asymptotic), NullArgumentException expected");         } catch (NullArgumentException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat;  import java.io.BufferedReader; import java.io.StringReader; import java.util.ArrayList; import java.util.Iterator; import java.util.List;  import org.apache.commons.math4.TestUtils; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link Frequency} class.  *  */ public final class FrequencyTest {     private static final long ONE_LONG = 1L;     private static final long TWO_LONG = 2L;     private static final long THREE_LONG = 3L;     private static final int ONE = 1;     private static final int TWO = 2;     private static final int THREE = 3 ;     private static final double TOLERANCE = 10E-15d;      /** test freq counts */     @Test     public void testCounts() {         Frequency<Long> fLong = new Frequency<>();         Assert.assertEquals("total count",0,fLong.getSumFreq());         fLong.addValue(ONE_LONG);         fLong.addValue(TWO_LONG);         fLong.addValue(1l);         fLong.addValue(ONE_LONG);         Assert.assertEquals("one frequency count",3,fLong.getCount(1l));         Assert.assertEquals("two frequency count",1,fLong.getCount(2l));         Assert.assertEquals("three frequency count",0,fLong.getCount(3l));         Assert.assertEquals("total count",4,fLong.getSumFreq());         Assert.assertEquals("zero cumulative frequency", 0, fLong.getCumFreq(0l));         Assert.assertEquals("one cumulative frequency", 3,  fLong.getCumFreq(1l));         Assert.assertEquals("two cumulative frequency", 4,  fLong.getCumFreq(2l));         Assert.assertEquals("Integer argument cum freq",4, fLong.getCumFreq(Long.valueOf(2)));         Assert.assertEquals("five cumulative frequency", 4,  fLong.getCumFreq(5l));         Assert.assertEquals("foo cumulative frequency", 0,  fLong.getCumFreq(-1l));          fLong.clear();         Assert.assertEquals("total count",0,fLong.getSumFreq());          // userguide examples -------------------------------------------------------------------         Frequency<String> fString = new Frequency<>();         fString.addValue("one");         fString.addValue("One");         fString.addValue("oNe");         fString.addValue("Z");         Assert.assertEquals("one cumulative frequency", 1 , fString.getCount("one"));         Assert.assertEquals("Z cumulative pct", 0.5,  fString.getCumPct("Z"), TOLERANCE);         Assert.assertEquals("z cumulative pct", 1.0,  fString.getCumPct("z"), TOLERANCE);         Assert.assertEquals("Ot cumulative pct", 0.25,  fString.getCumPct("Ot"), TOLERANCE);          Frequency<Integer> fInteger = new Frequency<>();         fInteger.addValue(1);         fInteger.addValue(Integer.valueOf(1));         fInteger.addValue(ONE);         fInteger.addValue(2);         fInteger.addValue(Integer.valueOf(-1));         Assert.assertEquals("1 count", 3, fInteger.getCount(1));         Assert.assertEquals("1 count", 3, fInteger.getCount(Integer.valueOf(1)));         Assert.assertEquals("0 cum pct", 0.2, fInteger.getCumPct(0), TOLERANCE);         Assert.assertEquals("1 pct", 0.6, fInteger.getPct(Integer.valueOf(1)), TOLERANCE);         Assert.assertEquals("-2 cum pct", 0, fInteger.getCumPct(-2), TOLERANCE);         Assert.assertEquals("10 cum pct", 1, fInteger.getCumPct(10), TOLERANCE);          fString = new Frequency<String>(String.CASE_INSENSITIVE_ORDER);         fString.addValue("one");         fString.addValue("One");         fString.addValue("oNe");         fString.addValue("Z");         Assert.assertEquals("one count", 3 ,  fString.getCount("one"));         Assert.assertEquals("Z cumulative pct -- case insensitive", 1 ,  fString.getCumPct("Z"), TOLERANCE);         Assert.assertEquals("z cumulative pct -- case insensitive", 1 ,  fString.getCumPct("z"), TOLERANCE);          Frequency<Character> fChar = new Frequency<>();         Assert.assertEquals(0L, fChar.getCount('a'));         Assert.assertEquals(0L, fChar.getCumFreq('b'));         TestUtils.assertEquals(Double.NaN, fChar.getPct('a'), 0.0);         TestUtils.assertEquals(Double.NaN, fChar.getCumPct('b'), 0.0);         fChar.addValue('a');         fChar.addValue('b');         fChar.addValue('c');         fChar.addValue('d');         Assert.assertEquals(1L, fChar.getCount('a'));         Assert.assertEquals(2L, fChar.getCumFreq('b'));         Assert.assertEquals(0.25, fChar.getPct('a'), 0.0);         Assert.assertEquals(0.5, fChar.getCumPct('b'), 0.0);         Assert.assertEquals(1.0, fChar.getCumPct('e'), 0.0);     }      /** test pcts */     @Test     public void testPcts() {         Frequency<Long> f = new Frequency<>();         f.addValue(ONE_LONG);         f.addValue(TWO_LONG);         f.addValue(THREE_LONG);         f.addValue(THREE_LONG);         Assert.assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),TOLERANCE);         Assert.assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),TOLERANCE);         Assert.assertEquals("three cum pct",1.0,f.getCumPct(THREE_LONG),TOLERANCE);     }      /** test adding incomparable values */     @Test     public void testAdd() {         Frequency<Character> f = new Frequency<>();         char aChar = 'a';         char bChar = 'b';         f.addValue(aChar);         f.addValue(bChar);         Assert.assertEquals("a pct",0.5,f.getPct(aChar),TOLERANCE);         Assert.assertEquals("b cum pct",1.0,f.getCumPct(bChar),TOLERANCE);     }      /** test empty table */     @Test     public void testEmptyTable() {         Frequency<Integer> f = new Frequency<>();         Assert.assertEquals("freq sum, empty table", 0, f.getSumFreq());         Assert.assertEquals("count, empty table", 0, f.getCount(0));         Assert.assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0)));         Assert.assertEquals("cum freq, empty table", 0, f.getCumFreq(0));         Assert.assertTrue("pct, empty table", Double.isNaN(f.getPct(0)));         Assert.assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0))));         Assert.assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0)));         Assert.assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0))));     }      /**      * Tests toString()      */     @Test     public void testToString() throws Exception {         Frequency<Long> f = new Frequency<>();         f.addValue(ONE_LONG);         f.addValue(TWO_LONG);          String s = f.toString();         //System.out.println(s);         Assert.assertNotNull(s);         BufferedReader reader = new BufferedReader(new StringReader(s));         String line = reader.readLine(); // header line         Assert.assertNotNull(line);          line = reader.readLine(); // one's or two's line         Assert.assertNotNull(line);     }      @Test     public void testIntegerValues() {         Frequency<Integer> f = new Frequency<>();         f.addValue(Integer.valueOf(1));         f.addValue(1);         f.addValue(2);         f.addValue(Integer.valueOf(2));         Assert.assertEquals("Integer 1 count", 2, f.getCount(1));         Assert.assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1)));         Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), TOLERANCE);         Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), TOLERANCE);          f.incrementValue(ONE, -2);         f.incrementValue(THREE, 5);          Assert.assertEquals("Integer 1 count", 0, f.getCount(1));         Assert.assertEquals("Integer 3 count", 5, f.getCount(3));          Iterator<?> it = f.valuesIterator();         while (it.hasNext()) {             Assert.assertTrue(it.next() instanceof Integer);         }     }      @Test     public void testSerial() {         Frequency<Integer> f = new Frequency<>();         f.addValue(ONE);         f.addValue(TWO);         Assert.assertEquals(f, TestUtils.serializeAndRecover(f));     }      @Test     public void testGetUniqueCount() {         Frequency<Long> f = new Frequency<>();         Assert.assertEquals(0, f.getUniqueCount());         f.addValue(ONE_LONG);         Assert.assertEquals(1, f.getUniqueCount());         f.addValue(ONE_LONG);         Assert.assertEquals(1, f.getUniqueCount());         f.addValue(TWO_LONG);         Assert.assertEquals(2, f.getUniqueCount());     }      @Test     public void testIncrement() {         Frequency<Long> f = new Frequency<>();         Assert.assertEquals(0, f.getUniqueCount());         f.incrementValue(ONE_LONG, 1);         Assert.assertEquals(1, f.getCount(ONE_LONG));          f.incrementValue(ONE_LONG, 4);         Assert.assertEquals(5, f.getCount(ONE_LONG));          f.incrementValue(ONE_LONG, -5);         Assert.assertEquals(0, f.getCount(ONE_LONG));     }      @Test     public void testMerge() {         Frequency<Long> f = new Frequency<>();         Assert.assertEquals(0, f.getUniqueCount());         f.addValue(ONE_LONG);         f.addValue(TWO_LONG);         f.addValue(ONE_LONG);         f.addValue(TWO_LONG);          Assert.assertEquals(2, f.getUniqueCount());         Assert.assertEquals(2, f.getCount(ONE_LONG));         Assert.assertEquals(2, f.getCount(TWO_LONG));          Frequency<Long> g = new Frequency<>();         g.addValue(ONE_LONG);         g.addValue(THREE_LONG);         g.addValue(THREE_LONG);          Assert.assertEquals(2, g.getUniqueCount());         Assert.assertEquals(1, g.getCount(ONE_LONG));         Assert.assertEquals(2, g.getCount(THREE_LONG));          f.merge(g);          Assert.assertEquals(3, f.getUniqueCount());         Assert.assertEquals(3, f.getCount(ONE_LONG));         Assert.assertEquals(2, f.getCount(TWO_LONG));         Assert.assertEquals(2, f.getCount(THREE_LONG));     }      @Test     public void testMergeCollection() {         Frequency<Long> f = new Frequency<>();         Assert.assertEquals(0, f.getUniqueCount());         f.addValue(ONE_LONG);          Assert.assertEquals(1, f.getUniqueCount());         Assert.assertEquals(1, f.getCount(ONE_LONG));         Assert.assertEquals(0, f.getCount(TWO_LONG));          Frequency<Long> g = new Frequency<Long>();         g.addValue(TWO_LONG);          Frequency<Long> h = new Frequency<Long>();         h.addValue(THREE_LONG);          List<Frequency<Long>> coll = new ArrayList<>();         coll.add(g);         coll.add(h);         f.merge(coll);          Assert.assertEquals(3, f.getUniqueCount());         Assert.assertEquals(1, f.getCount(ONE_LONG));         Assert.assertEquals(1, f.getCount(TWO_LONG));         Assert.assertEquals(1, f.getCount(THREE_LONG));     }      @Test     public void testMode() {         Frequency<String> f = new Frequency<>();         List<String> mode;         mode = f.getMode();         Assert.assertEquals(0, mode.size());          f.addValue("3");         mode = f.getMode();         Assert.assertEquals(1, mode.size());         Assert.assertEquals("3", mode.get(0));          f.addValue("2");         mode = f.getMode();         Assert.assertEquals(2, mode.size());         Assert.assertEquals("2", mode.get(0));         Assert.assertEquals("3",mode.get(1));          f.addValue("2");         mode = f.getMode();         Assert.assertEquals(1, mode.size());         Assert.assertEquals("2", mode.get(0));         Assert.assertFalse(mode.contains("1"));         Assert.assertTrue(mode.contains("2"));     }      @Test     public void testModeDoubleNan() {         Frequency<Double> f = new Frequency<>();         List<Double> mode;         f.addValue(Double.valueOf(Double.NaN));         f.addValue(Double.valueOf(Double.NaN));         f.addValue(Double.valueOf(Double.NaN));         f.addValue(Double.valueOf(Double.NEGATIVE_INFINITY));         f.addValue(Double.valueOf(Double.POSITIVE_INFINITY));         f.addValue(Double.valueOf(Double.NEGATIVE_INFINITY));         f.addValue(Double.valueOf(Double.POSITIVE_INFINITY));         f.addValue(Double.valueOf(Double.NEGATIVE_INFINITY));         f.addValue(Double.valueOf(Double.POSITIVE_INFINITY));         mode = f.getMode();         Assert.assertEquals(3, mode.size());         Assert.assertEquals(Double.valueOf(Double.NEGATIVE_INFINITY), mode.get(0));         Assert.assertEquals(Double.valueOf(Double.POSITIVE_INFINITY), mode.get(1));         Assert.assertEquals(Double.valueOf(Double.NaN), mode.get(2));     }      @Test     public void testModeFloatNan() {         Frequency<Float> f = new Frequency<>();         List<Float> mode;         f.addValue(Float.valueOf(Float.NaN));         f.addValue(Float.valueOf(Float.NaN));         f.addValue(Float.valueOf(Float.NaN));         f.addValue(Float.valueOf(Float.NEGATIVE_INFINITY));         f.addValue(Float.valueOf(Float.POSITIVE_INFINITY));         f.addValue(Float.valueOf(Float.NEGATIVE_INFINITY));         f.addValue(Float.valueOf(Float.POSITIVE_INFINITY));         f.addValue(Float.valueOf(Float.NEGATIVE_INFINITY));         f.addValue(Float.valueOf(Float.POSITIVE_INFINITY));         mode = f.getMode();         Assert.assertEquals(3, mode.size());         Assert.assertEquals(Float.valueOf(Float.NEGATIVE_INFINITY), mode.get(0));         Assert.assertEquals(Float.valueOf(Float.POSITIVE_INFINITY), mode.get(1));         Assert.assertEquals(Float.valueOf(Float.NaN), mode.get(2));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.regression;  import java.util.Random;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for the TestStatistic class.  *  */  public final class SimpleRegressionTest {      /*      * NIST "Norris" reference data set from      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat      * Strangely, order is {y,x}      */     private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 },             {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 },             {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 },             {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 },             {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 },             {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 },             {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 },             {449.2, 448.9 }, {0.2, 0.5 }     };      /*      * Correlation example from      * http://www.xycoon.com/correlation.htm      */     private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 },             {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 },             {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 },             {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }     };      /*      * From Moore and Mcabe, "Introduction to the Practice of Statistics"      * Example 10.3      */     private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },             {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }     };      /*      * Points to remove in the remove tests      */     private double[][] removeSingle = {infData[1]};     private double[][] removeMultiple = { infData[1], infData[2] };     private double removeX = infData[0][0];     private double removeY = infData[0][1];       /*      * Data with bad linear fit      */     private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },             {5, -1 }, {6, 12 }     };       /*      * Data from NIST NOINT1      */     private double[][] noint1 = {         {130.0,60.0},         {131.0,61.0},         {132.0,62.0},         {133.0,63.0},         {134.0,64.0},         {135.0,65.0},         {136.0,66.0},         {137.0,67.0},         {138.0,68.0},         {139.0,69.0},         {140.0,70.0}     };      /*      * Data from NIST NOINT2      *      */     private double[][] noint2 = {         {3.0,4},         {4,5},         {4,6}     };       /**      * Test that the SimpleRegression objects generated from combining two      * SimpleRegression objects created from subsets of data are identical to      * SimpleRegression objects created from the combined data.      */     @Test     public void testAppend() {         check(false);         check(true);     }      /**      * Checks that adding data to a single model gives the same result      * as adding "parts" of the dataset to smaller models and using append      * to aggregate the smaller models.      *      * @param includeIntercept      */     private void check(boolean includeIntercept) {         final int sets = 2;         final UniformRandomProvider rand = RandomSource.create(RandomSource.ISAAC, 10L);// Seed can be changed         final SimpleRegression whole = new SimpleRegression(includeIntercept);// regression of the whole set         final SimpleRegression parts = new SimpleRegression(includeIntercept);// regression with parts.          for (int s = 0; s < sets; s++) {// loop through each subset of data.             final double coef = rand.nextDouble();             final SimpleRegression sub = new SimpleRegression(includeIntercept);// sub regression             for (int i = 0; i < 5; i++) { // loop through individual samlpes.                 final double x = rand.nextDouble();                 final double y = x * coef + rand.nextDouble();// some noise                 sub.addData(x, y);                 whole.addData(x, y);             }             parts.append(sub);             Assert.assertTrue(equals(parts, whole, 1E-6));         }     }      /**      * Returns true iff the statistics reported by model1 are all within tol of      * those reported by model2.      *      * @param model1 first model      * @param model2 second model      * @param tol tolerance      * @return true if the two models report the same regression stats      */     private boolean equals(SimpleRegression model1, SimpleRegression model2, double tol) {         if (model1.getN() != model2.getN()) {             return false;         }         if (FastMath.abs(model1.getIntercept() - model2.getIntercept()) > tol) {             return false;         }         if (FastMath.abs(model1.getInterceptStdErr() - model2.getInterceptStdErr()) > tol) {             return false;         }         if (FastMath.abs(model1.getMeanSquareError() - model2.getMeanSquareError()) > tol) {             return false;         }         if (FastMath.abs(model1.getR() - model2.getR()) > tol) {             return false;         }         if (FastMath.abs(model1.getRegressionSumSquares() - model2.getRegressionSumSquares()) > tol) {             return false;         }         if (FastMath.abs(model1.getRSquare() - model2.getRSquare()) > tol) {             return false;         }         if (FastMath.abs(model1.getSignificance() - model2.getSignificance()) > tol) {             return false;         }         if (FastMath.abs(model1.getSlope() - model2.getSlope()) > tol) {             return false;         }         if (FastMath.abs(model1.getSlopeConfidenceInterval() - model2.getSlopeConfidenceInterval()) > tol) {             return false;         }         if (FastMath.abs(model1.getSlopeStdErr() - model2.getSlopeStdErr()) > tol) {             return false;         }         if (FastMath.abs(model1.getSumOfCrossProducts() - model2.getSumOfCrossProducts()) > tol) {             return false;         }         if (FastMath.abs(model1.getSumSquaredErrors() - model2.getSumSquaredErrors()) > tol) {             return false;         }         if (FastMath.abs(model1.getTotalSumSquares() - model2.getTotalSumSquares()) > tol) {             return false;         }         if (FastMath.abs(model1.getXSumSquares() - model2.getXSumSquares()) > tol) {             return false;         }         return true;     }      @Test     public void testRegressIfaceMethod(){         final SimpleRegression regression = new SimpleRegression(true);         final UpdatingMultipleLinearRegression iface = regression;         final SimpleRegression regressionNoint = new SimpleRegression( false );         final SimpleRegression regressionIntOnly= new SimpleRegression( false );         for (int i = 0; i < data.length; i++) {             iface.addObservation( new double[]{data[i][1]}, data[i][0]);             regressionNoint.addData(data[i][1], data[i][0]);             regressionIntOnly.addData(1.0, data[i][0]);         }          //should not be null         final RegressionResults fullReg = iface.regress( );         Assert.assertNotNull(fullReg);         Assert.assertEquals("intercept", regression.getIntercept(), fullReg.getParameterEstimate(0), 1.0e-16);         Assert.assertEquals("intercept std err",regression.getInterceptStdErr(), fullReg.getStdErrorOfEstimate(0),1.0E-16);         Assert.assertEquals("slope", regression.getSlope(), fullReg.getParameterEstimate(1), 1.0e-16);         Assert.assertEquals("slope std err",regression.getSlopeStdErr(), fullReg.getStdErrorOfEstimate(1),1.0E-16);         Assert.assertEquals("number of observations",regression.getN(), fullReg.getN());         Assert.assertEquals("r-square",regression.getRSquare(), fullReg.getRSquared(), 1.0E-16);         Assert.assertEquals("SSR", regression.getRegressionSumSquares(), fullReg.getRegressionSumSquares() ,1.0E-16);         Assert.assertEquals("MSE", regression.getMeanSquareError(), fullReg.getMeanSquareError() ,1.0E-16);         Assert.assertEquals("SSE", regression.getSumSquaredErrors(), fullReg.getErrorSumSquares() ,1.0E-16);           final RegressionResults noInt   = iface.regress( new int[]{1} );         Assert.assertNotNull(noInt);         Assert.assertEquals("slope", regressionNoint.getSlope(), noInt.getParameterEstimate(0), 1.0e-12);         Assert.assertEquals("slope std err",regressionNoint.getSlopeStdErr(), noInt.getStdErrorOfEstimate(0),1.0E-16);         Assert.assertEquals("number of observations",regressionNoint.getN(), noInt.getN());         Assert.assertEquals("r-square",regressionNoint.getRSquare(), noInt.getRSquared(), 1.0E-16);         Assert.assertEquals("SSR", regressionNoint.getRegressionSumSquares(), noInt.getRegressionSumSquares() ,1.0E-8);         Assert.assertEquals("MSE", regressionNoint.getMeanSquareError(), noInt.getMeanSquareError() ,1.0E-16);         Assert.assertEquals("SSE", regressionNoint.getSumSquaredErrors(), noInt.getErrorSumSquares() ,1.0E-16);          final RegressionResults onlyInt = iface.regress( new int[]{0} );         Assert.assertNotNull(onlyInt);         Assert.assertEquals("slope", regressionIntOnly.getSlope(), onlyInt.getParameterEstimate(0), 1.0e-12);         Assert.assertEquals("slope std err",regressionIntOnly.getSlopeStdErr(), onlyInt.getStdErrorOfEstimate(0),1.0E-12);         Assert.assertEquals("number of observations",regressionIntOnly.getN(), onlyInt.getN());         Assert.assertEquals("r-square",regressionIntOnly.getRSquare(), onlyInt.getRSquared(), 1.0E-14);         Assert.assertEquals("SSE", regressionIntOnly.getSumSquaredErrors(), onlyInt.getErrorSumSquares() ,1.0E-8);         Assert.assertEquals("SSR", regressionIntOnly.getRegressionSumSquares(), onlyInt.getRegressionSumSquares() ,1.0E-8);         Assert.assertEquals("MSE", regressionIntOnly.getMeanSquareError(), onlyInt.getMeanSquareError() ,1.0E-8);      }      /**      * Verify that regress generates exceptions as advertised for bad model specifications.      */     @Test     public void testRegressExceptions() {         // No intercept         final SimpleRegression noIntRegression = new SimpleRegression(false);         noIntRegression.addData(noint2[0][1], noint2[0][0]);         noIntRegression.addData(noint2[1][1], noint2[1][0]);         noIntRegression.addData(noint2[2][1], noint2[2][0]);         try { // null array             noIntRegression.regress(null);             Assert.fail("Expecting MathIllegalArgumentException for null array");         } catch (MathIllegalArgumentException ex) {             // Expected         }         try { // empty array             noIntRegression.regress(new int[] {});             Assert.fail("Expecting MathIllegalArgumentException for empty array");         } catch (MathIllegalArgumentException ex) {             // Expected         }         try { // more than 1 regressor             noIntRegression.regress(new int[] {0, 1});             Assert.fail("Expecting ModelSpecificationException - too many regressors");         } catch (ModelSpecificationException ex) {             // Expected         }         try { // invalid regressor             noIntRegression.regress(new int[] {1});             Assert.fail("Expecting OutOfRangeException - invalid regression");         } catch (OutOfRangeException ex) {             // Expected         }          // With intercept         final SimpleRegression regression = new SimpleRegression(true);         regression.addData(noint2[0][1], noint2[0][0]);         regression.addData(noint2[1][1], noint2[1][0]);         regression.addData(noint2[2][1], noint2[2][0]);         try { // null array             regression.regress(null);             Assert.fail("Expecting MathIllegalArgumentException for null array");         } catch (MathIllegalArgumentException ex) {             // Expected         }         try { // empty array             regression.regress(new int[] {});             Assert.fail("Expecting MathIllegalArgumentException for empty array");         } catch (MathIllegalArgumentException ex) {             // Expected         }         try { // more than 2 regressors             regression.regress(new int[] {0, 1, 2});             Assert.fail("Expecting ModelSpecificationException - too many regressors");         } catch (ModelSpecificationException ex) {             // Expected         }         try { // wrong order             regression.regress(new int[] {1,0});             Assert.fail("Expecting ModelSpecificationException - invalid regression");         } catch (ModelSpecificationException ex) {             // Expected         }         try { // out of range             regression.regress(new int[] {3,4});             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // Expected         }         try { // out of range             regression.regress(new int[] {0,2});             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // Expected         }         try { // out of range             regression.regress(new int[] {2});             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // Expected         }     }      @Test     public void testNoInterceot_noint2(){          SimpleRegression regression = new SimpleRegression(false);          regression.addData(noint2[0][1], noint2[0][0]);          regression.addData(noint2[1][1], noint2[1][0]);          regression.addData(noint2[2][1], noint2[2][0]);          Assert.assertEquals("intercept", 0, regression.getIntercept(), 0);          Assert.assertEquals("slope", 0.727272727272727,                  regression.getSlope(), 10E-12);          Assert.assertEquals("slope std err", 0.420827318078432E-01,                 regression.getSlopeStdErr(),10E-12);         Assert.assertEquals("number of observations", 3, regression.getN());         Assert.assertEquals("r-square", 0.993348115299335,             regression.getRSquare(), 10E-12);         Assert.assertEquals("SSR", 40.7272727272727,             regression.getRegressionSumSquares(), 10E-9);         Assert.assertEquals("MSE", 0.136363636363636,             regression.getMeanSquareError(), 10E-10);         Assert.assertEquals("SSE", 0.272727272727273,             regression.getSumSquaredErrors(),10E-9);     }      @Test     public void testNoIntercept_noint1(){         SimpleRegression regression = new SimpleRegression(false);         for (int i = 0; i < noint1.length; i++) {             regression.addData(noint1[i][1], noint1[i][0]);         }         Assert.assertEquals("intercept", 0, regression.getIntercept(), 0);         Assert.assertEquals("slope", 2.07438016528926, regression.getSlope(), 10E-12);         Assert.assertEquals("slope std err", 0.165289256198347E-01,                 regression.getSlopeStdErr(),10E-12);         Assert.assertEquals("number of observations", 11, regression.getN());         Assert.assertEquals("r-square", 0.999365492298663,             regression.getRSquare(), 10E-12);         Assert.assertEquals("SSR", 200457.727272727,             regression.getRegressionSumSquares(), 10E-9);         Assert.assertEquals("MSE", 12.7272727272727,             regression.getMeanSquareError(), 10E-10);         Assert.assertEquals("SSE", 127.272727272727,             regression.getSumSquaredErrors(),10E-9);      }      @Test     public void testNorris() {         SimpleRegression regression = new SimpleRegression();         for (int i = 0; i < data.length; i++) {             regression.addData(data[i][1], data[i][0]);         }         // Tests against certified values from         // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat         Assert.assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);         Assert.assertEquals("slope std err", 0.429796848199937E-03,                 regression.getSlopeStdErr(),10E-12);         Assert.assertEquals("number of observations", 36, regression.getN());         Assert.assertEquals( "intercept", -0.262323073774029,             regression.getIntercept(),10E-12);         Assert.assertEquals("std err intercept", 0.232818234301152,             regression.getInterceptStdErr(),10E-12);         Assert.assertEquals("r-square", 0.999993745883712,             regression.getRSquare(), 10E-12);         Assert.assertEquals("SSR", 4255954.13232369,             regression.getRegressionSumSquares(), 10E-9);         Assert.assertEquals("MSE", 0.782864662630069,             regression.getMeanSquareError(), 10E-10);         Assert.assertEquals("SSE", 26.6173985294224,             regression.getSumSquaredErrors(),10E-9);         // ------------  End certified data tests          Assert.assertEquals( "predict(0)",  -0.262323073774029,             regression.predict(0), 10E-12);         Assert.assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,             regression.predict(1), 10E-12);     }      @Test     public void testCorr() {         SimpleRegression regression = new SimpleRegression();         regression.addData(corrData);         Assert.assertEquals("number of observations", 17, regression.getN());         Assert.assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);         Assert.assertEquals("r", -0.94663767742, regression.getR(), 1E-10);     }      @Test     public void testNaNs() {         SimpleRegression regression = new SimpleRegression();         Assert.assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));         Assert.assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));         Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));         Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));         Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));         Assert.assertTrue("e not NaN", Double.isNaN(regression.getR()));         Assert.assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));         Assert.assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));         Assert.assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));         Assert.assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));         Assert.assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));          regression.addData(1, 2);         regression.addData(1, 3);          // No x variation, so these should still blow...         Assert.assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));         Assert.assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));         Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));         Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));         Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));         Assert.assertTrue("e not NaN", Double.isNaN(regression.getR()));         Assert.assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));         Assert.assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));         Assert.assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));         Assert.assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));          // but SSTO should be OK         Assert.assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));          regression = new SimpleRegression();          regression.addData(1, 2);         regression.addData(3, 3);          // All should be OK except MSE, s(b0), s(b1) which need one more df         Assert.assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));         Assert.assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));         Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));         Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));         Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));         Assert.assertTrue("r NaN", !Double.isNaN(regression.getR()));         Assert.assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));         Assert.assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));         Assert.assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));         Assert.assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));         Assert.assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));          regression.addData(1, 4);          // MSE, MSE, s(b0), s(b1) should all be OK now         Assert.assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));         Assert.assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));         Assert.assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));     }      @Test     public void testClear() {         SimpleRegression regression = new SimpleRegression();         regression.addData(corrData);         Assert.assertEquals("number of observations", 17, regression.getN());         regression.clear();         Assert.assertEquals("number of observations", 0, regression.getN());         regression.addData(corrData);         Assert.assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);         regression.addData(data);         Assert.assertEquals("number of observations", 53, regression.getN());     }      @Test     public void testInference() {         //----------  verified against R, version 1.8.1 -----         // infData         SimpleRegression regression = new SimpleRegression();         regression.addData(infData);         Assert.assertEquals("slope std err", 0.011448491,                 regression.getSlopeStdErr(), 1E-10);         Assert.assertEquals("std err intercept", 0.286036932,                 regression.getInterceptStdErr(),1E-8);         Assert.assertEquals("significance", 4.596e-07,                 regression.getSignificance(),1E-8);         Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);         // infData2         regression = new SimpleRegression();         regression.addData(infData2);         Assert.assertEquals("slope std err", 1.07260253,                 regression.getSlopeStdErr(), 1E-8);         Assert.assertEquals("std err intercept",4.17718672,                 regression.getInterceptStdErr(),1E-8);         Assert.assertEquals("significance", 0.261829133982,                 regression.getSignificance(),1E-11);         Assert.assertEquals("slope conf interval half-width", 2.97802204827,                 regression.getSlopeConfidenceInterval(),1E-8);         //------------- End R-verified tests -------------------------------          //FIXME: get a real example to test against with alpha = .01         Assert.assertTrue("tighter means wider",                 regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));          try {             regression.getSlopeConfidenceInterval(1);             Assert.fail("expecting MathIllegalArgumentException for alpha = 1");         } catch (MathIllegalArgumentException ex) {             // ignored         }      }      @Test     public void testPerfect() {         SimpleRegression regression = new SimpleRegression();         int n = 100;         for (int i = 0; i < n; i++) {             regression.addData(((double) i) / (n - 1), i);         }         Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5);         Assert.assertTrue(regression.getSlope() > 0.0);         Assert.assertTrue(regression.getSumSquaredErrors() >= 0.0);     }      @Test     public void testPerfect2() {         SimpleRegression regression = new SimpleRegression();         regression.addData(0, 0);         regression.addData(1, 1);         regression.addData(2, 2);         Assert.assertEquals(0.0, regression.getSlopeStdErr(), 0.0);         Assert.assertEquals(0.0, regression.getSignificance(), Double.MIN_VALUE);         Assert.assertEquals(1, regression.getRSquare(), Double.MIN_VALUE);     }      @Test     public void testPerfectNegative() {         SimpleRegression regression = new SimpleRegression();         int n = 100;         for (int i = 0; i < n; i++) {             regression.addData(- ((double) i) / (n - 1), i);         }          Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5);         Assert.assertTrue(regression.getSlope() < 0.0);     }      @Test     public void testRandom() {         SimpleRegression regression = new SimpleRegression();         Random random = new Random(1);         int n = 100;         for (int i = 0; i < n; i++) {             regression.addData(((double) i) / (n - 1), random.nextDouble());         }          Assert.assertTrue( 0.0 < regression.getSignificance()                     && regression.getSignificance() < 1.0);     }       // Jira MATH-85 = Bugzilla 39432     @Test     public void testSSENonNegative() {         double[] y = { 8915.102, 8919.302, 8923.502 };         double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };         SimpleRegression reg = new SimpleRegression();         for (int i = 0; i < x.length; i++) {             reg.addData(x[i], y[i]);         }         Assert.assertTrue(reg.getSumSquaredErrors() >= 0.0);     }      // Test remove X,Y (single observation)     @Test     public void testRemoveXY() {         // Create regression with inference data then remove to test         SimpleRegression regression = new SimpleRegression();         regression.addData(infData);         regression.removeData(removeX, removeY);         regression.addData(removeX, removeY);         // Use the inference assertions to make sure that everything worked         Assert.assertEquals("slope std err", 0.011448491,                 regression.getSlopeStdErr(), 1E-10);         Assert.assertEquals("std err intercept", 0.286036932,                 regression.getInterceptStdErr(),1E-8);         Assert.assertEquals("significance", 4.596e-07,                 regression.getSignificance(),1E-8);         Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);      }       // Test remove single observation in array     @Test     public void testRemoveSingle() {         // Create regression with inference data then remove to test         SimpleRegression regression = new SimpleRegression();         regression.addData(infData);         regression.removeData(removeSingle);         regression.addData(removeSingle);         // Use the inference assertions to make sure that everything worked         Assert.assertEquals("slope std err", 0.011448491,                 regression.getSlopeStdErr(), 1E-10);         Assert.assertEquals("std err intercept", 0.286036932,                 regression.getInterceptStdErr(),1E-8);         Assert.assertEquals("significance", 4.596e-07,                 regression.getSignificance(),1E-8);         Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);      }      // Test remove multiple observations     @Test     public void testRemoveMultiple() {         // Create regression with inference data then remove to test         SimpleRegression regression = new SimpleRegression();         regression.addData(infData);         regression.removeData(removeMultiple);         regression.addData(removeMultiple);         // Use the inference assertions to make sure that everything worked         Assert.assertEquals("slope std err", 0.011448491,                 regression.getSlopeStdErr(), 1E-10);         Assert.assertEquals("std err intercept", 0.286036932,                 regression.getInterceptStdErr(),1E-8);         Assert.assertEquals("significance", 4.596e-07,                 regression.getSignificance(),1E-8);         Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);      }      // Remove observation when empty     @Test     public void testRemoveObsFromEmpty() {         SimpleRegression regression = new SimpleRegression();         regression.removeData(removeX, removeY);         Assert.assertEquals(regression.getN(), 0);     }      // Remove single observation to empty     @Test     public void testRemoveObsFromSingle() {         SimpleRegression regression = new SimpleRegression();         regression.addData(removeX, removeY);         regression.removeData(removeX, removeY);         Assert.assertEquals(regression.getN(), 0);     }      // Remove multiple observations to empty     @Test     public void testRemoveMultipleToEmpty() {         SimpleRegression regression = new SimpleRegression();         regression.addData(removeMultiple);         regression.removeData(removeMultiple);         Assert.assertEquals(regression.getN(), 0);     }      // Remove multiple observations past empty (i.e. size of array > n)     @Test     public void testRemoveMultiplePastEmpty() {         SimpleRegression regression = new SimpleRegression();         regression.addData(removeX, removeY);         regression.removeData(removeMultiple);         Assert.assertEquals(regression.getN(), 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.regression;   import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.DefaultRealMatrixChangingVisitor; import org.apache.commons.math4.linear.MatrixUtils; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.stat.StatUtils; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  public class OLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {      private double[] y;     private double[][] x;      @Before     @Override     public void setUp(){         y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};         x = new double[6][];         x[0] = new double[]{0, 0, 0, 0, 0};         x[1] = new double[]{2.0, 0, 0, 0, 0};         x[2] = new double[]{0, 3.0, 0, 0, 0};         x[3] = new double[]{0, 0, 4.0, 0, 0};         x[4] = new double[]{0, 0, 0, 5.0, 0};         x[5] = new double[]{0, 0, 0, 0, 6.0};         super.setUp();     }      @Override     protected OLSMultipleLinearRegression createRegression() {         OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();         regression.newSampleData(y, x);         return regression;     }      @Override     protected int getNumberOfRegressors() {         return x[0].length + 1;     }      @Override     protected int getSampleSize() {         return y.length;     }      @Test(expected=MathIllegalArgumentException.class)     public void cannotAddSampleDataWithSizeMismatch() {         double[] y = new double[]{1.0, 2.0};         double[][] x = new double[1][];         x[0] = new double[]{1.0, 0};         createRegression().newSampleData(y, x);     }      @Test     public void testPerfectFit() {         double[] betaHat = regression.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,                                new double[]{ 11.0, 1.0 / 2.0, 2.0 / 3.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0 },                                1e-14);         double[] residuals = regression.estimateResiduals();         TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},                                1e-14);         RealMatrix errors =             new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(), false);         final double[] s = { 1.0, -1.0 /  2.0, -1.0 /  3.0, -1.0 /  4.0, -1.0 /  5.0, -1.0 /  6.0 };         RealMatrix referenceVariance = new Array2DRowRealMatrix(s.length, s.length);         referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {             @Override             public double visit(int row, int column, double value) {                 if (row == 0) {                     return s[column];                 }                 double x = s[row] * s[column];                 return (row == column) ? 2 * x : x;             }         });        Assert.assertEquals(0.0,                      errors.subtract(referenceVariance).getNorm(),                      5.0e-16 * referenceVariance.getNorm());        Assert.assertEquals(1, ((OLSMultipleLinearRegression) regression).calculateRSquared(), 1E-12);     }       /**      * Test Longley dataset against certified values provided by NIST.      * Data Source: J. Longley (1967) "An Appraisal of Least Squares      * Programs for the Electronic Computer from the Point of View of the User"      * Journal of the American Statistical Association, vol. 62. September,      * pp. 819-841.      *      * Certified values (and data) are from NIST:      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat      */     @Test     public void testLongley() {         // Y values are first, then independent vars         // Each row is one observation         double[] design = new double[] {             60323,83.0,234289,2356,1590,107608,1947,             61122,88.5,259426,2325,1456,108632,1948,             60171,88.2,258054,3682,1616,109773,1949,             61187,89.5,284599,3351,1650,110929,1950,             63221,96.2,328975,2099,3099,112075,1951,             63639,98.1,346999,1932,3594,113270,1952,             64989,99.0,365385,1870,3547,115094,1953,             63761,100.0,363112,3578,3350,116219,1954,             66019,101.2,397469,2904,3048,117388,1955,             67857,104.6,419180,2822,2857,118734,1956,             68169,108.4,442769,2936,2798,120445,1957,             66513,110.8,444546,4681,2637,121950,1958,             68655,112.6,482704,3813,2552,123366,1959,             69564,114.2,502601,3931,2514,125368,1960,             69331,115.7,518173,4806,2572,127852,1961,             70551,116.9,554894,4007,2827,130081,1962         };          final int nobs = 16;         final int nvars = 6;          // Estimate the model         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.newSampleData(design, nobs, nvars);          // Check expected beta values from NIST         double[] betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,           new double[]{-3482258.63459582, 15.0618722713733,                 -0.358191792925910E-01,-2.02022980381683,                 -1.03322686717359,-0.511041056535807E-01,                  1829.15146461355}, 2E-8); //          // Check expected residuals from R         double[] residuals = model.estimateResiduals();         TestUtils.assertEquals(residuals, new double[]{                 267.340029759711,-94.0139423988359,46.28716775752924,                 -410.114621930906,309.7145907602313,-249.3112153297231,                 -164.0489563956039,-13.18035686637081,14.30477260005235,                  455.394094551857,-17.26892711483297,-39.0550425226967,                 -155.5499735953195,-85.6713080421283,341.9315139607727,                 -206.7578251937366},                       1E-8);          // Check standard errors from NIST         double[] errors = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(new double[] {890420.383607373,                        84.9149257747669,                        0.334910077722432E-01,                        0.488399681651699,                        0.214274163161675,                        0.226073200069370,                        455.478499142212}, errors, 1E-6);          // Check regression standard error against R         Assert.assertEquals(304.8540735619638, model.estimateRegressionStandardError(), 1E-10);          // Check R-Square statistics against R         Assert.assertEquals(0.995479004577296, model.calculateRSquared(), 1E-12);         Assert.assertEquals(0.992465007628826, model.calculateAdjustedRSquared(), 1E-12);          checkVarianceConsistency(model);          // Estimate model without intercept         model.setNoIntercept(true);         model.newSampleData(design, nobs, nvars);          // Check expected beta values from R         betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,           new double[]{-52.99357013868291, 0.07107319907358,                 -0.42346585566399,-0.57256866841929,                 -0.41420358884978, 48.41786562001326}, 1E-11);          // Check standard errors from R         errors = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(new double[] {129.54486693117232, 0.03016640003786,                 0.41773654056612, 0.27899087467676, 0.32128496193363,                 17.68948737819961}, errors, 1E-11);          // Check expected residuals from R         residuals = model.estimateResiduals();         TestUtils.assertEquals(residuals, new double[]{                 279.90274927293092, -130.32465380836874, 90.73228661967445, -401.31252201634948,                 -440.46768772620027, -543.54512853774793, 201.32111639536299, 215.90889365977932,                 73.09368242049943, 913.21694494481869, 424.82484953610174, -8.56475876776709,                 -361.32974610842876, 27.34560497213464, 151.28955976355002, -492.49937355336846},                       1E-10);          // Check regression standard error against R         Assert.assertEquals(475.1655079819517, model.estimateRegressionStandardError(), 1E-10);          // Check R-Square statistics against R         Assert.assertEquals(0.9999670130706, model.calculateRSquared(), 1E-12);         Assert.assertEquals(0.999947220913, model.calculateAdjustedRSquared(), 1E-12);      }      /**      * Test R Swiss fertility dataset against R.      * Data Source: R datasets package      */     @Test     public void testSwissFertility() {         double[] design = new double[] {             80.2,17.0,15,12,9.96,             83.1,45.1,6,9,84.84,             92.5,39.7,5,5,93.40,             85.8,36.5,12,7,33.77,             76.9,43.5,17,15,5.16,             76.1,35.3,9,7,90.57,             83.8,70.2,16,7,92.85,             92.4,67.8,14,8,97.16,             82.4,53.3,12,7,97.67,             82.9,45.2,16,13,91.38,             87.1,64.5,14,6,98.61,             64.1,62.0,21,12,8.52,             66.9,67.5,14,7,2.27,             68.9,60.7,19,12,4.43,             61.7,69.3,22,5,2.82,             68.3,72.6,18,2,24.20,             71.7,34.0,17,8,3.30,             55.7,19.4,26,28,12.11,             54.3,15.2,31,20,2.15,             65.1,73.0,19,9,2.84,             65.5,59.8,22,10,5.23,             65.0,55.1,14,3,4.52,             56.6,50.9,22,12,15.14,             57.4,54.1,20,6,4.20,             72.5,71.2,12,1,2.40,             74.2,58.1,14,8,5.23,             72.0,63.5,6,3,2.56,             60.5,60.8,16,10,7.72,             58.3,26.8,25,19,18.46,             65.4,49.5,15,8,6.10,             75.5,85.9,3,2,99.71,             69.3,84.9,7,6,99.68,             77.3,89.7,5,2,100.00,             70.5,78.2,12,6,98.96,             79.4,64.9,7,3,98.22,             65.0,75.9,9,9,99.06,             92.2,84.6,3,3,99.46,             79.3,63.1,13,13,96.83,             70.4,38.4,26,12,5.62,             65.7,7.7,29,11,13.79,             72.7,16.7,22,13,11.22,             64.4,17.6,35,32,16.92,             77.6,37.6,15,7,4.97,             67.6,18.7,25,7,8.65,             35.0,1.2,37,53,42.34,             44.7,46.6,16,29,50.43,             42.8,27.7,22,29,58.33         };          final int nobs = 47;         final int nvars = 4;          // Estimate the model         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.newSampleData(design, nobs, nvars);          // Check expected beta values from R         double[] betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,                 new double[]{91.05542390271397,                 -0.22064551045715,                 -0.26058239824328,                 -0.96161238456030,                  0.12441843147162}, 1E-12);          // Check expected residuals from R         double[] residuals = model.estimateResiduals();         TestUtils.assertEquals(residuals, new double[]{                 7.1044267859730512,1.6580347433531366,                 4.6944952770029644,8.4548022690166160,13.6547432343186212,                -9.3586864458500774,7.5822446330520386,15.5568995563859289,                 0.8113090736598980,7.1186762732484308,7.4251378771228724,                 2.6761316873234109,0.8351584810309354,7.1769991119615177,                -3.8746753206299553,-3.1337779476387251,-0.1412575244091504,                 1.1186809170469780,-6.3588097346816594,3.4039270429434074,                 2.3374058329820175,-7.9272368576900503,-7.8361010968497959,                -11.2597369269357070,0.9445333697827101,6.6544245101380328,                -0.9146136301118665,-4.3152449403848570,-4.3536932047009183,                -3.8907885169304661,-6.3027643926302188,-7.8308982189289091,                -3.1792280015332750,-6.7167298771158226,-4.8469946718041754,                -10.6335664353633685,11.1031134362036958,6.0084032641811733,                 5.4326230830188482,-7.2375578629692230,2.1671550814448222,                 15.0147574652763112,4.8625103516321015,-7.1597256413907706,                 -0.4515205619767598,-10.2916870903837587,-15.7812984571900063},                 1E-12);          // Check standard errors from R         double[] errors = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(new double[] {6.94881329475087,                 0.07360008972340,                 0.27410957467466,                 0.19454551679325,                 0.03726654773803}, errors, 1E-10);          // Check regression standard error against R         Assert.assertEquals(7.73642194433223, model.estimateRegressionStandardError(), 1E-12);          // Check R-Square statistics against R         Assert.assertEquals(0.649789742860228, model.calculateRSquared(), 1E-12);         Assert.assertEquals(0.6164363850373927, model.calculateAdjustedRSquared(), 1E-12);          checkVarianceConsistency(model);          // Estimate the model with no intercept         model = new OLSMultipleLinearRegression();         model.setNoIntercept(true);         model.newSampleData(design, nobs, nvars);          // Check expected beta values from R         betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,                 new double[]{0.52191832900513,                   2.36588087917963,                   -0.94770353802795,                   0.30851985863609}, 1E-12);          // Check expected residuals from R         residuals = model.estimateResiduals();         TestUtils.assertEquals(residuals, new double[]{                 44.138759883538249, 27.720705122356215, 35.873200836126799,                 34.574619581211977, 26.600168342080213, 15.074636243026923, -12.704904871199814,                 1.497443824078134, 2.691972687079431, 5.582798774291231, -4.422986561283165,                 -9.198581600334345, 4.481765170730647, 2.273520207553216, -22.649827853221336,                 -17.747900013943308, 20.298314638496436, 6.861405135329779, -8.684712790954924,                 -10.298639278062371, -9.896618896845819, 4.568568616351242, -15.313570491727944,                 -13.762961360873966, 7.156100301980509, 16.722282219843990, 26.716200609071898,                 -1.991466398777079, -2.523342564719335, 9.776486693095093, -5.297535127628603,                 -16.639070567471094, -10.302057295211819, -23.549487860816846, 1.506624392156384,                 -17.939174438345930, 13.105792202765040, -1.943329906928462, -1.516005841666695,                 -0.759066561832886, 20.793137744128977, -2.485236153005426, 27.588238710486976,                 2.658333257106881, -15.998337823623046, -5.550742066720694, -14.219077806826615},                 1E-12);          // Check standard errors from R         errors = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(new double[] {0.10470063765677, 0.41684100584290,                 0.43370143099691, 0.07694953606522}, errors, 1E-10);          // Check regression standard error against R         Assert.assertEquals(17.24710630547, model.estimateRegressionStandardError(), 1E-10);          // Check R-Square statistics against R         Assert.assertEquals(0.946350722085, model.calculateRSquared(), 1E-12);         Assert.assertEquals(0.9413600915813, model.calculateAdjustedRSquared(), 1E-12);     }      /**      * Test hat matrix computation      *      */     @Test     public void testHat() {          /*          * This example is from "The Hat Matrix in Regression and ANOVA",          * David C. Hoaglin and Roy E. Welsch,          * The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.          *          */         double[] design = new double[] {                 11.14, .499, 11.1,                 12.74, .558, 8.9,                 13.13, .604, 8.8,                 11.51, .441, 8.9,                 12.38, .550, 8.8,                 12.60, .528, 9.9,                 11.13, .418, 10.7,                 11.7, .480, 10.5,                 11.02, .406, 10.5,                 11.41, .467, 10.7         };          int nobs = 10;         int nvars = 2;          // Estimate the model         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.newSampleData(design, nobs, nvars);          RealMatrix hat = model.calculateHat();          // Reference data is upper half of symmetric hat matrix         double[] referenceData = new double[] {                 .418, -.002,  .079, -.274, -.046,  .181,  .128,  .222,  .050,  .242,                        .242,  .292,  .136,  .243,  .128, -.041,  .033, -.035,  .004,                               .417, -.019,  .273,  .187, -.126,  .044, -.153,  .004,                                      .604,  .197, -.038,  .168, -.022,  .275, -.028,                                             .252,  .111, -.030,  .019, -.010, -.010,                                                    .148,  .042,  .117,  .012,  .111,                                                           .262,  .145,  .277,  .174,                                                                  .154,  .120,  .168,                                                                         .315,  .148,                                                                                .187         };          // Check against reference data and verify symmetry         int k = 0;         for (int i = 0; i < 10; i++) {             for (int j = i; j < 10; j++) {                 Assert.assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);                 Assert.assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);                 k++;             }         }          /*          * Verify that residuals computed using the hat matrix are close to          * what we get from direct computation, i.e. r = (I - H) y          */         double[] residuals = model.estimateResiduals();         RealMatrix I = MatrixUtils.createRealIdentityMatrix(10);         double[] hatResiduals = I.subtract(hat).operate(model.getY()).toArray();         TestUtils.assertEquals(residuals, hatResiduals, 10e-12);     }      /**      * test calculateYVariance      */     @Test     public void testYVariance() {          // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};          OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.newSampleData(y, x);         TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0);     }      /**      * Verifies that calculateYVariance and calculateResidualVariance return consistent      * values with direct variance computation from Y, residuals, respectively.      */     protected void checkVarianceConsistency(OLSMultipleLinearRegression model) {         // Check Y variance consistency         TestUtils.assertEquals(StatUtils.variance(model.getY().toArray()), model.calculateYVariance(), 0);          // Check residual variance consistency         double[] residuals = model.calculateResiduals().toArray();         RealMatrix X = model.getX();         TestUtils.assertEquals(                 StatUtils.variance(model.calculateResiduals().toArray()) * (residuals.length - 1),                 model.calculateErrorVariance() * (X.getRowDimension() - X.getColumnDimension()), 1E-20);      }      /**      * Verifies that setting X and Y separately has the same effect as newSample(X,Y).      */     @Test     public void testNewSample2() {         double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {           {19, 22, 33},           {20, 30, 40},           {25, 35, 45},           {27, 37, 47}         };         OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();         regression.newSampleData(y, x);         RealMatrix combinedX = regression.getX().copy();         RealVector combinedY = regression.getY().copy();         regression.newXSampleData(x);         regression.newYSampleData(y);         Assert.assertEquals(combinedX, regression.getX());         Assert.assertEquals(combinedY, regression.getY());          // No intercept         regression.setNoIntercept(true);         regression.newSampleData(y, x);         combinedX = regression.getX().copy();         combinedY = regression.getY().copy();         regression.newXSampleData(x);         regression.newYSampleData(y);         Assert.assertEquals(combinedX, regression.getX());         Assert.assertEquals(combinedY, regression.getY());     }      @Test(expected=NullArgumentException.class)     public void testNewSampleDataYNull() {         createRegression().newSampleData(null, new double[][] {});     }      @Test(expected=NullArgumentException.class)     public void testNewSampleDataXNull() {         createRegression().newSampleData(new double[] {}, null);     }       /*      * This is a test based on the Wampler1 data set      * http://www.itl.nist.gov/div898/strd/lls/data/Wampler1.shtml      */     @Test     public void testWampler1() {         double[] data = new double[]{             1, 0,             6, 1,             63, 2,             364, 3,             1365, 4,             3906, 5,             9331, 6,             19608, 7,             37449, 8,             66430, 9,             111111, 10,             177156, 11,             271453, 12,             402234, 13,             579195, 14,             813616, 15,             1118481, 16,             1508598, 17,             2000719, 18,             2613660, 19,             3368421, 20};         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();           final int nvars = 5;         final int nobs = 21;         double[] tmp = new double[(nvars + 1) * nobs];         int off = 0;         int off2 = 0;         for (int i = 0; i < nobs; i++) {             tmp[off2] = data[off];             tmp[off2 + 1] = data[off + 1];             tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];             tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];             tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];             tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];             off2 += (nvars + 1);             off += 2;         }         model.newSampleData(tmp, nobs, nvars);         double[] betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,                 new double[]{1.0,                     1.0, 1.0,                     1.0, 1.0,                     1.0}, 1E-8);          double[] se = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(se,                 new double[]{0.0,                     0.0, 0.0,                     0.0, 0.0,                     0.0}, 1E-8);          TestUtils.assertEquals(1.0, model.calculateRSquared(), 1.0e-10);         TestUtils.assertEquals(0, model.estimateErrorVariance(), 1.0e-7);         TestUtils.assertEquals(0.00, model.calculateResidualSumOfSquares(), 1.0e-6);          return;     }      /*      * This is a test based on the Wampler2 data set      * http://www.itl.nist.gov/div898/strd/lls/data/Wampler2.shtml      */     @Test     public void testWampler2() {         double[] data = new double[]{             1.00000, 0,             1.11111, 1,             1.24992, 2,             1.42753, 3,             1.65984, 4,             1.96875, 5,             2.38336, 6,             2.94117, 7,             3.68928, 8,             4.68559, 9,             6.00000, 10,             7.71561, 11,             9.92992, 12,             12.75603, 13,             16.32384, 14,             20.78125, 15,             26.29536, 16,             33.05367, 17,             41.26528, 18,             51.16209, 19,             63.00000, 20};         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();           final int nvars = 5;         final int nobs = 21;         double[] tmp = new double[(nvars + 1) * nobs];         int off = 0;         int off2 = 0;         for (int i = 0; i < nobs; i++) {             tmp[off2] = data[off];             tmp[off2 + 1] = data[off + 1];             tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];             tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];             tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];             tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];             off2 += (nvars + 1);             off += 2;         }         model.newSampleData(tmp, nobs, nvars);         double[] betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,                 new double[]{                     1.0,                     1.0e-1,                     1.0e-2,                     1.0e-3, 1.0e-4,                     1.0e-5}, 1E-8);          double[] se = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(se,                 new double[]{0.0,                     0.0, 0.0,                     0.0, 0.0,                     0.0}, 1E-8);         TestUtils.assertEquals(1.0, model.calculateRSquared(), 1.0e-10);         TestUtils.assertEquals(0, model.estimateErrorVariance(), 1.0e-7);         TestUtils.assertEquals(0.00, model.calculateResidualSumOfSquares(), 1.0e-6);         return;     }      /*      * This is a test based on the Wampler3 data set      * http://www.itl.nist.gov/div898/strd/lls/data/Wampler3.shtml      */     @Test     public void testWampler3() {         double[] data = new double[]{             760, 0,             -2042, 1,             2111, 2,             -1684, 3,             3888, 4,             1858, 5,             11379, 6,             17560, 7,             39287, 8,             64382, 9,             113159, 10,             175108, 11,             273291, 12,             400186, 13,             581243, 14,             811568, 15,             1121004, 16,             1506550, 17,             2002767, 18,             2611612, 19,             3369180, 20};          OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         final int nvars = 5;         final int nobs = 21;         double[] tmp = new double[(nvars + 1) * nobs];         int off = 0;         int off2 = 0;         for (int i = 0; i < nobs; i++) {             tmp[off2] = data[off];             tmp[off2 + 1] = data[off + 1];             tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];             tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];             tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];             tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];             off2 += (nvars + 1);             off += 2;         }         model.newSampleData(tmp, nobs, nvars);         double[] betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,                 new double[]{                     1.0,                     1.0,                     1.0,                     1.0,                     1.0,                     1.0}, 1E-8);          double[] se = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(se,                 new double[]{2152.32624678170,                     2363.55173469681, 779.343524331583,                     101.475507550350, 5.64566512170752,                     0.112324854679312}, 1E-8); //          TestUtils.assertEquals(.999995559025820, model.calculateRSquared(), 1.0e-10);         TestUtils.assertEquals(5570284.53333333, model.estimateErrorVariance(), 1.0e-6);         TestUtils.assertEquals(83554268.0000000, model.calculateResidualSumOfSquares(), 1.0e-5);         return;     }      /*      * This is a test based on the Wampler4 data set      * http://www.itl.nist.gov/div898/strd/lls/data/Wampler4.shtml      */     @Test     public void testWampler4() {         double[] data = new double[]{             75901, 0,             -204794, 1,             204863, 2,             -204436, 3,             253665, 4,             -200894, 5,             214131, 6,             -185192, 7,             221249, 8,             -138370, 9,             315911, 10,             -27644, 11,             455253, 12,             197434, 13,             783995, 14,             608816, 15,             1370781, 16,             1303798, 17,             2205519, 18,             2408860, 19,             3444321, 20};          OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         final int nvars = 5;         final int nobs = 21;         double[] tmp = new double[(nvars + 1) * nobs];         int off = 0;         int off2 = 0;         for (int i = 0; i < nobs; i++) {             tmp[off2] = data[off];             tmp[off2 + 1] = data[off + 1];             tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];             tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];             tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];             tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];             off2 += (nvars + 1);             off += 2;         }         model.newSampleData(tmp, nobs, nvars);         double[] betaHat = model.estimateRegressionParameters();         TestUtils.assertEquals(betaHat,                 new double[]{                     1.0,                     1.0,                     1.0,                     1.0,                     1.0,                     1.0}, 1E-6);          double[] se = model.estimateRegressionParametersStandardErrors();         TestUtils.assertEquals(se,                 new double[]{215232.624678170,                     236355.173469681, 77934.3524331583,                     10147.5507550350, 564.566512170752,                     11.2324854679312}, 1E-8);          TestUtils.assertEquals(.957478440825662, model.calculateRSquared(), 1.0e-10);         TestUtils.assertEquals(55702845333.3333, model.estimateErrorVariance(), 1.0e-4);         TestUtils.assertEquals(835542680000.000, model.calculateResidualSumOfSquares(), 1.0e-3);         return;     }      /**      * Anything requiring beta calculation should advertise SME.      */     @Test(expected=org.apache.commons.math4.linear.SingularMatrixException.class)     public void testSingularCalculateBeta() {         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.newSampleData(new double[] {1,  2,  3, 1, 2, 3, 1, 2, 3}, 3, 2);         model.calculateBeta();     }      @Test     public void testNoSSTOCalculateRsquare() {         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.newSampleData(new double[] {1,  2,  3, 1, 7, 8, 1, 10, 12}, 3, 2);         Assert.assertTrue(Double.isNaN(model.calculateRSquared()));     }      @Test(expected=NullPointerException.class)     public void testNoDataNPECalculateBeta() {         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.calculateBeta();     }      @Test(expected=NullPointerException.class)     public void testNoDataNPECalculateHat() {         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.calculateHat();     }      @Test(expected=NullPointerException.class)     public void testNoDataNPESSTO() {         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();         model.calculateTotalSumOfSquares();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.regression;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.stat.correlation.PearsonsCorrelation; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * MillerUpdatingRegression tests.  */ public class MillerUpdatingRegressionTest {      public MillerUpdatingRegressionTest() {     }     /* This is the Greene Airline Cost data.      * The data can be downloaded from http://www.indiana.edu/~statmath/stat/all/panel/airline.csv      */     private final static double[][] airdata = {         /*"I",*/new double[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},         /*"T",*/ new double[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},         /*"C",*/ new double[]{1140640, 1215690, 1309570, 1511530, 1676730, 1823740, 2022890, 2314760, 2639160, 3247620, 3787750, 3867750, 3996020, 4282880, 4748320, 569292, 640614, 777655, 999294, 1203970, 1358100, 1501350, 1709270, 2025400, 2548370, 3137740, 3557700, 3717740, 3962370, 4209390, 286298, 309290, 342056, 374595, 450037, 510412, 575347, 669331, 783799, 913883, 1041520, 1125800, 1096070, 1198930, 1170470, 145167, 170192, 247506, 309391, 354338, 373941, 420915, 474017, 532590, 676771, 880438, 1052020, 1193680, 1303390, 1436970, 91361, 95428, 98187, 115967, 138382, 156228, 183169, 210212, 274024, 356915, 432344, 524294, 530924, 581447, 610257, 68978, 74904, 83829, 98148, 118449, 133161, 145062, 170711, 199775, 276797, 381478, 506969, 633388, 804388, 1009500},         /*"Q",*/ new double[]{0.952757, 0.986757, 1.09198, 1.17578, 1.16017, 1.17376, 1.29051, 1.39067, 1.61273, 1.82544, 1.54604, 1.5279, 1.6602, 1.82231, 1.93646, 0.520635, 0.534627, 0.655192, 0.791575, 0.842945, 0.852892, 0.922843, 1, 1.19845, 1.34067, 1.32624, 1.24852, 1.25432, 1.37177, 1.38974, 0.262424, 0.266433, 0.306043, 0.325586, 0.345706, 0.367517, 0.409937, 0.448023, 0.539595, 0.539382, 0.467967, 0.450544, 0.468793, 0.494397, 0.493317, 0.086393, 0.09674, 0.1415, 0.169715, 0.173805, 0.164272, 0.170906, 0.17784, 0.192248, 0.242469, 0.256505, 0.249657, 0.273923, 0.371131, 0.421411, 0.051028, 0.052646, 0.056348, 0.066953, 0.070308, 0.073961, 0.084946, 0.095474, 0.119814, 0.150046, 0.144014, 0.1693, 0.172761, 0.18667, 0.213279, 0.037682, 0.039784, 0.044331, 0.050245, 0.055046, 0.052462, 0.056977, 0.06149, 0.069027, 0.092749, 0.11264, 0.154154, 0.186461, 0.246847, 0.304013},         /*"PF",*/ new double[]{106650, 110307, 110574, 121974, 196606, 265609, 263451, 316411, 384110, 569251, 871636, 997239, 938002, 859572, 823411, 103795, 111477, 118664, 114797, 215322, 281704, 304818, 348609, 374579, 544109, 853356, 1003200, 941977, 856533, 821361, 118788, 123798, 122882, 131274, 222037, 278721, 306564, 356073, 378311, 555267, 850322, 1015610, 954508, 886999, 844079, 114987, 120501, 121908, 127220, 209405, 263148, 316724, 363598, 389436, 547376, 850418, 1011170, 951934, 881323, 831374, 118222, 116223, 115853, 129372, 243266, 277930, 317273, 358794, 397667, 566672, 848393, 1005740, 958231, 872924, 844622, 117112, 119420, 116087, 122997, 194309, 307923, 323595, 363081, 386422, 564867, 874818, 1013170, 930477, 851676, 819476},         /*"LF",*/ new double[]{0.534487, 0.532328, 0.547736, 0.540846, 0.591167, 0.575417, 0.594495, 0.597409, 0.638522, 0.676287, 0.605735, 0.61436, 0.633366, 0.650117, 0.625603, 0.490851, 0.473449, 0.503013, 0.512501, 0.566782, 0.558133, 0.558799, 0.57207, 0.624763, 0.628706, 0.58915, 0.532612, 0.526652, 0.540163, 0.528775, 0.524334, 0.537185, 0.582119, 0.579489, 0.606592, 0.60727, 0.582425, 0.573972, 0.654256, 0.631055, 0.56924, 0.589682, 0.587953, 0.565388, 0.577078, 0.432066, 0.439669, 0.488932, 0.484181, 0.529925, 0.532723, 0.549067, 0.55714, 0.611377, 0.645319, 0.611734, 0.580884, 0.572047, 0.59457, 0.585525, 0.442875, 0.462473, 0.519118, 0.529331, 0.557797, 0.556181, 0.569327, 0.583465, 0.631818, 0.604723, 0.587921, 0.616159, 0.605868, 0.594688, 0.635545, 0.448539, 0.475889, 0.500562, 0.500344, 0.528897, 0.495361, 0.510342, 0.518296, 0.546723, 0.554276, 0.517766, 0.580049, 0.556024, 0.537791, 0.525775}     };      /**      * Test of hasIntercept method, of class MillerUpdatingRegression.      */     @Test     public void testHasIntercept() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(10, false);         if (instance.hasIntercept()) {             Assert.fail("Should not have intercept");         }         instance = new MillerUpdatingRegression(10, true);         if (!instance.hasIntercept()) {             Assert.fail("Should have intercept");         }     }      /**      * Test of getN method, of class MillerUpdatingRegression.      */     @Test     public void testAddObsGetNClear() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);         double[][] xAll = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             xAll[i] = new double[3];             xAll[i][0] = FastMath.log(airdata[3][i]);             xAll[i][1] = FastMath.log(airdata[4][i]);             xAll[i][2] = airdata[5][i];             y[i] = FastMath.log(airdata[2][i]);         }         instance.addObservations(xAll, y);         if (instance.getN() != xAll.length) {             Assert.fail("Number of observations not correct in bulk addition");         }         instance.clear();         for (int i = 0; i < xAll.length; i++) {             instance.addObservation(xAll[i], y[i]);         }         if (instance.getN() != xAll.length) {             Assert.fail("Number of observations not correct in drip addition");         }         return;     }      @Test     public void testNegativeTestAddObs() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);         try {             instance.addObservation(new double[]{1.0}, 0.0);             Assert.fail("Should throw MathIllegalArgumentException");         } catch (MathIllegalArgumentException iae) {         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException");         }         try {             instance.addObservation(new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 0.0);             Assert.fail("Should throw MathIllegalArgumentException");         } catch (MathIllegalArgumentException iae) {         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException");         }         try {             instance.addObservation(new double[]{1.0, 1.0, 1.0}, 0.0);         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException");         }          //now we try it without an intercept         instance = new MillerUpdatingRegression(3, false);         try {             instance.addObservation(new double[]{1.0}, 0.0);             Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");         } catch (MathIllegalArgumentException iae) {         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");         }         try {             instance.addObservation(new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 0.0);             Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");         } catch (MathIllegalArgumentException iae) {         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");         }         try {             instance.addObservation(new double[]{1.0, 1.0, 1.0}, 0.0);         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");         }     }      @Test     public void testNegativeTestAddMultipleObs() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);         try {             double[][] tst = {{1.0, 1.0, 1.0}, {1.20, 2.0, 2.1}};             double[] y = {1.0};             instance.addObservations(tst, y);              Assert.fail("Should throw MathIllegalArgumentException");         } catch (MathIllegalArgumentException iae) {         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException");         }          try {             double[][] tst = {{1.0, 1.0, 1.0}, {1.20, 2.0, 2.1}};             double[] y = {1.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};             instance.addObservations(tst, y);              Assert.fail("Should throw MathIllegalArgumentException");         } catch (MathIllegalArgumentException iae) {         } catch (Exception e) {             Assert.fail("Should throw MathIllegalArgumentException");         }     }      /* Results can be found at http://www.indiana.edu/~statmath/stat/all/panel/panel4.html      * This test concerns a known data set      */     @Test     public void testRegressAirlineConstantExternal() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);         double[][] x = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[4];             x[i][0] = 1.0;             x[i][1] = FastMath.log(airdata[3][i]);             x[i][2] = FastMath.log(airdata[4][i]);             x[i][3] = airdata[5][i];             y[i] = FastMath.log(airdata[2][i]);         }          instance.addObservations(x, y);         try {             RegressionResults result = instance.regress();             Assert.assertNotNull("The test case is a prototype.", result);             TestUtils.assertEquals(                     new double[]{9.5169, 0.8827, 0.4540, -1.6275},                     result.getParameterEstimates(), 1e-4);               TestUtils.assertEquals(                     new double[]{.2292445, .0132545, .0203042, .345302},                     result.getStdErrorOfEstimates(), 1.0e-4);              TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8);         } catch (Exception e) {             Assert.fail("Should not throw exception but does");         }     }      @Test     public void testRegressAirlineConstantInternal() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);         double[][] x = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[3];             x[i][0] = FastMath.log(airdata[3][i]);             x[i][1] = FastMath.log(airdata[4][i]);             x[i][2] = airdata[5][i];             y[i] = FastMath.log(airdata[2][i]);         }          instance.addObservations(x, y);         try {             RegressionResults result = instance.regress();             Assert.assertNotNull("The test case is a prototype.", result);             TestUtils.assertEquals(                     new double[]{9.5169, 0.8827, 0.4540, -1.6275},                     result.getParameterEstimates(), 1e-4);               TestUtils.assertEquals(                     new double[]{.2292445, .0132545, .0203042, .345302},                     result.getStdErrorOfEstimates(), 1.0e-4);              TestUtils.assertEquals(0.9883, result.getRSquared(), 1.0e-4);             TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8);         } catch (Exception e) {             Assert.fail("Should not throw exception but does");         }     }      @Test     public void testFilippelli() {         double[] data = new double[]{             0.8116, -6.860120914,             0.9072, -4.324130045,             0.9052, -4.358625055,             0.9039, -4.358426747,             0.8053, -6.955852379,             0.8377, -6.661145254,             0.8667, -6.355462942,             0.8809, -6.118102026,             0.7975, -7.115148017,             0.8162, -6.815308569,             0.8515, -6.519993057,             0.8766, -6.204119983,             0.8885, -5.853871964,             0.8859, -6.109523091,             0.8959, -5.79832982,             0.8913, -5.482672118,             0.8959, -5.171791386,             0.8971, -4.851705903,             0.9021, -4.517126416,             0.909, -4.143573228,             0.9139, -3.709075441,             0.9199, -3.499489089,             0.8692, -6.300769497,             0.8872, -5.953504836,             0.89, -5.642065153,             0.891, -5.031376979,             0.8977, -4.680685696,             0.9035, -4.329846955,             0.9078, -3.928486195,             0.7675, -8.56735134,             0.7705, -8.363211311,             0.7713, -8.107682739,             0.7736, -7.823908741,             0.7775, -7.522878745,             0.7841, -7.218819279,             0.7971, -6.920818754,             0.8329, -6.628932138,             0.8641, -6.323946875,             0.8804, -5.991399828,             0.7668, -8.781464495,             0.7633, -8.663140179,             0.7678, -8.473531488,             0.7697, -8.247337057,             0.77, -7.971428747,             0.7749, -7.676129393,             0.7796, -7.352812702,             0.7897, -7.072065318,             0.8131, -6.774174009,             0.8498, -6.478861916,             0.8741, -6.159517513,             0.8061, -6.835647144,             0.846, -6.53165267,             0.8751, -6.224098421,             0.8856, -5.910094889,             0.8919, -5.598599459,             0.8934, -5.290645224,             0.894, -4.974284616,             0.8957, -4.64454848,             0.9047, -4.290560426,             0.9129, -3.885055584,             0.9209, -3.408378962,             0.9219, -3.13200249,             0.7739, -8.726767166,             0.7681, -8.66695597,             0.7665, -8.511026475,             0.7703, -8.165388579,             0.7702, -7.886056648,             0.7761, -7.588043762,             0.7809, -7.283412422,             0.7961, -6.995678626,             0.8253, -6.691862621,             0.8602, -6.392544977,             0.8809, -6.067374056,             0.8301, -6.684029655,             0.8664, -6.378719832,             0.8834, -6.065855188,             0.8898, -5.752272167,             0.8964, -5.132414673,             0.8963, -4.811352704,             0.9074, -4.098269308,             0.9119, -3.66174277,             0.9228, -3.2644011         };         MillerUpdatingRegression model = new MillerUpdatingRegression(10, true);         int off = 0;         double[] tmp = new double[10];         int nobs = 82;         for (int i = 0; i < nobs; i++) {             tmp[0] = data[off + 1]; //            tmp[1] = tmp[0] * tmp[0]; //            tmp[2] = tmp[0] * tmp[1]; //^3 //            tmp[3] = tmp[1] * tmp[1]; //^4 //            tmp[4] = tmp[2] * tmp[1]; //^5 //            tmp[5] = tmp[2] * tmp[2]; //^6 //            tmp[6] = tmp[2] * tmp[3]; //^7 //            tmp[7] = tmp[3] * tmp[3]; //^8 //            tmp[8] = tmp[4] * tmp[3]; //^9 //            tmp[9] = tmp[4] * tmp[4]; //^10             tmp[1] = tmp[0] * tmp[0];             tmp[2] = tmp[0] * tmp[1];             tmp[3] = tmp[0] * tmp[2];             tmp[4] = tmp[0] * tmp[3];             tmp[5] = tmp[0] * tmp[4];             tmp[6] = tmp[0] * tmp[5];             tmp[7] = tmp[0] * tmp[6];             tmp[8] = tmp[0] * tmp[7];             tmp[9] = tmp[0] * tmp[8];             model.addObservation(tmp, data[off]);             off += 2;         }         RegressionResults result = model.regress();         double[] betaHat = result.getParameterEstimates();         TestUtils.assertEquals(betaHat,                 new double[]{                     -1467.48961422980,                     -2772.17959193342,                     -2316.37108160893,                     -1127.97394098372,                     -354.478233703349,                     -75.1242017393757,                     -10.8753180355343,                     -1.06221498588947,                     -0.670191154593408E-01,                     -0.246781078275479E-02,                     -0.402962525080404E-04                 }, 1E-5); // //         double[] se = result.getStdErrorOfEstimates();         TestUtils.assertEquals(se,                 new double[]{                     298.084530995537,                     559.779865474950,                     466.477572127796,                     227.204274477751,                     71.6478660875927,                     15.2897178747400,                     2.23691159816033,                     0.221624321934227,                     0.142363763154724E-01,                     0.535617408889821E-03,                     0.896632837373868E-05                 }, 1E-5); //          TestUtils.assertEquals(0.996727416185620, result.getRSquared(), 1.0e-8);         TestUtils.assertEquals(0.112091743968020E-04, result.getMeanSquareError(), 1.0e-10);         TestUtils.assertEquals(0.795851382172941E-03, result.getErrorSumSquares(), 1.0e-10);      }      @Test     public void testWampler1() {         double[] data = new double[]{             1, 0,             6, 1,             63, 2,             364, 3,             1365, 4,             3906, 5,             9331, 6,             19608, 7,             37449, 8,             66430, 9,             111111, 10,             177156, 11,             271453, 12,             402234, 13,             579195, 14,             813616, 15,             1118481, 16,             1508598, 17,             2000719, 18,             2613660, 19,             3368421, 20};          MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);         int off = 0;         double[] tmp = new double[5];         int nobs = 21;         for (int i = 0; i < nobs; i++) {             tmp[0] = data[off + 1];             tmp[1] = tmp[0] * tmp[0];             tmp[2] = tmp[0] * tmp[1];             tmp[3] = tmp[0] * tmp[2];             tmp[4] = tmp[0] * tmp[3];             model.addObservation(tmp, data[off]);             off += 2;         }         RegressionResults result = model.regress();         double[] betaHat = result.getParameterEstimates();         TestUtils.assertEquals(betaHat,                 new double[]{1.0,                     1.0, 1.0,                     1.0, 1.0,                     1.0}, 1E-8); // //         double[] se = result.getStdErrorOfEstimates();         TestUtils.assertEquals(se,                 new double[]{0.0,                     0.0, 0.0,                     0.0, 0.0,                     0.0}, 1E-8); //          TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10);         TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7);         TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6);          return;     }      @Test     public void testWampler2() {         double[] data = new double[]{             1.00000, 0,             1.11111, 1,             1.24992, 2,             1.42753, 3,             1.65984, 4,             1.96875, 5,             2.38336, 6,             2.94117, 7,             3.68928, 8,             4.68559, 9,             6.00000, 10,             7.71561, 11,             9.92992, 12,             12.75603, 13,             16.32384, 14,             20.78125, 15,             26.29536, 16,             33.05367, 17,             41.26528, 18,             51.16209, 19,             63.00000, 20};          MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);         int off = 0;         double[] tmp = new double[5];         int nobs = 21;         for (int i = 0; i < nobs; i++) {             tmp[0] = data[off + 1];             tmp[1] = tmp[0] * tmp[0];             tmp[2] = tmp[0] * tmp[1];             tmp[3] = tmp[0] * tmp[2];             tmp[4] = tmp[0] * tmp[3];             model.addObservation(tmp, data[off]);             off += 2;         }         RegressionResults result = model.regress();         double[] betaHat = result.getParameterEstimates();         TestUtils.assertEquals(betaHat,                 new double[]{1.0,                     1.0e-1, 1.0e-2,                     1.0e-3, 1.0e-4,                     1.0e-5}, 1E-8); // //         double[] se = result.getStdErrorOfEstimates();         TestUtils.assertEquals(se,                 new double[]{0.0,                     0.0, 0.0,                     0.0, 0.0,                     0.0}, 1E-8); //          TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10);         TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7);         TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6);         return;     }      @Test     public void testWampler3() {         double[] data = new double[]{             760, 0,             -2042, 1,             2111, 2,             -1684, 3,             3888, 4,             1858, 5,             11379, 6,             17560, 7,             39287, 8,             64382, 9,             113159, 10,             175108, 11,             273291, 12,             400186, 13,             581243, 14,             811568, 15,             1121004, 16,             1506550, 17,             2002767, 18,             2611612, 19,             3369180, 20};         MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);         int off = 0;         double[] tmp = new double[5];         int nobs = 21;         for (int i = 0; i < nobs; i++) {             tmp[0] = data[off + 1];             tmp[1] = tmp[0] * tmp[0];             tmp[2] = tmp[0] * tmp[1];             tmp[3] = tmp[0] * tmp[2];             tmp[4] = tmp[0] * tmp[3];             model.addObservation(tmp, data[off]);             off += 2;         }         RegressionResults result = model.regress();         double[] betaHat = result.getParameterEstimates();         TestUtils.assertEquals(betaHat,                 new double[]{1.0,                     1.0, 1.0,                     1.0, 1.0,                     1.0}, 1E-8); //         double[] se = result.getStdErrorOfEstimates();         TestUtils.assertEquals(se,                 new double[]{2152.32624678170,                     2363.55173469681, 779.343524331583,                     101.475507550350, 5.64566512170752,                     0.112324854679312}, 1E-8); //          TestUtils.assertEquals(.999995559025820, result.getRSquared(), 1.0e-10);         TestUtils.assertEquals(5570284.53333333, result.getMeanSquareError(), 1.0e-7);         TestUtils.assertEquals(83554268.0000000, result.getErrorSumSquares(), 1.0e-6);         return;     }      //@Test     public void testWampler4() {         double[] data = new double[]{             75901, 0,             -204794, 1,             204863, 2,             -204436, 3,             253665, 4,             -200894, 5,             214131, 6,             -185192, 7,             221249, 8,             -138370, 9,             315911, 10,             -27644, 11,             455253, 12,             197434, 13,             783995, 14,             608816, 15,             1370781, 16,             1303798, 17,             2205519, 18,             2408860, 19,             3444321, 20};         MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);         int off = 0;         double[] tmp = new double[5];         int nobs = 21;         for (int i = 0; i < nobs; i++) {             tmp[0] = data[off + 1];             tmp[1] = tmp[0] * tmp[0];             tmp[2] = tmp[0] * tmp[1];             tmp[3] = tmp[0] * tmp[2];             tmp[4] = tmp[0] * tmp[3];             model.addObservation(tmp, data[off]);             off += 2;         }         RegressionResults result = model.regress();         double[] betaHat = result.getParameterEstimates();         TestUtils.assertEquals(betaHat,                 new double[]{1.0,                     1.0, 1.0,                     1.0, 1.0,                     1.0}, 1E-8); // //         double[] se = result.getStdErrorOfEstimates();         TestUtils.assertEquals(se,                 new double[]{215232.624678170,                     236355.173469681, 77934.3524331583,                     10147.5507550350, 564.566512170752,                     11.2324854679312}, 1E-8); //          TestUtils.assertEquals(.957478440825662, result.getRSquared(), 1.0e-10);         TestUtils.assertEquals(55702845333.3333, result.getMeanSquareError(), 1.0e-4);         TestUtils.assertEquals(835542680000.000, result.getErrorSumSquares(), 1.0e-3);          return;     }      /**      * Test Longley dataset against certified values provided by NIST.      * Data Source: J. Longley (1967) "An Appraisal of Least Squares      * Programs for the Electronic Computer from the Point of View of the User"      * Journal of the American Statistical Association, vol. 62. September,      * pp. 819-841.      *      * Certified values (and data) are from NIST:      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat      */     @Test     public void testLongley() {         // Y values are first, then independent vars         // Each row is one observation         double[] design = new double[]{             60323, 83.0, 234289, 2356, 1590, 107608, 1947,             61122, 88.5, 259426, 2325, 1456, 108632, 1948,             60171, 88.2, 258054, 3682, 1616, 109773, 1949,             61187, 89.5, 284599, 3351, 1650, 110929, 1950,             63221, 96.2, 328975, 2099, 3099, 112075, 1951,             63639, 98.1, 346999, 1932, 3594, 113270, 1952,             64989, 99.0, 365385, 1870, 3547, 115094, 1953,             63761, 100.0, 363112, 3578, 3350, 116219, 1954,             66019, 101.2, 397469, 2904, 3048, 117388, 1955,             67857, 104.6, 419180, 2822, 2857, 118734, 1956,             68169, 108.4, 442769, 2936, 2798, 120445, 1957,             66513, 110.8, 444546, 4681, 2637, 121950, 1958,             68655, 112.6, 482704, 3813, 2552, 123366, 1959,             69564, 114.2, 502601, 3931, 2514, 125368, 1960,             69331, 115.7, 518173, 4806, 2572, 127852, 1961,             70551, 116.9, 554894, 4007, 2827, 130081, 1962         };          final int nobs = 16;         final int nvars = 6;          // Estimate the model         MillerUpdatingRegression model = new MillerUpdatingRegression(6, true);         int off = 0;         double[] tmp = new double[6];         for (int i = 0; i < nobs; i++) {             System.arraycopy(design, off + 1, tmp, 0, nvars);             model.addObservation(tmp, design[off]);             off += nvars + 1;         }          // Check expected beta values from NIST         RegressionResults result = model.regress();         double[] betaHat = result.getParameterEstimates();         TestUtils.assertEquals(betaHat,                 new double[]{-3482258.63459582, 15.0618722713733,                     -0.358191792925910E-01, -2.02022980381683,                     -1.03322686717359, -0.511041056535807E-01,                     1829.15146461355}, 1E-8); //          // Check standard errors from NIST         double[] errors = result.getStdErrorOfEstimates();         TestUtils.assertEquals(new double[]{890420.383607373,                     84.9149257747669,                     0.334910077722432E-01,                     0.488399681651699,                     0.214274163161675,                     0.226073200069370,                     455.478499142212}, errors, 1E-6); //         // Check R-Square statistics against R         TestUtils.assertEquals(0.995479004577296, result.getRSquared(), 1E-12);         TestUtils.assertEquals(0.992465007628826, result.getAdjustedRSquared(), 1E-12); // // //        // Estimate model without intercept         model = new MillerUpdatingRegression(6, false);         off = 0;         for (int i = 0; i < nobs; i++) {             System.arraycopy(design, off + 1, tmp, 0, nvars);             model.addObservation(tmp, design[off]);             off += nvars + 1;         }         // Check expected beta values from R         result = model.regress();         betaHat = result.getParameterEstimates();         TestUtils.assertEquals(betaHat,                 new double[]{-52.99357013868291, 0.07107319907358,                     -0.42346585566399, -0.57256866841929,                     -0.41420358884978, 48.41786562001326}, 1E-11); //         // Check standard errors from R         errors = result.getStdErrorOfEstimates();         TestUtils.assertEquals(new double[]{129.54486693117232, 0.03016640003786,                     0.41773654056612, 0.27899087467676, 0.32128496193363,                     17.68948737819961}, errors, 1E-11); //  //        // Check R-Square statistics against R         TestUtils.assertEquals(0.9999670130706, result.getRSquared(), 1E-12);         TestUtils.assertEquals(0.999947220913, result.getAdjustedRSquared(), 1E-12);      }  //    @Test //    public void testRegressReorder() { //        // System.out.println("testRegressReorder"); //        MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); //        double[][] x = new double[airdata[0].length][]; //        double[] y = new double[airdata[0].length]; //        for (int i = 0; i < airdata[0].length; i++) { //            x[i] = new double[4]; //            x[i][0] = 1.0; //            x[i][1] = FastMath.log(airdata[3][i]); //            x[i][2] = FastMath.log(airdata[4][i]); //            x[i][3] = airdata[5][i]; //            y[i] = FastMath.log(airdata[2][i]); //        } // //        instance.addObservations(x, y); //        RegressionResults result = instance.regress(); //        if (result == null) { //            Assert.fail("Null result...."); //        } // //        instance.reorderRegressors(new int[]{3, 2}, 0); //        RegressionResults resultInverse = instance.regress(); // //        double[] beta = result.getParameterEstimates(); //        double[] betar = resultInverse.getParameterEstimates(); //        if (FastMath.abs(beta[0] - betar[0]) > 1.0e-14) { //            Assert.fail("Parameters not correct after reorder (0,3)"); //        } //        if (FastMath.abs(beta[1] - betar[1]) > 1.0e-14) { //            Assert.fail("Parameters not correct after reorder (1,2)"); //        } //        if (FastMath.abs(beta[2] - betar[2]) > 1.0e-14) { //            Assert.fail("Parameters not correct after reorder (2,1)"); //        } //        if (FastMath.abs(beta[3] - betar[3]) > 1.0e-14) { //            Assert.fail("Parameters not correct after reorder (3,0)"); //        } //    }      @Test     public void testOneRedundantColumn() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);         MillerUpdatingRegression instance2 = new MillerUpdatingRegression(5, false);         double[][] x = new double[airdata[0].length][];         double[][] x2 = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[4];             x2[i] = new double[5];             x[i][0] = 1.0;             x[i][1] = FastMath.log(airdata[3][i]);             x[i][2] = FastMath.log(airdata[4][i]);             x[i][3] = airdata[5][i];              x2[i][0] = x[i][0];             x2[i][1] = x[i][1];             x2[i][2] = x[i][2];             x2[i][3] = x[i][3];             x2[i][4] = x[i][3];              y[i] = FastMath.log(airdata[2][i]);         }          instance.addObservations(x, y);         RegressionResults result = instance.regress();         Assert.assertNotNull("Could not estimate initial regression", result);          instance2.addObservations(x2, y);         RegressionResults resultRedundant = instance2.regress();         Assert.assertNotNull("Could not estimate redundant regression", resultRedundant);         double[] beta = result.getParameterEstimates();         double[] betar = resultRedundant.getParameterEstimates();         double[] se = result.getStdErrorOfEstimates();         double[] ser = resultRedundant.getStdErrorOfEstimates();          for (int i = 0; i < beta.length; i++) {             if (FastMath.abs(beta[i] - betar[i]) > 1.0e-8) {                 Assert.fail("Parameters not correctly estimated");             }             if (FastMath.abs(se[i] - ser[i]) > 1.0e-8) {                 Assert.fail("Standard errors not correctly estimated");             }             for (int j = 0; j < i; j++) {                 if (FastMath.abs(result.getCovarianceOfParameters(i, j)                         - resultRedundant.getCovarianceOfParameters(i, j)) > 1.0e-8) {                     Assert.fail("Variance Covariance not correct");                 }             }         }           TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8);         TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8);         TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8);         TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8);         return;     }      @Test     public void testThreeRedundantColumn() {          MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);         MillerUpdatingRegression instance2 = new MillerUpdatingRegression(7, false);         double[][] x = new double[airdata[0].length][];         double[][] x2 = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[4];             x2[i] = new double[7];             x[i][0] = 1.0;             x[i][1] = FastMath.log(airdata[3][i]);             x[i][2] = FastMath.log(airdata[4][i]);             x[i][3] = airdata[5][i];              x2[i][0] = x[i][0];             x2[i][1] = x[i][0];             x2[i][2] = x[i][1];             x2[i][3] = x[i][2];             x2[i][4] = x[i][1];             x2[i][5] = x[i][3];             x2[i][6] = x[i][2];              y[i] = FastMath.log(airdata[2][i]);         }          instance.addObservations(x, y);         RegressionResults result = instance.regress();         Assert.assertNotNull("Could not estimate initial regression", result);          instance2.addObservations(x2, y);         RegressionResults resultRedundant = instance2.regress();         Assert.assertNotNull("Could not estimate redundant regression", resultRedundant);         double[] beta = result.getParameterEstimates();         double[] betar = resultRedundant.getParameterEstimates();         double[] se = result.getStdErrorOfEstimates();         double[] ser = resultRedundant.getStdErrorOfEstimates();          if (FastMath.abs(beta[0] - betar[0]) > 1.0e-8) {             Assert.fail("Parameters not correct after reorder (0,3)");         }         if (FastMath.abs(beta[1] - betar[2]) > 1.0e-8) {             Assert.fail("Parameters not correct after reorder (1,2)");         }         if (FastMath.abs(beta[2] - betar[3]) > 1.0e-8) {             Assert.fail("Parameters not correct after reorder (2,1)");         }         if (FastMath.abs(beta[3] - betar[5]) > 1.0e-8) {             Assert.fail("Parameters not correct after reorder (3,0)");         }          if (FastMath.abs(se[0] - ser[0]) > 1.0e-8) {             Assert.fail("Se not correct after reorder (0,3)");         }         if (FastMath.abs(se[1] - ser[2]) > 1.0e-8) {             Assert.fail("Se not correct after reorder (1,2)");         }         if (FastMath.abs(se[2] - ser[3]) > 1.0e-8) {             Assert.fail("Se not correct after reorder (2,1)");         }         if (FastMath.abs(se[3] - ser[5]) > 1.0e-8) {             Assert.fail("Se not correct after reorder (3,0)");         }          if (FastMath.abs(result.getCovarianceOfParameters(0, 0)                 - resultRedundant.getCovarianceOfParameters(0, 0)) > 1.0e-8) {             Assert.fail("VCV not correct after reorder (0,0)");         }         if (FastMath.abs(result.getCovarianceOfParameters(0, 1)                 - resultRedundant.getCovarianceOfParameters(0, 2)) > 1.0e-8) {             Assert.fail("VCV not correct after reorder (0,1)<->(0,2)");         }         if (FastMath.abs(result.getCovarianceOfParameters(0, 2)                 - resultRedundant.getCovarianceOfParameters(0, 3)) > 1.0e-8) {             Assert.fail("VCV not correct after reorder (0,2)<->(0,1)");         }         if (FastMath.abs(result.getCovarianceOfParameters(0, 3)                 - resultRedundant.getCovarianceOfParameters(0, 5)) > 1.0e-8) {             Assert.fail("VCV not correct after reorder (0,3)<->(0,3)");         }         if (FastMath.abs(result.getCovarianceOfParameters(1, 0)                 - resultRedundant.getCovarianceOfParameters(2, 0)) > 1.0e-8) {             Assert.fail("VCV not correct after reorder (1,0)<->(2,0)");         }         if (FastMath.abs(result.getCovarianceOfParameters(1, 1)                 - resultRedundant.getCovarianceOfParameters(2, 2)) > 1.0e-8) {             Assert.fail("VCV not correct  (1,1)<->(2,1)");         }         if (FastMath.abs(result.getCovarianceOfParameters(1, 2)                 - resultRedundant.getCovarianceOfParameters(2, 3)) > 1.0e-8) {             Assert.fail("VCV not correct  (1,2)<->(2,2)");         }          if (FastMath.abs(result.getCovarianceOfParameters(2, 0)                 - resultRedundant.getCovarianceOfParameters(3, 0)) > 1.0e-8) {             Assert.fail("VCV not correct  (2,0)<->(1,0)");         }         if (FastMath.abs(result.getCovarianceOfParameters(2, 1)                 - resultRedundant.getCovarianceOfParameters(3, 2)) > 1.0e-8) {             Assert.fail("VCV not correct  (2,1)<->(1,2)");         }          if (FastMath.abs(result.getCovarianceOfParameters(3, 3)                 - resultRedundant.getCovarianceOfParameters(5, 5)) > 1.0e-8) {             Assert.fail("VCV not correct  (3,3)<->(3,2)");         }          TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8);         TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8);         TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8);         TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8);         return;     }      @Test     public void testPCorr() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);         double[][] x = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         double[] cp = new double[10];         double[] yxcorr = new double[4];         double[] diag = new double[4];         double sumysq = 0.0;         int off = 0;         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[4];             x[i][0] = 1.0;             x[i][1] = FastMath.log(airdata[3][i]);             x[i][2] = FastMath.log(airdata[4][i]);             x[i][3] = airdata[5][i];             y[i] = FastMath.log(airdata[2][i]);             off = 0;             for (int j = 0; j < 4; j++) {                 double tmp = x[i][j];                 for (int k = 0; k <= j; k++, off++) {                     cp[off] += tmp * x[i][k];                 }                 yxcorr[j] += tmp * y[i];             }             sumysq += y[i] * y[i];         }         PearsonsCorrelation pearson = new PearsonsCorrelation(x);         RealMatrix corr = pearson.getCorrelationMatrix();         off = 0;         for (int i = 0; i < 4; i++, off += (i + 1)) {             diag[i] = FastMath.sqrt(cp[off]);         }          instance.addObservations(x, y);         double[] pc = instance.getPartialCorrelations(0);         int idx = 0;         off = 0;         int off2 = 6;         for (int i = 0; i < 4; i++) {             for (int j = 0; j < i; j++) {                 if (FastMath.abs(pc[idx] - cp[off] / (diag[i] * diag[j])) > 1.0e-8) {                     Assert.fail("Failed cross products... i = " + i + " j = " + j);                 }                 ++idx;                 ++off;             }             ++off;             if (FastMath.abs(pc[i+off2] - yxcorr[ i] / (FastMath.sqrt(sumysq) * diag[i])) > 1.0e-8) {                 Assert.fail("Assert.failed cross product i = " + i + " y");             }         }         double[] pc2 = instance.getPartialCorrelations(1);          idx = 0;          for (int i = 1; i < 4; i++) {             for (int j = 1; j < i; j++) {                 if (FastMath.abs(pc2[idx] - corr.getEntry(j, i)) > 1.0e-8) {                     Assert.fail("Failed cross products... i = " + i + " j = " + j);                 }                 ++idx;             }         }         double[] pc3 = instance.getPartialCorrelations(2);         if (pc3 == null) {             Assert.fail("Should not be null");         }         return;     }      @Test     public void testHdiag() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);         double[][] x = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[4];             x[i][0] = 1.0;             x[i][1] = FastMath.log(airdata[3][i]);             x[i][2] = FastMath.log(airdata[4][i]);             x[i][3] = airdata[5][i];             y[i] = FastMath.log(airdata[2][i]);         }         instance.addObservations(x, y);         OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression();         ols.setNoIntercept(true);         ols.newSampleData(y, x);          RealMatrix rm = ols.calculateHat();         for (int i = 0; i < x.length; i++) {             TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8);         }         return;     }     @Test     public void testHdiagConstant() {         MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);         double[][] x = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[3];             x[i][0] = FastMath.log(airdata[3][i]);             x[i][1] = FastMath.log(airdata[4][i]);             x[i][2] = airdata[5][i];             y[i] = FastMath.log(airdata[2][i]);         }         instance.addObservations(x, y);         OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression();         ols.setNoIntercept(false);         ols.newSampleData(y, x);          RealMatrix rm = ols.calculateHat();         for (int i = 0; i < x.length; i++) {             TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8);         }         return;     }       private void subsetRegression(int i_exclude, boolean constant){         int[] indices = new int[2];         int j = 0;         for (int i = 0; i < 3; i++){             if (i != i_exclude){                 indices[j] = i;                 j++;             }         }         int i0 = indices[0];         int i1 = indices[1];         MillerUpdatingRegression instance = new MillerUpdatingRegression(3, constant);         MillerUpdatingRegression redRegression = new MillerUpdatingRegression(2, constant);         double[][] x = new double[airdata[0].length][];         double[][] xReduced = new double[airdata[0].length][];         double[] y = new double[airdata[0].length];         for (int i = 0; i < airdata[0].length; i++) {             x[i] = new double[3];             x[i][i0] = FastMath.log(airdata[3][i]);             x[i][i1] = FastMath.log(airdata[4][i]);             x[i][i_exclude] = airdata[5][i];              xReduced[i] = new double[2];             xReduced[i][0] = FastMath.log(airdata[3][i]);             xReduced[i][1] = FastMath.log(airdata[4][i]);              y[i] = FastMath.log(airdata[2][i]);         }          instance.addObservations(x, y);         redRegression.addObservations(xReduced, y);          int includedIndices[];         if (constant){             includedIndices = new int[3];             includedIndices[0] = 0;             includedIndices[1] = i0 + 1;             includedIndices[2] = i1 + 1;         } else {             includedIndices = indices;         }          RegressionResults resultsInstance = instance.regress( includedIndices );         RegressionResults resultsReduced = redRegression.regress();          TestUtils.assertEquals(resultsInstance.getParameterEstimates(), resultsReduced.getParameterEstimates(), 1.0e-12);         TestUtils.assertEquals(resultsInstance.getStdErrorOfEstimates(), resultsReduced.getStdErrorOfEstimates(), 1.0e-12);     }       @Test     public void testSubsetRegression() {         for (int i=0; i < 3; i++){             subsetRegression(i, true);             subsetRegression(i, false);         }     }   } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.regression;  import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.linear.MatrixUtils; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.apache.commons.math4.random.CorrelatedRandomVectorGenerator; import org.apache.commons.math4.random.GaussianRandomGenerator; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.math4.stat.correlation.Covariance; import org.apache.commons.math4.stat.descriptive.DescriptiveStatistics;  public class GLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {      private double[] y;     private double[][] x;     private double[][] omega;     private final double[] longley = new double[] {             60323,83.0,234289,2356,1590,107608,1947,             61122,88.5,259426,2325,1456,108632,1948,             60171,88.2,258054,3682,1616,109773,1949,             61187,89.5,284599,3351,1650,110929,1950,             63221,96.2,328975,2099,3099,112075,1951,             63639,98.1,346999,1932,3594,113270,1952,             64989,99.0,365385,1870,3547,115094,1953,             63761,100.0,363112,3578,3350,116219,1954,             66019,101.2,397469,2904,3048,117388,1955,             67857,104.6,419180,2822,2857,118734,1956,             68169,108.4,442769,2936,2798,120445,1957,             66513,110.8,444546,4681,2637,121950,1958,             68655,112.6,482704,3813,2552,123366,1959,             69564,114.2,502601,3931,2514,125368,1960,             69331,115.7,518173,4806,2572,127852,1961,             70551,116.9,554894,4007,2827,130081,1962         };      @Before     @Override     public void setUp(){         y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};         x = new double[6][];         x[0] = new double[]{0, 0, 0, 0, 0};         x[1] = new double[]{2.0, 0, 0, 0, 0};         x[2] = new double[]{0, 3.0, 0, 0, 0};         x[3] = new double[]{0, 0, 4.0, 0, 0};         x[4] = new double[]{0, 0, 0, 5.0, 0};         x[5] = new double[]{0, 0, 0, 0, 6.0};         omega = new double[6][];         omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};         omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};         omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};         omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};         omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};         omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};         super.setUp();     }      @Test(expected=NullArgumentException.class)     public void cannotAddXSampleData() {         createRegression().newSampleData(new double[]{}, null, null);     }      @Test(expected=NullArgumentException.class)     public void cannotAddNullYSampleData() {         createRegression().newSampleData(null, new double[][]{}, null);     }      @Test(expected=MathIllegalArgumentException.class)     public void cannotAddSampleDataWithSizeMismatch() {         double[] y = new double[]{1.0, 2.0};         double[][] x = new double[1][];         x[0] = new double[]{1.0, 0};         createRegression().newSampleData(y, x, null);     }      @Test(expected=MathIllegalArgumentException.class)     public void cannotAddNullCovarianceData() {         createRegression().newSampleData(new double[]{}, new double[][]{}, null);     }      @Test(expected=MathIllegalArgumentException.class)     public void notEnoughData() {         double[]   reducedY = new double[y.length - 1];         double[][] reducedX = new double[x.length - 1][];         double[][] reducedO = new double[omega.length - 1][];         System.arraycopy(y,     0, reducedY, 0, reducedY.length);         System.arraycopy(x,     0, reducedX, 0, reducedX.length);         System.arraycopy(omega, 0, reducedO, 0, reducedO.length);         createRegression().newSampleData(reducedY, reducedX, reducedO);     }      @Test(expected=MathIllegalArgumentException.class)     public void cannotAddCovarianceDataWithSampleSizeMismatch() {         double[] y = new double[]{1.0, 2.0};         double[][] x = new double[2][];         x[0] = new double[]{1.0, 0};         x[1] = new double[]{0, 1.0};         double[][] omega = new double[1][];         omega[0] = new double[]{1.0, 0};         createRegression().newSampleData(y, x, omega);     }      @Test(expected=MathIllegalArgumentException.class)     public void cannotAddCovarianceDataThatIsNotSquare() {         double[] y = new double[]{1.0, 2.0};         double[][] x = new double[2][];         x[0] = new double[]{1.0, 0};         x[1] = new double[]{0, 1.0};         double[][] omega = new double[3][];         omega[0] = new double[]{1.0, 0};         omega[1] = new double[]{0, 1.0};         omega[2] = new double[]{0, 2.0};         createRegression().newSampleData(y, x, omega);     }      @Override     protected GLSMultipleLinearRegression createRegression() {         GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();         regression.newSampleData(y, x, omega);         return regression;     }      @Override     protected int getNumberOfRegressors() {         return x[0].length + 1;     }      @Override     protected int getSampleSize() {         return y.length;     }      /**      * test calculateYVariance      */     @Test     public void testYVariance() {          // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};          GLSMultipleLinearRegression model = new GLSMultipleLinearRegression();         model.newSampleData(y, x, omega);         TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0);     }      /**      * Verifies that setting X, Y and covariance separately has the same effect as newSample(X,Y,cov).      */     @Test     public void testNewSample2() {         double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {           {19, 22, 33},           {20, 30, 40},           {25, 35, 45},           {27, 37, 47}         };         double[][] covariance = MatrixUtils.createRealIdentityMatrix(4).scalarMultiply(2).getData();         GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();         regression.newSampleData(y, x, covariance);         RealMatrix combinedX = regression.getX().copy();         RealVector combinedY = regression.getY().copy();         RealMatrix combinedCovInv = regression.getOmegaInverse();         regression.newXSampleData(x);         regression.newYSampleData(y);         Assert.assertEquals(combinedX, regression.getX());         Assert.assertEquals(combinedY, regression.getY());         Assert.assertEquals(combinedCovInv, regression.getOmegaInverse());     }      /**      * Verifies that GLS with identity covariance matrix gives the same results      * as OLS.      */     @Test     public void testGLSOLSConsistency() {         RealMatrix identityCov = MatrixUtils.createRealIdentityMatrix(16);         GLSMultipleLinearRegression glsModel = new GLSMultipleLinearRegression();         OLSMultipleLinearRegression olsModel = new OLSMultipleLinearRegression();         glsModel.newSampleData(longley, 16, 6);         olsModel.newSampleData(longley, 16, 6);         glsModel.newCovarianceData(identityCov.getData());         double[] olsBeta = olsModel.calculateBeta().toArray();         double[] glsBeta = glsModel.calculateBeta().toArray();         // TODO:  Should have assertRelativelyEquals(double[], double[], eps) in TestUtils         //        Should also add RealVector and RealMatrix versions         for (int i = 0; i < olsBeta.length; i++) {             TestUtils.assertRelativelyEquals(olsBeta[i], glsBeta[i], 10E-7);         }     }      /**      * Generate an error covariance matrix and sample data representing models      * with this error structure. Then verify that GLS estimated coefficients,      * on average, perform better than OLS.      */     @Test     public void testGLSEfficiency() {         final UniformRandomProvider rg = RandomSource.create(RandomSource.MT, 123456789L);         final ContinuousDistribution.Sampler gauss = new NormalDistribution(0, 1).createSampler(rg);          // Assume model has 16 observations (will use Longley data).  Start by generating         // non-constant variances for the 16 error terms.         final int nObs = 16;         double[] sigma = new double[nObs];         for (int i = 0; i < nObs; i++) {             sigma[i] = 10 * rg.nextDouble();         }          // Now generate 1000 error vectors to use to estimate the covariance matrix         // Columns are draws on N(0, sigma[col])         final int numSeeds = 1000;         RealMatrix errorSeeds = MatrixUtils.createRealMatrix(numSeeds, nObs);         for (int i = 0; i < numSeeds; i++) {             for (int j = 0; j < nObs; j++) {                 errorSeeds.setEntry(i, j, gauss.sample() * sigma[j]);             }         }          // Get covariance matrix for columns         RealMatrix cov = (new Covariance(errorSeeds)).getCovarianceMatrix();          // Create a CorrelatedRandomVectorGenerator to use to generate correlated errors         GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);         double[] errorMeans = new double[nObs];  // Counting on init to 0 here         CorrelatedRandomVectorGenerator gen = new CorrelatedRandomVectorGenerator(errorMeans, cov,          1.0e-12 * cov.getNorm(), rawGenerator);          // Now start generating models.  Use Longley X matrix on LHS         // and Longley OLS beta vector as "true" beta.  Generate         // Y values by XB + u where u is a CorrelatedRandomVector generated         // from cov.         OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression();         ols.newSampleData(longley, nObs, 6);         final RealVector b = ols.calculateBeta().copy();         final RealMatrix x = ols.getX().copy();          // Create a GLS model to reuse         GLSMultipleLinearRegression gls = new GLSMultipleLinearRegression();         gls.newSampleData(longley, nObs, 6);         gls.newCovarianceData(cov.getData());          // Create aggregators for stats measuring model performance         DescriptiveStatistics olsBetaStats = new DescriptiveStatistics();         DescriptiveStatistics glsBetaStats = new DescriptiveStatistics();          // Generate Y vectors for 10000 models, estimate GLS and OLS and         // Verify that OLS estimates are better         final int nModels = 10000;         for (int i = 0; i < nModels; i++) {              // Generate y = xb + u with u cov             RealVector u = MatrixUtils.createRealVector(gen.nextVector());             double[] y = u.add(x.operate(b)).toArray();              // Estimate OLS parameters             ols.newYSampleData(y);             RealVector olsBeta = ols.calculateBeta();              // Estimate GLS parameters             gls.newYSampleData(y);             RealVector glsBeta = gls.calculateBeta();              // Record deviations from "true" beta             double dist = olsBeta.getDistance(b);             olsBetaStats.addValue(dist * dist);             dist = glsBeta.getDistance(b);             glsBetaStats.addValue(dist * dist);          }          // Verify that GLS is on average more efficient, lower variance         assert(olsBetaStats.getMean() > 1.5 * glsBetaStats.getMean());         assert(olsBetaStats.getStandardDeviation() > glsBetaStats.getStandardDeviation());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.regression;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.linear.RealVector; import org.junit.Assert; import org.junit.Before; import org.junit.Test;   public abstract class MultipleLinearRegressionAbstractTest {      protected AbstractMultipleLinearRegression regression;      @Before     public void setUp(){         regression = createRegression();     }      protected abstract AbstractMultipleLinearRegression createRegression();      protected abstract int getNumberOfRegressors();      protected abstract int getSampleSize();      @Test     public void canEstimateRegressionParameters(){         double[] beta = regression.estimateRegressionParameters();         Assert.assertEquals(getNumberOfRegressors(), beta.length);     }      @Test     public void canEstimateResiduals(){         double[] e = regression.estimateResiduals();         Assert.assertEquals(getSampleSize(), e.length);     }      @Test     public void canEstimateRegressionParametersVariance(){         double[][] variance = regression.estimateRegressionParametersVariance();         Assert.assertEquals(getNumberOfRegressors(), variance.length);     }      @Test     public void canEstimateRegressandVariance(){         if (getSampleSize() > getNumberOfRegressors()) {             double variance = regression.estimateRegressandVariance();             Assert.assertTrue(variance > 0.0);         }     }      /**      * Verifies that newSampleData methods consistently insert unitary columns      * in design matrix.  Confirms the fix for MATH-411.      */     @Test     public void testNewSample() {         double[] design = new double[] {           1, 19, 22, 33,           2, 20, 30, 40,           3, 25, 35, 45,           4, 27, 37, 47         };         double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {           {19, 22, 33},           {20, 30, 40},           {25, 35, 45},           {27, 37, 47}         };         AbstractMultipleLinearRegression regression = createRegression();         regression.newSampleData(design, 4, 3);         RealMatrix flatX = regression.getX().copy();         RealVector flatY = regression.getY().copy();         regression.newXSampleData(x);         regression.newYSampleData(y);         Assert.assertEquals(flatX, regression.getX());         Assert.assertEquals(flatY, regression.getY());          // No intercept         regression.setNoIntercept(true);         regression.newSampleData(design, 4, 3);         flatX = regression.getX().copy();         flatY = regression.getY().copy();         regression.newXSampleData(x);         regression.newYSampleData(y);         Assert.assertEquals(flatX, regression.getX());         Assert.assertEquals(flatY, regression.getY());     }      @Test(expected=NullArgumentException.class)     public void testNewSampleNullData() {         double[] data = null;         createRegression().newSampleData(data, 2, 3);     }      @Test(expected=MathIllegalArgumentException.class)     public void testNewSampleInvalidData() {         double[] data = new double[] {1, 2, 3, 4};         createRegression().newSampleData(data, 2, 3);     }      @Test(expected=MathIllegalArgumentException.class)     public void testNewSampleInsufficientData() {         double[] data = new double[] {1, 2, 3, 4};         createRegression().newSampleData(data, 1, 3);     }      @Test(expected=NullArgumentException.class)     public void testXSampleDataNull() {         createRegression().newXSampleData(null);     }      @Test(expected=NullArgumentException.class)     public void testYSampleDataNull() {         createRegression().newYSampleData(null);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat;  import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader;  import org.apache.commons.math4.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math4.stat.descriptive.SummaryStatistics; import org.junit.Assert; import org.junit.Test;  /**  * Certified data test cases.  */ public class CertifiedDataTest {      protected double mean = Double.NaN;      protected double std = Double.NaN;      /**      * Test SummaryStatistics - implementations that do not store the data      * and use single pass algorithms to compute statistics     */     @Test     public void testSummaryStatistics() throws Exception {         SummaryStatistics u = new SummaryStatistics();         loadStats("data/PiDigits.txt", u);         Assert.assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-13);         Assert.assertEquals("PiDigits: mean", mean, u.getMean(), 1E-13);          loadStats("data/Mavro.txt", u);         Assert.assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);          loadStats("data/Michelso.txt", u);         Assert.assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-13);         Assert.assertEquals("Michelso: mean", mean, u.getMean(), 1E-13);          loadStats("data/NumAcc1.txt", u);         Assert.assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);          loadStats("data/NumAcc2.txt", u);         Assert.assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);     }      /**      * Test DescriptiveStatistics - implementations that store full array of      * values and execute multi-pass algorithms      */     @Test     public void testDescriptiveStatistics() throws Exception {          DescriptiveStatistics u = new DescriptiveStatistics();          loadStats("data/PiDigits.txt", u);         Assert.assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("PiDigits: mean", mean, u.getMean(), 1E-14);          loadStats("data/Mavro.txt", u);         Assert.assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);          loadStats("data/Michelso.txt", u);         Assert.assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("Michelso: mean", mean, u.getMean(), 1E-14);          loadStats("data/NumAcc1.txt", u);         Assert.assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);          loadStats("data/NumAcc2.txt", u);         Assert.assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);         Assert.assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);     }      /**      * loads a DescriptiveStatistics off of a test file      */     private void loadStats(String resource, Object u) throws Exception {          DescriptiveStatistics d = null;         SummaryStatistics s = null;         if (u instanceof DescriptiveStatistics) {             d = (DescriptiveStatistics) u;         } else {             s = (SummaryStatistics) u;         }         u.getClass().getDeclaredMethod(                 "clear", new Class[]{}).invoke(u, new Object[]{});         mean = Double.NaN;         std = Double.NaN;          InputStream resourceAsStream = CertifiedDataTest.class.getResourceAsStream(resource);         Assert.assertNotNull("Could not find resource "+resource,resourceAsStream);         BufferedReader in =             new BufferedReader(                     new InputStreamReader(                             resourceAsStream));          String line = null;          for (int j = 0; j < 60; j++) {             line = in.readLine();             if (j == 40) {                 mean =                     Double.parseDouble(                             line.substring(line.lastIndexOf(":") + 1).trim());             }             if (j == 41) {                 std =                     Double.parseDouble(                             line.substring(line.lastIndexOf(":") + 1).trim());             }         }          line = in.readLine();          while (line != null) {             if (d != null) {                 d.addValue(Double.parseDouble(line.trim()));             }  else {                 s.addValue(Double.parseDouble(line.trim()));             }             line = in.readLine();         }          resourceAsStream.close();         in.close();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;  import java.util.Locale;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.stat.descriptive.moment.GeometricMean; import org.apache.commons.math4.stat.descriptive.moment.Mean; import org.apache.commons.math4.stat.descriptive.moment.Variance; import org.apache.commons.math4.stat.descriptive.rank.Max; import org.apache.commons.math4.stat.descriptive.rank.Min; import org.apache.commons.math4.stat.descriptive.rank.Percentile; import org.apache.commons.math4.stat.descriptive.summary.Sum; import org.apache.commons.math4.stat.descriptive.summary.SumOfSquares; import org.apache.commons.numbers.core.Precision; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link DescriptiveStatistics} class.  */ public class DescriptiveStatisticsTest {     private static UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A, 2345789432894l);      protected DescriptiveStatistics createDescriptiveStatistics() {         return new DescriptiveStatistics();     }      @Test     public void testSetterInjection() {         DescriptiveStatistics stats = createDescriptiveStatistics();         stats.addValue(1);         stats.addValue(3);         Assert.assertEquals(2, stats.getMean(), 1E-10);         // Now lets try some new math         stats.setMeanImpl(new deepMean());         Assert.assertEquals(42, stats.getMean(), 1E-10);     }      @Test     public void testCopy() {         DescriptiveStatistics stats = createDescriptiveStatistics();         stats.addValue(1);         stats.addValue(3);         DescriptiveStatistics copy = new DescriptiveStatistics(stats);         Assert.assertEquals(2, copy.getMean(), 1E-10);         // Now lets try some new math         stats.setMeanImpl(new deepMean());         copy = stats.copy();         Assert.assertEquals(42, copy.getMean(), 1E-10);     }      @Test     public void testWindowSize() {         DescriptiveStatistics stats = createDescriptiveStatistics();         stats.setWindowSize(300);         for (int i = 0; i < 100; ++i) {             stats.addValue(i + 1);         }         int refSum = (100 * 101) / 2;         Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10);         Assert.assertEquals(300, stats.getWindowSize());         try {             stats.setWindowSize(-3);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException iae) {             // expected         }         Assert.assertEquals(300, stats.getWindowSize());         stats.setWindowSize(50);         Assert.assertEquals(50, stats.getWindowSize());         int refSum2 = refSum - (50 * 51) / 2;         Assert.assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10);     }      @Test     public void testGetValues() {         DescriptiveStatistics stats = createDescriptiveStatistics();         for (int i = 100; i > 0; --i) {             stats.addValue(i);         }         int refSum = (100 * 101) / 2;         Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10);         double[] v = stats.getValues();         for (int i = 0; i < v.length; ++i) {             Assert.assertEquals(100.0 - i, v[i], 1.0e-10);         }         double[] s = stats.getSortedValues();         for (int i = 0; i < s.length; ++i) {             Assert.assertEquals(i + 1.0, s[i], 1.0e-10);         }         Assert.assertEquals(12.0, stats.getElement(88), 1.0e-10);     }      @Test     public void testQuadraticMean() {         final double[] values = { 1.2, 3.4, 5.6, 7.89 };         final DescriptiveStatistics stats = new DescriptiveStatistics(values);          final int len = values.length;         double expected = 0;         for (int i = 0; i < len; i++) {             final double v = values[i];             expected += v * v / len;         }         expected = Math.sqrt(expected);          Assert.assertEquals(expected, stats.getQuadraticMean(), Math.ulp(expected));     }      @Test     public void testToString() {         DescriptiveStatistics stats = createDescriptiveStatistics();         stats.addValue(1);         stats.addValue(2);         stats.addValue(3);         Locale d = Locale.getDefault();         Locale.setDefault(Locale.US);         Assert.assertEquals("DescriptiveStatistics:\n" +                      "n: 3\n" +                      "min: 1.0\n" +                      "max: 3.0\n" +                      "mean: 2.0\n" +                      "std dev: 1.0\n" +                      "median: 2.0\n" +                      "skewness: 0.0\n" +                      "kurtosis: NaN\n",  stats.toString());         Locale.setDefault(d);     }      @Test     public void testShuffledStatistics() {         // the purpose of this test is only to check the get/set methods         // we are aware shuffling statistics like this is really not         // something sensible to do in production ...         DescriptiveStatistics reference = createDescriptiveStatistics();         DescriptiveStatistics shuffled  = createDescriptiveStatistics();          UnivariateStatistic tmp = shuffled.getGeometricMeanImpl();         shuffled.setGeometricMeanImpl(shuffled.getMeanImpl());         shuffled.setMeanImpl(shuffled.getKurtosisImpl());         shuffled.setKurtosisImpl(shuffled.getSkewnessImpl());         shuffled.setSkewnessImpl(shuffled.getVarianceImpl());         shuffled.setVarianceImpl(shuffled.getMaxImpl());         shuffled.setMaxImpl(shuffled.getMinImpl());         shuffled.setMinImpl(shuffled.getSumImpl());         shuffled.setSumImpl(shuffled.getSumsqImpl());         shuffled.setSumsqImpl(tmp);          for (int i = 100; i > 0; --i) {             reference.addValue(i);             shuffled.addValue(i);         }          Assert.assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);         Assert.assertEquals(reference.getKurtosis(),      shuffled.getMean(),          1.0e-10);         Assert.assertEquals(reference.getSkewness(),      shuffled.getKurtosis(), 1.0e-10);         Assert.assertEquals(reference.getVariance(),      shuffled.getSkewness(), 1.0e-10);         Assert.assertEquals(reference.getMax(),           shuffled.getVariance(), 1.0e-10);         Assert.assertEquals(reference.getMin(),           shuffled.getMax(), 1.0e-10);         Assert.assertEquals(reference.getSum(),           shuffled.getMin(), 1.0e-10);         Assert.assertEquals(reference.getSumsq(),         shuffled.getSum(), 1.0e-10);         Assert.assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10);      }      @Test     public void testPercentileSetter() {         DescriptiveStatistics stats = createDescriptiveStatistics();         stats.addValue(1);         stats.addValue(2);         stats.addValue(3);         Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10);          // Inject wrapped Percentile impl         stats.setPercentileImpl(new goodPercentile());         Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10);          // Try "new math" impl         stats.setPercentileImpl(new subPercentile());         Assert.assertEquals(10.0, stats.getPercentile(10.0), 1E-10);          // Try to set bad impl         try {             stats.setPercentileImpl(new badPercentile());             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      @Test     public void test20090720() {         DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics(100);         for (int i = 0; i < 161; i++) {             descriptiveStatistics.addValue(1.2);         }         descriptiveStatistics.clear();         descriptiveStatistics.addValue(1.2);         Assert.assertEquals(1, descriptiveStatistics.getN());     }      @Test     public void testRemoval() {          final DescriptiveStatistics dstat = createDescriptiveStatistics();          checkremoval(dstat, 1, 6.0, 0.0, Double.NaN);         checkremoval(dstat, 3, 5.0, 3.0, 4.5);         checkremoval(dstat, 6, 3.5, 2.5, 3.0);         checkremoval(dstat, 9, 3.5, 2.5, 3.0);         checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0);      }      @Test     public void testSummaryConsistency() {         final DescriptiveStatistics dstats = new DescriptiveStatistics();         final SummaryStatistics sstats = new SummaryStatistics();         final int windowSize = 5;         dstats.setWindowSize(windowSize);         final double tol = 1E-12;         for (int i = 0; i < 20; i++) {             dstats.addValue(i);             sstats.clear();             double[] values = dstats.getValues();             for (int j = 0; j < values.length; j++) {                 sstats.addValue(values[j]);             }             TestUtils.assertEquals(dstats.getMean(), sstats.getMean(), tol);             TestUtils.assertEquals(new Mean().evaluate(values), dstats.getMean(), tol);             TestUtils.assertEquals(dstats.getMax(), sstats.getMax(), tol);             TestUtils.assertEquals(new Max().evaluate(values), dstats.getMax(), tol);             TestUtils.assertEquals(dstats.getGeometricMean(), sstats.getGeometricMean(), tol);             TestUtils.assertEquals(new GeometricMean().evaluate(values), dstats.getGeometricMean(), tol);             TestUtils.assertEquals(dstats.getMin(), sstats.getMin(), tol);             TestUtils.assertEquals(new Min().evaluate(values), dstats.getMin(), tol);             TestUtils.assertEquals(dstats.getStandardDeviation(), sstats.getStandardDeviation(), tol);             TestUtils.assertEquals(dstats.getVariance(), sstats.getVariance(), tol);             TestUtils.assertEquals(new Variance().evaluate(values), dstats.getVariance(), tol);             TestUtils.assertEquals(dstats.getSum(), sstats.getSum(), tol);             TestUtils.assertEquals(new Sum().evaluate(values), dstats.getSum(), tol);             TestUtils.assertEquals(dstats.getSumsq(), sstats.getSumsq(), tol);             TestUtils.assertEquals(new SumOfSquares().evaluate(values), dstats.getSumsq(), tol);             TestUtils.assertEquals(dstats.getPopulationVariance(), sstats.getPopulationVariance(), tol);             TestUtils.assertEquals(new Variance(false).evaluate(values), dstats.getPopulationVariance(), tol);         }     }      @Test     public void testMath1129(){         final double[] data = new double[] {             -0.012086732064244697,             -0.24975668704012527,             0.5706168483164684,             -0.322111769955327,             0.24166759508327315,             Double.NaN,             0.16698443218942854,             -0.10427763937565114,             -0.15595963093172435,             -0.028075857595882995,             -0.24137994506058857,             0.47543170476574426,             -0.07495595384947631,             0.37445697625436497,             -0.09944199541668033         };          final DescriptiveStatistics ds = new DescriptiveStatistics(data);          final double t = ds.getPercentile(75);         final double o = ds.getPercentile(25);          final double iqr = t - o;         // System.out.println(String.format("25th percentile %s 75th percentile %s", o, t));         Assert.assertTrue(iqr >= 0);     }      @Test     public void testInit0() {         //test window constructor         int window = 1 + random.nextInt(Integer.MAX_VALUE-1);         DescriptiveStatistics instance = new DescriptiveStatistics(window);         Assert.assertEquals(window,                             instance.getWindowSize());     }      @Test     public void testInitDouble() {         //test double[] constructor         double[] initialDoubleArray = null;         new DescriptiveStatistics(initialDoubleArray);             //a null argument corresponds to DescriptiveStatistics(), so test             //that no exception is thrown         int initialDoubleArraySize = random.nextInt(1024 //some random             //memory consumption and test size limitation         ); //        System.out.println(String.format("initialDoubleArraySize: %s", //                initialDoubleArraySize));         initialDoubleArray = new double[initialDoubleArraySize];         for(int i = 0; i < initialDoubleArraySize; i++) {             double value = random.nextDouble();             initialDoubleArray[i] = value;         }         new DescriptiveStatistics(initialDoubleArray);     }      @Test     public void testInitDoubleWrapper() {         //test Double[] constructor         Double[] initialDoubleWrapperArray = null;         new DescriptiveStatistics(initialDoubleWrapperArray);         int initialDoubleWrapperArraySize = random.nextInt(1024 //some random             //memory consumption and test size limitation         );         initialDoubleWrapperArray = generateInitialDoubleArray(initialDoubleWrapperArraySize);         new DescriptiveStatistics(initialDoubleWrapperArray);     }      @Test     public void testInitCopy() {         //test copy constructor         int initialDoubleArray = random.nextInt(1024 //some random             //memory consumption and test size limitation         );         DescriptiveStatistics original = new DescriptiveStatistics(initialDoubleArray);         DescriptiveStatistics instance = new DescriptiveStatistics(original);         Assert.assertEquals(original.getGeometricMean(),                             instance.getGeometricMean(),                             0);         Assert.assertEquals(original.getKurtosis(),                             instance.getKurtosis(),                             0);         Assert.assertEquals(original.getMax(),                             instance.getMax(),                             0);         Assert.assertEquals(original.getMean(),                             instance.getMean(),                             0);         Assert.assertEquals(original.getMin(),                             instance.getMin(),                             0);         Assert.assertEquals(original.getN(),                             instance.getN());         Assert.assertEquals(original.getSkewness(),                             instance.getSkewness(),                             0);         Assert.assertArrayEquals(original.getValues(),                                  instance.getValues(),                                  0);         Assert.assertEquals(original.getWindowSize(),                             instance.getWindowSize());             //doesn't implement equals     }      public void checkremoval(DescriptiveStatistics dstat, int wsize,                              double mean1, double mean2, double mean3) {          dstat.setWindowSize(wsize);         dstat.clear();          for (int i = 1 ; i <= 6 ; ++i) {             dstat.addValue(i);         }          Assert.assertTrue(Precision.equalsIncludingNaN(mean1, dstat.getMean()));         dstat.replaceMostRecentValue(0);         Assert.assertTrue(Precision.equalsIncludingNaN(mean2, dstat.getMean()));         dstat.removeMostRecentValue();         Assert.assertTrue(Precision.equalsIncludingNaN(mean3, dstat.getMean()));      }      private Double[] generateInitialDoubleArray(int size) {         Double[] retValue = new Double[size];         for(int i = 0; i < size; i++) {             Double value = random.nextDouble();             retValue[i] = value;         }         return retValue;     }      // Test UnivariateStatistics impls for setter injection tests      /**      * A new way to compute the mean      */     static class deepMean implements UnivariateStatistic {          @Override         public double evaluate(double[] values, int begin, int length) {             return 42;         }          @Override         public double evaluate(double[] values) {             return 42;         }         @Override         public UnivariateStatistic copy() {             return new deepMean();         }     }      /**      * Test percentile implementation - wraps a Percentile      */     static class goodPercentile implements UnivariateStatistic {         private final Percentile percentile = new Percentile();         public void setQuantile(double quantile) {             percentile.setQuantile(quantile);         }         @Override         public double evaluate(double[] values, int begin, int length) {             return percentile.evaluate(values, begin, length);         }         @Override         public double evaluate(double[] values) {             return percentile.evaluate(values);         }         @Override         public UnivariateStatistic copy() {             goodPercentile result = new goodPercentile();             result.setQuantile(percentile.getQuantile());             return result;         }     }      /**      * Test percentile subclass - another "new math" impl      * Always returns currently set quantile      */     static class subPercentile extends Percentile {         @Override         public double evaluate(double[] values, int begin, int length) {             return getQuantile();         }         @Override         public double evaluate(double[] values) {             return getQuantile();         }         private static final long serialVersionUID = 8040701391045914979L;         @Override         public Percentile copy() {             subPercentile result = new subPercentile();             return result;         }     }      /**      * "Bad" test percentile implementation - no setQuantile      */     static class badPercentile implements UnivariateStatistic {         private final Percentile percentile = new Percentile();         @Override         public double evaluate(double[] values, int begin, int length) {             return percentile.evaluate(values, begin, length);         }         @Override         public double evaluate(double[] values) {             return percentile.evaluate(values);         }         @Override         public UnivariateStatistic copy() {             return new badPercentile();         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link FirstMoment} class.  */ public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{      /** descriptive statistic. */     protected FirstMoment stat;      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new FirstMoment();     }      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()      */     @Override     public double expectedValue() {         return this.mean;     }      /**      * Added in an attempt to resolve MATH-1146      * Commented out tests that won't pass with the current implementation.      */     @Test     public void testSpecialValues() {         final FirstMoment mean = new FirstMoment();  //         mean.clear(); //         mean.increment(Double.POSITIVE_INFINITY); //         mean.increment(1d); //         Assert.assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0d);  //         mean.clear(); //         mean.increment(Double.POSITIVE_INFINITY); //         mean.increment(-1d); //         Assert.assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0d);  //         mean.clear(); //         mean.increment(Double.NEGATIVE_INFINITY); //         mean.increment(1d); //         Assert.assertEquals(Double.NEGATIVE_INFINITY, mean.getResult(), 0d);  //         mean.clear(); //         mean.increment(Double.NEGATIVE_INFINITY); //         mean.increment(-1d); //         Assert.assertEquals(Double.NEGATIVE_INFINITY, mean.getResult(), 0d);  //         mean.clear(); //         mean.increment(Double.POSITIVE_INFINITY); //         mean.increment(Double.POSITIVE_INFINITY); //         Assert.assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0d);  //         mean.clear(); //         mean.increment(Double.NEGATIVE_INFINITY); //         mean.increment(Double.NEGATIVE_INFINITY); //         Assert.assertEquals(Double.NEGATIVE_INFINITY, mean.getResult(), 0d);          mean.clear();         mean.increment(Double.POSITIVE_INFINITY);         mean.increment(Double.NEGATIVE_INFINITY);         Assert.assertTrue(Double.isNaN(mean.getResult()));          mean.clear();         mean.increment(Double.NEGATIVE_INFINITY);         mean.increment(Double.POSITIVE_INFINITY);         Assert.assertTrue(Double.isNaN(mean.getResult()));          mean.clear();         mean.increment(Double.NaN);         mean.increment(Double.POSITIVE_INFINITY);         Assert.assertTrue(Double.isNaN(mean.getResult()));          mean.clear();         mean.increment(Double.NaN);         mean.increment(Double.NEGATIVE_INFINITY);         Assert.assertTrue(Double.isNaN(mean.getResult()));          mean.clear();         mean.increment(Double.NaN);         mean.increment(0d);         Assert.assertTrue(Double.isNaN(mean.getResult()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{      protected Kurtosis stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Kurtosis();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.kurt;     }      /**      * Make sure Double.NaN is returned iff n < 4      */     @Test     public void testNaN() {         Kurtosis kurt = new Kurtosis();         Assert.assertTrue(Double.isNaN(kurt.getResult()));         kurt.increment(1d);         Assert.assertTrue(Double.isNaN(kurt.getResult()));         kurt.increment(1d);         Assert.assertTrue(Double.isNaN(kurt.getResult()));         kurt.increment(1d);         Assert.assertTrue(Double.isNaN(kurt.getResult()));         kurt.increment(1d);         Assert.assertFalse(Double.isNaN(kurt.getResult()));     }  } 
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements.  See the NOTICE file //distributed with this work for additional information //regarding copyright ownership.  The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License.  You may obtain a copy of the License at  //http://www.apache.org/licenses/LICENSE-2.0  //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied.  See the License for the //specific language governing permissions and limitations //under the License.  package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.junit.Test; import org.junit.Assert;  public class VectorialMeanTest {     private double[][] points;      public VectorialMeanTest() {         points = new double[][] {             { 1.2, 2.3,  4.5},             {-0.7, 2.3,  5.0},             { 3.1, 0.0, -3.1},             { 6.0, 1.2,  4.2},             {-0.7, 2.3,  5.0}         };     }      @Test     public void testMismatch() {         try {             new VectorialMean(8).increment(new double[5]);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException dme) {             Assert.assertEquals(5, dme.getArgument());             Assert.assertEquals(8, dme.getDimension());         }     }      @Test     public void testSimplistic() {         VectorialMean stat = new VectorialMean(2);         stat.increment(new double[] {-1.0,  1.0});         stat.increment(new double[] { 1.0, -1.0});         double[] mean = stat.getResult();         Assert.assertEquals(0.0, mean[0], 1.0e-12);         Assert.assertEquals(0.0, mean[1], 1.0e-12);     }      @Test     public void testBasicStats() {          VectorialMean stat = new VectorialMean(points[0].length);         for (int i = 0; i < points.length; ++i) {             stat.increment(points[i]);         }          Assert.assertEquals(points.length, stat.getN());          double[] mean = stat.getResult();         double[]   refMean = new double[] { 1.78, 1.62,  3.12};          for (int i = 0; i < mean.length; ++i) {             Assert.assertEquals(refMean[i], mean[i], 1.0e-12);         }      }      @Test     public void testSerial() {         VectorialMean stat = new VectorialMean(points[0].length);         for (int i = 0; i < points.length; ++i) {             stat.increment(points[i]);         }         Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.junit.Assert; import org.junit.Test;   /**  */ public class InteractionTest {      protected double mean = 12.40454545454550;     protected double var = 10.00235930735930;     protected double skew = 1.437423729196190;     protected double kurt = 2.377191264804700;      protected double tolerance = 10E-12;      protected double[] testArray =         {             12.5,             12,             11.8,             14.2,             14.9,             14.5,             21,             8.2,             10.3,             11.3,             14.1,             9.9,             12.2,             12,             12.1,             11,             19.8,             11,             10,             8.8,             9,             12.3 };      @Test     public void testInteraction() {          FourthMoment m4 = new FourthMoment();         Mean m = new Mean(m4);         Variance v = new Variance(m4);         Skewness s= new Skewness(m4);         Kurtosis k = new Kurtosis(m4);          for (int i = 0; i < testArray.length; i++){             m4.increment(testArray[i]);         }          Assert.assertEquals(mean,m.getResult(),tolerance);         Assert.assertEquals(var,v.getResult(),tolerance);         Assert.assertEquals(skew ,s.getResult(),tolerance);         Assert.assertEquals(kurt,k.getResult(),tolerance);      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic;  /**  * Test cases for the {@link FourthMoment} class.  */ public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{      /** descriptive statistic. */     protected FourthMoment stat;      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new FourthMoment();     }      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()      */     @Override     public double expectedValue() {        return this.fourthMoment;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class MeanTest extends StorelessUnivariateStatisticAbstractTest{      protected Mean stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Mean();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.mean;     }      /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */     public double expectedWeightedValue() {         return this.weightedMean;     }      @Test     public void testSmallSamples() {         Mean mean = new Mean();         Assert.assertTrue(Double.isNaN(mean.getResult()));         mean.increment(1d);         Assert.assertEquals(1d, mean.getResult(), 0);     }      @Test     public void testWeightedMean() {         Mean mean = new Mean();         Assert.assertEquals(expectedWeightedValue(), mean.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());         Assert.assertEquals(expectedValue(), mean.evaluate(testArray, identicalWeightsArray, 0, testArray.length), getTolerance());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{      protected GeometricMean stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new GeometricMean();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.geoMean;     }      @Test     public void testSpecialValues() {         GeometricMean mean = new GeometricMean();         // empty         Assert.assertTrue(Double.isNaN(mean.getResult()));          // finite data         mean.increment(1d);         Assert.assertFalse(Double.isNaN(mean.getResult()));          // add 0 -- makes log sum blow to minus infinity, should make 0         mean.increment(0d);         Assert.assertEquals(0d, mean.getResult(), 0);          // add positive infinity - note the minus infinity above         mean.increment(Double.POSITIVE_INFINITY);         Assert.assertTrue(Double.isNaN(mean.getResult()));          // clear         mean.clear();         Assert.assertTrue(Double.isNaN(mean.getResult()));          // positive infinity by itself         mean.increment(Double.POSITIVE_INFINITY);         Assert.assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);          // negative value -- should make NaN         mean.increment(-2d);         Assert.assertTrue(Double.isNaN(mean.getResult()));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.stat.StatUtils; import org.junit.Assert; import org.junit.Test;   public class SemiVarianceTest {      @Test     public void testInsufficientData() {         double[] nothing = null;         SemiVariance sv = new SemiVariance();         try {             sv.evaluate(nothing);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException nae) {         }          try {             sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);             sv.evaluate(nothing);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException nae) {         }         nothing = new double[] {};         Assert.assertTrue(Double.isNaN(sv.evaluate(nothing)));     }      @Test     public void testSingleDown() {         SemiVariance sv = new SemiVariance();         double[] values = { 50.0d };         double singletest = sv.evaluate(values);         Assert.assertEquals(0.0d, singletest, 0);     }      @Test     public void testSingleUp() {         SemiVariance sv = new SemiVariance(SemiVariance.UPSIDE_VARIANCE);         double[] values = { 50.0d };         double singletest = sv.evaluate(values);         Assert.assertEquals(0.0d, singletest, 0);     }      @Test     public void testSample() {         final double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };         final int length = values.length;         final double mean = StatUtils.mean(values); // 6.333...         final SemiVariance sv = new SemiVariance();  // Default bias correction is true         final double downsideSemiVariance = sv.evaluate(values); // Downside is the default         Assert.assertEquals(TestUtils.sumSquareDev(new double[] {-2d, 2d, 4d, -2d, 3d, 5d}, mean) / (length - 1),                 downsideSemiVariance, 1E-14);          sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);         final double upsideSemiVariance = sv.evaluate(values);         Assert.assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1),                 upsideSemiVariance, 1E-14);          // Verify that upper + lower semivariance against the mean sum to variance         Assert.assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12);     }      @Test     public void testPopulation() {         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };         SemiVariance sv = new SemiVariance(false);          double singletest = sv.evaluate(values);         Assert.assertEquals(19.556d, singletest, 0.01d);          sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);         singletest = sv.evaluate(values);         Assert.assertEquals(36.222d, singletest, 0.01d);     }      @Test     public void testNonMeanCutoffs() {         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };         SemiVariance sv = new SemiVariance(false); // Turn off bias correction - use df = length          double singletest = sv.evaluate(values, 1.0d, SemiVariance.DOWNSIDE_VARIANCE, false, 0, values.length);         Assert.assertEquals(TestUtils.sumSquareDev(new double[] { -2d, -2d }, 1.0d) / values.length,                 singletest, 0.01d);          singletest = sv.evaluate(values, 3.0d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length);         Assert.assertEquals(TestUtils.sumSquareDev(new double[] { 4d, 22d, 11d, 14d, 5d }, 3.0d) / values.length, singletest,                 0.01d);     }      /**      * Check that the lower + upper semivariance against the mean sum to the      * variance.      */     @Test     public void testVarianceDecompMeanCutoff() {         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };         double variance = StatUtils.variance(values);         SemiVariance sv = new SemiVariance(true); // Bias corrected         sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);         final double lower = sv.evaluate(values);         sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);         final double upper = sv.evaluate(values);         Assert.assertEquals(variance, lower + upper, 10e-12);     }      /**      * Check that upper and lower semivariances against a cutoff sum to the sum      * of squared deviations of the full set of values against the cutoff      * divided by df = length - 1 (assuming bias-corrected).      */     @Test     public void testVarianceDecompNonMeanCutoff() {         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };         double target = 0;         double totalSumOfSquares = TestUtils.sumSquareDev(values, target);         SemiVariance sv = new SemiVariance(true); // Bias corrected         sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);         double lower = sv.evaluate(values, target);         sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);         double upper = sv.evaluate(values, target);         Assert.assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12);     }      @Test     public void testNoVariance() {         final double[] values = {100d, 100d, 100d, 100d};         SemiVariance sv = new SemiVariance();         Assert.assertEquals(0, sv.evaluate(values), 10E-12);         Assert.assertEquals(0, sv.evaluate(values, 100d), 10E-12);         Assert.assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  *  */ public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{      protected Skewness stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Skewness();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.skew;     }      /**      * Make sure Double.NaN is returned iff n < 3      */     @Test     public void testNaN() {         Skewness skew = new Skewness();         Assert.assertTrue(Double.isNaN(skew.getResult()));         skew.increment(1d);         Assert.assertTrue(Double.isNaN(skew.getResult()));         skew.increment(1d);         Assert.assertTrue(Double.isNaN(skew.getResult()));         skew.increment(1d);         Assert.assertFalse(Double.isNaN(skew.getResult()));     }  } 
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements.  See the NOTICE file //distributed with this work for additional information //regarding copyright ownership.  The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License.  You may obtain a copy of the License at  //http://www.apache.org/licenses/LICENSE-2.0  //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied.  See the License for the //specific language governing permissions and limitations //under the License.  package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.linear.RealMatrix; import org.junit.Test; import org.junit.Assert;  public class VectorialCovarianceTest {     private double[][] points;      public VectorialCovarianceTest() {         points = new double[][] {             { 1.2, 2.3,  4.5},             {-0.7, 2.3,  5.0},             { 3.1, 0.0, -3.1},             { 6.0, 1.2,  4.2},             {-0.7, 2.3,  5.0}         };     }      @Test     public void testMismatch() {         try {             new VectorialCovariance(8, true).increment(new double[5]);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException dme) {             Assert.assertEquals(5, dme.getArgument());             Assert.assertEquals(8, dme.getDimension());         }     }      @Test     public void testSimplistic() {         VectorialCovariance stat = new VectorialCovariance(2, true);         stat.increment(new double[] {-1.0,  1.0});         stat.increment(new double[] { 1.0, -1.0});         RealMatrix c = stat.getResult();         Assert.assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);         Assert.assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);         Assert.assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);     }      @Test     public void testBasicStats() {          VectorialCovariance stat = new VectorialCovariance(points[0].length, true);         for (int i = 0; i < points.length; ++i) {             stat.increment(points[i]);         }          Assert.assertEquals(points.length, stat.getN());          RealMatrix c = stat.getResult();         double[][] refC    = new double[][] {                 { 8.0470, -1.9195, -3.4445},                 {-1.9195,  1.0470,  3.2795},                 {-3.4445,  3.2795, 12.2070}         };          for (int i = 0; i < c.getRowDimension(); ++i) {             for (int j = 0; j <= i; ++j) {                 Assert.assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);             }         }      }      @Test     public void testSerial(){         VectorialCovariance stat = new VectorialCovariance(points[0].length, true);         Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  *  */ public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{      protected StandardDeviation stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new StandardDeviation();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.std;     }      /**      * Make sure Double.NaN is returned iff n = 0      *      */     @Test     public void testNaN() {         StandardDeviation std = new StandardDeviation();         Assert.assertTrue(Double.isNaN(std.getResult()));         std.increment(1d);         Assert.assertEquals(0d, std.getResult(), 0);     }      /**      * Test population version of variance      */     @Test     public void testPopulation() {         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};         double sigma = populationStandardDeviation(values);         SecondMoment m = new SecondMoment();         m.incrementAll(values);  // side effect is to add values         StandardDeviation s1 = new StandardDeviation();         s1.setBiasCorrected(false);         Assert.assertEquals(sigma, s1.evaluate(values), 1E-14);         s1.incrementAll(values);         Assert.assertEquals(sigma, s1.getResult(), 1E-14);         s1 = new StandardDeviation(false, m);         Assert.assertEquals(sigma, s1.getResult(), 1E-14);         s1 = new StandardDeviation(false);         Assert.assertEquals(sigma, s1.evaluate(values), 1E-14);         s1.incrementAll(values);         Assert.assertEquals(sigma, s1.getResult(), 1E-14);     }      /**      * Definitional formula for population standard deviation      */     protected double populationStandardDeviation(double[] v) {         double mean = new Mean().evaluate(v);         double sum = 0;         for (int i = 0; i < v.length; i++) {             sum += (v[i] - mean) * (v[i] - mean);         }         return FastMath.sqrt(sum / v.length);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.apache.commons.math4.util.MathArrays; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  *  */ public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{      protected Variance stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Variance();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.var;     }      /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */     public double expectedWeightedValue() {         return this.weightedVar;     }      /**      * Make sure Double.NaN is returned iff n = 0      *      */     @Test     public void testNaN() {         StandardDeviation std = new StandardDeviation();         Assert.assertTrue(Double.isNaN(std.getResult()));         std.increment(1d);         Assert.assertEquals(0d, std.getResult(), 0);     }      /**      * Test population version of variance      */     @Test     public void testPopulation() {         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};         SecondMoment m = new SecondMoment();         m.incrementAll(values);  // side effect is to add values         Variance v1 = new Variance();         v1.setBiasCorrected(false);         Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);         v1.incrementAll(values);         Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);         v1 = new Variance(false, m);         Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);         v1 = new Variance(false);         Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);         v1.incrementAll(values);         Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);     }      /**      * Definitional formula for population variance      */     protected double populationVariance(double[] v) {         double mean = new Mean().evaluate(v);         double sum = 0;         for (int i = 0; i < v.length; i++) {            sum += (v[i] - mean) * (v[i] - mean);         }         return sum / v.length;     }      @Test     public void testWeightedVariance() {         Variance variance = new Variance();         Assert.assertEquals(expectedWeightedValue(),                 variance.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());          // All weights = 1 -> weighted variance = unweighted variance         Assert.assertEquals(expectedValue(),                 variance.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());          // All weights the same -> when weights are normalized to sum to the length of the values array,         // weighted variance = unweighted value         Assert.assertEquals(expectedValue(),                 variance.evaluate(testArray, MathArrays.normalizeArray(identicalWeightsArray, testArray.length),                         0, testArray.length), getTolerance());      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic;  /**  * Test cases for the {@link ThirdMoment} class.  */ public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{      /** descriptive statistic. */     protected ThirdMoment stat;      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new ThirdMoment();     }      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()      */     @Override     public double expectedValue() {       return this.thirdMoment;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.moment;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic;  /**  * Test cases for the {@link SecondMoment} class.  */ public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {      /** descriptive statistic. */     protected SecondMoment stat;      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new SecondMoment();     }      /**      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()      */     @Override     public double expectedValue() {         return this.secondMoment;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;   import java.util.Locale;  import org.apache.commons.math4.TestUtils; import org.junit.Assert; import org.junit.Test; /**  * Test cases for the {@link StatisticalSummaryValues} class.  *  */  public final class StatisticalSummaryValuesTest {      @Test     public void testSerialization() {         StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);         TestUtils.checkSerializedEquality(u);         StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);         verifyEquality(u, t);     }      @Test     public void testEqualsAndHashCode() {         StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);         StatisticalSummaryValues t = null;         Assert.assertTrue("reflexive", u.equals(u));         Assert.assertFalse("non-null compared to null", u.equals(t));         Assert.assertFalse("wrong type", u.equals(Double.valueOf(0)));         t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);         Assert.assertTrue("instances with same data should be equal", t.equals(u));         Assert.assertEquals("hash code", u.hashCode(), t.hashCode());          u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);         t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);         Assert.assertFalse("instances based on different data should be different",                 (u.equals(t) ||t.equals(u)));     }      private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {         Assert.assertEquals("N",s.getN(),u.getN());         TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0);         TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0);         TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0);         TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0);         TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0);         TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0);     }      @Test     public void testToString() {         StatisticalSummaryValues u  = new StatisticalSummaryValues(4.5, 16, 10, 5, 4, 45);         Locale d = Locale.getDefault();         Locale.setDefault(Locale.US);         Assert.assertEquals("StatisticalSummaryValues:\n" +                      "n: 10\n" +                      "min: 4.0\n" +                      "max: 5.0\n" +                      "mean: 4.5\n" +                      "std dev: 4.0\n" +                      "variance: 16.0\n" +                      "sum: 45.0\n",  u.toString());         Locale.setDefault(d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.rank;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class MaxTest extends StorelessUnivariateStatisticAbstractTest {      protected Max stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Max();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.max;     }      @Test     public void testSpecialValues() {         double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY};         Max max = new Max();         Assert.assertTrue(Double.isNaN(max.getResult()));         max.increment(testArray[0]);         Assert.assertEquals(0d, max.getResult(), 0);         max.increment(testArray[1]);         Assert.assertEquals(0d, max.getResult(), 0);         max.increment(testArray[2]);         Assert.assertEquals(0d, max.getResult(), 0);         max.increment(testArray[3]);         Assert.assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);         Assert.assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);     }      @Test     public void testNaNs() {         Max max = new Max();         double nan = Double.NaN;         Assert.assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);         Assert.assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);         Assert.assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);         Assert.assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.rank;  import java.util.Arrays;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.math4.distribution.AbstractRealDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NotANumberException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType; import org.apache.commons.math4.stat.ranking.NaNStrategy; import org.apache.commons.math4.util.CentralPivotingStrategy; import org.apache.commons.math4.util.KthSelector; import org.apache.commons.math4.util.MedianOf3PivotingStrategy; import org.apache.commons.math4.util.PivotingStrategyInterface; import org.apache.commons.math4.util.RandomPivotingStrategy; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class PercentileTest extends UnivariateStatisticAbstractTest{      protected Percentile stat;      private double quantile;      /**      * {@link org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType type}      * of estimation to be used while calling {@link #getUnivariateStatistic()}      */     private Percentile.EstimationType type;      /**      * {@link NaNStrategy}      * of estimation to be used while calling {@link #getUnivariateStatistic()}      */     private NaNStrategy nanStrategy;      /**      * kth selector      */     private KthSelector kthSelector;      /**      * A default percentile to be used for {@link #getUnivariateStatistic()}      */     protected final double DEFAULT_PERCENTILE = 95d;      /**      * Before method to ensure defaults retained      */     @Before     public void before() {         quantile         = 95.0;         type             = Percentile.EstimationType.LEGACY;         nanStrategy      = NaNStrategy.REMOVED;         kthSelector      = new KthSelector(new MedianOf3PivotingStrategy());     }      private void reset(final double p, final Percentile.EstimationType type) {         this.quantile = p;         this.type     = type;         nanStrategy   = (type == Percentile.EstimationType.LEGACY) ? NaNStrategy.FIXED : NaNStrategy.REMOVED;     }      /**      * {@inheritDoc}      */     @Override     public Percentile getUnivariateStatistic() {         return new Percentile(quantile).                 withEstimationType(type).                 withNaNStrategy(nanStrategy).                 withKthSelector(kthSelector);     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.percentile95;     }      @Test     public void testHighPercentile(){         final double[] d = new double[]{1, 2, 3};         final Percentile p = new Percentile(75);         Assert.assertEquals(3.0, p.evaluate(d), 1.0e-5);     }      @Test     public void testLowPercentile() {         final double[] d = new double[] {0, 1};         final Percentile p = new Percentile(25);         Assert.assertEquals(0d, p.evaluate(d), Double.MIN_VALUE);     }      @Test     public void testPercentile() {         final double[] d = new double[] {1, 3, 2, 4};         final Percentile p = new Percentile(30);         Assert.assertEquals(1.5, p.evaluate(d), 1.0e-5);         p.setQuantile(25);         Assert.assertEquals(1.25, p.evaluate(d), 1.0e-5);         p.setQuantile(75);         Assert.assertEquals(3.75, p.evaluate(d), 1.0e-5);         p.setQuantile(50);         Assert.assertEquals(2.5, p.evaluate(d), 1.0e-5);          // invalid percentiles         try {             p.evaluate(d, 0, d.length, -1.0);             Assert.fail();         } catch (final MathIllegalArgumentException ex) {             // success         }         try {             p.evaluate(d, 0, d.length, 101.0);             Assert.fail();         } catch (final MathIllegalArgumentException ex) {             // success         }     }      @Test     public void testNISTExample() {         final double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,                 95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682         };         final Percentile p = new Percentile(90);         Assert.assertEquals(95.1981, p.evaluate(d), 1.0e-4);         Assert.assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);     }      @Test     public void test5() {         final Percentile percentile = new Percentile(5);         Assert.assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());     }      @Test     public void testNullEmpty() {         final Percentile percentile = new Percentile(50);         final double[] nullArray = null;         final double[] emptyArray = new double[] {};         try {             percentile.evaluate(nullArray);             Assert.fail("Expecting NullArgumentException for null array");         } catch (final NullArgumentException ex) {             // expected         }         Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));     }      @Test     public void testSingleton() {         final Percentile percentile = new Percentile(50);         final double[] singletonArray = new double[] {1d};         Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);         Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);         Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);         Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);         Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));     }      @Test     public void testSpecialValues() {         final Percentile percentile = new Percentile(50);         double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};         Assert.assertEquals(/*2.5d*/2d, percentile.evaluate(specialValues), 0);         specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,                 Double.NaN, Double.POSITIVE_INFINITY};         Assert.assertEquals(/*2.5d*/2d, percentile.evaluate(specialValues), 0);         specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,                 Double.POSITIVE_INFINITY};         Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));         specialValues = new double[] {1d, 1d, Double.NaN,                 Double.NaN};         Assert.assertTrue(!Double.isNaN(percentile.evaluate(specialValues)));         Assert.assertTrue(1d==percentile.evaluate(specialValues));         specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,                 Double.NEGATIVE_INFINITY};         // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY         Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));     }      @Test     public void testSetQuantile() {         final Percentile percentile = new Percentile(10);         percentile.setQuantile(100); // OK         Assert.assertEquals(100, percentile.getQuantile(), 0);         try {             percentile.setQuantile(0);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (final MathIllegalArgumentException ex) {             // expected         }         try {             new Percentile(0);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (final MathIllegalArgumentException ex) {             // expected         }     }      //Below tests are basically to run for all estimation types.     /**      * While {@link #testHighPercentile()} checks only for the existing      * implementation; this method verifies for all the types including Percentile.Type.CM Percentile.Type.      */     @Test     public void testAllTechniquesHighPercentile() {         final double[] d = new double[] { 1, 2, 3 };         testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 3d }, { Percentile.EstimationType.R_1, 3d },                 { Percentile.EstimationType.R_2, 3d }, { Percentile.EstimationType.R_3, 2d }, { Percentile.EstimationType.R_4, 2.25 }, { Percentile.EstimationType.R_5, 2.75 },                 { Percentile.EstimationType.R_6, 3d }, { Percentile.EstimationType.R_7, 2.5 },{ Percentile.EstimationType.R_8, 2.83333 }, {Percentile.EstimationType.R_9,2.81250} },                 75d, 1.0e-5);     }      @Test     public void testAllTechniquesLowPercentile() {         final double[] d = new double[] { 0, 1 };         testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 0d }, { Percentile.EstimationType.R_1, 0d },                 { Percentile.EstimationType.R_2, 0d }, { Percentile.EstimationType.R_3, 0d }, { Percentile.EstimationType.R_4, 0d }, {Percentile.EstimationType.R_5, 0d}, {Percentile.EstimationType.R_6, 0d},                 { Percentile.EstimationType.R_7, 0.25 }, { Percentile.EstimationType.R_8, 0d }, {Percentile.EstimationType.R_9, 0d} },                 25d, Double.MIN_VALUE);     }      public void checkAllTechniquesPercentile() {         final double[] d = new double[] { 1, 3, 2, 4 };          testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 1.5d },                 { Percentile.EstimationType.R_1, 2d }, { Percentile.EstimationType.R_2, 2d }, { Percentile.EstimationType.R_3, 1d }, { Percentile.EstimationType.R_4, 1.2 }, {Percentile.EstimationType.R_5, 1.7},                 { Percentile.EstimationType.R_6, 1.5 },{ Percentile.EstimationType.R_7, 1.9 }, { Percentile.EstimationType.R_8, 1.63333 },{ Percentile.EstimationType.R_9, 1.65 } },                 30d, 1.0e-05);          testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 1.25d },                 { Percentile.EstimationType.R_1, 1d }, { Percentile.EstimationType.R_2, 1.5d }, { Percentile.EstimationType.R_3, 1d }, { Percentile.EstimationType.R_4, 1d }, {Percentile.EstimationType.R_5, 1.5},                 { Percentile.EstimationType.R_6, 1.25 },{ Percentile.EstimationType.R_7, 1.75 },                 { Percentile.EstimationType.R_8, 1.41667 }, { Percentile.EstimationType.R_9, 1.43750 } }, 25d, 1.0e-05);          testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 3.75d },                 { Percentile.EstimationType.R_1, 3d }, { Percentile.EstimationType.R_2, 3.5d }, { Percentile.EstimationType.R_3, 3d }, { Percentile.EstimationType.R_4, 3d },                 { Percentile.EstimationType.R_5, 3.5d },{ Percentile.EstimationType.R_6, 3.75d }, { Percentile.EstimationType.R_7, 3.25 },                 { Percentile.EstimationType.R_8, 3.58333 },{ Percentile.EstimationType.R_9, 3.56250} }, 75d, 1.0e-05);          testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 2.5d },                 { Percentile.EstimationType.R_1, 2d }, { Percentile.EstimationType.R_2, 2.5d }, { Percentile.EstimationType.R_3, 2d }, { Percentile.EstimationType.R_4, 2d },                 { Percentile.EstimationType.R_5, 2.5 },{ Percentile.EstimationType.R_6, 2.5 },{ Percentile.EstimationType.R_7, 2.5 },                 { Percentile.EstimationType.R_8, 2.5 },{ Percentile.EstimationType.R_9, 2.5 } }, 50d, 1.0e-05);          // invalid percentiles         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             try {                 reset(-1.0, e);                 getUnivariateStatistic().evaluate(d, 0, d.length);                 Assert.fail();             } catch (final MathIllegalArgumentException ex) {                 // success             }         }          for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             try {                 reset(101.0, e);                 getUnivariateStatistic().evaluate(d, 0, d.length);                 Assert.fail();             } catch (final MathIllegalArgumentException ex) {                 // success             }         }     }      @Test     public void testAllTechniquesPercentileUsingMedianOf3Pivoting() {         kthSelector = new KthSelector(new MedianOf3PivotingStrategy());         Assert.assertEquals(MedianOf3PivotingStrategy.class,                             getUnivariateStatistic().getPivotingStrategy().getClass());         checkAllTechniquesPercentile();     }      @Test     public void testAllTechniquesPercentileUsingCentralPivoting() {         kthSelector = new KthSelector(new CentralPivotingStrategy());         Assert.assertEquals(CentralPivotingStrategy.class,                             getUnivariateStatistic().getPivotingStrategy().getClass());         checkAllTechniquesPercentile();     }      @Test     public void testAllTechniquesPercentileUsingRandomPivoting() {         kthSelector = new KthSelector(new RandomPivotingStrategy(RandomSource.WELL_1024_A, 0x268a7fb4194240f6l));         Assert.assertEquals(RandomPivotingStrategy.class,                             getUnivariateStatistic().getPivotingStrategy().getClass());         checkAllTechniquesPercentile();     }      @Test     public void testAllTechniquesNISTExample() {         final double[] d =                 new double[] { 95.1772, 95.1567, 95.1937, 95.1959, 95.1442,                         95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990,                         95.1682 };          testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 95.1981 },                 { Percentile.EstimationType.R_1, 95.19590 }, { Percentile.EstimationType.R_2, 95.19590 }, { Percentile.EstimationType.R_3, 95.19590 },                 { Percentile.EstimationType.R_4, 95.19546 }, { Percentile.EstimationType.R_5, 95.19683 }, { Percentile.EstimationType.R_6, 95.19807 },                 { Percentile.EstimationType.R_7, 95.19568 }, { Percentile.EstimationType.R_8, 95.19724 }, { Percentile.EstimationType.R_9, 95.19714 } }, 90d,                 1.0e-04);          for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset(100.0, e);             Assert.assertEquals(95.1990, getUnivariateStatistic().evaluate(d), 1.0e-4);         }     }      @Test     public void testAllTechniques5() {         reset(5, Percentile.EstimationType.LEGACY);         final UnivariateStatistic percentile = getUnivariateStatistic();         Assert.assertEquals(this.percentile5, percentile.evaluate(testArray),                 getTolerance());         testAssertMappedValues(testArray,                 new Object[][] { { Percentile.EstimationType.LEGACY, percentile5 }, { Percentile.EstimationType.R_1, 8.8000 },                         { Percentile.EstimationType.R_2, 8.8000 }, { Percentile.EstimationType.R_3, 8.2000 }, { Percentile.EstimationType.R_4, 8.2600 },                         { Percentile.EstimationType.R_5, 8.5600 }, { Percentile.EstimationType.R_6, 8.2900 },                         { Percentile.EstimationType.R_7, 8.8100 }, { Percentile.EstimationType.R_8, 8.4700 },                         { Percentile.EstimationType.R_9, 8.4925 }}, 5d, getTolerance());     }      @Test     public void testAllTechniquesNullEmpty() {          final double[] nullArray = null;         final double[] emptyArray = new double[] {};         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset (50, e);             final UnivariateStatistic percentile = getUnivariateStatistic();             try {                 percentile.evaluate(nullArray);                 Assert.fail("Expecting NullArgumentException "                         + "for null array");             } catch (final NullArgumentException ex) {                 // expected             }             Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));         }      }      @Test     public void testAllTechniquesSingleton() {         final double[] singletonArray = new double[] { 1d };         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset (50, e);             final UnivariateStatistic percentile = getUnivariateStatistic();             Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);             Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1),                     0);             Assert.assertEquals(1d,                     new Percentile().evaluate(singletonArray, 0, 1, 5), 0);             Assert.assertEquals(1d,                     new Percentile().evaluate(singletonArray, 0, 1, 100), 0);             Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray,                     0, 0)));         }     }      @Test     public void testAllTechniquesEmpty() {         final double[] singletonArray = new double[] { };         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset (50, e);             final UnivariateStatistic percentile = getUnivariateStatistic();             Assert.assertEquals(Double.NaN, percentile.evaluate(singletonArray),                     0);             Assert.assertEquals(Double.NaN, percentile.evaluate(singletonArray,                     0, 0),                     0);             Assert.assertEquals(Double.NaN,                     new Percentile().evaluate(singletonArray, 0, 0, 5), 0);             Assert.assertEquals(Double.NaN,                     new Percentile().evaluate(singletonArray, 0, 0, 100), 0);             Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray,                     0, 0)));         }     }      @Test     public void testReplaceNanInRange() {         final double[] specialValues =                 new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN, Double.NaN, 5d,                 7d, Double.NaN, 8d};         Assert.assertEquals(/*Double.NaN*/3.5,new Percentile(50d).evaluate(specialValues),0d);         reset (50, Percentile.EstimationType.R_1);         Assert.assertEquals(3d, getUnivariateStatistic().evaluate(specialValues),0d);         reset (50, Percentile.EstimationType.R_2);         Assert.assertEquals(3.5d, getUnivariateStatistic().evaluate(specialValues),0d);         Assert.assertEquals(Double.POSITIVE_INFINITY,new Percentile(70)                                         .withNaNStrategy(NaNStrategy.MAXIMAL)                                         .evaluate(specialValues),0d);     }      @Test     public void testRemoveNan() {         final double[] specialValues =                 new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };         final double[] expectedValues =                 new double[] { 0d, 1d, 2d, 3d, 4d };         reset (50, Percentile.EstimationType.R_1);         Assert.assertEquals(2.0, getUnivariateStatistic().evaluate(specialValues), 0d);         Assert.assertEquals(2.0, getUnivariateStatistic().evaluate(expectedValues),0d);         Assert.assertTrue(Double.isNaN(getUnivariateStatistic().evaluate(specialValues,5,1)));         Assert.assertEquals(4d, getUnivariateStatistic().evaluate(specialValues, 4, 2), 0d);         Assert.assertEquals(3d, getUnivariateStatistic().evaluate(specialValues,3,3),0d);         reset(50, Percentile.EstimationType.R_2);         Assert.assertEquals(3.5d, getUnivariateStatistic().evaluate(specialValues,3,3),0d);      }      @Test     public void testPercentileCopy() {        reset(50d, Percentile.EstimationType.LEGACY);        final Percentile original = getUnivariateStatistic();        final Percentile copy = new Percentile(original);        Assert.assertEquals(original.getNaNStrategy(),copy.getNaNStrategy());        Assert.assertEquals(original.getQuantile(), copy.getQuantile(),0d);        Assert.assertEquals(original.getEstimationType(),copy.getEstimationType());        Assert.assertEquals(NaNStrategy.FIXED, original.getNaNStrategy());     }      @Test     public void testAllTechniquesSpecialValues() {         reset(50d, Percentile.EstimationType.LEGACY);         final UnivariateStatistic percentile = getUnivariateStatistic();         double[] specialValues =                 new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };         Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);          testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },                 { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_6, 2.0 },                 { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 }}, 50d, 0d);          specialValues =                 new double[] { Double.NEGATIVE_INFINITY, 1d, 2d, 3d,                         Double.NaN, Double.POSITIVE_INFINITY };         Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);          testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },                 { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_7, 2.0 },                 { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 } }, 50d, 0d);          specialValues =                 new double[] { 1d, 1d, Double.POSITIVE_INFINITY,                         Double.POSITIVE_INFINITY };         Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));          testAssertMappedValues(specialValues, new Object[][] {                 // This is one test not matching with R results.                 { Percentile.EstimationType.LEGACY, Double.POSITIVE_INFINITY },                 { Percentile.EstimationType.R_1,/* 1.0 */Double.NaN },                 { Percentile.EstimationType.R_2, /* Double.POSITIVE_INFINITY */Double.NaN },                 { Percentile.EstimationType.R_3, /* 1.0 */Double.NaN }, { Percentile.EstimationType.R_4, /* 1.0 */Double.NaN },                 { Percentile.EstimationType.R_5, Double.POSITIVE_INFINITY },                 { Percentile.EstimationType.R_6, Double.POSITIVE_INFINITY },                 { Percentile.EstimationType.R_7, Double.POSITIVE_INFINITY },                 { Percentile.EstimationType.R_8, Double.POSITIVE_INFINITY },                 { Percentile.EstimationType.R_9, Double.POSITIVE_INFINITY }, }, 50d, 0d);          specialValues = new double[] { 1d, 1d, Double.NaN, Double.NaN };         Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));         testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, Double.NaN }, { Percentile.EstimationType.R_1, 1.0 }, { Percentile.EstimationType.R_2, 1.0 }, { Percentile.EstimationType.R_3, 1.0 },                 { Percentile.EstimationType.R_4, 1.0 }, { Percentile.EstimationType.R_5, 1.0 },{ Percentile.EstimationType.R_6, 1.0 },{ Percentile.EstimationType.R_7, 1.0 },                 { Percentile.EstimationType.R_8, 1.0 }, { Percentile.EstimationType.R_9, 1.0 },}, 50d, 0d);          specialValues =                 new double[] { 1d, 1d, Double.NEGATIVE_INFINITY,                         Double.NEGATIVE_INFINITY };          testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, Double.NaN }, { Percentile.EstimationType.R_1, Double.NaN },                 { Percentile.EstimationType.R_2, Double.NaN }, { Percentile.EstimationType.R_3, Double.NaN }, { Percentile.EstimationType.R_4, Double.NaN },                 { Percentile.EstimationType.R_5, Double.NaN }, { Percentile.EstimationType.R_6, Double.NaN },                 { Percentile.EstimationType.R_7, Double.NaN }, { Percentile.EstimationType.R_8, Double.NaN }, { Percentile.EstimationType.R_9, Double.NaN }                 }, 50d, 0d);      }      @Test     public void testAllTechniquesSetQuantile() {         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset(10, e);             final Percentile percentile = getUnivariateStatistic();             percentile.setQuantile(100); // OK             Assert.assertEquals(100, percentile.getQuantile(), 0);             try {                 percentile.setQuantile(0);                 Assert.fail("Expecting MathIllegalArgumentException");             } catch (final MathIllegalArgumentException ex) {                 // expected             }             try {                 new Percentile(0);                 Assert.fail("Expecting MathIllegalArgumentException");             } catch (final MathIllegalArgumentException ex) {                 // expected             }         }     }      @Test     public void testAllTechniquesEvaluateArraySegmentWeighted() {         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset(quantile, e);             testEvaluateArraySegmentWeighted();         }     }      @Test     public void testAllTechniquesEvaluateArraySegment() {         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset(quantile, e);             testEvaluateArraySegment();         }     }      @Test     public void testAllTechniquesWeightedConsistency() {         for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {             reset(quantile, e);             testWeightedConsistency();         }     }      @Test     public void testAllTechniquesEvaluation() {          testAssertMappedValues(testArray, new Object[][] { { Percentile.EstimationType.LEGACY, 20.820 },                 { Percentile.EstimationType.R_1, 19.800 }, { Percentile.EstimationType.R_2, 19.800 }, { Percentile.EstimationType.R_3, 19.800 },                 { Percentile.EstimationType.R_4, 19.310 }, { Percentile.EstimationType.R_5, 20.280 }, { Percentile.EstimationType.R_6, 20.820 },                 { Percentile.EstimationType.R_7, 19.555 }, { Percentile.EstimationType.R_8, 20.460 },{ Percentile.EstimationType.R_9, 20.415} },                 DEFAULT_PERCENTILE, tolerance);     }      @Test     public void testPercentileWithTechnique() {         reset (50, Percentile.EstimationType.LEGACY);;         final Percentile p = getUnivariateStatistic();         Assert.assertTrue(Percentile.EstimationType.LEGACY.equals(p.getEstimationType()));         Assert.assertFalse(Percentile.EstimationType.R_1.equals(p.getEstimationType()));     }      static final int TINY = 10, SMALL = 50, NOMINAL = 100, MEDIUM = 500,             STANDARD = 1000, BIG = 10000, VERY_BIG = 50000, LARGE = 1000000,             VERY_LARGE = 10000000;     static final int[] sampleSizes= {TINY , SMALL , NOMINAL , MEDIUM ,             STANDARD, BIG };      @Test     public void testStoredVsDirect() {         final ContinuousDistribution.Sampler sampler =             new NormalDistribution(4000, 50).createSampler(RandomSource.create(RandomSource.JDK,                                                                                Long.MAX_VALUE));          for (final int sampleSize : sampleSizes) {             final double[] data = AbstractRealDistribution.sample(sampleSize, sampler);             for (final double p : new double[] { 50d, 95d }) {                 for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {                     reset(p, e);                     final Percentile pStoredData = getUnivariateStatistic();                     pStoredData.setData(data);                     final double storedDataResult = pStoredData.evaluate();                     pStoredData.setData(null);                     final Percentile pDirect = getUnivariateStatistic();                     Assert.assertEquals("Sample=" + sampleSize + ", P=" + p + " e=" + e,                                         storedDataResult,                                         pDirect.evaluate(data), 0d);                 }             }         }     }      @Test     public void testPercentileWithDataRef() {         reset(50.0, Percentile.EstimationType.R_7);         final Percentile p = getUnivariateStatistic();         p.setData(testArray);         Assert.assertTrue(Percentile.EstimationType.R_7.equals(p.getEstimationType()));         Assert.assertFalse(Percentile.EstimationType.R_1.equals(p.getEstimationType()));         Assert.assertEquals(12d, p.evaluate(), 0d);         Assert.assertEquals(12.16d, p.evaluate(60d), 0d);     }      @Test(expected=NullArgumentException.class)     public void testNullEstimation() {         type = null;         getUnivariateStatistic();     }      @Test     public void testAllEstimationTechniquesOnlyLimits() {         final int N=testArray.length;          final double[] input = Arrays.copyOf(testArray, testArray.length);         Arrays.sort(input);         final double min = input[0];         final double max=input[input.length-1];         //limits may be ducked by 0.01 to induce the condition of p<pMin         final Object[][] map =                 new Object[][] { { Percentile.EstimationType.LEGACY, 0d, 1d }, { Percentile.EstimationType.R_1, 0d, 1d },                         { Percentile.EstimationType.R_2, 0d,1d }, { Percentile.EstimationType.R_3, 0.5/N,1d },                         { Percentile.EstimationType.R_4, 1d/N-0.001,1d },                         { Percentile.EstimationType.R_5, 0.5/N-0.001,(N-0.5)/N}, { Percentile.EstimationType.R_6, 0.99d/(N+1),                             1.01d*N/(N+1)},                         { Percentile.EstimationType.R_7, 0d,1d}, { Percentile.EstimationType.R_8, 1.99d/3/(N+1d/3),                             (N-1d/3)/(N+1d/3)},                         { Percentile.EstimationType.R_9, 4.99d/8/(N+0.25), (N-3d/8)/(N+0.25)} };          for(final Object[] arr:map) {             final Percentile.EstimationType t= (Percentile.EstimationType) arr[0];             double pMin=(Double)arr[1];             final double pMax=(Double)arr[2];             Assert.assertEquals("Type:"+t,0d, t.index(pMin, N),0d);             Assert.assertEquals("Type:"+t,N, t.index(pMax, N),0.5d);             pMin=pMin==0d?pMin+0.01:pMin;             testAssertMappedValues(testArray, new Object[][] { { t, min }}, pMin, 0.01);             testAssertMappedValues(testArray, new Object[][] { { t, max }}, pMax * 100, tolerance);         }     }      @Test     public void testAllEstimationTechniquesOnly() {         Assert.assertEquals("Legacy Apache Commons Math",Percentile.EstimationType.LEGACY.getName());         final Object[][] map =                 new Object[][] { { Percentile.EstimationType.LEGACY, 20.82 }, { Percentile.EstimationType.R_1, 19.8 },                         { Percentile.EstimationType.R_2, 19.8 }, { Percentile.EstimationType.R_3, 19.8 }, { Percentile.EstimationType.R_4, 19.310 },                         { Percentile.EstimationType.R_5, 20.280}, { Percentile.EstimationType.R_6, 20.820},                         { Percentile.EstimationType.R_7, 19.555 }, { Percentile.EstimationType.R_8, 20.460 },{Percentile.EstimationType.R_9,20.415} };         try {             Percentile.EstimationType.LEGACY.evaluate(testArray, -1d, new KthSelector(new MedianOf3PivotingStrategy()));         } catch (final OutOfRangeException oore) {         }         try {             Percentile.EstimationType.LEGACY.evaluate(testArray, 101d, new KthSelector());         } catch (final OutOfRangeException oore) {         }         try {             Percentile.EstimationType.LEGACY.evaluate(testArray, 50d, new KthSelector());         } catch(final OutOfRangeException oore) {         }         for (final Object[] o : map) {             final Percentile.EstimationType e = (Percentile.EstimationType) o[0];             final double expected = (Double) o[1];             final double result = e.evaluate(testArray, DEFAULT_PERCENTILE, new KthSelector());             Assert.assertEquals("expected[" + e + "] = " + expected +                     " but was = " + result, expected, result, tolerance);         }     }      @Test     public void testAllEstimationTechniquesOnlyForAllPivotingStrategies() {          Assert.assertEquals("Legacy Apache Commons Math",Percentile.EstimationType.LEGACY.getName());          for (final PivotingStrategyInterface strategy : new PivotingStrategyInterface[] {             new MedianOf3PivotingStrategy(),             new CentralPivotingStrategy(),             new RandomPivotingStrategy(RandomSource.WELL_1024_A, 0xf097c734e4740053l)         }) {             kthSelector = new KthSelector(strategy);             testAllEstimationTechniquesOnly();         }     }      @Test     public void testAllEstimationTechniquesOnlyForExtremeIndexes() {         final double MAX=100;         final Object[][] map =                 new Object[][] { { Percentile.EstimationType.LEGACY, 0d, MAX}, { Percentile.EstimationType.R_1, 0d,MAX+0.5 },                 { Percentile.EstimationType.R_2, 0d,MAX}, { Percentile.EstimationType.R_3, 0d,MAX }, { Percentile.EstimationType.R_4, 0d,MAX },                 { Percentile.EstimationType.R_5, 0d,MAX }, { Percentile.EstimationType.R_6, 0d,MAX },                 { Percentile.EstimationType.R_7, 0d,MAX }, { Percentile.EstimationType.R_8, 0d,MAX }, { Percentile.EstimationType.R_9, 0d,MAX }  };         for (final Object[] o : map) {             final Percentile.EstimationType e = (Percentile.EstimationType) o[0];                 Assert.assertEquals(((Double)o[1]).doubleValue(),                         e.index(0d, (int)MAX),0d);                 Assert.assertEquals("Enum:"+e,((Double)o[2]).doubleValue(),                         e.index(1.0, (int)MAX),0d);             }     }      @Test     public void testAllEstimationTechniquesOnlyForNullsAndOOR() {          final Object[][] map =                 new Object[][] { { Percentile.EstimationType.LEGACY, 20.82 }, { Percentile.EstimationType.R_1, 19.8 },                         { Percentile.EstimationType.R_2, 19.8 }, { Percentile.EstimationType.R_3, 19.8 }, { Percentile.EstimationType.R_4, 19.310 },                         { Percentile.EstimationType.R_5, 20.280}, { Percentile.EstimationType.R_6, 20.820},                         { Percentile.EstimationType.R_7, 19.555 }, { Percentile.EstimationType.R_8, 20.460 },{ Percentile.EstimationType.R_9, 20.415 } };         for (final Object[] o : map) {             final Percentile.EstimationType e = (Percentile.EstimationType) o[0];             try {                 e.evaluate(null, DEFAULT_PERCENTILE, new KthSelector());                 Assert.fail("Expecting NullArgumentException");             } catch (final NullArgumentException nae) {                 // expected             }             try {                 e.evaluate(testArray, 120, new KthSelector());                 Assert.fail("Expecting OutOfRangeException");             } catch (final OutOfRangeException oore) {                 // expected             }         }     }      /**      * Simple test assertion utility method assuming {@link NaNStrategy default}      * nan handling strategy specific to each {@link EstimationType type}      *      * @param data input data      * @param map of expected result against a {@link EstimationType}      * @param p the quantile to compute for      * @param tolerance the tolerance of difference allowed      */     protected void testAssertMappedValues(final double[] data, final Object[][] map,             final Double p, final Double tolerance) {         for (final Object[] o : map) {             final Percentile.EstimationType e = (Percentile.EstimationType) o[0];             final double expected = (Double) o[1];             try {                 reset(p, e);                 final double result = getUnivariateStatistic().evaluate(data);                 Assert.assertEquals("expected[" + e + "] = " + expected +                     " but was = " + result, expected, result, tolerance);             } catch(final Exception ex) {                 Assert.fail("Exception occured for estimation type "+e+":"+                         ex.getLocalizedMessage());             }         }     }      // Some NaNStrategy specific testing     @Test     public void testNanStrategySpecific() {         double[] specialValues = new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };         Assert.assertTrue(Double.isNaN(new Percentile(50d).withEstimationType(Percentile.EstimationType.LEGACY).withNaNStrategy(NaNStrategy.MAXIMAL).evaluate(specialValues, 3, 3)));         Assert.assertEquals(2d,new Percentile(50d).withEstimationType(Percentile.EstimationType.R_1).withNaNStrategy(NaNStrategy.REMOVED).evaluate(specialValues),0d);         Assert.assertEquals(Double.NaN,new Percentile(50d).withEstimationType(Percentile.EstimationType.R_5).withNaNStrategy(NaNStrategy.REMOVED).evaluate(new double[] {Double.NaN,Double.NaN,Double.NaN}),0d);         Assert.assertEquals(50d,new Percentile(50d).withEstimationType(Percentile.EstimationType.R_7).withNaNStrategy(NaNStrategy.MINIMAL).evaluate(new double[] {50d,50d,50d},1,2),0d);          specialValues = new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN, Double.NaN };         Assert.assertEquals(3.5,new Percentile().evaluate(specialValues, 3, 4),0d);         Assert.assertEquals(4d,new Percentile().evaluate(specialValues, 4, 3),0d);         Assert.assertTrue(Double.isNaN(new Percentile().evaluate(specialValues, 5, 2)));          specialValues = new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN, Double.NaN, 5d, 6d };         Assert.assertEquals(4.5,new Percentile().evaluate(specialValues, 3, 6),0d);         Assert.assertEquals(5d,new Percentile().evaluate(specialValues, 4, 5),0d);         Assert.assertTrue(Double.isNaN(new Percentile().evaluate(specialValues, 5, 2)));         Assert.assertTrue(Double.isNaN(new Percentile().evaluate(specialValues, 5, 1)));         Assert.assertEquals(5.5,new Percentile().evaluate(specialValues, 5, 4),0d);     }      // Some NaNStrategy specific testing     @Test(expected=NotANumberException.class)     public void testNanStrategyFailed() {         double[] specialValues =                 new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };         new Percentile(50d).         withEstimationType(Percentile.EstimationType.R_9).         withNaNStrategy(NaNStrategy.FAILED).         evaluate(specialValues);     }      @Test     public void testAllTechniquesSpecialValuesWithNaNStrategy() {         double[] specialValues =                 new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };         try {             new Percentile(50d).withEstimationType(Percentile.EstimationType.LEGACY).withNaNStrategy(null);             Assert.fail("Expecting NullArgumentArgumentException "                     + "for null Nan Strategy");         } catch (NullArgumentException ex) {             // expected         }         //This is as per each type's default NaNStrategy         testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },                 { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_6, 2.0 },                 { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 }}, 50d, 0d);          //This is as per MAXIMAL and hence the values tend a +0.5 upward         testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.5 }, { Percentile.EstimationType.R_3, 2.0 },                 { Percentile.EstimationType.R_4, 2.0 }, { Percentile.EstimationType.R_5, 2.5 }, { Percentile.EstimationType.R_6, 2.5 },                 { Percentile.EstimationType.R_7, 2.5 }, { Percentile.EstimationType.R_8, 2.5 }, { Percentile.EstimationType.R_9, 2.5 }}, 50d, 0d,                 NaNStrategy.MAXIMAL);          //This is as per MINIMAL and hence the values tend a -0.5 downward         testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, 1.5d }, { Percentile.EstimationType.R_1, 1.0 }, { Percentile.EstimationType.R_2, 1.5 }, { Percentile.EstimationType.R_3, 1.0 },                 { Percentile.EstimationType.R_4, 1.0 }, { Percentile.EstimationType.R_5, 1.5 }, { Percentile.EstimationType.R_6, 1.5 },                 { Percentile.EstimationType.R_7, 1.5 }, { Percentile.EstimationType.R_8, 1.5 }, { Percentile.EstimationType.R_9, 1.5 }}, 50d, 0d,                 NaNStrategy.MINIMAL);          //This is as per REMOVED as here Percentile.Type.CM changed its value from default         //while rest of Estimation types were anyways defaulted to REMOVED         testAssertMappedValues(specialValues, new Object[][] {                 { Percentile.EstimationType.LEGACY, 2.0 }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },                 { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_6, 2.0 },                 { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 }}, 50d, 0d,                 NaNStrategy.REMOVED);     }      /**      * Simple test assertion utility method      *      * @param data input data      * @param map of expected result against a {@link EstimationType}      * @param p the quantile to compute for      * @param tolerance the tolerance of difference allowed      * @param nanStrategy NaNStrategy to be passed      */     protected void testAssertMappedValues(double[] data, Object[][] map,                                           Double p, Double tolerance, NaNStrategy nanStrategy) {         for (Object[] o : map) {             Percentile.EstimationType e = (Percentile.EstimationType) o[0];             double expected = (Double) o[1];             try {                 double result = new Percentile(p).withEstimationType(e).withNaNStrategy(nanStrategy).evaluate(data);                 Assert.assertEquals("expected[" + e + "] = " + expected + " but was = " + result,                                     expected, result, tolerance);             } catch(Exception ex) {                 Assert.fail("Exception occured for estimation type " + e + ":" + ex.getLocalizedMessage());             }         }     }      // Test if weighted percentile got the same result with the non-weighted one     // when all weights are equal to each other.     @Test     public void testResultWithNonWeightedPercentile() {         double[] dataset =                 new double[] { Double.NaN, Double.NaN, Double.NaN };         double[] weights =                 new double[] { 1, 1, 1 };         Percentile p = new Percentile().                            withEstimationType(Percentile.EstimationType.R_7).                            withNaNStrategy(NaNStrategy.MAXIMAL);         Assert.assertEquals(p.evaluate(dataset, weights, 25d), p.evaluate(dataset, 25d), 0d);         Assert.assertEquals(p.evaluate(dataset, weights, 50d), p.evaluate(dataset, 50d), 0d);         Assert.assertEquals(p.evaluate(dataset, weights, 75d), p.evaluate(dataset, 75d), 0d);         p = new Percentile().                 withEstimationType(Percentile.EstimationType.R_7).                 withNaNStrategy(NaNStrategy.MINIMAL);         Assert.assertEquals(p.evaluate(dataset, weights, 25d), p.evaluate(dataset, 25d), 0d);         Assert.assertEquals(p.evaluate(dataset, weights, 50d), p.evaluate(dataset, 50d), 0d);         Assert.assertEquals(p.evaluate(dataset, weights, 75d), p.evaluate(dataset, 75d), 0d);         p = new Percentile().                 withEstimationType(Percentile.EstimationType.R_7);         Assert.assertEquals(p.evaluate(dataset, weights, 25d), p.evaluate(dataset, 25d), 0d);         Assert.assertEquals(p.evaluate(dataset, weights, 50d), p.evaluate(dataset, 50d), 0d);         Assert.assertEquals(p.evaluate(dataset, weights, 75d), p.evaluate(dataset, 75d), 0d);     }      @Test(expected=MathIllegalArgumentException.class)     public void testDataAndWeightsLength() {         double[] dataset =                 new double[] { 1d, 2d, 3d, 4d, 5d };         double[] weights =         new double[] { 1, 1, 1, 1 };         new Percentile().         withEstimationType(Percentile.EstimationType.R_7).         evaluate(dataset, weights, 50d);     }      @Test     public void testWeightedPercentileWithSpecialValues() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 2, 6, 4, 3};         Percentile p = new Percentile().                            withEstimationType(Percentile.EstimationType.R_7);         Assert.assertEquals( 3.53125, p.evaluate(dataset, weights, 50d), 0d);     }      @Test(expected=MathIllegalArgumentException.class)     public void testsetDataInputLength() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1 };         new Percentile().setData(dataset, weights);         new Percentile().setData(dataset, weights, 0, dataset.length);     }      @Test(expected=NotANumberException.class)     public void testsetDataNotANumber() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1, Double.NaN };         new Percentile().setData(dataset, weights);         new Percentile().setData(dataset, weights, 0, dataset.length);     }      @Test(expected=NotStrictlyPositiveException.class)     public void testsetDataPositiveWeights() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { -1, -1, -1, -1 };         new Percentile().setData(dataset, weights);         new Percentile().setData(dataset, weights, 0, dataset.length);     }      @Test(expected=NotPositiveException.class)     public void testsetDataPositivIndex() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1, 1 };         new Percentile().setData(dataset, weights, -1, dataset.length);         new Percentile().setData(dataset, weights, 0, -1);     }      @Test(expected=NumberIsTooLargeException.class)     public void testsetDataIndexOutBound() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1, 1 };         new Percentile().setData(dataset, weights, 0, dataset.length+1);     }      @Test(expected=NullPointerException.class)     public void testsetDataInputNull() {         new Percentile().setData(null, null);         new Percentile().setData(null, null, 0, 0);     }      @Test(expected=MathIllegalArgumentException.class)     public void testevaluateInputLength() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1 };         Percentile p = new Percentile().withEstimationType(Percentile.EstimationType.R_7);         p.setData(dataset, weights);         p.evaluate(50);         p.evaluate(dataset, weights, 50);         p.evaluate(dataset, weights, 0, dataset.length);         p.evaluate(dataset, weights, 0, dataset.length, 50);     }      @Test(expected=NotPositiveException.class)     public void testevaluatePositivIndex() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1 ,1};         Percentile p = new Percentile().withEstimationType(Percentile.EstimationType.R_7);         p.setData(dataset, weights);         p.evaluate(50);         p.evaluate(dataset, weights, 50);         p.evaluate(dataset, weights, -1, dataset.length);         p.evaluate(dataset, weights, 0, -1, 50);     }      @Test(expected=NotStrictlyPositiveException.class)     public void testevaluatePositivWeights() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { -1, -1, -1 , -1};         Percentile p = new Percentile().withEstimationType(Percentile.EstimationType.R_7);         p.setData(dataset, weights);         p.evaluate(50);         p.evaluate(dataset, weights, 50);         p.evaluate(dataset, weights, 0, dataset.length);         p.evaluate(dataset, weights, 0, dataset.length, 50);     }      @Test(expected=NotANumberException.class)     public void testevaluateNotANumber() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1, Double.NaN};         Percentile p = new Percentile().withEstimationType(Percentile.EstimationType.R_7);         p.setData(dataset, weights);         p.evaluate(50);         p.evaluate(dataset, weights, 50);         p.evaluate(dataset, weights, 0, dataset.length);         p.evaluate(dataset, weights, 0, dataset.length, 50);     }      @Test(expected=NotStrictlyPositiveException.class)     public void testevaluatePositiveWeights() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { -1, -1, -1, -1};         Percentile p = new Percentile().withEstimationType(Percentile.EstimationType.R_7);         p.setData(dataset, weights);         p.evaluate(50);         p.evaluate(dataset, weights, 50);         p.evaluate(dataset, weights, 0, dataset.length);         p.evaluate(dataset, weights, 0, dataset.length, 50);     }      @Test(expected=OutOfRangeException.class)     public void testevaluatep() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1, 1};         Percentile p = new Percentile().withEstimationType(Percentile.EstimationType.R_7);         p.setData(dataset, weights);         p.evaluate(101);         p.evaluate(dataset, weights, 101);         p.evaluate(dataset, weights, 0, dataset.length);         p.evaluate(dataset, weights, 0, dataset.length, 101);     }      @Test(expected=NumberIsTooLargeException.class)     public void testevaluateIndexBound() {         double[] dataset = new double[] { 3, 4, 2, 9 };         double[] weights = new double[] { 1, 1, 1, 1};         Percentile p = new Percentile().withEstimationType(Percentile.EstimationType.R_7);         p.setData(dataset, weights);         p.evaluate(50);         p.evaluate(dataset, weights, 50);         p.evaluate(dataset, weights, 0, dataset.length + 1);         p.evaluate(dataset, weights, 0, dataset.length + 1, 50);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.rank;  import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.Set;  import org.apache.commons.statistics.distribution.LogNormalDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.math4.distribution.AbstractRealDistribution; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link PSquarePercentile} class which naturally extends  * {@link StorelessUnivariateStatisticAbstractTest}.  */ public class PSquarePercentileTest extends         StorelessUnivariateStatisticAbstractTest {      protected double percentile5 = 8.2299d;     protected double percentile95 = 16.72195;// 20.82d; this is approximation     protected double tolerance = 10E-12;      private final UniformRandomProvider randomGenerator = RandomSource.create(RandomSource.WELL_19937_C, 1000);      @Override     public double getTolerance() {         return 1.0e-2;// tolerance limit changed as this is an approximation         // algorithm and also gets accurate after few tens of         // samples     }      /**      * Verifies that copied statistics remain equal to originals when      * incremented the same way by making the copy after a majority of elements      * are incremented      */     @Test     public void testCopyConsistencyWithInitialMostElements() {          StorelessUnivariateStatistic master =                 (StorelessUnivariateStatistic) getUnivariateStatistic();          StorelessUnivariateStatistic replica = null;          // select a portion of testArray till 75 % of the length to load first         long index = FastMath.round(0.75 * testArray.length);          // Put first half in master and copy master to replica         master.incrementAll(testArray, 0, (int) index);         replica = master.copy();          // Check same         Assert.assertTrue(replica.equals(master));         Assert.assertTrue(master.equals(replica));          // Now add second part to both and check again         master.incrementAll(testArray, (int) index,                 (int) (testArray.length - index));         replica.incrementAll(testArray, (int) index,                 (int) (testArray.length - index));         Assert.assertTrue(replica.equals(master));         Assert.assertTrue(master.equals(replica));     }      /**      * Verifies that copied statistics remain equal to originals when      * incremented the same way by way of copying original after just a few      * elements are incremented      */     @Test     public void testCopyConsistencyWithInitialFirstFewElements() {          StorelessUnivariateStatistic master =                 (StorelessUnivariateStatistic) getUnivariateStatistic();          StorelessUnivariateStatistic replica = null;          // select a portion of testArray which is 10% of the length to load         // first         long index = FastMath.round(0.1 * testArray.length);          // Put first half in master and copy master to replica         master.incrementAll(testArray, 0, (int) index);         replica = master.copy();          // Check same         Assert.assertTrue(replica.equals(master));         Assert.assertTrue(master.equals(replica));         // Now add second part to both and check again         master.incrementAll(testArray, (int) index,                 (int) (testArray.length - index));         replica.incrementAll(testArray, (int) index,                 (int) (testArray.length - index));         Assert.assertTrue(master.equals(master));         Assert.assertTrue(replica.equals(replica));         Assert.assertTrue(replica.equals(master));         Assert.assertTrue(master.equals(replica));     }      @Test(expected = MathIllegalArgumentException.class)     public void testNullListInMarkers() {         // In case of null list Markers cannot be instantiated..is getting         // verified         // new Markers(null, 0, PSquarePercentile.newEstimator());         PSquarePercentile.newMarkers(null, 0);      }      @Test     public void testMiscellaniousFunctionsInMarkers() {         double p = 0.5;         PSquareMarkers markers =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 0.02, 1.18, 9.15, 21.91,                                 38.62 }), p);         // Markers equality         Assert.assertTrue(markers.equals(markers));         Assert.assertFalse(markers.equals(null));         Assert.assertFalse(markers.equals(new String()));         // Check for null markers test during equality testing         // Until 5 elements markers are not initialized         PSquarePercentile p1 = new PSquarePercentile(), p2 =                 new PSquarePercentile();         Assert.assertEquals(p1, p2);         p1.evaluate(new double[] { 1.0, 2.0, 3.0 });         p2.evaluate(new double[] { 1.0, 2.0, 3.0 });         Assert.assertEquals(p1, p2);         // Move p2 alone with more values just to make sure markers are not null         // for p2         p2.incrementAll(new double[] { 5.0, 7.0, 11.0 });         Assert.assertFalse(p1.equals(p2));         Assert.assertFalse(p2.equals(p1));         // Next add different data to p1 to make number of elements match and         // markers are not null however actual results will vary         p1.incrementAll(new double[] { 20, 21, 22, 23 });         Assert.assertFalse(p1.equals(p2));// though markers are non null, N         // matches, results wont      }      @Test(expected = OutOfRangeException.class)     public void testMarkersOORLow() {         PSquarePercentile.newMarkers(                 Arrays.asList(new Double[] { 0.02, 1.18, 9.15, 21.91, 38.62 }),                 0.5).estimate(0);     }      @Test(expected = OutOfRangeException.class)     public void testMarkersOORHigh() {         PSquarePercentile.newMarkers(                 Arrays.asList(new Double[] { 0.02, 1.18, 9.15, 21.91, 38.62 }),                 0.5).estimate(5);     }      @Test     public void testMarkers2() {         double p = 0.5;         PSquareMarkers markers =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 0.02, 1.18, 9.15, 21.91,                                 38.62 }), p);          PSquareMarkers markersNew =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 0.02, 1.18, 9.15, 21.91,                                 38.62 }), p);          Assert.assertTrue(markers.equals(markersNew));         // If just one element of markers got changed then its still false.         markersNew.processDataPoint(39);         Assert.assertFalse(markers.equals(markersNew));      }      @Test     public void testHashCodeInMarkers() {         PSquarePercentile p = new PSquarePercentile(95);         PSquarePercentile p2 = new PSquarePercentile(95);         Set<PSquarePercentile> s = new HashSet<>();         s.add(p);         s.add(p2);         Assert.assertEquals(1, s.size());         Assert.assertEquals(p, s.iterator().next());         double[] d =                 new double[] { 95.1772, 95.1567, 95.1937, 95.1959, 95.1442,                         95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990,                         95.1682 };         Assert.assertEquals(95.1981, p.evaluate(d), 1.0e-2); // change         Assert.assertEquals(95.1981, p2.evaluate(d), 1.0e-2); // change         s.clear();         s.add(p);         s.add(p2);         Assert.assertEquals(1, s.size());         Assert.assertEquals(p, s.iterator().next());          PSquareMarkers m1 =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 95.1772, 95.1567, 95.1937,                                 95.1959, 95.1442, 95.0610, 95.1591, 95.1195,                                 95.1772, 95.0925, 95.1990, 95.1682 }), 0.0);         PSquareMarkers m2 =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 95.1772, 95.1567, 95.1937,                                 95.1959, 95.1442, 95.0610, 95.1591, 95.1195,                                 95.1772, 95.0925, 95.1990, 95.1682 }), 0.0);         Assert.assertTrue(m1.equals(m2));         Set<PSquareMarkers> setMarkers = new LinkedHashSet<>();         Assert.assertTrue(setMarkers.add(m1));         Assert.assertFalse(setMarkers.add(m2));         Assert.assertEquals(1, setMarkers.size());          PSquareMarkers mThis =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 195.1772, 195.1567,                                 195.1937, 195.1959, 95.1442, 195.0610,                                 195.1591, 195.1195, 195.1772, 95.0925, 95.1990,                                 195.1682 }), 0.50);         PSquareMarkers mThat =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 95.1772, 95.1567, 95.1937,                                 95.1959, 95.1442, 95.0610, 95.1591, 95.1195,                                 95.1772, 95.0925, 95.1990, 95.1682 }), 0.50);         Assert.assertTrue(mThis.equals(mThis));         Assert.assertFalse(mThis.equals(mThat));         String s1="";         Assert.assertFalse(mThis.equals(s1));         for (int i = 0; i < testArray.length; i++) {             mThat.processDataPoint(testArray[i]);         }         setMarkers.add(mThat);         setMarkers.add(mThis);         Assert.assertTrue(mThat.equals(mThat));         Assert.assertTrue(setMarkers.contains(mThat));         Assert.assertTrue(setMarkers.contains(mThis));         Assert.assertEquals(3, setMarkers.size());         Iterator<PSquareMarkers> iterator=setMarkers.iterator();         Assert.assertEquals(m1, iterator.next());         Assert.assertEquals(mThat, iterator.next());         Assert.assertEquals(mThis, iterator.next());     }      @Test(expected = OutOfRangeException.class)     public void testMarkersWithLowerIndex() {         PSquareMarkers mThat =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 95.1772, 95.1567, 95.1937,                                 95.1959, 95.1442, 95.0610, 95.1591, 95.1195,                                 95.1772, 95.0925, 95.1990, 95.1682 }), 0.50);         for (int i = 0; i < testArray.length; i++) {             mThat.processDataPoint(testArray[i]);         }         mThat.estimate(0);     }      @Test(expected = OutOfRangeException.class)     public void testMarkersWithHigherIndex() {         PSquareMarkers mThat =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 95.1772, 95.1567, 95.1937,                                 95.1959, 95.1442, 95.0610, 95.1591, 95.1195,                                 95.1772, 95.0925, 95.1990, 95.1682 }), 0.50);         for (int i = 0; i < testArray.length; i++) {             mThat.processDataPoint(testArray[i]);         }         mThat.estimate(6);     }      @Test(expected = OutOfRangeException.class)     public void testMarkerHeightWithLowerIndex() {         PSquareMarkers mThat =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 95.1772, 95.1567, 95.1937,                                 95.1959, 95.1442, 95.0610, 95.1591, 95.1195,                                 95.1772, 95.0925, 95.1990, 95.1682 }), 0.50);         mThat.height(0);     }      @Test(expected = OutOfRangeException.class)     public void testMarkerHeightWithHigherIndex() {         PSquareMarkers mThat =                 PSquarePercentile.newMarkers(                         Arrays.asList(new Double[] { 95.1772, 95.1567, 95.1937,                                 95.1959, 95.1442, 95.0610, 95.1591, 95.1195,                                 95.1772, 95.0925, 95.1990, 95.1682 }), 0.50);         mThat.height(6);     }      @Test     public void testPSquaredEqualsAndMin() {         PSquarePercentile ptile = new PSquarePercentile(0);         Assert.assertEquals(ptile, ptile);         Assert.assertFalse(ptile.equals(null));         Assert.assertFalse(ptile.equals(new String()));         // Just to check if there is no data get result for zeroth and 100th         // ptile returns NAN         Assert.assertTrue(Double.isNaN(ptile.getResult()));         Assert.assertTrue(Double.isNaN(new PSquarePercentile(100).getResult()));          double[] d = new double[] { 1, 3, 2, 4, 9, 10, 11 };         ptile.incrementAll(d);         Assert.assertEquals(ptile, ptile);         Assert.assertEquals(1d, ptile.getResult(), 1e-02);// this calls min     }      @Test     public void testString() {         PSquarePercentile ptile = new PSquarePercentile(95);         Assert.assertNotNull(ptile.toString());         ptile.increment(1);         ptile.increment(2);         ptile.increment(3);         Assert.assertNotNull(ptile.toString());         Assert.assertEquals(expectedValue(), ptile.evaluate(testArray), getTolerance());         Assert.assertNotNull(ptile.toString());     }      @Override     public UnivariateStatistic getUnivariateStatistic() {         PSquarePercentile ptile = new PSquarePercentile(95);         // Assert.assertNull(ptile.markers());         return ptile;     }      @Override     public double expectedValue() {         return this.percentile95;     }      @Test     public void testHighPercentile() {         double[] d = new double[] { 1, 2, 3 };         PSquarePercentile p = new PSquarePercentile(75.0);         Assert.assertEquals(2, p.evaluate(d), 1.0e-5);         PSquarePercentile p95 = new PSquarePercentile();         Assert.assertEquals(2, p95.evaluate(d), 1.0e-5);     }      @Test     public void testLowPercentile() {         double[] d = new double[] { 0, 1 };         PSquarePercentile p = new PSquarePercentile(25.0);         Assert.assertEquals(0d, p.evaluate(d), Double.MIN_VALUE);     }      @Test     public void testPercentile() {         double[] d = new double[] { 1, 3, 2, 4 };         PSquarePercentile p = new PSquarePercentile(30d);         Assert.assertEquals(1.0, p.evaluate(d), 1.0e-5);         p = new PSquarePercentile(25);         Assert.assertEquals(1.0, p.evaluate(d), 1.0e-5);         p = new PSquarePercentile(75);         Assert.assertEquals(3.0, p.evaluate(d), 1.0e-5);         p = new PSquarePercentile(50);         Assert.assertEquals(2d, p.evaluate(d), 1.0e-5);      }      @Test(expected = MathIllegalArgumentException.class)     public void testInitial() {         PSquarePercentile.newMarkers(new ArrayList<Double>(), 0.5);         Assert.fail();     }      @Test(expected = MathIllegalArgumentException.class)     public void testNegativeInvalidValues() {         double[] d =                 new double[] { 95.1772, 95.1567, 95.1937, 95.1959, 95.1442,                         95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990,                         95.1682 };         PSquarePercentile p = new PSquarePercentile(-1.0);         p.evaluate(d, 0, d.length);         Assert.fail("This method has had to throw exception..but it is not..");      }      @Test(expected = MathIllegalArgumentException.class)     public void testPositiveInvalidValues() {         double[] d =                 new double[] { 95.1772, 95.1567, 95.1937, 95.1959, 95.1442,                         95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990,                         95.1682 };         PSquarePercentile p = new PSquarePercentile(101.0);         p.evaluate(d, 0, d.length);         Assert.fail("This method has had to throw exception..but it is not..");      }      @Test     public void testNISTExample() {         double[] d =                 new double[] { 95.1772, 95.1567, 95.1937, 95.1959, 95.1442,                         95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990,                         95.1682 };         Assert.assertEquals(95.1981, new PSquarePercentile(90d).evaluate(d),                 1.0e-2); // changed the accuracy to 1.0e-2         Assert.assertEquals(95.061, new PSquarePercentile(0d).evaluate(d), 0);         Assert.assertEquals(95.1990,                 new PSquarePercentile(100d).evaluate(d, 0, d.length), 0);     }      @Test     public void test5() {         PSquarePercentile percentile = new PSquarePercentile(5d);         Assert.assertEquals(this.percentile5, percentile.evaluate(testArray),                 1.0);// changed the accuracy to 1 instead of tolerance     }      @Test(expected = NullArgumentException.class)     public void testNull() {         PSquarePercentile percentile = new PSquarePercentile(50d);         double[] nullArray = null;         percentile.evaluate(nullArray);     }      @Test     public void testEmpty() {         PSquarePercentile percentile = new PSquarePercentile(50d);         double[] emptyArray = new double[] {};         Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));     }      @Test     public void testSingleton() {         PSquarePercentile percentile = new PSquarePercentile(50d);         double[] singletonArray = new double[] { 1d };         Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);         Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);         percentile = new PSquarePercentile(5);         Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);         percentile = new PSquarePercentile(100);         Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);         percentile = new PSquarePercentile(100);         Assert.assertTrue(Double.isNaN(percentile                 .evaluate(singletonArray, 0, 0)));     }      @Test     public void testSpecialValues() {         PSquarePercentile percentile = new PSquarePercentile(50d);         double[] specialValues =                 new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };         Assert.assertEquals(2d, percentile.evaluate(specialValues), 0);         specialValues =                 new double[] { Double.NEGATIVE_INFINITY, 1d, 2d, 3d,                         Double.NaN, Double.POSITIVE_INFINITY };         Assert.assertEquals(2d, percentile.evaluate(specialValues), 0);         specialValues =                 new double[] { 1d, 1d, Double.POSITIVE_INFINITY,                         Double.POSITIVE_INFINITY };         Assert.assertFalse(Double.isInfinite(percentile.evaluate(specialValues)));         specialValues = new double[] { 1d, 1d, Double.NaN, Double.NaN };         Assert.assertFalse(Double.isNaN(percentile.evaluate(specialValues)));         specialValues =                 new double[] { 1d, 1d, Double.NEGATIVE_INFINITY,                         Double.NEGATIVE_INFINITY };         percentile = new PSquarePercentile(50d);         // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY         // changed the result check to infinity instead of NaN         Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));     }      @Test     public void testArrayExample() {         Assert.assertEquals(expectedValue(),                 new PSquarePercentile(95d).evaluate(testArray), getTolerance());     }      @Test     public void testSetQuantile() {         PSquarePercentile percentile = new PSquarePercentile(10d);          percentile = new PSquarePercentile(100); // OK         Assert.assertEquals(1.0, percentile.quantile(), 0);         try {             percentile = new PSquarePercentile(0);             // Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             new PSquarePercentile(0d);             // Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      private Double[] randomTestData(int factor, int values) {         Double[] test = new Double[values];         for (int i = 0; i < test.length; i++) {             test[i] = Math.abs(randomGenerator.nextDouble() * factor);         }         return test;     }      @Test     public void testAccept() {         PSquarePercentile psquared = new PSquarePercentile(0.99);         Assert.assertTrue(Double.isNaN(psquared.getResult()));         Double[] test = randomTestData(100, 10000);          for (Double value : test) {             psquared.increment(value);             Assert.assertTrue(psquared.getResult() >= 0);         }     }      private void assertValues(Double a, Double b, double delta) {         if (Double.isNaN(a)) {             Assert.assertTrue("" + b + " is not NaN.", Double.isNaN(a));         } else {             double max = FastMath.max(a, b);             double percentage = FastMath.abs(a - b) / max;             double deviation = delta;             Assert.assertTrue(String.format(                     "Deviated = %f and is beyond %f as a=%f,  b=%f",                     percentage, deviation, a, b), percentage < deviation);         }     }      private void doCalculatePercentile(Double percentile, Number[] test) {         doCalculatePercentile(percentile, test, Double.MAX_VALUE);     }      private void doCalculatePercentile(Double percentile, Number[] test,             double delta) {         PSquarePercentile psquared = new PSquarePercentile(percentile);         for (Number value : test) {             psquared.increment(value.doubleValue());         }          Percentile p2 = new Percentile(percentile * 100);          double[] dall = new double[test.length];         for (int i = 0; i < test.length; i++) {             dall[i] = test[i].doubleValue();         }          Double referenceValue = p2.evaluate(dall);         assertValues(psquared.getResult(), referenceValue, delta);     }      private void doCalculatePercentile(double percentile, double[] test,             double delta) {         PSquarePercentile psquared = new PSquarePercentile(percentile);         for (double value : test) {             psquared.increment(value);         }          Percentile p2 =                 new Percentile(percentile < 1 ? percentile * 100 : percentile);         /*          * double[] dall = new double[test.length]; for (int i = 0; i <          * test.length; i++) dall[i] = test[i];          */         Double referenceValue = p2.evaluate(test);         assertValues(psquared.getResult(), referenceValue, delta);     }      @Test     public void testCannedDataSet() {         // test.unoverride("dump");         Integer[] seedInput =                 new Integer[] { 283, 285, 298, 304, 310, 31, 319, 32, 33, 339,                         342, 348, 350, 354, 354, 357, 36, 36, 369, 37, 37, 375,                         378, 383, 390, 396, 405, 408, 41, 414, 419, 416, 42,                         420, 430, 430, 432, 444, 447, 447, 449, 45, 451, 456,                         468, 470, 471, 474, 600, 695, 70, 83, 97, 109, 113, 128 };         Integer[] input = new Integer[seedInput.length * 100];         for (int i = 0; i < input.length; i++) {             input[i] = seedInput[i % seedInput.length] + i;         }         // Arrays.sort(input);         doCalculatePercentile(0.50d, input);         doCalculatePercentile(0.95d, input);      }      @Test     public void test99Percentile() {         Double[] test = randomTestData(100, 10000);         doCalculatePercentile(0.99d, test);     }      @Test     public void test90Percentile() {         Double[] test = randomTestData(100, 10000);         doCalculatePercentile(0.90d, test);     }      @Test     public void test20Percentile() {         Double[] test = randomTestData(100, 100000);         doCalculatePercentile(0.20d, test);     }      @Test     public void test5Percentile() {         Double[] test = randomTestData(50, 990000);         doCalculatePercentile(0.50d, test);     }      @Test     public void test99PercentileHighValues() {         Double[] test = randomTestData(100000, 10000);         doCalculatePercentile(0.99d, test);     }      @Test     public void test90PercentileHighValues() {         Double[] test = randomTestData(100000, 100000);         doCalculatePercentile(0.90d, test);     }      @Test     public void test20PercentileHighValues() {         Double[] test = randomTestData(100000, 100000);         doCalculatePercentile(0.20d, test);     }      @Test     public void test5PercentileHighValues() {         Double[] test = randomTestData(100000, 100000);         doCalculatePercentile(0.05d, test);     }      @Test     public void test0PercentileValuesWithFewerThan5Values() {         double[] test = { 1d, 2d, 3d, 4d };         PSquarePercentile p = new PSquarePercentile(0d);         Assert.assertEquals(1d, p.evaluate(test), 0);         Assert.assertNotNull(p.toString());     }      @Test     public void testPSQuaredEvalFuncWithPapersExampleData() throws IOException {          // This data as input is considered from         // http://www.cs.wustl.edu/~jain/papers/ftp/psqr.pdf         double[] data =                 { 0.02, 0.5, 0.74, 3.39, 0.83, 22.37, 10.15, 15.43, 38.62,                         15.92, 34.6, 10.28, 1.47, 0.4, 0.05, 11.39, 0.27, 0.42,                         0.09, 11.37,                          11.39, 15.43, 15.92, 22.37, 34.6, 38.62, 18.9, 19.2,                         27.6, 12.8, 13.7, 21.9                  };          PSquarePercentile psquared = new PSquarePercentile(50);          Double p2value = 0d;         for (int i = 0; i < 20; i++) {             psquared.increment(data[i]);             p2value = psquared.getResult();             // System.out.println(psquared.toString());//uncomment here to see             // the papers example output         }         // System.out.println("p2value=" + p2value);         Double expected = 4.44d;// 13d; // From The Paper         // http://www.cs.wustl.edu/~jain/papers/ftp/psqr.pdf.         // Pl refer Pg 1061 Look at the mid marker         // height         // expected = new Percentile(50).evaluate(data,0,20);         // Well the values deviate in our calculation by 0.25 so its 4.25 vs         // 4.44         Assert.assertEquals(                 String.format("Expected=%f, Actual=%f", expected, p2value),                 expected, p2value, 0.25);      }      final int TINY = 10, SMALL = 50, NOMINAL = 100, MEDIUM = 500,             STANDARD = 1000, BIG = 10000, VERY_BIG = 50000, LARGE = 1000000,             VERY_LARGE = 10000000;      private void doDistributionTest(ContinuousDistribution distribution) {         final ContinuousDistribution.Sampler sampler =             distribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));         double data[];          data = AbstractRealDistribution.sample(VERY_LARGE, sampler);         doCalculatePercentile(50, data, 0.0001);         doCalculatePercentile(95, data, 0.0001);          data = AbstractRealDistribution.sample(LARGE, sampler);         doCalculatePercentile(50, data, 0.001);         doCalculatePercentile(95, data, 0.001);          data = AbstractRealDistribution.sample(VERY_BIG, sampler);         doCalculatePercentile(50, data, 0.001);         doCalculatePercentile(95, data, 0.001);          data = AbstractRealDistribution.sample(BIG, sampler);         doCalculatePercentile(50, data, 0.001);         doCalculatePercentile(95, data, 0.001);          data = AbstractRealDistribution.sample(STANDARD, sampler);         doCalculatePercentile(50, data, 0.005);         doCalculatePercentile(95, data, 0.005);          data = AbstractRealDistribution.sample(MEDIUM, sampler);         doCalculatePercentile(50, data, 0.005);         doCalculatePercentile(95, data, 0.005);          data = AbstractRealDistribution.sample(NOMINAL, sampler);         doCalculatePercentile(50, data, 0.01);         doCalculatePercentile(95, data, 0.01);          data = AbstractRealDistribution.sample(SMALL, sampler);         doCalculatePercentile(50, data, 0.01);         doCalculatePercentile(95, data, 0.01);          data = AbstractRealDistribution.sample(TINY, sampler);         doCalculatePercentile(50, data, 0.05);         doCalculatePercentile(95, data, 0.05);      }      /**      * Test Various Dist      */     @Test     public void testDistribution() {         doDistributionTest(new NormalDistribution(4000, 50));         doDistributionTest(new LogNormalDistribution(4000, 50));         // doDistributionTest((new ExponentialDistribution(4000));         // doDistributionTest(new GammaDistribution(5d,1d),0.1);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.rank;  import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.LEGACY; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_1; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_2; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_3; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_4; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_5; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_6; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_7; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_8; import static org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType.R_9;  import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType; import org.apache.commons.math4.stat.ranking.NaNStrategy; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class MedianTest extends UnivariateStatisticAbstractTest{      protected Median stat;      /**      * {@link  org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType type}      *  to be used while calling      * {@link #getUnivariateStatistic()}      */     protected EstimationType estimationType = LEGACY;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Median();     }      private Median getTestMedian(EstimationType type) {         NaNStrategy strategy = (type == LEGACY) ? NaNStrategy.FIXED : NaNStrategy.REMOVED;         return new Median().withEstimationType(type).withNaNStrategy(strategy);     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.median;     }      @Before     public void before() {         estimationType=LEGACY;     }      @Test     public void testAllTechniquesSingleton() {         double[] singletonArray = new double[] { 1d };         for (EstimationType e : EstimationType.values()) {             UnivariateStatistic percentile = getTestMedian(e);             Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);             Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);             Assert.assertEquals(1d, new Median().evaluate(singletonArray, 0, 1, 5), 0);             Assert.assertEquals(1d, new Median().evaluate(singletonArray, 0, 1, 100), 0);             Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));         }     }      @Test     public void testAllTechniquesMedian() {         double[] d = new double[] { 1, 3, 2, 4 };         testAssertMappedValues(d, new Object[][] { { LEGACY, 2.5d },             { R_1, 2d }, { R_2, 2.5d }, { R_3, 2d }, { R_4, 2d }, { R_5, 2.5 },             { R_6, 2.5 },{ R_7, 2.5 },{ R_8, 2.5 }, { R_9 , 2.5 } },  1.0e-05);     }      /**      * Simple test assertion utility method      *      * @param d input data      * @param map of expected result against a {@link EstimationType}      * @param tolerance the tolerance of difference allowed      */     protected void testAssertMappedValues(double[] d, Object[][] map, Double tolerance) {         for (Object[] o : map) {             EstimationType e = (EstimationType) o[0];             double expected = (Double) o[1];             double result = getTestMedian(e).evaluate(d);             Assert.assertEquals("expected[" + e + "] = " + expected +                     " but was = " + result, expected, result, tolerance);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.rank;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class MinTest extends StorelessUnivariateStatisticAbstractTest{      protected Min stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Min();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.min;     }      @Test     public void testSpecialValues() {         double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};         Min min = new Min();         Assert.assertTrue(Double.isNaN(min.getResult()));         min.increment(testArray[0]);         Assert.assertEquals(0d, min.getResult(), 0);         min.increment(testArray[1]);         Assert.assertEquals(0d, min.getResult(), 0);         min.increment(testArray[2]);         Assert.assertEquals(0d, min.getResult(), 0);         min.increment(testArray[3]);         Assert.assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);         Assert.assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);     }      @Test     public void testNaNs() {         Min min = new Min();         double nan = Double.NaN;         Assert.assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);         Assert.assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);         Assert.assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);         Assert.assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;  import java.io.Serializable; import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.NumberTransformer; import org.apache.commons.math4.util.TransformerMap; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link ListUnivariateImpl} class.  */ public final class MixedListUnivariateImplTest {     private final double one = 1;     private final float two = 2;     private final int three = 3;      private final double mean = 2;     private final double sumSq = 18;     private final double sum = 8;     private final double var = 0.666666666666666666667;     private final double std = FastMath.sqrt(var);     private final double n = 4;     private final double min = 1;     private final double max = 3;     private final double tolerance = 10E-15;      private TransformerMap transformers = new TransformerMap();      public MixedListUnivariateImplTest() {         transformers = new TransformerMap();          transformers.putTransformer(Foo.class, new FooTransformer());          transformers.putTransformer(Bar.class, new BarTransformer());      }      /** test stats */     @Test     public void testStats() {         List<Object> externalList = new ArrayList<>();          DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);          Assert.assertEquals("total count", 0, u.getN(), tolerance);         u.addValue(one);         u.addValue(two);         u.addValue(two);         u.addValue(three);         Assert.assertEquals("N", n, u.getN(), tolerance);         Assert.assertEquals("sum", sum, u.getSum(), tolerance);         Assert.assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);         Assert.assertEquals("var", var, u.getVariance(), tolerance);         Assert.assertEquals("std", std, u.getStandardDeviation(), tolerance);         Assert.assertEquals("mean", mean, u.getMean(), tolerance);         Assert.assertEquals("min", min, u.getMin(), tolerance);         Assert.assertEquals("max", max, u.getMax(), tolerance);         u.clear();         Assert.assertEquals("total count", 0, u.getN(), tolerance);     }      @Test     public void testN0andN1Conditions() {         DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<>(),transformers);          Assert.assertTrue(             "Mean of n = 0 set should be NaN",             Double.isNaN(u.getMean()));         Assert.assertTrue(             "Standard Deviation of n = 0 set should be NaN",             Double.isNaN(u.getStandardDeviation()));         Assert.assertTrue(             "Variance of n = 0 set should be NaN",             Double.isNaN(u.getVariance()));          u.addValue(one);          Assert.assertTrue(             "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,             u.getMean() == one);          Assert.assertTrue(             "StdDev of n = 1 set should be zero, instead it is: "                 + u.getStandardDeviation(),             u.getStandardDeviation() == 0);         Assert.assertTrue(             "Variance of n = 1 set should be zero",             u.getVariance() == 0);     }      @Test     public void testSkewAndKurtosis() {         ListUnivariateImpl u =             new ListUnivariateImpl(new ArrayList<>(), transformers);          u.addObject("12.5");         u.addObject(Integer.valueOf(12));         u.addObject("11.8");         u.addObject("14.2");         u.addObject(new Foo());         u.addObject("14.5");         u.addObject(Long.valueOf(21));         u.addObject("8.2");         u.addObject("10.3");         u.addObject("11.3");         u.addObject(Float.valueOf(14.1f));         u.addObject("9.9");         u.addObject("12.2");         u.addObject(new Bar());         u.addObject("12.1");         u.addObject("11");         u.addObject(Double.valueOf(19.8));         u.addObject("11");         u.addObject("10");         u.addObject("8.8");         u.addObject("9");         u.addObject("12.3");           Assert.assertEquals("mean", 12.40455, u.getMean(), 0.0001);         Assert.assertEquals("variance", 10.00236, u.getVariance(), 0.0001);         Assert.assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);         Assert.assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);     }      @Test     public void testProductAndGeometricMean() {         ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<>(),transformers);         u.setWindowSize(10);          u.addValue(1.0);         u.addValue(2.0);         u.addValue(3.0);         u.addValue(4.0);          Assert.assertEquals(             "Geometric mean not expected",             2.213364,             u.getGeometricMean(),             0.00001);          // Now test rolling - StorelessDescriptiveStatistics should discount the contribution         // of a discarded element         for (int i = 0; i < 10; i++) {             u.addValue(i + 2);         }         // Values should be (2,3,4,5,6,7,8,9,10,11)         Assert.assertEquals(             "Geometric mean not expected",             5.755931,             u.getGeometricMean(),             0.00001);      }      public static final class Foo {         public String heresFoo() {             return "14.9";         }     }      public static final class FooTransformer implements NumberTransformer, Serializable {         private static final long serialVersionUID = -4252248129291326127L;         @Override         public double transform(Object o) {             return Double.parseDouble(((Foo) o).heresFoo());         }     }      public static final class Bar {         public String heresBar() {             return "12.0";         }     }      public static final class BarTransformer implements NumberTransformer, Serializable {         private static final long serialVersionUID = -1768345377764262043L;         @Override         public double transform(Object o) {             return Double.parseDouble(((Bar) o).heresBar());         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;   import java.util.Locale;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.stat.descriptive.moment.Mean; import org.apache.commons.math4.util.FastMath; import org.junit.Test; import org.junit.Assert;  /**  * Test cases for the {@link MultivariateSummaryStatistics} class.  *  */  public class MultivariateSummaryStatisticsTest {      protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {         return new MultivariateSummaryStatistics(k, isCovarianceBiasCorrected);     }      @Test     public void testSetterInjection() {         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);         u.setMeanImpl(new StorelessUnivariateStatistic[] {                         new sumMean(), new sumMean()                       });         u.addValue(new double[] { 1, 2 });         u.addValue(new double[] { 3, 4 });         Assert.assertEquals(4, u.getMean()[0], 1E-14);         Assert.assertEquals(6, u.getMean()[1], 1E-14);         u.clear();         u.addValue(new double[] { 1, 2 });         u.addValue(new double[] { 3, 4 });         Assert.assertEquals(4, u.getMean()[0], 1E-14);         Assert.assertEquals(6, u.getMean()[1], 1E-14);         u.clear();         u.setMeanImpl(new StorelessUnivariateStatistic[] {                         new Mean(), new Mean()                       }); // OK after clear         u.addValue(new double[] { 1, 2 });         u.addValue(new double[] { 3, 4 });         Assert.assertEquals(2, u.getMean()[0], 1E-14);         Assert.assertEquals(3, u.getMean()[1], 1E-14);         Assert.assertEquals(2, u.getDimension());     }      @Test     public void testSetterIllegalState() {         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);         u.addValue(new double[] { 1, 2 });         u.addValue(new double[] { 3, 4 });         try {             u.setMeanImpl(new StorelessUnivariateStatistic[] { new sumMean(), new sumMean() });             Assert.fail("Expecting MathIllegalStateException");         } catch (MathIllegalStateException ex) {             // expected         }     }      @Test     public void testToString() {         MultivariateSummaryStatistics stats = createMultivariateSummaryStatistics(2, true);         stats.addValue(new double[] {1, 3});         stats.addValue(new double[] {2, 2});         stats.addValue(new double[] {3, 1});         Locale d = Locale.getDefault();         Locale.setDefault(Locale.US);         final String suffix = System.getProperty("line.separator");         Assert.assertEquals("MultivariateSummaryStatistics:" + suffix+                      "n: 3" +suffix+                      "min: 1.0, 1.0" +suffix+                      "max: 3.0, 3.0" +suffix+                      "mean: 2.0, 2.0" +suffix+                      "geometric mean: 1.817..., 1.817..." +suffix+                      "sum of squares: 14.0, 14.0" +suffix+                      "sum of logarithms: 1.791..., 1.791..." +suffix+                      "standard deviation: 1.0, 1.0" +suffix+                      "covariance: Array2DRowRealMatrix{{1.0,-1.0},{-1.0,1.0}}" +suffix,                      stats.toString().replaceAll("([0-9]+\\.[0-9][0-9][0-9])[0-9]+", "$1..."));         Locale.setDefault(d);     }      @Test     public void testShuffledStatistics() {         // the purpose of this test is only to check the get/set methods         // we are aware shuffling statistics like this is really not         // something sensible to do in production ...         MultivariateSummaryStatistics reference = createMultivariateSummaryStatistics(2, true);         MultivariateSummaryStatistics shuffled  = createMultivariateSummaryStatistics(2, true);          StorelessUnivariateStatistic[] tmp = shuffled.getGeoMeanImpl();         shuffled.setGeoMeanImpl(shuffled.getMeanImpl());         shuffled.setMeanImpl(shuffled.getMaxImpl());         shuffled.setMaxImpl(shuffled.getMinImpl());         shuffled.setMinImpl(shuffled.getSumImpl());         shuffled.setSumImpl(shuffled.getSumsqImpl());         shuffled.setSumsqImpl(shuffled.getSumLogImpl());         shuffled.setSumLogImpl(tmp);          for (int i = 100; i > 0; --i) {             reference.addValue(new double[] {i, i});             shuffled.addValue(new double[] {i, i});         }          TestUtils.assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);         TestUtils.assertEquals(reference.getMax(),           shuffled.getMean(),          1.0e-10);         TestUtils.assertEquals(reference.getMin(),           shuffled.getMax(),           1.0e-10);         TestUtils.assertEquals(reference.getSum(),           shuffled.getMin(),           1.0e-10);         TestUtils.assertEquals(reference.getSumSq(),         shuffled.getSum(),           1.0e-10);         TestUtils.assertEquals(reference.getSumLog(),        shuffled.getSumSq(),         1.0e-10);         TestUtils.assertEquals(reference.getGeometricMean(), shuffled.getSumLog(),        1.0e-10);      }      /**      * Bogus mean implementation to test setter injection.      * Returns the sum instead of the mean.      */     static class sumMean implements StorelessUnivariateStatistic {         private double sum = 0;         private long n = 0;         @Override         public double evaluate(double[] values, int begin, int length) {             return 0;         }         @Override         public double evaluate(double[] values) {             return 0;         }         @Override         public void clear() {           sum = 0;           n = 0;         }         @Override         public long getN() {             return n;         }         @Override         public double getResult() {             return sum;         }         @Override         public void increment(double d) {             sum += d;             n++;         }         @Override         public void incrementAll(double[] values, int start, int length) {         }         @Override         public void incrementAll(double[] values) {         }         @Override         public StorelessUnivariateStatistic copy() {             return new sumMean();         }     }      @Test     public void testDimension() {         try {             createMultivariateSummaryStatistics(2, true).addValue(new double[3]);             Assert.fail("Expecting DimensionMismatchException");         } catch (DimensionMismatchException dme) {             // expected behavior         }     }      /** test stats */     @Test     public void testStats() {         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);         Assert.assertEquals(0, u.getN());         u.addValue(new double[] { 1, 2 });         u.addValue(new double[] { 2, 3 });         u.addValue(new double[] { 2, 3 });         u.addValue(new double[] { 3, 4 });         Assert.assertEquals( 4, u.getN());         Assert.assertEquals( 8, u.getSum()[0], 1.0e-10);         Assert.assertEquals(12, u.getSum()[1], 1.0e-10);         Assert.assertEquals(18, u.getSumSq()[0], 1.0e-10);         Assert.assertEquals(38, u.getSumSq()[1], 1.0e-10);         Assert.assertEquals( 1, u.getMin()[0], 1.0e-10);         Assert.assertEquals( 2, u.getMin()[1], 1.0e-10);         Assert.assertEquals( 3, u.getMax()[0], 1.0e-10);         Assert.assertEquals( 4, u.getMax()[1], 1.0e-10);         Assert.assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);         Assert.assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);         Assert.assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);         Assert.assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);         Assert.assertEquals( 2, u.getMean()[0], 1.0e-10);         Assert.assertEquals( 3, u.getMean()[1], 1.0e-10);         Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);         Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);         Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);         Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);         Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);         Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);         u.clear();         Assert.assertEquals(0, u.getN());     }      @Test     public void testN0andN1Conditions() {         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);         Assert.assertTrue(Double.isNaN(u.getMean()[0]));         Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));          /* n=1 */         u.addValue(new double[] { 1 });         Assert.assertEquals(1.0, u.getMean()[0], 1.0e-10);         Assert.assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);         Assert.assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);          /* n=2 */         u.addValue(new double[] { 2 });         Assert.assertTrue(u.getStandardDeviation()[0] > 0);      }      @Test     public void testNaNContracts() {         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);         Assert.assertTrue(Double.isNaN(u.getMean()[0]));         Assert.assertTrue(Double.isNaN(u.getMin()[0]));         Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));         Assert.assertTrue(Double.isNaN(u.getGeometricMean()[0]));          u.addValue(new double[] { 1.0 });         Assert.assertFalse(Double.isNaN(u.getMean()[0]));         Assert.assertFalse(Double.isNaN(u.getMin()[0]));         Assert.assertFalse(Double.isNaN(u.getStandardDeviation()[0]));         Assert.assertFalse(Double.isNaN(u.getGeometricMean()[0]));      }      @Test     public void testSerialization() {         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);         // Empty test         TestUtils.checkSerializedEquality(u);         MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);         Assert.assertEquals(u, s);          // Add some data         u.addValue(new double[] { 2d, 1d });         u.addValue(new double[] { 1d, 1d });         u.addValue(new double[] { 3d, 1d });         u.addValue(new double[] { 4d, 1d });         u.addValue(new double[] { 5d, 1d });          // Test again         TestUtils.checkSerializedEquality(u);         s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);         Assert.assertEquals(u, s);      }      @Test     public void testEqualsAndHashCode() {         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);         MultivariateSummaryStatistics t = null;         int emptyHash = u.hashCode();         Assert.assertTrue(u.equals(u));         Assert.assertFalse(u.equals(t));         Assert.assertFalse(u.equals(Double.valueOf(0)));         t = createMultivariateSummaryStatistics(2, true);         Assert.assertTrue(t.equals(u));         Assert.assertTrue(u.equals(t));         Assert.assertEquals(emptyHash, t.hashCode());          // Add some data to u         u.addValue(new double[] { 2d, 1d });         u.addValue(new double[] { 1d, 1d });         u.addValue(new double[] { 3d, 1d });         u.addValue(new double[] { 4d, 1d });         u.addValue(new double[] { 5d, 1d });         Assert.assertFalse(t.equals(u));         Assert.assertFalse(u.equals(t));         Assert.assertTrue(u.hashCode() != t.hashCode());          //Add data in same order to t         t.addValue(new double[] { 2d, 1d });         t.addValue(new double[] { 1d, 1d });         t.addValue(new double[] { 3d, 1d });         t.addValue(new double[] { 4d, 1d });         t.addValue(new double[] { 5d, 1d });         Assert.assertTrue(t.equals(u));         Assert.assertTrue(u.equals(t));         Assert.assertEquals(u.hashCode(), t.hashCode());          // Clear and make sure summaries are indistinguishable from empty summary         u.clear();         t.clear();         Assert.assertTrue(t.equals(u));         Assert.assertTrue(u.equals(t));         Assert.assertEquals(emptyHash, t.hashCode());         Assert.assertEquals(emptyHash, u.hashCode());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;  /**  * Test cases for the {@link SynchronizedSummaryStatisticsTest} class.  *          2007) $  */ public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {      @Override     protected SummaryStatistics createSummaryStatistics() {         return new SynchronizedSummaryStatistics();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;   import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.stat.descriptive.moment.GeometricMean; import org.apache.commons.math4.stat.descriptive.moment.Mean; import org.apache.commons.math4.stat.descriptive.moment.Variance; import org.apache.commons.math4.stat.descriptive.summary.Sum; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test; /**  * Test cases for the {@link SummaryStatistics} class.  */ public class SummaryStatisticsTest {      private final double one = 1;     private final float twoF = 2;     private final long twoL = 2;     private final int three = 3;     private final double mean = 2;     private final double sumSq = 18;     private final double sum = 8;     private final double var = 0.666666666666666666667;     private final double popVar = 0.5;     private final double std = FastMath.sqrt(var);     private final double n = 4;     private final double min = 1;     private final double max = 3;     private final double tolerance = 10E-15;      protected SummaryStatistics createSummaryStatistics() {         return new SummaryStatistics();     }      /** test stats */     @Test     public void testStats() {         SummaryStatistics u = createSummaryStatistics();         Assert.assertEquals("total count",0,u.getN(),tolerance);         u.addValue(one);         u.addValue(twoF);         u.addValue(twoL);         u.addValue(three);         Assert.assertEquals("N",n,u.getN(),tolerance);         Assert.assertEquals("sum",sum,u.getSum(),tolerance);         Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);         Assert.assertEquals("var",var,u.getVariance(),tolerance);         Assert.assertEquals("population var",popVar,u.getPopulationVariance(),tolerance);         Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);         Assert.assertEquals("mean",mean,u.getMean(),tolerance);         Assert.assertEquals("min",min,u.getMin(),tolerance);         Assert.assertEquals("max",max,u.getMax(),tolerance);         u.clear();         Assert.assertEquals("total count",0,u.getN(),tolerance);     }      @Test     public void testN0andN1Conditions() {         SummaryStatistics u = createSummaryStatistics();         Assert.assertTrue("Mean of n = 0 set should be NaN",                 Double.isNaN( u.getMean() ) );         Assert.assertTrue("Standard Deviation of n = 0 set should be NaN",                 Double.isNaN( u.getStandardDeviation() ) );         Assert.assertTrue("Variance of n = 0 set should be NaN",                 Double.isNaN(u.getVariance() ) );          /* n=1 */         u.addValue(one);         Assert.assertTrue("mean should be one (n = 1)",                 u.getMean() == one);         Assert.assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(),                 u.getGeometricMean() == one);         Assert.assertTrue("Std should be zero (n = 1)",                 u.getStandardDeviation() == 0.0);         Assert.assertTrue("variance should be zero (n = 1)",                 u.getVariance() == 0.0);          /* n=2 */         u.addValue(twoF);         Assert.assertTrue("Std should not be zero (n = 2)",                 u.getStandardDeviation() != 0.0);         Assert.assertTrue("variance should not be zero (n = 2)",                 u.getVariance() != 0.0);      }      @Test     public void testProductAndGeometricMean() {         SummaryStatistics u = createSummaryStatistics();         u.addValue( 1.0 );         u.addValue( 2.0 );         u.addValue( 3.0 );         u.addValue( 4.0 );          Assert.assertEquals( "Geometric mean not expected", 2.213364,                 u.getGeometricMean(), 0.00001 );     }      @Test     public void testNaNContracts() {         SummaryStatistics u = createSummaryStatistics();         Assert.assertTrue("mean not NaN",Double.isNaN(u.getMean()));         Assert.assertTrue("min not NaN",Double.isNaN(u.getMin()));         Assert.assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));         Assert.assertTrue("var not NaN",Double.isNaN(u.getVariance()));         Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));          u.addValue(1.0);          Assert.assertEquals( "mean not expected", 1.0,                 u.getMean(), Double.MIN_VALUE);         Assert.assertEquals( "variance not expected", 0.0,                 u.getVariance(), Double.MIN_VALUE);         Assert.assertEquals( "geometric mean not expected", 1.0,                 u.getGeometricMean(), Double.MIN_VALUE);          u.addValue(-1.0);          Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));          u.addValue(0.0);          Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));          //FiXME: test all other NaN contract specs     }      @Test     public void testGetSummary() {         SummaryStatistics u = createSummaryStatistics();         StatisticalSummary summary = u.getSummary();         verifySummary(u, summary);         u.addValue(1d);         summary = u.getSummary();         verifySummary(u, summary);         u.addValue(2d);         summary = u.getSummary();         verifySummary(u, summary);         u.addValue(2d);         summary = u.getSummary();         verifySummary(u, summary);     }      @Test     public void testSerialization() {         SummaryStatistics u = createSummaryStatistics();         // Empty test         TestUtils.checkSerializedEquality(u);         SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);         StatisticalSummary summary = s.getSummary();         verifySummary(u, summary);          // Add some data         u.addValue(2d);         u.addValue(1d);         u.addValue(3d);         u.addValue(4d);         u.addValue(5d);          // Test again         TestUtils.checkSerializedEquality(u);         s = (SummaryStatistics) TestUtils.serializeAndRecover(u);         summary = s.getSummary();         verifySummary(u, summary);      }      @Test     public void testEqualsAndHashCode() {         SummaryStatistics u = createSummaryStatistics();         SummaryStatistics t = null;         int emptyHash = u.hashCode();         Assert.assertTrue("reflexive", u.equals(u));         Assert.assertFalse("non-null compared to null", u.equals(t));         Assert.assertFalse("wrong type", u.equals(Double.valueOf(0)));         t = createSummaryStatistics();         Assert.assertTrue("empty instances should be equal", t.equals(u));         Assert.assertTrue("empty instances should be equal", u.equals(t));         Assert.assertEquals("empty hash code", emptyHash, t.hashCode());          // Add some data to u         u.addValue(2d);         u.addValue(1d);         u.addValue(3d);         u.addValue(4d);         Assert.assertFalse("different n's should make instances not equal", t.equals(u));         Assert.assertFalse("different n's should make instances not equal", u.equals(t));         Assert.assertTrue("different n's should make hashcodes different",                 u.hashCode() != t.hashCode());          //Add data in same order to t         t.addValue(2d);         t.addValue(1d);         t.addValue(3d);         t.addValue(4d);         Assert.assertTrue("summaries based on same data should be equal", t.equals(u));         Assert.assertTrue("summaries based on same data should be equal", u.equals(t));         Assert.assertEquals("summaries based on same data should have same hashcodes",                 u.hashCode(), t.hashCode());          // Clear and make sure summaries are indistinguishable from empty summary         u.clear();         t.clear();         Assert.assertTrue("empty instances should be equal", t.equals(u));         Assert.assertTrue("empty instances should be equal", u.equals(t));         Assert.assertEquals("empty hash code", emptyHash, t.hashCode());         Assert.assertEquals("empty hash code", emptyHash, u.hashCode());     }      @Test     public void testCopy() {         SummaryStatistics u = createSummaryStatistics();         u.addValue(2d);         u.addValue(1d);         u.addValue(3d);         u.addValue(4d);         SummaryStatistics v = new SummaryStatistics(u);         Assert.assertEquals(u, v);         Assert.assertEquals(v, u);          // Make sure both behave the same with additional values added         u.addValue(7d);         u.addValue(9d);         u.addValue(11d);         u.addValue(23d);         v.addValue(7d);         v.addValue(9d);         v.addValue(11d);         v.addValue(23d);         Assert.assertEquals(u, v);         Assert.assertEquals(v, u);          // Check implementation pointers are preserved         u.clear();         u.setSumImpl(new Sum());         SummaryStatistics.copy(u,v);         Assert.assertEquals(u.getSumImpl(), v.getSumImpl());      }      private void verifySummary(SummaryStatistics u, StatisticalSummary s) {         Assert.assertEquals("N",s.getN(),u.getN());         TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);         TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);         TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);         TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);         TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);         TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);     }      @Test     public void testSetterInjection() {         SummaryStatistics u = createSummaryStatistics();         u.setMeanImpl(new Sum());         u.setSumLogImpl(new Sum());         u.addValue(1);         u.addValue(3);         Assert.assertEquals(4, u.getMean(), 1E-14);         Assert.assertEquals(4, u.getSumOfLogs(), 1E-14);         Assert.assertEquals(FastMath.exp(2), u.getGeometricMean(), 1E-14);         u.clear();         u.addValue(1);         u.addValue(2);         Assert.assertEquals(3, u.getMean(), 1E-14);         u.clear();         u.setMeanImpl(new Mean()); // OK after clear     }      @Test     public void testSetterIllegalState() {         SummaryStatistics u = createSummaryStatistics();         u.addValue(1);         u.addValue(3);         try {             u.setMeanImpl(new Sum());             Assert.fail("Expecting MathIllegalStateException");         } catch (MathIllegalStateException ex) {             // expected         }     }      @Test     public void testQuadraticMean() {         final double[] values = { 1.2, 3.4, 5.6, 7.89 };         final SummaryStatistics stats = createSummaryStatistics();          final int len = values.length;         double expected = 0;         for (int i = 0; i < len; i++) {             final double v = values[i];             expected += v * v / len;              stats.addValue(v);         }         expected = Math.sqrt(expected);          Assert.assertEquals(expected, stats.getQuadraticMean(), Math.ulp(expected));     }      /**      * JIRA: MATH-691      */     @Test     public void testOverrideVarianceWithMathClass() {         double[] scores = {1, 2, 3, 4};         SummaryStatistics stats = new SummaryStatistics();         stats.setVarianceImpl(new Variance(false)); //use "population variance"         for(double i : scores) {           stats.addValue(i);         }         Assert.assertEquals((new Variance(false)).evaluate(scores),stats.getVariance(), 0);     }      @Test     public void testOverrideMeanWithMathClass() {         double[] scores = {1, 2, 3, 4};         SummaryStatistics stats = new SummaryStatistics();         stats.setMeanImpl(new Mean());         for(double i : scores) {           stats.addValue(i);         }         Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(), 0);     }      @Test     public void testOverrideGeoMeanWithMathClass() {         double[] scores = {1, 2, 3, 4};         SummaryStatistics stats = new SummaryStatistics();         stats.setGeoMeanImpl(new GeometricMean());         for(double i : scores) {           stats.addValue(i);         }         Assert.assertEquals((new GeometricMean()).evaluate(scores),stats.getGeometricMean(), 0);     }      @Test     public void testToString() {         SummaryStatistics u = createSummaryStatistics();         for (int i = 0; i < 5; i++) {             u.addValue(i);         }         final String[] labels = {"min", "max", "sum", "geometric mean", "variance",                 "population variance", "second moment", "sum of squares", "standard deviation",         "sum of logs"};         final double[] values = {u.getMin(), u.getMax(), u.getSum(), u.getGeometricMean(),                 u.getVariance(), u.getPopulationVariance(), u.getSecondMoment(), u.getSumsq(),                 u.getStandardDeviation(), u.getSumOfLogs()};         final String toString = u.toString();         Assert.assertTrue(toString.indexOf("n: " + u.getN()) > 0); // getN() returns a long         for (int i = 0; i < values.length; i++) {             Assert.assertTrue(toString.indexOf(labels[i] + ": " + String.valueOf(values[i])) > 0);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;   /**  * Test cases for the {@link SynchronizedDescriptiveStatisticsTest} class.  *          2007) $  */ public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {      @Override     protected DescriptiveStatistics createDescriptiveStatistics() {         return new SynchronizedDescriptiveStatistics();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link ListUnivariateImpl} class.  *  */  public final class ListUnivariateImplTest {      private double one = 1;     private float two = 2;     private int three = 3;      private double mean = 2;     private double sumSq = 18;     private double sum = 8;     private double var = 0.666666666666666666667;     private double std = FastMath.sqrt(var);     private double n = 4;     private double min = 1;     private double max = 3;     private double tolerance = 10E-15;      /** test stats */     @Test     public void testStats() {         List<Object> externalList = new ArrayList<>();          DescriptiveStatistics u = new ListUnivariateImpl( externalList );          Assert.assertEquals("total count",0,u.getN(),tolerance);         u.addValue(one);         u.addValue(two);         u.addValue(two);         u.addValue(three);         Assert.assertEquals("N",n,u.getN(),tolerance);         Assert.assertEquals("sum",sum,u.getSum(),tolerance);         Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);         Assert.assertEquals("var",var,u.getVariance(),tolerance);         Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);         Assert.assertEquals("mean",mean,u.getMean(),tolerance);         Assert.assertEquals("min",min,u.getMin(),tolerance);         Assert.assertEquals("max",max,u.getMax(),tolerance);         u.clear();         Assert.assertEquals("total count",0,u.getN(),tolerance);     }      @Test     public void testN0andN1Conditions() {         List<Object> list = new ArrayList<>();          DescriptiveStatistics u = new ListUnivariateImpl( list );          Assert.assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );         Assert.assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );         Assert.assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );          list.add( Double.valueOf(one));          Assert.assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);         Assert.assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);         Assert.assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);     }      @Test     public void testSkewAndKurtosis() {         DescriptiveStatistics u = new DescriptiveStatistics();          double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,                                              9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };         for( int i = 0; i < testArray.length; i++) {             u.addValue( testArray[i]);         }          Assert.assertEquals("mean", 12.40455, u.getMean(), 0.0001);         Assert.assertEquals("variance", 10.00236, u.getVariance(), 0.0001);         Assert.assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);         Assert.assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);     }      @Test     public void testProductAndGeometricMean() {         ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<>());         u.setWindowSize(10);          u.addValue( 1.0 );         u.addValue( 2.0 );         u.addValue( 3.0 );         u.addValue( 4.0 );          Assert.assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );          // Now test rolling - StorelessDescriptiveStatistics should discount the contribution         // of a discarded element         for( int i = 0; i < 10; i++ ) {             u.addValue( i + 2 );         }         // Values should be (2,3,4,5,6,7,8,9,10,11)          Assert.assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );       }      /** test stats */     @Test     public void testSerialization() {          DescriptiveStatistics u = new ListUnivariateImpl();          Assert.assertEquals("total count",0,u.getN(),tolerance);         u.addValue(one);         u.addValue(two);          DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);          u2.addValue(two);         u2.addValue(three);          Assert.assertEquals("N",n,u2.getN(),tolerance);         Assert.assertEquals("sum",sum,u2.getSum(),tolerance);         Assert.assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);         Assert.assertEquals("var",var,u2.getVariance(),tolerance);         Assert.assertEquals("std",std,u2.getStandardDeviation(),tolerance);         Assert.assertEquals("mean",mean,u2.getMean(),tolerance);         Assert.assertEquals("min",min,u2.getMin(),tolerance);         Assert.assertEquals("max",max,u2.getMax(),tolerance);          u2.clear();         Assert.assertEquals("total count",0,u2.getN(),tolerance);     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law  * or agreed to in writing, software distributed under the License is  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;   /**  * Test cases for the {@link SynchronizedMultivariateSummaryStatisticsTest} class.  *          2007) $  */ public final class SynchronizedMultivariateSummaryStatisticsTest     extends MultivariateSummaryStatisticsTest {     @Override     protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {         return new SynchronizedMultivariateSummaryStatistics(k, isCovarianceBiasCorrected);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  * s * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.TestUtils; import org.apache.commons.statistics.distribution.DiscreteDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformDiscreteDistribution; import org.apache.commons.math4.util.FastMath; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public abstract class UnivariateStatisticAbstractTest {      protected double mean = 12.404545454545455d;     protected double geoMean = 12.070589161633011d;      protected double var = 10.00235930735931d;     protected double std = FastMath.sqrt(var);     protected double skew = 1.437423729196190d;     protected double kurt = 2.377191264804700d;      protected double min = 8.2d;     protected double max = 21d;     protected double median = 12d;     protected double percentile5 = 8.29d;     protected double percentile95 = 20.82d;      protected double product = 628096400563833396009676.9200400128d;     protected double sumLog = 54.7969806116451507d;     protected double sumSq = 3595.250d;     protected double sum = 272.90d;     protected double secondMoment = 210.04954545454547d;     protected double thirdMoment = 868.0906859504136;     protected double fourthMoment = 9244.080993773481;       protected double weightedMean = 12.366995073891626d;     protected double weightedVar =   9.974760968886391d;     protected double weightedStd = FastMath.sqrt(weightedVar);     protected double weightedProduct = 8517647448765288000000d;     protected double weightedSum = 251.05d;      protected double tolerance = 10E-12;      protected double[] testArray =         { 12.5, 12.0, 11.8, 14.2, 14.9, 14.5, 21.0,  8.2, 10.3, 11.3,           14.1,  9.9, 12.2, 12.0, 12.1, 11.0, 19.8, 11.0, 10.0,  8.8,            9.0, 12.3 };      protected double[] testWeightsArray =         {  1.5,  0.8,  1.2,  0.4,  0.8,  1.8,  1.2,  1.1,  1.0,  0.7,            1.3,  0.6,  0.7,  1.3,  0.7,  1.0,  0.4,  0.1,  1.4,  0.9,            1.1,  0.3 };      protected double[] identicalWeightsArray =         {  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,            0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,            0.5,  0.5 };      protected double[] unitWeightsArray =         {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,            1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,            1.0,  1.0 };      public abstract UnivariateStatistic getUnivariateStatistic();      public abstract double expectedValue();      public double getTolerance() {         return tolerance;     }      @Test     public void testEvaluation() {         Assert.assertEquals(expectedValue(), getUnivariateStatistic().evaluate(testArray), getTolerance());     }      @Test     public void testEvaluateArraySegment() {         final UnivariateStatistic stat = getUnivariateStatistic();         final double[] arrayZero = new double[5];         System.arraycopy(testArray, 0, arrayZero, 0, 5);         Assert.assertEquals(stat.evaluate(arrayZero), stat.evaluate(testArray, 0, 5), 0);         final double[] arrayOne = new double[5];         System.arraycopy(testArray, 5, arrayOne, 0, 5);         Assert.assertEquals(stat.evaluate(arrayOne), stat.evaluate(testArray, 5, 5), 0);         final double[] arrayEnd = new double[5];         System.arraycopy(testArray, testArray.length - 5, arrayEnd, 0, 5);         Assert.assertEquals(stat.evaluate(arrayEnd), stat.evaluate(testArray, testArray.length - 5, 5), 0);     }      @Test     public void testEvaluateArraySegmentWeighted() {         // See if this statistic computes weighted statistics         // If not, skip this test         UnivariateStatistic statistic = getUnivariateStatistic();         if (!(statistic instanceof WeightedEvaluation)) {             return;         }         final WeightedEvaluation stat = (WeightedEvaluation) getUnivariateStatistic();         final double[] arrayZero = new double[5];         final double[] weightZero = new double[5];         System.arraycopy(testArray, 0, arrayZero, 0, 5);         System.arraycopy(testWeightsArray, 0, weightZero, 0, 5);         Assert.assertEquals(stat.evaluate(arrayZero, weightZero),                 stat.evaluate(testArray, testWeightsArray, 0, 5), 0);         final double[] arrayOne = new double[5];         final double[] weightOne = new double[5];         System.arraycopy(testArray, 5, arrayOne, 0, 5);         System.arraycopy(testWeightsArray, 5, weightOne, 0, 5);         Assert.assertEquals(stat.evaluate(arrayOne, weightOne),                 stat.evaluate(testArray, testWeightsArray, 5, 5), 0);         final double[] arrayEnd = new double[5];         final double[] weightEnd = new double[5];         System.arraycopy(testArray, testArray.length - 5, arrayEnd, 0, 5);         System.arraycopy(testWeightsArray, testArray.length - 5, weightEnd, 0, 5);         Assert.assertEquals(stat.evaluate(arrayEnd, weightEnd),                 stat.evaluate(testArray, testWeightsArray, testArray.length - 5, 5), 0);     }      @Test     public void testCopy() {         UnivariateStatistic original = getUnivariateStatistic();         UnivariateStatistic copy = original.copy();         Assert.assertEquals(expectedValue(), copy.evaluate(testArray), getTolerance());     }      /**      * Tests consistency of weighted statistic computation.      * For statistics that support weighted evaluation, this test case compares      * the result of direct computation on an array with repeated values with      * a weighted computation on the corresponding (shorter) array with each      * value appearing only once but with a weight value equal to its multiplicity      * in the repeating array.      */      @Test     public void testWeightedConsistency() {          // See if this statistic computes weighted statistics         // If not, skip this test         UnivariateStatistic statistic = getUnivariateStatistic();         if (!(statistic instanceof WeightedEvaluation)) {             return;         }          // Create arrays of values and corresponding integral weights         // and longer array with values repeated according to the weights         final int len = 10;        // length of values array         final double mu = 0;       // mean of test data         final double sigma = 5;    // std dev of test data         double[] values = new double[len];         double[] weights = new double[len];          // Fill weights array with random int values between 1 and 5         int[] intWeights = new int[len];         final DiscreteDistribution.Sampler weightDist =             new UniformDiscreteDistribution(1, 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                     234878544L));         for (int i = 0; i < len; i++) {             intWeights[i] = weightDist.sample();             weights[i] = intWeights[i];         }          // Fill values array with random data from N(mu, sigma)         // and fill valuesList with values from values array with         // values[i] repeated weights[i] times, each i         final ContinuousDistribution.Sampler valueDist =             new NormalDistribution(mu, sigma).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                 64925784252L));         List<Double> valuesList = new ArrayList<>();         for (int i = 0; i < len; i++) {             double value = valueDist.sample();             values[i] = value;             for (int j = 0; j < intWeights[i]; j++) {                 valuesList.add(new Double(value));             }         }          // Dump valuesList into repeatedValues array         int sumWeights = valuesList.size();         double[] repeatedValues = new double[sumWeights];         for (int i = 0; i < sumWeights; i++) {             repeatedValues[i] = valuesList.get(i);         }          // Compare result of weighted statistic computation with direct computation         // on array of repeated values         WeightedEvaluation weightedStatistic = (WeightedEvaluation) statistic;         TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),                 weightedStatistic.evaluate(values, weights, 0, values.length),                 10E-12);          // Check consistency of weighted evaluation methods         Assert.assertEquals(weightedStatistic.evaluate(values, weights, 0, values.length),                 weightedStatistic.evaluate(values, weights), Double.MIN_VALUE);      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.summary;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class ProductTest extends StorelessUnivariateStatisticAbstractTest{      protected Product stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Product();     }      /**      * {@inheritDoc}      */     @Override     public double getTolerance() {         return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.product;     }      /** Expected value for  the testArray defined in UnivariateStatisticAbstractTest */     public double expectedWeightedValue() {         return this.weightedProduct;     }      @Test     public void testSpecialValues() {         Product product = new Product();         Assert.assertEquals(1, product.getResult(), 0);         product.increment(1);         Assert.assertEquals(1, product.getResult(), 0);         product.increment(Double.POSITIVE_INFINITY);         Assert.assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);         product.increment(Double.NEGATIVE_INFINITY);         Assert.assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);         product.increment(Double.NaN);         Assert.assertTrue(Double.isNaN(product.getResult()));         product.increment(1);         Assert.assertTrue(Double.isNaN(product.getResult()));     }      @Test     public void testWeightedProduct() {         Product product = new Product();         Assert.assertEquals(expectedWeightedValue(),                             product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());         Assert.assertEquals(expectedValue(),                             product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());     }      @Override     protected void checkClearValue(StorelessUnivariateStatistic statistic){         Assert.assertEquals(1, statistic.getResult(), 0);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.summary;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link Sum} class.  */ public class SumTest extends StorelessUnivariateStatisticAbstractTest{      protected Sum stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new Sum();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.sum;     }      /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */     public double expectedWeightedValue() {         return this.weightedSum;     }      @Test     public void testSpecialValues() {         Sum sum = new Sum();         Assert.assertEquals(0, sum.getResult(), 0);         sum.increment(1);         Assert.assertEquals(1, sum.getResult(), 0);         sum.increment(Double.POSITIVE_INFINITY);         Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);         sum.increment(Double.NEGATIVE_INFINITY);         Assert.assertTrue(Double.isNaN(sum.getResult()));         sum.increment(1);         Assert.assertTrue(Double.isNaN(sum.getResult()));     }      @Test     public void testWeightedSum() {         Sum sum = new Sum();         Assert.assertEquals(expectedWeightedValue(),                             sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());         Assert.assertEquals(expectedValue(),                             sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());     }      @Override     protected void checkClearValue(StorelessUnivariateStatistic statistic) {         Assert.assertEquals(0, statistic.getResult(), 0);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.summary;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link SumOfSquares} class.  */ public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{      protected SumOfSquares stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new SumOfSquares();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.sumSq;     }      @Test     public void testSpecialValues() {         SumOfSquares sumSq = new SumOfSquares();         Assert.assertEquals(0, sumSq.getResult(), 0);         sumSq.increment(2d);         Assert.assertEquals(4d, sumSq.getResult(), 0);         sumSq.increment(Double.POSITIVE_INFINITY);         Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);         sumSq.increment(Double.NEGATIVE_INFINITY);         Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);         sumSq.increment(Double.NaN);         Assert.assertTrue(Double.isNaN(sumSq.getResult()));         sumSq.increment(1);         Assert.assertTrue(Double.isNaN(sumSq.getResult()));     }      @Override     protected void checkClearValue(StorelessUnivariateStatistic statistic) {         Assert.assertEquals(0, statistic.getResult(), 0);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive.summary;  import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math4.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link UnivariateStatistic} class.  */ public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{      protected SumOfLogs stat;      /**      * {@inheritDoc}      */     @Override     public UnivariateStatistic getUnivariateStatistic() {         return new SumOfLogs();     }      /**      * {@inheritDoc}      */     @Override     public double expectedValue() {         return this.sumLog;     }      @Test     public void testSpecialValues() {         SumOfLogs sum = new SumOfLogs();         // empty         Assert.assertEquals(0, sum.getResult(), 0);          // finite data         sum.increment(1d);         Assert.assertFalse(Double.isNaN(sum.getResult()));          // add negative infinity         sum.increment(0d);         Assert.assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);          // add positive infinity -- should make NaN         sum.increment(Double.POSITIVE_INFINITY);         Assert.assertTrue(Double.isNaN(sum.getResult()));          // clear         sum.clear();         Assert.assertEquals(0, sum.getResult(), 0);          // positive infinity by itself         sum.increment(Double.POSITIVE_INFINITY);         Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);          // negative value -- should make NaN         sum.increment(-2d);         Assert.assertTrue(Double.isNaN(sum.getResult()));     }      @Override     protected void checkClearValue(StorelessUnivariateStatistic statistic) {         Assert.assertEquals(0, statistic.getResult(), 0);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.stat.descriptive;  import java.util.ArrayList; import java.util.Collection;  import org.apache.commons.math4.TestUtils; import org.apache.commons.statistics.distribution.DiscreteDistribution; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.math4.distribution.AbstractRealDistribution; import org.apache.commons.statistics.distribution.UniformDiscreteDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.numbers.core.Precision; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;   /**  * Test cases for {@link AggregateSummaryStatistics}  */ public class AggregateSummaryStatisticsTest {      /**      * Tests the standard aggregation behavior      */     @Test     public void testAggregation() {         AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();         SummaryStatistics setOneStats = aggregate.createContributingStatistics();         SummaryStatistics setTwoStats = aggregate.createContributingStatistics();          Assert.assertNotNull("The set one contributing stats are null", setOneStats);         Assert.assertNotNull("The set two contributing stats are null", setTwoStats);         Assert.assertNotSame("Contributing stats objects are the same", setOneStats, setTwoStats);          setOneStats.addValue(2);         setOneStats.addValue(3);         setOneStats.addValue(5);         setOneStats.addValue(7);         setOneStats.addValue(11);         Assert.assertEquals("Wrong number of set one values", 5, setOneStats.getN());         Assert.assertTrue("Wrong sum of set one values", Precision.equals(28.0, setOneStats.getSum(), 1));          setTwoStats.addValue(2);         setTwoStats.addValue(4);         setTwoStats.addValue(8);         Assert.assertEquals("Wrong number of set two values", 3, setTwoStats.getN());         Assert.assertTrue("Wrong sum of set two values", Precision.equals(14.0, setTwoStats.getSum(), 1));          Assert.assertEquals("Wrong number of aggregate values", 8, aggregate.getN());         Assert.assertTrue("Wrong aggregate sum", Precision.equals(42.0, aggregate.getSum(), 1));     }      /**      * Verify that aggregating over a partition gives the same results      * as direct computation.      *      *  1) Randomly generate a dataset of 10-100 values      *     from [-100, 100]      *  2) Divide the dataset it into 2-5 partitions      *  3) Create an AggregateSummaryStatistic and ContributingStatistics      *     for each partition      *  4) Compare results from the AggregateSummaryStatistic with values      *     returned by a single SummaryStatistics instance that is provided      *     the full dataset      */     @Test     public void testAggregationConsistency() {          // Generate a random sample and random partition         double[] totalSample = generateSample();         double[][] subSamples = generatePartition(totalSample);         int nSamples = subSamples.length;          // Create aggregator and total stats for comparison         AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();         SummaryStatistics totalStats = new SummaryStatistics();          // Create array of component stats         SummaryStatistics componentStats[] = new SummaryStatistics[nSamples];          for (int i = 0; i < nSamples; i++) {              // Make componentStats[i] a contributing statistic to aggregate             componentStats[i] = aggregate.createContributingStatistics();              // Add values from subsample             for (int j = 0; j < subSamples[i].length; j++) {                 componentStats[i].addValue(subSamples[i][j]);             }         }          // Compute totalStats directly         for (int i = 0; i < totalSample.length; i++) {             totalStats.addValue(totalSample[i]);         }          /*          * Compare statistics in totalStats with aggregate.          * Note that guaranteed success of this comparison depends on the          * fact that <aggregate> gets values in exactly the same order          * as <totalStats>.          *          */         Assert.assertEquals(totalStats.getSummary(), aggregate.getSummary());      }      /**      * Test aggregate function by randomly generating a dataset of 10-100 values      * from [-100, 100], dividing it into 2-5 partitions, computing stats for each      * partition and comparing the result of aggregate(...) applied to the collection      * of per-partition SummaryStatistics with a single SummaryStatistics computed      * over the full sample.      */     @Test     public void testAggregate() {          // Generate a random sample and random partition         double[] totalSample = generateSample();         double[][] subSamples = generatePartition(totalSample);         int nSamples = subSamples.length;          // Compute combined stats directly         SummaryStatistics totalStats = new SummaryStatistics();         for (int i = 0; i < totalSample.length; i++) {             totalStats.addValue(totalSample[i]);         }          // Now compute subsample stats individually and aggregate         SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples];         for (int i = 0; i < nSamples; i++) {             subSampleStats[i] = new SummaryStatistics();         }         Collection<SummaryStatistics> aggregate = new ArrayList<>();         for (int i = 0; i < nSamples; i++) {             for (int j = 0; j < subSamples[i].length; j++) {                 subSampleStats[i].addValue(subSamples[i][j]);             }             aggregate.add(subSampleStats[i]);         }          // Compare values         StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);     }      /**      * Similar to {@link #testAggregate()} but operating on      * {@link StatisticalSummary} instead.      */     @Test     public void testAggregateStatisticalSummary() {          // Generate a random sample and random partition         double[] totalSample = generateSample();         double[][] subSamples = generatePartition(totalSample);         int nSamples = subSamples.length;          // Compute combined stats directly         SummaryStatistics totalStats = new SummaryStatistics();         for (int i = 0; i < totalSample.length; i++) {             totalStats.addValue(totalSample[i]);         }          // Now compute subsample stats individually and aggregate         SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples];         for (int i = 0; i < nSamples; i++) {             subSampleStats[i] = new SummaryStatistics();         }         Collection<StatisticalSummary> aggregate = new ArrayList<>();         for (int i = 0; i < nSamples; i++) {             for (int j = 0; j < subSamples[i].length; j++) {                 subSampleStats[i].addValue(subSamples[i][j]);             }             aggregate.add(subSampleStats[i].getSummary());         }          // Compare values         StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);     }       @Test     public void testAggregateDegenerate() {         double[] totalSample = {1, 2, 3, 4, 5};         double[][] subSamples = {{1}, {2}, {3}, {4}, {5}};          // Compute combined stats directly         SummaryStatistics totalStats = new SummaryStatistics();         for (int i = 0; i < totalSample.length; i++) {             totalStats.addValue(totalSample[i]);         }          // Now compute subsample stats individually and aggregate         SummaryStatistics[] subSampleStats = new SummaryStatistics[5];         for (int i = 0; i < 5; i++) {             subSampleStats[i] = new SummaryStatistics();         }         Collection<SummaryStatistics> aggregate = new ArrayList<>();         for (int i = 0; i < 5; i++) {             for (int j = 0; j < subSamples[i].length; j++) {                 subSampleStats[i].addValue(subSamples[i][j]);             }             aggregate.add(subSampleStats[i]);         }          // Compare values         StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);     }      @Test     public void testAggregateSpecialValues() {         double[] totalSample = {Double.POSITIVE_INFINITY, 2, 3, Double.NaN, 5};         double[][] subSamples = {{Double.POSITIVE_INFINITY, 2}, {3}, {Double.NaN}, {5}};          // Compute combined stats directly         SummaryStatistics totalStats = new SummaryStatistics();         for (int i = 0; i < totalSample.length; i++) {             totalStats.addValue(totalSample[i]);         }          // Now compute subsample stats individually and aggregate         SummaryStatistics[] subSampleStats = new SummaryStatistics[5];         for (int i = 0; i < 4; i++) {             subSampleStats[i] = new SummaryStatistics();         }         Collection<SummaryStatistics> aggregate = new ArrayList<>();         for (int i = 0; i < 4; i++) {             for (int j = 0; j < subSamples[i].length; j++) {                 subSampleStats[i].addValue(subSamples[i][j]);             }             aggregate.add(subSampleStats[i]);         }          // Compare values         StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);      }      /**      * Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up      * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values      * have to agree exactly, delta is used only for sum, mean, variance, std dev.      */     protected static void assertEquals(StatisticalSummary expected, StatisticalSummary observed, double delta) {         TestUtils.assertEquals(expected.getMax(), observed.getMax(), 0);         TestUtils.assertEquals(expected.getMin(), observed.getMin(), 0);         Assert.assertEquals(expected.getN(), observed.getN());         TestUtils.assertEquals(expected.getSum(), observed.getSum(), delta);         TestUtils.assertEquals(expected.getMean(), observed.getMean(), delta);         TestUtils.assertEquals(expected.getStandardDeviation(), observed.getStandardDeviation(), delta);         TestUtils.assertEquals(expected.getVariance(), observed.getVariance(), delta);     }       /**      * Generates a random sample of double values.      * Sample size is random, between 10 and 100 and values are      * uniformly distributed over [-100, 100].      *      * @return array of random double values      */     private double[] generateSample() {         final DiscreteDistribution.Sampler size =             new UniformDiscreteDistribution(10, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                       327652));         final ContinuousDistribution.Sampler randomData             = new UniformContinuousDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                                                        64925784252L));;         final int sampleSize = size.sample();         final double[] out = AbstractRealDistribution.sample(sampleSize, randomData);         return out;     }      /**      * Generates a partition of <sample> into up to 5 sequentially selected      * subsamples with randomly selected partition points.      *      * @param sample array to partition      * @return rectangular array with rows = subsamples      */     private double[][] generatePartition(double[] sample) {         final int length = sample.length;         final double[][] out = new double[5][];         int cur = 0;          // beginning of current partition segment         int offset = 0;       // end of current partition segment         int sampleCount = 0;  // number of segments defined         for (int i = 0; i < 5; i++) {             if (cur == length || offset == length) {                 break;             }             final int next;             if (i == 4 || cur == length - 1) {                 next = length - 1;             } else {                 final DiscreteDistribution.Sampler sampler =                     new UniformDiscreteDistribution(cur, length - 1).createSampler(RandomSource.create(RandomSource.WELL_512_A));                 next = sampler.sample();             }             final int subLength = next - cur + 1;             out[i] = new double[subLength];             System.arraycopy(sample, offset, out[i], 0, subLength);             cur = next + 1;             sampleCount++;             offset += subLength;         }         if (sampleCount < 5) {             double[][] out2 = new double[sampleCount][];             for (int j = 0; j < sampleCount; j++) {                 final int curSize = out[j].length;                 out2[j] = new double[curSize];                 System.arraycopy(out[j], 0, out2[j], 0, curSize);             }             return out2;         } else {             return out;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;  import java.io.Serializable; import java.util.ArrayList; import java.util.List;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.util.DefaultTransformer; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.NumberTransformer;  /**  */ public class ListUnivariateImpl extends DescriptiveStatistics implements Serializable {     /** Serializable version identifier */     private static final long serialVersionUID = -8837442489133392138L;     /**      * Holds a reference to a list - GENERICs are going to make      * our lives easier here as we could only accept List<Number>      */     protected List<Object> list;     /** Number Transformer maps Objects to Number for us. */     protected NumberTransformer transformer;      /**      * No argument constructor      */     public ListUnivariateImpl(){         this(new ArrayList<>());     }      /**      * Construct a ListUnivariate with a specific List.      * @param list The list that will back this DescriptiveStatistics      */     public ListUnivariateImpl(List<Object> list) {         this(list, new DefaultTransformer());     }      /**      * Construct a ListUnivariate with a specific List.      * @param list The list that will back this DescriptiveStatistics      * @param transformer the number transformer used to convert the list items.      */     public ListUnivariateImpl(List<Object> list, NumberTransformer transformer) {         this.list = list;         this.transformer = transformer;     }      /** {@inheritDoc} */     @Override     public double[] getValues() {         int length = list.size();          // If the window size is not INFINITE_WINDOW AND         // the current list is larger that the window size, we need to         // take into account only the last n elements of the list         // as defined by windowSize          final int wSize = getWindowSize();         if (wSize != DescriptiveStatistics.INFINITE_WINDOW && wSize < list.size()) {             length = list.size() - FastMath.max(0, list.size() - wSize);         }          // Create an array to hold all values         double[] copiedArray = new double[length];          for (int i = 0; i < copiedArray.length; i++) {             copiedArray[i] = getElement(i);         }         return copiedArray;     }      /** {@inheritDoc} */     @Override     public double getElement(int index) {         double value = Double.NaN;         int calcIndex = index;          final int wSize = getWindowSize();         if (wSize != DescriptiveStatistics.INFINITE_WINDOW && wSize < list.size()) {             calcIndex = (list.size() - wSize) + index;         }           try {             value = transformer.transform(list.get(calcIndex));         } catch (MathIllegalArgumentException e) {             e.printStackTrace();         }          return value;     }      /** {@inheritDoc} */     @Override     public long getN() {         int n = 0;          final int wSize = getWindowSize();         if (wSize != DescriptiveStatistics.INFINITE_WINDOW) {             if (list.size() > wSize) {                 n = wSize;             } else {                 n = list.size();             }         } else {             n = list.size();         }          return n;     }      /** {@inheritDoc} */     @Override     public void addValue(double v) {         list.add(Double.valueOf(v));     }      /**      * Adds an object to this list.      * @param o Object to add to the list      */     public void addObject(Object o) {         list.add(o);     }      /**      * Clears all statistics.      * <p>      * <strong>N.B.: </strong> This method has the side effect of clearing the underlying list.      */     @Override     public void clear() {         list.clear();     }      /**      * Apply the given statistic to this univariate collection.      * @param stat the statistic to apply      * @return the computed value of the statistic.      */     @Override     public double apply(UnivariateStatistic stat) {         final double[] v = this.getValues();          if (v != null) {             return stat.evaluate(v, 0, v.length);         }          return Double.NaN;     }      /**      * Access the number transformer.      * @return the number transformer.      */     public NumberTransformer getTransformer() {         return transformer;     }      /**      * Modify the number transformer.      * @param transformer the new number transformer.      */     public void setTransformer(NumberTransformer transformer) {         this.transformer = transformer;     }      /** {@inheritDoc} */     @Override     public void setWindowSize(int windowSize) {         super.setWindowSize(windowSize);         // Discard elements from the front of the list if "windowSize"         // is less than the size of the list.         final int extra = list.size() - windowSize;         if (extra > 0) {             list.subList(0, extra).clear();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat.descriptive;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.stat.descriptive.moment.SecondMoment; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for {@link StorelessUnivariateStatistic} classes.  */ public abstract class StorelessUnivariateStatisticAbstractTest     extends UnivariateStatisticAbstractTest {      /** Small sample arrays */     protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};      /** Return a new instance of the statistic */     @Override     public abstract UnivariateStatistic getUnivariateStatistic();      /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */     @Override     public abstract double expectedValue();      /**      *  Verifies that increment() and incrementAll work properly.      */     @Test     public void testIncrementation() {          StorelessUnivariateStatistic statistic =             (StorelessUnivariateStatistic) getUnivariateStatistic();          // Add testArray one value at a time and check result         for (int i = 0; i < testArray.length; i++) {             statistic.increment(testArray[i]);         }          Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());         Assert.assertEquals(testArray.length, statistic.getN());          statistic.clear();          // Add testArray all at once and check again         statistic.incrementAll(testArray);         Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());         Assert.assertEquals(testArray.length, statistic.getN());          statistic.clear();          // Cleared         checkClearValue(statistic);         Assert.assertEquals(0, statistic.getN());      }      protected void checkClearValue(StorelessUnivariateStatistic statistic){         Assert.assertTrue(Double.isNaN(statistic.getResult()));     }      @Test     public void testSerialization() {          StorelessUnivariateStatistic statistic =             (StorelessUnivariateStatistic) getUnivariateStatistic();          TestUtils.checkSerializedEquality(statistic);          statistic.clear();          for (int i = 0; i < testArray.length; i++) {             statistic.increment(testArray[i]);             if(i % 5 == 0) {                 statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);             }         }          TestUtils.checkSerializedEquality(statistic);          Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());          statistic.clear();          checkClearValue(statistic);      }      @Test     public void testEqualsAndHashCode() {         StorelessUnivariateStatistic statistic =             (StorelessUnivariateStatistic) getUnivariateStatistic();         StorelessUnivariateStatistic statistic2 = null;          Assert.assertTrue("non-null, compared to null", !statistic.equals(statistic2));         Assert.assertTrue("reflexive, non-null", statistic.equals(statistic));          int emptyHash = statistic.hashCode();         statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();         Assert.assertTrue("empty stats should be equal", statistic.equals(statistic2));         Assert.assertEquals("empty stats should have the same hashcode",                 emptyHash, statistic2.hashCode());          statistic.increment(1d);         Assert.assertTrue("reflexive, non-empty", statistic.equals(statistic));         Assert.assertTrue("non-empty, compared to empty", !statistic.equals(statistic2));         Assert.assertTrue("non-empty, compared to empty", !statistic2.equals(statistic));         Assert.assertTrue("non-empty stat should have different hashcode from empty stat",                 statistic.hashCode() != emptyHash);          statistic2.increment(1d);         Assert.assertTrue("stats with same data should be equal", statistic.equals(statistic2));         Assert.assertEquals("stats with same data should have the same hashcode",                 statistic.hashCode(), statistic2.hashCode());          statistic.increment(Double.POSITIVE_INFINITY);         Assert.assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic));         Assert.assertTrue("stats with different n's should have different hashcodes",                 statistic.hashCode() != statistic2.hashCode());          statistic2.increment(Double.POSITIVE_INFINITY);         Assert.assertTrue("stats with same data should be equal", statistic.equals(statistic2));         Assert.assertEquals("stats with same data should have the same hashcode",                 statistic.hashCode(), statistic2.hashCode());          statistic.clear();         statistic2.clear();         Assert.assertTrue("cleared stats should be equal", statistic.equals(statistic2));         Assert.assertEquals("cleared stats should have thashcode of empty stat",                 emptyHash, statistic2.hashCode());         Assert.assertEquals("cleared stats should have thashcode of empty stat",                 emptyHash, statistic.hashCode());      }      @Test     public void testMomentSmallSamples() {         UnivariateStatistic stat = getUnivariateStatistic();         if (stat instanceof SecondMoment) {             SecondMoment moment = (SecondMoment) getUnivariateStatistic();             Assert.assertTrue(Double.isNaN(moment.getResult()));             moment.increment(1d);             Assert.assertEquals(0d, moment.getResult(), 0);         }     }      /**      * Make sure that evaluate(double[]) and inrementAll(double[]),      * getResult() give same results.      */     @Test     public void testConsistency() {         StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();         stat.incrementAll(testArray);         Assert.assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());         for (int i = 0; i < smallSamples.length; i++) {             stat.clear();             for (int j =0; j < smallSamples[i].length; j++) {                 stat.increment(smallSamples[i][j]);             }             TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());         }     }      /**      * Verifies that copied statistics remain equal to originals when      * incremented the same way.      */     @Test     public void testCopyConsistency() {          StorelessUnivariateStatistic master =             (StorelessUnivariateStatistic) getUnivariateStatistic();          StorelessUnivariateStatistic replica = null;          // Randomly select a portion of testArray to load first         long index = FastMath.round((FastMath.random()) * testArray.length);          // Put first half in master and copy master to replica         master.incrementAll(testArray, 0, (int) index);         replica = master.copy();          // Check same         Assert.assertTrue(replica.equals(master));         Assert.assertTrue(master.equals(replica));          // Now add second part to both and check again         master.incrementAll(testArray,                 (int) index, (int) (testArray.length - index));         replica.incrementAll(testArray,                 (int) index, (int) (testArray.length - index));         Assert.assertTrue(replica.equals(master));         Assert.assertTrue(master.equals(replica));     }      @Test     public void testSerial() {         StorelessUnivariateStatistic s =             (StorelessUnivariateStatistic) getUnivariateStatistic();         Assert.assertEquals(s, TestUtils.serializeAndRecover(s));     }      /**      * Make sure that evaluate(double[]) does not alter the internal state.      */     @Test     public void testEvaluateInternalState() {         StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();         stat.evaluate(testArray);         Assert.assertEquals(0, stat.getN());          stat.incrementAll(testArray);          StorelessUnivariateStatistic savedStatistic = stat.copy();          Assert.assertNotEquals(stat.getResult(), stat.evaluate(testArray, 0, 5), getTolerance());          Assert.assertEquals(savedStatistic.getResult(), stat.getResult(), 0.0);         Assert.assertEquals(savedStatistic.getN(), stat.getN());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.stat;   import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test cases for the {@link StatUtils} class.  */  public final class StatUtilsTest {      private static final double ONE = 1;     private static final float  TWO = 2;     private static final int    THREE = 3;     private static final double MEAN = 2;     private static final double SUMSQ = 18;     private static final double SUM = 8;     private static final double VAR = 0.666666666666666666667;     private static final double MIN = 1;     private static final double MAX = 3;     private static final double TOLERANCE = 10E-15;     private static final double NAN = Double.NaN;      /** test stats */     @Test     public void testStats() {         double[] values = new double[] { ONE, TWO, TWO, THREE };         Assert.assertEquals("sum", SUM, StatUtils.sum(values), TOLERANCE);         Assert.assertEquals("sumsq", SUMSQ, StatUtils.sumSq(values), TOLERANCE);         Assert.assertEquals("var", VAR, StatUtils.variance(values), TOLERANCE);         Assert.assertEquals("var with mean", VAR, StatUtils.variance(values, MEAN), TOLERANCE);         Assert.assertEquals("mean", MEAN, StatUtils.mean(values), TOLERANCE);         Assert.assertEquals("min", MIN, StatUtils.min(values), TOLERANCE);         Assert.assertEquals("max", MAX, StatUtils.max(values), TOLERANCE);     }      @Test     public void testN0andN1Conditions() {         double[] values = new double[0];          Assert.assertTrue(             "Mean of n = 0 set should be NaN",             Double.isNaN(StatUtils.mean(values)));         Assert.assertTrue(             "Variance of n = 0 set should be NaN",             Double.isNaN(StatUtils.variance(values)));          values = new double[] { ONE };          Assert.assertTrue(             "Mean of n = 1 set should be value of single item n1",             StatUtils.mean(values) == ONE);         Assert.assertTrue(             "Variance of n = 1 set should be zero",             StatUtils.variance(values) == 0);     }      @Test     public void testArrayIndexConditions() {         double[] values = { 1.0, 2.0, 3.0, 4.0 };          Assert.assertEquals(             "Sum not expected",             5.0,             StatUtils.sum(values, 1, 2),             Double.MIN_VALUE);         Assert.assertEquals(             "Sum not expected",             3.0,             StatUtils.sum(values, 0, 2),             Double.MIN_VALUE);         Assert.assertEquals(             "Sum not expected",             7.0,             StatUtils.sum(values, 2, 2),             Double.MIN_VALUE);          try {             StatUtils.sum(values, 2, 3);             Assert.fail("Expected RuntimeException");         } catch (RuntimeException e) {             // expected         }          try {             StatUtils.sum(values, -1, 2);             Assert.fail("Expected RuntimeException");         } catch (RuntimeException e) {             // expected         }      }      @Test     public void testSumSq() {         double[] x = null;          // test null         try {             StatUtils.sumSq(x);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          try {             StatUtils.sumSq(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(0, StatUtils.sumSq(x), TOLERANCE);         TestUtils.assertEquals(0, StatUtils.sumSq(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(4, StatUtils.sumSq(x), TOLERANCE);         TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(18, StatUtils.sumSq(x), TOLERANCE);         TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), TOLERANCE);     }      @Test     public void testProduct() {         double[] x = null;          // test null         try {             StatUtils.product(x);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          try {             StatUtils.product(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(1, StatUtils.product(x), TOLERANCE);         TestUtils.assertEquals(1, StatUtils.product(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(TWO, StatUtils.product(x), TOLERANCE);         TestUtils.assertEquals(TWO, StatUtils.product(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(12, StatUtils.product(x), TOLERANCE);         TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), TOLERANCE);     }      @Test     public void testSumLog() {         double[] x = null;          // test null         try {             StatUtils.sumLog(x);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          try {             StatUtils.sumLog(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(0, StatUtils.sumLog(x), TOLERANCE);         TestUtils.assertEquals(0, StatUtils.sumLog(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(FastMath.log(TWO), StatUtils.sumLog(x), TOLERANCE);         TestUtils.assertEquals(FastMath.log(TWO), StatUtils.sumLog(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(FastMath.log(ONE) + 2.0 * FastMath.log(TWO) + FastMath.log(THREE), StatUtils.sumLog(x), TOLERANCE);         TestUtils.assertEquals(2.0 * FastMath.log(TWO), StatUtils.sumLog(x, 1, 2), TOLERANCE);     }      @Test     public void testMean() {         double[] x = null;          try {             StatUtils.mean(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(TWO, StatUtils.mean(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), TOLERANCE);     }      @Test     public void testVariance() {         double[] x = null;          try {             StatUtils.variance(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), TOLERANCE);          // test precomputed mean         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), TOLERANCE);     }      @Test     public void testPopulationVariance() {         double[] x = null;          try {             StatUtils.variance(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(Double.NaN, StatUtils.populationVariance(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(0.0, StatUtils.populationVariance(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(0.25, StatUtils.populationVariance(x, 0, 2), TOLERANCE);          // test precomputed mean         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(0.25, StatUtils.populationVariance(x, 2.5, 2, 2), TOLERANCE);     }       @Test     public void testMax() {         double[] x = null;          try {             StatUtils.max(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(TWO, StatUtils.max(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(THREE, StatUtils.max(x, 1, 3), TOLERANCE);          // test first nan is ignored         x = new double[] {NAN, TWO, THREE};         TestUtils.assertEquals(THREE, StatUtils.max(x), TOLERANCE);          // test middle nan is ignored         x = new double[] {ONE, NAN, THREE};         TestUtils.assertEquals(THREE, StatUtils.max(x), TOLERANCE);          // test last nan is ignored         x = new double[] {ONE, TWO, NAN};         TestUtils.assertEquals(TWO, StatUtils.max(x), TOLERANCE);          // test all nan returns nan         x = new double[] {NAN, NAN, NAN};         TestUtils.assertEquals(NAN, StatUtils.max(x), TOLERANCE);     }      @Test     public void testMin() {         double[] x = null;          try {             StatUtils.min(x, 0, 4);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(TWO, StatUtils.min(x, 0, 1), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(TWO, StatUtils.min(x, 1, 3), TOLERANCE);          // test first nan is ignored         x = new double[] {NAN, TWO, THREE};         TestUtils.assertEquals(TWO, StatUtils.min(x), TOLERANCE);          // test middle nan is ignored         x = new double[] {ONE, NAN, THREE};         TestUtils.assertEquals(ONE, StatUtils.min(x), TOLERANCE);          // test last nan is ignored         x = new double[] {ONE, TWO, NAN};         TestUtils.assertEquals(ONE, StatUtils.min(x), TOLERANCE);          // test all nan returns nan         x = new double[] {NAN, NAN, NAN};         TestUtils.assertEquals(NAN, StatUtils.min(x), TOLERANCE);     }      @Test     public void testPercentile() {         double[] x = null;          // test null         try {             StatUtils.percentile(x, .25);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          try {             StatUtils.percentile(x, 0, 4, 0.25);             Assert.fail("null is not a valid data array.");         } catch (NullArgumentException ex) {             // success         }          // test empty         x = new double[] {};         TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), TOLERANCE);         TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), TOLERANCE);          // test one         x = new double[] {TWO};         TestUtils.assertEquals(TWO, StatUtils.percentile(x, 25), TOLERANCE);         TestUtils.assertEquals(TWO, StatUtils.percentile(x, 0, 1, 25), TOLERANCE);          // test many         x = new double[] {ONE, TWO, TWO, THREE};         TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), TOLERANCE);         TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), TOLERANCE);     }      @Test     public void testDifferenceStats() {         double sample1[] = {1d, 2d, 3d, 4d};         double sample2[] = {1d, 3d, 4d, 2d};         double diff[] = {0d, -1d, -1d, 2d};         double small[] = {1d, 4d};         double meanDifference = StatUtils.meanDifference(sample1, sample2);         Assert.assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), TOLERANCE);         Assert.assertEquals(meanDifference, StatUtils.mean(diff), TOLERANCE);         Assert.assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),                 StatUtils.variance(diff), TOLERANCE);         try {             StatUtils.meanDifference(sample1, small);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             StatUtils.varianceDifference(sample1, small, meanDifference);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             double[] single = {1.0};             StatUtils.varianceDifference(single, single, meanDifference);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      @Test     public void testGeometricMean() {         double[] test = null;         try {             StatUtils.geometricMean(test);             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // expected         }         test = new double[] {2, 4, 6, 8};         Assert.assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)),                 StatUtils.geometricMean(test), Double.MIN_VALUE);         Assert.assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)),                 StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);     }       /**      * Run the test with the values 50 and 100 and assume standardized values      */      @Test     public void testNormalize1() {         double sample[] = { 50, 100 };         double expectedSample[] = { -25 / FastMath.sqrt(1250), 25 / FastMath.sqrt(1250) };         double[] out = StatUtils.normalize(sample);         for (int i = 0; i < out.length; i++) {             Assert.assertTrue(Precision.equals(out[i], expectedSample[i], 1));         }      }      /**      * Run with 77 random values, assuming that the outcome has a mean of 0 and a standard deviation of 1 with a      * precision of 1E-10.      */      @Test     public void testNormalize2() {         // create an sample with 77 values         int length = 77;         double sample[] = new double[length];         for (int i = 0; i < length; i++) {             sample[i] = FastMath.random();         }         // normalize this sample         double standardizedSample[] = StatUtils.normalize(sample);          DescriptiveStatistics stats = new DescriptiveStatistics();         // Add the data from the array         for (int i = 0; i < length; i++) {             stats.addValue(standardizedSample[i]);         }         // the calculations do have a limited precision         double distance = 1E-10;         // check the mean an standard deviation         Assert.assertEquals(0.0, stats.getMean(), distance);         Assert.assertEquals(1.0, stats.getStandardDeviation(), distance);      }      @Test     public void testMode() {         final double[] singleMode = {0, 1, 0, 2, 7, 11, 12};         final double[] modeSingle = StatUtils.mode(singleMode);         Assert.assertEquals(0, modeSingle[0], Double.MIN_VALUE);         Assert.assertEquals(1, modeSingle.length);          final double[] twoMode = {0, 1, 2, 0, 2, 3, 7, 11};         final double[] modeDouble = StatUtils.mode(twoMode);         Assert.assertEquals(0, modeDouble[0], Double.MIN_VALUE);         Assert.assertEquals(2, modeDouble[1], Double.MIN_VALUE);         Assert.assertEquals(2, modeDouble.length);          final double[] nanInfested = {0, 0, 0, Double.NaN, Double.NaN, Double.NaN, Double.NaN, 2, 2, 2, 3, 5};         final double[] modeNan = StatUtils.mode(nanInfested);         Assert.assertEquals(0, modeNan[0], Double.MIN_VALUE);         Assert.assertEquals(2, modeNan[1], Double.MIN_VALUE);         Assert.assertEquals(2, modeNan.length);          final double[] infInfested = {0, 0, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY,             Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 2, 2, 3, 5};         final double[] modeInf = StatUtils.mode(infInfested);         Assert.assertEquals(Double.NEGATIVE_INFINITY, modeInf[0], Double.MIN_VALUE);         Assert.assertEquals(0, modeInf[1], Double.MIN_VALUE);         Assert.assertEquals(2, modeInf[2], Double.MIN_VALUE);         Assert.assertEquals(Double.POSITIVE_INFINITY, modeInf[3], Double.MIN_VALUE);         Assert.assertEquals(4, modeInf.length);          final double[] noData = {};         final double[] modeNodata = StatUtils.mode(noData);         Assert.assertEquals(0, modeNodata.length);          final double[] nansOnly = {Double.NaN, Double.NaN};         final double[] modeNansOnly = StatUtils.mode(nansOnly);         Assert.assertEquals(0, modeNansOnly.length);          final double[] nullArray = null;         try {             StatUtils.mode(nullArray);             Assert.fail("Expecting NullArgumentException");         } catch (NullArgumentException ex) {             // Expected         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Expm1; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for {@link MullerSolver Muller} solver.  * <p>  * Muller's method converges almost quadratically near roots, but it can  * be very slow in regions far away from zeros. Test runs show that for  * reasonably good initial values, for a default absolute accuracy of 1E-6,  * it generally takes 5 to 10 iterations for the solver to converge.  * <p>  * Tests for the exponential function illustrate the situations where  * Muller solver performs poorly.  *  */ public final class MullerSolverTest {     /**      * Test of solver for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = new MullerSolver();         double min, max, expected, result, tolerance;          min = 3.0; max = 4.0; expected = FastMath.PI;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -1.0; max = 1.5; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the quintic function.      */     @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateSolver solver = new MullerSolver();         double min, max, expected, result, tolerance;          min = -0.4; max = 0.2; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = 0.75; max = 1.5; expected = 1.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -0.9; max = -0.2; expected = -0.5;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the exponential function.      * <p>      * It takes 10 to 15 iterations for the last two tests to converge.      * In fact, if not for the bisection alternative, the solver would      * exceed the default maximal iteration of 100.      */     @Test     public void testExpm1Function() {         UnivariateFunction f = new Expm1();         UnivariateSolver solver = new MullerSolver();         double min, max, expected, result, tolerance;          min = -1.0; max = 2.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -20.0; max = 10.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -50.0; max = 100.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of parameters for the solver.      */     @Test     public void testParameters() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = new MullerSolver();          try {             // bad interval             double root = solver.solve(100, f, 1, -1);             System.out.println("root=" + root);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // no bracketing             solver.solve(100, f, 2, 3);             Assert.fail("Expecting NoBracketingException - no bracketing");         } catch (NoBracketingException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.util.FastMath; import org.junit.Test; import org.junit.Assert;  /**  * Test case for {@link RegulaFalsiSolver Regula Falsi} solver.  *  */ public final class RegulaFalsiSolverTest extends BaseSecantSolverAbstractTest {     /** {@inheritDoc} */     @Override     protected UnivariateSolver getSolver() {         return new RegulaFalsiSolver();     }      /** {@inheritDoc} */     @Override     protected int[] getQuinticEvalCounts() {         // While the Regula Falsi method guarantees convergence, convergence         // may be extremely slow. The last test case does not converge within         // even a million iterations. As such, it was disabled.         return new int[] {3, 7, 8, 19, 18, 11, 67, 55, 288, 151, -1};     }      @Test(expected=ConvergenceException.class)     public void testIssue631() {         final UnivariateFunction f = new UnivariateFunction() {                 /** {@inheritDoc} */                 @Override                 public double value(double x) {                     return FastMath.exp(x) - FastMath.pow(Math.PI, 3.0);                 }             };          final UnivariateSolver solver = new RegulaFalsiSolver();         final double root = solver.solve(3624, f, 1, 10);         Assert.assertEquals(3.4341896575482003, root, 1e-15);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.solvers;  /**  * Test case for {@link SecantSolver Secant} solver.  *  */ public final class SecantSolverTest extends BaseSecantSolverAbstractTest {     /** {@inheritDoc} */     @Override     protected UnivariateSolver getSolver() {         return new SecantSolver();     }      /** {@inheritDoc} */     @Override     protected int[] getQuinticEvalCounts() {         // As the Secant method does not maintain a bracketed solution,         // convergence is not guaranteed. Two test cases are disabled (-1) due         // to bad solutions.         return new int[] {3, 7, -1, 8, 9, 8, 11, 12, 14, -1, 16};     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  */ public final class BisectionSolverTest {     @Test     public void testSinZero() {         UnivariateFunction f = new Sin();         double result;          BisectionSolver solver = new BisectionSolver();         result = solver.solve(100, f, 3, 4);         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 1, 4);         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());     }      @Test     public void testQuinticZero() {         UnivariateFunction f = new QuinticFunction();         double result;          BisectionSolver solver = new BisectionSolver();         result = solver.solve(100, f, -0.2, 0.2);         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, -0.1, 0.3);         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, -0.3, 0.45);         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.3, 0.7);         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.2, 0.6);         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.05, 0.95);         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.85, 1.25);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.8, 1.2);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.85, 1.75);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.55, 1.45);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.85, 5);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          Assert.assertTrue(solver.getEvaluations() > 0);     }      @Test     public void testMath369() {         UnivariateFunction f = new Sin();         BisectionSolver solver = new BisectionSolver();         Assert.assertEquals(FastMath.PI, solver.solve(100, f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.RealFieldUnivariateFunction; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.dfp.DfpField; import org.apache.commons.math4.dfp.DfpMath; import org.apache.commons.math4.exception.MathInternalError; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Test case for {@link FieldBracketingNthOrderBrentSolver bracketing n<sup>th</sup> order Brent} solver.  *  */ public final class FieldBracketingNthOrderBrentSolverTest {      @Test(expected=NumberIsTooSmallException.class)     public void testInsufficientOrder3() {         new FieldBracketingNthOrderBrentSolver<>(relativeAccuracy, absoluteAccuracy,                                                     functionValueAccuracy, 1);     }      @Test     public void testConstructorOK() {         FieldBracketingNthOrderBrentSolver<Dfp> solver =                 new FieldBracketingNthOrderBrentSolver<>(relativeAccuracy, absoluteAccuracy,                                                             functionValueAccuracy, 2);         Assert.assertEquals(2, solver.getMaximalOrder());     }      @Test     public void testConvergenceOnFunctionAccuracy() {         FieldBracketingNthOrderBrentSolver<Dfp> solver =                 new FieldBracketingNthOrderBrentSolver<>(relativeAccuracy, absoluteAccuracy,                                                             field.newDfp(1.0e-20), 20);         RealFieldUnivariateFunction<Dfp> f = new RealFieldUnivariateFunction<Dfp>() {             @Override             public Dfp value(Dfp x) {                 Dfp one     = field.getOne();                 Dfp oneHalf = one.divide(2);                 Dfp xMo     = x.subtract(one);                 Dfp xMh     = x.subtract(oneHalf);                 Dfp xPh     = x.add(oneHalf);                 Dfp xPo     = x.add(one);                 return xMo.multiply(xMh).multiply(x).multiply(xPh).multiply(xPo);             }         };          Dfp result = solver.solve(20, f, field.newDfp(0.2), field.newDfp(0.9),                                   field.newDfp(0.4), AllowedSolution.BELOW_SIDE);         Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));         Assert.assertTrue(f.value(result).negativeOrNull());         Assert.assertTrue(result.subtract(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).positiveOrNull());         result = solver.solve(20, f, field.newDfp(-0.9), field.newDfp(-0.2),                               field.newDfp(-0.4), AllowedSolution.ABOVE_SIDE);         Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));         Assert.assertTrue(f.value(result).positiveOrNull());         Assert.assertTrue(result.add(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).negativeOrNull());     }      @Test     public void testNeta() {          // the following test functions come from Beny Neta's paper:         // "Several New Methods for solving Equations"         // intern J. Computer Math Vol 23 pp 265-282         // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF         for (AllowedSolution allowed : AllowedSolution.values()) {             check(new RealFieldUnivariateFunction<Dfp>() {                 @Override                 public Dfp value(Dfp x) {                     return DfpMath.sin(x).subtract(x.divide(2));                 }             }, 200, -2.0, 2.0, allowed);              check(new RealFieldUnivariateFunction<Dfp>() {                 @Override                 public Dfp value(Dfp x) {                     return DfpMath.pow(x, 5).add(x).subtract(field.newDfp(10000));                 }             }, 200, -5.0, 10.0, allowed);              check(new RealFieldUnivariateFunction<Dfp>() {                 @Override                 public Dfp value(Dfp x) {                     return x.sqrt().subtract(field.getOne().divide(x)).subtract(field.newDfp(3));                 }             }, 200, 0.001, 10.0, allowed);              check(new RealFieldUnivariateFunction<Dfp>() {                 @Override                 public Dfp value(Dfp x) {                     return DfpMath.exp(x).add(x).subtract(field.newDfp(20));                 }             }, 200, -5.0, 5.0, allowed);              check(new RealFieldUnivariateFunction<Dfp>() {                 @Override                 public Dfp value(Dfp x) {                     return DfpMath.log(x).add(x.sqrt()).subtract(field.newDfp(5));                 }             }, 200, 0.001, 10.0, allowed);              check(new RealFieldUnivariateFunction<Dfp>() {                 @Override                 public Dfp value(Dfp x) {                     return x.subtract(field.getOne()).multiply(x).multiply(x).subtract(field.getOne());                 }             }, 200, -0.5, 1.5, allowed);         }      }      private void check(RealFieldUnivariateFunction<Dfp> f, int maxEval, double min, double max,                        AllowedSolution allowedSolution) {         FieldBracketingNthOrderBrentSolver<Dfp> solver =                 new FieldBracketingNthOrderBrentSolver<>(relativeAccuracy, absoluteAccuracy,                                                      functionValueAccuracy, 20);         Dfp xResult = solver.solve(maxEval, f, field.newDfp(min), field.newDfp(max),                                    allowedSolution);         Dfp yResult = f.value(xResult);         switch (allowedSolution) {         case ANY_SIDE :             Assert.assertTrue(yResult.abs().lessThan(functionValueAccuracy.multiply(2)));             break;         case LEFT_SIDE : {             boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult);             Assert.assertTrue(increasing ? yResult.negativeOrNull() : yResult.positiveOrNull());             break;         }         case RIGHT_SIDE : {             boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult);             Assert.assertTrue(increasing ? yResult.positiveOrNull() : yResult.negativeOrNull());             break;         }         case BELOW_SIDE :             Assert.assertTrue(yResult.negativeOrNull());             break;         case ABOVE_SIDE :             Assert.assertTrue(yResult.positiveOrNull());             break;         default :             // this should never happen             throw new MathInternalError(null);         }     }      @Before     public void setUp() {         field                 = new DfpField(50);         absoluteAccuracy      = field.newDfp(1.0e-45);         relativeAccuracy      = field.newDfp(1.0e-45);         functionValueAccuracy = field.newDfp(1.0e-45);     }      private DfpField field;     private Dfp      absoluteAccuracy;     private Dfp      relativeAccuracy;     private Dfp      functionValueAccuracy;  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.XMinus5Function; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Base class for root-finding algorithms tests derived from  * {@link BaseSecantSolver}.  *  */ public abstract class BaseSecantSolverAbstractTest {     /** Returns the solver to use to perform the tests.      * @return the solver to use to perform the tests      */     protected abstract UnivariateSolver getSolver();      /** Returns the expected number of evaluations for the      * {@link #testQuinticZero} unit test. A value of {@code -1} indicates that      * the test should be skipped for that solver.      * @return the expected number of evaluations for the      * {@link #testQuinticZero} unit test      */     protected abstract int[] getQuinticEvalCounts();      @Test     public void testSinZero() {         // The sinus function is behaved well around the root at pi. The second         // order derivative is zero, which means linear approximating methods         // still converge quadratically.         UnivariateFunction f = new Sin();         double result;         UnivariateSolver solver = getSolver();          result = solver.solve(100, f, 3, 4);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 6);         result = solver.solve(100, f, 1, 4);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 7);     }      @Test     public void testQuinticZero() {         // The quintic function has zeros at 0, +-0.5 and +-1.         // Around the root of 0 the function is well behaved, with a second         // derivative of zero a 0.         // The other roots are less well to find, in particular the root at 1,         // because the function grows fast for x>1.         // The function has extrema (first derivative is zero) at 0.27195613         // and 0.82221643, intervals containing these values are harder for         // the solvers.         UnivariateFunction f = new QuinticFunction();         double result;         UnivariateSolver solver = getSolver();         double atol = solver.getAbsoluteAccuracy();         int[] counts = getQuinticEvalCounts();          // Tests data: initial bounds, and expected solution, per test case.         double[][] testsData = {{-0.2,  0.2,  0.0},                                 {-0.1,  0.3,  0.0},                                 {-0.3,  0.45, 0.0},                                 { 0.3,  0.7,  0.5},                                 { 0.2,  0.6,  0.5},                                 { 0.05, 0.95, 0.5},                                 { 0.85, 1.25, 1.0},                                 { 0.8,  1.2,  1.0},                                 { 0.85, 1.75, 1.0},                                 { 0.55, 1.45, 1.0},                                 { 0.85, 5.0,  1.0},                                };         int maxIter = 500;          for(int i = 0; i < testsData.length; i++) {             // Skip test, if needed.             if (counts[i] == -1) {                 continue;             }              // Compute solution.             double[] testData = testsData[i];             result = solver.solve(maxIter, f, testData[0], testData[1]);             //System.out.println(             //    "Root: " + result + " Evaluations: " + solver.getEvaluations());              // Check solution.             Assert.assertEquals(result, testData[2], atol);             Assert.assertTrue(solver.getEvaluations() <= counts[i] + 1);         }     }      @Test     public void testRootEndpoints() {         UnivariateFunction f = new XMinus5Function();         UnivariateSolver solver = getSolver();          // End-point is root. This should be a special case in the solver, and         // the initial end-point should be returned exactly.         double result = solver.solve(100, f, 5.0, 6.0);         Assert.assertEquals(5.0, result, 0.0);          result = solver.solve(100, f, 4.0, 5.0);         Assert.assertEquals(5.0, result, 0.0);          result = solver.solve(100, f, 5.0, 6.0, 5.5);         Assert.assertEquals(5.0, result, 0.0);          result = solver.solve(100, f, 4.0, 5.0, 4.5);         Assert.assertEquals(5.0, result, 0.0);     }      @Test     public void testBadEndpoints() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = getSolver();         try {  // bad interval             solver.solve(100, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {  // no bracket             solver.solve(100, f, 1, 1.5);             Assert.fail("Expecting NoBracketingException - non-bracketing");         } catch (NoBracketingException ex) {             // expected         }         try {  // no bracket             solver.solve(100, f, 1, 1.5, 1.2);             Assert.fail("Expecting NoBracketingException - non-bracketing");         } catch (NoBracketingException ex) {             // expected         }     }      @Test     public void testSolutionLeftSide() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = getSolver();         double left = -1.5;         double right = 0.05;         for(int i = 0; i < 10; i++) {             // Test whether the allowed solutions are taken into account.             double solution = getSolution(solver, 100, f, left, right, AllowedSolution.LEFT_SIDE);             if (!Double.isNaN(solution)) {                 Assert.assertTrue(solution <= 0.0);             }              // Prepare for next test.             left -= 0.1;             right += 0.3;         }     }      @Test     public void testSolutionRightSide() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = getSolver();         double left = -1.5;         double right = 0.05;         for(int i = 0; i < 10; i++) {             // Test whether the allowed solutions are taken into account.             double solution = getSolution(solver, 100, f, left, right, AllowedSolution.RIGHT_SIDE);             if (!Double.isNaN(solution)) {                 Assert.assertTrue(solution >= 0.0);             }              // Prepare for next test.             left -= 0.1;             right += 0.3;         }     }     @Test     public void testSolutionBelowSide() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = getSolver();         double left = -1.5;         double right = 0.05;         for(int i = 0; i < 10; i++) {             // Test whether the allowed solutions are taken into account.             double solution = getSolution(solver, 100, f, left, right, AllowedSolution.BELOW_SIDE);             if (!Double.isNaN(solution)) {                 Assert.assertTrue(f.value(solution) <= 0.0);             }              // Prepare for next test.             left -= 0.1;             right += 0.3;         }     }      @Test     public void testSolutionAboveSide() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = getSolver();         double left = -1.5;         double right = 0.05;         for(int i = 0; i < 10; i++) {             // Test whether the allowed solutions are taken into account.             double solution = getSolution(solver, 100, f, left, right, AllowedSolution.ABOVE_SIDE);             if (!Double.isNaN(solution)) {                 Assert.assertTrue(f.value(solution) >= 0.0);             }              // Prepare for next test.             left -= 0.1;             right += 0.3;         }     }      private double getSolution(UnivariateSolver solver, int maxEval, UnivariateFunction f,                                double left, double right, AllowedSolution allowedSolution) {         try {             @SuppressWarnings("unchecked")             BracketedUnivariateSolver<UnivariateFunction> bracketing =             (BracketedUnivariateSolver<UnivariateFunction>) solver;             return bracketing.solve(100, f, left, right, allowedSolution);         } catch (ClassCastException cce) {             double baseRoot = solver.solve(maxEval, f, left, right);             if ((baseRoot <= left) || (baseRoot >= right)) {                 // the solution slipped out of interval                 return Double.NaN;             }             PegasusSolver bracketing =                     new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy(),                                       solver.getFunctionValueAccuracy());             return UnivariateSolverUtils.forceSide(maxEval - solver.getEvaluations(),                                                        f, bracketing, baseRoot, left, right,                                                        allowedSolution);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.junit.Assert; import org.junit.Test;  /**  * Test case for {@link BracketingNthOrderBrentSolver bracketing n<sup>th</sup> order Brent} solver.  *  */ public final class BracketingNthOrderBrentSolverTest extends BaseSecantSolverAbstractTest {     /** {@inheritDoc} */     @Override     protected UnivariateSolver getSolver() {         return new BracketingNthOrderBrentSolver();     }      /** {@inheritDoc} */     @Override     protected int[] getQuinticEvalCounts() {         return new int[] {1, 3, 8, 1, 9, 4, 8, 1, 12, 1, 16};     }      @Test(expected=NumberIsTooSmallException.class)     public void testInsufficientOrder1() {         new BracketingNthOrderBrentSolver(1.0e-10, 1);     }      @Test(expected=NumberIsTooSmallException.class)     public void testInsufficientOrder2() {         new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1);     }      @Test(expected=NumberIsTooSmallException.class)     public void testInsufficientOrder3() {         new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 1);     }      @Test     public void testConstructorsOK() {         Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 2).getMaximalOrder());         Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 2).getMaximalOrder());         Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 2).getMaximalOrder());     }      @Test     public void testConvergenceOnFunctionAccuracy() {         BracketingNthOrderBrentSolver solver =                 new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 0.001, 3);         QuinticFunction f = new QuinticFunction();         double result = solver.solve(20, f, 0.2, 0.9, 0.4, AllowedSolution.BELOW_SIDE);         Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());         Assert.assertTrue(f.value(result) <= 0);         Assert.assertTrue(result - 0.5 > solver.getAbsoluteAccuracy());         result = solver.solve(20, f, -0.9, -0.2,  -0.4, AllowedSolution.ABOVE_SIDE);         Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());         Assert.assertTrue(f.value(result) >= 0);         Assert.assertTrue(result + 0.5 < -solver.getAbsoluteAccuracy());     }      @Test     public void testIssue716() {         BracketingNthOrderBrentSolver solver =                 new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5);         UnivariateFunction sharpTurn = new UnivariateFunction() {             @Override             public double value(double x) {                 return (2 * x + 1) / (1.0e9 * (x + 1));             }         };         double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);         Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy());         Assert.assertTrue(sharpTurn.value(result) >= 0);         Assert.assertEquals(-0.5, result, 1.0e-10);     }      @Test     public void testFasterThanNewton() {         // the following test functions come from Beny Neta's paper:         // "Several New Methods for solving Equations"         // intern J. Computer Math Vol 23 pp 265-282         // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF         // the reference roots have been computed by the Dfp solver to more than         // 80 digits and checked with emacs (only the first 20 digits are reproduced here)         compare(new TestFunction(0.0, -2, 2) {             @Override             public DerivativeStructure value(DerivativeStructure x) {                 return x.sin().subtract(x.multiply(0.5));             }         });         compare(new TestFunction(6.3087771299726890947, -5, 10) {             @Override             public DerivativeStructure value(DerivativeStructure x) {                 return x.pow(5).add(x).subtract(10000);             }         });         compare(new TestFunction(9.6335955628326951924, 0.001, 10) {             @Override             public DerivativeStructure value(DerivativeStructure x) {                 return x.sqrt().subtract(x.reciprocal()).subtract(3);             }         });         compare(new TestFunction(2.8424389537844470678, -5, 5) {             @Override             public DerivativeStructure value(DerivativeStructure x) {                 return x.exp().add(x).subtract(20);             }         });         compare(new TestFunction(8.3094326942315717953, 0.001, 10) {             @Override             public DerivativeStructure value(DerivativeStructure x) {                 return x.log().add(x.sqrt()).subtract(5);             }         });         compare(new TestFunction(1.4655712318767680266, -0.5, 1.5) {             @Override             public DerivativeStructure value(DerivativeStructure x) {                 return x.subtract(1).multiply(x).multiply(x).subtract(1);             }         });      }      private void compare(TestFunction f) {         compare(f, f.getRoot(), f.getMin(), f.getMax());     }      private void compare(final UnivariateDifferentiableFunction f,                          double root, double min, double max) {         NewtonRaphsonSolver newton = new NewtonRaphsonSolver(1.0e-12);         BracketingNthOrderBrentSolver bracketing =                 new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-12, 1.0e-18, 5);         double resultN;         try {             resultN = newton.solve(100, f, min, max);         } catch (TooManyEvaluationsException tmee) {             resultN = Double.NaN;         }         double resultB;         try {             resultB = bracketing.solve(100, f, min, max);         } catch (TooManyEvaluationsException tmee) {             resultB = Double.NaN;         }         Assert.assertEquals(root, resultN, newton.getAbsoluteAccuracy());         Assert.assertEquals(root, resultB, bracketing.getAbsoluteAccuracy());          // bracketing solver evaluates only function value, we set the weight to 1         final int weightedBracketingEvaluations = bracketing.getEvaluations();          // Newton-Raphson solver evaluates both function value and derivative, we set the weight to 2         final int weightedNewtonEvaluations = 2 * newton.getEvaluations();          Assert.assertTrue(weightedBracketingEvaluations < weightedNewtonEvaluations);      }      private static abstract class TestFunction implements UnivariateDifferentiableFunction {          private final double root;         private final double min;         private final double max;          protected TestFunction(final double root, final double min, final double max) {             this.root = root;             this.min  = min;             this.max  = max;         }          public double getRoot() {             return root;         }          public double getMin() {             return min;         }          public double getMax() {             return max;         }          @Override         public double value(final double x) {             return value(new DerivativeStructure(0, 0, x)).getValue();         }          @Override         public abstract DerivativeStructure value(final DerivativeStructure t);      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  */ public class UnivariateSolverUtilsTest {      protected UnivariateFunction sin = new Sin();      @Test(expected=NullArgumentException.class)     public void testSolveNull() {         UnivariateSolverUtils.solve(null, 0.0, 4.0);     }      @Test(expected=MathIllegalArgumentException.class)     public void testSolveBadEndpoints() {         double root = UnivariateSolverUtils.solve(sin, 4.0, -0.1, 1e-6);         System.out.println("root=" + root);     }      @Test     public void testSolveBadAccuracy() {         try { // bad accuracy             UnivariateSolverUtils.solve(sin, 0.0, 4.0, 0.0); //             Assert.fail("Expecting MathIllegalArgumentException"); // TODO needs rework since convergence behaviour was changed         } catch (MathIllegalArgumentException ex) {             // expected         }     }      @Test     public void testSolveSin() {         double x = UnivariateSolverUtils.solve(sin, 1.0, 4.0);         Assert.assertEquals(FastMath.PI, x, 1.0e-4);     }      @Test(expected=NullArgumentException.class)     public void testSolveAccuracyNull()  {         double accuracy = 1.0e-6;         UnivariateSolverUtils.solve(null, 0.0, 4.0, accuracy);     }      @Test     public void testSolveAccuracySin() {         double accuracy = 1.0e-6;         double x = UnivariateSolverUtils.solve(sin, 1.0,                 4.0, accuracy);         Assert.assertEquals(FastMath.PI, x, accuracy);     }      @Test(expected=MathIllegalArgumentException.class)     public void testSolveNoRoot() {         UnivariateSolverUtils.solve(sin, 1.0, 1.5);     }      @Test     public void testBracketSin() {         double[] result = UnivariateSolverUtils.bracket(sin,                 0.0, -2.0, 2.0);         Assert.assertTrue(sin.value(result[0]) < 0);         Assert.assertTrue(sin.value(result[1]) > 0);     }      @Test     public void testBracketCentered() {         double initial = 0.1;         double[] result = UnivariateSolverUtils.bracket(sin, initial, -2.0, 2.0, 0.2, 1.0, 100);         Assert.assertTrue(result[0] < initial);         Assert.assertTrue(result[1] > initial);         Assert.assertTrue(sin.value(result[0]) < 0);         Assert.assertTrue(sin.value(result[1]) > 0);     }      @Test     public void testBracketLow() {         double initial = 0.5;         double[] result = UnivariateSolverUtils.bracket(sin, initial, -2.0, 2.0, 0.2, 1.0, 100);         Assert.assertTrue(result[0] < initial);         Assert.assertTrue(result[1] < initial);         Assert.assertTrue(sin.value(result[0]) < 0);         Assert.assertTrue(sin.value(result[1]) > 0);     }      @Test     public void testBracketHigh(){         double initial = -0.5;         double[] result = UnivariateSolverUtils.bracket(sin, initial, -2.0, 2.0, 0.2, 1.0, 100);         Assert.assertTrue(result[0] > initial);         Assert.assertTrue(result[1] > initial);         Assert.assertTrue(sin.value(result[0]) < 0);         Assert.assertTrue(sin.value(result[1]) > 0);     }      @Test(expected=NoBracketingException.class)     public void testBracketLinear(){         UnivariateSolverUtils.bracket(new UnivariateFunction() {             @Override             public double value(double x) {                 return 1 - x;             }         }, 1000, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0, 1.0, 100);     }      @Test     public void testBracketExponential(){         double[] result = UnivariateSolverUtils.bracket(new UnivariateFunction() {             @Override             public double value(double x) {                 return 1 - x;             }         }, 1000, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0, 2.0, 10);         Assert.assertTrue(result[0] <= 1);         Assert.assertTrue(result[1] >= 1);     }      @Test     public void testBracketEndpointRoot() {         double[] result = UnivariateSolverUtils.bracket(sin, 1.5, 0, 2.0);         Assert.assertEquals(0.0, sin.value(result[0]), 1.0e-15);         Assert.assertTrue(sin.value(result[1]) > 0);     }      @Test(expected=NullArgumentException.class)     public void testNullFunction() {         UnivariateSolverUtils.bracket(null, 1.5, 0, 2.0);     }      @Test(expected=MathIllegalArgumentException.class)     public void testBadInitial() {         UnivariateSolverUtils.bracket(sin, 2.5, 0, 2.0);     }      @Test(expected=MathIllegalArgumentException.class)     public void testBadAdditive() {         UnivariateSolverUtils.bracket(sin, 1.0, -2.0, 3.0, -1.0, 1.0, 100);     }      @Test(expected=NoBracketingException.class)     public void testIterationExceeded() {         UnivariateSolverUtils.bracket(sin, 1.0, -2.0, 3.0, 1.0e-5, 1.0, 100);     }      @Test(expected=MathIllegalArgumentException.class)     public void testBadEndpoints() {         // endpoints not valid         UnivariateSolverUtils.bracket(sin, 1.5, 2.0, 1.0);     }      @Test(expected=MathIllegalArgumentException.class)     public void testBadMaximumIterations() {         // bad maximum iterations         UnivariateSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);     }      /** check the search continues when a = lowerBound and b < upperBound. */     @Test     public void testBracketLoopConditionForB() {         double[] result = UnivariateSolverUtils.bracket(sin, -0.9, -1, 1, 0.1, 1, 100);         Assert.assertTrue(result[0] <= 0);         Assert.assertTrue(result[1] >= 0);     }      @Test     public void testMisc() {         UnivariateFunction f = new QuinticFunction();         double result;         // Static solve method         result = UnivariateSolverUtils.solve(f, -0.2, 0.2);         Assert.assertEquals(result, 0, 1E-8);         result = UnivariateSolverUtils.solve(f, -0.1, 0.3);         Assert.assertEquals(result, 0, 1E-8);         result = UnivariateSolverUtils.solve(f, -0.3, 0.45);         Assert.assertEquals(result, 0, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.3, 0.7);         Assert.assertEquals(result, 0.5, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.2, 0.6);         Assert.assertEquals(result, 0.5, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.05, 0.95);         Assert.assertEquals(result, 0.5, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.85, 1.25);         Assert.assertEquals(result, 1.0, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.8, 1.2);         Assert.assertEquals(result, 1.0, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.85, 1.75);         Assert.assertEquals(result, 1.0, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.55, 1.45);         Assert.assertEquals(result, 1.0, 1E-6);         result = UnivariateSolverUtils.solve(f, 0.85, 5);         Assert.assertEquals(result, 1.0, 1E-6);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Expm1; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for {@link MullerSolver2 Muller} solver.  * <p>  * Muller's method converges almost quadratically near roots, but it can  * be very slow in regions far away from zeros. Test runs show that for  * reasonably good initial values, for a default absolute accuracy of 1E-6,  * it generally takes 5 to 10 iterations for the solver to converge.  * <p>  * Tests for the exponential function illustrate the situations where  * Muller solver performs poorly.  *  */ public final class MullerSolver2Test {     /**      * Test of solver for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = new MullerSolver2();         double min, max, expected, result, tolerance;          min = 3.0; max = 4.0; expected = FastMath.PI;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -1.0; max = 1.5; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the quintic function.      */     @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateSolver solver = new MullerSolver2();         double min, max, expected, result, tolerance;          min = -0.4; max = 0.2; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = 0.75; max = 1.5; expected = 1.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -0.9; max = -0.2; expected = -0.5;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the exponential function.      * <p>      * It takes 25 to 50 iterations for the last two tests to converge.      */     @Test     public void testExpm1Function() {         UnivariateFunction f = new Expm1();         UnivariateSolver solver = new MullerSolver2();         double min, max, expected, result, tolerance;          min = -1.0; max = 2.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -20.0; max = 10.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -50.0; max = 100.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of parameters for the solver.      */     @Test     public void testParameters() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = new MullerSolver2();          try {             // bad interval             solver.solve(100, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // no bracketing             solver.solve(100, f, 2, 3);             Assert.fail("Expecting NoBracketingException - no bracketing");         } catch (NoBracketingException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.solvers;  /**  * Test case for {@link PegasusSolver Pegasus} solver.  *  */ public final class PegasusSolverTest extends BaseSecantSolverAbstractTest {     /** {@inheritDoc} */     @Override     protected UnivariateSolver getSolver() {         return new PegasusSolver();     }      /** {@inheritDoc} */     @Override     protected int[] getQuinticEvalCounts() {         return new int[] {3, 7, 9, 8, 9, 8, 10, 10, 12, 16, 18};     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.FunctionUtils; import org.apache.commons.math4.analysis.MonitoredFunction; import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math4.analysis.function.Constant; import org.apache.commons.math4.analysis.function.Inverse; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.Sqrt; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for {@link BrentSolver Brent} solver.  * Because Brent-Dekker is guaranteed to converge in less than the default  * maximum iteration count due to bisection fallback, it is quite hard to  * debug. I include measured iteration counts plus one in order to detect  * regressions. On average Brent-Dekker should use 4..5 iterations for the  * default absolute accuracy of 10E-8 for sinus and the quintic function around  * zero, and 5..10 iterations for the other zeros.  *  */ public final class BrentSolverTest {     @Test     public void testSinZero() {         // The sinus function is behaved well around the root at pi. The second         // order derivative is zero, which means linar approximating methods will         // still converge quadratically.         UnivariateFunction f = new Sin();         double result;         UnivariateSolver solver = new BrentSolver();         // Somewhat benign interval. The function is monotone.         result = solver.solve(100, f, 3, 4);         // System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 7);         // Larger and somewhat less benign interval. The function is grows first.         result = solver.solve(100, f, 1, 4);         // System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 8);     }      @Test     public void testQuinticZero() {         // The quintic function has zeros at 0, +-0.5 and +-1.         // Around the root of 0 the function is well behaved, with a second derivative         // of zero a 0.         // The other roots are less well to find, in particular the root at 1, because         // the function grows fast for x>1.         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,         // intervals containing these values are harder for the solvers.         UnivariateFunction f = new QuinticFunction();         double result;         // Brent-Dekker solver.         UnivariateSolver solver = new BrentSolver();         // Symmetric bracket around 0. Test whether solvers can handle hitting         // the root in the first iteration.         result = solver.solve(100, f, -0.2, 0.2);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 3);         // 1 iterations on i586 JDK 1.4.1.         // Asymmetric bracket around 0, just for fun. Contains extremum.         result = solver.solve(100, f, -0.1, 0.3);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());         // 5 iterations on i586 JDK 1.4.1.         Assert.assertTrue(solver.getEvaluations() <= 7);         // Large bracket around 0. Contains two extrema.         result = solver.solve(100, f, -0.3, 0.45);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());         // 6 iterations on i586 JDK 1.4.1.         Assert.assertTrue(solver.getEvaluations() <= 8);         // Benign bracket around 0.5, function is monotonous.         result = solver.solve(100, f, 0.3, 0.7);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());         // 6 iterations on i586 JDK 1.4.1.         Assert.assertTrue(solver.getEvaluations() <= 9);         // Less benign bracket around 0.5, contains one extremum.         result = solver.solve(100, f, 0.2, 0.6);         // System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 10);         // Large, less benign bracket around 0.5, contains both extrema.         result = solver.solve(100, f, 0.05, 0.95);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 11);         // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1         // is still a problem.         result = solver.solve(100, f, 0.85, 1.25);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 11);         // Less benign bracket around 1 with extremum.         result = solver.solve(100, f, 0.8, 1.2);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 11);         // Large bracket around 1. Monotonous.         result = solver.solve(100, f, 0.85, 1.75);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 13);         // Large bracket around 1. Interval contains extremum.         result = solver.solve(100, f, 0.55, 1.45);         //System.out.println(         //    "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 10);         // Very large bracket around 1 for testing fast growth behaviour.         result = solver.solve(100, f, 0.85, 5);         //System.out.println(        //     "Root: " + result + " Evaluations: " + solver.getEvaluations());         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertTrue(solver.getEvaluations() <= 15);          try {             result = solver.solve(5, f, 0.85, 5);             Assert.fail("Expected TooManyEvaluationsException");         } catch (TooManyEvaluationsException e) {             // Expected.         }     }      @Test     public void testRootEndpoints() {         UnivariateFunction f = new Sin();         BrentSolver solver = new BrentSolver();          // endpoint is root         double result = solver.solve(100, f, FastMath.PI, 4);         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 3, FastMath.PI);         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, FastMath.PI, 4, 3.5);         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 3, FastMath.PI, 3.07);         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());     }      @Test     public void testBadEndpoints() {         UnivariateFunction f = new Sin();         BrentSolver solver = new BrentSolver();         try {  // bad interval             solver.solve(100, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {  // no bracket             solver.solve(100, f, 1, 1.5);             Assert.fail("Expecting NoBracketingException - non-bracketing");         } catch (NoBracketingException ex) {             // expected         }         try {  // no bracket             solver.solve(100, f, 1, 1.5, 1.2);             Assert.fail("Expecting NoBracketingException - non-bracketing");         } catch (NoBracketingException ex) {             // expected         }     }      @Test     public void testInitialGuess() {         MonitoredFunction f = new MonitoredFunction(new QuinticFunction());         BrentSolver solver = new BrentSolver();         double result;          // no guess         result = solver.solve(100, f, 0.6, 7.0);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         int referenceCallsCount = f.getCallsCount();         Assert.assertTrue(referenceCallsCount >= 13);          // invalid guess (it *is* a root, but outside of the range)         try {           result = solver.solve(100, f, 0.6, 7.0, 0.0);           Assert.fail("a NumberIsTooLargeException was expected");         } catch (NumberIsTooLargeException iae) {             // expected behaviour         }          // bad guess         f.setCallsCount(0);         result = solver.solve(100, f, 0.6, 7.0, 0.61);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertTrue(f.getCallsCount() > referenceCallsCount);          // good guess         f.setCallsCount(0);         result = solver.solve(100, f, 0.6, 7.0, 0.999999);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertTrue(f.getCallsCount() < referenceCallsCount);          // perfect guess         f.setCallsCount(0);         result = solver.solve(100, f, 0.6, 7.0, 1.0);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());         Assert.assertEquals(1, solver.getEvaluations());         Assert.assertEquals(1, f.getCallsCount());     }      @Test     public void testMath832() {         final UnivariateFunction f = new UnivariateFunction() {                 private final UnivariateDifferentiableFunction sqrt = new Sqrt();                 private final UnivariateDifferentiableFunction inv = new Inverse();                 private final UnivariateDifferentiableFunction func                     = FunctionUtils.add(FunctionUtils.multiply(new Constant(1e2), sqrt),                                         FunctionUtils.multiply(new Constant(1e6), inv),                                         FunctionUtils.multiply(new Constant(1e4),                                                                FunctionUtils.compose(inv, sqrt)));                  @Override                 public double value(double x) {                     return func.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1);                 }              };          BrentSolver solver = new BrentSolver();         final double result = solver.solve(100, f, 1, 1e30, 1 + 1e-10);         Assert.assertEquals(804.93558250, result, solver.getAbsoluteAccuracy());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.solvers;  /**  * Test case for {@link IllinoisSolver Illinois} solver.  *  */ public final class IllinoisSolverTest extends BaseSecantSolverAbstractTest {     /** {@inheritDoc} */     @Override     protected UnivariateSolver getSolver() {         return new IllinoisSolver();     }      /** {@inheritDoc} */     @Override     protected int[] getQuinticEvalCounts() {         return new int[] {3, 7, 9, 10, 10, 10, 12, 12, 14, 15, 20};     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Expm1; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for {@link RiddersSolver Ridders} solver.  * <p>  * Ridders' method converges superlinearly, more specific, its rate of  * convergence is sqrt(2). Test runs show that for a default absolute  * accuracy of 1E-6, it generally takes less than 5 iterations for close  * initial bracket and 5 to 10 iterations for distant initial bracket  * to converge.  *  */ public final class RiddersSolverTest {     /**      * Test of solver for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = new RiddersSolver();         double min, max, expected, result, tolerance;          min = 3.0; max = 4.0; expected = FastMath.PI;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -1.0; max = 1.5; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the quintic function.      */     @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateSolver solver = new RiddersSolver();         double min, max, expected, result, tolerance;          min = -0.4; max = 0.2; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = 0.75; max = 1.5; expected = 1.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -0.9; max = -0.2; expected = -0.5;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the exponential function.      */     @Test     public void testExpm1Function() {         UnivariateFunction f = new Expm1();         UnivariateSolver solver = new RiddersSolver();         double min, max, expected, result, tolerance;          min = -1.0; max = 2.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -20.0; max = 10.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -50.0; max = 100.0; expected = 0.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of parameters for the solver.      */     @Test     public void testParameters() {         UnivariateFunction f = new Sin();         UnivariateSolver solver = new RiddersSolver();          try {             // bad interval             solver.solve(100, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // no bracketing             solver.solve(100, f, 2, 3);             Assert.fail("Expecting NoBracketingException - no bracketing");         } catch (NoBracketingException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.numbers.complex.Complex; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.exception.NoBracketingException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.TestUtils; import org.junit.Assert; import org.junit.Test;  /**  * Test case for Laguerre solver.  * <p>  * Laguerre's method is very efficient in solving polynomials. Test runs  * show that for a default absolute accuracy of 1E-6, it generally takes  * less than 5 iterations to find one root, provided solveAll() is not  * invoked, and 15 to 20 iterations to find all roots for quintic function.  *  */ public final class LaguerreSolverTest {     /**      * Test of solver for the linear function.      */     @Test     public void testLinearFunction() {         double min, max, expected, result, tolerance;          // p(x) = 4x - 1         double coefficients[] = { -1.0, 4.0 };         PolynomialFunction f = new PolynomialFunction(coefficients);         LaguerreSolver solver = new LaguerreSolver();          min = 0.0; max = 1.0; expected = 0.25;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the quadratic function.      */     @Test     public void testQuadraticFunction() {         double min, max, expected, result, tolerance;          // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)         double coefficients[] = { -3.0, 5.0, 2.0 };         PolynomialFunction f = new PolynomialFunction(coefficients);         LaguerreSolver solver = new LaguerreSolver();          min = 0.0; max = 2.0; expected = 0.5;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -4.0; max = -1.0; expected = -3.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the quintic function.      */     @Test     public void testQuinticFunction() {         double min, max, expected, result, tolerance;          // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)         double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };         PolynomialFunction f = new PolynomialFunction(coefficients);         LaguerreSolver solver = new LaguerreSolver();          min = -2.0; max = 2.0; expected = -1.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -5.0; max = -2.5; expected = -3.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = 3.0; max = 6.0; expected = 4.0;         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                     FastMath.abs(expected * solver.getRelativeAccuracy()));         result = solver.solve(100, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of solver for the quintic function using      * {@link LaguerreSolver#solveAllComplex(double[],double) solveAllComplex}.      */     @Test     public void testQuinticFunction2() {         // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)         final double[] coefficients = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };         final LaguerreSolver solver = new LaguerreSolver();         final Complex[] result = solver.solveAllComplex(coefficients, 0);          for (Complex expected : new Complex[] { Complex.ofCartesian(0, -2),                                                 Complex.ofCartesian(0, 2),                                                 Complex.ofCartesian(0.5, 0.5 * FastMath.sqrt(3)),                                                 Complex.ofCartesian(-1, 0),                                                 Complex.ofCartesian(0.5, -0.5 * FastMath.sqrt(3.0)) }) {             final double tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                                                   FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));             TestUtils.assertContains(result, expected, tolerance);         }     }      /**      * Test of parameters for the solver.      */     @Test     public void testParameters() {         double coefficients[] = { -3.0, 5.0, 2.0 };         PolynomialFunction f = new PolynomialFunction(coefficients);         LaguerreSolver solver = new LaguerreSolver();          try {             // bad interval             solver.solve(100, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // no bracketing             solver.solve(100, f, 2, 3);             Assert.fail("Expecting NoBracketingException - no bracketing");         } catch (NoBracketingException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.solvers;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  */ public final class NewtonRaphsonSolverTest {     /**      *      */     @Test     public void testSinZero() {         UnivariateDifferentiableFunction f = new Sin();         double result;          NewtonRaphsonSolver solver = new NewtonRaphsonSolver();         result = solver.solve(100, f, 3, 4);         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 1, 4);         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());          Assert.assertTrue(solver.getEvaluations() > 0);     }      /**      *      */     @Test     public void testQuinticZero() {         final UnivariateDifferentiableFunction f = new QuinticFunction();         double result;          NewtonRaphsonSolver solver = new NewtonRaphsonSolver();         result = solver.solve(100, f, -0.2, 0.2);         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, -0.1, 0.3);         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, -0.3, 0.45);         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.3, 0.7);         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.2, 0.6);         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.05, 0.95);         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.85, 1.25);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.8, 1.2);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.85, 1.75);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.55, 1.45);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());          result = solver.solve(100, f, 0.85, 5);         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.differentiation;  import java.util.Arrays; import java.util.List;  import org.apache.commons.math4.ExtendedFieldElementAbstractTest; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.numbers.core.ArithmeticUtils; import org.apache.commons.numbers.combinatorics.Factorial; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link DerivativeStructure}.  */ public class DerivativeStructureTest extends ExtendedFieldElementAbstractTest<DerivativeStructure> {      @Override     protected DerivativeStructure build(final double x) {         return new DerivativeStructure(2, 1, 0, x);     }      @Test(expected=NumberIsTooLargeException.class)     public void testWrongVariableIndex() {         new DerivativeStructure(3, 1, 3, 1.0);     }      @Test(expected=DimensionMismatchException.class)     public void testMissingOrders() {         new DerivativeStructure(3, 1, 0, 1.0).getPartialDerivative(0, 1);     }      @Test(expected=NumberIsTooLargeException.class)     public void testTooLargeOrder() {         new DerivativeStructure(3, 1, 0, 1.0).getPartialDerivative(1, 1, 2);     }      @Test     public void testVariableWithoutDerivative0() {         DerivativeStructure v = new DerivativeStructure(1, 0, 0, 1.0);         Assert.assertEquals(1.0, v.getValue(), 1.0e-15);     }      @Test(expected=NumberIsTooLargeException.class)     public void testVariableWithoutDerivative1() {         DerivativeStructure v = new DerivativeStructure(1, 0, 0, 1.0);         Assert.assertEquals(1.0, v.getPartialDerivative(1), 1.0e-15);     }      @Test     public void testVariable() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0),                       1.0, 1.0, 0.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0),                       2.0, 0.0, 1.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0),                       3.0, 0.0, 0.0, 1.0);         }     }      @Test     public void testConstant() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             checkF0F1(new DerivativeStructure(3, maxOrder, FastMath.PI),                       FastMath.PI, 0.0, 0.0, 0.0);         }     }      @Test     public void testCreateConstant() {         DerivativeStructure a = new DerivativeStructure(3, 2, 0, 1.3);         DerivativeStructure b = a.createConstant(2.5);         Assert.assertEquals(a.getFreeParameters(), b.getFreeParameters());         Assert.assertEquals(a.getOrder(), b.getOrder());         checkEquals(a.getField().getOne().multiply(2.5), b, 1.0e-15);     }      @Test     public void testPrimitiveAdd() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).add(5), 6.0, 1.0, 0.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).add(5), 7.0, 0.0, 1.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).add(5), 8.0, 0.0, 0.0, 1.0);         }     }      @Test     public void testAdd() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);             DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);             DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);             DerivativeStructure xyz = x.add(y.add(z));             checkF0F1(xyz, x.getValue() + y.getValue() + z.getValue(), 1.0, 1.0, 1.0);         }     }      @Test     public void testPrimitiveSubtract() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).subtract(5), -4.0, 1.0, 0.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).subtract(5), -3.0, 0.0, 1.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).subtract(5), -2.0, 0.0, 0.0, 1.0);         }     }      @Test     public void testSubtract() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);             DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);             DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);             DerivativeStructure xyz = x.subtract(y.subtract(z));             checkF0F1(xyz, x.getValue() - (y.getValue() - z.getValue()), 1.0, -1.0, 1.0);         }     }      @Test     public void testPrimitiveMultiply() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).multiply(5),  5.0, 5.0, 0.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).multiply(5), 10.0, 0.0, 5.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).multiply(5), 15.0, 0.0, 0.0, 5.0);         }     }      @Test     public void testMultiply() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);             DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);             DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);             DerivativeStructure xyz = x.multiply(y.multiply(z));             for (int i = 0; i <= maxOrder; ++i) {                 for (int j = 0; j <= maxOrder; ++j) {                     for (int k = 0; k <= maxOrder; ++k) {                         if (i + j + k <= maxOrder) {                             Assert.assertEquals((i == 0 ? x.getValue() : (i == 1 ? 1.0 : 0.0)) *                                                 (j == 0 ? y.getValue() : (j == 1 ? 1.0 : 0.0)) *                                                 (k == 0 ? z.getValue() : (k == 1 ? 1.0 : 0.0)),                                                 xyz.getPartialDerivative(i, j, k),                                                 1.0e-15);                         }                     }                 }             }         }     }      @Test     public void testNegate() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).negate(), -1.0, -1.0, 0.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).negate(), -2.0, 0.0, -1.0, 0.0);             checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).negate(), -3.0, 0.0, 0.0, -1.0);         }     }      @Test     public void testReciprocal() {         for (double x = 0.1; x < 1.2; x += 0.1) {             DerivativeStructure r = new DerivativeStructure(1, 6, 0, x).reciprocal();             Assert.assertEquals(1 / x, r.getValue(), 1.0e-15);             for (int i = 1; i < r.getOrder(); ++i) {                 double expected = ArithmeticUtils.pow(-1, i) * Factorial.value(i) /                                   FastMath.pow(x, i + 1);                 Assert.assertEquals(expected, r.getPartialDerivative(i), 1.0e-15 * FastMath.abs(expected));             }         }     }      @Test     public void testPow() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             for (int n = 0; n < 10; ++n) {                  DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);                 DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);                 DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);                 List<DerivativeStructure> list = Arrays.asList(x, y, z,                                                                x.add(y).add(z),                                                                x.multiply(y).multiply(z));                  if (n == 0) {                     for (DerivativeStructure ds : list) {                         checkEquals(ds.getField().getOne(), ds.pow(n), 1.0e-15);                     }                 } else if (n == 1) {                     for (DerivativeStructure ds : list) {                         checkEquals(ds, ds.pow(n), 1.0e-15);                     }                 } else {                     for (DerivativeStructure ds : list) {                         DerivativeStructure p = ds.getField().getOne();                         for (int i = 0; i < n; ++i) {                             p = p.multiply(ds);                         }                         checkEquals(p, ds.pow(n), 1.0e-15);                     }                 }             }         }     }      @Test     public void testPowDoubleDS() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {              DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 0.1);             DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 0.2);             DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 0.3);             List<DerivativeStructure> list = Arrays.asList(x, y, z,                                                            x.add(y).add(z),                                                            x.multiply(y).multiply(z));              for (DerivativeStructure ds : list) {                 // the special case a = 0 is included here                 for (double a : new double[] { 0.0, 0.1, 1.0, 2.0, 5.0 }) {                     DerivativeStructure reference = (a == 0) ?                                                     x.getField().getZero() :                                                     new DerivativeStructure(3, maxOrder, a).pow(ds);                     DerivativeStructure result = DerivativeStructure.pow(a, ds);                     checkEquals(reference, result, 1.0e-15);                 }              }              // negative base: -1^x can be evaluated for integers only, so value is sometimes OK, derivatives are always NaN             DerivativeStructure negEvenInteger = DerivativeStructure.pow(-2.0, new DerivativeStructure(3,  maxOrder, 0, 2.0));             Assert.assertEquals(4.0, negEvenInteger.getValue(), 1.0e-15);             Assert.assertTrue(Double.isNaN(negEvenInteger.getPartialDerivative(1, 0, 0)));             DerivativeStructure negOddInteger = DerivativeStructure.pow(-2.0, new DerivativeStructure(3,  maxOrder, 0, 3.0));             Assert.assertEquals(-8.0, negOddInteger.getValue(), 1.0e-15);             Assert.assertTrue(Double.isNaN(negOddInteger.getPartialDerivative(1, 0, 0)));             DerivativeStructure negNonInteger = DerivativeStructure.pow(-2.0, new DerivativeStructure(3,  maxOrder, 0, 2.001));             Assert.assertTrue(Double.isNaN(negNonInteger.getValue()));             Assert.assertTrue(Double.isNaN(negNonInteger.getPartialDerivative(1, 0, 0)));              DerivativeStructure zeroNeg = DerivativeStructure.pow(0.0, new DerivativeStructure(3,  maxOrder, 0, -1.0));             Assert.assertTrue(Double.isNaN(zeroNeg.getValue()));             Assert.assertTrue(Double.isNaN(zeroNeg.getPartialDerivative(1, 0, 0)));             DerivativeStructure posNeg = DerivativeStructure.pow(2.0, new DerivativeStructure(3,  maxOrder, 0, -2.0));             Assert.assertEquals(1.0 / 4.0, posNeg.getValue(), 1.0e-15);             Assert.assertEquals(FastMath.log(2.0) / 4.0, posNeg.getPartialDerivative(1, 0, 0), 1.0e-15);              // very special case: a = 0 and power = 0             DerivativeStructure zeroZero = DerivativeStructure.pow(0.0, new DerivativeStructure(3,  maxOrder, 0, 0.0));              // this should be OK for simple first derivative with one variable only ...             Assert.assertEquals(1.0, zeroZero.getValue(), 1.0e-15);             Assert.assertEquals(Double.NEGATIVE_INFINITY, zeroZero.getPartialDerivative(1, 0, 0), 1.0e-15);              // the following checks show a LIMITATION of the current implementation             // we have no way to tell x is a pure linear variable x = 0             // we only say: "x is a structure with value = 0.0,             // first derivative with respect to x = 1.0, and all other derivatives             // (first order with respect to y and z and higher derivatives) all 0.0.             // We have function f(x) = a^x and x = 0 so we compute:             // f(0) = 1, f'(0) = ln(a), f''(0) = ln(a)^2. The limit of these values             // when a converges to 0 implies all derivatives keep switching between             // +infinity and -infinity.             //             // Function composition rule for first derivatives is:             // d[f(g(x,y,z))]/dy = f'(g(x,y,z)) * dg(x,y,z)/dy             // so given that in our case x represents g and does not depend             // on y or z, we have dg(x,y,z)/dy = 0             // applying the composition rules gives:             // d[f(g(x,y,z))]/dy = f'(g(x,y,z)) * dg(x,y,z)/dy             //                 = -infinity * 0             //                 = NaN             // if we knew x is really the x variable and not the identity             // function applied to x, we would not have computed f'(g(x,y,z)) * dg(x,y,z)/dy             // and we would have found that the result was 0 and not NaN             Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 1, 0)));             Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 0, 1)));              // Function composition rule for second derivatives is:             // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)             // when function f is the a^x root and x = 0 we have:             // f(0) = 1, f'(0) = ln(a), f''(0) = ln(a)^2 which for a = 0 implies             // all derivatives keep switching between +infinity and -infinity             // so given that in our case x represents g, we have g(x) = 0,             // g'(x) = 1 and g''(x) = 0             // applying the composition rules gives:             // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)             //                 = +infinity * 1^2 + -infinity * 0             //                 = +infinity + NaN             //                 = NaN             // if we knew x is really the x variable and not the identity             // function applied to x, we would not have computed f'(g(x)) * g''(x)             // and we would have found that the result was +infinity and not NaN             if (maxOrder > 1) {                 Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(2, 0, 0)));                 Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 2, 0)));                 Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 0, 2)));                 Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(1, 1, 0)));                 Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 1, 1)));                 Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(1, 1, 0)));             }              // very special case: 0^0 where the power is a primitive             DerivativeStructure zeroDsZeroDouble = new DerivativeStructure(3,  maxOrder, 0, 0.0).pow(0.0);             boolean first = true;             for (final double d : zeroDsZeroDouble.getAllDerivatives()) {                 if (first) {                     Assert.assertEquals(1.0, d, Precision.EPSILON);                     first = false;                 } else {                     Assert.assertEquals(0.0, d, Precision.SAFE_MIN);                 }             }             DerivativeStructure zeroDsZeroInt = new DerivativeStructure(3,  maxOrder, 0, 0.0).pow(0);             first = true;             for (final double d : zeroDsZeroInt.getAllDerivatives()) {                 if (first) {                     Assert.assertEquals(1.0, d, Precision.EPSILON);                     first = false;                 } else {                     Assert.assertEquals(0.0, d, Precision.SAFE_MIN);                 }             }              // 0^p with p smaller than 1.0             DerivativeStructure u = new DerivativeStructure(3, maxOrder, 1, -0.0).pow(0.25);             for (int i0 = 0; i0 <= maxOrder; ++i0) {                 for (int i1 = 0; i1 <= maxOrder; ++i1) {                     for (int i2 = 0; i2 <= maxOrder; ++i2) {                         if (i0 + i1 + i2 <= maxOrder) {                             Assert.assertEquals(0.0, u.getPartialDerivative(i0, i1, i2), 1.0e-10);                         }                     }                 }             }         }      }      @Test     public void testExpression() {         double epsilon = 2.5e-13;         for (double x = 0; x < 2; x += 0.2) {             DerivativeStructure dsX = new DerivativeStructure(3, 5, 0, x);             for (double y = 0; y < 2; y += 0.2) {                 DerivativeStructure dsY = new DerivativeStructure(3, 5, 1, y);                 for (double z = 0; z >- 2; z -= 0.2) {                     DerivativeStructure dsZ = new DerivativeStructure(3, 5, 2, z);                      // f(x, y, z) = x + 5 x y - 2 z + (8 z x - y)^3                     DerivativeStructure ds =                             new DerivativeStructure(1, dsX,                                                     5, dsX.multiply(dsY),                                                     -2, dsZ,                                                     1, new DerivativeStructure(8, dsZ.multiply(dsX),                                                                                -1, dsY).pow(3));                     DerivativeStructure dsOther =                             new DerivativeStructure(1, dsX,                                                     5, dsX.multiply(dsY),                                                     -2, dsZ).add(new DerivativeStructure(8, dsZ.multiply(dsX),                                                                                          -1, dsY).pow(3));                     double f = x + 5 * x * y - 2 * z + FastMath.pow(8 * z * x - y, 3);                     Assert.assertEquals(f, ds.getValue(),                                         FastMath.abs(epsilon * f));                     Assert.assertEquals(f, dsOther.getValue(),                                         FastMath.abs(epsilon * f));                      // df/dx = 1 + 5 y + 24 (8 z x - y)^2 z                     double dfdx = 1 + 5 * y + 24 * z * FastMath.pow(8 * z * x - y, 2);                     Assert.assertEquals(dfdx, ds.getPartialDerivative(1, 0, 0),                                         FastMath.abs(epsilon * dfdx));                     Assert.assertEquals(dfdx, dsOther.getPartialDerivative(1, 0, 0),                                         FastMath.abs(epsilon * dfdx));                      // df/dxdy = 5 + 48 z*(y - 8 z x)                     double dfdxdy = 5 + 48 * z * (y - 8 * z * x);                     Assert.assertEquals(dfdxdy, ds.getPartialDerivative(1, 1, 0),                                         FastMath.abs(epsilon * dfdxdy));                     Assert.assertEquals(dfdxdy, dsOther.getPartialDerivative(1, 1, 0),                                         FastMath.abs(epsilon * dfdxdy));                      // df/dxdydz = 48 (y - 16 z x)                     double dfdxdydz = 48 * (y - 16 * z * x);                     Assert.assertEquals(dfdxdydz, ds.getPartialDerivative(1, 1, 1),                                         FastMath.abs(epsilon * dfdxdydz));                     Assert.assertEquals(dfdxdydz, dsOther.getPartialDerivative(1, 1, 1),                                         FastMath.abs(epsilon * dfdxdydz));                  }              }         }     }      @Test     public void testCompositionOneVariableX() {         double epsilon = 1.0e-13;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.1) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 for (double y = 0.1; y < 1.2; y += 0.1) {                     DerivativeStructure dsY = new DerivativeStructure(1, maxOrder, y);                     DerivativeStructure f = dsX.divide(dsY).sqrt();                     double f0 = FastMath.sqrt(x / y);                     Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));                     if (f.getOrder() > 0) {                         double f1 = 1 / (2 * FastMath.sqrt(x * y));                         Assert.assertEquals(f1, f.getPartialDerivative(1), FastMath.abs(epsilon * f1));                         if (f.getOrder() > 1) {                             double f2 = -f1 / (2 * x);                             Assert.assertEquals(f2, f.getPartialDerivative(2), FastMath.abs(epsilon * f2));                             if (f.getOrder() > 2) {                                 double f3 = (f0 + x / (2 * y * f0)) / (4 * x * x * x);                                 Assert.assertEquals(f3, f.getPartialDerivative(3), FastMath.abs(epsilon * f3));                             }                         }                     }                 }             }         }     }      @Test     public void testTrigo() {         double epsilon = 2.0e-12;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.1) {                 DerivativeStructure dsX = new DerivativeStructure(3, maxOrder, 0, x);                 for (double y = 0.1; y < 1.2; y += 0.1) {                     DerivativeStructure dsY = new DerivativeStructure(3, maxOrder, 1, y);                     for (double z = 0.1; z < 1.2; z += 0.1) {                         DerivativeStructure dsZ = new DerivativeStructure(3, maxOrder, 2, z);                         DerivativeStructure f = dsX.divide(dsY.cos().add(dsZ.tan())).sin();                         double a = FastMath.cos(y) + FastMath.tan(z);                         double f0 = FastMath.sin(x / a);                         Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));                         if (f.getOrder() > 0) {                             double dfdx = FastMath.cos(x / a) / a;                             Assert.assertEquals(dfdx, f.getPartialDerivative(1, 0, 0), FastMath.abs(epsilon * dfdx));                             double dfdy =  x * FastMath.sin(y) * dfdx / a;                             Assert.assertEquals(dfdy, f.getPartialDerivative(0, 1, 0), FastMath.abs(epsilon * dfdy));                             double cz = FastMath.cos(z);                             double cz2 = cz * cz;                             double dfdz = -x * dfdx / (a * cz2);                             Assert.assertEquals(dfdz, f.getPartialDerivative(0, 0, 1), FastMath.abs(epsilon * dfdz));                             if (f.getOrder() > 1) {                                 double df2dx2 = -(f0 / (a * a));                                 Assert.assertEquals(df2dx2, f.getPartialDerivative(2, 0, 0), FastMath.abs(epsilon * df2dx2));                                 double df2dy2 = x * FastMath.cos(y) * dfdx / a -                                                 x * x * FastMath.sin(y) * FastMath.sin(y) * f0 / (a * a * a * a) +                                                 2 * FastMath.sin(y) * dfdy / a;                                 Assert.assertEquals(df2dy2, f.getPartialDerivative(0, 2, 0), FastMath.abs(epsilon * df2dy2));                                 double c4 = cz2 * cz2;                                 double df2dz2 = x * (2 * a * (1 - a * cz * FastMath.sin(z)) * dfdx - x * f0 / a ) / (a * a * a * c4);                                 Assert.assertEquals(df2dz2, f.getPartialDerivative(0, 0, 2), FastMath.abs(epsilon * df2dz2));                                 double df2dxdy = dfdy / x  - x * FastMath.sin(y) * f0 / (a * a * a);                                 Assert.assertEquals(df2dxdy, f.getPartialDerivative(1, 1, 0), FastMath.abs(epsilon * df2dxdy));                             }                         }                     }                 }             }         }     }      @Test     public void testSqrtDefinition() {         double[] epsilon = new double[] { 5.0e-16, 5.0e-16, 2.0e-15, 5.0e-14, 2.0e-12 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure sqrt1 = dsX.pow(0.5);                 DerivativeStructure sqrt2 = dsX.sqrt();                 DerivativeStructure zero = sqrt1.subtract(sqrt2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testRootNSingularity() {         for (int n = 2; n < 10; ++n) {             for (int maxOrder = 0; maxOrder < 12; ++maxOrder) {                 DerivativeStructure dsZero = new DerivativeStructure(1, maxOrder, 0, 0.0);                 DerivativeStructure rootN  = dsZero.rootN(n);                 Assert.assertEquals(0.0, rootN.getValue(), 1.0e-20);                 if (maxOrder > 0) {                     Assert.assertTrue(Double.isInfinite(rootN.getPartialDerivative(1)));                     Assert.assertTrue(rootN.getPartialDerivative(1) > 0);                     for (int order = 2; order <= maxOrder; ++order) {                         // the following checks shows a LIMITATION of the current implementation                         // we have no way to tell dsZero is a pure linear variable x = 0                         // we only say: "dsZero is a structure with value = 0.0,                         // first derivative = 1.0, second and higher derivatives = 0.0".                         // Function composition rule for second derivatives is:                         // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)                         // when function f is the nth root and x = 0 we have:                         // f(0) = 0, f'(0) = +infinity, f''(0) = -infinity (and higher                         // derivatives keep switching between +infinity and -infinity)                         // so given that in our case dsZero represents g, we have g(x) = 0,                         // g'(x) = 1 and g''(x) = 0                         // applying the composition rules gives:                         // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)                         //                 = -infinity * 1^2 + +infinity * 0                         //                 = -infinity + NaN                         //                 = NaN                         // if we knew dsZero is really the x variable and not the identity                         // function applied to x, we would not have computed f'(g(x)) * g''(x)                         // and we would have found that the result was -infinity and not NaN                         Assert.assertTrue(Double.isNaN(rootN.getPartialDerivative(order)));                     }                 }                  // the following shows that the limitation explained above is NOT a bug...                 // if we set up the higher order derivatives for g appropriately, we do                 // compute the higher order derivatives of the composition correctly                 double[] gDerivatives = new double[ 1 + maxOrder];                 gDerivatives[0] = 0.0;                 for (int k = 1; k <= maxOrder; ++k) {                     gDerivatives[k] = FastMath.pow(-1.0, k + 1);                 }                 DerivativeStructure correctRoot = new DerivativeStructure(1, maxOrder, gDerivatives).rootN(n);                 Assert.assertEquals(0.0, correctRoot.getValue(), 1.0e-20);                 if (maxOrder > 0) {                     Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(1)));                     Assert.assertTrue(correctRoot.getPartialDerivative(1) > 0);                     for (int order = 2; order <= maxOrder; ++order) {                         Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(order)));                         if ((order % 2) == 0) {                             Assert.assertTrue(correctRoot.getPartialDerivative(order) < 0);                         } else {                             Assert.assertTrue(correctRoot.getPartialDerivative(order) > 0);                         }                     }                 }              }          }      }      @Test     public void testSqrtPow2() {         double[] epsilon = new double[] { 1.0e-16, 3.0e-16, 2.0e-15, 6.0e-14, 6.0e-12 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.multiply(dsX).sqrt();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testCbrtDefinition() {         double[] epsilon = new double[] { 4.0e-16, 9.0e-16, 6.0e-15, 2.0e-13, 4.0e-12 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure cbrt1 = dsX.pow(1.0 / 3.0);                 DerivativeStructure cbrt2 = dsX.cbrt();                 DerivativeStructure zero = cbrt1.subtract(cbrt2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testCbrtPow3() {         double[] epsilon = new double[] { 1.0e-16, 5.0e-16, 8.0e-15, 3.0e-13, 4.0e-11 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.multiply(dsX.multiply(dsX)).cbrt();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testPowReciprocalPow() {         double[] epsilon = new double[] { 2.0e-15, 2.0e-14, 3.0e-13, 8.0e-12, 3.0e-10 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.01) {                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);                 for (double y = 0.1; y < 1.2; y += 0.01) {                     DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);                     DerivativeStructure rebuiltX = dsX.pow(dsY).pow(dsY.reciprocal());                     DerivativeStructure zero = rebuiltX.subtract(dsX);                     for (int n = 0; n <= maxOrder; ++n) {                         for (int m = 0; m <= maxOrder; ++m) {                             if (n + m <= maxOrder) {                                 Assert.assertEquals(0.0, zero.getPartialDerivative(n, m), epsilon[n + m]);                             }                         }                     }                 }             }         }     }      @Test     public void testHypotDefinition() {         double epsilon = 1.0e-20;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = -1.7; x < 2; x += 0.2) {                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);                 for (double y = -1.7; y < 2; y += 0.2) {                     DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);                     DerivativeStructure hypot = DerivativeStructure.hypot(dsY, dsX);                     DerivativeStructure ref = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt();                     DerivativeStructure zero = hypot.subtract(ref);                     for (int n = 0; n <= maxOrder; ++n) {                         for (int m = 0; m <= maxOrder; ++m) {                             if (n + m <= maxOrder) {                                 Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon);                             }                         }                     }                 }             }         }     }      @Test     public void testHypotNoOverflow() {          DerivativeStructure dsX = new DerivativeStructure(2, 5, 0, +3.0e250);         DerivativeStructure dsY = new DerivativeStructure(2, 5, 1, -4.0e250);         DerivativeStructure hypot = DerivativeStructure.hypot(dsX, dsY);         Assert.assertEquals(5.0e250, hypot.getValue(), 1.0e235);         Assert.assertEquals(dsX.getValue() / hypot.getValue(), hypot.getPartialDerivative(1, 0), 1.0e-10);         Assert.assertEquals(dsY.getValue() / hypot.getValue(), hypot.getPartialDerivative(0, 1), 1.0e-10);          DerivativeStructure sqrt  = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt();         Assert.assertTrue(Double.isInfinite(sqrt.getValue()));      }      @Test     public void testHypotNeglectible() {          DerivativeStructure dsSmall = new DerivativeStructure(2, 5, 0, +3.0e-10);         DerivativeStructure dsLarge = new DerivativeStructure(2, 5, 1, -4.0e25);          Assert.assertEquals(dsLarge.abs().getValue(),                             DerivativeStructure.hypot(dsSmall, dsLarge).getValue(),                             1.0e-10);         Assert.assertEquals(0,                             DerivativeStructure.hypot(dsSmall, dsLarge).getPartialDerivative(1, 0),                             1.0e-10);         Assert.assertEquals(-1,                             DerivativeStructure.hypot(dsSmall, dsLarge).getPartialDerivative(0, 1),                             1.0e-10);          Assert.assertEquals(dsLarge.abs().getValue(),                             DerivativeStructure.hypot(dsLarge, dsSmall).getValue(),                             1.0e-10);         Assert.assertEquals(0,                             DerivativeStructure.hypot(dsLarge, dsSmall).getPartialDerivative(1, 0),                             1.0e-10);         Assert.assertEquals(-1,                             DerivativeStructure.hypot(dsLarge, dsSmall).getPartialDerivative(0, 1),                             1.0e-10);      }      @Test     public void testHypotSpecial() {         Assert.assertTrue(Double.isNaN(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, Double.NaN),                                                                  new DerivativeStructure(2, 5, 0, +3.0e250)).getValue()));         Assert.assertTrue(Double.isNaN(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, +3.0e250),                                                                  new DerivativeStructure(2, 5, 0, Double.NaN)).getValue()));         Assert.assertTrue(Double.isInfinite(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, Double.POSITIVE_INFINITY),                                                                       new DerivativeStructure(2, 5, 0, +3.0e250)).getValue()));         Assert.assertTrue(Double.isInfinite(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, +3.0e250),                                                                       new DerivativeStructure(2, 5, 0, Double.POSITIVE_INFINITY)).getValue()));     }      @Test     public void testPrimitiveRemainder() {         double epsilon = 1.0e-15;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = -1.7; x < 2; x += 0.2) {                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);                 for (double y = -1.7; y < 2; y += 0.2) {                     DerivativeStructure remainder = dsX.remainder(y);                     DerivativeStructure ref = dsX.subtract(x - FastMath.IEEEremainder(x, y));                     DerivativeStructure zero = remainder.subtract(ref);                     for (int n = 0; n <= maxOrder; ++n) {                         for (int m = 0; m <= maxOrder; ++m) {                             if (n + m <= maxOrder) {                                 Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon);                             }                         }                     }                 }             }         }     }      @Test     public void testRemainder() {         double epsilon = 2.0e-15;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = -1.7; x < 2; x += 0.2) {                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);                 for (double y = -1.7; y < 2; y += 0.2) {                     DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);                     DerivativeStructure remainder = dsX.remainder(dsY);                     DerivativeStructure ref = dsX.subtract(dsY.multiply((x - FastMath.IEEEremainder(x, y)) / y));                     DerivativeStructure zero = remainder.subtract(ref);                     for (int n = 0; n <= maxOrder; ++n) {                         for (int m = 0; m <= maxOrder; ++m) {                             if (n + m <= maxOrder) {                                 Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon);                             }                         }                     }                 }             }         }     }      @Override     @Test     public void testExp() {         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 double refExp = FastMath.exp(x);                 DerivativeStructure exp = new DerivativeStructure(1, maxOrder, 0, x).exp();                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(refExp, exp.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testExpm1Definition() {         double epsilon = 3.0e-16;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure expm11 = dsX.expm1();                 DerivativeStructure expm12 = dsX.exp().subtract(dsX.getField().getOne());                 DerivativeStructure zero = expm11.subtract(expm12);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon);                 }             }         }     }      @Override     @Test     public void testLog() {         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 3.0e-14, 7.0e-13, 3.0e-11 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure log = new DerivativeStructure(1, maxOrder, 0, x).log();                 Assert.assertEquals(FastMath.log(x), log.getValue(), epsilon[0]);                 for (int n = 1; n <= maxOrder; ++n) {                     double refDer = -Factorial.value(n - 1) / FastMath.pow(-x, n);                     Assert.assertEquals(refDer, log.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testLog1pDefinition() {         double epsilon = 3.0e-16;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure log1p1 = dsX.log1p();                 DerivativeStructure log1p2 = dsX.add(dsX.getField().getOne()).log();                 DerivativeStructure zero = log1p1.subtract(log1p2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon);                 }             }         }     }      @Test     public void testLog10Definition() {         double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 8.0e-15, 3.0e-13, 8.0e-12 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure log101 = dsX.log10();                 DerivativeStructure log102 = dsX.log().divide(FastMath.log(10.0));                 DerivativeStructure zero = log101.subtract(log102);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testLogExp() {         double[] epsilon = new double[] { 2.0e-16, 2.0e-16, 3.0e-16, 2.0e-15, 6.0e-15 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.exp().log();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testLog1pExpm1() {         double[] epsilon = new double[] { 6.0e-17, 3.0e-16, 5.0e-16, 9.0e-16, 6.0e-15 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.expm1().log1p();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testLog10Power() {         double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 9.0e-16, 6.0e-15, 6.0e-14 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = new DerivativeStructure(1, maxOrder, 10.0).pow(dsX).log10();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testSinCos() {         double epsilon = 5.0e-16;         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure sin = dsX.sin();                 DerivativeStructure cos = dsX.cos();                 double s = FastMath.sin(x);                 double c = FastMath.cos(x);                 for (int n = 0; n <= maxOrder; ++n) {                     switch (n % 4) {                     case 0 :                         Assert.assertEquals( s, sin.getPartialDerivative(n), epsilon);                         Assert.assertEquals( c, cos.getPartialDerivative(n), epsilon);                         break;                     case 1 :                         Assert.assertEquals( c, sin.getPartialDerivative(n), epsilon);                         Assert.assertEquals(-s, cos.getPartialDerivative(n), epsilon);                         break;                     case 2 :                         Assert.assertEquals(-s, sin.getPartialDerivative(n), epsilon);                         Assert.assertEquals(-c, cos.getPartialDerivative(n), epsilon);                         break;                     default :                         Assert.assertEquals(-c, sin.getPartialDerivative(n), epsilon);                         Assert.assertEquals( s, cos.getPartialDerivative(n), epsilon);                         break;                     }                 }             }         }     }      @Test     public void testSinAsin() {         double[] epsilon = new double[] { 3.0e-16, 5.0e-16, 3.0e-15, 2.0e-14, 4.0e-13 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.sin().asin();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testCosAcos() {         double[] epsilon = new double[] { 6.0e-16, 6.0e-15, 2.0e-13, 4.0e-12, 2.0e-10 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.cos().acos();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testTanAtan() {         double[] epsilon = new double[] { 6.0e-17, 2.0e-16, 2.0e-15, 4.0e-14, 2.0e-12 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.tan().atan();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testTangentDefinition() {         double[] epsilon = new double[] { 5.0e-16, 2.0e-15, 3.0e-14, 5.0e-13, 2.0e-11 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure tan1 = dsX.sin().divide(dsX.cos());                 DerivativeStructure tan2 = dsX.tan();                 DerivativeStructure zero = tan1.subtract(tan2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Override     @Test     public void testAtan2() {         double[] epsilon = new double[] { 5.0e-16, 3.0e-15, 2.2e-14, 1.0e-12, 8.0e-11 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = -1.7; x < 2; x += 0.2) {                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);                 for (double y = -1.7; y < 2; y += 0.2) {                     DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);                     DerivativeStructure atan2 = DerivativeStructure.atan2(dsY, dsX);                     DerivativeStructure ref = dsY.divide(dsX).atan();                     if (x < 0) {                         ref = (y < 0) ? ref.subtract(FastMath.PI) : ref.add(FastMath.PI);                     }                     DerivativeStructure zero = atan2.subtract(ref);                     for (int n = 0; n <= maxOrder; ++n) {                         for (int m = 0; m <= maxOrder; ++m) {                             if (n + m <= maxOrder) {                                 Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon[n + m]);                             }                         }                     }                 }             }         }     }      @Test     public void testAtan2SpecialCases() {          DerivativeStructure pp =                 DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),                                           new DerivativeStructure(2, 2, 1, +0.0));         Assert.assertEquals(0, pp.getValue(), 1.0e-15);         Assert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15);          DerivativeStructure pn =                 DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),                                           new DerivativeStructure(2, 2, 1, -0.0));         Assert.assertEquals(FastMath.PI, pn.getValue(), 1.0e-15);          DerivativeStructure np =                 DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),                                           new DerivativeStructure(2, 2, 1, +0.0));         Assert.assertEquals(0, np.getValue(), 1.0e-15);         Assert.assertEquals(-1, FastMath.copySign(1, np.getValue()), 1.0e-15);          DerivativeStructure nn =                 DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),                                           new DerivativeStructure(2, 2, 1, -0.0));         Assert.assertEquals(-FastMath.PI, nn.getValue(), 1.0e-15);      }      @Test     public void testSinhDefinition() {         double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure sinh1 = dsX.exp().subtract(dsX.exp().reciprocal()).multiply(0.5);                 DerivativeStructure sinh2 = dsX.sinh();                 DerivativeStructure zero = sinh1.subtract(sinh2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testCoshDefinition() {         double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure cosh1 = dsX.exp().add(dsX.exp().reciprocal()).multiply(0.5);                 DerivativeStructure cosh2 = dsX.cosh();                 DerivativeStructure zero = cosh1.subtract(cosh2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testTanhDefinition() {         double[] epsilon = new double[] { 3.0e-16, 5.0e-16, 7.0e-16, 3.0e-15, 2.0e-14 };         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure tanh1 = dsX.exp().subtract(dsX.exp().reciprocal()).divide(dsX.exp().add(dsX.exp().reciprocal()));                 DerivativeStructure tanh2 = dsX.tanh();                 DerivativeStructure zero = tanh1.subtract(tanh2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testSinhAsinh() {         double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 4.0e-16, 7.0e-16, 3.0e-15, 8.0e-15 };         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.sinh().asinh();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testCoshAcosh() {         double[] epsilon = new double[] { 2.0e-15, 1.0e-14, 2.0e-13, 6.0e-12, 3.0e-10, 2.0e-8 };         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.cosh().acosh();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testTanhAtanh() {         double[] epsilon = new double[] { 3.0e-16, 2.0e-16, 7.0e-16, 4.0e-15, 3.0e-14, 4.0e-13 };         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.tanh().atanh();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testCompositionOneVariableY() {         double epsilon = 1.0e-13;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.1) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, x);                 for (double y = 0.1; y < 1.2; y += 0.1) {                     DerivativeStructure dsY = new DerivativeStructure(1, maxOrder, 0, y);                     DerivativeStructure f = dsX.divide(dsY).sqrt();                     double f0 = FastMath.sqrt(x / y);                     Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));                     if (f.getOrder() > 0) {                         double f1 = -x / (2 * y * y * f0);                         Assert.assertEquals(f1, f.getPartialDerivative(1), FastMath.abs(epsilon * f1));                         if (f.getOrder() > 1) {                             double f2 = (f0 - x / (4 * y * f0)) / (y * y);                             Assert.assertEquals(f2, f.getPartialDerivative(2), FastMath.abs(epsilon * f2));                             if (f.getOrder() > 2) {                                 double f3 = (x / (8 * y * f0) - 2 * f0) / (y * y * y);                                 Assert.assertEquals(f3, f.getPartialDerivative(3), FastMath.abs(epsilon * f3));                             }                         }                     }                 }             }         }     }      @Test     public void testTaylorPolynomial() {         for (double x = 0; x < 1.2; x += 0.1) {             DerivativeStructure dsX = new DerivativeStructure(3, 4, 0, x);             for (double y = 0; y < 1.2; y += 0.2) {                 DerivativeStructure dsY = new DerivativeStructure(3, 4, 1, y);                 for (double z = 0; z < 1.2; z += 0.2) {                     DerivativeStructure dsZ = new DerivativeStructure(3, 4, 2, z);                     DerivativeStructure f = dsX.multiply(dsY).add(dsZ).multiply(dsX).multiply(dsY);                     for (double dx = -0.2; dx < 0.2; dx += 0.2) {                         for (double dy = -0.2; dy < 0.2; dy += 0.1) {                             for (double dz = -0.2; dz < 0.2; dz += 0.1) {                                 double ref = (x + dx) * (y + dy) * ((x + dx) * (y + dy) + (z + dz));                                 Assert.assertEquals(ref, f.taylor(dx, dy, dz), 2.0e-15);                             }                         }                     }                 }             }         }     }      @Test     public void testTaylorAtan2() {         double[] expected = new double[] { 0.214, 0.0241, 0.00422, 6.48e-4, 8.04e-5 };         double x0 =  0.1;         double y0 = -0.3;         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {             DerivativeStructure dsX   = new DerivativeStructure(2, maxOrder, 0, x0);             DerivativeStructure dsY   = new DerivativeStructure(2, maxOrder, 1, y0);             DerivativeStructure atan2 = DerivativeStructure.atan2(dsY, dsX);             double maxError = 0;             for (double dx = -0.05; dx < 0.05; dx += 0.001) {                 for (double dy = -0.05; dy < 0.05; dy += 0.001) {                     double ref = FastMath.atan2(y0 + dy, x0 + dx);                     maxError = FastMath.max(maxError, FastMath.abs(ref - atan2.taylor(dx, dy)));                 }             }             Assert.assertEquals(0.0, expected[maxOrder] - maxError, 0.01 * expected[maxOrder]);         }     }      @Override     @Test     public void testAbs() {          DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0);         Assert.assertEquals(+1.0, minusOne.abs().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.abs().getPartialDerivative(1), 1.0e-15);          DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0);         Assert.assertEquals(+1.0, plusOne.abs().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.abs().getPartialDerivative(1), 1.0e-15);          DerivativeStructure minusZero = new DerivativeStructure(1, 1, 0, -0.0);         Assert.assertEquals(+0.0, minusZero.abs().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, minusZero.abs().getPartialDerivative(1), 1.0e-15);          DerivativeStructure plusZero = new DerivativeStructure(1, 1, 0, +0.0);         Assert.assertEquals(+0.0, plusZero.abs().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, plusZero.abs().getPartialDerivative(1), 1.0e-15);      }      @Override     @Test     public void testSignum() {          DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0);         Assert.assertEquals(-1.0, minusOne.signum().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals( 0.0, minusOne.signum().getPartialDerivative(1), 1.0e-15);          DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0);         Assert.assertEquals(+1.0, plusOne.signum().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals( 0.0, plusOne.signum().getPartialDerivative(1), 1.0e-15);          DerivativeStructure minusZero = new DerivativeStructure(1, 1, 0, -0.0);         Assert.assertEquals(-0.0, minusZero.signum().getPartialDerivative(0), 1.0e-15);         Assert.assertTrue(Double.doubleToLongBits(minusZero.signum().getValue()) < 0);         Assert.assertEquals( 0.0, minusZero.signum().getPartialDerivative(1), 1.0e-15);          DerivativeStructure plusZero = new DerivativeStructure(1, 1, 0, +0.0);         Assert.assertEquals(+0.0, plusZero.signum().getPartialDerivative(0), 1.0e-15);         Assert.assertTrue(Double.doubleToLongBits(plusZero.signum().getValue()) == 0);         Assert.assertEquals( 0.0, plusZero.signum().getPartialDerivative(1), 1.0e-15);      }      @Test     public void testCeilFloorRintLong() {          DerivativeStructure x = new DerivativeStructure(1, 1, 0, -1.5);         Assert.assertEquals(-1.5, x.getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, x.getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-1.0, x.ceil().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+0.0, x.ceil().getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-2.0, x.floor().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+0.0, x.floor().getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-2.0, x.rint().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+0.0, x.rint().getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-2.0, x.subtract(x.getField().getOne()).rint().getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1l, x.round());      }      @Test     public void testCopySign() {          DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0);         Assert.assertEquals(+1.0, minusOne.copySign(+1.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(+1.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(-1.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(-1.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(+0.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(+0.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(-0.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(-0.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(Double.NaN).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(Double.NaN).getPartialDerivative(1), 1.0e-15);          DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0);         Assert.assertEquals(+1.0, plusOne.copySign(+1.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(+1.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-1.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-1.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(+0.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(+0.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-0.0).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-0.0).getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(Double.NaN).getPartialDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(Double.NaN).getPartialDerivative(1), 1.0e-15);      }      @Test     public void testToDegreesDefinition() {         double epsilon = 3.0e-16;         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 Assert.assertEquals(FastMath.toDegrees(x), dsX.toDegrees().getValue(), epsilon);                 for (int n = 1; n <= maxOrder; ++n) {                     if (n == 1) {                         Assert.assertEquals(180 / FastMath.PI, dsX.toDegrees().getPartialDerivative(1), epsilon);                     } else {                         Assert.assertEquals(0.0, dsX.toDegrees().getPartialDerivative(n), epsilon);                     }                 }             }         }     }      @Test     public void testToRadiansDefinition() {         double epsilon = 3.0e-16;         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 Assert.assertEquals(FastMath.toRadians(x), dsX.toRadians().getValue(), epsilon);                 for (int n = 1; n <= maxOrder; ++n) {                     if (n == 1) {                         Assert.assertEquals(FastMath.PI / 180, dsX.toRadians().getPartialDerivative(1), epsilon);                     } else {                         Assert.assertEquals(0.0, dsX.toRadians().getPartialDerivative(n), epsilon);                     }                 }             }         }     }      @Test     public void testDegRad() {         double epsilon = 3.0e-16;         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure rebuiltX = dsX.toDegrees().toRadians();                 DerivativeStructure zero = rebuiltX.subtract(dsX);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon);                 }             }         }     }      @Test(expected=DimensionMismatchException.class)     public void testComposeMismatchedDimensions() {         new DerivativeStructure(1, 3, 0, 1.2).compose(new double[3]);     }      @Test     public void testCompose() {         double[] epsilon = new double[] { 1.0e-20, 5.0e-14, 2.0e-13, 3.0e-13, 2.0e-13, 1.0e-20 };         PolynomialFunction poly =                 new PolynomialFunction(new double[] { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 });         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             PolynomialFunction[] p = new PolynomialFunction[maxOrder + 1];             p[0] = poly;             for (int i = 1; i <= maxOrder; ++i) {                 p[i] = p[i - 1].polynomialDerivative();             }             for (double x = 0.1; x < 1.2; x += 0.001) {                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 DerivativeStructure dsY1 = dsX.getField().getZero();                 for (int i = poly.degree(); i >= 0; --i) {                     dsY1 = dsY1.multiply(dsX).add(poly.getCoefficients()[i]);                 }                 double[] f = new double[maxOrder + 1];                 for (int i = 0; i < f.length; ++i) {                     f[i] = p[i].value(x);                 }                 DerivativeStructure dsY2 = dsX.compose(f);                 DerivativeStructure zero = dsY1.subtract(dsY2);                 for (int n = 0; n <= maxOrder; ++n) {                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);                 }             }         }     }      @Test     public void testField() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {             DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);             checkF0F1(x.getField().getZero(), 0.0, 0.0, 0.0, 0.0);             checkF0F1(x.getField().getOne(), 1.0, 0.0, 0.0, 0.0);             Assert.assertEquals(maxOrder, x.getField().getZero().getOrder());             Assert.assertEquals(3, x.getField().getZero().getFreeParameters());             Assert.assertEquals(DerivativeStructure.class, x.getField().getRuntimeClass());         }     }      @Test     public void testOneParameterConstructor() {         double x = 1.2;         double cos = FastMath.cos(x);         double sin = FastMath.sin(x);         DerivativeStructure yRef = new DerivativeStructure(1, 4, 0, x).cos();         try {             new DerivativeStructure(1, 4, 0.0, 0.0);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException dme) {             // expected         } catch (Exception e) {             Assert.fail("wrong exceptionc caught " + e.getClass().getName());         }         double[] derivatives = new double[] { cos, -sin, -cos, sin, cos };         DerivativeStructure y = new DerivativeStructure(1,  4, derivatives);         checkEquals(yRef, y, 1.0e-15);         TestUtils.assertEquals(derivatives, y.getAllDerivatives(), 1.0e-15);     }      @Test     public void testOneOrderConstructor() {         double x =  1.2;         double y =  2.4;         double z = 12.5;         DerivativeStructure xRef = new DerivativeStructure(3, 1, 0, x);         DerivativeStructure yRef = new DerivativeStructure(3, 1, 1, y);         DerivativeStructure zRef = new DerivativeStructure(3, 1, 2, z);         try {             new DerivativeStructure(3, 1, x + y - z, 1.0, 1.0);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException dme) {             // expected         } catch (Exception e) {             Assert.fail("wrong exceptionc caught " + e.getClass().getName());         }         double[] derivatives = new double[] { x + y - z, 1.0, 1.0, -1.0 };         DerivativeStructure t = new DerivativeStructure(3, 1, derivatives);         checkEquals(xRef.add(yRef.subtract(zRef)), t, 1.0e-15);         TestUtils.assertEquals(derivatives, xRef.add(yRef.subtract(zRef)).getAllDerivatives(), 1.0e-15);     }      @Test     public void testLinearCombination1DSDS() {         final DerivativeStructure[] a = new DerivativeStructure[] {             new DerivativeStructure(6, 1, 0, -1321008684645961.0 / 268435456.0),             new DerivativeStructure(6, 1, 1, -5774608829631843.0 / 268435456.0),             new DerivativeStructure(6, 1, 2, -7645843051051357.0 / 8589934592.0)         };         final DerivativeStructure[] b = new DerivativeStructure[] {             new DerivativeStructure(6, 1, 3, -5712344449280879.0 / 2097152.0),             new DerivativeStructure(6, 1, 4, -4550117129121957.0 / 2097152.0),             new DerivativeStructure(6, 1, 5, 8846951984510141.0 / 131072.0)         };          final DerivativeStructure abSumInline = a[0].linearCombination(a[0], b[0], a[1], b[1], a[2], b[2]);         final DerivativeStructure abSumArray = a[0].linearCombination(a, b);          Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);         Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);         Assert.assertEquals(b[0].getValue(), abSumInline.getPartialDerivative(1, 0, 0, 0, 0, 0), 1.0e-15);         Assert.assertEquals(b[1].getValue(), abSumInline.getPartialDerivative(0, 1, 0, 0, 0, 0), 1.0e-15);         Assert.assertEquals(b[2].getValue(), abSumInline.getPartialDerivative(0, 0, 1, 0, 0, 0), 1.0e-15);         Assert.assertEquals(a[0].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 1, 0, 0), 1.0e-15);         Assert.assertEquals(a[1].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 1, 0), 1.0e-15);         Assert.assertEquals(a[2].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 0, 1), 1.0e-15);      }      @Test     public void testLinearCombination1DoubleDS() {         final double[] a = new double[] {             -1321008684645961.0 / 268435456.0,             -5774608829631843.0 / 268435456.0,             -7645843051051357.0 / 8589934592.0         };         final DerivativeStructure[] b = new DerivativeStructure[] {             new DerivativeStructure(3, 1, 0, -5712344449280879.0 / 2097152.0),             new DerivativeStructure(3, 1, 1, -4550117129121957.0 / 2097152.0),             new DerivativeStructure(3, 1, 2, 8846951984510141.0 / 131072.0)         };          final DerivativeStructure abSumInline = b[0].linearCombination(a[0], b[0],                                                                        a[1], b[1],                                                                        a[2], b[2]);         final DerivativeStructure abSumArray = b[0].linearCombination(a, b);          Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);         Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);         Assert.assertEquals(a[0], abSumInline.getPartialDerivative(1, 0, 0), 1.0e-15);         Assert.assertEquals(a[1], abSumInline.getPartialDerivative(0, 1, 0), 1.0e-15);         Assert.assertEquals(a[2], abSumInline.getPartialDerivative(0, 0, 1), 1.0e-15);      }      @Test     public void testLinearCombination2DSDS() {         // we compare accurate versus naive dot product implementations         // on regular vectors (i.e. not extreme cases like in the previous test)         UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A, 0xc6af886975069f11l);          for (int i = 0; i < 10000; ++i) {             final DerivativeStructure[] u = new DerivativeStructure[4];             final DerivativeStructure[] v = new DerivativeStructure[4];             for (int j = 0; j < u.length; ++j) {                 u[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());                 v[j] = new DerivativeStructure(u.length, 1, 1e17 * random.nextDouble());             }              DerivativeStructure lin = u[0].linearCombination(u[0], v[0], u[1], v[1]);             double ref = u[0].getValue() * v[0].getValue() +                          u[1].getValue() * v[1].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));              lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);             ref = u[0].getValue() * v[0].getValue() +                   u[1].getValue() * v[1].getValue() +                   u[2].getValue() * v[2].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));              lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);             ref = u[0].getValue() * v[0].getValue() +                   u[1].getValue() * v[1].getValue() +                   u[2].getValue() * v[2].getValue() +                   u[3].getValue() * v[3].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));             Assert.assertEquals(v[3].getValue(), lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));          }     }      @Test     public void testLinearCombination2DoubleDS() {         // we compare accurate versus naive dot product implementations         // on regular vectors (i.e. not extreme cases like in the previous test)         UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A, 0xc6af886975069f11l);          for (int i = 0; i < 10000; ++i) {             final double[] u = new double[4];             final DerivativeStructure[] v = new DerivativeStructure[4];             for (int j = 0; j < u.length; ++j) {                 u[j] = 1e17 * random.nextDouble();                 v[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());             }              DerivativeStructure lin = v[0].linearCombination(u[0], v[0], u[1], v[1]);             double ref = u[0] * v[0].getValue() +                          u[1] * v[1].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));              lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);             ref = u[0] * v[0].getValue() +                   u[1] * v[1].getValue() +                   u[2] * v[2].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));              lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);             ref = u[0] * v[0].getValue() +                   u[1] * v[1].getValue() +                   u[2] * v[2].getValue() +                   u[3] * v[3].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));             Assert.assertEquals(u[3], lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));          }     }      @Test     public void testSerialization() {         DerivativeStructure a = new DerivativeStructure(3, 2, 0, 1.3);         DerivativeStructure b = (DerivativeStructure) TestUtils.serializeAndRecover(a);         Assert.assertEquals(a.getFreeParameters(), b.getFreeParameters());         Assert.assertEquals(a.getOrder(), b.getOrder());         checkEquals(a, b, 1.0e-15);     }      private void checkF0F1(DerivativeStructure ds, double value, double...derivatives) {          // check dimension         Assert.assertEquals(derivatives.length, ds.getFreeParameters());          // check value, directly and also as 0th order derivative         Assert.assertEquals(value, ds.getValue(), 1.0e-15);         Assert.assertEquals(value, ds.getPartialDerivative(new int[ds.getFreeParameters()]), 1.0e-15);          // check first order derivatives         for (int i = 0; i < derivatives.length; ++i) {             int[] orders = new int[derivatives.length];             orders[i] = 1;             Assert.assertEquals(derivatives[i], ds.getPartialDerivative(orders), 1.0e-15);         }      }      private void checkEquals(DerivativeStructure ds1, DerivativeStructure ds2, double epsilon) {          // check dimension         Assert.assertEquals(ds1.getFreeParameters(), ds2.getFreeParameters());         Assert.assertEquals(ds1.getOrder(), ds2.getOrder());          int[] derivatives = new int[ds1.getFreeParameters()];         int sum = 0;         while (true) {              if (sum <= ds1.getOrder()) {                 Assert.assertEquals(ds1.getPartialDerivative(derivatives),                                     ds2.getPartialDerivative(derivatives),                                     epsilon);             }              boolean increment = true;             sum = 0;             for (int i = derivatives.length - 1; i >= 0; --i) {                 if (increment) {                     if (derivatives[i] == ds1.getOrder()) {                         derivatives[i] = 0;                     } else {                         derivatives[i]++;                         increment = false;                     }                 }                 sum += derivatives[i];             }             if (increment) {                 return;             }          }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.differentiation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.util.FastMath; import org.junit.Test;   /**  * Test for class {@link GradientFunction}.  */ public class GradientFunctionTest {      @Test     public void test2DDistance() {         EuclideanDistance f = new EuclideanDistance();         GradientFunction g = new GradientFunction(f);         for (double x = -10; x < 10; x += 0.5) {             for (double y = -10; y < 10; y += 0.5) {                 double[] point = new double[] { x, y };                 TestUtils.assertEquals(f.gradient(point), g.value(point), 1.0e-15);             }         }     }      @Test     public void test3DDistance() {         EuclideanDistance f = new EuclideanDistance();         GradientFunction g = new GradientFunction(f);         for (double x = -10; x < 10; x += 0.5) {             for (double y = -10; y < 10; y += 0.5) {                 for (double z = -10; z < 10; z += 0.5) {                     double[] point = new double[] { x, y, z };                     TestUtils.assertEquals(f.gradient(point), g.value(point), 1.0e-15);                 }             }         }     }      private static class EuclideanDistance implements MultivariateDifferentiableFunction {          @Override         public double value(double[] point) {             double d2 = 0;             for (double x : point) {                 d2 += x * x;             }             return FastMath.sqrt(d2);         }          @Override         public DerivativeStructure value(DerivativeStructure[] point)             throws DimensionMismatchException, MathIllegalArgumentException {             DerivativeStructure d2 = point[0].getField().getZero();             for (DerivativeStructure x : point) {                 d2 = d2.add(x.multiply(x));             }             return d2.sqrt();         }          public double[] gradient(double[] point) {             double[] gradient = new double[point.length];             double d = value(point);             for (int i = 0; i < point.length; ++i) {                 gradient[i] = point[i] / d;             }             return gradient;         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.differentiation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test for class {@link JacobianFunction}.  */ public class JacobianFunctionTest {      @Test     public void testSphere() {         SphereMapping    f = new SphereMapping(10.0);         JacobianFunction j = new JacobianFunction(f);         for (double latitude = -1.5; latitude < 1.5; latitude += 0.1) {             for (double longitude = -3.1; longitude < 3.1; longitude += 0.1) {                 double[] point = new double[] { latitude, longitude };                 double[][] referenceJacobian  = f.jacobian(point);                 double[][] testJacobian       = j.value(point);                 Assert.assertEquals(referenceJacobian.length, testJacobian.length);                 for (int i = 0; i < 3; ++i) {                     TestUtils.assertEquals(referenceJacobian[i], testJacobian[i], 2.0e-15);                 }             }         }     }      /* Maps (latitude, longitude) to (x, y, z) */     private static class SphereMapping implements MultivariateDifferentiableVectorFunction {          private final double radius;          public SphereMapping(final double radius) {             this.radius = radius;         }          @Override         public double[] value(double[] point) {             final double cLat = FastMath.cos(point[0]);             final double sLat = FastMath.sin(point[0]);             final double cLon = FastMath.cos(point[1]);             final double sLon = FastMath.sin(point[1]);             return new double[] {                 radius * cLon * cLat,                 radius * sLon * cLat,                 radius * sLat             };         }          @Override         public DerivativeStructure[] value(DerivativeStructure[] point) {             final DerivativeStructure cLat = point[0].cos();             final DerivativeStructure sLat = point[0].sin();             final DerivativeStructure cLon = point[1].cos();             final DerivativeStructure sLon = point[1].sin();             return new DerivativeStructure[] {                 cLon.multiply(cLat).multiply(radius),                 sLon.multiply(cLat).multiply(radius),                 sLat.multiply(radius)             };         }          public double[][] jacobian(double[] point) {             final double cLat = FastMath.cos(point[0]);             final double sLat = FastMath.sin(point[0]);             final double cLon = FastMath.cos(point[1]);             final double sLon = FastMath.sin(point[1]);             return new double[][] {                 { -radius * cLon * sLat, -radius * sLon * cLat },                 { -radius * sLon * sLat,  radius * cLon * cLat },                 {  radius * cLat,         0  }             };         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.differentiation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.UnivariateMatrixFunction; import org.apache.commons.math4.analysis.UnivariateVectorFunction; import org.apache.commons.math4.analysis.function.Gaussian; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.MathInternalError; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link FiniteDifferencesDifferentiator}.  */ public class FiniteDifferencesDifferentiatorTest {      @Test(expected=NumberIsTooSmallException.class)     public void testWrongNumberOfPoints() {         new FiniteDifferencesDifferentiator(1, 1.0);     }      @Test(expected=NotPositiveException.class)     public void testWrongStepSize() {         new FiniteDifferencesDifferentiator(3, 0.0);     }      @Test     public void testSerialization() {         FiniteDifferencesDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(3, 1.0e-3);         FiniteDifferencesDifferentiator recovered =                 (FiniteDifferencesDifferentiator) TestUtils.serializeAndRecover(differentiator);         Assert.assertEquals(differentiator.getNbPoints(), recovered.getNbPoints());         Assert.assertEquals(differentiator.getStepSize(), recovered.getStepSize(), 1.0e-15);     }      @Test     public void testConstant() {         FiniteDifferencesDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(5, 0.01);         UnivariateDifferentiableFunction f =                 differentiator.differentiate(new UnivariateFunction() {                     @Override                     public double value(double x) {                         return 42.0;                     }                 });         for (double x = -10; x < 10; x += 0.1) {             DerivativeStructure y = f.value(new DerivativeStructure(1, 2, 0, x));             Assert.assertEquals(42.0, y.getValue(), 1.0e-15);             Assert.assertEquals( 0.0, y.getPartialDerivative(1), 1.0e-15);             Assert.assertEquals( 0.0, y.getPartialDerivative(2), 1.0e-15);         }     }      @Test     public void testLinear() {         FiniteDifferencesDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(5, 0.01);         UnivariateDifferentiableFunction f =                 differentiator.differentiate(new UnivariateFunction() {                     @Override                     public double value(double x) {                         return 2 - 3 * x;                     }                 });         for (double x = -10; x < 10; x += 0.1) {             DerivativeStructure y = f.value(new DerivativeStructure(1, 2, 0, x));             Assert.assertEquals("" + (2 - 3 * x - y.getValue()), 2 - 3 * x, y.getValue(), 2.0e-15);             Assert.assertEquals(-3.0, y.getPartialDerivative(1), 4.0e-13);             Assert.assertEquals( 0.0, y.getPartialDerivative(2), 9.0e-11);         }     }      @Test     public void testGaussian() {         FiniteDifferencesDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(9, 0.02);         UnivariateDifferentiableFunction gaussian = new Gaussian(1.0, 2.0);         UnivariateDifferentiableFunction f =                 differentiator.differentiate(gaussian);         double[] expectedError = new double[] {             6.939e-18, 1.284e-15, 2.477e-13, 1.168e-11, 2.840e-9, 7.971e-8         };        double[] maxError = new double[expectedError.length];         for (double x = -10; x < 10; x += 0.1) {             DerivativeStructure dsX  = new DerivativeStructure(1, maxError.length - 1, 0, x);             DerivativeStructure yRef = gaussian.value(dsX);             DerivativeStructure y    = f.value(dsX);             Assert.assertEquals(f.value(dsX.getValue()), f.value(dsX).getValue(), 1.0e-15);             for (int order = 0; order <= yRef.getOrder(); ++order) {                 maxError[order] = FastMath.max(maxError[order],                                         FastMath.abs(yRef.getPartialDerivative(order) -                                                      y.getPartialDerivative(order)));             }         }         for (int i = 0; i < maxError.length; ++i) {             Assert.assertEquals(expectedError[i], maxError[i], 0.01 * expectedError[i]);         }     }      @Test     public void testStepSizeUnstability() {         UnivariateDifferentiableFunction quintic = new QuinticFunction();         UnivariateDifferentiableFunction goodStep =                 new FiniteDifferencesDifferentiator(7, 0.25).differentiate(quintic);         UnivariateDifferentiableFunction badStep =                 new FiniteDifferencesDifferentiator(7, 1.0e-6).differentiate(quintic);         double[] maxErrorGood = new double[7];         double[] maxErrorBad  = new double[7];         for (double x = -10; x < 10; x += 0.1) {             DerivativeStructure dsX  = new DerivativeStructure(1, 6, 0, x);             DerivativeStructure yRef  = quintic.value(dsX);             DerivativeStructure yGood = goodStep.value(dsX);             DerivativeStructure yBad  = badStep.value(dsX);             for (int order = 0; order <= 6; ++order) {                 maxErrorGood[order] = FastMath.max(maxErrorGood[order],                                                    FastMath.abs(yRef.getPartialDerivative(order) -                                                                 yGood.getPartialDerivative(order)));                 maxErrorBad[order]  = FastMath.max(maxErrorBad[order],                                                    FastMath.abs(yRef.getPartialDerivative(order) -                                                                 yBad.getPartialDerivative(order)));             }         }          // the 0.25 step size is good for finite differences in the quintic on this abscissa range for 7 points         // the errors are fair         final double[] expectedGood = new double[] {             7.276e-12, 7.276e-11, 9.968e-10, 3.092e-9, 5.432e-8, 8.196e-8, 1.818e-6         };          // the 1.0e-6 step size is far too small for finite differences in the quintic on this abscissa range for 7 points         // the errors are huge!         final double[] expectedBad = new double[] {             2.910e-11, 2.087e-5, 147.7, 3.820e7, 6.354e14, 6.548e19, 1.543e27         };          for (int i = 0; i < maxErrorGood.length; ++i) {             Assert.assertEquals(expectedGood[i], maxErrorGood[i], 0.01 * expectedGood[i]);             Assert.assertEquals(expectedBad[i],  maxErrorBad[i],  0.01 * expectedBad[i]);         }      }      @Test(expected=NumberIsTooLargeException.class)     public void testWrongOrder() {         UnivariateDifferentiableFunction f =                 new FiniteDifferencesDifferentiator(3, 0.01).differentiate(new UnivariateFunction() {                     @Override                     public double value(double x) {                         // this exception should not be thrown because wrong order                         // should be detected before function call                         throw new MathInternalError();                     }                 });         f.value(new DerivativeStructure(1, 3, 0, 1.0));     }      @Test(expected=NumberIsTooLargeException.class)     public void testWrongOrderVector() {         UnivariateDifferentiableVectorFunction f =                 new FiniteDifferencesDifferentiator(3, 0.01).differentiate(new UnivariateVectorFunction() {                     @Override                     public double[] value(double x) {                         // this exception should not be thrown because wrong order                         // should be detected before function call                         throw new MathInternalError();                     }                 });         f.value(new DerivativeStructure(1, 3, 0, 1.0));     }      @Test(expected=NumberIsTooLargeException.class)     public void testWrongOrderMatrix() {         UnivariateDifferentiableMatrixFunction f =                 new FiniteDifferencesDifferentiator(3, 0.01).differentiate(new UnivariateMatrixFunction() {                     @Override                     public double[][] value(double x) {                         // this exception should not be thrown because wrong order                         // should be detected before function call                         throw new MathInternalError();                     }                 });         f.value(new DerivativeStructure(1, 3, 0, 1.0));     }      @Test(expected=NumberIsTooLargeException.class)     public void testTooLargeStep() {         new FiniteDifferencesDifferentiator(3, 2.5, 0.0, 1.0);     }      @Test     public void testBounds() {          final double slope = 2.5;         UnivariateFunction f = new UnivariateFunction() {             @Override             public double value(double x) {                 if (x < 0) {                     throw new NumberIsTooSmallException(x, 0, true);                 } else if (x > 1) {                     throw new NumberIsTooLargeException(x, 1, true);                 } else {                     return slope * x;                 }             }         };          UnivariateDifferentiableFunction missingBounds =                 new FiniteDifferencesDifferentiator(3, 0.1).differentiate(f);         UnivariateDifferentiableFunction properlyBounded =                 new FiniteDifferencesDifferentiator(3, 0.1, 0.0, 1.0).differentiate(f);         DerivativeStructure tLow  = new DerivativeStructure(1, 1, 0, 0.05);         DerivativeStructure tHigh = new DerivativeStructure(1, 1, 0, 0.95);          try {             // here, we did not set the bounds, so the differences are evaluated out of domain             // using f(-0.05), f(0.05), f(0.15)             missingBounds.value(tLow);             Assert.fail("an exception should have been thrown");         } catch (NumberIsTooSmallException nse) {             Assert.assertEquals(-0.05, nse.getArgument().doubleValue(), 1.0e-10);         } catch (Exception e) {             Assert.fail("wrong exception caught: " + e.getClass().getName());         }          try {             // here, we did not set the bounds, so the differences are evaluated out of domain             // using f(0.85), f(0.95), f(1.05)             missingBounds.value(tHigh);             Assert.fail("an exception should have been thrown");         } catch (NumberIsTooLargeException nle) {             Assert.assertEquals(1.05, nle.getArgument().doubleValue(), 1.0e-10);         } catch (Exception e) {             Assert.fail("wrong exception caught: " + e.getClass().getName());         }          // here, we did set the bounds, so evaluations are done within domain         // using f(0.0), f(0.1), f(0.2)         Assert.assertEquals(slope, properlyBounded.value(tLow).getPartialDerivative(1), 1.0e-10);          // here, we did set the bounds, so evaluations are done within domain         // using f(0.8), f(0.9), f(1.0)         Assert.assertEquals(slope, properlyBounded.value(tHigh).getPartialDerivative(1), 1.0e-10);      }      @Test     public void testBoundedSqrt() {          UnivariateFunctionDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(9, 1.0 / 32, 0.0, Double.POSITIVE_INFINITY);         UnivariateDifferentiableFunction sqrt = differentiator.differentiate(new UnivariateFunction() {             @Override             public double value(double x) {                 return FastMath.sqrt(x);             }         });          // we are able to compute derivative near 0, but the accuracy is much poorer there         DerivativeStructure t001 = new DerivativeStructure(1, 1, 0, 0.01);         Assert.assertEquals(0.5 / FastMath.sqrt(t001.getValue()), sqrt.value(t001).getPartialDerivative(1), 1.6);         DerivativeStructure t01 = new DerivativeStructure(1, 1, 0, 0.1);         Assert.assertEquals(0.5 / FastMath.sqrt(t01.getValue()), sqrt.value(t01).getPartialDerivative(1), 7.0e-3);         DerivativeStructure t03 = new DerivativeStructure(1, 1, 0, 0.3);         Assert.assertEquals(0.5 / FastMath.sqrt(t03.getValue()), sqrt.value(t03).getPartialDerivative(1), 2.1e-7);      }      @Test     public void testVectorFunction() {          FiniteDifferencesDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(7, 0.01);         UnivariateDifferentiableVectorFunction f =                 differentiator.differentiate(new UnivariateVectorFunction() {              @Override             public double[] value(double x) {                 return new double[] { FastMath.cos(x), FastMath.sin(x) };             }          });          for (double x = -10; x < 10; x += 0.1) {             DerivativeStructure dsX = new DerivativeStructure(1, 2, 0, x);             DerivativeStructure[] y = f.value(dsX);             double cos = FastMath.cos(x);             double sin = FastMath.sin(x);             double[] f1 = f.value(dsX.getValue());             DerivativeStructure[] f2 = f.value(dsX);             Assert.assertEquals(f1.length, f2.length);             for (int i = 0; i < f1.length; ++i) {                 Assert.assertEquals(f1[i], f2[i].getValue(), 1.0e-15);             }             Assert.assertEquals( cos, y[0].getValue(), 7.0e-16);             Assert.assertEquals( sin, y[1].getValue(), 7.0e-16);             Assert.assertEquals(-sin, y[0].getPartialDerivative(1), 6.0e-14);             Assert.assertEquals( cos, y[1].getPartialDerivative(1), 6.0e-14);             Assert.assertEquals(-cos, y[0].getPartialDerivative(2), 2.0e-11);             Assert.assertEquals(-sin, y[1].getPartialDerivative(2), 2.0e-11);         }      }      @Test     public void testMatrixFunction() {          FiniteDifferencesDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(7, 0.01);         UnivariateDifferentiableMatrixFunction f =                 differentiator.differentiate(new UnivariateMatrixFunction() {              @Override             public double[][] value(double x) {                 return new double[][] {                     { FastMath.cos(x),  FastMath.sin(x)  },                     { FastMath.cosh(x), FastMath.sinh(x) }                 };             }          });          for (double x = -1; x < 1; x += 0.02) {             DerivativeStructure dsX = new DerivativeStructure(1, 2, 0, x);             DerivativeStructure[][] y = f.value(dsX);             double cos = FastMath.cos(x);             double sin = FastMath.sin(x);             double cosh = FastMath.cosh(x);             double sinh = FastMath.sinh(x);             double[][] f1 = f.value(dsX.getValue());             DerivativeStructure[][] f2 = f.value(dsX);             Assert.assertEquals(f1.length, f2.length);             for (int i = 0; i < f1.length; ++i) {                 Assert.assertEquals(f1[i].length, f2[i].length);                 for (int j = 0; j < f1[i].length; ++j) {                     Assert.assertEquals(f1[i][j], f2[i][j].getValue(), 1.0e-15);                 }             }             Assert.assertEquals(cos,   y[0][0].getValue(), 7.0e-18);             Assert.assertEquals(sin,   y[0][1].getValue(), 6.0e-17);             Assert.assertEquals(cosh,  y[1][0].getValue(), 3.0e-16);             Assert.assertEquals(sinh,  y[1][1].getValue(), 3.0e-16);             Assert.assertEquals(-sin,  y[0][0].getPartialDerivative(1), 2.0e-14);             Assert.assertEquals( cos,  y[0][1].getPartialDerivative(1), 2.0e-14);             Assert.assertEquals( sinh, y[1][0].getPartialDerivative(1), 3.0e-14);             Assert.assertEquals( cosh, y[1][1].getPartialDerivative(1), 3.0e-14);             Assert.assertEquals(-cos,  y[0][0].getPartialDerivative(2), 3.0e-12);             Assert.assertEquals(-sin,  y[0][1].getPartialDerivative(2), 3.0e-12);             Assert.assertEquals( cosh, y[1][0].getPartialDerivative(2), 6.0e-12);             Assert.assertEquals( sinh, y[1][1].getPartialDerivative(2), 6.0e-12);         }      }      @Test     public void testSeveralFreeParameters() {         FiniteDifferencesDifferentiator differentiator =                 new FiniteDifferencesDifferentiator(5, 0.001);         UnivariateDifferentiableFunction sine = new Sin();         UnivariateDifferentiableFunction f =                 differentiator.differentiate(sine);         double[] expectedError = new double[] {             6.696e-16, 1.371e-12, 2.007e-8, 1.754e-5         };         double[] maxError = new double[expectedError.length];        for (double x = -2; x < 2; x += 0.1) {            for (double y = -2; y < 2; y += 0.1) {                DerivativeStructure dsX  = new DerivativeStructure(2, maxError.length - 1, 0, x);                DerivativeStructure dsY  = new DerivativeStructure(2, maxError.length - 1, 1, y);                DerivativeStructure dsT  = dsX.multiply(3).subtract(dsY.multiply(2));                DerivativeStructure sRef = sine.value(dsT);                DerivativeStructure s    = f.value(dsT);                for (int xOrder = 0; xOrder <= sRef.getOrder(); ++xOrder) {                    for (int yOrder = 0; yOrder <= sRef.getOrder(); ++yOrder) {                        if (xOrder + yOrder <= sRef.getOrder()) {                            maxError[xOrder +yOrder] = FastMath.max(maxError[xOrder + yOrder],                                                                     FastMath.abs(sRef.getPartialDerivative(xOrder, yOrder) -                                                                                  s.getPartialDerivative(xOrder, yOrder)));                        }                    }                }            }        }        for (int i = 0; i < maxError.length; ++i) {            Assert.assertEquals(expectedError[i], maxError[i], 0.01 * expectedError[i]);        }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.differentiation;  import java.util.Arrays; import java.util.List;  import org.apache.commons.math4.ExtendedFieldElementAbstractTest; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class SparseGradientTest extends ExtendedFieldElementAbstractTest<SparseGradient> {      @Override     protected SparseGradient build(final double x) {         return SparseGradient.createVariable(0, x);     }      @Test     public void testConstant() {         double c = 1.0;         SparseGradient grad = SparseGradient.createConstant(c);         Assert.assertEquals(c, grad.getValue(), 1.0e-15); // returns the value         Assert.assertEquals(0, grad.numVars(), 1.0e-15); // has no variables     }      @Test     public void testVariable() {         double v = 1.0;         int id = 0;         SparseGradient grad = SparseGradient.createVariable(id, v);         Assert.assertEquals(v, grad.getValue(), 1.0e-15); // returns the value         Assert.assertEquals(1, grad.numVars(), 1.0e-15); // has one variable         Assert.assertEquals(1.0, grad.getDerivative(id), 1.0e-15); // derivative wr.t itself is 1     }      @Test     public void testVarAddition() {         final double v1 = 1.0;         final double v2 = 2.0;         final int id1 = -1;         final int id2 = 3;         final SparseGradient var1 = SparseGradient.createVariable(id1, v1);         final SparseGradient var2 = SparseGradient.createVariable(id2, v2);         final SparseGradient sum = var1.add(var2);          Assert.assertEquals(v1 + v2, sum.getValue(), 1.0e-15); // returns the value         Assert.assertEquals(2, sum.numVars());         Assert.assertEquals(1.0, sum.getDerivative(id1), 1.0e-15);         Assert.assertEquals(1.0, sum.getDerivative(id2), 1.0e-15);     }      @Test     public void testSubtraction() {         final double v1 = 1.0;         final double v2 = 2.0;         final int id1 = -1;         final int id2 = 3;         final SparseGradient var1 = SparseGradient.createVariable(id1, v1);         final SparseGradient var2 = SparseGradient.createVariable(id2, v2);         final SparseGradient sum = var1.subtract(var2);          Assert.assertEquals(v1 - v2, sum.getValue(), 1.0e-15); // returns the value         Assert.assertEquals(2, sum.numVars());         Assert.assertEquals(1.0, sum.getDerivative(id1), 1.0e-15);         Assert.assertEquals(-1.0, sum.getDerivative(id2), 1.0e-15);     }      @Test     public void testDivision() {         final double v1 = 1.0;         final double v2 = 2.0;         final int id1 = -1;         final int id2 = 3;         final SparseGradient var1 = SparseGradient.createVariable(id1, v1);         final SparseGradient var2 = SparseGradient.createVariable(id2, v2);         final SparseGradient out = var1.divide(var2);         Assert.assertEquals(v1 / v2, out.getValue(), 1.0e-15); // returns the value         Assert.assertEquals(2, out.numVars());         Assert.assertEquals(1 / v2, out.getDerivative(id1), 1.0e-15);         Assert.assertEquals(-1 / (v2 * v2), out.getDerivative(id2), 1.0e-15);     }      @Test     public void testMult() {         final double v1 = 1.0;         final double c1 = 0.5;         final double v2 = 2.0;         final int id1 = -1;         final int id2 = 3;         final SparseGradient var1 = SparseGradient.createVariable(id1, v1);         final SparseGradient unit1 = var1.multiply(c1);         final SparseGradient unit2 = SparseGradient.createVariable(id2, v2).multiply(var1);         final SparseGradient sum = unit1.add(unit2);         Assert.assertEquals(v1 * c1 + v2 * v1, sum.getValue(), 1.0e-15); // returns the value         Assert.assertEquals(2, sum.numVars());         Assert.assertEquals(c1 + v2, sum.getDerivative(id1), 1.0e-15);         Assert.assertEquals(v1, sum.getDerivative(id2), 1.0e-15);     }      @Test     public void testVarMultInPlace() {         final double v1 = 1.0;         final double c1 = 0.5;         final double v2 = 2.0;         final int id1 = -1;         final int id2 = 3;         final SparseGradient var1 = SparseGradient.createVariable(id1, v1);         final SparseGradient sum = var1.multiply(c1);         final SparseGradient mult = SparseGradient.createVariable(id2, v2);         mult.multiplyInPlace(var1);         sum.addInPlace(mult);         Assert.assertEquals(v1 * c1 + v2 * v1, sum.getValue(), 1.0e-15); // returns the value         Assert.assertEquals(2, sum.numVars());         Assert.assertEquals(c1 + v2, sum.getDerivative(id1), 1.0e-15);         Assert.assertEquals(v1, sum.getDerivative(id2), 1.0e-15);     }      @Test     public void testPrimitiveAdd() {         checkF0F1(SparseGradient.createVariable(0, 1.0).add(5), 6.0, 1.0, 0.0, 0.0);         checkF0F1(SparseGradient.createVariable(1, 2.0).add(5), 7.0, 0.0, 1.0, 0.0);         checkF0F1(SparseGradient.createVariable(2, 3.0).add(5), 8.0, 0.0, 0.0, 1.0);     }      @Test     public void testAdd() {         SparseGradient x = SparseGradient.createVariable(0, 1.0);         SparseGradient y = SparseGradient.createVariable(1, 2.0);         SparseGradient z = SparseGradient.createVariable(2, 3.0);         SparseGradient xyz = x.add(y.add(z));         checkF0F1(xyz, x.getValue() + y.getValue() + z.getValue(), 1.0, 1.0, 1.0);     }      @Test     public void testPrimitiveSubtract() {         checkF0F1(SparseGradient.createVariable(0, 1.0).subtract(5), -4.0, 1.0, 0.0, 0.0);         checkF0F1(SparseGradient.createVariable(1, 2.0).subtract(5), -3.0, 0.0, 1.0, 0.0);         checkF0F1(SparseGradient.createVariable(2, 3.0).subtract(5), -2.0, 0.0, 0.0, 1.0);     }      @Test     public void testSubtract() {         SparseGradient x = SparseGradient.createVariable(0, 1.0);         SparseGradient y = SparseGradient.createVariable(1, 2.0);         SparseGradient z = SparseGradient.createVariable(2, 3.0);         SparseGradient xyz = x.subtract(y.subtract(z));         checkF0F1(xyz, x.getValue() - (y.getValue() - z.getValue()), 1.0, -1.0, 1.0);     }      @Test     public void testPrimitiveMultiply() {         checkF0F1(SparseGradient.createVariable(0, 1.0).multiply(5),  5.0, 5.0, 0.0, 0.0);         checkF0F1(SparseGradient.createVariable(1, 2.0).multiply(5), 10.0, 0.0, 5.0, 0.0);         checkF0F1(SparseGradient.createVariable(2, 3.0).multiply(5), 15.0, 0.0, 0.0, 5.0);     }      @Test     public void testMultiply() {         SparseGradient x = SparseGradient.createVariable(0, 1.0);         SparseGradient y = SparseGradient.createVariable(1, 2.0);         SparseGradient z = SparseGradient.createVariable(2, 3.0);         SparseGradient xyz = x.multiply(y.multiply(z));         checkF0F1(xyz, 6.0, 6.0, 3.0, 2.0);     }      @Test     public void testNegate() {         checkF0F1(SparseGradient.createVariable(0, 1.0).negate(), -1.0, -1.0, 0.0, 0.0);         checkF0F1(SparseGradient.createVariable(1, 2.0).negate(), -2.0, 0.0, -1.0, 0.0);         checkF0F1(SparseGradient.createVariable(2, 3.0).negate(), -3.0, 0.0, 0.0, -1.0);     }      @Test     public void testReciprocal() {         for (double x = 0.1; x < 1.2; x += 0.1) {             SparseGradient r = SparseGradient.createVariable(0, x).reciprocal();             Assert.assertEquals(1 / x, r.getValue(), 1.0e-15);             final double expected = -1 / (x * x);             Assert.assertEquals(expected, r.getDerivative(0), 1.0e-15 * FastMath.abs(expected));         }     }      @Test     public void testPow() {         for (int n = 0; n < 10; ++n) {              SparseGradient x = SparseGradient.createVariable(0, 1.0);             SparseGradient y = SparseGradient.createVariable(1, 2.0);             SparseGradient z = SparseGradient.createVariable(2, 3.0);             List<SparseGradient> list = Arrays.asList(x, y, z,                                                       x.add(y).add(z),                                                       x.multiply(y).multiply(z));              if (n == 0) {                 for (SparseGradient sg : list) {                     Assert.assertEquals(sg.getField().getOne(), sg.pow(n));                 }             } else if (n == 1) {                 for (SparseGradient sg : list) {                     Assert.assertEquals(sg, sg.pow(n));                 }             } else {                 for (SparseGradient sg : list) {                     SparseGradient p = sg.getField().getOne();                     for (int i = 0; i < n; ++i) {                         p = p.multiply(sg);                     }                     Assert.assertEquals(p, sg.pow(n));                 }             }         }     }      @Test     public void testPowDoubleDS() {         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {              SparseGradient x = SparseGradient.createVariable(0, 0.1);             SparseGradient y = SparseGradient.createVariable(1, 0.2);             SparseGradient z = SparseGradient.createVariable(2, 0.3);             List<SparseGradient> list = Arrays.asList(x, y, z,                                                       x.add(y).add(z),                                                       x.multiply(y).multiply(z));              for (SparseGradient sg : list) {                 // the special case a = 0 is included here                 for (double a : new double[] { 0.0, 0.1, 1.0, 2.0, 5.0 }) {                     SparseGradient reference = (a == 0) ?                                                x.getField().getZero() :                                                SparseGradient.createConstant(a).pow(sg);                     SparseGradient result = SparseGradient.pow(a, sg);                     Assert.assertEquals(reference, result);                 }              }              // negative base: -1^x can be evaluated for integers only, so value is sometimes OK, derivatives are always NaN             SparseGradient negEvenInteger = SparseGradient.pow(-2.0, SparseGradient.createVariable(0, 2.0));             Assert.assertEquals(4.0, negEvenInteger.getValue(), 1.0e-15);             Assert.assertTrue(Double.isNaN(negEvenInteger.getDerivative(0)));             SparseGradient negOddInteger = SparseGradient.pow(-2.0, SparseGradient.createVariable(0, 3.0));             Assert.assertEquals(-8.0, negOddInteger.getValue(), 1.0e-15);             Assert.assertTrue(Double.isNaN(negOddInteger.getDerivative(0)));             SparseGradient negNonInteger = SparseGradient.pow(-2.0, SparseGradient.createVariable(0, 2.001));             Assert.assertTrue(Double.isNaN(negNonInteger.getValue()));             Assert.assertTrue(Double.isNaN(negNonInteger.getDerivative(0)));              SparseGradient zeroNeg = SparseGradient.pow(0.0, SparseGradient.createVariable(0, -1.0));             Assert.assertTrue(Double.isNaN(zeroNeg.getValue()));             Assert.assertTrue(Double.isNaN(zeroNeg.getDerivative(0)));             SparseGradient posNeg = SparseGradient.pow(2.0, SparseGradient.createVariable(0, -2.0));             Assert.assertEquals(1.0 / 4.0, posNeg.getValue(), 1.0e-15);             Assert.assertEquals(FastMath.log(2.0) / 4.0, posNeg.getDerivative(0), 1.0e-15);              // very special case: a = 0 and power = 0             SparseGradient zeroZero = SparseGradient.pow(0.0, SparseGradient.createVariable(0, 0.0));              // this should be OK for simple first derivative with one variable only ...             Assert.assertEquals(1.0, zeroZero.getValue(), 1.0e-15);             Assert.assertEquals(Double.NEGATIVE_INFINITY, zeroZero.getDerivative(0), 1.0e-15);             Assert.assertEquals(0.0, zeroZero.getDerivative(1), 1.0e-15);             Assert.assertEquals(0.0, zeroZero.getDerivative(2), 1.0e-15);          }      }      @Test     public void testExpression() {         double epsilon = 2.5e-13;         for (double x = 0; x < 2; x += 0.2) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = 0; y < 2; y += 0.2) {                 SparseGradient sgY = SparseGradient.createVariable(1, y);                 for (double z = 0; z >- 2; z -= 0.2) {                     SparseGradient sgZ = SparseGradient.createVariable(2, z);                      // f(x, y, z) = x + 5 x y - 2 z + (8 z x - y)^3                     SparseGradient sg =                             sgZ.linearCombination(1, sgX,                                                   5, sgX.multiply(sgY),                                                  -2, sgZ,                                                  1, sgZ.linearCombination(8, sgZ.multiply(sgX), -1, sgY).pow(3));                     double f = x + 5 * x * y - 2 * z + FastMath.pow(8 * z * x - y, 3);                     Assert.assertEquals(f, sg.getValue(), FastMath.abs(epsilon * f));                      // df/dx = 1 + 5 y + 24 (8 z x - y)^2 z                     double dfdx = 1 + 5 * y + 24 * z * FastMath.pow(8 * z * x - y, 2);                     Assert.assertEquals(dfdx, sg.getDerivative(0), FastMath.abs(epsilon * dfdx));                  }              }         }     }      @Test     public void testCompositionOneVariableX() {         double epsilon = 1.0e-13;         for (double x = 0.1; x < 1.2; x += 0.1) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = 0.1; y < 1.2; y += 0.1) {                 SparseGradient sgY = SparseGradient.createConstant(y);                 SparseGradient f = sgX.divide(sgY).sqrt();                 double f0 = FastMath.sqrt(x / y);                 Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));                 double f1 = 1 / (2 * FastMath.sqrt(x * y));                 Assert.assertEquals(f1, f.getDerivative(0), FastMath.abs(epsilon * f1));             }         }     }      @Test     public void testTrigo() {         double epsilon = 2.0e-12;             for (double x = 0.1; x < 1.2; x += 0.1) {                 SparseGradient sgX = SparseGradient.createVariable(0, x);                 for (double y = 0.1; y < 1.2; y += 0.1) {                     SparseGradient sgY = SparseGradient.createVariable(1, y);                     for (double z = 0.1; z < 1.2; z += 0.1) {                         SparseGradient sgZ = SparseGradient.createVariable(2, z);                         SparseGradient f = sgX.divide(sgY.cos().add(sgZ.tan())).sin();                         double a = FastMath.cos(y) + FastMath.tan(z);                         double f0 = FastMath.sin(x / a);                         Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));                         double dfdx = FastMath.cos(x / a) / a;                         Assert.assertEquals(dfdx, f.getDerivative(0), FastMath.abs(epsilon * dfdx));                         double dfdy =  x * FastMath.sin(y) * dfdx / a;                         Assert.assertEquals(dfdy, f.getDerivative(1), FastMath.abs(epsilon * dfdy));                         double cz = FastMath.cos(z);                         double cz2 = cz * cz;                         double dfdz = -x * dfdx / (a * cz2);                         Assert.assertEquals(dfdz, f.getDerivative(2), FastMath.abs(epsilon * dfdz));                     }                 }             }     }      @Test     public void testSqrtDefinition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient sqrt1 = sgX.pow(0.5);             SparseGradient sqrt2 = sgX.sqrt();             SparseGradient zero = sqrt1.subtract(sqrt2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testRootNSingularity() {         for (int n = 2; n < 10; ++n) {             SparseGradient sgZero = SparseGradient.createVariable(0, 0.0);             SparseGradient rootN  = sgZero.rootN(n);             Assert.assertEquals(0.0, rootN.getValue(), 1.0e-5);             Assert.assertTrue(Double.isInfinite(rootN.getDerivative(0)));             Assert.assertTrue(rootN.getDerivative(0) > 0);         }      }      @Test     public void testSqrtPow2() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.multiply(sgX).sqrt();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testCbrtDefinition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient cbrt1 = sgX.pow(1.0 / 3.0);             SparseGradient cbrt2 = sgX.cbrt();             SparseGradient zero = cbrt1.subtract(cbrt2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testCbrtPow3() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.multiply(sgX.multiply(sgX)).cbrt();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testPowReciprocalPow() {         for (double x = 0.1; x < 1.2; x += 0.01) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = 0.1; y < 1.2; y += 0.01) {                 SparseGradient sgY = SparseGradient.createVariable(1, y);                 SparseGradient rebuiltX = sgX.pow(sgY).pow(sgY.reciprocal());                 SparseGradient zero = rebuiltX.subtract(sgX);                 checkF0F1(zero, 0.0, 0.0, 0.0);             }         }     }      @Test     public void testHypotDefinition() {         for (double x = -1.7; x < 2; x += 0.2) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = -1.7; y < 2; y += 0.2) {                 SparseGradient sgY = SparseGradient.createVariable(1, y);                 SparseGradient hypot = SparseGradient.hypot(sgY, sgX);                 SparseGradient ref = sgX.multiply(sgX).add(sgY.multiply(sgY)).sqrt();                 SparseGradient zero = hypot.subtract(ref);                 checkF0F1(zero, 0.0, 0.0, 0.0);              }         }     }      @Test     public void testHypotNoOverflow() {          SparseGradient sgX = SparseGradient.createVariable(0, +3.0e250);         SparseGradient sgY = SparseGradient.createVariable(1, -4.0e250);         SparseGradient hypot = SparseGradient.hypot(sgX, sgY);         Assert.assertEquals(5.0e250, hypot.getValue(), 1.0e235);         Assert.assertEquals(sgX.getValue() / hypot.getValue(), hypot.getDerivative(0), 1.0e-10);         Assert.assertEquals(sgY.getValue() / hypot.getValue(), hypot.getDerivative(1), 1.0e-10);          SparseGradient sqrt  = sgX.multiply(sgX).add(sgY.multiply(sgY)).sqrt();         Assert.assertTrue(Double.isInfinite(sqrt.getValue()));      }      @Test     public void testHypotNeglectible() {          SparseGradient sgSmall = SparseGradient.createVariable(0, +3.0e-10);         SparseGradient sgLarge = SparseGradient.createVariable(1, -4.0e25);          Assert.assertEquals(sgLarge.abs().getValue(),                             SparseGradient.hypot(sgSmall, sgLarge).getValue(),                             1.0e-10);         Assert.assertEquals(0,                             SparseGradient.hypot(sgSmall, sgLarge).getDerivative(0),                             1.0e-10);         Assert.assertEquals(-1,                             SparseGradient.hypot(sgSmall, sgLarge).getDerivative(1),                             1.0e-10);          Assert.assertEquals(sgLarge.abs().getValue(),                             SparseGradient.hypot(sgLarge, sgSmall).getValue(),                             1.0e-10);         Assert.assertEquals(0,                             SparseGradient.hypot(sgLarge, sgSmall).getDerivative(0),                             1.0e-10);         Assert.assertEquals(-1,                             SparseGradient.hypot(sgLarge, sgSmall).getDerivative(1),                             1.0e-10);      }      @Test     public void testHypotSpecial() {         Assert.assertTrue(Double.isNaN(SparseGradient.hypot(SparseGradient.createVariable(0, Double.NaN),                                                                  SparseGradient.createVariable(0, +3.0e250)).getValue()));         Assert.assertTrue(Double.isNaN(SparseGradient.hypot(SparseGradient.createVariable(0, +3.0e250),                                                                  SparseGradient.createVariable(0, Double.NaN)).getValue()));         Assert.assertTrue(Double.isInfinite(SparseGradient.hypot(SparseGradient.createVariable(0, Double.POSITIVE_INFINITY),                                                                       SparseGradient.createVariable(0, +3.0e250)).getValue()));         Assert.assertTrue(Double.isInfinite(SparseGradient.hypot(SparseGradient.createVariable(0, +3.0e250),                                                                       SparseGradient.createVariable(0, Double.POSITIVE_INFINITY)).getValue()));     }      @Test     public void testPrimitiveRemainder() {         for (double x = -1.7; x < 2; x += 0.2) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = -1.7; y < 2; y += 0.2) {                 SparseGradient remainder = sgX.remainder(y);                 SparseGradient ref = sgX.subtract(x - FastMath.IEEEremainder(x, y));                 SparseGradient zero = remainder.subtract(ref);                 checkF0F1(zero, 0.0, 0.0, 0.0);             }         }     }      @Test     public void testRemainder() {         for (double x = -1.7; x < 2; x += 0.2) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = -1.7; y < 2; y += 0.2) {                 SparseGradient sgY = SparseGradient.createVariable(1, y);                 SparseGradient remainder = sgX.remainder(sgY);                 SparseGradient ref = sgX.subtract(sgY.multiply((x - FastMath.IEEEremainder(x, y)) / y));                 SparseGradient zero = remainder.subtract(ref);                 checkF0F1(zero, 0.0, 0.0, 0.0);             }         }     }      @Override     @Test     public void testExp() {         for (double x = 0.1; x < 1.2; x += 0.001) {             double refExp = FastMath.exp(x);             checkF0F1(SparseGradient.createVariable(0, x).exp(), refExp, refExp);         }     }      @Test     public void testExpm1Definition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient expm11 = sgX.expm1();             SparseGradient expm12 = sgX.exp().subtract(sgX.getField().getOne());             SparseGradient zero = expm11.subtract(expm12);             checkF0F1(zero, 0.0, 0.0);         }     }      @Override     @Test     public void testLog() {         for (double x = 0.1; x < 1.2; x += 0.001) {             checkF0F1(SparseGradient.createVariable(0, x).log(), FastMath.log(x), 1.0 / x);         }     }      @Test     public void testLog1pDefinition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient log1p1 = sgX.log1p();             SparseGradient log1p2 = sgX.add(sgX.getField().getOne()).log();             SparseGradient zero = log1p1.subtract(log1p2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testLog10Definition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient log101 = sgX.log10();             SparseGradient log102 = sgX.log().divide(FastMath.log(10.0));             SparseGradient zero = log101.subtract(log102);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testLogExp() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.exp().log();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testLog1pExpm1() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.expm1().log1p();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testLog10Power() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = SparseGradient.pow(10.0, sgX).log10();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testSinCos() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient sin = sgX.sin();             SparseGradient cos = sgX.cos();             double s = FastMath.sin(x);             double c = FastMath.cos(x);             checkF0F1(sin, s, c);             checkF0F1(cos, c, -s);         }     }      @Test     public void testSinAsin() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.sin().asin();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testCosAcos() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.cos().acos();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testTanAtan() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.tan().atan();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testTangentDefinition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient tan1 = sgX.sin().divide(sgX.cos());             SparseGradient tan2 = sgX.tan();             SparseGradient zero = tan1.subtract(tan2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Override     @Test     public void testAtan2() {         for (double x = -1.7; x < 2; x += 0.2) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = -1.7; y < 2; y += 0.2) {                 SparseGradient sgY = SparseGradient.createVariable(1, y);                 SparseGradient atan2 = SparseGradient.atan2(sgY, sgX);                 SparseGradient ref = sgY.divide(sgX).atan();                 if (x < 0) {                     ref = (y < 0) ? ref.subtract(FastMath.PI) : ref.add(FastMath.PI);                 }                 SparseGradient zero = atan2.subtract(ref);                 checkF0F1(zero, 0.0, 0.0);             }         }     }      @Test     public void testAtan2SpecialCases() {          SparseGradient pp =                 SparseGradient.atan2(SparseGradient.createVariable(1, +0.0),                                           SparseGradient.createVariable(1, +0.0));         Assert.assertEquals(0, pp.getValue(), 1.0e-15);         Assert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15);          SparseGradient pn =                 SparseGradient.atan2(SparseGradient.createVariable(1, +0.0),                                           SparseGradient.createVariable(1, -0.0));         Assert.assertEquals(FastMath.PI, pn.getValue(), 1.0e-15);          SparseGradient np =                 SparseGradient.atan2(SparseGradient.createVariable(1, -0.0),                                           SparseGradient.createVariable(1, +0.0));         Assert.assertEquals(0, np.getValue(), 1.0e-15);         Assert.assertEquals(-1, FastMath.copySign(1, np.getValue()), 1.0e-15);          SparseGradient nn =                 SparseGradient.atan2(SparseGradient.createVariable(1, -0.0),                                           SparseGradient.createVariable(1, -0.0));         Assert.assertEquals(-FastMath.PI, nn.getValue(), 1.0e-15);      }      @Test     public void testSinhDefinition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient sinh1 = sgX.exp().subtract(sgX.exp().reciprocal()).multiply(0.5);             SparseGradient sinh2 = sgX.sinh();             SparseGradient zero = sinh1.subtract(sinh2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testCoshDefinition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient cosh1 = sgX.exp().add(sgX.exp().reciprocal()).multiply(0.5);             SparseGradient cosh2 = sgX.cosh();             SparseGradient zero = cosh1.subtract(cosh2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testTanhDefinition() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient tanh1 = sgX.exp().subtract(sgX.exp().reciprocal()).divide(sgX.exp().add(sgX.exp().reciprocal()));             SparseGradient tanh2 = sgX.tanh();             SparseGradient zero = tanh1.subtract(tanh2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testSinhAsinh() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.sinh().asinh();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testCoshAcosh() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.cosh().acosh();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testTanhAtanh() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.tanh().atanh();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testCompositionOneVariableY() {         for (double x = 0.1; x < 1.2; x += 0.1) {             SparseGradient sgX = SparseGradient.createConstant(x);             for (double y = 0.1; y < 1.2; y += 0.1) {                 SparseGradient sgY = SparseGradient.createVariable(0, y);                 SparseGradient f = sgX.divide(sgY).sqrt();                 double f0 = FastMath.sqrt(x / y);                 double f1 = -x / (2 * y * y * f0);                 checkF0F1(f, f0, f1);             }         }     }      @Test     public void testTaylorPolynomial() {         for (double x = 0; x < 1.2; x += 0.1) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             for (double y = 0; y < 1.2; y += 0.2) {                 SparseGradient sgY = SparseGradient.createVariable(1, y);                 for (double z = 0; z < 1.2; z += 0.2) {                     SparseGradient sgZ = SparseGradient.createVariable(2, z);                     SparseGradient f = sgX.multiply(3).add(sgZ.multiply(-2)).add(sgY.multiply(5));                     for (double dx = -0.2; dx < 0.2; dx += 0.2) {                         for (double dy = -0.2; dy < 0.2; dy += 0.1) {                             for (double dz = -0.2; dz < 0.2; dz += 0.1) {                                 double ref = 3 * (x + dx) + 5 * (y + dy) -2 * (z + dz);                                 Assert.assertEquals(ref, f.taylor(dx, dy, dz), 3.0e-15);                             }                         }                     }                 }             }         }     }      @Test     public void testTaylorAtan2() {         double x0 =  0.1;         double y0 = -0.3;             SparseGradient sgX   = SparseGradient.createVariable(0, x0);             SparseGradient sgY   = SparseGradient.createVariable(1, y0);             SparseGradient atan2 = SparseGradient.atan2(sgY, sgX);             double maxError = 0;             for (double dx = -0.05; dx < 0.05; dx += 0.001) {                 for (double dy = -0.05; dy < 0.05; dy += 0.001) {                     double ref = FastMath.atan2(y0 + dy, x0 + dx);                     maxError = FastMath.max(maxError, FastMath.abs(ref - atan2.taylor(dx, dy)));                 }             }             double expectedError = 0.0241;             Assert.assertEquals(expectedError, maxError, 0.01 * expectedError);     }      @Override     @Test     public void testAbs() {          SparseGradient minusOne = SparseGradient.createVariable(0, -1.0);         Assert.assertEquals(+1.0, minusOne.abs().getValue(), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.abs().getDerivative(0), 1.0e-15);          SparseGradient plusOne = SparseGradient.createVariable(0, +1.0);         Assert.assertEquals(+1.0, plusOne.abs().getValue(), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.abs().getDerivative(0), 1.0e-15);          SparseGradient minusZero = SparseGradient.createVariable(0, -0.0);         Assert.assertEquals(+0.0, minusZero.abs().getValue(), 1.0e-15);         Assert.assertEquals(-1.0, minusZero.abs().getDerivative(0), 1.0e-15);          SparseGradient plusZero = SparseGradient.createVariable(0, +0.0);         Assert.assertEquals(+0.0, plusZero.abs().getValue(), 1.0e-15);         Assert.assertEquals(+1.0, plusZero.abs().getDerivative(0), 1.0e-15);      }      @Override     @Test     public void testSignum() {          SparseGradient minusOne = SparseGradient.createVariable(0, -1.0);         Assert.assertEquals(-1.0, minusOne.signum().getValue(), 1.0e-15);         Assert.assertEquals( 0.0, minusOne.signum().getDerivative(0), 1.0e-15);          SparseGradient plusOne = SparseGradient.createVariable(0, +1.0);         Assert.assertEquals(+1.0, plusOne.signum().getValue(), 1.0e-15);         Assert.assertEquals( 0.0, plusOne.signum().getDerivative(0), 1.0e-15);          SparseGradient minusZero = SparseGradient.createVariable(0, -0.0);         Assert.assertEquals(-0.0, minusZero.signum().getValue(), 1.0e-15);         Assert.assertTrue(Double.doubleToLongBits(minusZero.signum().getValue()) < 0);         Assert.assertEquals( 0.0, minusZero.signum().getDerivative(0), 1.0e-15);          SparseGradient plusZero = SparseGradient.createVariable(0, +0.0);         Assert.assertEquals(+0.0, plusZero.signum().getValue(), 1.0e-15);         Assert.assertTrue(Double.doubleToLongBits(plusZero.signum().getValue()) == 0);         Assert.assertEquals( 0.0, plusZero.signum().getDerivative(0), 1.0e-15);      }      @Test     public void testCeilFloorRintLong() {          SparseGradient x = SparseGradient.createVariable(0, -1.5);         Assert.assertEquals(-1.5, x.getValue(), 1.0e-15);         Assert.assertEquals(+1.0, x.getDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, x.ceil().getValue(), 1.0e-15);         Assert.assertEquals(+0.0, x.ceil().getDerivative(0), 1.0e-15);         Assert.assertEquals(-2.0, x.floor().getValue(), 1.0e-15);         Assert.assertEquals(+0.0, x.floor().getDerivative(0), 1.0e-15);         Assert.assertEquals(-2.0, x.rint().getValue(), 1.0e-15);         Assert.assertEquals(+0.0, x.rint().getDerivative(0), 1.0e-15);         Assert.assertEquals(-2.0, x.subtract(x.getField().getOne()).rint().getValue(), 1.0e-15);         Assert.assertEquals(-1l, x.round(), 1.0e-15);      }      @Test     public void testCopySign() {          SparseGradient minusOne = SparseGradient.createVariable(0, -1.0);         Assert.assertEquals(+1.0, minusOne.copySign(+1.0).getValue(), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(+1.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(-1.0).getValue(), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(-1.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(+0.0).getValue(), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(+0.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(-0.0).getValue(), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(-0.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, minusOne.copySign(Double.NaN).getValue(), 1.0e-15);         Assert.assertEquals(-1.0, minusOne.copySign(Double.NaN).getDerivative(0), 1.0e-15);          SparseGradient plusOne = SparseGradient.createVariable(0, +1.0);         Assert.assertEquals(+1.0, plusOne.copySign(+1.0).getValue(), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(+1.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-1.0).getValue(), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-1.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(+0.0).getValue(), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(+0.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-0.0).getValue(), 1.0e-15);         Assert.assertEquals(-1.0, plusOne.copySign(-0.0).getDerivative(0), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(Double.NaN).getValue(), 1.0e-15);         Assert.assertEquals(+1.0, plusOne.copySign(Double.NaN).getDerivative(0), 1.0e-15);      }      @Test     public void testToDegreesDefinition() {         double epsilon = 3.0e-16;         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 SparseGradient sgX = SparseGradient.createVariable(0, x);                 Assert.assertEquals(FastMath.toDegrees(x), sgX.toDegrees().getValue(), epsilon);                 Assert.assertEquals(180 / FastMath.PI, sgX.toDegrees().getDerivative(0), epsilon);             }         }     }      @Test     public void testToRadiansDefinition() {         double epsilon = 3.0e-16;         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             for (double x = 0.1; x < 1.2; x += 0.001) {                 SparseGradient sgX = SparseGradient.createVariable(0, x);                 Assert.assertEquals(FastMath.toRadians(x), sgX.toRadians().getValue(), epsilon);                 Assert.assertEquals(FastMath.PI / 180, sgX.toRadians().getDerivative(0), epsilon);             }         }     }      @Test     public void testDegRad() {         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient rebuiltX = sgX.toDegrees().toRadians();             SparseGradient zero = rebuiltX.subtract(sgX);             checkF0F1(zero, 0, 0);         }     }      @Test     public void testCompose() {         PolynomialFunction poly =                 new PolynomialFunction(new double[] { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 });         for (double x = 0.1; x < 1.2; x += 0.001) {             SparseGradient sgX = SparseGradient.createVariable(0, x);             SparseGradient sgY1 = sgX.getField().getZero();             for (int i = poly.degree(); i >= 0; --i) {                 sgY1 = sgY1.multiply(sgX).add(poly.getCoefficients()[i]);             }             SparseGradient sgY2 = sgX.compose(poly.value(x), poly.polynomialDerivative().value(x));             SparseGradient zero = sgY1.subtract(sgY2);             checkF0F1(zero, 0.0, 0.0);         }     }      @Test     public void testField() {             SparseGradient x = SparseGradient.createVariable(0, 1.0);             checkF0F1(x.getField().getZero(), 0.0, 0.0, 0.0, 0.0);             checkF0F1(x.getField().getOne(), 1.0, 0.0, 0.0, 0.0);             Assert.assertEquals(SparseGradient.class, x.getField().getRuntimeClass());     }      @Test     public void testLinearCombination1DSDS() {         final SparseGradient[] a = new SparseGradient[] {             SparseGradient.createVariable(0, -1321008684645961.0 / 268435456.0),             SparseGradient.createVariable(1, -5774608829631843.0 / 268435456.0),             SparseGradient.createVariable(2, -7645843051051357.0 / 8589934592.0)         };         final SparseGradient[] b = new SparseGradient[] {             SparseGradient.createVariable(3, -5712344449280879.0 / 2097152.0),             SparseGradient.createVariable(4, -4550117129121957.0 / 2097152.0),             SparseGradient.createVariable(5, 8846951984510141.0 / 131072.0)         };          final SparseGradient abSumInline = a[0].linearCombination(a[0], b[0], a[1], b[1], a[2], b[2]);         final SparseGradient abSumArray = a[0].linearCombination(a, b);          Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 1.0e-15);         Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);         Assert.assertEquals(b[0].getValue(), abSumInline.getDerivative(0), 1.0e-15);         Assert.assertEquals(b[1].getValue(), abSumInline.getDerivative(1), 1.0e-15);         Assert.assertEquals(b[2].getValue(), abSumInline.getDerivative(2), 1.0e-15);         Assert.assertEquals(a[0].getValue(), abSumInline.getDerivative(3), 1.0e-15);         Assert.assertEquals(a[1].getValue(), abSumInline.getDerivative(4), 1.0e-15);         Assert.assertEquals(a[2].getValue(), abSumInline.getDerivative(5), 1.0e-15);      }      @Test     public void testLinearCombination1DoubleDS() {         final double[] a = new double[] {             -1321008684645961.0 / 268435456.0,             -5774608829631843.0 / 268435456.0,             -7645843051051357.0 / 8589934592.0         };         final SparseGradient[] b = new SparseGradient[] {             SparseGradient.createVariable(0, -5712344449280879.0 / 2097152.0),             SparseGradient.createVariable(1, -4550117129121957.0 / 2097152.0),             SparseGradient.createVariable(2, 8846951984510141.0 / 131072.0)         };          final SparseGradient abSumInline = b[0].linearCombination(a[0], b[0],                                                                        a[1], b[1],                                                                        a[2], b[2]);         final SparseGradient abSumArray = b[0].linearCombination(a, b);          Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 1.0e-15);         Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);         Assert.assertEquals(a[0], abSumInline.getDerivative(0), 1.0e-15);         Assert.assertEquals(a[1], abSumInline.getDerivative(1), 1.0e-15);         Assert.assertEquals(a[2], abSumInline.getDerivative(2), 1.0e-15);      }      @Test     public void testLinearCombination2DSDS() {         // we compare accurate versus naive dot product implementations         // on regular vectors (i.e. not extreme cases like in the previous test)         UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,                                                            0xc6af886975069f11l);          for (int i = 0; i < 10000; ++i) {             final SparseGradient[] u = new SparseGradient[4];             final SparseGradient[] v = new SparseGradient[4];             for (int j = 0; j < u.length; ++j) {                 u[j] = SparseGradient.createVariable(j, 1e17 * random.nextDouble());                 v[j] = SparseGradient.createConstant(1e17 * random.nextDouble());             }              SparseGradient lin = u[0].linearCombination(u[0], v[0], u[1], v[1]);             double ref = u[0].getValue() * v[0].getValue() +                          u[1].getValue() * v[1].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(v[0].getValue(), lin.getDerivative(0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(v[1].getValue(), lin.getDerivative(1), 1.0e-15 * FastMath.abs(v[1].getValue()));              lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);             ref = u[0].getValue() * v[0].getValue() +                   u[1].getValue() * v[1].getValue() +                   u[2].getValue() * v[2].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(v[0].getValue(), lin.getDerivative(0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(v[1].getValue(), lin.getDerivative(1), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(v[2].getValue(), lin.getDerivative(2), 1.0e-15 * FastMath.abs(v[2].getValue()));              lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);             ref = u[0].getValue() * v[0].getValue() +                   u[1].getValue() * v[1].getValue() +                   u[2].getValue() * v[2].getValue() +                   u[3].getValue() * v[3].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(v[0].getValue(), lin.getDerivative(0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(v[1].getValue(), lin.getDerivative(1), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(v[2].getValue(), lin.getDerivative(2), 1.0e-15 * FastMath.abs(v[2].getValue()));             Assert.assertEquals(v[3].getValue(), lin.getDerivative(3), 1.0e-15 * FastMath.abs(v[3].getValue()));          }     }      @Test     public void testLinearCombination2DoubleDS() {         // we compare accurate versus naive dot product implementations         // on regular vectors (i.e. not extreme cases like in the previous test)         UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,                                                            0xc6af886975069f11l);          for (int i = 0; i < 10000; ++i) {             final double[] u = new double[4];             final SparseGradient[] v = new SparseGradient[4];             for (int j = 0; j < u.length; ++j) {                 u[j] = 1e17 * random.nextDouble();                 v[j] = SparseGradient.createVariable(j, 1e17 * random.nextDouble());             }              SparseGradient lin = v[0].linearCombination(u[0], v[0], u[1], v[1]);             double ref = u[0] * v[0].getValue() +                          u[1] * v[1].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(u[0], lin.getDerivative(0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(u[1], lin.getDerivative(1), 1.0e-15 * FastMath.abs(v[1].getValue()));              lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);             ref = u[0] * v[0].getValue() +                   u[1] * v[1].getValue() +                   u[2] * v[2].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(u[0], lin.getDerivative(0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(u[1], lin.getDerivative(1), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(u[2], lin.getDerivative(2), 1.0e-15 * FastMath.abs(v[2].getValue()));              lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);             ref = u[0] * v[0].getValue() +                   u[1] * v[1].getValue() +                   u[2] * v[2].getValue() +                   u[3] * v[3].getValue();             Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));             Assert.assertEquals(u[0], lin.getDerivative(0), 1.0e-15 * FastMath.abs(v[0].getValue()));             Assert.assertEquals(u[1], lin.getDerivative(1), 1.0e-15 * FastMath.abs(v[1].getValue()));             Assert.assertEquals(u[2], lin.getDerivative(2), 1.0e-15 * FastMath.abs(v[2].getValue()));             Assert.assertEquals(u[3], lin.getDerivative(3), 1.0e-15 * FastMath.abs(v[3].getValue()));          }     }      @Test     public void testSerialization() {         SparseGradient a = SparseGradient.createVariable(0, 1.3);         SparseGradient b = (SparseGradient) TestUtils.serializeAndRecover(a);         Assert.assertEquals(a, b);     }      private void checkF0F1(SparseGradient sg, double value, double...derivatives) {          // check value         Assert.assertEquals(value, sg.getValue(), 1.0e-13);          // check first order derivatives         for (int i = 0; i < derivatives.length; ++i) {             Assert.assertEquals(derivatives[i], sg.getDerivative(i), 1.0e-13);         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.differentiation;  import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.numbers.combinatorics.BinomialCoefficient; import org.junit.Assert; import org.junit.Test;   /**  * Test for class {@link DSCompiler}.  */ public class DSCompilerTest {      @Test     public void testSize() {         for (int i = 0; i < 6; ++i) {             for (int j = 0; j < 6; ++j) {                 long expected = BinomialCoefficient.value(i + j, i);                 Assert.assertEquals(expected, DSCompiler.getCompiler(i, j).getSize());                 Assert.assertEquals(expected, DSCompiler.getCompiler(j, i).getSize());             }         }     }      @Test     public void testIndices() {          DSCompiler c = DSCompiler.getCompiler(0, 0);         checkIndices(c.getPartialDerivativeOrders(0), new int[0]);          c = DSCompiler.getCompiler(0, 1);         checkIndices(c.getPartialDerivativeOrders(0), new int[0]);          c = DSCompiler.getCompiler(1, 0);         checkIndices(c.getPartialDerivativeOrders(0), 0);          c = DSCompiler.getCompiler(1, 1);         checkIndices(c.getPartialDerivativeOrders(0), 0);         checkIndices(c.getPartialDerivativeOrders(1), 1);          c = DSCompiler.getCompiler(1, 2);         checkIndices(c.getPartialDerivativeOrders(0), 0);         checkIndices(c.getPartialDerivativeOrders(1), 1);         checkIndices(c.getPartialDerivativeOrders(2), 2);          c = DSCompiler.getCompiler(2, 1);         checkIndices(c.getPartialDerivativeOrders(0), 0, 0);         checkIndices(c.getPartialDerivativeOrders(1), 1, 0);         checkIndices(c.getPartialDerivativeOrders(2), 0, 1);          c = DSCompiler.getCompiler(1, 3);         checkIndices(c.getPartialDerivativeOrders(0), 0);         checkIndices(c.getPartialDerivativeOrders(1), 1);         checkIndices(c.getPartialDerivativeOrders(2), 2);         checkIndices(c.getPartialDerivativeOrders(3), 3);          c = DSCompiler.getCompiler(2, 2);         checkIndices(c.getPartialDerivativeOrders(0), 0, 0);         checkIndices(c.getPartialDerivativeOrders(1), 1, 0);         checkIndices(c.getPartialDerivativeOrders(2), 2, 0);         checkIndices(c.getPartialDerivativeOrders(3), 0, 1);         checkIndices(c.getPartialDerivativeOrders(4), 1, 1);         checkIndices(c.getPartialDerivativeOrders(5), 0, 2);          c = DSCompiler.getCompiler(3, 1);         checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0);         checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0);         checkIndices(c.getPartialDerivativeOrders(2), 0, 1, 0);         checkIndices(c.getPartialDerivativeOrders(3), 0, 0, 1);          c = DSCompiler.getCompiler(1, 4);         checkIndices(c.getPartialDerivativeOrders(0), 0);         checkIndices(c.getPartialDerivativeOrders(1), 1);         checkIndices(c.getPartialDerivativeOrders(2), 2);         checkIndices(c.getPartialDerivativeOrders(3), 3);         checkIndices(c.getPartialDerivativeOrders(4), 4);          c = DSCompiler.getCompiler(2, 3);         checkIndices(c.getPartialDerivativeOrders(0), 0, 0);         checkIndices(c.getPartialDerivativeOrders(1), 1, 0);         checkIndices(c.getPartialDerivativeOrders(2), 2, 0);         checkIndices(c.getPartialDerivativeOrders(3), 3, 0);         checkIndices(c.getPartialDerivativeOrders(4), 0, 1);         checkIndices(c.getPartialDerivativeOrders(5), 1, 1);         checkIndices(c.getPartialDerivativeOrders(6), 2, 1);         checkIndices(c.getPartialDerivativeOrders(7), 0, 2);         checkIndices(c.getPartialDerivativeOrders(8), 1, 2);         checkIndices(c.getPartialDerivativeOrders(9), 0, 3);          c = DSCompiler.getCompiler(3, 2);         checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0);         checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0);         checkIndices(c.getPartialDerivativeOrders(2), 2, 0, 0);         checkIndices(c.getPartialDerivativeOrders(3), 0, 1, 0);         checkIndices(c.getPartialDerivativeOrders(4), 1, 1, 0);         checkIndices(c.getPartialDerivativeOrders(5), 0, 2, 0);         checkIndices(c.getPartialDerivativeOrders(6), 0, 0, 1);         checkIndices(c.getPartialDerivativeOrders(7), 1, 0, 1);         checkIndices(c.getPartialDerivativeOrders(8), 0, 1, 1);         checkIndices(c.getPartialDerivativeOrders(9), 0, 0, 2);          c = DSCompiler.getCompiler(4, 1);         checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0, 0);         checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0, 0);         checkIndices(c.getPartialDerivativeOrders(2), 0, 1, 0, 0);         checkIndices(c.getPartialDerivativeOrders(3), 0, 0, 1, 0);         checkIndices(c.getPartialDerivativeOrders(4), 0, 0, 0, 1);      }      @Test(expected=DimensionMismatchException.class)     public void testIncompatibleParams() {         DSCompiler.getCompiler(3, 2).checkCompatibility(DSCompiler.getCompiler(4, 2));     }      @Test(expected=DimensionMismatchException.class)     public void testIncompatibleOrder() {         DSCompiler.getCompiler(3, 3).checkCompatibility(DSCompiler.getCompiler(3, 2));     }      @Test     public void testSymmetry() {         for (int i = 0; i < 6; ++i) {             for (int j = 0; j < 6; ++j) {                 DSCompiler c = DSCompiler.getCompiler(i, j);                 for (int k = 0; k < c.getSize(); ++k) {                     Assert.assertEquals(k, c.getPartialDerivativeIndex(c.getPartialDerivativeOrders(k)));                 }             }         }     }      @Test public void testMultiplicationRules()         throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {          Map<String,String> referenceRules = new HashMap<>();         referenceRules.put("(f*g)",          "f * g");         referenceRules.put("d(f*g)/dx",      "f * dg/dx + df/dx * g");         referenceRules.put("d(f*g)/dy",      referenceRules.get("d(f*g)/dx").replaceAll("x", "y"));         referenceRules.put("d(f*g)/dz",      referenceRules.get("d(f*g)/dx").replaceAll("x", "z"));         referenceRules.put("d(f*g)/dt",      referenceRules.get("d(f*g)/dx").replaceAll("x", "t"));         referenceRules.put("d2(f*g)/dx2",    "f * d2g/dx2 + 2 * df/dx * dg/dx + d2f/dx2 * g");         referenceRules.put("d2(f*g)/dy2",    referenceRules.get("d2(f*g)/dx2").replaceAll("x", "y"));         referenceRules.put("d2(f*g)/dz2",    referenceRules.get("d2(f*g)/dx2").replaceAll("x", "z"));         referenceRules.put("d2(f*g)/dt2",    referenceRules.get("d2(f*g)/dx2").replaceAll("x", "t"));         referenceRules.put("d2(f*g)/dxdy",   "f * d2g/dxdy + df/dy * dg/dx + df/dx * dg/dy + d2f/dxdy * g");         referenceRules.put("d2(f*g)/dxdz",   referenceRules.get("d2(f*g)/dxdy").replaceAll("y", "z"));         referenceRules.put("d2(f*g)/dxdt",   referenceRules.get("d2(f*g)/dxdy").replaceAll("y", "t"));         referenceRules.put("d2(f*g)/dydz",   referenceRules.get("d2(f*g)/dxdz").replaceAll("x", "y"));         referenceRules.put("d2(f*g)/dydt",   referenceRules.get("d2(f*g)/dxdt").replaceAll("x", "y"));         referenceRules.put("d2(f*g)/dzdt",   referenceRules.get("d2(f*g)/dxdt").replaceAll("x", "z"));         referenceRules.put("d3(f*g)/dx3",    "f * d3g/dx3 +" +                                              " 3 * df/dx * d2g/dx2 +" +                                              " 3 * d2f/dx2 * dg/dx +" +                                              " d3f/dx3 * g");         referenceRules.put("d3(f*g)/dy3",   referenceRules.get("d3(f*g)/dx3").replaceAll("x", "y"));         referenceRules.put("d3(f*g)/dz3",   referenceRules.get("d3(f*g)/dx3").replaceAll("x", "z"));         referenceRules.put("d3(f*g)/dt3",   referenceRules.get("d3(f*g)/dx3").replaceAll("x", "t"));         referenceRules.put("d3(f*g)/dx2dy",  "f * d3g/dx2dy +" +                                              " df/dy * d2g/dx2 +" +                                              " 2 * df/dx * d2g/dxdy +" +                                              " 2 * d2f/dxdy * dg/dx +" +                                              " d2f/dx2 * dg/dy +" +                                              " d3f/dx2dy * g");         referenceRules.put("d3(f*g)/dxdy2",  "f * d3g/dxdy2 +" +                                              " 2 * df/dy * d2g/dxdy +" +                                              " d2f/dy2 * dg/dx +" +                                              " df/dx * d2g/dy2 +" +                                              " 2 * d2f/dxdy * dg/dy +" +                                              " d3f/dxdy2 * g");         referenceRules.put("d3(f*g)/dx2dz",   referenceRules.get("d3(f*g)/dx2dy").replaceAll("y", "z"));         referenceRules.put("d3(f*g)/dy2dz",   referenceRules.get("d3(f*g)/dx2dz").replaceAll("x", "y"));         referenceRules.put("d3(f*g)/dxdz2",   referenceRules.get("d3(f*g)/dxdy2").replaceAll("y", "z"));         referenceRules.put("d3(f*g)/dydz2",   referenceRules.get("d3(f*g)/dxdz2").replaceAll("x", "y"));         referenceRules.put("d3(f*g)/dx2dt",   referenceRules.get("d3(f*g)/dx2dz").replaceAll("z", "t"));         referenceRules.put("d3(f*g)/dy2dt",   referenceRules.get("d3(f*g)/dx2dt").replaceAll("x", "y"));         referenceRules.put("d3(f*g)/dz2dt",   referenceRules.get("d3(f*g)/dx2dt").replaceAll("x", "z"));         referenceRules.put("d3(f*g)/dxdt2",   referenceRules.get("d3(f*g)/dxdy2").replaceAll("y", "t"));         referenceRules.put("d3(f*g)/dydt2",   referenceRules.get("d3(f*g)/dxdt2").replaceAll("x", "y"));         referenceRules.put("d3(f*g)/dzdt2",   referenceRules.get("d3(f*g)/dxdt2").replaceAll("x", "z"));         referenceRules.put("d3(f*g)/dxdydz", "f * d3g/dxdydz +" +                                              " df/dz * d2g/dxdy +" +                                              " df/dy * d2g/dxdz +" +                                              " d2f/dydz * dg/dx +" +                                              " df/dx * d2g/dydz +" +                                              " d2f/dxdz * dg/dy +" +                                              " d2f/dxdy * dg/dz +" +                                              " d3f/dxdydz * g");         referenceRules.put("d3(f*g)/dxdydt", referenceRules.get("d3(f*g)/dxdydz").replaceAll("z", "t"));         referenceRules.put("d3(f*g)/dxdzdt", referenceRules.get("d3(f*g)/dxdydt").replaceAll("y", "z"));         referenceRules.put("d3(f*g)/dydzdt", referenceRules.get("d3(f*g)/dxdzdt").replaceAll("x", "y"));          Field multFieldArrayField = DSCompiler.class.getDeclaredField("multIndirection");         multFieldArrayField.setAccessible(true);         for (int i = 0; i < 5; ++i) {             for (int j = 0; j < 4; ++j) {                 DSCompiler compiler = DSCompiler.getCompiler(i, j);                 int[][][] multIndirection = (int[][][]) multFieldArrayField.get(compiler);                 for (int k = 0; k < multIndirection.length; ++k) {                     String product = ordersToString(compiler.getPartialDerivativeOrders(k),                                                     "(f*g)", "x", "y", "z", "t");                     StringBuilder rule = new StringBuilder();                     for (int[] term : multIndirection[k]) {                         if (rule.length() > 0) {                             rule.append(" + ");                         }                         if (term[0] > 1) {                             rule.append(term[0]).append(" * ");                         }                         rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[1]),                                                    "f", "x", "y", "z", "t"));                         rule.append(" * ");                         rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[2]),                                                    "g", "x", "y", "z", "t"));                     }                     Assert.assertEquals(product, referenceRules.get(product), rule.toString());                 }             }         }     }      @Test public void testCompositionRules()         throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {          // the following reference rules have all been computed independently from the library,         // using only pencil and paper and some search and replace to handle symmetries         Map<String,String> referenceRules = new HashMap<>();         referenceRules.put("(f(g))",              "(f(g))");         referenceRules.put("d(f(g))/dx",          "d(f(g))/dg * dg/dx");         referenceRules.put("d(f(g))/dy",          referenceRules.get("d(f(g))/dx").replaceAll("x", "y"));         referenceRules.put("d(f(g))/dz",          referenceRules.get("d(f(g))/dx").replaceAll("x", "z"));         referenceRules.put("d(f(g))/dt",          referenceRules.get("d(f(g))/dx").replaceAll("x", "t"));         referenceRules.put("d2(f(g))/dx2",        "d2(f(g))/dg2 * dg/dx * dg/dx + d(f(g))/dg * d2g/dx2");         referenceRules.put("d2(f(g))/dy2",        referenceRules.get("d2(f(g))/dx2").replaceAll("x", "y"));         referenceRules.put("d2(f(g))/dz2",        referenceRules.get("d2(f(g))/dx2").replaceAll("x", "z"));         referenceRules.put("d2(f(g))/dt2",        referenceRules.get("d2(f(g))/dx2").replaceAll("x", "t"));         referenceRules.put("d2(f(g))/dxdy",       "d2(f(g))/dg2 * dg/dx * dg/dy + d(f(g))/dg * d2g/dxdy");         referenceRules.put("d2(f(g))/dxdz",       referenceRules.get("d2(f(g))/dxdy").replaceAll("y", "z"));         referenceRules.put("d2(f(g))/dxdt",       referenceRules.get("d2(f(g))/dxdy").replaceAll("y", "t"));         referenceRules.put("d2(f(g))/dydz",       referenceRules.get("d2(f(g))/dxdz").replaceAll("x", "y"));         referenceRules.put("d2(f(g))/dydt",       referenceRules.get("d2(f(g))/dxdt").replaceAll("x", "y"));         referenceRules.put("d2(f(g))/dzdt",       referenceRules.get("d2(f(g))/dxdt").replaceAll("x", "z"));         referenceRules.put("d3(f(g))/dx3",        "d3(f(g))/dg3 * dg/dx * dg/dx * dg/dx +" +                                                   " 3 * d2(f(g))/dg2 * dg/dx * d2g/dx2 +" +                                                   " d(f(g))/dg * d3g/dx3");         referenceRules.put("d3(f(g))/dy3",        referenceRules.get("d3(f(g))/dx3").replaceAll("x", "y"));         referenceRules.put("d3(f(g))/dz3",        referenceRules.get("d3(f(g))/dx3").replaceAll("x", "z"));         referenceRules.put("d3(f(g))/dt3",        referenceRules.get("d3(f(g))/dx3").replaceAll("x", "t"));         referenceRules.put("d3(f(g))/dxdy2",      "d3(f(g))/dg3 * dg/dx * dg/dy * dg/dy +" +                                                   " 2 * d2(f(g))/dg2 * dg/dy * d2g/dxdy +" +                                                   " d2(f(g))/dg2 * dg/dx * d2g/dy2 +" +                                                   " d(f(g))/dg * d3g/dxdy2");         referenceRules.put("d3(f(g))/dxdz2",      referenceRules.get("d3(f(g))/dxdy2").replaceAll("y", "z"));         referenceRules.put("d3(f(g))/dxdt2",      referenceRules.get("d3(f(g))/dxdy2").replaceAll("y", "t"));         referenceRules.put("d3(f(g))/dydz2",      referenceRules.get("d3(f(g))/dxdz2").replaceAll("x", "y"));         referenceRules.put("d3(f(g))/dydt2",      referenceRules.get("d3(f(g))/dxdt2").replaceAll("x", "y"));         referenceRules.put("d3(f(g))/dzdt2",      referenceRules.get("d3(f(g))/dxdt2").replaceAll("x", "z"));         referenceRules.put("d3(f(g))/dx2dy",      "d3(f(g))/dg3 * dg/dx * dg/dx * dg/dy +" +                                                   " 2 * d2(f(g))/dg2 * dg/dx * d2g/dxdy +" +                                                   " d2(f(g))/dg2 * d2g/dx2 * dg/dy +" +                                                   " d(f(g))/dg * d3g/dx2dy");         referenceRules.put("d3(f(g))/dx2dz",      referenceRules.get("d3(f(g))/dx2dy").replaceAll("y", "z"));         referenceRules.put("d3(f(g))/dx2dt",      referenceRules.get("d3(f(g))/dx2dy").replaceAll("y", "t"));         referenceRules.put("d3(f(g))/dy2dz",      referenceRules.get("d3(f(g))/dx2dz").replaceAll("x", "y"));         referenceRules.put("d3(f(g))/dy2dt",      referenceRules.get("d3(f(g))/dx2dt").replaceAll("x", "y"));         referenceRules.put("d3(f(g))/dz2dt",      referenceRules.get("d3(f(g))/dx2dt").replaceAll("x", "z"));         referenceRules.put("d3(f(g))/dxdydz",     "d3(f(g))/dg3 * dg/dx * dg/dy * dg/dz +" +                                                   " d2(f(g))/dg2 * dg/dy * d2g/dxdz +" +                                                   " d2(f(g))/dg2 * dg/dx * d2g/dydz +" +                                                   " d2(f(g))/dg2 * d2g/dxdy * dg/dz +" +                                                   " d(f(g))/dg * d3g/dxdydz");         referenceRules.put("d3(f(g))/dxdydt",     referenceRules.get("d3(f(g))/dxdydz").replaceAll("z", "t"));         referenceRules.put("d3(f(g))/dxdzdt",     referenceRules.get("d3(f(g))/dxdydt").replaceAll("y", "z"));         referenceRules.put("d3(f(g))/dydzdt",     referenceRules.get("d3(f(g))/dxdzdt").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dx4",        "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dx * dg/dx +" +                                                   " 6 * d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dx2 +" +                                                   " 3 * d2(f(g))/dg2 * d2g/dx2 * d2g/dx2 +" +                                                   " 4 * d2(f(g))/dg2 * dg/dx * d3g/dx3 +" +                                                   " d(f(g))/dg * d4g/dx4");         referenceRules.put("d4(f(g))/dy4",        referenceRules.get("d4(f(g))/dx4").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dz4",        referenceRules.get("d4(f(g))/dx4").replaceAll("x", "z"));         referenceRules.put("d4(f(g))/dt4",        referenceRules.get("d4(f(g))/dx4").replaceAll("x", "t"));         referenceRules.put("d4(f(g))/dx3dy",      "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dx * dg/dy +" +                                                   " 3 * d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dxdy +" +                                                   " 3 * d3(f(g))/dg3 * dg/dx * d2g/dx2 * dg/dy +" +                                                   " 3 * d2(f(g))/dg2 * d2g/dx2 * d2g/dxdy +" +                                                   " 3 * d2(f(g))/dg2 * dg/dx * d3g/dx2dy +" +                                                   " d2(f(g))/dg2 * d3g/dx3 * dg/dy +" +                                                   " d(f(g))/dg * d4g/dx3dy");         referenceRules.put("d4(f(g))/dx3dz",      referenceRules.get("d4(f(g))/dx3dy").replaceAll("y", "z"));         referenceRules.put("d4(f(g))/dx3dt",      referenceRules.get("d4(f(g))/dx3dy").replaceAll("y", "t"));         referenceRules.put("d4(f(g))/dxdy3",      "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dy * dg/dy +" +                                                   " 3 * d3(f(g))/dg3 * dg/dy * dg/dy * d2g/dxdy +" +                                                   " 3 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dy2 +" +                                                   " 3 * d2(f(g))/dg2 * d2g/dxdy * d2g/dy2 +" +                                                   " 3 * d2(f(g))/dg2 * dg/dy * d3g/dxdy2 +" +                                                   " d2(f(g))/dg2 * dg/dx * d3g/dy3 +" +                                                   " d(f(g))/dg * d4g/dxdy3");         referenceRules.put("d4(f(g))/dxdz3",      referenceRules.get("d4(f(g))/dxdy3").replaceAll("y", "z"));         referenceRules.put("d4(f(g))/dxdt3",      referenceRules.get("d4(f(g))/dxdy3").replaceAll("y", "t"));         referenceRules.put("d4(f(g))/dy3dz",      referenceRules.get("d4(f(g))/dx3dz").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dy3dt",      referenceRules.get("d4(f(g))/dx3dt").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dydz3",      referenceRules.get("d4(f(g))/dxdz3").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dydt3",      referenceRules.get("d4(f(g))/dxdt3").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dz3dt",      referenceRules.get("d4(f(g))/dx3dt").replaceAll("x", "z"));         referenceRules.put("d4(f(g))/dzdt3",      referenceRules.get("d4(f(g))/dxdt3").replaceAll("x", "z"));         referenceRules.put("d4(f(g))/dx2dy2",     "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dy * dg/dy +" +                                                   " 4 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dxdy +" +                                                   " d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dy2 +" +                                                   " 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dxdy +" +                                                   " 2 * d2(f(g))/dg2 * dg/dx * d3g/dxdy2 +" +                                                   " d3(f(g))/dg3 * d2g/dx2 * dg/dy * dg/dy +" +                                                   " 2 * d2(f(g))/dg2 * dg/dy * d3g/dx2dy +" +                                                   " d2(f(g))/dg2 * d2g/dx2 * d2g/dy2 +" +                                                   " d(f(g))/dg * d4g/dx2dy2");         referenceRules.put("d4(f(g))/dx2dz2",     referenceRules.get("d4(f(g))/dx2dy2").replaceAll("y", "z"));         referenceRules.put("d4(f(g))/dx2dt2",     referenceRules.get("d4(f(g))/dx2dy2").replaceAll("y", "t"));         referenceRules.put("d4(f(g))/dy2dz2",     referenceRules.get("d4(f(g))/dx2dz2").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dy2dt2",     referenceRules.get("d4(f(g))/dx2dt2").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dz2dt2",     referenceRules.get("d4(f(g))/dx2dt2").replaceAll("x", "z"));          referenceRules.put("d4(f(g))/dx2dydz",    "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dy * dg/dz +" +                                                   " 2 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dxdz +" +                                                   " d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dydz +" +                                                   " 2 * d3(f(g))/dg3 * dg/dx * d2g/dxdy * dg/dz +" +                                                   " 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dxdz +" +                                                   " 2 * d2(f(g))/dg2 * dg/dx * d3g/dxdydz +" +                                                   " d3(f(g))/dg3 * d2g/dx2 * dg/dy * dg/dz +" +                                                   " d2(f(g))/dg2 * dg/dy * d3g/dx2dz +" +                                                   " d2(f(g))/dg2 * d2g/dx2 * d2g/dydz +" +                                                   " d2(f(g))/dg2 * d3g/dx2dy * dg/dz +" +                                                   " d(f(g))/dg * d4g/dx2dydz");         referenceRules.put("d4(f(g))/dx2dydt",    referenceRules.get("d4(f(g))/dx2dydz").replaceAll("z", "t"));         referenceRules.put("d4(f(g))/dx2dzdt",    referenceRules.get("d4(f(g))/dx2dydt").replaceAll("y", "z"));         referenceRules.put("d4(f(g))/dxdy2dz",    "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dy * dg/dz +" +                                                   " d3(f(g))/dg3 * dg/dy * dg/dy * d2g/dxdz +" +                                                   " 2 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dydz +" +                                                   " 2 * d3(f(g))/dg3 * dg/dy * d2g/dxdy * dg/dz +" +                                                   " 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dydz +" +                                                   " 2 * d2(f(g))/dg2 * dg/dy * d3g/dxdydz +" +                                                   " d3(f(g))/dg3 * dg/dx * d2g/dy2 * dg/dz +" +                                                   " d2(f(g))/dg2 * d2g/dy2 * d2g/dxdz +" +                                                   " d2(f(g))/dg2 * dg/dx * d3g/dy2dz +" +                                                   " d2(f(g))/dg2 * d3g/dxdy2 * dg/dz +" +                                                   " d(f(g))/dg * d4g/dxdy2dz");         referenceRules.put("d4(f(g))/dxdy2dt",    referenceRules.get("d4(f(g))/dxdy2dz").replaceAll("z", "t"));         referenceRules.put("d4(f(g))/dy2dzdt",    referenceRules.get("d4(f(g))/dx2dzdt").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dxdydz2",    "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dz * dg/dz +" +                                                   " 2 * d3(f(g))/dg3 * dg/dy * dg/dz * d2g/dxdz +" +                                                   " 2 * d3(f(g))/dg3 * dg/dx * dg/dz * d2g/dydz +" +                                                   " d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dz2 +" +                                                   " 2 * d2(f(g))/dg2 * d2g/dxdz * d2g/dydz +" +                                                   " d2(f(g))/dg2 * dg/dy * d3g/dxdz2 +" +                                                   " d2(f(g))/dg2 * dg/dx * d3g/dydz2 +" +                                                   " d3(f(g))/dg3 * d2g/dxdy * dg/dz * dg/dz +" +                                                   " 2 * d2(f(g))/dg2 * dg/dz * d3g/dxdydz +" +                                                   " d2(f(g))/dg2 * d2g/dxdy * d2g/dz2 +" +                                                   " d(f(g))/dg * d4g/dxdydz2");         referenceRules.put("d4(f(g))/dxdz2dt",    referenceRules.get("d4(f(g))/dxdy2dt").replaceAll("y", "z"));         referenceRules.put("d4(f(g))/dydz2dt",    referenceRules.get("d4(f(g))/dxdz2dt").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dxdydt2",    referenceRules.get("d4(f(g))/dxdydz2").replaceAll("z", "t"));         referenceRules.put("d4(f(g))/dxdzdt2",    referenceRules.get("d4(f(g))/dxdydt2").replaceAll("y", "z"));         referenceRules.put("d4(f(g))/dydzdt2",    referenceRules.get("d4(f(g))/dxdzdt2").replaceAll("x", "y"));         referenceRules.put("d4(f(g))/dxdydzdt",   "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dz * dg/dt +" +                                                   " d3(f(g))/dg3 * dg/dy * dg/dz * d2g/dxdt +" +                                                   " d3(f(g))/dg3 * dg/dx * dg/dz * d2g/dydt +" +                                                   " d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dzdt +" +                                                   " d3(f(g))/dg3 * dg/dy * d2g/dxdz * dg/dt +" +                                                   " d2(f(g))/dg2 * d2g/dxdz * d2g/dydt +" +                                                   " d2(f(g))/dg2 * dg/dy * d3g/dxdzdt +" +                                                   " d3(f(g))/dg3 * dg/dx * d2g/dydz * dg/dt +" +                                                   " d2(f(g))/dg2 * d2g/dydz * d2g/dxdt +" +                                                   " d2(f(g))/dg2 * dg/dx * d3g/dydzdt +" +                                                   " d3(f(g))/dg3 * d2g/dxdy * dg/dz * dg/dt +" +                                                   " d2(f(g))/dg2 * dg/dz * d3g/dxdydt +" +                                                   " d2(f(g))/dg2 * d2g/dxdy * d2g/dzdt +" +                                                   " d2(f(g))/dg2 * d3g/dxdydz * dg/dt +" +                                                   " d(f(g))/dg * d4g/dxdydzdt");          Field compFieldArrayField = DSCompiler.class.getDeclaredField("compIndirection");         compFieldArrayField.setAccessible(true);         for (int i = 0; i < 5; ++i) {             for (int j = 0; j < 5; ++j) {                 DSCompiler compiler = DSCompiler.getCompiler(i, j);                 int[][][] compIndirection = (int[][][]) compFieldArrayField.get(compiler);                 for (int k = 0; k < compIndirection.length; ++k) {                     String product = ordersToString(compiler.getPartialDerivativeOrders(k),                                                     "(f(g))", "x", "y", "z", "t");                     StringBuilder rule = new StringBuilder();                     for (int[] term : compIndirection[k]) {                         if (rule.length() > 0) {                             rule.append(" + ");                         }                         if (term[0] > 1) {                             rule.append(term[0]).append(" * ");                         }                         rule.append(orderToString(term[1], "(f(g))", "g"));                         for (int l = 2; l < term.length; ++l) {                             rule.append(" * ");                             rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[l]),                                                        "g", "x", "y", "z", "t"));                         }                     }                     Assert.assertEquals(product, referenceRules.get(product), rule.toString());                 }             }         }     }      private void checkIndices(int[] indices, int ... expected) {         Assert.assertEquals(expected.length, indices.length);         for (int i = 0; i < expected.length; ++i) {             Assert.assertEquals(expected[i], indices[i]);         }     }      private String orderToString(int order, String functionName, String parameterName) {         if (order == 0) {             return functionName;         } else if (order == 1) {             return "d" + functionName + "/d" + parameterName;         } else {             return "d" + order + functionName + "/d" + parameterName + order;         }     }      private String ordersToString(int[] orders, String functionName, String ... parametersNames) {          int sumOrders = 0;         for (int order : orders) {             sumOrders += order;         }          if (sumOrders == 0) {             return functionName;         }          StringBuilder builder = new StringBuilder();         builder.append('d');         if (sumOrders > 1) {             builder.append(sumOrders);         }         builder.append(functionName).append('/');         for (int i = 0; i < orders.length; ++i) {             if (orders[i] > 0) {                 builder.append('d').append(parametersNames[i]);                 if (orders[i] > 1) {                     builder.append(orders[i]);                 }             }         }         return builder.toString();      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Test;  /**  * Test the LinearInterpolator.  */ public class LinearInterpolatorTest {      /** error tolerance for spline interpolator value at knot points */     protected double knotTolerance = 1E-12;      /** error tolerance for interpolating polynomial coefficients */     protected double coefficientTolerance = 1E-6;      /** error tolerance for interpolated values */     protected double interpolationTolerance = 1E-12;      @Test     public void testInterpolateLinearDegenerateTwoSegment()         {         double x[] = { 0.0, 0.5, 1.0 };         double y[] = { 0.0, 0.5, 1.0 };         UnivariateInterpolator i = new LinearInterpolator();         UnivariateFunction f = i.interpolate(x, y);         verifyInterpolation(f, x, y);          // Verify coefficients using analytical values         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();         double target[] = {y[0], 1d};         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[1], 1d};         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);          // Check interpolation         Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance);         Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance);         Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance);     }      @Test     public void testInterpolateLinearDegenerateThreeSegment()         {         double x[] = { 0.0, 0.5, 1.0, 1.5 };         double y[] = { 0.0, 0.5, 1.0, 1.5 };         UnivariateInterpolator i = new LinearInterpolator();         UnivariateFunction f = i.interpolate(x, y);         verifyInterpolation(f, x, y);          // Verify coefficients using analytical values         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();         double target[] = {y[0], 1d};         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[1], 1d};         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[2], 1d};         TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);          // Check interpolation         Assert.assertEquals(0,f.value(0), interpolationTolerance);         Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance);         Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance);     }      @Test     public void testInterpolateLinear() {         double x[] = { 0.0, 0.5, 1.0 };         double y[] = { 0.0, 0.5, 0.0 };         UnivariateInterpolator i = new LinearInterpolator();         UnivariateFunction f = i.interpolate(x, y);         verifyInterpolation(f, x, y);          // Verify coefficients using analytical values         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();         double target[] = {y[0], 1d};         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[1], -1d};         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);     }      @Test     public void testIllegalArguments() {         // Data set arrays of different size.         UnivariateInterpolator i = new LinearInterpolator();         try {             double xval[] = { 0.0, 1.0 };             double yval[] = { 0.0, 1.0, 2.0 };             i.interpolate(xval, yval);             Assert.fail("Failed to detect data set array with different sizes.");         } catch (DimensionMismatchException iae) {             // Expected.         }         // X values not sorted.         try {             double xval[] = { 0.0, 1.0, 0.5 };             double yval[] = { 0.0, 1.0, 2.0 };             i.interpolate(xval, yval);             Assert.fail("Failed to detect unsorted arguments.");         } catch (NonMonotonicSequenceException iae) {             // Expected.         }         // Not enough data to interpolate.         try {             double xval[] = { 0.0 };             double yval[] = { 0.0 };             i.interpolate(xval, yval);             Assert.fail("Failed to detect unsorted arguments.");         } catch (NumberIsTooSmallException iae) {             // Expected.         }     }      /**      * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.      */     protected void verifyInterpolation(UnivariateFunction f, double x[], double y[])        {         for (int i = 0; i < x.length; i++) {             Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.BivariateFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  /**  * Test case for the bicubic interpolator.  */ public final class BicubicInterpolatorTest {     /**      * Test preconditions.      */     @Test     public void testPreconditions() {         double[] xval = new double[] {3, 4, 5, 6.5};         double[] yval = new double[] {-4, -3, -1, 2.5};         double[][] zval = new double[xval.length][yval.length];          BivariateGridInterpolator interpolator = new BicubicInterpolator();          @SuppressWarnings("unused")         BivariateFunction p = interpolator.interpolate(xval, yval, zval);          double[] wxval = new double[] {3, 2, 5, 6.5};         try {             p = interpolator.interpolate(wxval, yval, zval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }          double[] wyval = new double[] {-4, -3, -1, -1};         try {             p = interpolator.interpolate(xval, wyval, zval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }          double[][] wzval = new double[xval.length][yval.length + 1];         try {             p = interpolator.interpolate(xval, yval, wzval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         wzval = new double[xval.length - 1][yval.length];         try {             p = interpolator.interpolate(xval, yval, wzval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }     }      /**      * Interpolating a plane.      * <p>      * z = 2 x - 3 y + 5      */     @Test     public void testPlane() {         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 2 * x - 3 * y + 5;                 }             };          testInterpolation(3000,                           1e-13,                           f,                           false);     }      /**      * Interpolating a paraboloid.      * <p>      * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5      */     @Test     public void testParaboloid() {         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 2 * x * x - 3 * y * y + 4 * x * y - 5;                 }             };          testInterpolation(3000,                           1e-12,                           f,                           false);     }      /**      * @param numSamples Number of test samples.      * @param tolerance Allowed tolerance on the interpolated value.      * @param f Test function.      * @param print Whether to print debugging output to the console.      */     private void testInterpolation(int numSamples,                                    double tolerance,                                    BivariateFunction f,                                    boolean print) {         final int sz = 21;         final double[] xval = new double[sz];         final double[] yval = new double[sz];         // Coordinate values         final double delta = 1d / (sz - 1);         for (int i = 0; i < sz; i++) {             xval[i] = -1 + 15 * i * delta;             yval[i] = -20 + 30 * i * delta;         }          final double[][] zval = new double[xval.length][yval.length];         for (int i = 0; i < xval.length; i++) {             for (int j = 0; j < yval.length; j++) {                 zval[i][j] = f.value(xval[i], yval[j]);             }         }          final BicubicInterpolator interpolator = new BicubicInterpolator();         final BicubicInterpolatingFunction p = interpolator.interpolate(xval, yval, zval);         double x, y;          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C);         final ContinuousDistribution.Sampler distX = new UniformContinuousDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);         final ContinuousDistribution.Sampler distY = new UniformContinuousDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);          int count = 0;         while (true) {             x = distX.sample();             y = distY.sample();             if (!p.isValidPoint(x, y)) {                 if (print) {                     System.out.println("# " + x + " " + y);                 }                 continue;             }              if (count++ > numSamples) {                 break;             }             final double expected = f.value(x, y);             final double actual = p.value(x, y);              if (print) {                 System.out.println(x + " " + y + " " + expected + " " + actual);             }              Assert.assertEquals(expected, actual, tolerance);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.TrivariateFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for the {@link TricubicInterpolator tricubic interpolator}.  */ public final class TricubicInterpolatorTest {     /**      * Test preconditions.      */     @Test     public void testPreconditions() {         double[] xval = new double[] {3, 4, 5, 6.5};         double[] yval = new double[] {-4, -3, -1, 2.5};         double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};         double[][][] fval = new double[xval.length][yval.length][zval.length];          @SuppressWarnings("unused")         TrivariateFunction tcf = new TricubicInterpolator().interpolate(xval, yval, zval, fval);          double[] wxval = new double[] {3, 2, 5, 6.5};         try {             tcf = new TricubicInterpolator().interpolate(wxval, yval, zval, fval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[] wyval = new double[] {-4, -1, -1, 2.5};         try {             tcf = new TricubicInterpolator().interpolate(xval, wyval, zval, fval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[] wzval = new double[] {-12, -8, -9, -3, 0, 2.5};         try {             tcf = new TricubicInterpolator().interpolate(xval, yval, wzval, fval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[][][] wfval = new double[xval.length - 1][yval.length][zval.length];         try {             tcf = new TricubicInterpolator().interpolate(xval, yval, zval, wfval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         wfval = new double[xval.length][yval.length - 1][zval.length];         try {             tcf = new TricubicInterpolator().interpolate(xval, yval, zval, wfval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         wfval = new double[xval.length][yval.length][zval.length - 1];         try {             tcf = new TricubicInterpolator().interpolate(xval, yval, zval, wfval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }     }      @Test     public void testIsValid() {         double[] xval = new double[] {3, 4, 5, 6.5};         double[] yval = new double[] {-4, -3, -1, 2.5};         double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};         double[][][] fval = new double[xval.length][yval.length][zval.length];          TricubicInterpolatingFunction tcf = new TricubicInterpolator().interpolate(xval, yval, zval, fval);          // Valid.         Assert.assertTrue(tcf.isValidPoint(4, -3, -8));         Assert.assertTrue(tcf.isValidPoint(5, -3, -8));         Assert.assertTrue(tcf.isValidPoint(4, -1, -8));         Assert.assertTrue(tcf.isValidPoint(5, -1, -8));         Assert.assertTrue(tcf.isValidPoint(4, -3, 0));         Assert.assertTrue(tcf.isValidPoint(5, -3, 0));         Assert.assertTrue(tcf.isValidPoint(4, -1, 0));         Assert.assertTrue(tcf.isValidPoint(5, -1, 0));          // Invalid.         Assert.assertFalse(tcf.isValidPoint(3.5, -3, -8));         Assert.assertFalse(tcf.isValidPoint(4.5, -3.1, -8));         Assert.assertFalse(tcf.isValidPoint(4.5, -2, 0.1));         Assert.assertFalse(tcf.isValidPoint(4.5, 0, -3.5));         Assert.assertFalse(tcf.isValidPoint(4.1, -1, -10));     }      /**      * Test for a plane.      * <p>      *  f(x, y, z) = 2 x - 3 y - 4 z + 5      * </p>      */     @Test     public void testPlane() {         double[] xval = new double[] {3, 4, 5, 6.5};         double[] yval = new double[] {-4, -3, -1, 2, 2.5};         double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};          // Function values         TrivariateFunction f = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 2 * x - 3 * y - 4 * z + 5;                 }             };          double[][][] fval = new double[xval.length][yval.length][zval.length];          for (int i = 0; i < xval.length; i++) {             for (int j = 0; j < yval.length; j++) {                 for (int k = 0; k < zval.length; k++) {                     fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                 }             }         }          TrivariateFunction tcf = new TricubicInterpolator().interpolate(xval,                                                                         yval,                                                                         zval,                                                                         fval);         double x, y, z;         double expected, result;          x = 4;         y = -3;         z = 0;         expected = f.value(x, y, z);         result = tcf.value(x, y, z);         Assert.assertEquals("On sample point",                             expected, result, 1e-15);          x = 4.5;         y = -1.5;         z = -4.25;         expected = f.value(x, y, z);         result = tcf.value(x, y, z);         Assert.assertEquals("Half-way between sample points (middle of the patch)",                             expected, result, 1e-14);     }      /**      * Sine wave.      * <p>      *  f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y]      * </p>      * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1.      */     @Test     public void testWave() {         double[] xval = new double[] {3, 4, 5, 6.5};         double[] yval = new double[] {-4, -3, -1, 2, 2.5};         double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4};          final double a = 0.2;         final double omega = 0.5;         final double kx = 2;         final double ky = 1;          // Function values         TrivariateFunction f = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return a * FastMath.cos(omega * z - kx * x - ky * y);                 }             };          double[][][] fval = new double[xval.length][yval.length][zval.length];         for (int i = 0; i < xval.length; i++) {             for (int j = 0; j < yval.length; j++) {                 for (int k = 0; k < zval.length; k++) {                     fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                 }             }         }          TrivariateFunction tcf = new TricubicInterpolator().interpolate(xval,                                                                         yval,                                                                         zval,                                                                         fval);          double x, y, z;         double expected, result;          x = 4;         y = -3;         z = 0;         expected = f.value(x, y, z);         result = tcf.value(x, y, z);         Assert.assertEquals("On sample point",                             expected, result, 1e-14);          x = 4.5;         y = -1.5;         z = -4.25;         expected = f.value(x, y, z);         result = tcf.value(x, y, z);         Assert.assertEquals("Half-way between sample points (middle of the patch)",                             expected, result, 1e-1); // XXX Too high tolerance!     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Expm1; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test case for Divided Difference interpolator.  * <p>  * The error of polynomial interpolation is  *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!  * where f^(n) is the n-th derivative of the approximated function and  * zeta is some point in the interval determined by x[] and z.  * <p>  * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound  * it and use the absolute value upper bound for estimates. For reference,  * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.  *  */ public final class DividedDifferenceInterpolatorTest {      /**      * Test of interpolator for the sine function.      * <p>      * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateInterpolator interpolator = new DividedDifferenceInterpolator();         double x[], y[], z, expected, result, tolerance;          // 6 interpolating points on interval [0, 2*PI]         int n = 6;         double min = 0.0, max = 2 * FastMath.PI;         x = new double[n];         y = new double[n];         for (int i = 0; i < n; i++) {             x[i] = min + i * (max - min) / n;             y[i] = f.value(x[i]);         }         double derivativebound = 1.0;         UnivariateFunction p = interpolator.interpolate(x, y);          z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);          z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of interpolator for the exponential function.      * <p>      * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]      */     @Test     public void testExpm1Function() {         UnivariateFunction f = new Expm1();         UnivariateInterpolator interpolator = new DividedDifferenceInterpolator();         double x[], y[], z, expected, result, tolerance;          // 5 interpolating points on interval [-1, 1]         int n = 5;         double min = -1.0, max = 1.0;         x = new double[n];         y = new double[n];         for (int i = 0; i < n; i++) {             x[i] = min + i * (max - min) / n;             y[i] = f.value(x[i]);         }         double derivativebound = FastMath.E;         UnivariateFunction p = interpolator.interpolate(x, y);          z = 0.0; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);          z = 0.5; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);          z = -0.5; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of parameters for the interpolator.      */     @Test     public void testParameters() {         UnivariateInterpolator interpolator = new DividedDifferenceInterpolator();          try {             // bad abscissas array             double x[] = { 1.0, 2.0, 2.0, 4.0 };             double y[] = { 0.0, 4.0, 4.0, 2.5 };             UnivariateFunction p = interpolator.interpolate(x, y);             p.value(0.0);             Assert.fail("Expecting NonMonotonicSequenceException - bad abscissas array");         } catch (NonMonotonicSequenceException ex) {             // expected         }     }      /**      * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!      */     protected double partialerror(double x[], double z) throws         IllegalArgumentException {          if (x.length < 1) {             throw new IllegalArgumentException                 ("Interpolation array cannot be empty.");         }         double out = 1;         for (int i = 0; i < x.length; i++) {             out *= (z - x[i]) / (i + 1);         }         return out;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.MultivariateFunction; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for the {@link MicrosphereProjectionInterpolator  * "microsphere projection"} interpolator.  */ public final class MicrosphereProjectionInterpolatorTest {     /**      * Test of interpolator for a plane.      * <p>      * y = 2 x<sub>1</sub> - 3 x<sub>2</sub> + 5      */     @Test     public void testLinearFunction2D() {         MultivariateFunction f = new MultivariateFunction() {             @Override             public double value(double[] x) {                 if (x.length != 2) {                     throw new IllegalArgumentException();                 }                 return 2 * x[0] - 3 * x[1] + 5;             }         };          final double darkFraction = 0.5;         final double darkThreshold = 1e-2;         final double background = Double.NaN;         final double exponent = 1.1;         final boolean shareSphere = true;         final double noInterpolationTolerance = Math.ulp(1d);          // N-dimensional interpolator.         final MultivariateInterpolator interpolator             = new MicrosphereProjectionInterpolator(2, 500,                                                     darkFraction,                                                     darkThreshold,                                                     background,                                                     exponent,                                                     shareSphere,                                                     noInterpolationTolerance);          // 2D interpolator.         final MultivariateInterpolator interpolator2D             = new MicrosphereProjectionInterpolator(new InterpolatingMicrosphere2D(16,                                                                                    darkFraction,                                                                                    darkThreshold,                                                                                    background),                                                     exponent,                                                     shareSphere,                                                     noInterpolationTolerance);          final double min = -1;         final double max = 1;         final double range = max - min;         final int res = 5;         final int n = res * res; // Number of sample points.         final int dim = 2;         double[][] x = new double[n][dim];         double[] y = new double[n];         int index = 0;         for (int i = 0; i < res; i++) {             final double x1Val = toCoordinate(min, range, res, i);             for (int j = 0; j < res; j++) {                 final double x2Val = toCoordinate(min, range, res, j);                 x[index][0] = x1Val;                 x[index][1] = x2Val;                 y[index] = f.value(x[index]);                 ++index;             }         }          final MultivariateFunction p = interpolator.interpolate(x, y);         final MultivariateFunction p2D = interpolator2D.interpolate(x, y);          double[] c = new double[dim];         double expected, result, result2D;          final int sampleIndex = 2;         c[0] = x[sampleIndex][0];         c[1] = x[sampleIndex][1];         expected = f.value(c);         result = p.value(c);         result2D = p2D.value(c);         Assert.assertEquals("on sample point (exact)", expected, result2D, FastMath.ulp(1d));         Assert.assertEquals("on sample point (ND vs 2D)", result2D, result, FastMath.ulp(1d));          // Interpolation.         c[0] = 0.654321;         c[1] = -0.345678;         expected = f.value(c);         result = p.value(c);         result2D = p2D.value(c);         Assert.assertEquals("interpolation (exact)", expected, result2D, 1e-1);         Assert.assertEquals("interpolation (ND vs 2D)", result2D, result, 1e-1);          // Extrapolation.         c[0] = 0 - 1e-2;         c[1] = 1 + 1e-2;         expected = f.value(c);         result = p.value(c);         result2D = p2D.value(c);         Assert.assertFalse(Double.isNaN(result));         Assert.assertFalse(Double.isNaN(result2D));         Assert.assertEquals("extrapolation (exact)", expected, result2D, 1e-1);         Assert.assertEquals("extrapolation (ND vs 2D)", result2D, result, 1e-2);          // Far away.         c[0] = 20;         c[1] = -30;         result = p.value(c);         Assert.assertTrue(result + " should be NaN", Double.isNaN(result));         result2D = p2D.value(c);         Assert.assertTrue(result2D + " should be NaN", Double.isNaN(result2D));     }      /**      * @param min Minimum of the coordinate range.      * @param range Extent of the coordinate interval.      * @param res Number of pixels.      * @param pixel Pixel index.      */     private static double toCoordinate(double min,                                        double range,                                        int res,                                        int pixel) {         return pixel * range / (res - 1) + min;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import java.util.Random;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test for {@link UnivariatePeriodicInterpolator}.  */ public class UnivariatePeriodicInterpolatorTest {     private final Random rng = new Random(1224465L);      @Test     public void testSine() {         final int n = 30;         final double[] xval = new double[n];         final double[] yval = new double[n];         final double period = 12.3;         final double offset = 45.67;          double delta = 0;         for (int i = 0; i < n; i++) {             delta += rng.nextDouble() * period / n;             xval[i] = offset + delta;             yval[i] = FastMath.sin(xval[i]);         }          final UnivariateInterpolator inter = new LinearInterpolator();         final UnivariateFunction f = inter.interpolate(xval, yval);          final UnivariateInterpolator interP             = new UnivariatePeriodicInterpolator(new LinearInterpolator(),                                                      period, 1);         final UnivariateFunction fP = interP.interpolate(xval, yval);          // Comparing with original interpolation algorithm.         final double xMin = xval[0];         final double xMax = xval[n - 1];         for (int i = 0; i < n; i++) {             final double x = xMin + (xMax - xMin) * rng.nextDouble();             final double y = f.value(x);             final double yP = fP.value(x);              Assert.assertEquals("x=" + x, y, yP, Math.ulp(1d));         }          // Test interpolation outside the primary interval.         for (int i = 0; i < n; i++) {             final double xIn = offset + rng.nextDouble() * period;             final double xOut = xIn + rng.nextInt(123456789) * period;             final double yIn = fP.value(xIn);             final double yOut = fP.value(xOut);              Assert.assertEquals(yIn, yOut, 1e-7);         }     }      @Test     public void testLessThanOnePeriodCoverage() {         final int n = 30;         final double[] xval = new double[n];         final double[] yval = new double[n];         final double period = 12.3;         final double offset = 45.67;          double delta = period / 2;         for (int i = 0; i < n; i++) {             delta += period / (2 * n) * rng.nextDouble();             xval[i] = offset + delta;             yval[i] = FastMath.sin(xval[i]);         }          final UnivariateInterpolator interP             = new UnivariatePeriodicInterpolator(new LinearInterpolator(),                                                      period, 1);         final UnivariateFunction fP = interP.interpolate(xval, yval);          // Test interpolation outside the sample data interval.         for (int i = 0; i < n; i++) {             final double xIn = offset + rng.nextDouble() * period;             final double xOut = xIn + rng.nextInt(123456789) * period;             final double yIn = fP.value(xIn);             final double yOut = fP.value(xOut);              Assert.assertEquals(yIn, yOut, 1e-7);         }     }      @Test     public void testMoreThanOnePeriodCoverage() {         final int n = 30;         final double[] xval = new double[n];         final double[] yval = new double[n];         final double period = 12.3;         final double offset = 45.67;          double delta = period / 2;         for (int i = 0; i < n; i++) {             delta += 10 * period / n * rng.nextDouble();             xval[i] = offset + delta;             yval[i] = FastMath.sin(xval[i]);         }          final UnivariateInterpolator interP             = new UnivariatePeriodicInterpolator(new LinearInterpolator(),                                                      period, 1);         final UnivariateFunction fP = interP.interpolate(xval, yval);          // Test interpolation outside the sample data interval.         for (int i = 0; i < n; i++) {             final double xIn = offset + rng.nextDouble() * period;             final double xOut = xIn + rng.nextInt(123456789) * period;             final double yIn = fP.value(xIn);             final double yOut = fP.value(xOut);              Assert.assertEquals(yIn, yOut, 1e-6);         }     }      @Test(expected=NumberIsTooSmallException.class)     public void testTooFewSamples() {         final double[] xval = { 2, 3, 7 };         final double[] yval = { 1, 6, 5 };         final double period = 10;          final UnivariateInterpolator interpolator             = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period);         interpolator.interpolate(xval, yval);     }      @Test(expected=NonMonotonicSequenceException.class)     public void testUnsortedSamples() {         final double[] xval = { 2, 3, 7, 4, 6 };         final double[] yval = { 1, 6, 5, -1, -2 };         final double period = 10;          final UnivariateInterpolator interpolator             = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period);         interpolator.interpolate(xval, yval);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.TrivariateFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test case for the bicubic function.  */ public final class TricubicInterpolatingFunctionTest {     /**      * Test preconditions.      */     @Test     public void testPreconditions() {         double[] xval = new double[] {3, 4, 5, 6.5};         double[] yval = new double[] {-4, -3, -1, 2.5};         double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};         double[][][] fval = new double[xval.length][yval.length][zval.length];          @SuppressWarnings("unused")         TrivariateFunction tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                                    fval, fval, fval, fval,                                                                    fval, fval, fval, fval);          double[] wxval = new double[] {3, 2, 5, 6.5};         try {             tcf = new TricubicInterpolatingFunction(wxval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[] wyval = new double[] {-4, -1, -1, 2.5};         try {             tcf = new TricubicInterpolatingFunction(xval, wyval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[] wzval = new double[] {-12, -8, -9, -3, 0, 2.5};         try {             tcf = new TricubicInterpolatingFunction(xval, yval, wzval,                                                     fval, fval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[][][] wfval = new double[xval.length - 1][yval.length - 1][zval.length];         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     wfval, fval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, wfval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, wfval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, wfval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     wfval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, wfval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, wfval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, fval, wfval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         wfval = new double[xval.length][yval.length - 1][zval.length];         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     wfval, fval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, wfval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, wfval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, wfval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     wfval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, wfval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, wfval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, fval, wfval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         wfval = new double[xval.length][yval.length][zval.length - 1];         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     wfval, fval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, wfval, fval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, wfval, fval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, wfval,                                                     fval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     wfval, fval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, wfval, fval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, wfval, fval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             tcf = new TricubicInterpolatingFunction(xval, yval, zval,                                                     fval, fval, fval, fval,                                                     fval, fval, fval, wfval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }     }      /**      * @param minimumX Lower bound of interpolation range along the x-coordinate.      * @param maximumX Higher bound of interpolation range along the x-coordinate.      * @param minimumY Lower bound of interpolation range along the y-coordinate.      * @param maximumY Higher bound of interpolation range along the y-coordinate.      * @param minimumZ Lower bound of interpolation range along the z-coordinate.      * @param maximumZ Higher bound of interpolation range along the z-coordinate.      * @param numberOfElements Number of data points (along each dimension).      * @param numberOfSamples Number of test points.      * @param f Function to test.      * @param dfdx Partial derivative w.r.t. x of the function to test.      * @param dfdy Partial derivative w.r.t. y of the function to test.      * @param dfdz Partial derivative w.r.t. z of the function to test.      * @param d2fdxdy Second partial cross-derivative w.r.t x and y of the function to test.      * @param d2fdxdz Second partial cross-derivative w.r.t x and z of the function to test.      * @param d2fdydz Second partial cross-derivative w.r.t y and z of the function to test.      * @param d3fdxdydz Third partial cross-derivative w.r.t x, y and z of the function to test.      * @param meanRelativeTolerance Allowed average error (mean error on all interpolated values).      * @param maxRelativeTolerance Allowed error on each interpolated value.      * @param onDataMaxAbsoluteTolerance Allowed error on a data point.      */     private void testInterpolation(double minimumX,                                    double maximumX,                                    double minimumY,                                    double maximumY,                                    double minimumZ,                                    double maximumZ,                                    int numberOfElements,                                    int numberOfSamples,                                    TrivariateFunction f,                                    TrivariateFunction dfdx,                                    TrivariateFunction dfdy,                                    TrivariateFunction dfdz,                                    TrivariateFunction d2fdxdy,                                    TrivariateFunction d2fdxdz,                                    TrivariateFunction d2fdydz,                                    TrivariateFunction d3fdxdydz,                                    double meanRelativeTolerance,                                    double maxRelativeTolerance,                                    double onDataMaxAbsoluteTolerance,                                    boolean print) {         double expected;         double actual;         double currentX;         double currentY;         double currentZ;         final double deltaX = (maximumX - minimumX) / numberOfElements;         final double deltaY = (maximumY - minimumY) / numberOfElements;         final double deltaZ = (maximumZ - minimumZ) / numberOfElements;         final double[] xValues = new double[numberOfElements];         final double[] yValues = new double[numberOfElements];         final double[] zValues = new double[numberOfElements];         final double[][][] fValues = new double[numberOfElements][numberOfElements][numberOfElements];         final double[][][] dfdxValues = new double[numberOfElements][numberOfElements][numberOfElements];         final double[][][] dfdyValues = new double[numberOfElements][numberOfElements][numberOfElements];         final double[][][] dfdzValues = new double[numberOfElements][numberOfElements][numberOfElements];         final double[][][] d2fdxdyValues = new double[numberOfElements][numberOfElements][numberOfElements];         final double[][][] d2fdxdzValues = new double[numberOfElements][numberOfElements][numberOfElements];         final double[][][] d2fdydzValues = new double[numberOfElements][numberOfElements][numberOfElements];         final double[][][] d3fdxdydzValues = new double[numberOfElements][numberOfElements][numberOfElements];          for (int i = 0; i < numberOfElements; i++) {             xValues[i] = minimumX + deltaX * i;             final double x = xValues[i];             for (int j = 0; j < numberOfElements; j++) {                 yValues[j] = minimumY + deltaY * j;                 final double y = yValues[j];                 for (int k = 0; k < numberOfElements; k++) {                     zValues[k] = minimumZ + deltaZ * k;                     final double z = zValues[k];                     fValues[i][j][k] = f.value(x, y, z);                     dfdxValues[i][j][k] = dfdx.value(x, y, z);                     dfdyValues[i][j][k] = dfdy.value(x, y, z);                     dfdzValues[i][j][k] = dfdz.value(x, y, z);                     d2fdxdyValues[i][j][k] = d2fdxdy.value(x, y, z);                     d2fdxdzValues[i][j][k] = d2fdxdz.value(x, y, z);                     d2fdydzValues[i][j][k] = d2fdydz.value(x, y, z);                     d3fdxdydzValues[i][j][k] = d3fdxdydz.value(x, y, z);                 }             }         }          final TrivariateFunction interpolation             = new TricubicInterpolatingFunction(xValues,                                                 yValues,                                                 zValues,                                                 fValues,                                                 dfdxValues,                                                 dfdyValues,                                                 dfdzValues,                                                 d2fdxdyValues,                                                 d2fdxdzValues,                                                 d2fdydzValues,                                                 d3fdxdydzValues);          for (int i = 0; i < numberOfElements; i++) {             currentX = xValues[i];             for (int j = 0; j < numberOfElements; j++) {                 currentY = yValues[j];                 for (int k = 0; k < numberOfElements; k++) {                     currentZ = zValues[k];                     expected = f.value(currentX, currentY, currentZ);                     actual = interpolation.value(currentX, currentY, currentZ);                     Assert.assertTrue("On data point: " + expected + " != " + actual,                                       Precision.equals(expected, actual, onDataMaxAbsoluteTolerance));                 }             }         }          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234568L);         final ContinuousDistribution.Sampler distX = new UniformContinuousDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);         final ContinuousDistribution.Sampler distY = new UniformContinuousDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);         final ContinuousDistribution.Sampler distZ = new UniformContinuousDistribution(zValues[0], zValues[zValues.length - 1]).createSampler(rng);          double sumError = 0;         for (int i = 0; i < numberOfSamples; i++) {             currentX = distX.sample();             currentY = distY.sample();             currentZ = distZ.sample();             expected = f.value(currentX, currentY, currentZ);              actual = interpolation.value(currentX, currentY, currentZ);             final double relativeError = FastMath.abs(actual - expected) / FastMath.max(FastMath.abs(actual), FastMath.abs(expected));             sumError += relativeError;              if (print) {                 System.out.println(currentX + " " + currentY + " " + currentZ                                    + " " + actual                                    + " " + expected                                    + " " + (expected - actual));             }              Assert.assertEquals(0, relativeError, maxRelativeTolerance);         }          final double meanError = sumError / numberOfSamples;         Assert.assertEquals(0, meanError, meanRelativeTolerance);     }      /**      * Test for a plane.      * <p>      *  f(x, y, z) = 2 x - 3 y - 4 z + 5      * </p>      */     @Test     public void testPlane() {         final TrivariateFunction f = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 2 * x - 3 * y - 4 * z + 5;                 }             };          final TrivariateFunction dfdx = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 2;                 }             };          final TrivariateFunction dfdy = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return -3;                 }             };          final TrivariateFunction dfdz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return -4;                 }             };          final TrivariateFunction zero = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 0;                 }             };          testInterpolation(-10, 3,                           4.5, 6,                           -150, -117,                           7,                           1000,                           f,                           dfdx,                           dfdy,                           dfdz,                           zero,                           zero,                           zero,                           zero,                           1e-12,                           1e-11,                           1e-10,                           false);     }      /**      * Test for a quadric.      * <p>      *  f(x, y, z) = 2 x<sup>2</sup> - 3 y<sup>2</sup> - 4 z<sup>2</sup> + 5 x y + 6 x z - 2 y z + 3      * </p>      */     @Test     public void testQuadric() {         final TrivariateFunction f = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 2 * x * x - 3 * y * y - 4 * z * z + 5 * x * y + 6 * x * z - 2 * y * z + 3;                 }             };          final TrivariateFunction dfdx = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 4 * x + 5 * y + 6 * z;                 }             };          final TrivariateFunction dfdy = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return -6 * y + 5 * x - 2 * z;                 }             };          final TrivariateFunction dfdz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return -8 * z + 6 * x - 2 * y;                 }             };          final TrivariateFunction d2fdxdy = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 5;                 }             };          final TrivariateFunction d2fdxdz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 6;                 }             };          final TrivariateFunction d2fdydz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return -2;                 }             };          final TrivariateFunction d3fdxdydz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return 0;                 }             };          testInterpolation(-10, 3,                           4.5, 6,                           -150, -117,                           7,                           5000,                           f,                           dfdx,                           dfdy,                           dfdz,                           d2fdxdy,                           d2fdxdz,                           d2fdydz,                           d3fdxdydz,                           1e-12,                           1e-11,                           1e-8,                           false);     }      /**      * Wave.      * <p>      *  f(x, y, z) = a cos (&omega; z - k<sub>x</sub> x - k<sub>y</sub> y)      * </p>      * with a = 5, &omega; = 0.3, k<sub>x</sub> = 0.8, k<sub>y</sub> = 1.      */     @Test     public void testWave() {         final double a = 5;         final double omega = 0.3;         final double kx = 0.8;         final double ky = 1;          final TrivariateFunction arg = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return omega * z - kx * x - ky * y;                 }             };          final TrivariateFunction f = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return a * FastMath.cos(arg.value(x, y, z));                 }             };          final TrivariateFunction dfdx = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return kx * a * FastMath.sin(arg.value(x, y, z));                 }             };          final TrivariateFunction dfdy = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return ky * a * FastMath.sin(arg.value(x, y, z));                 }             };          final TrivariateFunction dfdz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return -omega * a * FastMath.sin(arg.value(x, y, z));                 }             };          final TrivariateFunction d2fdxdy = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return -ky * kx * a * FastMath.cos(arg.value(x, y, z));                 }             };          final TrivariateFunction d2fdxdz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return omega * kx * a * FastMath.cos(arg.value(x, y, z));                 }             };          final TrivariateFunction d2fdydz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return omega * ky * a * FastMath.cos(arg.value(x, y, z));                 }             };          final TrivariateFunction d3fdxdydz = new TrivariateFunction() {                 @Override                 public double value(double x, double y, double z) {                     return omega * ky * kx * a * FastMath.sin(arg.value(x, y, z));                 }             };          testInterpolation(-10, 3,                           4.5, 6,                           -150, -117,                           30,                           5000,                           f,                           dfdx,                           dfdy,                           dfdz,                           d2fdxdy,                           d2fdxdz,                           d2fdydz,                           d3fdxdydz,                           1e-3,                           1e-2,                           1e-12,                           false);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test the SplineInterpolator.  *  */ public class SplineInterpolatorTest {      /** error tolerance for spline interpolator value at knot points */     protected double knotTolerance = 1E-14;      /** error tolerance for interpolating polynomial coefficients */     protected double coefficientTolerance = 1E-14;      /** error tolerance for interpolated values -- high value is from sin test */     protected double interpolationTolerance = 1E-14;      @Test     public void testInterpolateLinearDegenerateTwoSegment()         {         double tolerance = 1e-15;         double x[] = { 0.0, 0.5, 1.0 };         double y[] = { 0.0, 0.5, 1.0 };         UnivariateInterpolator i = new SplineInterpolator();         UnivariateFunction f = i.interpolate(x, y);         verifyInterpolation(f, x, y);         verifyConsistency((PolynomialSplineFunction) f, x);          // Verify coefficients using analytical values         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();         double target[] = {y[0], 1d};         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[1], 1d};         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);          // Check interpolation         Assert.assertEquals(0.0,f.value(0.0), tolerance);         Assert.assertEquals(0.4,f.value(0.4), tolerance);         Assert.assertEquals(1.0,f.value(1.0), tolerance);     }      @Test     public void testInterpolateLinearDegenerateThreeSegment()         {         double tolerance = 1e-15;         double x[] = { 0.0, 0.5, 1.0, 1.5 };         double y[] = { 0.0, 0.5, 1.0, 1.5 };         UnivariateInterpolator i = new SplineInterpolator();         UnivariateFunction f = i.interpolate(x, y);         verifyInterpolation(f, x, y);          // Verify coefficients using analytical values         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();         double target[] = {y[0], 1d};         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[1], 1d};         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[2], 1d};         TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);          // Check interpolation         Assert.assertEquals(0,f.value(0), tolerance);         Assert.assertEquals(1.4,f.value(1.4), tolerance);         Assert.assertEquals(1.5,f.value(1.5), tolerance);     }      @Test     public void testInterpolateLinear() {         double x[] = { 0.0, 0.5, 1.0 };         double y[] = { 0.0, 0.5, 0.0 };         UnivariateInterpolator i = new SplineInterpolator();         UnivariateFunction f = i.interpolate(x, y);         verifyInterpolation(f, x, y);         verifyConsistency((PolynomialSplineFunction) f, x);          // Verify coefficients using analytical values         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();         double target[] = {y[0], 1.5d, 0d, -2d};         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);         target = new double[]{y[1], 0d, -3d, 2d};         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);     }      @Test     public void testInterpolateSin() {         double sineCoefficientTolerance = 1e-6;         double sineInterpolationTolerance = 0.0043;         double x[] =             {                 0.0,                 FastMath.PI / 6d,                 FastMath.PI / 2d,                 5d * FastMath.PI / 6d,                 FastMath.PI,                 7d * FastMath.PI / 6d,                 3d * FastMath.PI / 2d,                 11d * FastMath.PI / 6d,                 2.d * FastMath.PI };         double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };         UnivariateInterpolator i = new SplineInterpolator();         UnivariateFunction f = i.interpolate(x, y);         verifyInterpolation(f, x, y);         verifyConsistency((PolynomialSplineFunction) f, x);          /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)          *          * To replicate in R:          *     x[1] <- 0          *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)          *     g <- splinefun(x, y, "natural")          *     splinecoef <- eval(expression(z), envir = environment(g))          *     print(splinecoef)          */         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();         double target[] = {y[0], 1.002676d, 0d, -0.17415829d};         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, sineCoefficientTolerance);         target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, sineCoefficientTolerance);         target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};         TestUtils.assertEquals(polynomials[2].getCoefficients(), target, sineCoefficientTolerance);         target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};         TestUtils.assertEquals(polynomials[3].getCoefficients(), target, sineCoefficientTolerance);         target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};         TestUtils.assertEquals(polynomials[4].getCoefficients(), target, sineCoefficientTolerance);         target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};         TestUtils.assertEquals(polynomials[5].getCoefficients(), target, sineCoefficientTolerance);         target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};         TestUtils.assertEquals(polynomials[6].getCoefficients(), target, sineCoefficientTolerance);         target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};         TestUtils.assertEquals(polynomials[7].getCoefficients(), target, sineCoefficientTolerance);          //Check interpolation         Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(FastMath.PI/4d),sineInterpolationTolerance);         Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(3d*FastMath.PI/4d),sineInterpolationTolerance);     }      @Test     public void testIllegalArguments() {         // Data set arrays of different size.         UnivariateInterpolator i = new SplineInterpolator();         try {             double xval[] = { 0.0, 1.0 };             double yval[] = { 0.0, 1.0, 2.0 };             i.interpolate(xval, yval);             Assert.fail("Failed to detect data set array with different sizes.");         } catch (DimensionMismatchException iae) {             // Expected.         }         // X values not sorted.         try {             double xval[] = { 0.0, 1.0, 0.5 };             double yval[] = { 0.0, 1.0, 2.0 };             i.interpolate(xval, yval);             Assert.fail("Failed to detect unsorted arguments.");         } catch (NonMonotonicSequenceException iae) {             // Expected.         }         // Not enough data to interpolate.         try {             double xval[] = { 0.0, 1.0 };             double yval[] = { 0.0, 1.0 };             i.interpolate(xval, yval);             Assert.fail("Failed to detect unsorted arguments.");         } catch (NumberIsTooSmallException iae) {             // Expected.         }     }      /**      * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.      */     protected void verifyInterpolation(UnivariateFunction f, double x[], double y[])        {         for (int i = 0; i < x.length; i++) {             Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);         }     }      /**      * Verifies that interpolating polynomials satisfy consistency requirement:      *    adjacent polynomials must agree through two derivatives at knot points      */     protected void verifyConsistency(PolynomialSplineFunction f, double x[])         {         PolynomialFunction polynomials[] = f.getPolynomials();         for (int i = 1; i < x.length - 2; i++) {             // evaluate polynomials and derivatives at x[i + 1]             Assert.assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);             Assert.assertEquals(polynomials[i].polynomialDerivative().value(x[i +1] - x[i]),                                 polynomials[i + 1].polynomialDerivative().value(0), 0.5);             Assert.assertEquals(polynomials[i].polynomialDerivative().polynomialDerivative().value(x[i +1] - x[i]),                                 polynomials[i + 1].polynomialDerivative().polynomialDerivative().value(0), 0.5);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.BivariateFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.InsufficientDataException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  /**  * Test case for the piecewise bicubic interpolator.  */ public final class PiecewiseBicubicSplineInterpolatorTest {     /**      * Test preconditions.      */     @Test     public void testPreconditions() {         double[] xval = new double[] { 3, 4, 5, 6.5, 7.5 };         double[] yval = new double[] { -4, -3, -1, 2.5, 3.5 };         double[][] zval = new double[xval.length][yval.length];          BivariateGridInterpolator interpolator = new PiecewiseBicubicSplineInterpolator();          try {             interpolator.interpolate( null, yval, zval );             Assert.fail( "Failed to detect x null pointer" );         } catch ( NullArgumentException iae ) {             // Expected.         }          try {             interpolator.interpolate( xval, null, zval );             Assert.fail( "Failed to detect y null pointer" );         } catch ( NullArgumentException iae ) {             // Expected.         }          try {             interpolator.interpolate( xval, yval, null );             Assert.fail( "Failed to detect z null pointer" );         } catch ( NullArgumentException iae ) {             // Expected.         }          try {             double xval1[] = { 0.0, 1.0, 2.0, 3.0 };             interpolator.interpolate( xval1, yval, zval );             Assert.fail( "Failed to detect insufficient x data" );         } catch ( InsufficientDataException iae ) {             // Expected.         }          try  {             double yval1[] = { 0.0, 1.0, 2.0, 3.0 };             interpolator.interpolate( xval, yval1, zval );             Assert.fail( "Failed to detect insufficient y data" );         } catch ( InsufficientDataException iae ) {             // Expected.         }          try {             double zval1[][] = new double[4][4];             interpolator.interpolate( xval, yval, zval1 );             Assert.fail( "Failed to detect insufficient z data" );         } catch ( InsufficientDataException iae ) {             // Expected.         }          try {             double xval1[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };             interpolator.interpolate( xval1, yval, zval );             Assert.fail( "Failed to detect data set array with different sizes." );         } catch ( DimensionMismatchException iae ) {             // Expected.         }          try {             double yval1[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };             interpolator.interpolate( xval, yval1, zval );             Assert.fail( "Failed to detect data set array with different sizes." );         } catch ( DimensionMismatchException iae ) {             // Expected.         }          // X values not sorted.         try {             double xval1[] = { 0.0, 1.0, 0.5, 7.0, 3.5 };             interpolator.interpolate( xval1, yval, zval );             Assert.fail( "Failed to detect unsorted x arguments." );         } catch ( NonMonotonicSequenceException iae ) {             // Expected.         }          // Y values not sorted.         try {             double yval1[] = { 0.0, 1.0, 1.5, 0.0, 3.0 };             interpolator.interpolate( xval, yval1, zval );             Assert.fail( "Failed to detect unsorted y arguments." );         } catch ( NonMonotonicSequenceException iae ) {             // Expected.         }     }      /**      * Interpolating a plane.      * <p>      * z = 2 x - 3 y + 5      */     @Test     public void testInterpolation1() {         final int sz = 21;         double[] xval = new double[sz];         double[] yval = new double[sz];         // Coordinate values         final double delta = 1d / (sz - 1);         for ( int i = 0; i < sz; i++ ){             xval[i] = -1 + 15 * i * delta;             yval[i] = -20 + 30 * i * delta;         }          // Function values         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value( double x, double y ) {                     return 2 * x - 3 * y + 5;                 }             };         double[][] zval = new double[xval.length][yval.length];         for ( int i = 0; i < xval.length; i++ ) {             for ( int j = 0; j < yval.length; j++ ) {                 zval[i][j] = f.value(xval[i], yval[j]);             }         }          BivariateGridInterpolator interpolator = new PiecewiseBicubicSplineInterpolator();         BivariateFunction p = interpolator.interpolate(xval, yval, zval);         double x, y;          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);         final ContinuousDistribution.Sampler distX = new UniformContinuousDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);         final ContinuousDistribution.Sampler distY = new UniformContinuousDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);          final int numSamples = 50;         final double tol = 2e-14;         for ( int i = 0; i < numSamples; i++ ) {             x = distX.sample();             for ( int j = 0; j < numSamples; j++ ) {                 y = distY.sample(); //                 System.out.println(x + " " + y + " " + f.value(x, y) + " " + p.value(x, y));                 Assert.assertEquals(f.value(x, y),  p.value(x, y), tol);             } //             System.out.println();         }     }      /**      * Interpolating a paraboloid.      * <p>      * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5      */     @Test     public void testInterpolation2() {         final int sz = 21;         double[] xval = new double[sz];         double[] yval = new double[sz];         // Coordinate values         final double delta = 1d / (sz - 1);         for ( int i = 0; i < sz; i++ ) {             xval[i] = -1 + 15 * i * delta;             yval[i] = -20 + 30 * i * delta;         }          // Function values         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value( double x, double y ) {                     return 2 * x * x - 3 * y * y + 4 * x * y - 5;                 }             };         double[][] zval = new double[xval.length][yval.length];         for ( int i = 0; i < xval.length; i++ ) {             for ( int j = 0; j < yval.length; j++ ) {                 zval[i][j] = f.value(xval[i], yval[j]);             }         }          BivariateGridInterpolator interpolator = new PiecewiseBicubicSplineInterpolator();         BivariateFunction p = interpolator.interpolate(xval, yval, zval);         double x, y;          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);         final ContinuousDistribution.Sampler distX = new UniformContinuousDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);         final ContinuousDistribution.Sampler distY = new UniformContinuousDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);          final int numSamples = 50;         final double tol = 5e-13;         for ( int i = 0; i < numSamples; i++ ) {             x = distX.sample();             for ( int j = 0; j < numSamples; j++ ) {                 y = distY.sample(); //                 System.out.println(x + " " + y + " " + f.value(x, y) + " " + p.value(x, y));                 Assert.assertEquals(f.value(x, y),  p.value(x, y), tol);             } //             System.out.println();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import java.util.Random;  import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.dfp.DfpField; import org.apache.commons.math4.linear.Dfp25; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class FieldHermiteInterpolatorTest {      @Test     public void testZero() {         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         interpolator.addSamplePoint(Dfp25.of(0), new Dfp[] { Dfp25.of(0) });         for (int x = -10; x < 10; x++) {             Dfp y = interpolator.value(Dfp25.of(x))[0];             Assert.assertEquals(Dfp25.ZERO, y);             Dfp[][] derivatives = interpolator.derivatives(Dfp25.of(x), 1);             Assert.assertEquals(Dfp25.ZERO, derivatives[0][0]);             Assert.assertEquals(Dfp25.ZERO, derivatives[1][0]);         }     }      @Test     public void testQuadratic() {         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         interpolator.addSamplePoint(Dfp25.of(0), new Dfp[] { Dfp25.of(2) });         interpolator.addSamplePoint(Dfp25.of(1), new Dfp[] { Dfp25.of(0) });         interpolator.addSamplePoint(Dfp25.of(2), new Dfp[] { Dfp25.of(0) });         for (double x = -10; x < 10; x += 1.0) {             Dfp y = interpolator.value(Dfp25.of(x))[0];             Assert.assertEquals((x - 1) * (x - 2), y.toDouble(), 1.0e-15);             Dfp[][] derivatives = interpolator.derivatives(Dfp25.of(x), 3);             Assert.assertEquals((x - 1) * (x - 2), derivatives[0][0].toDouble(), 1.0e-15);             Assert.assertEquals(2 * x - 3, derivatives[1][0].toDouble(), 1.0e-15);             Assert.assertEquals(2, derivatives[2][0].toDouble(), 1.0e-15);             Assert.assertEquals(0, derivatives[3][0].toDouble(), 1.0e-15);         }     }      @Test     public void testMixedDerivatives() {         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         interpolator.addSamplePoint(Dfp25.of(0), new Dfp[] { Dfp25.of(1) }, new Dfp[] { Dfp25.of(2) });         interpolator.addSamplePoint(Dfp25.of(1), new Dfp[] { Dfp25.of(4) });         interpolator.addSamplePoint(Dfp25.of(2), new Dfp[] { Dfp25.of(5) }, new Dfp[] { Dfp25.of(2) });         Dfp[][] derivatives = interpolator.derivatives(Dfp25.of(0), 5);         Assert.assertEquals(Dfp25.of(  1), derivatives[0][0]);         Assert.assertEquals(Dfp25.of(  2), derivatives[1][0]);         Assert.assertEquals(Dfp25.of(  8), derivatives[2][0]);         Assert.assertEquals(Dfp25.of(-24), derivatives[3][0]);         Assert.assertEquals(Dfp25.of( 24), derivatives[4][0]);         Assert.assertEquals(Dfp25.of(  0), derivatives[5][0]);         derivatives = interpolator.derivatives(Dfp25.of(1), 5);         Assert.assertEquals(Dfp25.of(  4), derivatives[0][0]);         Assert.assertEquals(Dfp25.of(  2), derivatives[1][0]);         Assert.assertEquals(Dfp25.of( -4), derivatives[2][0]);         Assert.assertEquals(Dfp25.of(  0), derivatives[3][0]);         Assert.assertEquals(Dfp25.of( 24), derivatives[4][0]);         Assert.assertEquals(Dfp25.of(  0), derivatives[5][0]);         derivatives = interpolator.derivatives(Dfp25.of(2), 5);         Assert.assertEquals(Dfp25.of(  5), derivatives[0][0]);         Assert.assertEquals(Dfp25.of(  2), derivatives[1][0]);         Assert.assertEquals(Dfp25.of(  8), derivatives[2][0]);         Assert.assertEquals(Dfp25.of( 24), derivatives[3][0]);         Assert.assertEquals(Dfp25.of( 24), derivatives[4][0]);         Assert.assertEquals(Dfp25.of(  0), derivatives[5][0]);     }      @Test     public void testRandomPolynomialsValuesOnly() {          Random random = new Random(0x42b1e7dbd361a932l);          for (int i = 0; i < 100; ++i) {              int maxDegree = 0;             PolynomialFunction[] p = new PolynomialFunction[5];             for (int k = 0; k < p.length; ++k) {                 int degree = random.nextInt(7);                 p[k] = randomPolynomial(degree, random);                 maxDegree = FastMath.max(maxDegree, degree);             }              DfpField field = new DfpField(30);             Dfp step = field.getOne().divide(field.newDfp(10));             FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();             for (int j = 0; j < 1 + maxDegree; ++j) {                 Dfp x = field.newDfp(j).multiply(step);                 Dfp[] values = new Dfp[p.length];                 for (int k = 0; k < p.length; ++k) {                     values[k] = field.newDfp(p[k].value(x.getReal()));                 }                 interpolator.addSamplePoint(x, values);             }              for (int j = 0; j < 20; ++j) {                 Dfp x = field.newDfp(j).multiply(step);                 Dfp[] values = interpolator.value(x);                 Assert.assertEquals(p.length, values.length);                 for (int k = 0; k < p.length; ++k) {                     Assert.assertEquals(p[k].value(x.getReal()),                                         values[k].getReal(),                                         1.0e-8 * FastMath.abs(p[k].value(x.getReal())));                 }             }          }      }      @Test     public void testRandomPolynomialsFirstDerivative() {          Random random = new Random(0x570803c982ca5d3bl);          for (int i = 0; i < 100; ++i) {              int maxDegree = 0;             PolynomialFunction[] p      = new PolynomialFunction[5];             PolynomialFunction[] pPrime = new PolynomialFunction[5];             for (int k = 0; k < p.length; ++k) {                 int degree = random.nextInt(7);                 p[k]      = randomPolynomial(degree, random);                 pPrime[k] = p[k].polynomialDerivative();                 maxDegree = FastMath.max(maxDegree, degree);             }              DfpField field = new DfpField(30);             Dfp step = field.getOne().divide(field.newDfp(10));             FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();             for (int j = 0; j < 1 + maxDegree / 2; ++j) {                 Dfp x = field.newDfp(j).multiply(step);                 Dfp[] values      = new Dfp[p.length];                 Dfp[] derivatives = new Dfp[p.length];                 for (int k = 0; k < p.length; ++k) {                     values[k]      = field.newDfp(p[k].value(x.getReal()));                     derivatives[k] = field.newDfp(pPrime[k].value(x.getReal()));                 }                 interpolator.addSamplePoint(x, values, derivatives);             }              Dfp h = step.divide(field.newDfp(100000));             for (int j = 0; j < 20; ++j) {                 Dfp x = field.newDfp(j).multiply(step);                 Dfp[] y  = interpolator.value(x);                 Dfp[] yP = interpolator.value(x.add(h));                 Dfp[] yM = interpolator.value(x.subtract(h));                 Assert.assertEquals(p.length, y.length);                 for (int k = 0; k < p.length; ++k) {                     Assert.assertEquals(p[k].value(x.getReal()),                                         y[k].getReal(),                                         1.0e-8 * FastMath.abs(p[k].value(x.getReal())));                     Assert.assertEquals(pPrime[k].value(x.getReal()),                                         yP[k].subtract(yM[k]).divide(h.multiply(2)).getReal(),                                         4.0e-8 * FastMath.abs(p[k].value(x.getReal())));                 }             }          }     }      @Test     public void testSine() {         DfpField field = new DfpField(30);         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         for (Dfp x = field.getZero(); x.getReal() < FastMath.PI; x = x.add(0.5)) {             interpolator.addSamplePoint(x, new Dfp[] { x.sin() });         }         for (Dfp x = field.newDfp(0.1); x.getReal() < 2.9; x = x.add(0.01)) {             Dfp y = interpolator.value(x)[0];             Assert.assertEquals( x.sin().getReal(), y.getReal(), 3.5e-5);         }     }      @Test     public void testSquareRoot() {         DfpField field = new DfpField(30);         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         for (Dfp x = field.getOne(); x.getReal() < 3.6; x = x.add(0.5)) {             interpolator.addSamplePoint(x, new Dfp[] { x.sqrt() });         }         for (Dfp x = field.newDfp(1.1); x.getReal() < 3.5; x = x.add(0.01)) {             Dfp y = interpolator.value(x)[0];             Assert.assertEquals(x.sqrt().getReal(), y.getReal(), 1.5e-4);         }     }      @Test     public void testWikipedia() {         // this test corresponds to the example from Wikipedia page:         // http://en.wikipedia.org/wiki/Hermite_interpolation         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         interpolator.addSamplePoint(Dfp25.of(-1),                                     new Dfp[] { Dfp25.of( 2) },                                     new Dfp[] { Dfp25.of(-8) },                                     new Dfp[] { Dfp25.of(56) });         interpolator.addSamplePoint(Dfp25.of( 0),                                     new Dfp[] { Dfp25.of( 1) },                                     new Dfp[] { Dfp25.of( 0) },                                     new Dfp[] { Dfp25.of( 0) });         interpolator.addSamplePoint(Dfp25.of( 1),                                     new Dfp[] { Dfp25.of( 2) },                                     new Dfp[] { Dfp25.of( 8) },                                     new Dfp[] { Dfp25.of(56) });         for (Dfp x = Dfp25.of(-1); x.toDouble() <= 1.0; x = x.add(Dfp25.of(1, 8))) {             Dfp y = interpolator.value(x)[0];             Dfp x2 = x.multiply(x);             Dfp x4 = x2.multiply(x2);             Dfp x8 = x4.multiply(x4);             Assert.assertEquals(x8.add(Dfp25.of(1)), y);         }     }      @Test     public void testOnePointParabola() {         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         interpolator.addSamplePoint(Dfp25.of(0),                                     new Dfp[] { Dfp25.of(1) },                                     new Dfp[] { Dfp25.of(1) },                                     new Dfp[] { Dfp25.of(2) });         for (Dfp x = Dfp25.of(-1); x.toDouble() <= 1.0; x = x.add(Dfp25.of(1, 8))) {             Dfp y = interpolator.value(x)[0];             Assert.assertEquals(Dfp25.ONE.add(x.multiply(Dfp25.ONE.add(x))), y);         }     }      private PolynomialFunction randomPolynomial(int degree, Random random) {         double[] coeff = new double[ 1 + degree];         for (int j = 0; j < degree; ++j) {             coeff[j] = random.nextDouble();         }         return new PolynomialFunction(coeff);     }      @Test(expected=NoDataException.class)     public void testEmptySampleValue() {         new FieldHermiteInterpolator<Dfp>().value(Dfp25.ZERO);     }      @Test(expected=NoDataException.class)     public void testEmptySampleDerivative() {         new FieldHermiteInterpolator<Dfp>().derivatives(Dfp25.ZERO, 1);     }      @Test(expected=MathIllegalArgumentException.class)     public void testDuplicatedAbscissa() {         FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<>();         interpolator.addSamplePoint(Dfp25.of(1), new Dfp[] { Dfp25.of(0) });         interpolator.addSamplePoint(Dfp25.of(1), new Dfp[] { Dfp25.of(1) });     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Expm1; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test case for Neville interpolator.  * <p>  * The error of polynomial interpolation is  *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!  * where f^(n) is the n-th derivative of the approximated function and  * zeta is some point in the interval determined by x[] and z.  * <p>  * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound  * it and use the absolute value upper bound for estimates. For reference,  * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.  *  */ public final class NevilleInterpolatorTest {      /**      * Test of interpolator for the sine function.      * <p>      * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateInterpolator interpolator = new NevilleInterpolator();         double x[], y[], z, expected, result, tolerance;          // 6 interpolating points on interval [0, 2*PI]         int n = 6;         double min = 0.0, max = 2 * FastMath.PI;         x = new double[n];         y = new double[n];         for (int i = 0; i < n; i++) {             x[i] = min + i * (max - min) / n;             y[i] = f.value(x[i]);         }         double derivativebound = 1.0;         UnivariateFunction p = interpolator.interpolate(x, y);          z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);          z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of interpolator for the exponential function.      * <p>      * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]      */     @Test     public void testExpm1Function() {         UnivariateFunction f = new Expm1();         UnivariateInterpolator interpolator = new NevilleInterpolator();         double x[], y[], z, expected, result, tolerance;          // 5 interpolating points on interval [-1, 1]         int n = 5;         double min = -1.0, max = 1.0;         x = new double[n];         y = new double[n];         for (int i = 0; i < n; i++) {             x[i] = min + i * (max - min) / n;             y[i] = f.value(x[i]);         }         double derivativebound = FastMath.E;         UnivariateFunction p = interpolator.interpolate(x, y);          z = 0.0; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);          z = 0.5; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);          z = -0.5; expected = f.value(z); result = p.value(z);         tolerance = FastMath.abs(derivativebound * partialerror(x, z));         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of parameters for the interpolator.      */     @Test     public void testParameters() {         UnivariateInterpolator interpolator = new NevilleInterpolator();          try {             // bad abscissas array             double x[] = { 1.0, 2.0, 2.0, 4.0 };             double y[] = { 0.0, 4.0, 4.0, 2.5 };             UnivariateFunction p = interpolator.interpolate(x, y);             p.value(0.0);             Assert.fail("Expecting NonMonotonicSequenceException - bad abscissas array");         } catch (NonMonotonicSequenceException ex) {             // expected         }     }      /**      * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!      */     protected double partialerror(double x[], double z) throws         IllegalArgumentException {          if (x.length < 1) {             throw new IllegalArgumentException                 ("Interpolation array cannot be empty.");         }         double out = 1;         for (int i = 0; i < x.length; i++) {             out *= (z - x[i]) / (i + 1);         }         return out;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.BivariateFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test case for the bicubic function.  */ public final class BicubicInterpolatingFunctionTest {     /**      * Test preconditions.      */     @Test     public void testPreconditions() {         double[] xval = new double[] {3, 4, 5, 6.5};         double[] yval = new double[] {-4, -3, -1, 2.5};         double[][] zval = new double[xval.length][yval.length];          @SuppressWarnings("unused")         BivariateFunction bcf = new BicubicInterpolatingFunction(xval, yval, zval,                                                                  zval, zval, zval);          double[] wxval = new double[] {3, 2, 5, 6.5};         try {             bcf = new BicubicInterpolatingFunction(wxval, yval, zval, zval, zval, zval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[] wyval = new double[] {-4, -1, -1, 2.5};         try {             bcf = new BicubicInterpolatingFunction(xval, wyval, zval, zval, zval, zval);             Assert.fail("an exception should have been thrown");         } catch (MathIllegalArgumentException e) {             // Expected         }         double[][] wzval = new double[xval.length][yval.length - 1];         try {             bcf = new BicubicInterpolatingFunction(xval, yval, wzval, zval, zval, zval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             bcf = new BicubicInterpolatingFunction(xval, yval, zval, wzval, zval, zval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             bcf = new BicubicInterpolatingFunction(xval, yval, zval, zval, wzval, zval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             bcf = new BicubicInterpolatingFunction(xval, yval, zval, zval, zval, wzval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }          wzval = new double[xval.length - 1][yval.length];         try {             bcf = new BicubicInterpolatingFunction(xval, yval, wzval, zval, zval, zval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             bcf = new BicubicInterpolatingFunction(xval, yval, zval, wzval, zval, zval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             bcf = new BicubicInterpolatingFunction(xval, yval, zval, zval, wzval, zval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }         try {             bcf = new BicubicInterpolatingFunction(xval, yval, zval, zval, zval, wzval);             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             // Expected         }     }      @Test     public void testIsValidPoint() {         final double xMin = -12;         final double xMax = 34;         final double yMin = 5;         final double yMax = 67;         final double[] xval = new double[] { xMin, xMax };         final double[] yval = new double[] { yMin, yMax };         final double[][] f = new double[][] { { 1, 2 },                                               { 3, 4 } };         final double[][] dFdX = f;         final double[][] dFdY = f;         final double[][] dFdXdY = f;          final BicubicInterpolatingFunction bcf             = new BicubicInterpolatingFunction(xval, yval, f,                                                      dFdX, dFdY, dFdXdY);          double x, y;          x = xMin;         y = yMin;         Assert.assertTrue(bcf.isValidPoint(x, y));         // Ensure that no exception is thrown.         bcf.value(x, y);          x = xMax;         y = yMax;         Assert.assertTrue(bcf.isValidPoint(x, y));         // Ensure that no exception is thrown.         bcf.value(x, y);          final double xRange = xMax - xMin;         final double yRange = yMax - yMin;         x = xMin + xRange / 3.4;         y = yMin + yRange / 1.2;         Assert.assertTrue(bcf.isValidPoint(x, y));         // Ensure that no exception is thrown.         bcf.value(x, y);          final double small = 1e-8;         x = xMin - small;         y = yMax;         Assert.assertFalse(bcf.isValidPoint(x, y));         // Ensure that an exception would have been thrown.         try {             bcf.value(x, y);             Assert.fail("OutOfRangeException expected");         } catch (OutOfRangeException expected) {}          x = xMin;         y = yMax + small;         Assert.assertFalse(bcf.isValidPoint(x, y));         // Ensure that an exception would have been thrown.         try {             bcf.value(x, y);             Assert.fail("OutOfRangeException expected");         } catch (OutOfRangeException expected) {}     }      /**      * Interpolating a plane.      * <p>      * z = 2 x - 3 y + 5      */     @Test     public void testPlane() {         final int numberOfElements = 10;         final double minimumX = -10;         final double maximumX = 10;         final double minimumY = -10;         final double maximumY = 10;         final int numberOfSamples = 1000;          final double interpolationTolerance = 1e-15;         final double maxTolerance = 1e-14;          // Function values         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 2 * x - 3 * y + 5;                 }             };         BivariateFunction dfdx = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 2;                 }             };         BivariateFunction dfdy = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return -3;                 }             };         BivariateFunction d2fdxdy = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 0;                 }             };          testInterpolation(minimumX,                           maximumX,                           minimumY,                           maximumY,                           numberOfElements,                           numberOfSamples,                           f,                           dfdx,                           dfdy,                           d2fdxdy,                           interpolationTolerance,                           maxTolerance,                           false);     }      /**      * Interpolating a paraboloid.      * <p>      * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5      */     @Test     public void testParaboloid() {         final int numberOfElements = 10;         final double minimumX = -10;         final double maximumX = 10;         final double minimumY = -10;         final double maximumY = 10;         final int numberOfSamples = 1000;          final double interpolationTolerance = 2e-14;         final double maxTolerance = 1e-12;          // Function values         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 2 * x * x - 3 * y * y + 4 * x * y - 5;                 }             };         BivariateFunction dfdx = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 4 * (x + y);                 }             };         BivariateFunction dfdy = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 4 * x - 6 * y;                 }             };         BivariateFunction d2fdxdy = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 4;                 }             };          testInterpolation(minimumX,                           maximumX,                           minimumY,                           maximumY,                           numberOfElements,                           numberOfSamples,                           f,                           dfdx,                           dfdy,                           d2fdxdy,                           interpolationTolerance,                           maxTolerance,                           false);     }      /**      * @param minimumX Lower bound of interpolation range along the x-coordinate.      * @param maximumX Higher bound of interpolation range along the x-coordinate.      * @param minimumY Lower bound of interpolation range along the y-coordinate.      * @param maximumY Higher bound of interpolation range along the y-coordinate.      * @param numberOfElements Number of data points (along each dimension).      * @param numberOfSamples Number of test points.      * @param f Function to test.      * @param dfdx Partial derivative w.r.t. x of the function to test.      * @param dfdy Partial derivative w.r.t. y of the function to test.      * @param d2fdxdy Second partial cross-derivative of the function to test.      * @param meanTolerance Allowed average error (mean error on all interpolated values).      * @param maxTolerance Allowed error on each interpolated value.      */     private void testInterpolation(double minimumX,                                    double maximumX,                                    double minimumY,                                    double maximumY,                                    int numberOfElements,                                    int numberOfSamples,                                    BivariateFunction f,                                    BivariateFunction dfdx,                                    BivariateFunction dfdy,                                    BivariateFunction d2fdxdy,                                    double meanTolerance,                                    double maxTolerance,                                    boolean print) {         double expected;         double actual;         double currentX;         double currentY;         final double deltaX = (maximumX - minimumX) / numberOfElements;         final double deltaY = (maximumY - minimumY) / numberOfElements;         final double[] xValues = new double[numberOfElements];         final double[] yValues = new double[numberOfElements];         final double[][] zValues = new double[numberOfElements][numberOfElements];         final double[][] dzdx = new double[numberOfElements][numberOfElements];         final double[][] dzdy = new double[numberOfElements][numberOfElements];         final double[][] d2zdxdy = new double[numberOfElements][numberOfElements];          for (int i = 0; i < numberOfElements; i++) {             xValues[i] = minimumX + deltaX * i;             final double x = xValues[i];             for (int j = 0; j < numberOfElements; j++) {                 yValues[j] = minimumY + deltaY * j;                 final double y = yValues[j];                 zValues[i][j] = f.value(x, y);                 dzdx[i][j] = dfdx.value(x, y);                 dzdy[i][j] = dfdy.value(x, y);                 d2zdxdy[i][j] = d2fdxdy.value(x, y);             }         }          final BivariateFunction interpolation             = new BicubicInterpolatingFunction(xValues,                                                yValues,                                                zValues,                                                dzdx,                                                dzdy,                                                d2zdxdy);          for (int i = 0; i < numberOfElements; i++) {             currentX = xValues[i];             for (int j = 0; j < numberOfElements; j++) {                 currentY = yValues[j];                 expected = f.value(currentX, currentY);                 actual = interpolation.value(currentX, currentY);                 Assert.assertTrue("On data point: " + expected + " != " + actual,                                   Precision.equals(expected, actual));             }         }          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);         final ContinuousDistribution.Sampler distX = new UniformContinuousDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);         final ContinuousDistribution.Sampler distY = new UniformContinuousDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);          double sumError = 0;         for (int i = 0; i < numberOfSamples; i++) {             currentX = distX.sample();             currentY = distY.sample();             expected = f.value(currentX, currentY);              if (print) {                 System.out.println(currentX + " " + currentY + " -> ");             }              actual = interpolation.value(currentX, currentY);             sumError += FastMath.abs(actual - expected);              if (print) {                 System.out.println(actual + " (diff=" + (expected - actual) + ")");             }              Assert.assertEquals(expected, actual, maxTolerance);         }          final double meanError = sumError / numberOfSamples;         Assert.assertEquals(0, meanError, meanTolerance);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.analysis.BivariateFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.InsufficientDataException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test case for the piecewise bicubic function.  */ public final class PiecewiseBicubicSplineInterpolatingFunctionTest {     /**      * Test preconditions.      */     @Test     public void testPreconditions() {         double[] xval = new double[] { 3, 4, 5, 6.5, 7.5 };         double[] yval = new double[] { -4, -3, -1, 2.5, 3.5 };         double[][] zval = new double[xval.length][yval.length];          @SuppressWarnings("unused")         PiecewiseBicubicSplineInterpolatingFunction bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval, yval, zval);          try {             bcf = new PiecewiseBicubicSplineInterpolatingFunction(null, yval, zval);             Assert.fail("Failed to detect x null pointer");         } catch (NullArgumentException iae) {             // Expected.         }          try {             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval, null, zval);             Assert.fail("Failed to detect y null pointer");         } catch (NullArgumentException iae) {             // Expected.         }          try {             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval, yval, null);             Assert.fail("Failed to detect z null pointer");         } catch (NullArgumentException iae) {             // Expected.         }          try {             double xval1[] = { 0.0, 1.0, 2.0, 3.0 };             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval1, yval, zval);             Assert.fail("Failed to detect insufficient x data");         } catch (InsufficientDataException iae) {             // Expected.         }          try {             double yval1[] = { 0.0, 1.0, 2.0, 3.0 };             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval, yval1, zval);             Assert.fail("Failed to detect insufficient y data");         } catch (InsufficientDataException iae) {             // Expected.         }          try {             double zval1[][] = new double[4][4];             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval, yval, zval1);             Assert.fail("Failed to detect insufficient z data");         } catch (InsufficientDataException iae) {             // Expected.         }          try {             double xval1[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval1, yval, zval);             Assert.fail("Failed to detect data set array with different sizes.");         } catch (DimensionMismatchException iae) {             // Expected.         }          try {             double yval1[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval, yval1, zval);             Assert.fail("Failed to detect data set array with different sizes.");         } catch (DimensionMismatchException iae) {             // Expected.         }          // X values not sorted.         try {             double xval1[] = { 0.0, 1.0, 0.5, 7.0, 3.5 };             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval1, yval, zval);             Assert.fail("Failed to detect unsorted x arguments.");         } catch (NonMonotonicSequenceException iae) {             // Expected.         }          // Y values not sorted.         try {             double yval1[] = { 0.0, 1.0, 1.5, 0.0, 3.0 };             bcf = new PiecewiseBicubicSplineInterpolatingFunction(xval, yval1, zval);             Assert.fail("Failed to detect unsorted y arguments.");         } catch (NonMonotonicSequenceException iae) {             // Expected.         }     }      /**      * Interpolating a plane.      * <p>      * z = 2 x - 3 y + 5      */     @Test     public void testPlane() {         final int numberOfElements = 10;         final double minimumX = -10;         final double maximumX = 10;         final double minimumY = -10;         final double maximumY = 10;         final int numberOfSamples = 100;          final double interpolationTolerance = 7e-15;         final double maxTolerance = 6e-14;          // Function values         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 2 * x - 3 * y + 5;                 }             };          testInterpolation(minimumX,                           maximumX,                           minimumY,                           maximumY,                           numberOfElements,                           numberOfSamples,                           f,                           interpolationTolerance,                           maxTolerance);     }      /**      * Interpolating a paraboloid.      * <p>      * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5      */     @Test     public void testParabaloid() {         final int numberOfElements = 10;         final double minimumX = -10;         final double maximumX = 10;         final double minimumY = -10;         final double maximumY = 10;         final int numberOfSamples = 100;          final double interpolationTolerance = 1e-13;         final double maxTolerance = 6e-14;          // Function values         BivariateFunction f = new BivariateFunction() {                 @Override                 public double value(double x, double y) {                     return 2 * x * x - 3 * y * y + 4 * x * y - 5;                 }             };          testInterpolation(minimumX,                           maximumX,                           minimumY,                           maximumY,                           numberOfElements,                           numberOfSamples,                           f,                           interpolationTolerance,                           maxTolerance);     }      /**      * @param minimumX Lower bound of interpolation range along the x-coordinate.      * @param maximumX Higher bound of interpolation range along the x-coordinate.      * @param minimumY Lower bound of interpolation range along the y-coordinate.      * @param maximumY Higher bound of interpolation range along the y-coordinate.      * @param numberOfElements Number of data points (along each dimension).      * @param numberOfSamples Number of test points.      * @param f Function to test.      * @param meanTolerance Allowed average error (mean error on all interpolated values).      * @param maxTolerance Allowed error on each interpolated value.      */     private void testInterpolation(double minimumX,                                    double maximumX,                                    double minimumY,                                    double maximumY,                                    int numberOfElements,                                    int numberOfSamples,                                    BivariateFunction f,                                    double meanTolerance,                                    double maxTolerance) {         double expected;         double actual;         double currentX;         double currentY;         final double deltaX = (maximumX - minimumX) / ((double) numberOfElements);         final double deltaY = (maximumY - minimumY) / ((double) numberOfElements);         final double[] xValues = new double[numberOfElements];         final double[] yValues = new double[numberOfElements];         final double[][] zValues = new double[numberOfElements][numberOfElements];          for (int i = 0; i < numberOfElements; i++) {             xValues[i] = minimumX + deltaX * (double) i;             for (int j = 0; j < numberOfElements; j++) {                 yValues[j] = minimumY + deltaY * (double) j;                 zValues[i][j] = f.value(xValues[i], yValues[j]);             }         }          final BivariateFunction interpolation             = new PiecewiseBicubicSplineInterpolatingFunction(xValues,                                                               yValues,                                                               zValues);          for (int i = 0; i < numberOfElements; i++) {             currentX = xValues[i];             for (int j = 0; j < numberOfElements; j++) {                 currentY = yValues[j];                 expected = f.value(currentX, currentY);                 actual = interpolation.value(currentX, currentY);                 Assert.assertTrue(Precision.equals(expected, actual));             }         }          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);         final ContinuousDistribution.Sampler distX = new UniformContinuousDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);         final ContinuousDistribution.Sampler distY = new UniformContinuousDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);          double sumError = 0;         for (int i = 0; i < numberOfSamples; i++) {             currentX = distX.sample();             currentY = distY.sample();             expected = f.value(currentX, currentY);             actual = interpolation.value(currentX, currentY);             sumError += FastMath.abs(actual - expected);             Assert.assertEquals(expected, actual, maxTolerance);         }          final double meanError = sumError / numberOfSamples;         Assert.assertEquals(0, meanError, meanTolerance);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NotFiniteNumberException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test of the LoessInterpolator class.  */ public class LoessInterpolatorTest {      @Test     public void testOnOnePoint() {         double[] xval = {0.5};         double[] yval = {0.7};         double[] res = new LoessInterpolator().smooth(xval, yval);         Assert.assertEquals(1, res.length);         Assert.assertEquals(0.7, res[0], 0.0);     }      @Test     public void testOnTwoPoints() {         double[] xval = {0.5, 0.6};         double[] yval = {0.7, 0.8};         double[] res = new LoessInterpolator().smooth(xval, yval);         Assert.assertEquals(2, res.length);         Assert.assertEquals(0.7, res[0], 0.0);         Assert.assertEquals(0.8, res[1], 0.0);     }      @Test     public void testOnStraightLine() {         double[] xval = {1,2,3,4,5};         double[] yval = {2,4,6,8,10};         LoessInterpolator li = new LoessInterpolator(0.6, 2, 1e-12);         double[] res = li.smooth(xval, yval);         Assert.assertEquals(5, res.length);         for(int i = 0; i < 5; ++i) {             Assert.assertEquals(yval[i], res[i], 1e-8);         }     }      @Test     public void testOnDistortedSine() {         int numPoints = 100;         double[] xval = new double[numPoints];         double[] yval = new double[numPoints];         double xnoise = 0.1;         double ynoise = 0.2;          generateSineData(xval, yval, xnoise, ynoise);          LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);          double[] res = li.smooth(xval, yval);          // Check that the resulting curve differs from         // the "real" sine less than the jittered one          double noisyResidualSum = 0;         double fitResidualSum = 0;          for(int i = 0; i < numPoints; ++i) {             double expected = FastMath.sin(xval[i]);             double noisy = yval[i];             double fit = res[i];              noisyResidualSum += FastMath.pow(noisy - expected, 2);             fitResidualSum += FastMath.pow(fit - expected, 2);         }          Assert.assertTrue(fitResidualSum < noisyResidualSum);     }      @Test     public void testIncreasingBandwidthIncreasesSmoothness() {         int numPoints = 100;         double[] xval = new double[numPoints];         double[] yval = new double[numPoints];         double xnoise = 0.1;         double ynoise = 0.1;          generateSineData(xval, yval, xnoise, ynoise);          // Check that variance decreases as bandwidth increases          double[] bandwidths = {0.1, 0.5, 1.0};         double[] variances = new double[bandwidths.length];         for (int i = 0; i < bandwidths.length; i++) {             double bw = bandwidths[i];              LoessInterpolator li = new LoessInterpolator(bw, 4, 1e-12);              double[] res = li.smooth(xval, yval);              for (int j = 1; j < res.length; ++j) {                 variances[i] += FastMath.pow(res[j] - res[j-1], 2);             }         }          for(int i = 1; i < variances.length; ++i) {             Assert.assertTrue(variances[i] < variances[i-1]);         }     }      @Test     public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() {         int numPoints = 100;         double[] xval = new double[numPoints];         double[] yval = new double[numPoints];         double xnoise = 0.1;         double ynoise = 0.1;          generateSineData(xval, yval, xnoise, ynoise);          // Introduce a couple of outliers         yval[numPoints/3] *= 100;         yval[2 * numPoints/3] *= -100;          // Check that variance decreases as the number of robustness         // iterations increases          double[] variances = new double[4];         for (int i = 0; i < 4; i++) {             LoessInterpolator li = new LoessInterpolator(0.3, i, 1e-12);              double[] res = li.smooth(xval, yval);              for (int j = 1; j < res.length; ++j) {                 variances[i] += FastMath.abs(res[j] - res[j-1]);             }         }          for(int i = 1; i < variances.length; ++i) {             Assert.assertTrue(variances[i] < variances[i-1]);         }     }      @Test(expected=DimensionMismatchException.class)     public void testUnequalSizeArguments() {         new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4});     }      @Test(expected=NoDataException.class)     public void testEmptyData() {         new LoessInterpolator().smooth(new double[] {}, new double[] {});     }      @Test(expected=NonMonotonicSequenceException.class)     public void testNonStrictlyIncreasing1() {         new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6});     }      @Test(expected=NonMonotonicSequenceException.class)     public void testNonStrictlyIncreasing2() {         new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6});     }      @Test(expected=NotFiniteNumberException.class)     public void testNotAllFiniteReal1() {         new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5});     }      @Test(expected=NotFiniteNumberException.class)     public void testNotAllFiniteReal2() {         new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5});     }      @Test(expected=NotFiniteNumberException.class)     public void testNotAllFiniteReal3() {         new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5});     }      @Test(expected=NotFiniteNumberException.class)     public void testNotAllFiniteReal4() {         new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN});     }      @Test(expected=NotFiniteNumberException.class)     public void testNotAllFiniteReal5() {         new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY});     }      @Test(expected=NotFiniteNumberException.class)     public void testNotAllFiniteReal6() {         new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY});     }      @Test(expected=NumberIsTooSmallException.class)     public void testInsufficientBandwidth() {         LoessInterpolator li = new LoessInterpolator(0.1, 3, 1e-12);         li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});     }      @Test(expected=OutOfRangeException.class)     public void testCompletelyIncorrectBandwidth1() {         new LoessInterpolator(-0.2, 3, 1e-12);     }      @Test(expected=OutOfRangeException.class)     public void testCompletelyIncorrectBandwidth2() {         new LoessInterpolator(1.1, 3, 1e-12);     }      @Test     public void testMath296withoutWeights() {         double[] xval = {                 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,                  1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0};         double[] yval = {                 0.47, 0.48, 0.55, 0.56, -0.08, -0.04, -0.07, -0.07,                 -0.56, -0.46, -0.56, -0.52, -3.03, -3.08, -3.09,                 -3.04, 3.54, 3.46, 3.36, 3.35};         // Output from R, rounded to .001         double[] yref = {                 0.461, 0.499, 0.541, 0.308, 0.175, -0.042, -0.072,                 -0.196, -0.311, -0.446, -0.557, -1.497, -2.133,                 -3.08, -3.09, -0.621, 0.982, 3.449, 3.389, 3.336         };         LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);         double[] res = li.smooth(xval, yval);         Assert.assertEquals(xval.length, res.length);         for(int i = 0; i < res.length; ++i) {             Assert.assertEquals(yref[i], res[i], 0.02);         }     }      private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {         double dx = 2 * FastMath.PI / xval.length;         double x = 0;         for(int i = 0; i < xval.length; ++i) {             xval[i] = x;             yval[i] = FastMath.sin(x) + (2 * FastMath.random() - 1) * ynoise;             x += dx * (1 + (2 * FastMath.random() - 1) * xnoise);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import java.util.Random;  import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class HermiteInterpolatorTest {      @Test     public void testZero() {         HermiteInterpolator interpolator = new HermiteInterpolator();         interpolator.addSamplePoint(0.0, new double[] { 0.0 });         for (double x = -10; x < 10; x += 1.0) {             DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0];             Assert.assertEquals(0.0, y.getValue(), 1.0e-15);             Assert.assertEquals(0.0, y.getPartialDerivative(1), 1.0e-15);         }         checkPolynomial(new PolynomialFunction(new double[] { 0.0 }),                         interpolator.getPolynomials()[0]);     }      @Test     public void testQuadratic() {         HermiteInterpolator interpolator = new HermiteInterpolator();         interpolator.addSamplePoint(0.0, new double[] { 2.0 });         interpolator.addSamplePoint(1.0, new double[] { 0.0 });         interpolator.addSamplePoint(2.0, new double[] { 0.0 });         for (double x = -10; x < 10; x += 1.0) {             DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0];             Assert.assertEquals((x - 1.0) * (x - 2.0), y.getValue(), 1.0e-15);             Assert.assertEquals(2 * x - 3.0, y.getPartialDerivative(1), 1.0e-15);         }         checkPolynomial(new PolynomialFunction(new double[] { 2.0, -3.0, 1.0 }),                         interpolator.getPolynomials()[0]);     }      @Test     public void testMixedDerivatives() {         HermiteInterpolator interpolator = new HermiteInterpolator();         interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });         interpolator.addSamplePoint(1.0, new double[] { 4.0 });         interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });         Assert.assertEquals(4, interpolator.getPolynomials()[0].degree());         DerivativeStructure y0 = interpolator.value(new DerivativeStructure(1, 1, 0, 0.0))[0];         Assert.assertEquals(1.0, y0.getValue(), 1.0e-15);         Assert.assertEquals(2.0, y0.getPartialDerivative(1), 1.0e-15);         Assert.assertEquals(4.0, interpolator.value(1.0)[0], 1.0e-15);         DerivativeStructure y2 = interpolator.value(new DerivativeStructure(1, 1, 0, 2.0))[0];         Assert.assertEquals(5.0, y2.getValue(), 1.0e-15);         Assert.assertEquals(2.0, y2.getPartialDerivative(1), 1.0e-15);         checkPolynomial(new PolynomialFunction(new double[] { 1.0, 2.0, 4.0, -4.0, 1.0 }),                         interpolator.getPolynomials()[0]);     }      @Test     public void testRandomPolynomialsValuesOnly() {          Random random = new Random(0x42b1e7dbd361a932l);          for (int i = 0; i < 100; ++i) {              int maxDegree = 0;             PolynomialFunction[] p = new PolynomialFunction[5];             for (int k = 0; k < p.length; ++k) {                 int degree = random.nextInt(7);                 p[k] = randomPolynomial(degree, random);                 maxDegree = FastMath.max(maxDegree, degree);             }              HermiteInterpolator interpolator = new HermiteInterpolator();             for (int j = 0; j < 1 + maxDegree; ++j) {                 double x = 0.1 * j;                 double[] values = new double[p.length];                 for (int k = 0; k < p.length; ++k) {                     values[k] = p[k].value(x);                 }                 interpolator.addSamplePoint(x, values);             }              for (double x = 0; x < 2; x += 0.1) {                 double[] values = interpolator.value(x);                 Assert.assertEquals(p.length, values.length);                 for (int k = 0; k < p.length; ++k) {                     Assert.assertEquals(p[k].value(x), values[k], 1.0e-8 * FastMath.abs(p[k].value(x)));                 }             }              PolynomialFunction[] result = interpolator.getPolynomials();             for (int k = 0; k < p.length; ++k) {                 checkPolynomial(p[k], result[k]);             }          }     }      @Test     public void testRandomPolynomialsFirstDerivative() {          Random random = new Random(0x570803c982ca5d3bl);          for (int i = 0; i < 100; ++i) {              int maxDegree = 0;             PolynomialFunction[] p      = new PolynomialFunction[5];             PolynomialFunction[] pPrime = new PolynomialFunction[5];             for (int k = 0; k < p.length; ++k) {                 int degree = random.nextInt(7);                 p[k]      = randomPolynomial(degree, random);                 pPrime[k] = p[k].polynomialDerivative();                 maxDegree = FastMath.max(maxDegree, degree);             }              HermiteInterpolator interpolator = new HermiteInterpolator();             for (int j = 0; j < 1 + maxDegree / 2; ++j) {                 double x = 0.1 * j;                 double[] values      = new double[p.length];                 double[] derivatives = new double[p.length];                 for (int k = 0; k < p.length; ++k) {                     values[k]      = p[k].value(x);                     derivatives[k] = pPrime[k].value(x);                 }                 interpolator.addSamplePoint(x, values, derivatives);             }              for (double x = 0; x < 2; x += 0.1) {                 DerivativeStructure[] y = interpolator.value(new DerivativeStructure(1, 1, 0, x));                 Assert.assertEquals(p.length, y.length);                 for (int k = 0; k < p.length; ++k) {                     Assert.assertEquals(p[k].value(x), y[k].getValue(), 1.0e-8 * FastMath.abs(p[k].value(x)));                     Assert.assertEquals(pPrime[k].value(x), y[k].getPartialDerivative(1), 4.0e-8 * FastMath.abs(p[k].value(x)));                 }             }              PolynomialFunction[] result = interpolator.getPolynomials();             for (int k = 0; k < p.length; ++k) {                 checkPolynomial(p[k], result[k]);             }          }     }      @Test     public void testSine() {         HermiteInterpolator interpolator = new HermiteInterpolator();         for (double x = 0; x < FastMath.PI; x += 0.5) {             interpolator.addSamplePoint(x, new double[] { FastMath.sin(x) });         }         for (double x = 0.1; x <= 2.9; x += 0.01) {             DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 2, 0, x))[0];             Assert.assertEquals( FastMath.sin(x), y.getValue(), 3.5e-5);             Assert.assertEquals( FastMath.cos(x), y.getPartialDerivative(1), 1.3e-4);             Assert.assertEquals(-FastMath.sin(x), y.getPartialDerivative(2), 2.9e-3);         }     }      @Test     public void testSquareRoot() {         HermiteInterpolator interpolator = new HermiteInterpolator();         for (double x = 1.0; x < 3.6; x += 0.5) {             interpolator.addSamplePoint(x, new double[] { FastMath.sqrt(x) });         }         for (double x = 1.1; x < 3.5; x += 0.01) {             DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0];             Assert.assertEquals(FastMath.sqrt(x), y.getValue(), 1.5e-4);             Assert.assertEquals(0.5 / FastMath.sqrt(x), y.getPartialDerivative(1), 8.5e-4);         }     }      @Test     public void testWikipedia() {         // this test corresponds to the example from Wikipedia page:         // http://en.wikipedia.org/wiki/Hermite_interpolation         HermiteInterpolator interpolator = new HermiteInterpolator();         interpolator.addSamplePoint(-1, new double[] { 2 }, new double[] { -8 }, new double[] { 56 });         interpolator.addSamplePoint( 0, new double[] { 1 }, new double[] {  0 }, new double[] {  0 });         interpolator.addSamplePoint( 1, new double[] { 2 }, new double[] {  8 }, new double[] { 56 });         for (double x = -1.0; x <= 1.0; x += 0.125) {             DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0];             double x2 = x * x;             double x4 = x2 * x2;             double x8 = x4 * x4;             Assert.assertEquals(x8 + 1, y.getValue(), 1.0e-15);             Assert.assertEquals(8 * x4 * x2 * x, y.getPartialDerivative(1), 1.0e-15);         }         checkPolynomial(new PolynomialFunction(new double[] { 1, 0, 0, 0, 0, 0, 0, 0, 1 }),                         interpolator.getPolynomials()[0]);     }      @Test     public void testOnePointParabola() {         HermiteInterpolator interpolator = new HermiteInterpolator();         interpolator.addSamplePoint(0, new double[] { 1 }, new double[] { 1 }, new double[] { 2 });         for (double x = -1.0; x <= 1.0; x += 0.125) {             DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0];             Assert.assertEquals(1 + x * (1 + x), y.getValue(), 1.0e-15);             Assert.assertEquals(1 + 2 * x, y.getPartialDerivative(1), 1.0e-15);         }         checkPolynomial(new PolynomialFunction(new double[] { 1, 1, 1 }),                         interpolator.getPolynomials()[0]);     }      private PolynomialFunction randomPolynomial(int degree, Random random) {         double[] coeff = new double[ 1 + degree];         for (int j = 0; j < degree; ++j) {             coeff[j] = random.nextDouble();         }         return new PolynomialFunction(coeff);     }      @Test(expected=NoDataException.class)     public void testEmptySample() {         new HermiteInterpolator().value(0.0);     }      @Test(expected=MathIllegalArgumentException.class)     public void testDuplicatedAbscissa() {         HermiteInterpolator interpolator = new HermiteInterpolator();         interpolator.addSamplePoint(1.0, new double[] { 0.0 });         interpolator.addSamplePoint(1.0, new double[] { 1.0 });     }      private void checkPolynomial(PolynomialFunction expected, PolynomialFunction result) {         Assert.assertTrue(result.degree() >= expected.degree());         double[] cE = expected.getCoefficients();         double[] cR = result.getCoefficients();         for (int i = 0; i < cE.length; ++i) {             Assert.assertEquals(cE[i], cR[i], 1.0e-8 * FastMath.abs(cE[i]));         }         for (int i = cE.length; i < cR.length; ++i) {             Assert.assertEquals(0.0, cR[i], 1.0e-9);         }     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.interpolation;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  public class AkimaSplineInterpolatorTest {      @Test     public void testIllegalArguments()     {         // Data set arrays of different size.         UnivariateInterpolator i = new AkimaSplineInterpolator();          try         {             double yval[] = { 0.0, 1.0, 2.0, 3.0, 4.0 };             i.interpolate( null, yval );             Assert.fail( "Failed to detect x null pointer" );         }         catch ( NullArgumentException iae )         {             // Expected.         }          try         {             double xval[] = { 0.0, 1.0, 2.0, 3.0, 4.0 };             i.interpolate( xval, null );             Assert.fail( "Failed to detect y null pointer" );         }         catch ( NullArgumentException iae )         {             // Expected.         }          try         {             double xval[] = { 0.0, 1.0, 2.0, 3.0 };             double yval[] = { 0.0, 1.0, 2.0, 3.0 };             i.interpolate( xval, yval );             Assert.fail( "Failed to detect insufficient data" );         }         catch ( NumberIsTooSmallException iae )         {             // Expected.         }          try         {             double xval[] = { 0.0, 1.0, 2.0, 3.0, 4.0 };             double yval[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0 };             i.interpolate( xval, yval );             Assert.fail( "Failed to detect data set array with different sizes." );         }         catch ( DimensionMismatchException iae )         {             // Expected.         }          // X values not sorted.         try         {             double xval[] = { 0.0, 1.0, 0.5, 7.0, 3.5, 2.2, 8.0 };             double yval[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };             i.interpolate( xval, yval );             Assert.fail( "Failed to detect unsorted arguments." );         }         catch ( NonMonotonicSequenceException iae )         {             // Expected.         }     }      /*      * Interpolate a straight line. <p> y = 2 x - 5 <p> Tolerances determined by performing same calculation using      * Math.NET over ten runs of 100 random number draws for the same function over the same span with the same number      * of elements      */     @Test     public void testInterpolateLine()     {         final int numberOfElements = 10;         final double minimumX = -10;         final double maximumX = 10;         final int numberOfSamples = 100;         final double interpolationTolerance = 1e-15;         final double maxTolerance = 1e-15;          UnivariateFunction f = new UnivariateFunction()         {             @Override             public double value( double x )             {                 return 2 * x - 5;             }         };          testInterpolation( minimumX, maximumX, numberOfElements, numberOfSamples, f, interpolationTolerance,                            maxTolerance );     }      /*      * Interpolate a straight line. <p> y = 3 x<sup>2</sup> - 5 x + 7 <p> Tolerances determined by performing same      * calculation using Math.NET over ten runs of 100 random number draws for the same function over the same span with      * the same number of elements      */      @Test     public void testInterpolateParabola()     {         final int numberOfElements = 10;         final double minimumX = -10;         final double maximumX = 10;         final int numberOfSamples = 100;         final double interpolationTolerance = 7e-15;         final double maxTolerance = 6e-14;          UnivariateFunction f = new UnivariateFunction()         {             @Override             public double value( double x )             {                 return ( 3 * x * x ) - ( 5 * x ) + 7;             }         };          testInterpolation( minimumX, maximumX, numberOfElements, numberOfSamples, f, interpolationTolerance,                            maxTolerance );     }      /*      * Interpolate a straight line. <p> y = 3 x<sup>3</sup> - 0.5 x<sup>2</sup> + x - 1 <p> Tolerances determined by      * performing same calculation using Math.NET over ten runs of 100 random number draws for the same function over      * the same span with the same number of elements      */     @Test     public void testInterpolateCubic()     {         final int numberOfElements = 10;         final double minimumX = -3;         final double maximumX = 3;         final int numberOfSamples = 100;         final double interpolationTolerance = 0.37;         final double maxTolerance = 3.8;          UnivariateFunction f = new UnivariateFunction()         {             @Override             public double value( double x )             {                 return ( 3 * x * x * x ) - ( 0.5 * x * x ) + ( 1 * x ) - 1;             }         };          testInterpolation( minimumX, maximumX, numberOfElements, numberOfSamples, f, interpolationTolerance,                            maxTolerance );     }      @Test     public void testOriginalVsModified() {         final UnivariateFunction f = new UnivariateFunction() {             @Override             public double value(double x) {                 return x < -1 ? -1 :                     x < 1 ? x : 1;             }         };          final double[] xS = new double[] {-1, 0, 1, 2, 3 };         final double[] yS = new double[xS.length];          for (int i = 0; i < xS.length; i++) {             yS[i] = f.value(xS[i]);         }          final UnivariateFunction iOriginal = new AkimaSplineInterpolator(false).interpolate(xS, yS);         final UnivariateFunction iModified = new AkimaSplineInterpolator(true).interpolate(xS, yS);          final int n = 100;         final double delta = 1d / n;         for (int i = 1; i < n - 1; i++) {             final double x = 2 - i * delta;              final double value = f.value(x);             final double diffOriginal = Math.abs(iOriginal.value(x) - value);             final double diffModified = Math.abs(iModified.value(x) - value);              // In interval (1, 2), the modified algorithm eliminates interpolation artefacts.             Assert.assertTrue(diffOriginal > 0);             Assert.assertEquals(0d, diffModified, 0d);         }     }      private void testInterpolation( double minimumX, double maximumX, int numberOfElements, int numberOfSamples,                                     UnivariateFunction f, double tolerance, double maxTolerance )     {         double expected;         double actual;         double currentX;         final double delta = ( maximumX - minimumX ) / ( (double) numberOfElements );         double xValues[] = new double[numberOfElements];         double yValues[] = new double[numberOfElements];          for ( int i = 0; i < numberOfElements; i++ )         {             xValues[i] = minimumX + delta * (double) i;             yValues[i] = f.value( xValues[i] );         }          UnivariateFunction interpolation = new AkimaSplineInterpolator().interpolate( xValues, yValues );          for ( int i = 0; i < numberOfElements; i++ )         {             currentX = xValues[i];             expected = f.value( currentX );             actual = interpolation.value( currentX );             assertTrue( Precision.equals( expected, actual ) );         }          final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L); // "tol" depends on the seed.         final ContinuousDistribution.Sampler distX =             new UniformContinuousDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);          double sumError = 0;         for ( int i = 0; i < numberOfSamples; i++ )         {             currentX = distX.sample();             expected = f.value( currentX );             actual = interpolation.value( currentX );             sumError += FastMath.abs( actual - expected );             assertEquals( expected, actual, maxTolerance );         }          assertEquals( 0.0, ( sumError / (double) numberOfSamples ), tolerance );     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis;  import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.MultivariateDifferentiableFunction; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math4.analysis.function.Add; import org.apache.commons.math4.analysis.function.Constant; import org.apache.commons.math4.analysis.function.Cos; import org.apache.commons.math4.analysis.function.Cosh; import org.apache.commons.math4.analysis.function.Divide; import org.apache.commons.math4.analysis.function.Identity; import org.apache.commons.math4.analysis.function.Inverse; import org.apache.commons.math4.analysis.function.Log; import org.apache.commons.math4.analysis.function.Max; import org.apache.commons.math4.analysis.function.Min; import org.apache.commons.math4.analysis.function.Minus; import org.apache.commons.math4.analysis.function.Multiply; import org.apache.commons.math4.analysis.function.Pow; import org.apache.commons.math4.analysis.function.Power; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.function.Sinc; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for {@link FunctionUtils}.  */ public class FunctionUtilsTest {     private final double EPS = FastMath.ulp(1d);      @Test     public void testCompose() {         UnivariateFunction id = new Identity();         Assert.assertEquals(3, FunctionUtils.compose(id, id, id).value(3), EPS);          UnivariateFunction c = new Constant(4);         Assert.assertEquals(4, FunctionUtils.compose(id, c).value(3), EPS);         Assert.assertEquals(4, FunctionUtils.compose(c, id).value(3), EPS);          UnivariateFunction m = new Minus();         Assert.assertEquals(-3, FunctionUtils.compose(m).value(3), EPS);         Assert.assertEquals(3, FunctionUtils.compose(m, m).value(3), EPS);          UnivariateFunction inv = new Inverse();         Assert.assertEquals(-0.25, FunctionUtils.compose(inv, m, c, id).value(3), EPS);          UnivariateFunction pow = new Power(2);         Assert.assertEquals(81, FunctionUtils.compose(pow, pow).value(3), EPS);     }      @Test     public void testComposeDifferentiable() {         UnivariateDifferentiableFunction id = new Identity();         Assert.assertEquals(1, FunctionUtils.compose(id, id, id).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS);          UnivariateDifferentiableFunction c = new Constant(4);         Assert.assertEquals(0, FunctionUtils.compose(id, c).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS);         Assert.assertEquals(0, FunctionUtils.compose(c, id).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS);          UnivariateDifferentiableFunction m = new Minus();         Assert.assertEquals(-1, FunctionUtils.compose(m).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS);         Assert.assertEquals(1, FunctionUtils.compose(m, m).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS);          UnivariateDifferentiableFunction inv = new Inverse();         Assert.assertEquals(0.25, FunctionUtils.compose(inv, m, id).value(new DerivativeStructure(1, 1, 0, 2)).getPartialDerivative(1), EPS);          UnivariateDifferentiableFunction pow = new Power(2);         Assert.assertEquals(108, FunctionUtils.compose(pow, pow).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS);          UnivariateDifferentiableFunction log = new Log();         double a = 9876.54321;         Assert.assertEquals(pow.value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1) / pow.value(a),                             FunctionUtils.compose(log, pow).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), EPS);     }      @Test     public void testAdd() {         UnivariateFunction id = new Identity();         UnivariateFunction c = new Constant(4);         UnivariateFunction m = new Minus();         UnivariateFunction inv = new Inverse();          Assert.assertEquals(4.5, FunctionUtils.add(inv, m, c, id).value(2), EPS);         Assert.assertEquals(4 + 2, FunctionUtils.add(c, id).value(2), EPS);         Assert.assertEquals(4 - 2, FunctionUtils.add(c, FunctionUtils.compose(m, id)).value(2), EPS);     }      @Test     public void testAddDifferentiable() {         UnivariateDifferentiableFunction sin = new Sin();         UnivariateDifferentiableFunction c = new Constant(4);         UnivariateDifferentiableFunction m = new Minus();         UnivariateDifferentiableFunction inv = new Inverse();          final double a = 123.456;         Assert.assertEquals(- 1 / (a * a) -1 + FastMath.cos(a),                             FunctionUtils.add(inv, m, c, sin).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1),                             EPS);     }      @Test     public void testMultiply() {         UnivariateFunction c = new Constant(4);         Assert.assertEquals(16, FunctionUtils.multiply(c, c).value(12345), EPS);          UnivariateFunction inv = new Inverse();         UnivariateFunction pow = new Power(2);         Assert.assertEquals(1, FunctionUtils.multiply(FunctionUtils.compose(inv, pow), pow).value(3.5), EPS);     }      @Test     public void testMultiplyDifferentiable() {         UnivariateDifferentiableFunction c = new Constant(4);         UnivariateDifferentiableFunction id = new Identity();         final double a = 1.2345678;         Assert.assertEquals(8 * a, FunctionUtils.multiply(c, id, id).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), EPS);          UnivariateDifferentiableFunction inv = new Inverse();         UnivariateDifferentiableFunction pow = new Power(2.5);         UnivariateDifferentiableFunction cos = new Cos();         Assert.assertEquals(1.5 * FastMath.sqrt(a) * FastMath.cos(a) - FastMath.pow(a, 1.5) * FastMath.sin(a),                             FunctionUtils.multiply(inv, pow, cos).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), EPS);          UnivariateDifferentiableFunction cosh = new Cosh();         Assert.assertEquals(1.5 * FastMath.sqrt(a) * FastMath.cosh(a) + FastMath.pow(a, 1.5) * FastMath.sinh(a),                             FunctionUtils.multiply(inv, pow, cosh).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), 8 * EPS);     }      @Test     public void testCombine() {         BivariateFunction bi = new Add();         UnivariateFunction id = new Identity();         UnivariateFunction m = new Minus();         UnivariateFunction c = FunctionUtils.combine(bi, id, m);         Assert.assertEquals(0, c.value(2.3456), EPS);          bi = new Multiply();         UnivariateFunction inv = new Inverse();         c = FunctionUtils.combine(bi, id, inv);         Assert.assertEquals(1, c.value(2.3456), EPS);     }      @Test     public void testCollector() {         BivariateFunction bi = new Add();         MultivariateFunction coll = FunctionUtils.collector(bi, 0);         Assert.assertEquals(10, coll.value(new double[] {1, 2, 3, 4}), EPS);          bi = new Multiply();         coll = FunctionUtils.collector(bi, 1);         Assert.assertEquals(24, coll.value(new double[] {1, 2, 3, 4}), EPS);          bi = new Max();         coll = FunctionUtils.collector(bi, Double.NEGATIVE_INFINITY);         Assert.assertEquals(10, coll.value(new double[] {1, -2, 7.5, 10, -24, 9.99}), 0);          bi = new Min();         coll = FunctionUtils.collector(bi, Double.POSITIVE_INFINITY);         Assert.assertEquals(-24, coll.value(new double[] {1, -2, 7.5, 10, -24, 9.99}), 0);     }      @Test     public void testSinc() {         BivariateFunction div = new Divide();         UnivariateFunction sin = new Sin();         UnivariateFunction id = new Identity();         UnivariateFunction sinc1 = FunctionUtils.combine(div, sin, id);         UnivariateFunction sinc2 = new Sinc();          for (int i = 0; i < 10; i++) {             double x = FastMath.random();             Assert.assertEquals(sinc1.value(x), sinc2.value(x), EPS);         }     }      @Test     public void testFixingArguments() {         UnivariateFunction scaler = FunctionUtils.fix1stArgument(new Multiply(), 10);         Assert.assertEquals(1.23456, scaler.value(0.123456), EPS);          UnivariateFunction pow1 = new Power(2);         UnivariateFunction pow2 = FunctionUtils.fix2ndArgument(new Pow(), 2);          for (int i = 0; i < 10; i++) {             double x = FastMath.random() * 10;             Assert.assertEquals(pow1.value(x), pow2.value(x), 0);         }     }      @Test(expected = NumberIsTooLargeException.class)     public void testSampleWrongBounds(){         FunctionUtils.sample(new Sin(), FastMath.PI, 0.0, 10);     }      @Test(expected = NotStrictlyPositiveException.class)     public void testSampleNegativeNumberOfPoints(){         FunctionUtils.sample(new Sin(), 0.0, FastMath.PI, -1);     }      @Test(expected = NotStrictlyPositiveException.class)     public void testSampleNullNumberOfPoints(){         FunctionUtils.sample(new Sin(), 0.0, FastMath.PI, 0);     }      @Test     public void testSample() {         final int n = 11;         final double min = 0.0;         final double max = FastMath.PI;         final double[] actual = FunctionUtils.sample(new Sin(), min, max, n);         for (int i = 0; i < n; i++) {             final double x = min + (max - min) / n * i;             Assert.assertEquals("x = " + x, FastMath.sin(x), actual[i], 0.0);         }     }      @Test     public void testToDifferentiableUnivariate() {          final UnivariateFunction f0 = new UnivariateFunction() {             @Override             public double value(final double x) {                 return x * x;             }         };         final UnivariateFunction f1 = new UnivariateFunction() {             @Override             public double value(final double x) {                 return 2 * x;             }         };         final UnivariateFunction f2 = new UnivariateFunction() {             @Override             public double value(final double x) {                 return 2;             }         };         final UnivariateDifferentiableFunction f = FunctionUtils.toDifferentiable(f0, f1, f2);          for (double t = -1.0; t < 1; t += 0.01) {             // x = sin(t)             DerivativeStructure dsT = new DerivativeStructure(1, 2, 0, t);             DerivativeStructure y = f.value(dsT.sin());             Assert.assertEquals(FastMath.sin(t) * FastMath.sin(t),               f.value(FastMath.sin(t)),  1.0e-15);             Assert.assertEquals(FastMath.sin(t) * FastMath.sin(t),               y.getValue(),              1.0e-15);             Assert.assertEquals(2 * FastMath.cos(t) * FastMath.sin(t),           y.getPartialDerivative(1), 1.0e-15);             Assert.assertEquals(2 * (1 - 2 * FastMath.sin(t) * FastMath.sin(t)), y.getPartialDerivative(2), 1.0e-15);         }          try {             f.value(new DerivativeStructure(1, 3, 0.0));             Assert.fail("an exception should have been thrown");         } catch (NumberIsTooLargeException e) {             Assert.assertEquals(2, e.getMax());             Assert.assertEquals(3, e.getArgument());         }     }      @Test     public void testToDifferentiableMultivariate() {          final double a = 1.5;         final double b = 0.5;         final MultivariateFunction f = new MultivariateFunction() {             @Override             public double value(final double[] point) {                 return a * point[0] + b * point[1];             }         };         final MultivariateVectorFunction gradient = new MultivariateVectorFunction() {             @Override             public double[] value(final double[] point) {                 return new double[] { a, b };             }         };         final MultivariateDifferentiableFunction mdf = FunctionUtils.toDifferentiable(f, gradient);          for (double t = -1.0; t < 1; t += 0.01) {             // x = sin(t), y = cos(t), hence the method really becomes univariate             DerivativeStructure dsT = new DerivativeStructure(1, 1, 0, t);             DerivativeStructure y = mdf.value(new DerivativeStructure[] { dsT.sin(), dsT.cos() });             Assert.assertEquals(a * FastMath.sin(t) + b * FastMath.cos(t), y.getValue(),              1.0e-15);             Assert.assertEquals(a * FastMath.cos(t) - b * FastMath.sin(t), y.getPartialDerivative(1), 1.0e-15);         }          for (double u = -1.0; u < 1; u += 0.01) {             DerivativeStructure dsU = new DerivativeStructure(2, 1, 0, u);             for (double v = -1.0; v < 1; v += 0.01) {                 DerivativeStructure dsV = new DerivativeStructure(2, 1, 1, v);                 DerivativeStructure y = mdf.value(new DerivativeStructure[] { dsU, dsV });                 Assert.assertEquals(a * u + b * v, mdf.value(new double[] { u, v }), 1.0e-15);                 Assert.assertEquals(a * u + b * v, y.getValue(),                     1.0e-15);                 Assert.assertEquals(a,             y.getPartialDerivative(1, 0),     1.0e-15);                 Assert.assertEquals(b,             y.getPartialDerivative(0, 1),     1.0e-15);             }         }          try {             mdf.value(new DerivativeStructure[] { new DerivativeStructure(1, 3, 0.0), new DerivativeStructure(1, 3, 0.0) });             Assert.fail("an exception should have been thrown");         } catch (NumberIsTooLargeException e) {             Assert.assertEquals(1, e.getMax());             Assert.assertEquals(3, e.getArgument());         }     }      @Test     public void testToDifferentiableMultivariateInconsistentGradient() {          final double a = 1.5;         final double b = 0.5;         final MultivariateFunction f = new MultivariateFunction() {             @Override             public double value(final double[] point) {                 return a * point[0] + b * point[1];             }         };         final MultivariateVectorFunction gradient = new MultivariateVectorFunction() {             @Override             public double[] value(final double[] point) {                 return new double[] { a, b, 0.0 };             }         };         final MultivariateDifferentiableFunction mdf = FunctionUtils.toDifferentiable(f, gradient);          try {             DerivativeStructure dsT = new DerivativeStructure(1, 1, 0, 0.0);             mdf.value(new DerivativeStructure[] { dsT.sin(), dsT.cos() });             Assert.fail("an exception should have been thrown");         } catch (DimensionMismatchException e) {             Assert.assertEquals(2, e.getDimension());             Assert.assertEquals(3, e.getArgument());         }     }      @Test     public void testDerivativeUnivariate() {          final UnivariateDifferentiableFunction f = new UnivariateDifferentiableFunction() {              @Override             public double value(double x) {                 return x * x;             }              @Override             public DerivativeStructure value(DerivativeStructure x) {                 return x.multiply(x);             }          };          final UnivariateFunction f0 = FunctionUtils.derivative(f, 0);         final UnivariateFunction f1 = FunctionUtils.derivative(f, 1);         final UnivariateFunction f2 = FunctionUtils.derivative(f, 2);          for (double t = -1.0; t < 1; t += 0.01) {             Assert.assertEquals(t * t, f0.value(t), 1.0e-15);             Assert.assertEquals(2 * t, f1.value(t), 1.0e-15);             Assert.assertEquals(2,     f2.value(t), 1.0e-15);         }      }      @Test     public void testDerivativeMultivariate() {          final double a = 1.5;         final double b = 0.5;         final double c = 0.25;         final MultivariateDifferentiableFunction mdf = new MultivariateDifferentiableFunction() {              @Override             public double value(double[] point) {                 return a * point[0] * point[0] + b * point[1] * point[1] + c * point[0] * point[1];             }              @Override             public DerivativeStructure value(DerivativeStructure[] point) {                 DerivativeStructure x  = point[0];                 DerivativeStructure y  = point[1];                 DerivativeStructure x2 = x.multiply(x);                 DerivativeStructure y2 = y.multiply(y);                 DerivativeStructure xy = x.multiply(y);                 return x2.multiply(a).add(y2.multiply(b)).add(xy.multiply(c));             }          };          final MultivariateFunction f       = FunctionUtils.derivative(mdf, new int[] { 0, 0 });         final MultivariateFunction dfdx    = FunctionUtils.derivative(mdf, new int[] { 1, 0 });         final MultivariateFunction dfdy    = FunctionUtils.derivative(mdf, new int[] { 0, 1 });         final MultivariateFunction d2fdx2  = FunctionUtils.derivative(mdf, new int[] { 2, 0 });         final MultivariateFunction d2fdy2  = FunctionUtils.derivative(mdf, new int[] { 0, 2 });         final MultivariateFunction d2fdxdy = FunctionUtils.derivative(mdf, new int[] { 1, 1 });          for (double x = -1.0; x < 1; x += 0.01) {             for (double y = -1.0; y < 1; y += 0.01) {                 Assert.assertEquals(a * x * x + b * y * y + c * x * y, f.value(new double[]       { x, y }), 1.0e-15);                 Assert.assertEquals(2 * a * x + c * y,                 dfdx.value(new double[]    { x, y }), 1.0e-15);                 Assert.assertEquals(2 * b * y + c * x,                 dfdy.value(new double[]    { x, y }), 1.0e-15);                 Assert.assertEquals(2 * a,                             d2fdx2.value(new double[]  { x, y }), 1.0e-15);                 Assert.assertEquals(2 * b,                             d2fdy2.value(new double[]  { x, y }), 1.0e-15);                 Assert.assertEquals(c,                                 d2fdxdy.value(new double[] { x, y }), 1.0e-15);             }         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for all uncovered classes in org.apache.commons.math4.analysis.function that implement BivariateFunction explicitly.  */ public class BivariateFunctionTest {      private static final double EPS = Math.ulp(1d);      @Test     public void testAtan2() {         Atan2 atan2 = new Atan2();         Assert.assertEquals(FastMath.PI/4,atan2.value(1,1), EPS);     }      @Test     public void testSubtract() {         Subtract subtract = new Subtract();         Assert.assertEquals(5, subtract.value(10,5), EPS);         Assert.assertEquals(-5, subtract.value(5,10), EPS);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link HarmonicOscillator}.  */ public class HarmonicOscillatorTest {     private final double EPS = Math.ulp(1d);      @Test     public void testSomeValues() {         final double a = -1.2;         final double w = 0.34;         final double p = 5.6;         final UnivariateFunction f = new HarmonicOscillator(a, w, p);          final double d = 0.12345;         for (int i = 0; i < 10; i++) {             final double v = i * d;             Assert.assertEquals(a * FastMath.cos(w * v + p), f.value(v), 0);         }     }      @Test     public void testDerivative() {         final double a = -1.2;         final double w = 0.34;         final double p = 5.6;         final HarmonicOscillator f = new HarmonicOscillator(a, w, p);          for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             final double d = 0.12345;             for (int i = 0; i < 10; i++) {                 final double v = i * d;                 final DerivativeStructure h = f.value(new DerivativeStructure(1, maxOrder, 0, v));                 for (int k = 0; k <= maxOrder; ++k) {                     final double trigo;                     switch (k % 4) {                         case 0:                             trigo = +FastMath.cos(w * v + p);                             break;                         case 1:                             trigo = -FastMath.sin(w * v + p);                             break;                         case 2:                             trigo = -FastMath.cos(w * v + p);                             break;                         default:                             trigo = +FastMath.sin(w * v + p);                             break;                     }                     Assert.assertEquals(a * FastMath.pow(w, k) * trigo,                                         h.getPartialDerivative(k),                                         Precision.EPSILON);                 }             }         }     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage1() {         final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();         g.value(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage2() {         final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();         g.value(0, new double[] {0});     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage3() {         final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();         g.gradient(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage4() {         final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();         g.gradient(0, new double[] {0});     }      @Test     public void testParametricValue() {         final double amplitude = 2;         final double omega = 3;         final double phase = 4;         final HarmonicOscillator f = new HarmonicOscillator(amplitude, omega, phase);          final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();         Assert.assertEquals(f.value(-1), g.value(-1, new double[] {amplitude, omega, phase}), 0);         Assert.assertEquals(f.value(0), g.value(0, new double[] {amplitude, omega, phase}), 0);         Assert.assertEquals(f.value(2), g.value(2, new double[] {amplitude, omega, phase}), 0);     }      @Test     public void testParametricGradient() {         final double amplitude = 2;         final double omega = 3;         final double phase = 4;         final HarmonicOscillator.Parametric f = new HarmonicOscillator.Parametric();          final double x = 1;         final double[] grad = f.gradient(1, new double[] {amplitude, omega, phase});         final double xTimesOmegaPlusPhase = omega * x + phase;         final double a = FastMath.cos(xTimesOmegaPlusPhase);         Assert.assertEquals(a, grad[0], EPS);         final double w = -amplitude * x * FastMath.sin(xTimesOmegaPlusPhase);         Assert.assertEquals(w, grad[1], EPS);         final double p = -amplitude * FastMath.sin(xTimesOmegaPlusPhase);         Assert.assertEquals(p, grad[2], EPS);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NoDataException; import org.apache.commons.math4.exception.NonMonotonicSequenceException; import org.apache.commons.math4.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link StepFunction}.  */ public class StepFunctionTest {     private final double EPS = Math.ulp(1d);      @Test(expected=NullArgumentException.class)     public void testPreconditions1() {         new StepFunction(null, new double[] {0, -1, -2});     }      @Test(expected=NullArgumentException.class)     public void testPreconditions2() {         new StepFunction(new double[] {0, 1}, null);     }      @Test(expected=NoDataException.class)     public void testPreconditions3() {         new StepFunction(new double[] {0}, new double[] {});     }      @Test(expected=NoDataException.class)     public void testPreconditions4() {         new StepFunction(new double[] {}, new double[] {0});     }      @Test(expected=DimensionMismatchException.class)     public void testPreconditions5() {         new StepFunction(new double[] {0, 1}, new double[] {0, -1, -2});     }      @Test(expected=NonMonotonicSequenceException.class)     public void testPreconditions6() {         new StepFunction(new double[] {1, 0, 1}, new double[] {0, -1, -2});     }      @Test     public void testSomeValues() {         final double[] x = { -2, -0.5, 0, 1.9, 7.4, 21.3 };         final double[] y = { 4, -1, -5.5, 0.4, 5.8, 51.2 };          final UnivariateFunction f = new StepFunction(x, y);          Assert.assertEquals(4, f.value(Double.NEGATIVE_INFINITY), EPS);         Assert.assertEquals(4, f.value(-10), EPS);         Assert.assertEquals(-1, f.value(-0.4), EPS);         Assert.assertEquals(-5.5, f.value(0), EPS);         Assert.assertEquals(0.4, f.value(2), EPS);         Assert.assertEquals(5.8, f.value(10), EPS);         Assert.assertEquals(51.2, f.value(30), EPS);         Assert.assertEquals(51.2, f.value(Double.POSITIVE_INFINITY), EPS);     }      @Test     public void testEndpointBehavior() {         final double[] x = {0, 1, 2, 3};         final double[] xp = {-8, 1, 2, 3};         final double[] y = {1, 2, 3, 4};         final UnivariateFunction f = new StepFunction(x, y);         final UnivariateFunction fp = new StepFunction(xp, y);         Assert.assertEquals(f.value(-8), fp.value(-8), EPS);         Assert.assertEquals(f.value(-10), fp.value(-10), EPS);         Assert.assertEquals(f.value(0), fp.value(0), EPS);         Assert.assertEquals(f.value(0.5), fp.value(0.5), EPS);         for (int i = 0; i < x.length; i++) {            Assert.assertEquals(y[i], f.value(x[i]), EPS);            if (i > 0) {                Assert.assertEquals(y[i - 1], f.value(x[i] - 0.5), EPS);            } else {                Assert.assertEquals(y[0], f.value(x[i] - 0.5), EPS);            }         }     }      @Test     public void testHeaviside() {         final UnivariateFunction h = new StepFunction(new double[] {-1, 0},                                                           new double[] {0, 1});          Assert.assertEquals(0, h.value(Double.NEGATIVE_INFINITY), 0);         Assert.assertEquals(0, h.value(-Double.MAX_VALUE), 0);         Assert.assertEquals(0, h.value(-2), 0);         Assert.assertEquals(0, h.value(-Double.MIN_VALUE), 0);         Assert.assertEquals(1, h.value(0), 0);         Assert.assertEquals(1, h.value(2), 0);         Assert.assertEquals(1, h.value(Double.POSITIVE_INFINITY), 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for all classes in org.apache.commons.math4.analysis.function that implement UnivariateFunction explicitly.  */ public class UnivariateFunctionTest {       private final double EPS = Math.ulp(1d);      @Test     public void testAbs() {         Abs abs = new Abs();         Assert.assertEquals(5, abs.value(-5), EPS);         Assert.assertEquals(5, abs.value(5), EPS);         Assert.assertEquals(5.123, abs.value(-5.123), EPS);         Assert.assertEquals(5.123, abs.value(5.123), EPS);         Assert.assertEquals(0, abs.value(0), EPS);     }      @Test     public void testCeil() {         Ceil ceil = new Ceil();         Assert.assertEquals(-5, ceil.value(-5), EPS);         Assert.assertEquals(-4, ceil.value(-4.999), EPS);         Assert.assertEquals(0, ceil.value(0), EPS);         Assert.assertEquals(1, ceil.value(1), EPS);         Assert.assertEquals(2, ceil.value(1.000000001), EPS);     }      @Test     public void testFloor() {         Floor floor = new Floor();         Assert.assertEquals(-5, floor.value(-5), EPS);         Assert.assertEquals(-5, floor.value(-4.999), EPS);         Assert.assertEquals(0, floor.value(0), EPS);         Assert.assertEquals(1, floor.value(1), EPS);         Assert.assertEquals(1, floor.value(1.000000001), EPS);     }      @Test     public void testRint() {         //Rint function is round half even.         Rint rint = new Rint();         Assert.assertEquals(-5, rint.value(-5), EPS);         Assert.assertEquals(-4, rint.value(-4.5), EPS);         Assert.assertEquals(0, rint.value(0), EPS);         Assert.assertEquals(1, rint.value(1), EPS);         Assert.assertEquals(2, rint.value(1.5), EPS);         Assert.assertEquals(2, rint.value(2.5), EPS);         Assert.assertEquals(-1, rint.value(-0.99999999), EPS);         Assert.assertEquals(11, rint.value(10.99999999), EPS);     }      @Test     public void testSignum() {         Signum signum = new Signum();         Assert.assertEquals(-1, signum.value(-5), EPS);         Assert.assertEquals(-1, signum.value(-4.5), EPS);         Assert.assertEquals(0, signum.value(0), EPS);         Assert.assertEquals(-0, signum.value(-0), EPS);         Assert.assertEquals(1, signum.value(1), EPS);         Assert.assertEquals(1, signum.value(1.5), EPS);         Assert.assertEquals(1, signum.value(2.5), EPS);         Assert.assertEquals(-1, signum.value(-0.99999999), EPS);         Assert.assertEquals(1, signum.value(10.99999999), EPS);     }      @Test     public void testStepFunction() {         final double[] x = { -2, -0.5, 0, 1.9, 7.4, 21.3 };         final double[] y = { 4, -1, -5.5, 0.4, 5.8, 51.2 };          final UnivariateFunction f = new StepFunction(x, y);          Assert.assertEquals(4, f.value(Double.NEGATIVE_INFINITY), EPS);         Assert.assertEquals(4, f.value(-10), EPS);         Assert.assertEquals(-1, f.value(-0.4), EPS);         Assert.assertEquals(-5.5, f.value(0), EPS);         Assert.assertEquals(0.4, f.value(2), EPS);         Assert.assertEquals(5.8, f.value(10), EPS);         Assert.assertEquals(51.2, f.value(30), EPS);         Assert.assertEquals(51.2, f.value(Double.POSITIVE_INFINITY), EPS);     }      @Test     public void testUlp() {         Ulp ulp = new Ulp();         Assert.assertEquals(expectedUlp(1),ulp.value(1), EPS);         Assert.assertEquals(expectedUlp(1.123456789),ulp.value(1.123456789), EPS);         Assert.assertEquals(expectedUlp(-1),ulp.value(-1), EPS);         Assert.assertEquals(expectedUlp(-1.123456789),ulp.value(-1.123456789), EPS);         Assert.assertEquals(expectedUlp(0),ulp.value(0), EPS);         Assert.assertEquals(expectedUlp(500000000),ulp.value(500000000), EPS);         Assert.assertEquals(expectedUlp(-500000000),ulp.value(-500000000), EPS);     }      private double expectedUlp(double x) {         return FastMath.abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.FunctionUtils; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.OutOfRangeException; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link Logit}.  */ public class LogitTest {     private final double EPS = Math.ulp(1d);      @Test(expected=OutOfRangeException.class)     public void testPreconditions1() {         final double lo = -1;         final double hi = 2;         final UnivariateFunction f = new Logit(lo, hi);          f.value(lo - 1);     }      @Test(expected=OutOfRangeException.class)     public void testPreconditions2() {         final double lo = -1;         final double hi = 2;         final UnivariateFunction f = new Logit(lo, hi);          f.value(hi + 1);     }      @Test     public void testSomeValues() {         final double lo = 1;         final double hi = 2;         final UnivariateFunction f = new Logit(lo, hi);          Assert.assertEquals(Double.NEGATIVE_INFINITY, f.value(1), EPS);         Assert.assertEquals(Double.POSITIVE_INFINITY, f.value(2), EPS);         Assert.assertEquals(0, f.value(1.5), EPS);     }      @Test     public void testDerivative() {         final double lo = 1;         final double hi = 2;         final Logit f = new Logit(lo, hi);         final DerivativeStructure f15 = f.value(new DerivativeStructure(1, 1, 0, 1.5));          Assert.assertEquals(4, f15.getPartialDerivative(1), EPS);     }      @Test     public void testDerivativeLargeArguments() {         final Logit f = new Logit(1, 2);          for (double arg : new double[] {             Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1e155, 1e155, Double.MAX_VALUE, Double.POSITIVE_INFINITY             }) {             try {                 f.value(new DerivativeStructure(1, 1, 0, arg));                 Assert.fail("an exception should have been thrown");             } catch (OutOfRangeException ore) {                 // expected             } catch (Exception e) {                 Assert.fail("wrong exception caught: " + e.getMessage());             }         }     }      @Test     public void testDerivativesHighOrder() {         DerivativeStructure l = new Logit(1, 3).value(new DerivativeStructure(1, 5, 0, 1.2));         Assert.assertEquals(-2.1972245773362193828, l.getPartialDerivative(0), 1.0e-16);         Assert.assertEquals(5.5555555555555555555,  l.getPartialDerivative(1), 9.0e-16);         Assert.assertEquals(-24.691358024691358025, l.getPartialDerivative(2), 2.0e-14);         Assert.assertEquals(250.34293552812071331,  l.getPartialDerivative(3), 2.0e-13);         Assert.assertEquals(-3749.4284407864654778, l.getPartialDerivative(4), 4.0e-12);         Assert.assertEquals(75001.270131585632282,  l.getPartialDerivative(5), 8.0e-11);     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage1() {         final Logit.Parametric g = new Logit.Parametric();         g.value(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage2() {         final Logit.Parametric g = new Logit.Parametric();         g.value(0, new double[] {0});     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage3() {         final Logit.Parametric g = new Logit.Parametric();         g.gradient(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage4() {         final Logit.Parametric g = new Logit.Parametric();         g.gradient(0, new double[] {0});     }      @Test(expected=OutOfRangeException.class)     public void testParametricUsage5() {         final Logit.Parametric g = new Logit.Parametric();         g.value(-1, new double[] {0, 1});     }      @Test(expected=OutOfRangeException.class)     public void testParametricUsage6() {         final Logit.Parametric g = new Logit.Parametric();         g.value(2, new double[] {0, 1});     }      @Test     public void testParametricValue() {         final double lo = 2;         final double hi = 3;         final Logit f = new Logit(lo, hi);          final Logit.Parametric g = new Logit.Parametric();         Assert.assertEquals(f.value(2), g.value(2, new double[] {lo, hi}), 0);         Assert.assertEquals(f.value(2.34567), g.value(2.34567, new double[] {lo, hi}), 0);         Assert.assertEquals(f.value(3), g.value(3, new double[] {lo, hi}), 0);     }      @Test     public void testValueWithInverseFunction() {         final double lo = 2;         final double hi = 3;         final Logit f = new Logit(lo, hi);         final Sigmoid g = new Sigmoid(lo, hi);         final UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,                                                                  0x49914cdd9f0b8db5l);         final UnivariateDifferentiableFunction id = FunctionUtils.compose((UnivariateDifferentiableFunction) g,                                                                 (UnivariateDifferentiableFunction) f);          for (int i = 0; i < 10; i++) {             final double x = lo + random.nextDouble() * (hi - lo);             Assert.assertEquals(x, id.value(new DerivativeStructure(1, 1, 0, x)).getValue(), EPS);         }          Assert.assertEquals(lo, id.value(new DerivativeStructure(1, 1, 0, lo)).getValue(), EPS);         Assert.assertEquals(hi, id.value(new DerivativeStructure(1, 1, 0, hi)).getValue(), EPS);     }      @Test     public void testDerivativesWithInverseFunction() {         double[] epsilon = new double[] { 1.0e-20, 4.0e-16, 3.0e-15, 2.0e-11, 3.0e-9, 1.0e-6 };         final double lo = 2;         final double hi = 3;         final Logit f = new Logit(lo, hi);         final Sigmoid g = new Sigmoid(lo, hi);         final UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,                                                                  0x96885e9c1f81cea6l);         final UnivariateDifferentiableFunction id =                 FunctionUtils.compose((UnivariateDifferentiableFunction) g, (UnivariateDifferentiableFunction) f);         for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {             double max = 0;             for (int i = 0; i < 10; i++) {                 final double x = lo + random.nextDouble() * (hi - lo);                 final DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);                 max = FastMath.max(max, FastMath.abs(dsX.getPartialDerivative(maxOrder) -                                                      id.value(dsX).getPartialDerivative(maxOrder)));                 Assert.assertEquals("maxOrder = " + maxOrder,                                     dsX.getPartialDerivative(maxOrder),                                     id.value(dsX).getPartialDerivative(maxOrder),                                     epsilon[maxOrder]);             }              // each function evaluates correctly near boundaries,             // but combination leads to NaN as some intermediate point is infinite             final DerivativeStructure dsLo = new DerivativeStructure(1, maxOrder, 0, lo);             if (maxOrder == 0) {                 Assert.assertTrue(Double.isInfinite(f.value(dsLo).getPartialDerivative(maxOrder)));                 Assert.assertEquals(lo, id.value(dsLo).getPartialDerivative(maxOrder), epsilon[maxOrder]);             } else if (maxOrder == 1) {                 Assert.assertTrue(Double.isInfinite(f.value(dsLo).getPartialDerivative(maxOrder)));                 Assert.assertTrue(Double.isNaN(id.value(dsLo).getPartialDerivative(maxOrder)));             } else {                 Assert.assertTrue(Double.isNaN(f.value(dsLo).getPartialDerivative(maxOrder)));                 Assert.assertTrue(Double.isNaN(id.value(dsLo).getPartialDerivative(maxOrder)));             }              final DerivativeStructure dsHi = new DerivativeStructure(1, maxOrder, 0, hi);             if (maxOrder == 0) {                 Assert.assertTrue(Double.isInfinite(f.value(dsHi).getPartialDerivative(maxOrder)));                 Assert.assertEquals(hi, id.value(dsHi).getPartialDerivative(maxOrder), epsilon[maxOrder]);             } else if (maxOrder == 1) {                 Assert.assertTrue(Double.isInfinite(f.value(dsHi).getPartialDerivative(maxOrder)));                 Assert.assertTrue(Double.isNaN(id.value(dsHi).getPartialDerivative(maxOrder)));             } else {                 Assert.assertTrue(Double.isNaN(f.value(dsHi).getPartialDerivative(maxOrder)));                 Assert.assertTrue(Double.isNaN(id.value(dsHi).getPartialDerivative(maxOrder)));             }          }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class SqrtTest {    @Test    public void testComparison() {        final Sqrt s = new Sqrt();        final UnivariateFunction f = new UnivariateFunction() {            @Override            public double value(double x) {                return FastMath.sqrt(x);            }        };         for (double x = 1e-30; x < 1e10; x *= 2) {            final double fX = f.value(x);            final double sX = s.value(x);            Assert.assertEquals("x=" + x, fX, sX, 0);        }    }     @Test    public void testDerivativeComparison() {        final UnivariateDifferentiableFunction sPrime = new Sqrt();        final UnivariateFunction f = new UnivariateFunction() {                @Override             public double value(double x) {                    return 1 / (2 * FastMath.sqrt(x));                }            };         for (double x = 1e-30; x < 1e10; x *= 2) {            final double fX = f.value(x);            final double sX = sPrime.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1);            Assert.assertEquals("x=" + x, fX, sX, FastMath.ulp(fX));        }    }     @Test    public void testDerivativesHighOrder() {        DerivativeStructure s = new Sqrt().value(new DerivativeStructure(1, 5, 0, 1.2));        Assert.assertEquals(1.0954451150103322269, s.getPartialDerivative(0), 1.0e-16);        Assert.assertEquals(0.45643546458763842789, s.getPartialDerivative(1), 1.0e-16);        Assert.assertEquals(-0.1901814435781826783,  s.getPartialDerivative(2), 1.0e-16);        Assert.assertEquals(0.23772680447272834785,  s.getPartialDerivative(3), 1.0e-16);        Assert.assertEquals(-0.49526417598485072465,   s.getPartialDerivative(4), 1.0e-16);        Assert.assertEquals(1.4445205132891479465,  s.getPartialDerivative(5), 5.0e-16);    }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for all classes in org.apache.commons.math4.analysis.function that implement UnivariateDifferentiableFunction explicitly.  */ public class UnivariateDifferentiableFunctionTest {      private static final double EPS = Math.ulp(1d);      @Test     public void testAcos() {         Acos acos = new Acos();         Assert.assertEquals(FastMath.PI/3, acos.value(0.5), EPS);         Assert.assertEquals(FastMath.PI/4, acos.value(Double.valueOf(1/FastMath.sqrt(2))), EPS);         double a = 0.5;         Assert.assertEquals(-1/FastMath.sqrt(1-FastMath.pow(a,2)), acos.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testAcosh() {         Acosh acosh = new Acosh();         Assert.assertEquals(0,acosh.value(1), EPS);         double a = 1.2345;         Assert.assertEquals(a,acosh.value(FastMath.cosh(a)), EPS);         Assert.assertEquals(1/(FastMath.sqrt(a-1)*FastMath.sqrt(a+1)),acosh.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testAsin() {         Asin asin = new Asin();         double a = 1.2345;         Assert.assertEquals(a, asin.value(FastMath.sin(a)), EPS);         Assert.assertEquals(1/FastMath.sqrt(1 - FastMath.pow(a,2)), asin.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testAsinh() {         Asinh asinh = new Asinh();         double a = 1.2345;         Assert.assertEquals(a, asinh.value(FastMath.sinh(a)), EPS);         Assert.assertEquals(1/FastMath.sqrt(FastMath.pow(a,2.0) + 1), asinh.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testAtan() {         Atan atan = new Atan();         double a = 1.2345;         Assert.assertEquals(a, atan.value(FastMath.tan(a)), EPS);         Assert.assertEquals(1/(FastMath.pow(a,2.0) + 1), atan.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testAtanh() {         Atanh atanh = new Atanh();         double a = 1.2345;         Assert.assertEquals(a, atanh.value(FastMath.tanh(a)), EPS);         Assert.assertEquals(1/(1 - FastMath.pow(a,2.0)), atanh.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testCbrt() {         Cbrt cbrt = new Cbrt();         double a = 1.2345;         Assert.assertEquals(a, cbrt.value(FastMath.pow(a,3)), EPS);         Assert.assertEquals(1.0/(3.0*FastMath.pow(a, 2.0/3.0)), cbrt.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testConstant() {         double a = 123.456;         Constant constantNeg1 = new Constant(-1);         Constant constant0 = new Constant(0);         Constant constant5 = new Constant(5);         Assert.assertEquals(-1, constantNeg1.value(a), EPS);         Assert.assertEquals(0, constant0.value(a), EPS);         Assert.assertEquals(5, constant5.value(a), EPS);         Assert.assertEquals(0, constantNeg1.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);         Assert.assertEquals(0, constant0.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);         Assert.assertEquals(0, constant5.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testCos() {         Cos cos = new Cos();         double a = 0.987;         Assert.assertEquals(a, cos.value(FastMath.acos(a)), EPS);         Assert.assertEquals(-FastMath.sin(a), cos.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testCosh() {         Cosh cosh = new Cosh();         double a = 1.2345;         Assert.assertEquals(a, cosh.value(FastMath.acosh(a)), EPS);         Assert.assertEquals(FastMath.sinh(a), cosh.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testExp() {         Exp exp= new Exp();         double a = 1.2345;         Assert.assertEquals(a, exp.value(FastMath.log(a)), EPS);         Assert.assertEquals(exp.value(a), exp.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testExpm1() {         Expm1 expm1 = new Expm1();         double a = 1.2345;         Assert.assertEquals(a-1, expm1.value(FastMath.log(a)), EPS);         Assert.assertEquals(FastMath.exp(a), expm1.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testIdentity() {         Identity identity = new Identity();         double a = 123.456;         Assert.assertEquals(a, identity.value(a), EPS);         Assert.assertEquals(1, identity.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testInverse() {         Inverse inverse = new Inverse();         double a = 123.456;         Assert.assertEquals(1/a, inverse.value(a), EPS);         Assert.assertEquals(-1/FastMath.pow(a,2), inverse.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testLog() {         double a = 123.456;         Log log = new Log();         Assert.assertEquals(Math.log(a), log.value(a), EPS);         Assert.assertEquals(1/a,log.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testLog10() {         Log10 log10 = new Log10();         double a =1.2345;         Assert.assertEquals(a, log10.value(FastMath.pow(10, a)), EPS);         Assert.assertEquals(1/(a*FastMath.log(10)), log10.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testLog1p() {         Log1p log1p = new Log1p();         double a = 1.2345;         Assert.assertEquals(a+1,FastMath.exp(log1p.value(a)), EPS);         Assert.assertEquals(1/(1+a), log1p.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testMinus() {         Minus minus = new Minus();         double a = 123.456;         Assert.assertEquals(-a, minus.value(a), EPS);         Assert.assertEquals(-1, minus.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testPower() {         Power squared = new Power(2);         Power power2_5 = new Power(2.5);         double a = 123.456;         Assert.assertEquals(FastMath.pow(a,2), squared.value(a), EPS);         Assert.assertEquals(FastMath.pow(a, 2.5), power2_5.value(a), EPS);         Assert.assertEquals(2*a, squared.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);         Assert.assertEquals(2.5*FastMath.pow(a,1.5), power2_5.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testSin() {         Sin sin = new Sin();         double a = 0.987;         Assert.assertEquals(a, sin.value(FastMath.asin(a)), EPS);         Assert.assertEquals(FastMath.cos(a), sin.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testSinh() {         Sinh sinh = new Sinh();         double a = 1.2345;         Assert.assertEquals(a, sinh.value(FastMath.asinh(a)), EPS);         Assert.assertEquals(FastMath.cosh(a), sinh.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testTan() {         Tan tan = new Tan();         double a = 0.987;         Assert.assertEquals(a, tan.value(FastMath.atan(a)), EPS);         Assert.assertEquals(1/(FastMath.pow(FastMath.cos(a),2)), tan.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }      @Test     public void testTanh() {         Tanh tanh = new Tanh();         double a = 0.987;         Assert.assertEquals(a, tanh.value(FastMath.atanh(a)), EPS);         Assert.assertEquals(1/FastMath.pow(FastMath.cosh(a),2), tanh.value(new DerivativeStructure(1,1,0,a)).getPartialDerivative(1), EPS);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link Sigmoid}.  */ public class SigmoidTest {     private final double EPS = Math.ulp(1d);      @Test     public void testSomeValues() {         final UnivariateFunction f = new Sigmoid();          Assert.assertEquals(0.5, f.value(0), EPS);         Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), EPS);         Assert.assertEquals(1, f.value(Double.POSITIVE_INFINITY), EPS);     }      @Test     public void testDerivative() {         final Sigmoid f = new Sigmoid();         final DerivativeStructure f0 = f.value(new DerivativeStructure(1, 1, 0, 0.0));          Assert.assertEquals(0.25, f0.getPartialDerivative(1), 0);     }      @Test     public void testDerivativesHighOrder() {         DerivativeStructure s = new Sigmoid(1, 3).value(new DerivativeStructure(1, 5, 0, 1.2));         Assert.assertEquals(2.5370495669980352859, s.getPartialDerivative(0), 5.0e-16);         Assert.assertEquals(0.35578888129361140441, s.getPartialDerivative(1), 6.0e-17);         Assert.assertEquals(-0.19107626464144938116,  s.getPartialDerivative(2), 6.0e-17);         Assert.assertEquals(-0.02396830286286711696,  s.getPartialDerivative(3), 4.0e-17);         Assert.assertEquals(0.21682059798981049049,   s.getPartialDerivative(4), 3.0e-17);         Assert.assertEquals(-0.19186320234632658055,  s.getPartialDerivative(5), 2.0e-16);     }      @Test     public void testDerivativeLargeArguments() {         final Sigmoid f = new Sigmoid(1, 2);          Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.NEGATIVE_INFINITY)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -Double.MAX_VALUE)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e50)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e3)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e3)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e50)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.MAX_VALUE)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.POSITIVE_INFINITY)).getPartialDerivative(1), 0);     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage1() {         final Sigmoid.Parametric g = new Sigmoid.Parametric();         g.value(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage2() {         final Sigmoid.Parametric g = new Sigmoid.Parametric();         g.value(0, new double[] {0});     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage3() {         final Sigmoid.Parametric g = new Sigmoid.Parametric();         g.gradient(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage4() {         final Sigmoid.Parametric g = new Sigmoid.Parametric();         g.gradient(0, new double[] {0});     }      @Test     public void testParametricValue() {         final double lo = 2;         final double hi = 3;         final Sigmoid f = new Sigmoid(lo, hi);          final Sigmoid.Parametric g = new Sigmoid.Parametric();         Assert.assertEquals(f.value(-1), g.value(-1, new double[] {lo, hi}), 0);         Assert.assertEquals(f.value(0), g.value(0, new double[] {lo, hi}), 0);         Assert.assertEquals(f.value(2), g.value(2, new double[] {lo, hi}), 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link Logistic}.  */ public class LogisticTest {     private final double EPS = Math.ulp(1d);      @Test(expected=NotStrictlyPositiveException.class)     public void testPreconditions1() {         new Logistic(1, 0, 1, 1, 0, -1);     }      @Test(expected=NotStrictlyPositiveException.class)     public void testPreconditions2() {         new Logistic(1, 0, 1, 1, 0, 0);     }      @Test     public void testCompareSigmoid() {         final UnivariateFunction sig = new Sigmoid();         final UnivariateFunction sigL = new Logistic(1, 0, 1, 1, 0, 1);          final double min = -2;         final double max = 2;         final int n = 100;         final double delta = (max - min) / n;         for (int i = 0; i < n; i++) {             final double x = min + i * delta;             Assert.assertEquals("x=" + x, sig.value(x), sigL.value(x), EPS);         }     }      @Test     public void testSomeValues() {         final double k = 4;         final double m = 5;         final double b = 2;         final double q = 3;         final double a = -1;         final double n = 2;          final UnivariateFunction f = new Logistic(k, m, b, q, a, n);          double x;         x = m;         Assert.assertEquals("x=" + x, a + (k - a) / FastMath.sqrt(1 + q), f.value(x), EPS);          x = Double.NEGATIVE_INFINITY;         Assert.assertEquals("x=" + x, a, f.value(x), EPS);          x = Double.POSITIVE_INFINITY;         Assert.assertEquals("x=" + x, k, f.value(x), EPS);     }      @Test     public void testCompareDerivativeSigmoid() {         final double k = 3;         final double a = 2;          final Logistic f = new Logistic(k, 0, 1, 1, a, 1);         final Sigmoid g = new Sigmoid(a, k);          final double min = -10;         final double max = 10;         final double n = 20;         final double delta = (max - min) / n;         for (int i = 0; i < n; i++) {             final DerivativeStructure x = new DerivativeStructure(1, 5, 0, min + i * delta);             for (int order = 0; order <= x.getOrder(); ++order) {                 Assert.assertEquals("x=" + x.getValue(),                                     g.value(x).getPartialDerivative(order),                                     f.value(x).getPartialDerivative(order),                                     3.0e-15);             }         }     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage1() {         final Logistic.Parametric g = new Logistic.Parametric();         g.value(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage2() {         final Logistic.Parametric g = new Logistic.Parametric();         g.value(0, new double[] {0});     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage3() {         final Logistic.Parametric g = new Logistic.Parametric();         g.gradient(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage4() {         final Logistic.Parametric g = new Logistic.Parametric();         g.gradient(0, new double[] {0});     }      @Test(expected=NotStrictlyPositiveException.class)     public void testParametricUsage5() {         final Logistic.Parametric g = new Logistic.Parametric();         g.value(0, new double[] {1, 0, 1, 1, 0 ,0});     }      @Test(expected=NotStrictlyPositiveException.class)     public void testParametricUsage6() {         final Logistic.Parametric g = new Logistic.Parametric();         g.gradient(0, new double[] {1, 0, 1, 1, 0 ,0});     }      @Test     public void testGradientComponent0Component4() {         final double k = 3;         final double a = 2;          final Logistic.Parametric f = new Logistic.Parametric();         // Compare using the "Sigmoid" function.         final Sigmoid.Parametric g = new Sigmoid.Parametric();          final double x = 0.12345;         final double[] gf = f.gradient(x, new double[] {k, 0, 1, 1, a, 1});         final double[] gg = g.gradient(x, new double[] {a, k});          Assert.assertEquals(gg[0], gf[4], EPS);         Assert.assertEquals(gg[1], gf[0], EPS);     }      @Test     public void testGradientComponent5() {         final double m = 1.2;         final double k = 3.4;         final double a = 2.3;         final double q = 0.567;         final double b = -FastMath.log(q);         final double n = 3.4;          final Logistic.Parametric f = new Logistic.Parametric();          final double x = m - 1;         final double qExp1 = 2;          final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n});          Assert.assertEquals((k - a) * FastMath.log(qExp1) / (n * n * FastMath.pow(qExp1, 1 / n)),                             gf[5], EPS);     }      @Test     public void testGradientComponent1Component2Component3() {         final double m = 1.2;         final double k = 3.4;         final double a = 2.3;         final double b = 0.567;         final double q = 1 / FastMath.exp(b * m);         final double n = 3.4;          final Logistic.Parametric f = new Logistic.Parametric();          final double x = 0;         final double qExp1 = 2;          final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n});          final double factor = (a - k) / (n * FastMath.pow(qExp1, 1 / n + 1));         Assert.assertEquals(factor * b, gf[1], EPS);         Assert.assertEquals(factor * m, gf[2], EPS);         Assert.assertEquals(factor / q, gf[3], EPS);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test for class {@link Gaussian}.  */ public class GaussianTest {     private final double EPS = Math.ulp(1d);      @Test(expected=NotStrictlyPositiveException.class)     public void testPreconditions() {         new Gaussian(1, 2, -1);     }      @Test     public void testSomeValues() {         final UnivariateFunction f = new Gaussian();          Assert.assertEquals(1 / FastMath.sqrt(2 * Math.PI), f.value(0), EPS);     }      @Test     public void testLargeArguments() {         final UnivariateFunction f = new Gaussian();          Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), 0);         Assert.assertEquals(0, f.value(-Double.MAX_VALUE), 0);         Assert.assertEquals(0, f.value(-1e2), 0);         Assert.assertEquals(0, f.value(1e2), 0);         Assert.assertEquals(0, f.value(Double.MAX_VALUE), 0);         Assert.assertEquals(0, f.value(Double.POSITIVE_INFINITY), 0);     }      @Test     public void testDerivatives() {         final UnivariateDifferentiableFunction gaussian = new Gaussian(2.0, 0.9, 3.0);         final DerivativeStructure dsX = new DerivativeStructure(1, 4, 0, 1.1);         final DerivativeStructure dsY = gaussian.value(dsX);         Assert.assertEquals( 1.9955604901712128349,   dsY.getValue(),              EPS);         Assert.assertEquals(-0.044345788670471396332, dsY.getPartialDerivative(1), EPS);         Assert.assertEquals(-0.22074348138190206174,  dsY.getPartialDerivative(2), EPS);         Assert.assertEquals( 0.014760030401924800557, dsY.getPartialDerivative(3), EPS);         Assert.assertEquals( 0.073253159785035691678, dsY.getPartialDerivative(4), EPS);     }      @Test     public void testDerivativeLargeArguments() {         final Gaussian f = new Gaussian(0, 1e-50);          Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.NEGATIVE_INFINITY)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -Double.MAX_VALUE)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e50)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e2)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e2)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e50)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.MAX_VALUE)).getPartialDerivative(1), 0);         Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.POSITIVE_INFINITY)).getPartialDerivative(1), 0);     }      @Test     public void testDerivativesNaN() {         final Gaussian f = new Gaussian(0, 1e-50);         final DerivativeStructure fx = f.value(new DerivativeStructure(1, 5, 0, Double.NaN));         for (int i = 0; i <= fx.getOrder(); ++i) {             Assert.assertTrue(Double.isNaN(fx.getPartialDerivative(i)));         }     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage1() {         final Gaussian.Parametric g = new Gaussian.Parametric();         g.value(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage2() {         final Gaussian.Parametric g = new Gaussian.Parametric();         g.value(0, new double[] {0});     }      @Test(expected=NotStrictlyPositiveException.class)     public void testParametricUsage3() {         final Gaussian.Parametric g = new Gaussian.Parametric();         g.value(0, new double[] {0, 1, 0});     }      @Test(expected=NullArgumentException.class)     public void testParametricUsage4() {         final Gaussian.Parametric g = new Gaussian.Parametric();         g.gradient(0, null);     }      @Test(expected=DimensionMismatchException.class)     public void testParametricUsage5() {         final Gaussian.Parametric g = new Gaussian.Parametric();         g.gradient(0, new double[] {0});     }      @Test(expected=NotStrictlyPositiveException.class)     public void testParametricUsage6() {         final Gaussian.Parametric g = new Gaussian.Parametric();         g.gradient(0, new double[] {0, 1, 0});     }      @Test     public void testParametricValue() {         final double norm = 2;         final double mean = 3;         final double sigma = 4;         final Gaussian f = new Gaussian(norm, mean, sigma);          final Gaussian.Parametric g = new Gaussian.Parametric();         Assert.assertEquals(f.value(-1), g.value(-1, new double[] {norm, mean, sigma}), 0);         Assert.assertEquals(f.value(0), g.value(0, new double[] {norm, mean, sigma}), 0);         Assert.assertEquals(f.value(2), g.value(2, new double[] {norm, mean, sigma}), 0);     }      @Test     public void testParametricGradient() {         final double norm = 2;         final double mean = 3;         final double sigma = 4;         final Gaussian.Parametric f = new Gaussian.Parametric();          final double x = 1;         final double[] grad = f.gradient(1, new double[] {norm, mean, sigma});         final double diff = x - mean;         final double n = FastMath.exp(-diff * diff / (2 * sigma * sigma));         Assert.assertEquals(n, grad[0], EPS);         final double m = norm * n * diff / (sigma * sigma);         Assert.assertEquals(m, grad[1], EPS);         final double s = m * diff / sigma;         Assert.assertEquals(s, grad[2], EPS);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.function;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.dfp.Dfp; import org.apache.commons.math4.dfp.DfpField; import org.apache.commons.math4.dfp.DfpMath; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  public class SincTest {     @Test    public void testShortcut() {        final Sinc s = new Sinc();        final UnivariateFunction f = new UnivariateFunction() {            @Override            public double value(double x) {                Dfp dfpX = new DfpField(25).newDfp(x);                return DfpMath.sin(dfpX).divide(dfpX).toDouble();            }        };         for (double x = 1e-30; x < 1e10; x *= 2) {            final double fX = f.value(x);            final double sX = s.value(x);            Assert.assertEquals("x=" + x, fX, sX, 2.0e-16);        }    }     @Test    public void testCrossings() {        final Sinc s = new Sinc(true);        final int numCrossings = 1000;        final double tol = 2e-16;        for (int i = 1; i <= numCrossings; i++) {            Assert.assertEquals("i=" + i, 0, s.value(i), tol);        }    }     @Test    public void testZero() {        final Sinc s = new Sinc();        Assert.assertEquals(1d, s.value(0), 0);    }     @Test    public void testEuler() {        final Sinc s = new Sinc();        final double x = 123456.789;        double prod = 1;        double xOverPow2 = x / 2;        while (xOverPow2 > 0) {            prod *= FastMath.cos(xOverPow2);            xOverPow2 /= 2;        }        Assert.assertEquals(prod, s.value(x), 1e-13);    }     @Test    public void testDerivativeZero() {        final DerivativeStructure s0 = new Sinc(true).value(new DerivativeStructure(1, 1, 0, 0.0));        Assert.assertEquals(0, s0.getPartialDerivative(1), 0);    }     @Test    public void testDerivatives1Dot2Unnormalized() {        DerivativeStructure s = new Sinc(false).value(new DerivativeStructure(1, 5, 0, 1.2));        Assert.assertEquals( 0.77669923830602195806, s.getPartialDerivative(0), 1.0e-16);        Assert.assertEquals(-0.34528456985779031701, s.getPartialDerivative(1), 1.0e-16);        Assert.assertEquals(-0.2012249552097047631,  s.getPartialDerivative(2), 1.0e-16);        Assert.assertEquals( 0.2010975926270339262,  s.getPartialDerivative(3), 4.0e-16);        Assert.assertEquals( 0.106373929549242204,   s.getPartialDerivative(4), 1.0e-15);        Assert.assertEquals(-0.1412599110579478695,  s.getPartialDerivative(5), 3.0e-15);    }     @Test    public void testDerivatives1Dot2Normalized() {        DerivativeStructure s = new Sinc(true).value(new DerivativeStructure(1, 5, 0, 1.2));        Assert.assertEquals(-0.15591488063143983888, s.getPartialDerivative(0), 6.0e-17);        Assert.assertEquals(-0.54425176145292298767, s.getPartialDerivative(1), 2.0e-16);        Assert.assertEquals(2.4459044611635856107,   s.getPartialDerivative(2), 9.0e-16);        Assert.assertEquals(0.5391369206235909586,   s.getPartialDerivative(3), 7.0e-16);        Assert.assertEquals(-16.984649869728849865,  s.getPartialDerivative(4), 8.0e-15);        Assert.assertEquals(5.0980327462666316586,   s.getPartialDerivative(5), 9.0e-15);    }     @Test    public void testDerivativeShortcut() {        final Sinc sinc = new Sinc();        final UnivariateFunction f = new UnivariateFunction() {                @Override             public double value(double x) {                    Dfp dfpX = new DfpField(25).newDfp(x);                    return DfpMath.cos(dfpX).subtract(DfpMath.sin(dfpX).divide(dfpX)).divide(dfpX).toDouble();                }            };         for (double x = 1e-30; x < 1e10; x *= 2) {            final double fX = f.value(x);            final DerivativeStructure sX = sinc.value(new DerivativeStructure(1, 1, 0, x));            Assert.assertEquals("x=" + x, fX, sX.getPartialDerivative(1), 3.0e-13);        }    } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis;  import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction;  /**  * Auxiliary class for testing solvers.  *  */ public class XMinus5Function implements UnivariateDifferentiableFunction {      /* Evaluate x - 5 function.      * @see org.apache.commons.math4.UnivariateFunction#value(double)      */     @Override     public double value(double x) {         return x - 5;     }      @Override     public DerivativeStructure value(DerivativeStructure t) {         return t.subtract(5);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis;  import org.apache.commons.math4.analysis.function.Sinc;  /**  * Auxiliary class for testing optimizers.  *  */ public class SumSincFunction implements MultivariateFunction {     private static final UnivariateFunction sinc = new Sinc();      /**      * Factor that will multiply each term of the sum.      */     private final double factor;      /**      * @param factor Factor that will multiply each term of the sum.      */     public SumSincFunction(double factor) {         this.factor = factor;     }      /**      * @param point Argument.      * @return the value of this function at point {@code x}.      */     @Override     public double value(double[] point) {         double sum = 0;         for (int i = 0, max = point.length; i < max; i++) {             final double x = point[i];             final double v = sinc.value(x);             sum += v;         }         return factor * sum;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.polynomials;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator; import org.apache.commons.numbers.combinatorics.BinomialCoefficient; import org.apache.commons.math4.util.FastMath; import org.apache.commons.numbers.core.Precision; import org.junit.Assert; import org.junit.Test;  /**  * Tests the PolynomialsUtils class.  *  */ public class PolynomialsUtilsTest {      @Test     public void testFirstChebyshevPolynomials() {         checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3), "-3 x + 4 x^3");         checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2), "-1 + 2 x^2");         checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1), "x");         checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0), "1");          checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7), "-7 x + 56 x^3 - 112 x^5 + 64 x^7");         checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6), "-1 + 18 x^2 - 48 x^4 + 32 x^6");         checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5), "5 x - 20 x^3 + 16 x^5");         checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4), "1 - 8 x^2 + 8 x^4");      }      @Test     public void testChebyshevBounds() {         for (int k = 0; k < 12; ++k) {             PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k);             for (double x = -1; x <= 1; x += 0.02) {                 Assert.assertTrue(k + " " + Tk.value(x), FastMath.abs(Tk.value(x)) < (1 + 1e-12));             }         }     }      @Test     public void testChebyshevDifferentials() {         for (int k = 0; k < 12; ++k) {              PolynomialFunction Tk0 = PolynomialsUtils.createChebyshevPolynomial(k);             PolynomialFunction Tk1 = Tk0.polynomialDerivative();             PolynomialFunction Tk2 = Tk1.polynomialDerivative();              PolynomialFunction g0 = new PolynomialFunction(new double[] { k * k });             PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -1});             PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });              PolynomialFunction Tk0g0 = Tk0.multiply(g0);             PolynomialFunction Tk1g1 = Tk1.multiply(g1);             PolynomialFunction Tk2g2 = Tk2.multiply(g2);              checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2)));          }     }      @Test     public void testChebyshevOrthogonality() {         UnivariateFunction weight = new UnivariateFunction() {             @Override             public double value(double x) {                 return 1 / FastMath.sqrt(1 - x * x);             }         };         for (int i = 0; i < 10; ++i) {             PolynomialFunction pi = PolynomialsUtils.createChebyshevPolynomial(i);             for (int j = 0; j <= i; ++j) {                 PolynomialFunction pj = PolynomialsUtils.createChebyshevPolynomial(j);                 checkOrthogonality(pi, pj, weight, -0.9999, 0.9999, 1.5, 0.03);             }         }     }      @Test     public void testFirstHermitePolynomials() {         checkPolynomial(PolynomialsUtils.createHermitePolynomial(3), "-12 x + 8 x^3");         checkPolynomial(PolynomialsUtils.createHermitePolynomial(2), "-2 + 4 x^2");         checkPolynomial(PolynomialsUtils.createHermitePolynomial(1), "2 x");         checkPolynomial(PolynomialsUtils.createHermitePolynomial(0), "1");          checkPolynomial(PolynomialsUtils.createHermitePolynomial(7), "-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7");         checkPolynomial(PolynomialsUtils.createHermitePolynomial(6), "-120 + 720 x^2 - 480 x^4 + 64 x^6");         checkPolynomial(PolynomialsUtils.createHermitePolynomial(5), "120 x - 160 x^3 + 32 x^5");         checkPolynomial(PolynomialsUtils.createHermitePolynomial(4), "12 - 48 x^2 + 16 x^4");      }      @Test     public void testHermiteDifferentials() {         for (int k = 0; k < 12; ++k) {              PolynomialFunction Hk0 = PolynomialsUtils.createHermitePolynomial(k);             PolynomialFunction Hk1 = Hk0.polynomialDerivative();             PolynomialFunction Hk2 = Hk1.polynomialDerivative();              PolynomialFunction g0 = new PolynomialFunction(new double[] { 2 * k });             PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });             PolynomialFunction g2 = new PolynomialFunction(new double[] { 1 });              PolynomialFunction Hk0g0 = Hk0.multiply(g0);             PolynomialFunction Hk1g1 = Hk1.multiply(g1);             PolynomialFunction Hk2g2 = Hk2.multiply(g2);              checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2)));          }     }      @Test     public void testHermiteOrthogonality() {         UnivariateFunction weight = new UnivariateFunction() {             @Override             public double value(double x) {                 return FastMath.exp(-x * x);             }         };         for (int i = 0; i < 10; ++i) {             PolynomialFunction pi = PolynomialsUtils.createHermitePolynomial(i);             for (int j = 0; j <= i; ++j) {                 PolynomialFunction pj = PolynomialsUtils.createHermitePolynomial(j);                 checkOrthogonality(pi, pj, weight, -50, 50, 1.5, 1.0e-8);             }         }     }      @Test     public void testFirstLaguerrePolynomials() {         checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3), 6l, "6 - 18 x + 9 x^2 - x^3");         checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2), 2l, "2 - 4 x + x^2");         checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1), 1l, "1 - x");         checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0), 1l, "1");          checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7), 5040l,                 "5040 - 35280 x + 52920 x^2 - 29400 x^3"                 + " + 7350 x^4 - 882 x^5 + 49 x^6 - x^7");         checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6),  720l,                 "720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4"                 + " - 36 x^5 + x^6");         checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5),  120l,         "120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5");         checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4),   24l,         "24 - 96 x + 72 x^2 - 16 x^3 + x^4");      }      @Test     public void testLaguerreDifferentials() {         for (int k = 0; k < 12; ++k) {              PolynomialFunction Lk0 = PolynomialsUtils.createLaguerrePolynomial(k);             PolynomialFunction Lk1 = Lk0.polynomialDerivative();             PolynomialFunction Lk2 = Lk1.polynomialDerivative();              PolynomialFunction g0 = new PolynomialFunction(new double[] { k });             PolynomialFunction g1 = new PolynomialFunction(new double[] { 1, -1 });             PolynomialFunction g2 = new PolynomialFunction(new double[] { 0, 1 });              PolynomialFunction Lk0g0 = Lk0.multiply(g0);             PolynomialFunction Lk1g1 = Lk1.multiply(g1);             PolynomialFunction Lk2g2 = Lk2.multiply(g2);              checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2)));          }     }      @Test     public void testLaguerreOrthogonality() {         UnivariateFunction weight = new UnivariateFunction() {             @Override             public double value(double x) {                 return FastMath.exp(-x);             }         };         for (int i = 0; i < 10; ++i) {             PolynomialFunction pi = PolynomialsUtils.createLaguerrePolynomial(i);             for (int j = 0; j <= i; ++j) {                 PolynomialFunction pj = PolynomialsUtils.createLaguerrePolynomial(j);                 checkOrthogonality(pi, pj, weight, 0.0, 100.0, 0.99999, 1.0e-13);             }         }     }      @Test     public void testFirstLegendrePolynomials() {         checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3),  2l, "-3 x + 5 x^3");         checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2),  2l, "-1 + 3 x^2");         checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1),  1l, "x");         checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0),  1l, "1");          checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7), 16l, "-35 x + 315 x^3 - 693 x^5 + 429 x^7");         checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6), 16l, "-5 + 105 x^2 - 315 x^4 + 231 x^6");         checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5),  8l, "15 x - 70 x^3 + 63 x^5");         checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4),  8l, "3 - 30 x^2 + 35 x^4");      }      @Test     public void testLegendreDifferentials() {         for (int k = 0; k < 12; ++k) {              PolynomialFunction Pk0 = PolynomialsUtils.createLegendrePolynomial(k);             PolynomialFunction Pk1 = Pk0.polynomialDerivative();             PolynomialFunction Pk2 = Pk1.polynomialDerivative();              PolynomialFunction g0 = new PolynomialFunction(new double[] { k * (k + 1) });             PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });             PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });              PolynomialFunction Pk0g0 = Pk0.multiply(g0);             PolynomialFunction Pk1g1 = Pk1.multiply(g1);             PolynomialFunction Pk2g2 = Pk2.multiply(g2);              checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2)));          }     }      @Test     public void testLegendreOrthogonality() {         UnivariateFunction weight = new UnivariateFunction() {             @Override             public double value(double x) {                 return 1;             }         };         for (int i = 0; i < 10; ++i) {             PolynomialFunction pi = PolynomialsUtils.createLegendrePolynomial(i);             for (int j = 0; j <= i; ++j) {                 PolynomialFunction pj = PolynomialsUtils.createLegendrePolynomial(j);                 checkOrthogonality(pi, pj, weight, -1, 1, 0.1, 1.0e-13);             }         }     }      @Test     public void testHighDegreeLegendre() {         PolynomialsUtils.createLegendrePolynomial(40);         double[] l40 = PolynomialsUtils.createLegendrePolynomial(40).getCoefficients();         double denominator = 274877906944d;         double[] numerators = new double[] {                           +34461632205d,            -28258538408100d,          +3847870979902950d,        -207785032914759300d,                   +5929294332103310025d,     -103301483474866556880d,    +1197358103913226000200d,    -9763073770369381232400d,               +58171647881784229843050d,  -260061484647976556945400d,  +888315281771246239250340d, -2345767627188139419665400d,             +4819022625419112503443050d, -7710436200670580005508880d, +9566652323054238154983240d, -9104813935044723209570256d,             +6516550296251767619752905d, -3391858621221953912598660d, +1211378079007840683070950d,  -265365894974690562152100d,               +26876802183334044115405d         };         for (int i = 0; i < l40.length; ++i) {             if (i % 2 == 0) {                 double ci = numerators[i / 2] / denominator;                 Assert.assertEquals(ci, l40[i], FastMath.abs(ci) * 1e-15);             } else {                 Assert.assertEquals(0, l40[i], 0);             }         }     }      @Test     public void testJacobiLegendre() {         for (int i = 0; i < 10; ++i) {             PolynomialFunction legendre = PolynomialsUtils.createLegendrePolynomial(i);             PolynomialFunction jacobi   = PolynomialsUtils.createJacobiPolynomial(i, 0, 0);             checkNullPolynomial(legendre.subtract(jacobi));         }     }      @Test     public void testJacobiEvaluationAt1() {         for (int v = 0; v < 10; ++v) {             for (int w = 0; w < 10; ++w) {                 for (int i = 0; i < 10; ++i) {                     PolynomialFunction jacobi = PolynomialsUtils.createJacobiPolynomial(i, v, w);                     double binomial = BinomialCoefficient.value(v + i, i);                     Assert.assertTrue(Precision.equals(binomial, jacobi.value(1.0), 1));                 }             }         }     }      @Test     public void testJacobiOrthogonality() {         for (int v = 0; v < 5; ++v) {             for (int w = v; w < 5; ++w) {                 final int vv = v;                 final int ww = w;                 UnivariateFunction weight = new UnivariateFunction() {                     @Override                     public double value(double x) {                         return FastMath.pow(1 - x, vv) * FastMath.pow(1 + x, ww);                     }                 };                 for (int i = 0; i < 10; ++i) {                     PolynomialFunction pi = PolynomialsUtils.createJacobiPolynomial(i, v, w);                     for (int j = 0; j <= i; ++j) {                         PolynomialFunction pj = PolynomialsUtils.createJacobiPolynomial(j, v, w);                         checkOrthogonality(pi, pj, weight, -1, 1, 0.1, 1.0e-12);                     }                 }             }         }     }      @Test     public void testShift() {         // f1(x) = 1 + x + 2 x^2         PolynomialFunction f1x = new PolynomialFunction(new double[] { 1, 1, 2 });          PolynomialFunction f1x1             = new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(), 1));         checkPolynomial(f1x1, "4 + 5 x + 2 x^2");          PolynomialFunction f1xM1             = new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(), -1));         checkPolynomial(f1xM1, "2 - 3 x + 2 x^2");          PolynomialFunction f1x3             = new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(), 3));         checkPolynomial(f1x3, "22 + 13 x + 2 x^2");          // f2(x) = 2 + 3 x^2 + 8 x^3 + 121 x^5         PolynomialFunction f2x = new PolynomialFunction(new double[]{2, 0, 3, 8, 0, 121});          PolynomialFunction f2x1             = new PolynomialFunction(PolynomialsUtils.shift(f2x.getCoefficients(), 1));         checkPolynomial(f2x1, "134 + 635 x + 1237 x^2 + 1218 x^3 + 605 x^4 + 121 x^5");          PolynomialFunction f2x3             = new PolynomialFunction(PolynomialsUtils.shift(f2x.getCoefficients(), 3));         checkPolynomial(f2x3, "29648 + 49239 x + 32745 x^2 + 10898 x^3 + 1815 x^4 + 121 x^5");     }       private void checkPolynomial(PolynomialFunction p, long denominator, String reference) {         PolynomialFunction q = new PolynomialFunction(new double[] { denominator});         Assert.assertEquals(reference, p.multiply(q).toString());     }      private void checkPolynomial(PolynomialFunction p, String reference) {         Assert.assertEquals(reference, p.toString());     }      private void checkNullPolynomial(PolynomialFunction p) {         for (double coefficient : p.getCoefficients()) {             Assert.assertEquals(0, coefficient, 1e-13);         }     }      private void checkOrthogonality(final PolynomialFunction p1,                                     final PolynomialFunction p2,                                     final UnivariateFunction weight,                                     final double a, final double b,                                     final double nonZeroThreshold,                                     final double zeroThreshold) {         UnivariateFunction f = new UnivariateFunction() {             @Override             public double value(double x) {                 return weight.value(x) * p1.value(x) * p2.value(x);             }         };         double dotProduct =                 new IterativeLegendreGaussIntegrator(5, 1.0e-9, 1.0e-8, 2, 15).integrate(1000000, f, a, b);         if (p1.degree() == p2.degree()) {             // integral should be non-zero             Assert.assertTrue("I(" + p1.degree() + ", " + p2.degree() + ") = "+ dotProduct,                               FastMath.abs(dotProduct) > nonZeroThreshold);         } else {             // integral should be zero             Assert.assertEquals("I(" + p1.degree() + ", " + p2.degree() + ") = "+ dotProduct,                                 0.0, FastMath.abs(dotProduct), zeroThreshold);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.polynomials;  import java.util.Arrays;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.OutOfRangeException; import org.junit.Assert; import org.junit.Test;  /**  * Tests the PolynomialSplineFunction implementation.  *  */ public class PolynomialSplineFunctionTest {      /** Error tolerance for tests */     protected double tolerance = 1.0e-12;      /**      * Quadratic polynomials used in tests:      *      * x^2 + x            [-1, 0)      * x^2 + x + 2        [0, 1)      * x^2 + x + 4        [1, 2)      *      * Defined so that evaluation using PolynomialSplineFunction evaluation      * algorithm agrees at knot point boundaries.      */     protected PolynomialFunction[] polynomials = {         new PolynomialFunction(new double[] {0d, 1d, 1d}),         new PolynomialFunction(new double[] {2d, 1d, 1d}),         new PolynomialFunction(new double[] {4d, 1d, 1d})     };      /** Knot points  */     protected double[] knots = {-1, 0, 1, 2};      /** Derivative of test polynomials -- 2x + 1  */     protected PolynomialFunction dp =         new PolynomialFunction(new double[] {1d, 2d});       @Test     public void testConstructor() {         PolynomialSplineFunction spline =             new PolynomialSplineFunction(knots, polynomials);         Assert.assertTrue(Arrays.equals(knots, spline.getKnots()));         Assert.assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);         Assert.assertEquals(3, spline.getN());          try { // too few knots             new PolynomialSplineFunction(new double[] {0}, polynomials);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }          try { // too many knots             new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }          try { // knots not increasing             new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);             Assert.fail("Expecting MathIllegalArgumentException");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      @Test     public void testValues() {         PolynomialSplineFunction spline =             new PolynomialSplineFunction(knots, polynomials);         UnivariateFunction dSpline = spline.polynomialSplineDerivative();          /**          * interior points -- spline value at x should equal p(x - knot)          * where knot is the largest knot point less than or equal to x and p          * is the polynomial defined over the knot segment to which x belongs.          */         double x = -1;         int index = 0;         for (int i = 0; i < 10; i++) {            x+=0.25;            index = findKnot(knots, x);            Assert.assertEquals("spline function evaluation failed for x=" + x,                    polynomials[index].value(x - knots[index]), spline.value(x), tolerance);            Assert.assertEquals("spline derivative evaluation failed for x=" + x,                    dp.value(x - knots[index]), dSpline.value(x), tolerance);         }          // knot points -- centering should zero arguments         for (int i = 0; i < 3; i++) {             Assert.assertEquals("spline function evaluation failed for knot=" + knots[i],                     polynomials[i].value(0), spline.value(knots[i]), tolerance);             Assert.assertEquals("spline function evaluation failed for knot=" + knots[i],                     dp.value(0), dSpline.value(knots[i]), tolerance);         }          try { //outside of domain -- under min             x = spline.value(-1.5);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }          try { //outside of domain -- over max             x = spline.value(2.5);             Assert.fail("Expecting OutOfRangeException");         } catch (OutOfRangeException ex) {             // expected         }     }      @Test     public void testIsValidPoint() {         final PolynomialSplineFunction spline =             new PolynomialSplineFunction(knots, polynomials);         final double xMin = knots[0];         final double xMax = knots[knots.length - 1];          double x;          x = xMin;         Assert.assertTrue(spline.isValidPoint(x));         // Ensure that no exception is thrown.         spline.value(x);          x = xMax;         Assert.assertTrue(spline.isValidPoint(x));         // Ensure that no exception is thrown.         spline.value(x);          final double xRange = xMax - xMin;         x = xMin + xRange / 3.4;         Assert.assertTrue(spline.isValidPoint(x));         // Ensure that no exception is thrown.         spline.value(x);          final double small = 1e-8;         x = xMin - small;         Assert.assertFalse(spline.isValidPoint(x));         // Ensure that an exception would have been thrown.         try {             spline.value(x);             Assert.fail("OutOfRangeException expected");         } catch (OutOfRangeException expected) {}     }      /**      *  Do linear search to find largest knot point less than or equal to x.      *  Implementation does binary search.      */      protected int findKnot(double[] knots, double x) {          if (x < knots[0] || x >= knots[knots.length -1]) {              throw new OutOfRangeException(x, knots[0], knots[knots.length -1]);          }          for (int i = 0; i < knots.length; i++) {              if (knots[i] > x) {                  return i - 1;              }          }          throw new MathIllegalStateException();      } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.polynomials;  import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;   /**  * Test case for Newton form of polynomial function.  * <p>  * The small tolerance number is used only to account for round-off errors.  *  */ public final class PolynomialFunctionNewtonFormTest {      /**      * Test of polynomial for the linear function.      */     @Test     public void testLinearFunction() {         PolynomialFunctionNewtonForm p;         double coefficients[], z, expected, result, tolerance = 1E-12;          // p(x) = 1.5x - 4 = 2 + 1.5(x-4)         double a[] = { 2.0, 1.5 };         double c[] = { 4.0 };         p = new PolynomialFunctionNewtonForm(a, c);          z = 2.0; expected = -1.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 4.5; expected = 2.75; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 6.0; expected = 5.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          Assert.assertEquals(1, p.degree());          coefficients = p.getCoefficients();         Assert.assertEquals(2, coefficients.length);         Assert.assertEquals(-4.0, coefficients[0], tolerance);         Assert.assertEquals(1.5, coefficients[1], tolerance);     }      /**      * Test of polynomial for the quadratic function.      */     @Test     public void testQuadraticFunction() {         PolynomialFunctionNewtonForm p;         double coefficients[], z, expected, result, tolerance = 1E-12;          // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)         double a[] = { 4.0, 3.0, 2.0 };         double c[] = { 1.0, -2.0 };         p = new PolynomialFunctionNewtonForm(a, c);          z = 1.0; expected = 4.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 2.5; expected = 22.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = -2.0; expected = -5.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          Assert.assertEquals(2, p.degree());          coefficients = p.getCoefficients();         Assert.assertEquals(3, coefficients.length);         Assert.assertEquals(-3.0, coefficients[0], tolerance);         Assert.assertEquals(5.0, coefficients[1], tolerance);         Assert.assertEquals(2.0, coefficients[2], tolerance);     }      /**      * Test of polynomial for the quintic function.      */     @Test     public void testQuinticFunction() {         PolynomialFunctionNewtonForm p;         double coefficients[], z, expected, result, tolerance = 1E-12;          // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x         //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)         double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };         double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };         p = new PolynomialFunctionNewtonForm(a, c);          z = 0.0; expected = 0.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = -2.0; expected = 0.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 4.0; expected = 360.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          Assert.assertEquals(5, p.degree());          coefficients = p.getCoefficients();         Assert.assertEquals(6, coefficients.length);         Assert.assertEquals(0.0, coefficients[0], tolerance);         Assert.assertEquals(6.0, coefficients[1], tolerance);         Assert.assertEquals(1.0, coefficients[2], tolerance);         Assert.assertEquals(-7.0, coefficients[3], tolerance);         Assert.assertEquals(-1.0, coefficients[4], tolerance);         Assert.assertEquals(1.0, coefficients[5], tolerance);     }      /**      * Test for derivatives.      */     @Test     public void testDerivative() {          // x^3 = 0 * [1] + 1 * [x] + 3 * [x(x-1)] + 1 * [x(x-1)(x-2)]         PolynomialFunctionNewtonForm p =                 new PolynomialFunctionNewtonForm(new double[] { 0, 1, 3, 1 },                                                  new double[] { 0, 1, 2 });          double eps = 2.0e-14;         for (double t = 0.0; t < 10.0; t += 0.1) {             DerivativeStructure x = new DerivativeStructure(1, 4, 0, t);             DerivativeStructure y = p.value(x);             Assert.assertEquals(t * t * t,   y.getValue(),              eps * t * t * t);             Assert.assertEquals(3.0 * t * t, y.getPartialDerivative(1), eps * 3.0 * t * t);             Assert.assertEquals(6.0 * t,     y.getPartialDerivative(2), eps * 6.0 * t);             Assert.assertEquals(6.0,         y.getPartialDerivative(3), eps * 6.0);             Assert.assertEquals(0.0,         y.getPartialDerivative(4), eps);         }      }      /**      * Test of parameters for the polynomial.      */     @Test     public void testParameters() {          try {             // bad input array length             double a[] = { 1.0 };             double c[] = { 2.0 };             new PolynomialFunctionNewtonForm(a, c);             Assert.fail("Expecting MathIllegalArgumentException - bad input array length");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             // mismatch input arrays             double a[] = { 1.0, 2.0, 3.0, 4.0 };             double c[] = { 4.0, 3.0, 2.0, 1.0 };             new PolynomialFunctionNewtonForm(a, c);             Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays");         } catch (MathIllegalArgumentException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.polynomials;  import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Tests the PolynomialFunction implementation of a UnivariateFunction.  *  */ public final class PolynomialFunctionTest {     /** Error tolerance for tests */     protected double tolerance = 1e-12;      /**      * tests the value of a constant polynomial.      *      * <p>value of this is 2.5 everywhere.</p>      */     @Test     public void testConstants() {         double[] c = { 2.5 };         PolynomialFunction f = new PolynomialFunction(c);          // verify that we are equal to c[0] at several (nonsymmetric) places         Assert.assertEquals(f.value(0), c[0], tolerance);         Assert.assertEquals(f.value(-1), c[0], tolerance);         Assert.assertEquals(f.value(-123.5), c[0], tolerance);         Assert.assertEquals(f.value(3), c[0], tolerance);         Assert.assertEquals(f.value(456.89), c[0], tolerance);          Assert.assertEquals(f.degree(), 0);         Assert.assertEquals(f.polynomialDerivative().value(0), 0, tolerance);          Assert.assertEquals(f.polynomialDerivative().polynomialDerivative().value(0), 0, tolerance);     }      /**      * tests the value of a linear polynomial.      *      * <p>This will test the function f(x) = 3*x - 1.5</p>      * <p>This will have the values      *  <tt>f(0) = -1.5, f(-1) = -4.5, f(-2.5) = -9,      *      f(0.5) = 0, f(1.5) = 3</tt> and {@code f(3) = 7.5}      * </p>      */     @Test     public void testLinear() {         double[] c = { -1.5, 3 };         PolynomialFunction f = new PolynomialFunction(c);          // verify that we are equal to c[0] when x=0         Assert.assertEquals(f.value(0), c[0], tolerance);          // now check a few other places         Assert.assertEquals(-4.5, f.value(-1), tolerance);         Assert.assertEquals(-9, f.value(-2.5), tolerance);         Assert.assertEquals(0, f.value(0.5), tolerance);         Assert.assertEquals(3, f.value(1.5), tolerance);         Assert.assertEquals(7.5, f.value(3), tolerance);          Assert.assertEquals(f.degree(), 1);          Assert.assertEquals(f.polynomialDerivative().polynomialDerivative().value(0), 0, tolerance);     }      /**      * Tests a second order polynomial.      * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>      */     @Test     public void testQuadratic() {         double[] c = { -2, -3, 2 };         PolynomialFunction f = new PolynomialFunction(c);          // verify that we are equal to c[0] when x=0         Assert.assertEquals(f.value(0), c[0], tolerance);          // now check a few other places         Assert.assertEquals(0, f.value(-0.5), tolerance);         Assert.assertEquals(0, f.value(2), tolerance);         Assert.assertEquals(-2, f.value(1.5), tolerance);         Assert.assertEquals(7, f.value(-1.5), tolerance);         Assert.assertEquals(265.5312, f.value(12.34), tolerance);     }      /**      * This will test the quintic function      *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>      */     @Test     public void testQuintic() {         double[] c = { 0, 0, 15, -13, -3, 1 };         PolynomialFunction f = new PolynomialFunction(c);          // verify that we are equal to c[0] when x=0         Assert.assertEquals(f.value(0), c[0], tolerance);          // now check a few other places         Assert.assertEquals(0, f.value(5), tolerance);         Assert.assertEquals(0, f.value(1), tolerance);         Assert.assertEquals(0, f.value(-3), tolerance);         Assert.assertEquals(54.84375, f.value(-1.5), tolerance);         Assert.assertEquals(-8.06637, f.value(1.3), tolerance);          Assert.assertEquals(f.degree(), 5);     }      /**      * tests the firstDerivative function by comparison      *      * <p>This will test the functions      * {@code f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6}      * and {@code h(x) = 6x - 4}      */     @Test     public void testfirstDerivativeComparison() {         double[] f_coeff = { 3, 6, -2, 1 };         double[] g_coeff = { 6, -4, 3 };         double[] h_coeff = { -4, 6 };          PolynomialFunction f = new PolynomialFunction(f_coeff);         PolynomialFunction g = new PolynomialFunction(g_coeff);         PolynomialFunction h = new PolynomialFunction(h_coeff);          // compare f' = g         Assert.assertEquals(f.polynomialDerivative().value(0), g.value(0), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(1), g.value(1), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(100), g.value(100), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(4.1), g.value(4.1), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(-3.25), g.value(-3.25), tolerance);          // compare g' = h         Assert.assertEquals(g.polynomialDerivative().value(FastMath.PI), h.value(FastMath.PI), tolerance);         Assert.assertEquals(g.polynomialDerivative().value(FastMath.E),  h.value(FastMath.E),  tolerance);     }      @Test     public void testString() {         PolynomialFunction p = new PolynomialFunction(new double[] { -5, 3, 1 });         checkPolynomial(p, "-5 + 3 x + x^2");         checkPolynomial(new PolynomialFunction(new double[] { 0, -2, 3 }),                         "-2 x + 3 x^2");         checkPolynomial(new PolynomialFunction(new double[] { 1, -2, 3 }),                       "1 - 2 x + 3 x^2");         checkPolynomial(new PolynomialFunction(new double[] { 0,  2, 3 }),                        "2 x + 3 x^2");         checkPolynomial(new PolynomialFunction(new double[] { 1,  2, 3 }),                      "1 + 2 x + 3 x^2");         checkPolynomial(new PolynomialFunction(new double[] { 1,  0, 3 }),                      "1 + 3 x^2");         checkPolynomial(new PolynomialFunction(new double[] { 0 }),                      "0");     }      @Test     public void testAddition() {         PolynomialFunction p1 = new PolynomialFunction(new double[] { -2, 1 });         PolynomialFunction p2 = new PolynomialFunction(new double[] { 2, -1, 0 });         checkNullPolynomial(p1.add(p2));          p2 = p1.add(p1);         checkPolynomial(p2, "-4 + 2 x");          p1 = new PolynomialFunction(new double[] { 1, -4, 2 });         p2 = new PolynomialFunction(new double[] { -1, 3, -2 });         p1 = p1.add(p2);         Assert.assertEquals(1, p1.degree());         checkPolynomial(p1, "-x");     }      @Test     public void testSubtraction() {         PolynomialFunction p1 = new PolynomialFunction(new double[] { -2, 1 });         checkNullPolynomial(p1.subtract(p1));          PolynomialFunction p2 = new PolynomialFunction(new double[] { -2, 6 });         p2 = p2.subtract(p1);         checkPolynomial(p2, "5 x");          p1 = new PolynomialFunction(new double[] { 1, -4, 2 });         p2 = new PolynomialFunction(new double[] { -1, 3, 2 });         p1 = p1.subtract(p2);         Assert.assertEquals(1, p1.degree());         checkPolynomial(p1, "2 - 7 x");     }      @Test     public void testMultiplication() {         PolynomialFunction p1 = new PolynomialFunction(new double[] { -3, 2 });         PolynomialFunction p2 = new PolynomialFunction(new double[] { 3, 2, 1 });         checkPolynomial(p1.multiply(p2), "-9 + x^2 + 2 x^3");          p1 = new PolynomialFunction(new double[] { 0, 1 });         p2 = p1;         for (int i = 2; i < 10; ++i) {             p2 = p2.multiply(p1);             checkPolynomial(p2, "x^" + i);         }     }      @Test     public void testSerial() {         PolynomialFunction p2 = new PolynomialFunction(new double[] { 3, 2, 1 });         Assert.assertEquals(p2, TestUtils.serializeAndRecover(p2));     }      /**      * tests the firstDerivative function by comparison      *      * <p>This will test the functions      * {@code f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6}      * and {@code h(x) = 6x - 4}      */     @Test     public void testMath341() {         double[] f_coeff = { 3, 6, -2, 1 };         double[] g_coeff = { 6, -4, 3 };         double[] h_coeff = { -4, 6 };          PolynomialFunction f = new PolynomialFunction(f_coeff);         PolynomialFunction g = new PolynomialFunction(g_coeff);         PolynomialFunction h = new PolynomialFunction(h_coeff);          // compare f' = g         Assert.assertEquals(f.polynomialDerivative().value(0), g.value(0), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(1), g.value(1), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(100), g.value(100), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(4.1), g.value(4.1), tolerance);         Assert.assertEquals(f.polynomialDerivative().value(-3.25), g.value(-3.25), tolerance);          // compare g' = h         Assert.assertEquals(g.polynomialDerivative().value(FastMath.PI), h.value(FastMath.PI), tolerance);         Assert.assertEquals(g.polynomialDerivative().value(FastMath.E),  h.value(FastMath.E),  tolerance);     }      public void checkPolynomial(PolynomialFunction p, String reference) {         Assert.assertEquals(reference, p.toString());     }      private void checkNullPolynomial(PolynomialFunction p) {         for (double coefficient : p.getCoefficients()) {             Assert.assertEquals(0, coefficient, 1e-15);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.polynomials;  import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test;  /**  * Test case for Lagrange form of polynomial function.  * <p>  * We use n+1 points to interpolate a polynomial of degree n. This should  * give us the exact same polynomial as result. Thus we can use a very  * small tolerance to account only for round-off errors.  *  */ public final class PolynomialFunctionLagrangeFormTest {      /**      * Test of polynomial for the linear function.      */     @Test     public void testLinearFunction() {         PolynomialFunctionLagrangeForm p;         double c[], z, expected, result, tolerance = 1E-12;          // p(x) = 1.5x - 4         double x[] = { 0.0, 3.0 };         double y[] = { -4.0, 0.5 };         p = new PolynomialFunctionLagrangeForm(x, y);          z = 2.0; expected = -1.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 4.5; expected = 2.75; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 6.0; expected = 5.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          Assert.assertEquals(1, p.degree());          c = p.getCoefficients();         Assert.assertEquals(2, c.length);         Assert.assertEquals(-4.0, c[0], tolerance);         Assert.assertEquals(1.5, c[1], tolerance);     }      /**      * Test of polynomial for the quadratic function.      */     @Test     public void testQuadraticFunction() {         PolynomialFunctionLagrangeForm p;         double c[], z, expected, result, tolerance = 1E-12;          // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)         double x[] = { 0.0, -1.0, 0.5 };         double y[] = { -3.0, -6.0, 0.0 };         p = new PolynomialFunctionLagrangeForm(x, y);          z = 1.0; expected = 4.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 2.5; expected = 22.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = -2.0; expected = -5.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          Assert.assertEquals(2, p.degree());          c = p.getCoefficients();         Assert.assertEquals(3, c.length);         Assert.assertEquals(-3.0, c[0], tolerance);         Assert.assertEquals(5.0, c[1], tolerance);         Assert.assertEquals(2.0, c[2], tolerance);     }      /**      * Test of polynomial for the quintic function.      */     @Test     public void testQuinticFunction() {         PolynomialFunctionLagrangeForm p;         double c[], z, expected, result, tolerance = 1E-12;          // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)         double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };         double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };         p = new PolynomialFunctionLagrangeForm(x, y);          z = 0.0; expected = 0.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = -2.0; expected = 0.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          z = 4.0; expected = 360.0; result = p.value(z);         Assert.assertEquals(expected, result, tolerance);          Assert.assertEquals(5, p.degree());          c = p.getCoefficients();         Assert.assertEquals(6, c.length);         Assert.assertEquals(0.0, c[0], tolerance);         Assert.assertEquals(6.0, c[1], tolerance);         Assert.assertEquals(1.0, c[2], tolerance);         Assert.assertEquals(-7.0, c[3], tolerance);         Assert.assertEquals(-1.0, c[4], tolerance);         Assert.assertEquals(1.0, c[5], tolerance);     }      /**      * Test of parameters for the polynomial.      */     @Test     public void testParameters() {          try {             // bad input array length             double x[] = { 1.0 };             double y[] = { 2.0 };             new PolynomialFunctionLagrangeForm(x, y);             Assert.fail("Expecting MathIllegalArgumentException - bad input array length");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             // mismatch input arrays             double x[] = { 1.0, 2.0, 3.0, 4.0 };             double y[] = { 0.0, -4.0, -24.0 };             new PolynomialFunctionLagrangeForm(x, y);             Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays");         } catch (MathIllegalArgumentException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test case for trapezoid integrator.  * <p>  * Test runs show that for a default relative accuracy of 1E-6, it  * generally takes 10 to 15 iterations for the integral to converge.  *  */ public final class TrapezoidIntegratorTest {      /**      * Test of integrator for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateIntegrator integrator = new TrapezoidIntegrator();         double min, max, expected, result, tolerance;          min = 0; max = FastMath.PI; expected = 2;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(10000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 2500);         Assert.assertTrue(integrator.getIterations()  < 15);         Assert.assertEquals(expected, result, tolerance);          min = -FastMath.PI/3; max = 0; expected = -0.5;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(10000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 2500);         Assert.assertTrue(integrator.getIterations()  < 15);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of integrator for the quintic function.      */     @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateIntegrator integrator = new TrapezoidIntegrator();         double min, max, expected, result, tolerance;          min = 0; max = 1; expected = -1.0/48;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(10000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 5000);         Assert.assertTrue(integrator.getIterations()  < 15);         Assert.assertEquals(expected, result, tolerance);          min = 0; max = 0.5; expected = 11.0/768;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(10000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 2500);         Assert.assertTrue(integrator.getIterations()  < 15);         Assert.assertEquals(expected, result, tolerance);          min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(10000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 5000);         Assert.assertTrue(integrator.getIterations()  < 15);         Assert.assertEquals(expected, result, tolerance);      }      /**      * Test of parameters for the integrator.      */     @Test     public void testParameters() {         UnivariateFunction f = new Sin();          try {             // bad interval             new TrapezoidIntegrator().integrate(1000, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // bad iteration limits             new TrapezoidIntegrator(5, 4);             Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             // bad iteration limits             new TrapezoidIntegrator(10,99);             Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");         } catch (NumberIsTooLargeException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test case for Romberg integrator.  * <p>  * Romberg algorithm is very fast for good behavior integrand. Test runs  * show that for a default relative accuracy of 1E-6, it generally takes  * takes less than 5 iterations for the integral to converge.  *  */ public final class RombergIntegratorTest {      /**      * Test of integrator for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateIntegrator integrator = new RombergIntegrator();         double min, max, expected, result, tolerance;          min = 0; max = FastMath.PI; expected = 2;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(100, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 50);         Assert.assertTrue(integrator.getIterations()  < 10);         Assert.assertEquals(expected, result, tolerance);          min = -FastMath.PI/3; max = 0; expected = -0.5;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(100, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 50);         Assert.assertTrue(integrator.getIterations()  < 10);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of integrator for the quintic function.      */     @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateIntegrator integrator = new RombergIntegrator();         double min, max, expected, result, tolerance;          min = 0; max = 1; expected = -1.0/48;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(100, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 10);         Assert.assertTrue(integrator.getIterations()  < 5);         Assert.assertEquals(expected, result, tolerance);          min = 0; max = 0.5; expected = 11.0/768;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(100, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 10);         Assert.assertTrue(integrator.getIterations()  < 5);         Assert.assertEquals(expected, result, tolerance);          min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(100, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 10);         Assert.assertTrue(integrator.getIterations()  < 5);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of parameters for the integrator.      */     @Test     public void testParameters() {         UnivariateFunction f = new Sin();          try {             // bad interval             new RombergIntegrator().integrate(1000, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // bad iteration limits             new RombergIntegrator(5, 4);             Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             // bad iteration limits             new RombergIntegrator(10, 50);             Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");         } catch (NumberIsTooLargeException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Identity; import org.apache.commons.math4.analysis.function.Inverse; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   /**  * Test case for Simpson integrator.  * <p>  * Test runs show that for a default relative accuracy of 1E-6, it  * generally takes 5 to 10 iterations for the integral to converge.  *  */ public final class SimpsonIntegratorTest {      /**      * Test of integrator for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateIntegrator integrator = new SimpsonIntegrator();         double min, max, expected, result, tolerance;          min = 0; max = FastMath.PI; expected = 2;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(1000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 100);         Assert.assertTrue(integrator.getIterations()  < 10);         Assert.assertEquals(expected, result, tolerance);          min = -FastMath.PI/3; max = 0; expected = -0.5;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(1000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 50);         Assert.assertTrue(integrator.getIterations()  < 10);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of integrator for the quintic function.      */     @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateIntegrator integrator = new SimpsonIntegrator();         double min, max, expected, result, tolerance;          min = 0; max = 1; expected = -1.0/48;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(1000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 150);         Assert.assertTrue(integrator.getIterations()  < 10);         Assert.assertEquals(expected, result, tolerance);          min = 0; max = 0.5; expected = 11.0/768;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(1000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 100);         Assert.assertTrue(integrator.getIterations()  < 10);         Assert.assertEquals(expected, result, tolerance);          min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(1000, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < 150);         Assert.assertTrue(integrator.getIterations()  < 10);         Assert.assertEquals(expected, result, tolerance);     }      /**      * Test of parameters for the integrator.      */     @Test     public void testParameters() {         UnivariateFunction f = new Sin();         try {             // bad interval             new SimpsonIntegrator().integrate(1000, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // bad iteration limits             new SimpsonIntegrator(5, 4);             Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             // bad iteration limits             new SimpsonIntegrator(10, SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT + 1);             Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");         } catch (NumberIsTooLargeException ex) {             // expected         }     }      // Tests for MATH-1458:     // The SimpsonIntegrator had the following bugs:     // - minimalIterationCount==1 results in no possible iteration     // - minimalIterationCount==1 computes incorrect Simpson sum (following no iteration)     // - minimalIterationCount>1 computes the first iteration sum as the Trapezoid sum     // - minimalIterationCount>1 computes the second iteration sum as the first Simpson sum      /**      * Test iteration is possible when minimalIterationCount==1.      * <br/>      * MATH-1458: No iterations were performed when minimalIterationCount==1.      */     @Test     public void testIterationIsPossibleWhenMinimalIterationCountIs1() {         UnivariateFunction f = new Sin();         UnivariateIntegrator integrator = new SimpsonIntegrator(1,                 SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT);         // The range or result is not relevant.         // This sum should not converge at 1 iteration.         // This tests iteration occurred.         integrator.integrate(1000, f, 0, 1);         // MATH-1458: No iterations were performed when minimalIterationCount==1         Assert.assertTrue("Iteration is not above 1",                 integrator.getIterations() > 1);     }      /**      * Test convergence at iteration 1 when minimalIterationCount==1.      * <br/>      * MATH-1458: No iterations were performed when minimalIterationCount==1.      */     @Test     public void testConvergenceIsPossibleAtIteration1() {     	// A linear function y=x should converge immediately         UnivariateFunction f = new Identity();         UnivariateIntegrator integrator = new SimpsonIntegrator(1,                 SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT);          double min, max, expected, result, tolerance;          min = 0; max = 1; expected = 0.5;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(1000, f, min, max);         // MATH-1458: No iterations were performed when minimalIterationCount==1         Assert.assertTrue("Iteration is not above 0",                 integrator.getIterations()  > 0);         // This should converge immediately         Assert.assertEquals("Iteration", integrator.getIterations(), 1);         Assert.assertEquals("Result", expected, result, tolerance);     }      /**      * Compute the integral using the composite Simpson's rule.      *      * @param f the function      * @param a the lower limit      * @param b the upper limit      * @param n the number of intervals (must be even)      * @return the integral between a and b      * @see <a href="https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule">      *       Composite_Simpson's_rule</a>      */     private static double compositeSimpsonsRule(UnivariateFunction f, double a,             double b, int n)     {         // Sum interval [a,b] split into n subintervals, with n an even number:         // sum ~ h/3 * [ f(x0) + 4f(x1) + 2f(x2) + 4f(x3) + 2f(x4) ... + 4f(xn-1) + f(xn) ]         // h = (b-a)/n         // f(xi) = f(a + i*h)         assert n > 0 && n % 2 == 0 : "n must be strictly positive and even";         final double h = (b - a) / n;         double sum4 = 0;         double sum2 = 0;         for (int i = 1; i < n; i++) {             // Alternate sums that are multiplied by 4 and 2             final double fxi = f.value(a + i * h);             if (i % 2 == 0)                 sum2 += fxi;             else                 sum4 += fxi;         }         return (h / 3) * (f.value(a) + 4 * sum4 + 2 * sum2 + f.value(b));     }      /**      * Compute the iteration of Simpson's rule.      *      * @param f the function      * @param a the lower limit      * @param b the upper limit      * @param iteration the refinement iteration      * @return the integral between a and b      */     private static double computeSimpsonIteration(UnivariateFunction f, double a,             double b, int iteration)     {         // The first possible Simpson's sum uses n=2.         // The next uses n=4. This is the 1st refinement expected when the         // integrator has performed 1 iteration.         final int n = 2 << iteration;         return compositeSimpsonsRule(f, a, b, n);     }      /**      * Test the reference Simpson integration is doing what is expected      */     @Test     public void testReferenceSimpsonItegrationIsCorrect() {         UnivariateFunction f = new Sin();          double a, b, h, expected, result, tolerance;          a = 0.5;         b = 1;          double b_a = b - a;          // First Simpson sum. 1 midpoint evaluation:         h = b_a / 2;         double f00 = f.value(a);         double f01 = f.value(a + 1 * h);         double f0n = f.value(b);         expected = (b_a / 6) * (f00 + 4 * f01 + f0n);         tolerance = FastMath.abs(expected * SimpsonIntegrator.DEFAULT_RELATIVE_ACCURACY);         result = computeSimpsonIteration(f, a, b, 0);         Assert.assertEquals("Result", expected, result, tolerance);          // Second Simpson sum: 2 more evaluations:         h = b_a / 4;         double f11 = f.value(a + 1 * h);         double f13 = f.value(a + 3 * h);         expected = (h / 3) * (f00 + 4 * f11 + 2 * f01 + 4 * f13 + f0n);         tolerance = FastMath.abs(expected * SimpsonIntegrator.DEFAULT_RELATIVE_ACCURACY);         result = computeSimpsonIteration(f, a, b, 1);         Assert.assertEquals("Result", expected, result, tolerance);          // Third Simpson sum: 4 more evaluations:         h = b_a / 8;         double f21 = f.value(a + 1 * h);         double f23 = f.value(a + 3 * h);         double f25 = f.value(a + 5 * h);         double f27 = f.value(a + 7 * h);         expected = (h / 3) * (f00 + 4 * f21 + 2 * f11 + 4 * f23 + 2 * f01 + 4 * f25 +                 2 * f13 + 4 * f27 + f0n);         tolerance = FastMath.abs(expected * SimpsonIntegrator.DEFAULT_RELATIVE_ACCURACY);         result = computeSimpsonIteration(f, a, b, 2);         Assert.assertEquals("Result", expected, result, tolerance);     }      /**      * Test iteration 1 returns the expected sum when minimalIterationCount==1.      * <br/>      * MATH-1458: minimalIterationCount==1 computes incorrect Simpson sum      * (following no iteration).      */     @Test     public void testIteration1ComputesTheExpectedSimpsonSum() {         UnivariateFunction f = new Sin();         // Set convergence criteria to force immediate convergence         UnivariateIntegrator integrator = new SimpsonIntegrator(                 0, Double.POSITIVE_INFINITY,                 1, SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT);         double min, max, expected, result, tolerance;          // MATH-1458: minimalIterationCount==1 computes incorrect         // Simpson sum (following no iteration)         min = 0;         max = 1;         result = integrator.integrate(1000, f, min, max);         // Immediate convergence         Assert.assertEquals("Iteration", 1, integrator.getIterations());          // Check the sum is as expected         expected = computeSimpsonIteration(f, min, max, 1);         tolerance = FastMath.abs(expected * SimpsonIntegrator.DEFAULT_RELATIVE_ACCURACY);         Assert.assertEquals("Result", expected, result, tolerance);     }      /**      * Test iteration N returns the expected sum when minimalIterationCount==1.      * <br/>      * MATH-1458: minimalIterationCount>1 computes the second iteration sum as      * the first Simpson sum.      */     @Test     public void testIterationNComputesTheExpectedSimpsonSum() {         // Use 1/x as the function as the sum will asymptote in a monotonic         // series. The convergence can then be controlled.         UnivariateFunction f = new Inverse();          double min, max, expected, result, tolerance;         int minIteration, maxIteration;          // Range for integration         min = 1;         max = 2;          // This is the expected sum.         // Each iteration will monotonically converge to this.         expected = FastMath.log(max) - FastMath.log(min);          // Test convergence at the given iteration         minIteration = 2;         maxIteration = 4;          // Compute the sums expected for different iterations.         // Add an additional sum so that the test can compare to the next value.         double[] sums = new double[maxIteration + 2];         for (int i = 0; i < sums.length; i++) {             sums[i] = computeSimpsonIteration(f, min, max, i);             // Check monotonic             if (i > 0) {                 Assert.assertTrue("Expected series not monotonic descending",                         sums[i] < sums[i - 1]);                 // Check monotonic difference                 if (i > 1) {                     Assert.assertTrue("Expected convergence not monotonic descending",                            sums[i - 1] - sums[i] < sums[i - 2] - sums[i - 1]);                 }             }         }          // Check the test function is correct.         tolerance = FastMath.abs(expected * SimpsonIntegrator.DEFAULT_RELATIVE_ACCURACY);         Assert.assertEquals("Expected result", expected, sums[maxIteration], tolerance);          // Set-up to test convergence at a specific iteration.         // Allow enough function evaluations.         // Iteration 0 = 3 evaluations         // Iteration 1 = 5 evaluations         // Iteration n = 2^(n+1)+1 evaluations         int evaluations = 2 << (maxIteration + 1) + 1;          for (int i = minIteration; i <= maxIteration; i++) {             // Create convergence criteria.             // (sum - previous) is monotonic descending.             // So use a point half-way between them:             // ((sums[i-1] - sums[i]) + (sums[i-2] - sums[i-1])) / 2             final double absoluteAccuracy = (sums[i - 2] - sums[i]) / 2;              // Use minimalIterationCount>1             UnivariateIntegrator integrator = new SimpsonIntegrator(                     0, absoluteAccuracy,                     2, SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT);              result = integrator.integrate(evaluations, f, min, max);              // Check the iteration is as expected             Assert.assertEquals("Test failed to control iteration", i, integrator.getIterations());              // MATH-1458: minimalIterationCount>1 computes incorrect Simpson sum             // for the iteration. Check it is the correct sum.             // It should be closer to this one than the previous or next.             final double dp = FastMath.abs(sums[i-1] - result);             final double d  = FastMath.abs(sums[i]   - result);             final double dn = FastMath.abs(sums[i+1] - result);              Assert.assertTrue("Result closer to sum expected from previous iteration: " + i, d < dp);             Assert.assertTrue("Result closer to sum expected from next iteration: " + i, d < dn);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test case for midpoint integrator.  * <p>  * Test runs show that for a default relative accuracy of 1E-6, it generally  * takes 10 to 15 iterations for the integral to converge.  *  */ public final class MidPointIntegratorTest {     private static final int NUM_ITER = 30;      /**      * The initial iteration contributes 1 evaluation. Each successive iteration      * contributes 2 points to each previous slice.      *      * The total evaluation count == 1 + 2*3^0 + 2*3^1 + ... 2*3^n      *      * the series 3^0 + 3^1 + ... + 3^n sums to 3^(n-1) / (3-1), so the total      * expected evaluations == 1 + 2*(3^(n-1) - 1)/2 == 3^(n-1).      *      * The n in the series above is offset by 1 from the MidPointIntegrator      * iteration count so the actual result == 3^n.      *      * Without the incremental implementation, the same result would require      * (3^(n + 1) - 1) / 2 evaluations; just under 50% more.      */     private long expectedEvaluations(int iterations) {         return (long) FastMath.pow(3, iterations);     }      /**      * Test of integrator for the sine function.      */     @Test     public void testLowAccuracy() {         UnivariateFunction f = new QuinticFunction();         UnivariateIntegrator integrator = new MidPointIntegrator(0.01, 1.0e-10, 2, 4);          double min = -10;         double max =  -9;         double expected = -3697001.0 / 48.0;         double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         double result = integrator.integrate(Integer.MAX_VALUE, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 3);         Assert.assertTrue(integrator.getIterations() < NUM_ITER);         Assert.assertEquals(expectedEvaluations(integrator.getIterations()), integrator.getEvaluations());         Assert.assertEquals(expected, result, tolerance);      }      /**      * Test of integrator for the sine function.      */     @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         UnivariateIntegrator integrator = new MidPointIntegrator();          double min = 0;         double max = FastMath.PI;         double expected = 2;         double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         double result = integrator.integrate(Integer.MAX_VALUE, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 3);         Assert.assertTrue(integrator.getIterations() < NUM_ITER);         Assert.assertEquals(expectedEvaluations(integrator.getIterations()), integrator.getEvaluations());         Assert.assertEquals(expected, result, tolerance);          min = -FastMath.PI/3;         max = 0;         expected = -0.5;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(Integer.MAX_VALUE, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 3);         Assert.assertTrue(integrator.getIterations() < NUM_ITER);         Assert.assertEquals(expectedEvaluations(integrator.getIterations()), integrator.getEvaluations());         Assert.assertEquals(expected, result, tolerance);      }      /**      * Test of integrator for the quintic function.      */     @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateIntegrator integrator = new MidPointIntegrator();          double min = 0;         double max = 1;         double expected = -1.0 / 48;         double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         double result = integrator.integrate(Integer.MAX_VALUE, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 3);         Assert.assertTrue(integrator.getIterations() < NUM_ITER);         Assert.assertEquals(expectedEvaluations(integrator.getIterations()), integrator.getEvaluations());         Assert.assertEquals(expected, result, tolerance);          min = 0;         max = 0.5;         expected = 11.0 / 768;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(Integer.MAX_VALUE, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 3);         Assert.assertTrue(integrator.getIterations() < NUM_ITER);         Assert.assertEquals(expected, result, tolerance);          min = -1;         max = 4;         expected = 2048 / 3.0 - 78 + 1.0 / 48;         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());         result = integrator.integrate(Integer.MAX_VALUE, f, min, max);         Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 3);         Assert.assertTrue(integrator.getIterations() < NUM_ITER);         Assert.assertEquals(expectedEvaluations(integrator.getIterations()), integrator.getEvaluations());         Assert.assertEquals(expected, result, tolerance);      }      /**      * Test of parameters for the integrator.      */     @Test     public void testParameters() {         UnivariateFunction f = new Sin();          try {             // bad interval             new MidPointIntegrator().integrate(1000, f, 1, -1);             Assert.fail("Expecting NumberIsTooLargeException - bad interval");         } catch (NumberIsTooLargeException ex) {             // expected         }         try {             // bad iteration limits             new MidPointIntegrator(5, 4);             Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");         } catch (NumberIsTooSmallException ex) {             // expected         }         try {             // bad iteration limits             new MidPointIntegrator(10, 99);             Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");         } catch (NumberIsTooLargeException ex) {             // expected         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.util.FastMath; import org.junit.Test; import org.junit.Assert;  /**  * Test of the {@link HermiteRuleFactory}.  *  */ public class HermiteTest {     private static final GaussIntegratorFactory factory = new GaussIntegratorFactory();      @Test     public void testNormalDistribution() {         final double oneOverSqrtPi = 1 / FastMath.sqrt(Math.PI);          // By definition, Gauss-Hermite quadrature readily provides the         // integral of the normal distribution density.         final int numPoints = 1;          // Change of variable:         //   y = (x - mu) / (sqrt(2) *  sigma)         // such that the integrand         //   N(x, mu, sigma)         // is transformed to         //   f(y) * exp(-y^2)         final UnivariateFunction f = new UnivariateFunction() {                 @Override                 public double value(double y) {                     return oneOverSqrtPi; // Constant function.                 }             };          final GaussIntegrator integrator = factory.hermite(numPoints);         final double result = integrator.integrate(f);         final double expected = 1;         Assert.assertEquals(expected, result, Math.ulp(expected));     }      @Test     public void testNormalMean() {         final double sqrtTwo = FastMath.sqrt(2);         final double oneOverSqrtPi = 1 / FastMath.sqrt(Math.PI);          final double mu = 12345.6789;         final double sigma = 987.654321;         final int numPoints = 5;          // Change of variable:         //   y = (x - mu) / (sqrt(2) *  sigma)         // such that the integrand         //   x * N(x, mu, sigma)         // is transformed to         //   f(y) * exp(-y^2)         final UnivariateFunction f = new UnivariateFunction() {                 @Override                 public double value(double y) {                     return oneOverSqrtPi * (sqrtTwo * sigma * y + mu);                 }             };          final GaussIntegrator integrator = factory.hermite(numPoints);         final double result = integrator.integrate(f);         final double expected = mu;         Assert.assertEquals(expected, result, Math.ulp(expected));     }      @Test     public void testNormalVariance() {         final double twoOverSqrtPi = 2 / FastMath.sqrt(Math.PI);          final double sigma = 987.654321;         final double sigma2 = sigma * sigma;         final int numPoints = 5;          // Change of variable:         //   y = (x - mu) / (sqrt(2) *  sigma)         // such that the integrand         //   (x - mu)^2 * N(x, mu, sigma)         // is transformed to         //   f(y) * exp(-y^2)         final UnivariateFunction f = new UnivariateFunction() {                 @Override                 public double value(double y) {                     return twoOverSqrtPi * sigma2 * y * y;                 }             };          final GaussIntegrator integrator = factory.hermite(numPoints);         final double result = integrator.integrate(f);         final double expected = sigma2;         Assert.assertEquals(expected, result, 10 * Math.ulp(expected));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.numbers.gamma.Gamma; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;  /**  * Test of the {@link LaguerreRuleFactory}.  */ public class LaguerreTest {     private static final GaussIntegratorFactory factory = new GaussIntegratorFactory();      @Test     public void testGamma() {         final double tol = 1e-13;          for (int i = 2; i < 10; i += 1) {             final double t = i;              final UnivariateFunction f = new UnivariateFunction() {                 @Override                 public double value(double x) {                     return FastMath.pow(x, t - 1);                 }             };              final GaussIntegrator integrator = factory.laguerre(7);             final double s = integrator.integrate(f);             Assert.assertEquals(1d, Gamma.value(t) / s, tol);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Cos; import org.apache.commons.math4.analysis.function.Inverse; import org.apache.commons.math4.analysis.function.Log; import org.junit.Test; import org.junit.Assert;  /**  * Test of the {@link LegendreRuleFactory}.  *  */ public class LegendreTest {     private static final GaussIntegratorFactory factory = new GaussIntegratorFactory();      @Test     public void testCos() {         final UnivariateFunction cos = new Cos();          final GaussIntegrator integrator = factory.legendre(7, 0, Math.PI / 2);         final double s = integrator.integrate(cos);         // System.out.println("s=" + s + " e=" + 1);         Assert.assertEquals(1, s, Math.ulp(1d));     }       @Test     public void testInverse() {         final UnivariateFunction inv = new Inverse();         final UnivariateFunction log = new Log();          final double lo = 12.34;         final double hi = 456.78;          final GaussIntegrator integrator = factory.legendre(60, lo, hi);         final double s = integrator.integrate(inv);         final double expected = log.value(hi) - log.value(lo);         // System.out.println("s=" + s + " e=" + expected);         Assert.assertEquals(expected, s, 1e-14);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import java.util.ArrayList; import java.util.Collection;  import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  /**  * Test of the {@link LegendreRuleFactory}.  * This parameterized test extends the standard test for Gaussian quadrature  * rule, where each monomial is tested in turn.  * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS}  * quadrature rules.  *  */ @RunWith(value=Parameterized.class) public class LegendreParametricTest extends GaussianQuadratureAbstractTest {     private static final GaussIntegratorFactory factory = new GaussIntegratorFactory();      /**      * The highest order quadrature rule to be tested.      */     public static final int MAX_NUM_POINTS = 30;      /**      * Creates a new instance of this test, with the specified number of nodes      * for the Gauss-Legendre quadrature rule.      *      * @param numberOfPoints Order of integration rule.      * @param maxDegree Maximum degree of monomials to be tested.      * @param eps Value of &epsilon;.      * @param numUlps Value of the maximum relative error (in ulps).      */     public LegendreParametricTest(int numberOfPoints,                                   int maxDegree,                                   double eps,                                   double numUlps) {         super(factory.legendre(numberOfPoints),               maxDegree, eps, numUlps);     }      /**      * Returns the collection of parameters to be passed to the constructor of      * this class.      * Gauss-Legendre quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS}      * will be constructed.      *      * @return the collection of parameters for this parameterized test.      */     @SuppressWarnings("boxing") // OK here     @Parameters     public static Collection<Object[]> getParameters() {         final ArrayList<Object[]> parameters = new ArrayList<>();         for (int k = 1; k <= MAX_NUM_POINTS; k++) {             parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 91d });         }         return parameters;     }      @Override     public double getExpectedValue(final int n) {         if (n % 2 == 1) {             return 0;         }         return 2d / (n + 1);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Cos; import org.apache.commons.math4.analysis.function.Inverse; import org.apache.commons.math4.analysis.function.Log; import org.junit.Test; import org.junit.Assert;  /**  * Test of the {@link LegendreHighPrecisionRuleFactory}.  *  */ public class LegendreHighPrecisionTest {     private static GaussIntegratorFactory factory = new GaussIntegratorFactory();      @Test     public void testCos() {         final UnivariateFunction cos = new Cos();          final GaussIntegrator integrator = factory.legendreHighPrecision(7, 0, Math.PI / 2);         final double s = integrator.integrate(cos);         // System.out.println("s=" + s + " e=" + 1);         Assert.assertEquals(1, s, Math.ulp(1d));     }       @Test     public void testInverse() {         final UnivariateFunction inv = new Inverse();         final UnivariateFunction log = new Log();          final double lo = 12.34;         final double hi = 456.78;          final GaussIntegrator integrator = factory.legendreHighPrecision(60, lo, hi);         final double s = integrator.integrate(inv);         final double expected = log.value(hi) - log.value(lo);         // System.out.println("s=" + s + " e=" + expected);         Assert.assertEquals(expected, s, 1e-15);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Constant; import org.apache.commons.math4.util.Pair; import org.junit.Test; import org.junit.Assert;  /**  * Test for {@link GaussIntegrator} class.  *  */ public class GaussIntegratorTest {     @Test     public void testGetWeights() {         final double[] points = { 0, 1.2, 3.4 };         final double[] weights = { 9.8, 7.6, 5.4 };          final GaussIntegrator integrator             = new GaussIntegrator(new Pair<>(points, weights));          Assert.assertEquals(weights.length, integrator.getNumberOfPoints());          for (int i = 0; i < integrator.getNumberOfPoints(); i++) {             Assert.assertEquals(weights[i], integrator.getWeight(i), 0d);         }     }      @Test     public void testGetPoints() {         final double[] points = { 0, 1.2, 3.4 };         final double[] weights = { 9.8, 7.6, 5.4 };          final GaussIntegrator integrator             = new GaussIntegrator(new Pair<>(points, weights));          Assert.assertEquals(points.length, integrator.getNumberOfPoints());          for (int i = 0; i < integrator.getNumberOfPoints(); i++) {             Assert.assertEquals(points[i], integrator.getPoint(i), 0d);         }     }      @Test     public void testIntegrate() {         final double[] points = { 0, 1, 2, 3, 4, 5 };         final double[] weights = { 1, 1, 1, 1, 1, 1 };          final GaussIntegrator integrator             = new GaussIntegrator(new Pair<>(points, weights));          final double val = 123.456;         final UnivariateFunction c = new Constant(val);          final double s = integrator.integrate(c);         Assert.assertEquals(points.length * val, s, 0d);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import java.util.List; import java.util.ArrayList; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.TimeUnit; import java.util.concurrent.Callable; import java.util.concurrent.Future; import java.util.concurrent.ExecutionException; import java.util.concurrent.atomic.AtomicInteger;  import org.apache.commons.math4.util.Pair; import org.junit.Test; import org.junit.Assert;  /**  * Test for {@link BaseRuleFactory}.  *  */ public class BaseRuleFactoryTest {     /**      * Tests that a given rule rule will be computed and added once to the cache      * whatever the number of times this rule is called concurrently.      */     @Test         public void testConcurrentCreation() throws InterruptedException,                                                     ExecutionException {         // Number of times the same rule will be called.         final int numTasks = 20;          final ThreadPoolExecutor exec             = new ThreadPoolExecutor(3, numTasks, 1, TimeUnit.SECONDS,                                      new ArrayBlockingQueue<Runnable>(2));          final List<Future<Pair<double[], double[]>>> results             = new ArrayList<>();         for (int i = 0; i < numTasks; i++) {             results.add(exec.submit(new RuleBuilder()));         }          // Ensure that all computations have completed.         for (Future<Pair<double[], double[]>> f : results) {             f.get();         }          // Assertion would fail if "getRuleInternal" were not "synchronized".         final int n = RuleBuilder.getNumberOfCalls();         Assert.assertEquals("Rule computation was called " + n + " times", 1, n);     } }  class RuleBuilder implements Callable<Pair<double[], double[]>> {     private static final DummyRuleFactory factory = new DummyRuleFactory();      @Override     public Pair<double[], double[]> call() {         final int dummy = 2; // Always request the same rule.         return factory.getRule(dummy);     }      public static int getNumberOfCalls() {         return factory.getNumberOfCalls();     } }  class DummyRuleFactory extends BaseRuleFactory<Double> {     /** Rule computations counter. */     private static AtomicInteger nCalls = new AtomicInteger();      @Override     protected Pair<Double[], Double[]> computeRule(int order) {         // Tracks whether this computation has been called more than once.         nCalls.getAndIncrement();          try {             // Sleep to simulate computation time.             Thread.sleep(20);         } catch (InterruptedException e) {             Assert.fail("Unexpected interruption");         }           // Dummy rule (but contents must exist).         final Double[] p = new Double[order];         final Double[] w = new Double[order];         for (int i = 0; i < order; i++) {             p[i] = new Double(i);             w[i] = new Double(i);         }         return new Pair<>(p, w);     }      public int getNumberOfCalls() {         return nCalls.get();     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import java.util.ArrayList; import java.util.Collection;  import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  /**  * Test of the {@link LegendreHighPrecisionRuleFactory}.  * This parameterized test extends the standard test for Gaussian quadrature  * rule, where each monomial is tested in turn.  * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS}  * quadrature rules.  *  */ @RunWith(value=Parameterized.class) public class LegendreHighPrecisionParametricTest extends GaussianQuadratureAbstractTest {     private static GaussIntegratorFactory factory = new GaussIntegratorFactory();      /**      * The highest order quadrature rule to be tested.      */     public static final int MAX_NUM_POINTS = 30;      /**      * Creates a new instance of this test, with the specified number of nodes      * for the Gauss-Legendre quadrature rule.      *      * @param numberOfPoints Order of integration rule.      * @param maxDegree Maximum degree of monomials to be tested.      * @param eps Value of &epsilon;.      * @param numUlps Value of the maximum relative error (in ulps).      */     public LegendreHighPrecisionParametricTest(int numberOfPoints,                                                int maxDegree,                                                double eps,                                                double numUlps) {         super(factory.legendreHighPrecision(numberOfPoints),               maxDegree, eps, numUlps);     }      /**      * Returns the collection of parameters to be passed to the constructor of      * this class.      * Gauss-Legendre quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS}      * will be constructed.      *      * @return the collection of parameters for this parameterized test.      */     @SuppressWarnings("boxing") // OK here     @Parameters     public static Collection<Object[]> getParameters() {         final ArrayList<Object[]> parameters = new ArrayList<>();         for (int k = 1; k <= MAX_NUM_POINTS; k++) {             parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 13d });         }         return parameters;     }      @Override     public double getExpectedValue(final int n) {         if (n % 2 == 1) {             return 0;         }         return 2d / (n + 1);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import org.apache.commons.math4.analysis.function.Power; import org.apache.commons.math4.util.FastMath; import org.junit.Test; import org.junit.Assert;  /**  * Base class for standard testing of Gaussian quadrature rules,  * which are exact for polynomials up to a certain degree. In this test, each  * monomial in turn is tested against the specified quadrature rule.  *  */ public abstract class GaussianQuadratureAbstractTest {     /**      * The maximum absolute error (for zero testing).      */     private final double eps;     /**      * The maximum relative error (in ulps).      */     private final double numUlps;     /**      * The quadrature rule under test.      */     private final GaussIntegrator integrator;     /**      * Maximum degree of monomials to be tested.      */     private final int maxDegree;      /**      * Creates a new instance of this abstract test with the specified      * quadrature rule.      * If the expected value is non-zero, equality of actual and expected values      * is checked in the relative sense <center>      * |x<sub>act</sub>&nbsp;-&nbsp;x<sub>exp</sub>|&nbsp;&le;&nbsp; n&nbsp;      * <code>Math.ulp(</code>x<sub>exp</sub><code>)</code>, </center> where n is      * the maximum relative error (in ulps). If the expected value is zero, the      * test checks that <center> |x<sub>act</sub>|&nbsp;&le;&nbsp;&epsilon;,      * </center> where &epsilon; is the maximum absolute error.      *      * @param integrator Quadrature rule under test.      * @param maxDegree Maximum degree of monomials to be tested.      * @param eps &epsilon;.      * @param numUlps Value of the maximum relative error (in ulps).      */     public GaussianQuadratureAbstractTest(GaussIntegrator integrator,                                           int maxDegree,                                           double eps,                                           double numUlps) {         this.integrator = integrator;         this.maxDegree = maxDegree;         this.eps = eps;         this.numUlps = numUlps;     }      /**      * Returns the expected value of the integral of the specified monomial.      * The integration is carried out on the natural interval of the quadrature      * rule under test.      *      * @param n Degree of the monomial.      * @return the expected value of the integral of x<sup>n</sup>.      */     public abstract double getExpectedValue(final int n);      /**      * Checks that the value of the integral of each monomial      *   <code>x<sup>0</sup>, ... , x<sup>p</sup></code>      * returned by the quadrature rule under test conforms with the expected      * value.      * Here {@code p} denotes the degree of the highest polynomial for which      * exactness is to be expected.      */     @Test     public void testAllMonomials() {         for (int n = 0; n <= maxDegree; n++) {             final double expected = getExpectedValue(n);              final Power monomial = new Power(n);             final double actual = integrator.integrate(monomial);              // System.out.println(n + "/" + maxDegree + " " + integrator.getNumberOfPoints()             //                    + " " + expected + " " + actual + " " + Math.ulp(expected));             if (expected == 0) {                 Assert.assertEquals("while integrating monomial x**" + n +                                     " with a " +                                     integrator.getNumberOfPoints() + "-point quadrature rule",                                     expected, actual, eps);             } else {                 double err = FastMath.abs(actual - expected) / Math.ulp(expected);                 Assert.assertEquals("while integrating monomial x**" + n + " with a " +                                     + integrator.getNumberOfPoints() + "-point quadrature rule, " +                                     " error was " + err + " ulps",                                     expected, actual, Math.ulp(expected) * numUlps);             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration.gauss;  import java.util.ArrayList; import java.util.Collection;  import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; import org.apache.commons.math4.util.FastMath;  /**  * Test of the {@link HermiteRuleFactory}.  * This parameterized test extends the standard test for Gaussian quadrature  * rule, where each monomial is tested in turn.  * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS}  * quadrature rules.  *  */ @RunWith(value=Parameterized.class) public class HermiteParametricTest extends GaussianQuadratureAbstractTest {     private static final double SQRT_PI = FastMath.sqrt(Math.PI);     private static final GaussIntegratorFactory factory = new GaussIntegratorFactory();      /**      * The highest order quadrature rule to be tested.      */     public static final int MAX_NUM_POINTS = 30;      /**      * Creates a new instance of this test, with the specified number of nodes      * for the Gauss-Hermite quadrature rule.      *      * @param numberOfPoints Order of integration rule.      * @param maxDegree Maximum degree of monomials to be tested.      * @param eps Value of &epsilon;.      * @param numUlps Value of the maximum relative error (in ulps).      */     public HermiteParametricTest(int numberOfPoints,                                  int maxDegree,                                  double eps,                                  double numUlps) {         super(factory.hermite(numberOfPoints),               maxDegree, eps, numUlps);     }      /**      * Returns the collection of parameters to be passed to the constructor of      * this class.      * Gauss-Hermite quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS}      * will be constructed.      *      * @return the collection of parameters for this parameterized test.      */     @SuppressWarnings("boxing") // OK here     @Parameters     public static Collection<Object[]> getParameters() {         final ArrayList<Object[]> parameters = new ArrayList<>();         for (int k = 1; k <= MAX_NUM_POINTS; k++) {             parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 195 });         }         return parameters;     }      @Override     public double getExpectedValue(final int n) {         if (n % 2 == 1) {             return 0;         }          final int iMax = n / 2;         double p = 1;         double q = 1;         for (int i = 0; i < iMax; i++) {             p *= 2 * i + 1;             q *= 2;         }          return p / q * SQRT_PI;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis.integration;  import java.util.Random;  import org.apache.commons.math4.analysis.QuinticFunction; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.function.Gaussian; import org.apache.commons.math4.analysis.function.Sin; import org.apache.commons.math4.analysis.polynomials.PolynomialFunction; import org.apache.commons.math4.exception.TooManyEvaluationsException; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Test;   public class IterativeLegendreGaussIntegratorTest {      @Test     public void testSinFunction() {         UnivariateFunction f = new Sin();         BaseAbstractUnivariateIntegrator integrator             = new IterativeLegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15);         double min, max, expected, result, tolerance;          min = 0; max = FastMath.PI; expected = 2;         tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),                              FastMath.abs(expected * integrator.getRelativeAccuracy()));         result = integrator.integrate(10000, f, min, max);         Assert.assertEquals(expected, result, tolerance);          min = -FastMath.PI/3; max = 0; expected = -0.5;         tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),                 FastMath.abs(expected * integrator.getRelativeAccuracy()));         result = integrator.integrate(10000, f, min, max);         Assert.assertEquals(expected, result, tolerance);     }      @Test     public void testQuinticFunction() {         UnivariateFunction f = new QuinticFunction();         UnivariateIntegrator integrator =                 new IterativeLegendreGaussIntegrator(3,                                                      BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY,                                                      BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY,                                                      BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT,                                                      64);         double min, max, expected, result;          min = 0; max = 1; expected = -1.0/48;         result = integrator.integrate(10000, f, min, max);         Assert.assertEquals(expected, result, 1.0e-16);          min = 0; max = 0.5; expected = 11.0/768;         result = integrator.integrate(10000, f, min, max);         Assert.assertEquals(expected, result, 1.0e-16);          min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;         result = integrator.integrate(10000, f, min, max);         Assert.assertEquals(expected, result, 1.0e-16);     }      @Test     public void testExactIntegration() {         Random random = new Random(86343623467878363l);         for (int n = 2; n < 6; ++n) {             IterativeLegendreGaussIntegrator integrator =                 new IterativeLegendreGaussIntegrator(n,                                                      BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY,                                                      BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY,                                                      BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT,                                                      64);              // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly             for (int degree = 0; degree <= 2 * n - 1; ++degree) {                 for (int i = 0; i < 10; ++i) {                     double[] coeff = new double[degree + 1];                     for (int k = 0; k < coeff.length; ++k) {                         coeff[k] = 2 * random.nextDouble() - 1;                     }                     PolynomialFunction p = new PolynomialFunction(coeff);                     double result    = integrator.integrate(10000, p, -5.0, 15.0);                     double reference = exactIntegration(p, -5.0, 15.0);                     Assert.assertEquals(n + " " + degree + " " + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));                 }             }          }     }      // Cf. MATH-995     @Test     public void testNormalDistributionWithLargeSigma() {         final double sigma = 1000;         final double mean = 0;         final double factor = 1 / (sigma * FastMath.sqrt(2 * FastMath.PI));         final UnivariateFunction normal = new Gaussian(factor, mean, sigma);          final double tol = 1e-2;         final IterativeLegendreGaussIntegrator integrator =             new IterativeLegendreGaussIntegrator(5, tol, tol);          final double a = -5000;         final double b = 5000;         final double s = integrator.integrate(60, normal, a, b);         Assert.assertEquals(1, s, 1e-5);     }      @Test     public void testIssue464() {         final double value = 0.2;         UnivariateFunction f = new UnivariateFunction() {             @Override             public double value(double x) {                 return (x >= 0 && x <= 5) ? value : 0.0;             }         };         IterativeLegendreGaussIntegrator gauss             = new IterativeLegendreGaussIntegrator(5, 3, 100);          // due to the discontinuity, integration implies *many* calls         double maxX = 0.32462367623786328;         Assert.assertEquals(maxX * value, gauss.integrate(Integer.MAX_VALUE, f, -10, maxX), 1.0e-7);         Assert.assertTrue(gauss.getEvaluations() > 37000000);         Assert.assertTrue(gauss.getIterations() < 30);          // setting up limits prevents such large number of calls         try {             gauss.integrate(1000, f, -10, maxX);             Assert.fail("expected TooManyEvaluationsException");         } catch (TooManyEvaluationsException tmee) {             // expected             Assert.assertEquals(1000, tmee.getMax());         }          // integrating on the two sides should be simpler         double sum1 = gauss.integrate(1000, f, -10, 0);         int eval1   = gauss.getEvaluations();         double sum2 = gauss.integrate(1000, f, 0, maxX);         int eval2   = gauss.getEvaluations();         Assert.assertEquals(maxX * value, sum1 + sum2, 1.0e-7);         Assert.assertTrue(eval1 + eval2 < 200);      }      private double exactIntegration(PolynomialFunction p, double a, double b) {         final double[] coeffs = p.getCoefficients();         double yb = coeffs[coeffs.length - 1] / coeffs.length;         double ya = yb;         for (int i = coeffs.length - 2; i >= 0; --i) {             yb = yb * b + coeffs[i] / (i + 1);             ya = ya * a + coeffs[i] / (i + 1);         }         return yb * b - ya * a;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis;  import org.apache.commons.math4.analysis.differentiation.DerivativeStructure; import org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction;  /**  * Auxiliary class for testing solvers.  *  */ public class QuinticFunction implements UnivariateDifferentiableFunction {      /* Evaluate quintic.      * @see org.apache.commons.math4.UnivariateFunction#value(double)      */     @Override     public double value(double x) {         return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);     }      @Override     public DerivativeStructure value(DerivativeStructure t) {         return t.subtract(1).multiply(t.subtract(0.5)).multiply(t).multiply(t.add(0.5)).multiply(t.add(1));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.analysis;   /**  * Wrapper class for counting functions calls.  *  */ public class MonitoredFunction implements UnivariateFunction {      public MonitoredFunction(UnivariateFunction f) {         callsCount = 0;         this.f = f;     }      public void setCallsCount(int callsCount) {         this.callsCount = callsCount;     }      public int getCallsCount() {         return callsCount;     }      @Override     public double value(double x) {         ++callsCount;         return f.value(x);     }      private int callsCount;     private final UnivariateFunction f;  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4;  import java.lang.annotation.*;  /**  * Annotation that enables test retries.  */ @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface Retry {     int value() default 2; } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.math4.distribution;  import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.correlation.Covariance;  import java.util.Random;  import org.junit.Assert; import org.junit.Test;  /**  * Test cases for {@link MultivariateNormalDistribution}.  */ public class MultivariateNormalDistributionTest {     /**      * Test the ability of the distribution to report its mean value parameter.      */     @Test     public void testGetMean() {         final double[] mu = { -1.5, 2 };         final double[][] sigma = { { 2, -1.1 },                                    { -1.1, 2 } };         final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma);          final double[] m = d.getMeans();         for (int i = 0; i < m.length; i++) {             Assert.assertEquals(mu[i], m[i], 0);         }     }      /**      * Test the ability of the distribution to report its covariance matrix parameter.      */     @Test     public void testGetCovarianceMatrix() {         final double[] mu = { -1.5, 2 };         final double[][] sigma = { { 2, -1.1 },                                    { -1.1, 2 } };         final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma);          final RealMatrix s = d.getCovariances();         final int dim = d.getDimension();         for (int i = 0; i < dim; i++) {             for (int j = 0; j < dim; j++) {                 Assert.assertEquals(sigma[i][j], s.getEntry(i, j), 0);             }         }     }      /**      * Test the accuracy of sampling from the distribution.      */     @Test     public void testSampling() {         final double[] mu = { -1.5, 2 };         final double[][] sigma = { { 2, -1.1 },                                    { -1.1, 2 } };         final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma);         final MultivariateRealDistribution.Sampler sampler =             d.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 50));          final int n = 500000;         final double[][] samples = AbstractMultivariateRealDistribution.sample(n, sampler);          final int dim = d.getDimension();         final double[] sampleMeans = new double[dim];          for (int i = 0; i < samples.length; i++) {             for (int j = 0; j < dim; j++) {                 sampleMeans[j] += samples[i][j];             }         }          final double sampledValueTolerance = 1e-2;         for (int j = 0; j < dim; j++) {             sampleMeans[j] /= samples.length;             Assert.assertEquals(mu[j], sampleMeans[j], sampledValueTolerance);         }          final double[][] sampleSigma = new Covariance(samples).getCovarianceMatrix().getData();         for (int i = 0; i < dim; i++) {             for (int j = 0; j < dim; j++) {                 Assert.assertEquals(sigma[i][j], sampleSigma[i][j], sampledValueTolerance);             }         }     }      /**      * Test the accuracy of the distribution when calculating densities.      */     @Test     public void testDensities() {         final double[] mu = { -1.5, 2 };         final double[][] sigma = { { 2, -1.1 },                                    { -1.1, 2 } };         final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma);          final double[][] testValues = { { -1.5, 2 },                                         { 4, 4 },                                         { 1.5, -2 },                                         { 0, 0 } };         final double[] densities = new double[testValues.length];         for (int i = 0; i < densities.length; i++) {             densities[i] = d.density(testValues[i]);         }          // From dmvnorm function in R 2.15 CRAN package Mixtools v0.4.5         final double[] correctDensities = { 0.09528357207691344,                                             5.80932710124009e-09,                                             0.001387448895173267,                                             0.03309922090210541 };          for (int i = 0; i < testValues.length; i++) {             Assert.assertEquals(correctDensities[i], densities[i], 1e-16);         }     }      /**      * Test the accuracy of the distribution when calculating densities.      */     @Test     public void testUnivariateDistribution() {         final double[] mu = { -1.5 };         final double[][] sigma = { { 1 } };          final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma);          final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]);         final Random rng = new Random();         final int numCases = 100;         final double tol = Math.ulp(1d);         for (int i = 0; i < numCases; i++) {             final double v = rng.nextDouble() * 10 - 5;             Assert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;  import java.util.Arrays; import org.apache.commons.statistics.distribution.DiscreteDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.math4.exception.NotANumberException; import org.apache.commons.math4.exception.NotFiniteNumberException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  /**  * Test class for {@link EnumeratedIntegerDistribution}.  *  */ public class EnumeratedIntegerDistributionTest {      /**      * The distribution object used for testing.      */     private final EnumeratedIntegerDistribution testDistribution;      /**      * Creates the default distribution object used for testing.      */     public EnumeratedIntegerDistributionTest() {         // Non-sorted singleton array with duplicates should be allowed.         // Values with zero-probability do not extend the support.         testDistribution = new EnumeratedIntegerDistribution(                 new int[]{3, -1, 3, 7, -2, 8},                 new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});     }      /**      * Tests if the EnumeratedIntegerDistribution constructor throws      * exceptions for invalid data.      */     @Test     public void testExceptions() {         EnumeratedIntegerDistribution invalid = null;         try {             new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0});             Assert.fail("Expected DimensionMismatchException");         } catch (DimensionMismatchException e) {         }         try {             new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, -1.0});             Assert.fail("Expected NotPositiveException");         } catch (NotPositiveException e) {         }         try {             new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, 0.0});             Assert.fail("Expected MathArithmeticException");         } catch (MathArithmeticException e) {         }         try {           new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.NaN});             Assert.fail("Expected NotANumberException");         } catch (NotANumberException e) {         }         try {         new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.POSITIVE_INFINITY});             Assert.fail("Expected NotFiniteNumberException");         } catch (NotFiniteNumberException e) {         }         Assert.assertNull("Expected non-initialized DiscreteRealDistribution", invalid);     }      /**      * Tests if the distribution returns proper probability values.      */     @Test     public void testProbability() {         int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8};         double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};         for (int p = 0; p < points.length; p++) {             double probability = testDistribution.probability(points[p]);             Assert.assertEquals(results[p], probability, 0.0);         }     }      /**      * Tests if the distribution returns proper cumulative probability values.      */     @Test     public void testCumulativeProbability() {         int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8};         double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0};         for (int p = 0; p < points.length; p++) {             double probability = testDistribution.cumulativeProbability(points[p]);             Assert.assertEquals(results[p], probability, 1e-10);         }     }      /**      * Tests if the distribution returns proper mean value.      */     @Test     public void testGetNumericalMean() {         Assert.assertEquals(3.4, testDistribution.getMean(), 1e-10);     }      /**      * Tests if the distribution returns proper variance.      */     @Test     public void testGetNumericalVariance() {         Assert.assertEquals(7.84, testDistribution.getVariance(), 1e-10);     }      /**      * Tests if the distribution returns proper lower bound.      */     @Test     public void testGetSupportLowerBound() {         Assert.assertEquals(-1, testDistribution.getSupportLowerBound());     }      /**      * Tests if the distribution returns proper upper bound.      */     @Test     public void testGetSupportUpperBound() {         Assert.assertEquals(7, testDistribution.getSupportUpperBound());     }      /**      * Tests if the distribution returns properly that the support is connected.      */     @Test     public void testIsSupportConnected() {         Assert.assertTrue(testDistribution.isSupportConnected());     }      /**      * Tests sampling.      */     @Test     public void testSample() {         final int n = 1000000;         final DiscreteDistribution.Sampler sampler             = testDistribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C,                                                                  -334759360)); // fixed seed         final int[] samples = AbstractIntegerDistribution.sample(n, sampler);         Assert.assertEquals(n, samples.length);         double sum = 0;         double sumOfSquares = 0;         for (int i = 0; i < samples.length; i++) {             sum += samples[i];             sumOfSquares += samples[i] * samples[i];         }         Assert.assertEquals(testDistribution.getMean(),                 sum / n, 1e-2);         Assert.assertEquals(testDistribution.getVariance(),                 sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2);     }      @Test     public void testCreateFromIntegers() {         final int[] data = new int[] {0, 1, 1, 2, 2, 2};         EnumeratedIntegerDistribution distribution = new EnumeratedIntegerDistribution(data);         Assert.assertEquals(0.5, distribution.probability(2), 0);         Assert.assertEquals(0.5, distribution.cumulativeProbability(1), 0);     }      @Test     public void testMath1533() {         final EnumeratedIntegerDistribution d1 = new EnumeratedIntegerDistribution(new int[] {1, 2},                                                                                    new double[] {0.3, 0.7});         final EnumeratedIntegerDistribution d2 = new EnumeratedIntegerDistribution(new int[] {2, 1},                                                                                    new double[] {0.7, 0.3});          final int len = 24;         final RandomSource r = RandomSource.WELL_19937_C;         final int s = 42;         Assert.assertTrue(Arrays.equals(AbstractIntegerDistribution.sample(len, d1.createSampler(RandomSource.create(r, s))),                                         AbstractIntegerDistribution.sample(len, d2.createSampler(RandomSource.create(r, s)))));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;  import org.apache.commons.statistics.distribution.DiscreteDistribution; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Abstract base class for {@link DiscreteDistribution} tests.  * <p>  * To create a concrete test class for an integer distribution implementation,  *  implement makeDistribution() to return a distribution instance to use in  *  tests and each of the test data generation methods below.  In each case, the  *  test points and test values arrays returned represent parallel arrays of  *  inputs and expected values for the distribution returned by makeDistribution().  *  <p>  *  makeDensityTestPoints() -- arguments used to test probability density calculation  *  makeDensityTestValues() -- expected probability densities  *  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities  *  makeCumulativeTestValues() -- expected cumulative probabilities  *  makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation  *  makeInverseCumulativeTestValues() -- expected inverse cdf values  * <p>  *  To implement additional test cases with different distribution instances and test data,  *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods  *  to verify results.  *  */ public abstract class IntegerDistributionAbstractTest {  //-------------------- Private test instance data -------------------------     /** Discrete distribution instance used to perform tests */     private DiscreteDistribution distribution;      /** Tolerance used in comparing expected and returned values */     private double tolerance = 1E-12;      /** Arguments used to test probability density calculations */     private int[] densityTestPoints;      /** Values used to test probability density calculations */     private double[] densityTestValues;      /** Values used to test logarithmic probability density calculations */     private double[] logDensityTestValues;      /** Arguments used to test cumulative probability density calculations */     private int[] cumulativeTestPoints;      /** Values used to test cumulative probability density calculations */     private double[] cumulativeTestValues;      /** Arguments used to test inverse cumulative probability density calculations */     private double[] inverseCumulativeTestPoints;      /** Values used to test inverse cumulative probability density calculations */     private int[] inverseCumulativeTestValues;      //-------------------- Abstract methods -----------------------------------      /** Creates the default discrete distribution instance to use in tests. */     public abstract DiscreteDistribution makeDistribution();      /** Creates the default probability density test input values */     public abstract int[] makeDensityTestPoints();      /** Creates the default probability density test expected values */     public abstract double[] makeDensityTestValues();      /** Creates the default logarithmic probability density test expected values.      *      * The default implementation simply computes the logarithm of all the values in      * {@link #makeDensityTestValues()}.      *      * @return double[] the default logarithmic probability density test expected values.      */     public double[] makeLogDensityTestValues() {         final double[] densityTestValues = makeDensityTestValues();         final double[] logDensityTestValues = new double[densityTestValues.length];         for (int i = 0; i < densityTestValues.length; i++) {             logDensityTestValues[i] = FastMath.log(densityTestValues[i]);         }         return logDensityTestValues;     }      /** Creates the default cumulative probability density test input values */     public abstract int[] makeCumulativeTestPoints();      /** Creates the default cumulative probability density test expected values */     public abstract double[] makeCumulativeTestValues();      /** Creates the default inverse cumulative probability test input values */     public abstract double[] makeInverseCumulativeTestPoints();      /** Creates the default inverse cumulative probability density test expected values */     public abstract int[] makeInverseCumulativeTestValues();      //-------------------- Setup / tear down ----------------------------------      /**      * Setup sets all test instance data to default values      */     @Before     public void setUp() {         distribution = makeDistribution();         densityTestPoints = makeDensityTestPoints();         densityTestValues = makeDensityTestValues();         logDensityTestValues = makeLogDensityTestValues();         cumulativeTestPoints = makeCumulativeTestPoints();         cumulativeTestValues = makeCumulativeTestValues();         inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();         inverseCumulativeTestValues = makeInverseCumulativeTestValues();     }      /**      * Cleans up test instance data      */     @After     public void tearDown() {         distribution = null;         densityTestPoints = null;         densityTestValues = null;         logDensityTestValues = null;         cumulativeTestPoints = null;         cumulativeTestValues = null;         inverseCumulativeTestPoints = null;         inverseCumulativeTestValues = null;     }      //-------------------- Verification methods -------------------------------      /**      * Verifies that probability density calculations match expected values      * using current test instance data      */     protected void verifyDensities() {         for (int i = 0; i < densityTestPoints.length; i++) {             Assert.assertEquals("Incorrect density value returned for " + densityTestPoints[i],                     densityTestValues[i],                     distribution.probability(densityTestPoints[i]), getTolerance());         }     }      /**      * Verifies that logarithmic probability density calculations match expected values      * using current test instance data.      */     protected void verifyLogDensities() {         for (int i = 0; i < densityTestPoints.length; i++) {             Assert.assertEquals("Incorrect log density value returned for " + densityTestPoints[i],                     logDensityTestValues[i],                     distribution.logProbability(densityTestPoints[i]), tolerance);         }     }      /**      * Verifies that cumulative probability density calculations match expected values      * using current test instance data      */     protected void verifyCumulativeProbabilities() {         for (int i = 0; i < cumulativeTestPoints.length; i++) {             Assert.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],                     cumulativeTestValues[i],                     distribution.cumulativeProbability(cumulativeTestPoints[i]), getTolerance());         }     }       /**      * Verifies that inverse cumulative probability density calculations match expected values      * using current test instance data      */     protected void verifyInverseCumulativeProbabilities() {         for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {             Assert.assertEquals("Incorrect inverse cumulative probability value returned for "                     + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                     distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));         }     }      //------------------------ Default test cases -----------------------------      /**      * Verifies that probability density calculations match expected values      * using default test instance data      */     @Test     public void testDensities() {         verifyDensities();     }      /**      * Verifies that logarithmic probability density calculations match expected values      * using default test instance data      */     @Test     public void testLogDensities() {         verifyLogDensities();     }      /**      * Verifies that cumulative probability density calculations match expected values      * using default test instance data      */     @Test     public void testCumulativeProbabilities() {         verifyCumulativeProbabilities();     }      /**      * Verifies that inverse cumulative probability density calculations match expected values      * using default test instance data      */     @Test     public void testInverseCumulativeProbabilities() {         verifyInverseCumulativeProbabilities();     }      @Test     public void testConsistencyAtSupportBounds() {         final int lower = distribution.getSupportLowerBound();         Assert.assertEquals("Cumulative probability must be 0 below support lower bound.",                 0.0, distribution.cumulativeProbability(lower - 1), 0.0);         Assert.assertEquals("Cumulative probability of support lower bound must be equal to probability mass at this point.",                 distribution.probability(lower), distribution.cumulativeProbability(lower), getTolerance());         Assert.assertEquals("Inverse cumulative probability of 0 must be equal to support lower bound.",                 lower, distribution.inverseCumulativeProbability(0.0));          final int upper = distribution.getSupportUpperBound();         if (upper != Integer.MAX_VALUE) {             Assert.assertEquals("Cumulative probability of support upper bound must be equal to 1.",                     1.0, distribution.cumulativeProbability(upper), 0.0);         }         Assert.assertEquals("Inverse cumulative probability of 1 must be equal to support upper bound.",                 upper, distribution.inverseCumulativeProbability(1.0));     }      /**      * Verifies that illegal arguments are correctly handled      */     @Test     public void testIllegalArguments() {         try {             distribution.probability(1, 0);             Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             distribution.inverseCumulativeProbability(-1);             Assert.fail("Expecting MathIllegalArgumentException for p = -1");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             distribution.inverseCumulativeProbability(2);             Assert.fail("Expecting MathIllegalArgumentException for p = 2");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      /**      * Test sampling      */     @Test     public void testSampling() {         int[] densityPoints = makeDensityTestPoints();         double[] densityValues = makeDensityTestValues();         int sampleSize = 1000;         int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);         AbstractIntegerDistribution distribution = (AbstractIntegerDistribution) makeDistribution();         double[] expectedCounts = new double[length];         long[] observedCounts = new long[length];         for (int i = 0; i < length; i++) {             expectedCounts[i] = sampleSize * densityValues[i];         }         // Use fixed seed.         final DiscreteDistribution.Sampler sampler =             distribution.createSampler(RandomSource.create(RandomSource.WELL_512_A,                                                            1000));         int[] sample = AbstractIntegerDistribution.sample(sampleSize, sampler);         for (int i = 0; i < sampleSize; i++) {           for (int j = 0; j < length; j++) {               if (sample[i] == densityPoints[j]) {                   observedCounts[j]++;               }           }         }         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);     }      //------------------ Getters / Setters for test instance data -----------     /**      * @return Returns the cumulativeTestPoints.      */     protected int[] getCumulativeTestPoints() {         return cumulativeTestPoints;     }      /**      * @param cumulativeTestPoints The cumulativeTestPoints to set.      */     protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {         this.cumulativeTestPoints = cumulativeTestPoints;     }      /**      * @return Returns the cumulativeTestValues.      */     protected double[] getCumulativeTestValues() {         return cumulativeTestValues;     }      /**      * @param cumulativeTestValues The cumulativeTestValues to set.      */     protected void setCumulativeTestValues(double[] cumulativeTestValues) {         this.cumulativeTestValues = cumulativeTestValues;     }      /**      * @return Returns the densityTestPoints.      */     protected int[] getDensityTestPoints() {         return densityTestPoints;     }      /**      * @param densityTestPoints The densityTestPoints to set.      */     protected void setDensityTestPoints(int[] densityTestPoints) {         this.densityTestPoints = densityTestPoints;     }      /**      * @return Returns the densityTestValues.      */     protected double[] getDensityTestValues() {         return densityTestValues;     }      /**      * @param densityTestValues The densityTestValues to set.      */     protected void setDensityTestValues(double[] densityTestValues) {         this.densityTestValues = densityTestValues;     }      /**      * @return Returns the distribution.      */     protected DiscreteDistribution getDistribution() {         return distribution;     }      /**      * @param distribution The distribution to set.      */     protected void setDistribution(DiscreteDistribution distribution) {         this.distribution = distribution;     }      /**      * @return Returns the inverseCumulativeTestPoints.      */     protected double[] getInverseCumulativeTestPoints() {         return inverseCumulativeTestPoints;     }      /**      * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.      */     protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {         this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;     }      /**      * @return Returns the inverseCumulativeTestValues.      */     protected int[] getInverseCumulativeTestValues() {         return inverseCumulativeTestValues;     }      /**      * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.      */     protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {         this.inverseCumulativeTestValues = inverseCumulativeTestValues;     }      /**      * @return Returns the tolerance.      */     protected double getTolerance() {         return tolerance;     }      /**      * @param tolerance The tolerance to set.      */     protected void setTolerance(double tolerance) {         this.tolerance = tolerance;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;   import java.util.ArrayList; import java.util.Collections; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator; import org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator; import org.apache.commons.math4.exception.MathIllegalArgumentException; import org.apache.commons.math4.exception.NumberIsTooLargeException; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.FastMath; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Abstract base class for {@link ContinuousDistribution} tests.  * <p>  * To create a concrete test class for a continuous distribution  * implementation, first implement makeDistribution() to return a distribution  * instance to use in tests. Then implement each of the test data generation  * methods below.  In each case, the test points and test values arrays  * returned represent parallel arrays of inputs and expected values for the  * distribution returned by makeDistribution().  Default implementations  * are provided for the makeInverseXxx methods that just invert the mapping  * defined by the arrays returned by the makeCumulativeXxx methods.  * <p>  * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities  * makeCumulativeTestValues() -- expected cumulative probabilities  * makeDensityTestValues() -- expected density values at cumulativeTestPoints  * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf  * makeInverseCumulativeTestValues() -- expected inverse cdf values  * <p>  * To implement additional test cases with different distribution instances and  * test data, use the setXxx methods for the instance data in test cases and  * call the verifyXxx methods to verify results.  * <p>  * Error tolerance can be overridden by implementing getTolerance().  * <p>  * Test data should be validated against reference tables or other packages  * where possible, and the source of the reference data and/or validation  * should be documented in the test cases.  A framework for validating  * distribution data against R is included in the /src/test/R source tree.  *  */ public abstract class RealDistributionAbstractTest {  //-------------------- Private test instance data -------------------------     /**  Distribution instance used to perform tests */     private ContinuousDistribution distribution;      /** Tolerance used in comparing expected and returned values */     private double tolerance = 1E-4;      /** Arguments used to test cumulative probability density calculations */     private double[] cumulativeTestPoints;      /** Values used to test cumulative probability density calculations */     private double[] cumulativeTestValues;      /** Arguments used to test inverse cumulative probability density calculations */     private double[] inverseCumulativeTestPoints;      /** Values used to test inverse cumulative probability density calculations */     private double[] inverseCumulativeTestValues;      /** Values used to test density calculations */     private double[] densityTestValues;      /** Values used to test logarithmic density calculations */     private double[] logDensityTestValues;      //-------------------- Abstract methods -----------------------------------      /** Creates the default continuous distribution instance to use in tests. */     public abstract ContinuousDistribution makeDistribution();      /** Creates the default cumulative probability test input values */     public abstract double[] makeCumulativeTestPoints();      /** Creates the default cumulative probability test expected values */     public abstract double[] makeCumulativeTestValues();      /** Creates the default density test expected values */     public abstract double[] makeDensityTestValues();      /** Creates the default logarithmic density test expected values.      * The default implementation simply computes the logarithm      * of each value returned by {@link #makeDensityTestValues()}.*/     public double[] makeLogDensityTestValues() {         final double[] densityTestValues = makeDensityTestValues();         final double[] logDensityTestValues = new double[densityTestValues.length];         for (int i = 0; i < densityTestValues.length; i++) {             logDensityTestValues[i] = FastMath.log(densityTestValues[i]);         }         return logDensityTestValues;     }      //---- Default implementations of inverse test data generation methods ----      /** Creates the default inverse cumulative probability test input values */     public double[] makeInverseCumulativeTestPoints() {         return makeCumulativeTestValues();     }      /** Creates the default inverse cumulative probability density test expected values */     public double[] makeInverseCumulativeTestValues() {         return makeCumulativeTestPoints();     }      //-------------------- Setup / tear down ----------------------------------      /**      * Setup sets all test instance data to default values      */     @Before     public void setUp() {         distribution = makeDistribution();         cumulativeTestPoints = makeCumulativeTestPoints();         cumulativeTestValues = makeCumulativeTestValues();         inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();         inverseCumulativeTestValues = makeInverseCumulativeTestValues();         densityTestValues = makeDensityTestValues();         logDensityTestValues = makeLogDensityTestValues();     }      /**      * Cleans up test instance data      */     @After     public void tearDown() {         distribution = null;         cumulativeTestPoints = null;         cumulativeTestValues = null;         inverseCumulativeTestPoints = null;         inverseCumulativeTestValues = null;         densityTestValues = null;         logDensityTestValues = null;     }      //-------------------- Verification methods -------------------------------      /**      * Verifies that cumulative probability density calculations match expected values      * using current test instance data      */     protected void verifyCumulativeProbabilities() {         // verify cumulativeProbability(double)         for (int i = 0; i < cumulativeTestPoints.length; i++) {             TestUtils.assertEquals("Incorrect cumulative probability value returned for "                 + cumulativeTestPoints[i], cumulativeTestValues[i],                 distribution.cumulativeProbability(cumulativeTestPoints[i]),                 getTolerance());         }         // verify probability(double, double)         for (int i = 0; i < cumulativeTestPoints.length; i++) {             for (int j = 0; j < cumulativeTestPoints.length; j++) {                 if (cumulativeTestPoints[i] <= cumulativeTestPoints[j]) {                     TestUtils.assertEquals(cumulativeTestValues[j] - cumulativeTestValues[i],                         distribution.probability(cumulativeTestPoints[i], cumulativeTestPoints[j]),                         getTolerance());                 } else {                     try {                         distribution.probability(cumulativeTestPoints[i], cumulativeTestPoints[j]);                     } catch (NumberIsTooLargeException e) {                         continue;                     }                     Assert.fail("distribution.probability(double, double) should have thrown an exception that second argument is too large");                 }             }         }     }      /**      * Verifies that inverse cumulative probability density calculations match expected values      * using current test instance data      */     protected void verifyInverseCumulativeProbabilities() {         for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {             TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for "                 + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                  distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]),                  getTolerance());         }     }      /**      * Verifies that density calculations match expected values      */     protected void verifyDensities() {         for (int i = 0; i < cumulativeTestPoints.length; i++) {             TestUtils.assertEquals("Incorrect probability density value returned for "                 + cumulativeTestPoints[i], densityTestValues[i],                  distribution.density(cumulativeTestPoints[i]),                  getTolerance());         }     }      /**      * Verifies that logarithmic density calculations match expected values      */     protected void verifyLogDensities() {         for (int i = 0; i < cumulativeTestPoints.length; i++) {             TestUtils.assertEquals("Incorrect probability density value returned for "                     + cumulativeTestPoints[i], logDensityTestValues[i],                     distribution.logDensity(cumulativeTestPoints[i]),                     getTolerance());         }     }      //------------------------ Default test cases -----------------------------      /**      * Verifies that cumulative probability density calculations match expected values      * using default test instance data      */     @Test     public void testCumulativeProbabilities() {         verifyCumulativeProbabilities();     }      /**      * Verifies that inverse cumulative probability density calculations match expected values      * using default test instance data      */     @Test     public void testInverseCumulativeProbabilities() {         verifyInverseCumulativeProbabilities();     }      /**      * Verifies that density calculations return expected values      * for default test instance data      */     @Test     public void testDensities() {         verifyDensities();     }      /**      * Verifies that logarithmic density calculations return expected values      * for default test instance data      */     @Test     public void testLogDensities() {         verifyLogDensities();     }      /**      * Verifies that probability computations are consistent      */     @Test     public void testConsistency() {         for (int i=1; i < cumulativeTestPoints.length; i++) {              // check that cdf(x, x) = 0             TestUtils.assertEquals(0d,                distribution.probability                  (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);              // check that P(a < X <= b) = P(X <= b) - P(X <= a)             double upper = FastMath.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);             double lower = FastMath.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);             double diff = distribution.cumulativeProbability(upper) -                 distribution.cumulativeProbability(lower);             double direct = distribution.probability(lower, upper);             TestUtils.assertEquals("Inconsistent probability for ("                     + lower + "," + upper + ")", diff, direct, tolerance);         }     }      /**      * Verifies that illegal arguments are correctly handled      */     @Test     public void testIllegalArguments() {         try {             distribution.probability(1, 0);             Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             distribution.inverseCumulativeProbability(-1);             Assert.fail("Expecting MathIllegalArgumentException for p = -1");         } catch (MathIllegalArgumentException ex) {             // expected         }         try {             distribution.inverseCumulativeProbability(2);             Assert.fail("Expecting MathIllegalArgumentException for p = 2");         } catch (MathIllegalArgumentException ex) {             // expected         }     }      /**      * Test sampling      */     @Test     public void testSampler() {         final int sampleSize = 1000;         final ContinuousDistribution.Sampler sampler =             distribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 123456789L));         final double[] sample = AbstractRealDistribution.sample(sampleSize, sampler);         final double[] quartiles = TestUtils.getDistributionQuartiles(distribution);         final double[] expected = {250, 250, 250, 250};         final long[] counts = new long[4];          for (int i = 0; i < sampleSize; i++) {             TestUtils.updateCounts(sample[i], counts, quartiles);         }         TestUtils.assertChiSquareAccept(expected, counts, 0.001);     }      /**      * Verify that density integrals match the distribution.      * The (filtered, sorted) cumulativeTestPoints array is used to source      * integration limits. The integral of the density (estimated using a      * Legendre-Gauss integrator) is compared with the cdf over the same      * interval. Test points outside of the domain of the density function      * are discarded.      */     @Test     public void testDensityIntegrals() {         final double tol = 1.0e-9;         final BaseAbstractUnivariateIntegrator integrator =             new IterativeLegendreGaussIntegrator(5, 1.0e-12, 1.0e-10);         final UnivariateFunction d = new UnivariateFunction() {             @Override             public double value(double x) {                 return distribution.density(x);             }         };         final ArrayList<Double> integrationTestPoints = new ArrayList<>();         for (int i = 0; i < cumulativeTestPoints.length; i++) {             if (Double.isNaN(cumulativeTestValues[i]) ||                     cumulativeTestValues[i] < 1.0e-5 ||                     cumulativeTestValues[i] > 1 - 1.0e-5) {                 continue; // exclude integrals outside domain.             }             integrationTestPoints.add(cumulativeTestPoints[i]);         }         Collections.sort(integrationTestPoints);         for (int i = 1; i < integrationTestPoints.size(); i++) {             Assert.assertEquals(                     distribution.probability(                             integrationTestPoints.get(0), integrationTestPoints.get(i)),                             integrator.integrate(                                     1000000, // Triangle integrals are very slow to converge                                     d, integrationTestPoints.get(0),                                     integrationTestPoints.get(i)), tol);         }     }      @Test     public void testDistributionClone()         throws IOException,                ClassNotFoundException {         // Construct a distribution and initialize its internal random         // generator, using a fixed seed for deterministic results.         final long seed = 123;         RandomSource source = RandomSource.WELL_512_A;         ContinuousDistribution.Sampler origSampler = distribution.createSampler(RandomSource.create(source, seed));          // Clone the distribution.         final ContinuousDistribution cloned = deepClone();         ContinuousDistribution.Sampler clonedSampler = cloned.createSampler(RandomSource.create(source, seed));          // Make sure they still produce the same samples.         Assert.assertEquals(origSampler.sample(),                             clonedSampler.sample(),                             0d);     }      //------------------ Getters / Setters for test instance data -----------     /**      * @return Returns the cumulativeTestPoints.      */     protected double[] getCumulativeTestPoints() {         return cumulativeTestPoints;     }      /**      * @param cumulativeTestPoints The cumulativeTestPoints to set.      */     protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {         this.cumulativeTestPoints = cumulativeTestPoints;     }      /**      * @return Returns the cumulativeTestValues.      */     protected double[] getCumulativeTestValues() {         return cumulativeTestValues;     }      /**      * @param cumulativeTestValues The cumulativeTestValues to set.      */     protected void setCumulativeTestValues(double[] cumulativeTestValues) {         this.cumulativeTestValues = cumulativeTestValues;     }      protected double[] getDensityTestValues() {         return densityTestValues;     }      protected void setDensityTestValues(double[] densityTestValues) {         this.densityTestValues = densityTestValues;     }      /**      * @return Returns the distribution.      */     protected ContinuousDistribution getDistribution() {         return distribution;     }      /**      * @param distribution The distribution to set.      */     protected void setDistribution(ContinuousDistribution distribution) {         this.distribution = distribution;     }      /**      * @return Returns the inverseCumulativeTestPoints.      */     protected double[] getInverseCumulativeTestPoints() {         return inverseCumulativeTestPoints;     }      /**      * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.      */     protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {         this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;     }      /**      * @return Returns the inverseCumulativeTestValues.      */     protected double[] getInverseCumulativeTestValues() {         return inverseCumulativeTestValues;     }      /**      * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.      */     protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {         this.inverseCumulativeTestValues = inverseCumulativeTestValues;     }      /**      * @return Returns the tolerance.      */     protected double getTolerance() {         return tolerance;     }      /**      * @param tolerance The tolerance to set.      */     protected void setTolerance(double tolerance) {         this.tolerance = tolerance;     }      /**      * Serialization and deserialization loop of the {@link #distribution}.      */     private ContinuousDistribution deepClone()         throws IOException,                ClassNotFoundException {         // Serialize to byte array.         final ByteArrayOutputStream bOut = new ByteArrayOutputStream();         final ObjectOutputStream oOut = new ObjectOutputStream(bOut);         oOut.writeObject(distribution);         final byte[] data = bOut.toByteArray();          // Deserialize from byte array.         final ByteArrayInputStream bIn = new ByteArrayInputStream(data);         final ObjectInputStream oIn = new ObjectInputStream(bIn);         final Object clone = oIn.readObject();         oIn.close();          return (ContinuousDistribution) clone;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;  import java.util.List;  import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.util.Pair; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore;  /**  * Test case {@link MixtureMultivariateNormalDistribution}.  */ public class MixtureMultivariateNormalDistributionTest {      @Test     public void testNonUnitWeightSum() {         final double[] weights = { 1, 2 };         final double[][] means = { { -1.5, 2.0 },                                    { 4.0, 8.2 } };         final double[][][] covariances = { { { 2.0, -1.1 },                                              { -1.1, 2.0 } },                                            { { 3.5, 1.5 },                                              { 1.5, 3.5 } } };         final MixtureMultivariateNormalDistribution d             = new MixtureMultivariateNormalDistribution(weights, means, covariances);          final List<Pair<Double, MultivariateNormalDistribution>> comp = d.getComponents();          Assert.assertEquals(1d / 3, comp.get(0).getFirst().doubleValue(), Math.ulp(1d));         Assert.assertEquals(2d / 3, comp.get(1).getFirst().doubleValue(), Math.ulp(1d));     }      @Test(expected=MathArithmeticException.class)     public void testWeightSumOverFlow() {         final double[] weights = { 0.5 * Double.MAX_VALUE, 0.51 * Double.MAX_VALUE };         final double[][] means = { { -1.5, 2.0 },                                    { 4.0, 8.2 } };         final double[][][] covariances = { { { 2.0, -1.1 },                                              { -1.1, 2.0 } },                                            { { 3.5, 1.5 },                                              { 1.5, 3.5 } } };         new MixtureMultivariateNormalDistribution(weights, means, covariances);     }      @Test(expected=NotPositiveException.class)     public void testPreconditionPositiveWeights() {         final double[] negativeWeights = { -0.5, 1.5 };         final double[][] means = { { -1.5, 2.0 },                                    { 4.0, 8.2 } };         final double[][][] covariances = { { { 2.0, -1.1 },                                              { -1.1, 2.0 } },                                            { { 3.5, 1.5 },                                              { 1.5, 3.5 } } };         new MixtureMultivariateNormalDistribution(negativeWeights, means, covariances);     }      /**      * Test the accuracy of the density calculation.      */     @Test     public void testDensities() {         final double[] weights = { 0.3, 0.7 };         final double[][] means = { { -1.5, 2.0 },                                    { 4.0, 8.2 } };         final double[][][] covariances = { { { 2.0, -1.1 },                                              { -1.1, 2.0 } },                                            { { 3.5, 1.5 },                                              { 1.5, 3.5 } } };         final MixtureMultivariateNormalDistribution d             = new MixtureMultivariateNormalDistribution(weights, means, covariances);          // Test vectors         final double[][] testValues = { { -1.5, 2 },                                         { 4, 8.2 },                                         { 1.5, -2 },                                         { 0, 0 } };          // Densities that we should get back.         // Calculated by assigning weights to multivariate normal distribution         // and summing         // values from dmvnorm function in R 2.15 CRAN package Mixtools v0.4.         // Like: .3*dmvnorm(val,mu1,sigma1)+.7*dmvnorm(val,mu2,sigma2)         final double[] correctDensities = { 0.02862037278930575,                                             0.03523044847314091,                                             0.000416241365629767,                                             0.009932042831700297 };          for (int i = 0; i < testValues.length; i++) {             Assert.assertEquals(correctDensities[i], d.density(testValues[i]), Math.ulp(1d));         }     }      /**      * Test the accuracy of sampling from the distribution.      */     @Ignore@Test     public void testSampling() {         final double[] weights = { 0.3, 0.7 };         final double[][] means = { { -1.5, 2.0 },                                    { 4.0, 8.2 } };         final double[][][] covariances = { { { 2.0, -1.1 },                                              { -1.1, 2.0 } },                                            { { 3.5, 1.5 },                                              { 1.5, 3.5 } } };         final MixtureMultivariateNormalDistribution d =             new MixtureMultivariateNormalDistribution(weights, means, covariances);         final MultivariateRealDistribution.Sampler sampler =             d.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 50));          final double[][] correctSamples = getCorrectSamples();         final int n = correctSamples.length;         final double[][] samples = AbstractMultivariateRealDistribution.sample(n, sampler);          for (int i = 0; i < n; i++) {             for (int j = 0; j < samples[i].length; j++) {                 Assert.assertEquals("sample[" + j + "]",                                     correctSamples[i][j], samples[i][j], 1e-16);             }         }     }      /**      * Values used in {@link #testSampling()}.      */     private double[][] getCorrectSamples() {         // These were sampled from the MultivariateNormalMixtureModelDistribution class         // with seed 50.         //         // They were then fit to a MVN mixture model in R using mixtools.         //         // The optimal parameters were:         // - component weights: {0.3595186, 0.6404814}         // - mean vectors: {-1.645879, 1.989797}, {3.474328, 7.782232}         // - covariance matrices:         //     { 1.397738 -1.167732         //       -1.167732 1.801782 }         //   and         //     { 3.934593 2.354787         //       2.354787 4.428024 }         //         // It is considered fairly close to the actual test parameters,         // considering that the sample size is only 100.         return new double[][] {             { 6.259990922080121, 11.972954175355897 },             { -2.5296544304801847, 1.0031292519854365 },             { 0.49037886081440396, 0.9758251727325711 },             { 5.022970993312015, 9.289348879616787 },             { -1.686183146603914, 2.007244382745706 },             { -1.4729253946002685, 2.762166644212484 },             { 4.329788143963888, 11.514016497132253 },             { 3.008674596114442, 4.960246550446107 },             { 3.342379304090846, 5.937630105198625 },             { 2.6993068328674754, 7.42190871572571 },             { -2.446569340219571, 1.9687117791378763 },             { 1.922417883170056, 4.917616702617099 },             { -1.1969741543898518, 2.4576126277884387 },             { 2.4216948702967196, 8.227710158117134 },             { 6.701424725804463, 9.098666475042428 },             { 2.9890253545698964, 9.643807939324331 },             { 0.7162632354907799, 8.978811120287553 },             { -2.7548699149775877, 4.1354812280794215 },             { 8.304528180745018, 11.602319388898287 },             { -2.7633253389165926, 2.786173883989795 },             { 1.3322228389460813, 5.447481218602913 },             { -1.8120096092851508, 1.605624499560037 },             { 3.6546253437206504, 8.195304526564376 },             { -2.312349539658588, 1.868941220444169 },             { -1.882322136356522, 2.033795570464242 },             { 4.562770714939441, 7.414967958885031 },             { 4.731882017875329, 8.890676665580747 },             { 3.492186010427425, 8.9005225241848 },             { -1.619700190174894, 3.314060142479045 },             { 3.5466090064003315, 7.75182101001913 },             { 5.455682472787392, 8.143119287755635 },             { -2.3859602945473197, 1.8826732217294837 },             { 3.9095306088680015, 9.258129209626317 },             { 7.443020189508173, 7.837840713329312 },             { 2.136004873917428, 6.917636475958297 },             { -1.7203379410395119, 2.3212878757611524 },             { 4.618991257611526, 12.095065976419436 },             { -0.4837044029854387, 0.8255970441255125 },             { -4.438938966557163, 4.948666297280241 },             { -0.4539625134045906, 4.700922454655341 },             { 2.1285488271265356, 8.457941480487563 },             { 3.4873561871454393, 11.99809827845933 },             { 4.723049431412658, 7.813095742563365 },             { 1.1245583037967455, 5.20587873556688 },             { 1.3411933634409197, 6.069796875785409 },             { 4.585119332463686, 7.967669543767418 },             { 1.3076522817963823, -0.647431033653445 },             { -1.4449446442803178, 1.9400424267464862 },             { -2.069794456383682, 3.5824162107496544 },             { -0.15959481421417276, 1.5466782303315405 },             { -2.0823081278810136, 3.0914366458581437 },             { 3.521944615248141, 10.276112932926408 },             { 1.0164326704884257, 4.342329556442856 },             { 5.3718868590295275, 8.374761158360922 },             { 0.3673656866959396, 8.75168581694866 },             { -2.250268955954753, 1.4610850300996527 },             { -2.312739727403522, 1.5921126297576362 },             { 3.138993360831055, 6.7338392374947365 },             { 2.6978650950790115, 7.941857288979095 },             { 4.387985088655384, 8.253499976968 },             { -1.8928961721456705, 0.23631082388724223 },             { 4.43509029544109, 8.565290285488782 },             { 4.904728034106502, 5.79936660133754 },             { -1.7640371853739507, 2.7343727594167433 },             { 2.4553674733053463, 7.875871017408807 },             { -2.6478965122565006, 4.465127753193949 },             { 3.493873671142299, 10.443093773532448 },             { 1.1321916197409103, 7.127108479263268 },             { -1.7335075535240392, 2.550629648463023 },             { -0.9772679734368084, 4.377196298969238 },             { 3.6388366973980357, 6.947299283206256 },             { 0.27043799318823325, 6.587978599614367 },             { 5.356782352010253, 7.388957912116327 },             { -0.09187745751354681, 0.23612399246659743 },             { 2.903203580353435, 3.8076727621794415 },             { 5.297014824937293, 8.650985262326508 },             { 4.934508602170976, 9.164571423190052 },             { -1.0004911869654256, 4.797064194444461 },             { 6.782491700298046, 11.852373338280497 },             { 2.8983678524536014, 8.303837362117521 },             { 4.805003269830865, 6.790462904325329 },             { -0.8815799740744226, 1.3015810062131394 },             { 5.115138859802104, 6.376895810201089 },             { 4.301239328205988, 8.60546337560793 },             { 3.276423626317666, 9.889429652591947 },             { -4.001924973153122, 4.3353864592328515 },             { 3.9571892554119517, 4.500569057308562 },             { 4.783067027436208, 7.451125480601317 },             { 4.79065438272821, 9.614122776979698 },             { 2.677655270279617, 6.8875223698210135 },             { -1.3714746289327362, 2.3992153193382437 },             { 3.240136859745249, 7.748339397522042 },             { 5.107885374416291, 8.508324480583724 },             { -1.5830830226666048, 0.9139127045208315 },             { -1.1596156791652918, -0.04502759384531929 },             { -0.4670021307952068, 3.6193633227841624 },             { -0.7026065228267798, 0.4811423031997131 },             { -2.719979836732917, 2.5165041618080104 },             { 1.0336754331123372, -0.34966029029320644 },             { 4.743217291882213, 5.750060115251131 }         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;  import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import java.util.ArrayList; import java.util.Arrays;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.statistics.distribution.ConstantContinuousDistribution; import org.apache.commons.statistics.distribution.UniformContinuousDistribution; import org.apache.commons.statistics.distribution.NormalDistribution; import org.apache.commons.math4.TestUtils; import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator; import org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator; import org.apache.commons.math4.exception.MathIllegalStateException; import org.apache.commons.math4.exception.NullArgumentException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.rng.simple.RandomSource; import org.apache.commons.math4.stat.descriptive.SummaryStatistics; import org.apache.commons.math4.util.FastMath; import org.junit.Assert; import org.junit.Before; import org.junit.Test;  /**  * Test cases for the {@link EmpiricalDistribution} class.  */ public final class EmpiricalDistributionTest extends RealDistributionAbstractTest {      protected EmpiricalDistribution empiricalDistribution = null;     protected EmpiricalDistribution empiricalDistribution2 = null;     protected File file = null;     protected URL url = null;     protected double[] dataArray = null;     protected final int n = 10000;      @Override     @Before     public void setUp() {         super.setUp();         empiricalDistribution = new EmpiricalDistribution(100);         url = getClass().getResource("testData.txt");         final ArrayList<Double> list = new ArrayList<>();         try {             empiricalDistribution2 = new EmpiricalDistribution(100);             BufferedReader in =                 new BufferedReader(new InputStreamReader(                         url.openStream()));             String str = null;             while ((str = in.readLine()) != null) {                 list.add(Double.valueOf(str));             }             in.close();             in = null;         } catch (IOException ex) {             Assert.fail("IOException " + ex);         }          dataArray = new double[list.size()];         int i = 0;         for (Double data : list) {             dataArray[i] = data.doubleValue();             i++;         }     }      // MATH-1279     @Test(expected=NotStrictlyPositiveException.class)     public void testPrecondition1() {         new EmpiricalDistribution(0);     }      /**      * Test EmpiricalDistribution.load() using sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file. Also verify that load is idempotent.      */     @Test     public void testLoad() throws Exception {         // Load from a URL         empiricalDistribution.load(url);         checkDistribution();          // Load again from a file (also verifies idempotency of load)         File file = new File(url.toURI());         empiricalDistribution.load(file);         checkDistribution();     }      private void checkDistribution() {         // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1         // Make sure that loaded distribution matches this         Assert.assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);         //TODO: replace with statistical tests         Assert.assertEquals(empiricalDistribution.getSampleStats().getMean(),                 5.069831575018909,10E-7);         Assert.assertEquals(empiricalDistribution.getSampleStats().getStandardDeviation(),                 1.0173699343977738,10E-7);     }      /**      * Test EmpiricalDistribution.load(double[]) using data taken from      * sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.      */     @Test     public void testDoubleLoad() throws Exception {         empiricalDistribution2.load(dataArray);         // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1         // Make sure that loaded distribution matches this         Assert.assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);         //TODO: replace with statistical tests         Assert.assertEquals(empiricalDistribution2.getSampleStats().getMean(),                 5.069831575018909,10E-7);         Assert.assertEquals(empiricalDistribution2.getSampleStats().getStandardDeviation(),                 1.0173699343977738,10E-7);          double[] bounds = empiricalDistribution2.getGeneratorUpperBounds();         Assert.assertEquals(bounds.length, 100);         Assert.assertEquals(bounds[99], 1.0, 10e-12);      }       // MATH-1531     @Test     public void testMath1531() {         final EmpiricalDistribution inputDistribution = new EmpiricalDistribution(120);         inputDistribution.load(new double[] {                 50.993456376721454,                 49.455345691918055,                 49.527276095295804,                 50.017183448668845,                 49.10508147470046,                 49.813998274118696,                 50.87195348756139,                 50.419474110037,                 50.63614906979689,                 49.49694777179407,                 50.71799078406067,                 50.03192853759164,                 49.915092423165994,                 49.56895392597687,                 51.034638001064934,                 50.681227971275945,                 50.43749845081759,                 49.86513120270245,                 50.21475262482965,                 49.99202971042547,                 50.02382189838519,                 49.386888585302884,                 49.45585010202781,                 49.988009479855435,                 49.8136712206123,                 49.6715197127997,                 50.1981278397565,                 49.842297508010276,                 49.62491227740015,                 50.05101916097176,                 48.834912763303926,                 49.806787657848574,                 49.478236106374695,                 49.56648347371614,                 49.95069238081982,                 49.71845132077346,                 50.6097468705947,                 49.80724637775541,                 49.90448813086025,                 49.39641861662603,                 50.434295712893714,                 49.227176959566734,                 49.541126466050905,                 49.03416593170446,                 49.11584328494423,                 49.61387482435674,                 49.92877857995328,                 50.70638552955101,                 50.60078208448842,                 49.39326233277838,                 49.21488424364095,                 49.69503351015096,                 50.13733214001718,                 50.22084761458942,                 51.09804435604931,                 49.18559131120419,                 49.52286371605357,                 49.34804374996689,                 49.6901827776375,                 50.01316351359638,                 48.7751460520373,                 50.12961836291053,                 49.9978419772511,                 49.885658399408584,                 49.673438879979834,                 49.45565980965606,                 50.429747484906564,                 49.40129274804164,                 50.13034614008073,                 49.87685735146651,                 50.12967905393557,                 50.323560376181696,                 49.83519233651367,                 49.37333369733053,                 49.70074301611427,                 50.11626105774947,                 50.28249500380083,                 50.543354367136466,                 50.05866241335002,                 50.39516515672527,                 49.4838561463057,                 50.451757089234796,                 50.31370674203726,                 49.79063762614284,                 50.19652349768548,                 49.75881420748814,                 49.98371855036422,                 49.82171344472916,                 48.810793204162415,                 49.37040569084592,                 50.050641186203976,                 50.48360952263646,                 50.86666450358076,                 50.463268776129844,                 50.137489751888666,                 50.23823061444118,                 49.881460479468004,                 50.641174398764356,                 49.09314136851421,                 48.80877928574451,                 50.46197084844826,                 49.97691704141741,                 49.99933997561926,                 50.25692254481885,                 49.52973451252715,                 49.81229858420664,                 48.996112655915994,                 48.740531054814674,                 50.026642633066416,                 49.98696633604899,                 49.61307159972952,                 50.5115278979726,                 50.75245152442404,                 50.51807785445929,                 49.60929671768147,                 49.1079533564074,                 49.65347196551866,                 49.31684818724059,                 50.4906368627049,                 50.37483603684714});         inputDistribution.inverseCumulativeProbability(0.7166666666666669);     }      /**       * Generate 1000 random values and make sure they look OK.<br>       * Note that there is a non-zero (but very small) probability that       * these tests will fail even if the code is working as designed.       */     @Test     public void testNext() throws Exception {         tstGen(0.1);         tstDoubleGen(0.1);     }      /**      * Make sure exception thrown if sampling is attempted      * before loading empiricalDistribution.      */     @Test     public void testNextFail1() {         try {             empiricalDistribution.createSampler(RandomSource.create(RandomSource.JDK)).sample();             Assert.fail("Expecting MathIllegalStateException");         } catch (MathIllegalStateException ex) {             // expected         }     }      /**      * Make sure exception thrown if sampling is attempted      * before loading empiricalDistribution.      */     @Test     public void testNextFail2() {         try {             empiricalDistribution2.createSampler(RandomSource.create(RandomSource.JDK)).sample();             Assert.fail("Expecting MathIllegalStateException");         } catch (MathIllegalStateException ex) {             // expected         }     }      /**      * Make sure we can handle a grid size that is too fine      */     @Test     public void testGridTooFine() throws Exception {         empiricalDistribution = new EmpiricalDistribution(1001);         tstGen(0.1);         empiricalDistribution2 = new EmpiricalDistribution(1001);         tstDoubleGen(0.1);     }      /**      * How about too fat?      */     @Test     public void testGridTooFat() throws Exception {         empiricalDistribution = new EmpiricalDistribution(1);         tstGen(5); // ridiculous tolerance; but ridiculous grid size                    // really just checking to make sure we do not bomb         empiricalDistribution2 = new EmpiricalDistribution(1);         tstDoubleGen(5);     }      /**      * Test bin index overflow problem (BZ 36450)      */     @Test     public void testBinIndexOverflow() throws Exception {         double[] x = new double[] {9474.94326071674, 2080107.8865462579};         new EmpiricalDistribution().load(x);     }      @Test     public void testSerialization() {         // Empty         EmpiricalDistribution dist = new EmpiricalDistribution();         EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);         verifySame(dist, dist2);          // Loaded         empiricalDistribution2.load(dataArray);         dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);         verifySame(empiricalDistribution2, dist2);     }      @Test(expected=NullArgumentException.class)     public void testLoadNullDoubleArray() {        new EmpiricalDistribution().load((double[]) null);     }      @Test(expected=NullArgumentException.class)     public void testLoadNullURL() throws Exception {         new EmpiricalDistribution().load((URL) null);     }      @Test(expected=NullArgumentException.class)     public void testLoadNullFile() throws Exception {         new EmpiricalDistribution().load((File) null);     }      /**      * MATH-298      */     @Test     public void testGetBinUpperBounds() {         double[] testData = {0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10};         EmpiricalDistribution dist = new EmpiricalDistribution(5);         dist.load(testData);         double[] expectedBinUpperBounds = {2, 4, 6, 8, 10};         double[] expectedGeneratorUpperBounds = {4d/13d, 7d/13d, 9d/13d, 11d/13d, 1};         double tol = 10E-12;         TestUtils.assertEquals(expectedBinUpperBounds, dist.getUpperBounds(), tol);         TestUtils.assertEquals(expectedGeneratorUpperBounds, dist.getGeneratorUpperBounds(), tol);     }      private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {         Assert.assertEquals(d1.isLoaded(), d2.isLoaded());         Assert.assertEquals(d1.getBinCount(), d2.getBinCount());         Assert.assertEquals(d1.getSampleStats(), d2.getSampleStats());         if (d1.isLoaded()) {             for (int i = 0;  i < d1.getUpperBounds().length; i++) {                 Assert.assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);             }             Assert.assertEquals(d1.getBinStats(), d2.getBinStats());         }     }      private void tstGen(double tolerance)throws Exception {         empiricalDistribution.load(url);         ContinuousDistribution.Sampler sampler             = empiricalDistribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));         SummaryStatistics stats = new SummaryStatistics();         for (int i = 1; i < 1000; i++) {             stats.addValue(sampler.sample());         }         Assert.assertEquals("mean", 5.069831575018909, stats.getMean(),tolerance);         Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(),tolerance);     }      private void tstDoubleGen(double tolerance)throws Exception {         empiricalDistribution2.load(dataArray);         ContinuousDistribution.Sampler sampler             = empiricalDistribution2.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));         SummaryStatistics stats = new SummaryStatistics();         for (int i = 1; i < 1000; i++) {             stats.addValue(sampler.sample());         }         Assert.assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);         Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(), tolerance);     }      //  Setup for distribution tests      @Override     public ContinuousDistribution makeDistribution() {         // Create a uniform distribution on [0, 10,000]         final double[] sourceData = new double[n + 1];         for (int i = 0; i < n + 1; i++) {             sourceData[i] = i;         }         EmpiricalDistribution dist = new EmpiricalDistribution();         dist.load(sourceData);         return dist;     }      /** Uniform bin mass = 10/10001 == mass of all but the first bin */     private final double binMass = 10d / (n + 1);      /** Mass of first bin = 11/10001 */     private final double firstBinMass = 11d / (n + 1);      @Override     public double[] makeCumulativeTestPoints() {        final double[] testPoints = new double[] {9, 10, 15, 1000, 5004, 9999};        return testPoints;     }       @Override     public double[] makeCumulativeTestValues() {         /*          * Bins should be [0, 10], (10, 20], ..., (9990, 10000]          * Kernels should be N(4.5, 3.02765), N(14.5, 3.02765)...          * Each bin should have mass 10/10000 = .001          */         final double[] testPoints = getCumulativeTestPoints();         final double[] cumValues = new double[testPoints.length];         final EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution) makeDistribution();         final double[] binBounds = empiricalDistribution.getUpperBounds();         for (int i = 0; i < testPoints.length; i++) {             final int bin = findBin(testPoints[i]);             final double lower = bin == 0 ? empiricalDistribution.getSupportLowerBound() :                 binBounds[bin - 1];             final double upper = binBounds[bin];             // Compute bMinus = sum or mass of bins below the bin containing the point             // First bin has mass 11 / 10000, the rest have mass 10 / 10000.             final double bMinus = bin == 0 ? 0 : (bin - 1) * binMass + firstBinMass;             final ContinuousDistribution kernel = findKernel(lower, upper);             final double withinBinKernelMass = kernel.probability(lower, upper);             final double kernelCum = kernel.probability(lower, testPoints[i]);             cumValues[i] = bMinus + (bin == 0 ? firstBinMass : binMass) * kernelCum/withinBinKernelMass;         }         return cumValues;     }      @Override     public double[] makeDensityTestValues() {         final double[] testPoints = getCumulativeTestPoints();         final double[] densityValues = new double[testPoints.length];         final EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution) makeDistribution();         final double[] binBounds = empiricalDistribution.getUpperBounds();         for (int i = 0; i < testPoints.length; i++) {             final int bin = findBin(testPoints[i]);             final double lower = bin == 0 ? empiricalDistribution.getSupportLowerBound() :                 binBounds[bin - 1];             final double upper = binBounds[bin];             final ContinuousDistribution kernel = findKernel(lower, upper);             final double withinBinKernelMass = kernel.probability(lower, upper);             final double density = kernel.density(testPoints[i]);             densityValues[i] = density * (bin == 0 ? firstBinMass : binMass) / withinBinKernelMass;         }         return densityValues;     }      /**      * Modify test integration bounds from the default. Because the distribution      * has discontinuities at bin boundaries, integrals spanning multiple bins      * will face convergence problems.  Only test within-bin integrals and spans      * across no more than 3 bin boundaries.      */     @Override     @Test     public void testDensityIntegrals() {         final ContinuousDistribution distribution = makeDistribution();         final double tol = 1.0e-9;         final BaseAbstractUnivariateIntegrator integrator =             new IterativeLegendreGaussIntegrator(5, 1.0e-12, 1.0e-10);         final UnivariateFunction d = new UnivariateFunction() {             @Override             public double value(double x) {                 return distribution.density(x);             }         };         final double[] lower = {0, 5, 1000, 5001, 9995};         final double[] upper = {5, 12, 1030, 5010, 10000};         for (int i = 1; i < 5; i++) {             Assert.assertEquals(                     distribution.probability(                             lower[i], upper[i]),                             integrator.integrate(                                     1000000, // Triangle integrals are very slow to converge                                     d, lower[i], upper[i]), tol);         }     }      /**      * MATH-984      * Verify that sampled values do not go outside of the range of the data.      */     @Test     public void testSampleValuesRange() {         // Concentrate values near the endpoints of (0, 1).         // Unconstrained Gaussian kernel would generate values outside the interval.         final double[] data = new double[100];         for (int i = 0; i < 50; i++) {             data[i] = 1 / ((double) i + 1);         }         for (int i = 51; i < 100; i++) {             data[i] = 1 - 1 / (100 - (double) i + 2);         }         EmpiricalDistribution dist = new EmpiricalDistribution(10);         dist.load(data);         ContinuousDistribution.Sampler sampler             = dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));         for (int i = 0; i < 1000; i++) {             final double dev = sampler.sample();             Assert.assertTrue(dev < 1);             Assert.assertTrue(dev > 0);         }     }      /**      * MATH-1203, MATH-1208      */     @Test     public void testNoBinVariance() {         final double[] data = {0, 0, 1, 1};         EmpiricalDistribution dist = new EmpiricalDistribution(2);         dist.load(data);         ContinuousDistribution.Sampler sampler             = dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));         for (int i = 0; i < 1000; i++) {             final double dev = sampler.sample();             Assert.assertTrue(dev == 0 || dev == 1);         }         Assert.assertEquals(0.5, dist.cumulativeProbability(0), Double.MIN_VALUE);         Assert.assertEquals(1.0, dist.cumulativeProbability(1), Double.MIN_VALUE);         Assert.assertEquals(0.5, dist.cumulativeProbability(0.5), Double.MIN_VALUE);         Assert.assertEquals(0.5, dist.cumulativeProbability(0.7), Double.MIN_VALUE);     }      /**      * Find the bin that x belongs (relative to {@link #makeDistribution()}).      */     private int findBin(double x) {         // Number of bins below x should be trunc(x/10)         final double nMinus = FastMath.floor(x / 10);         final int bin =  (int) FastMath.round(nMinus);         // If x falls on a bin boundary, it is in the lower bin         return FastMath.floor(x / 10) == x / 10 ? bin - 1 : bin;     }      /**      * Find the within-bin kernel for the bin with lower bound lower      * and upper bound upper. All bins other than the first contain 10 points      * exclusive of the lower bound and are centered at (lower + upper + 1) / 2.      * The first bin includes its lower bound, 0, so has different mean and      * standard deviation.      */     private ContinuousDistribution findKernel(double lower, double upper) {         if (lower < 1) {             return new NormalDistribution(5d, 3.3166247903554);         } else {             return new NormalDistribution((upper + lower + 1) / 2d, 3.0276503540974917);         }     }      @Test     public void testKernelOverrideConstant() {         final EmpiricalDistribution dist = new ConstantKernelEmpiricalDistribution(5);         final double[] data = {1d,2d,3d, 4d,5d,6d, 7d,8d,9d, 10d,11d,12d, 13d,14d,15d};         dist.load(data);         ContinuousDistribution.Sampler sampler             = dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));         // Bin masses concentrated on 2, 5, 8, 11, 14 <- effectively discrete uniform distribution over these         double[] values = {2d, 5d, 8d, 11d, 14d};         for (int i = 0; i < 20; i++) {             Assert.assertTrue(Arrays.binarySearch(values, sampler.sample()) >= 0);         }         final double tol = 10E-12;         Assert.assertEquals(0.0, dist.cumulativeProbability(1), tol);         Assert.assertEquals(0.2, dist.cumulativeProbability(2), tol);         Assert.assertEquals(0.6, dist.cumulativeProbability(10), tol);         Assert.assertEquals(0.8, dist.cumulativeProbability(12), tol);         Assert.assertEquals(0.8, dist.cumulativeProbability(13), tol);         Assert.assertEquals(1.0, dist.cumulativeProbability(15), tol);          Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.1), tol);         Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.2), tol);         Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.3), tol);         Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.4), tol);         Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.5), tol);         Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.6), tol);     }      @Test     public void testKernelOverrideUniform() {         final EmpiricalDistribution dist = new UniformKernelEmpiricalDistribution(5);         final double[] data = {1d,2d,3d, 4d,5d,6d, 7d,8d,9d, 10d,11d,12d, 13d,14d,15d};         dist.load(data);         ContinuousDistribution.Sampler sampler             = dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));         // Kernels are uniform distributions on [1,3], [4,6], [7,9], [10,12], [13,15]         final double bounds[] = {3d, 6d, 9d, 12d};         final double tol = 10E-12;         for (int i = 0; i < 20; i++) {             final double v = sampler.sample();             // Make sure v is not in the excluded range between bins - that is (bounds[i], bounds[i] + 1)             for (int j = 0; j < bounds.length; j++) {                 Assert.assertFalse(v > bounds[j] + tol && v < bounds[j] + 1 - tol);             }         }         Assert.assertEquals(0.0, dist.cumulativeProbability(1), tol);         Assert.assertEquals(0.1, dist.cumulativeProbability(2), tol);         Assert.assertEquals(0.6, dist.cumulativeProbability(10), tol);         Assert.assertEquals(0.8, dist.cumulativeProbability(12), tol);         Assert.assertEquals(0.8, dist.cumulativeProbability(13), tol);         Assert.assertEquals(1.0, dist.cumulativeProbability(15), tol);          Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.1), tol);         Assert.assertEquals(3.0, dist.inverseCumulativeProbability(0.2), tol);         Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.3), tol);         Assert.assertEquals(6.0, dist.inverseCumulativeProbability(0.4), tol);         Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.5), tol);         Assert.assertEquals(9.0, dist.inverseCumulativeProbability(0.6), tol);     }       /**      * Empirical distribution using a constant smoothing kernel.      */     private class ConstantKernelEmpiricalDistribution extends EmpiricalDistribution {         private static final long serialVersionUID = 1L;         public ConstantKernelEmpiricalDistribution(int i) {             super(i);         }         // Use constant distribution equal to bin mean within bin         @Override         protected ContinuousDistribution getKernel(SummaryStatistics bStats) {             return new ConstantContinuousDistribution(bStats.getMean());         }     }      /**      * Empirical distribution using a uniform smoothing kernel.      */     private class UniformKernelEmpiricalDistribution extends EmpiricalDistribution {         private static final long serialVersionUID = 2963149194515159653L;         public UniformKernelEmpiricalDistribution(int i) {             super(i);         }         @Override         protected ContinuousDistribution getKernel(SummaryStatistics bStats) {             return new UniformContinuousDistribution(bStats.getMin(), bStats.getMax());         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;  import org.junit.Assert; import org.junit.Test;  /**  * Test cases for AbstractIntegerDistribution default implementations.  *  */ public class AbstractIntegerDistributionTest {     protected final DiceDistribution diceDistribution = new DiceDistribution();     protected final double p = diceDistribution.probability(1);      @Test     public void testInverseCumulativeProbabilityMethod()     {         double precision = 0.000000000000001;         Assert.assertEquals(1, diceDistribution.inverseCumulativeProbability(0));         Assert.assertEquals(1, diceDistribution.inverseCumulativeProbability((1d-Double.MIN_VALUE)/6d));         Assert.assertEquals(2, diceDistribution.inverseCumulativeProbability((1d+precision)/6d));         Assert.assertEquals(2, diceDistribution.inverseCumulativeProbability((2d-Double.MIN_VALUE)/6d));         Assert.assertEquals(3, diceDistribution.inverseCumulativeProbability((2d+precision)/6d));         Assert.assertEquals(3, diceDistribution.inverseCumulativeProbability((3d-Double.MIN_VALUE)/6d));         Assert.assertEquals(4, diceDistribution.inverseCumulativeProbability((3d+precision)/6d));         Assert.assertEquals(4, diceDistribution.inverseCumulativeProbability((4d-Double.MIN_VALUE)/6d));         Assert.assertEquals(5, diceDistribution.inverseCumulativeProbability((4d+precision)/6d));         Assert.assertEquals(5, diceDistribution.inverseCumulativeProbability((5d-precision)/6d));//Can't use Double.MIN         Assert.assertEquals(6, diceDistribution.inverseCumulativeProbability((5d+precision)/6d));         Assert.assertEquals(6, diceDistribution.inverseCumulativeProbability((6d-precision)/6d));//Can't use Double.MIN         Assert.assertEquals(6, diceDistribution.inverseCumulativeProbability((6d)/6d));     }      @Test     public void testCumulativeProbabilitiesSingleArguments() {         for (int i = 1; i < 7; i++) {             Assert.assertEquals(p * i,                     diceDistribution.cumulativeProbability(i), Double.MIN_VALUE);         }         Assert.assertEquals(0.0,                 diceDistribution.cumulativeProbability(0), Double.MIN_VALUE);         Assert.assertEquals(1.0,                 diceDistribution.cumulativeProbability(7), Double.MIN_VALUE);     }      @Test     public void testProbabilitiesRangeArguments() {         int lower = 0;         int upper = 6;         for (int i = 0; i < 2; i++) {             // cum(0,6) = p(0 < X <= 6) = 1, cum(1,5) = 4/6, cum(2,4) = 2/6             Assert.assertEquals(1 - p * 2 * i,                     diceDistribution.probability(lower, upper), 1E-12);             lower++;             upper--;         }         for (int i = 0; i < 6; i++) {             Assert.assertEquals(p, diceDistribution.probability(i, i+1), 1E-12);         }     }      /**      * Simple distribution modeling a 6-sided die      */     class DiceDistribution extends AbstractIntegerDistribution {         public static final long serialVersionUID = 23734213;          private final double p = 1d/6d;          @Override         public double probability(int x) {             if (x < 1 || x > 6) {                 return 0;             } else {                 return p;             }         }          @Override         public double cumulativeProbability(int x) {             if (x < 1) {                 return 0;             } else if (x >= 6) {                 return 1;             } else {                 return p * x;             }         }          @Override         public double getMean() {             return 3.5;         }          @Override         public double getVariance() {             return 70/24;  // E(X^2) - E(X)^2         }          @Override         public int getSupportLowerBound() {             return 1;         }          @Override         public int getSupportUpperBound() {             return 6;         }          @Override         public final boolean isSupportConnected() {             return true;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to You under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */ package org.apache.commons.math4.distribution.fitting;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  import org.apache.commons.math4.distribution.MixtureMultivariateNormalDistribution; import org.apache.commons.math4.distribution.MultivariateNormalDistribution; import org.apache.commons.math4.exception.ConvergenceException; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.NotStrictlyPositiveException; import org.apache.commons.math4.exception.NumberIsTooSmallException; import org.apache.commons.math4.linear.Array2DRowRealMatrix; import org.apache.commons.math4.linear.RealMatrix; import org.apache.commons.math4.util.Pair; import org.junit.Assert; import org.junit.Test;  /**  * Test that demonstrates the use of  * {@link MultivariateNormalMixtureExpectationMaximization}.  */ public class MultivariateNormalMixtureExpectationMaximizationTest {      @Test(expected = NotStrictlyPositiveException.class)     public void testNonEmptyData() {         // Should not accept empty data         new MultivariateNormalMixtureExpectationMaximization(new double[][] {});     }      @Test(expected = DimensionMismatchException.class)     public void testNonJaggedData() {         // Reject data with nonconstant numbers of columns         double[][] data = new double[][] {                 { 1, 2, 3 },                 { 4, 5, 6, 7 },         };         new MultivariateNormalMixtureExpectationMaximization(data);     }      @Test(expected = NumberIsTooSmallException.class)     public void testMultipleColumnsRequired() {         // Data should have at least 2 columns         double[][] data = new double[][] {                 { 1 }, { 2 }         };         new MultivariateNormalMixtureExpectationMaximization(data);     }      @Test(expected = NotStrictlyPositiveException.class)     public void testMaxIterationsPositive() {         // Maximum iterations for fit must be positive integer         double[][] data = getTestSamples();         MultivariateNormalMixtureExpectationMaximization fitter =                 new MultivariateNormalMixtureExpectationMaximization(data);          MixtureMultivariateNormalDistribution             initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);          fitter.fit(initialMix, 0, 1E-5);     }      @Test(expected = NotStrictlyPositiveException.class)     public void testThresholdPositive() {         // Maximum iterations for fit must be positive         double[][] data = getTestSamples();         MultivariateNormalMixtureExpectationMaximization fitter =                 new MultivariateNormalMixtureExpectationMaximization(                     data);          MixtureMultivariateNormalDistribution             initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);          fitter.fit(initialMix, 1000, 0);     }      @Test(expected = ConvergenceException.class)     public void testConvergenceException() {         // ConvergenceException thrown if fit terminates before threshold met         double[][] data = getTestSamples();         MultivariateNormalMixtureExpectationMaximization fitter             = new MultivariateNormalMixtureExpectationMaximization(data);          MixtureMultivariateNormalDistribution             initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);          // 5 iterations not enough to meet convergence threshold         fitter.fit(initialMix, 5, 1E-5);     }      @Test(expected = DimensionMismatchException.class)     public void testIncompatibleInitialMixture() {         // Data has 3 columns         double[][] data = new double[][] {                 { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }         };         double[] weights = new double[] { 0.5, 0.5 };          // These distributions are compatible with 2-column data, not 3-column         // data         MultivariateNormalDistribution[] mvns = new MultivariateNormalDistribution[2];          mvns[0] = new MultivariateNormalDistribution(new double[] {                         -0.0021722935000328823, 3.5432892936887908 },                         new double[][] {                                 { 4.537422569229048, 3.5266152281729304 },                                 { 3.5266152281729304, 6.175448814169779 } });         mvns[1] = new MultivariateNormalDistribution(new double[] {                         5.090902706507635, 8.68540656355283 }, new double[][] {                         { 2.886778573963039, 1.5257474543463154 },                         { 1.5257474543463154, 3.3794567673616918 } });          // Create components and mixture         List<Pair<Double, MultivariateNormalDistribution>> components =                 new ArrayList<>();         components.add(new Pair<>(                 weights[0], mvns[0]));         components.add(new Pair<>(                 weights[1], mvns[1]));          MixtureMultivariateNormalDistribution badInitialMix             = new MixtureMultivariateNormalDistribution(components);          MultivariateNormalMixtureExpectationMaximization fitter             = new MultivariateNormalMixtureExpectationMaximization(data);          fitter.fit(badInitialMix);     }      @Test     public void testInitialMixture() {         // Testing initial mixture estimated from data         final double[] correctWeights = new double[] { 0.5, 0.5 };          final double[][] correctMeans = new double[][] {             {-0.0021722935000328823, 3.5432892936887908},             {5.090902706507635, 8.68540656355283},         };          final RealMatrix[] correctCovMats = new Array2DRowRealMatrix[2];          correctCovMats[0] = new Array2DRowRealMatrix(new double[][] {                 { 4.537422569229048, 3.5266152281729304 },                 { 3.5266152281729304, 6.175448814169779 } });          correctCovMats[1] = new Array2DRowRealMatrix( new double[][] {                 { 2.886778573963039, 1.5257474543463154 },                 { 1.5257474543463154, 3.3794567673616918 } });          final MultivariateNormalDistribution[] correctMVNs = new                 MultivariateNormalDistribution[2];          correctMVNs[0] = new MultivariateNormalDistribution(correctMeans[0],                 correctCovMats[0].getData());          correctMVNs[1] = new MultivariateNormalDistribution(correctMeans[1],                 correctCovMats[1].getData());          final MixtureMultivariateNormalDistribution initialMix             = MultivariateNormalMixtureExpectationMaximization.estimate(getTestSamples(), 2);          int i = 0;         for (Pair<Double, MultivariateNormalDistribution> component : initialMix                 .getComponents()) {             Assert.assertEquals(correctWeights[i], component.getFirst(),                     Math.ulp(1d));              final double[] means = component.getValue().getMeans();             Assert.assertTrue(Arrays.equals(correctMeans[i], means));              final RealMatrix covMat = component.getValue().getCovariances();             Assert.assertEquals(correctCovMats[i], covMat);             i++;         }     }      @Test     public void testFit() {         // Test that the loglikelihood, weights, and models are determined and         // fitted correctly         final double[][] data = getTestSamples();         final double correctLogLikelihood = -4.292431006791994;         final double[] correctWeights = new double[] { 0.2962324189652912, 0.7037675810347089 };          final double[][] correctMeans = new double[][]{             {-1.4213112715121132, 1.6924690505757753},             {4.213612224374709, 7.975621325853645}         };          final RealMatrix[] correctCovMats = new Array2DRowRealMatrix[2];         correctCovMats[0] = new Array2DRowRealMatrix(new double[][] {             { 1.739356907285747, -0.5867644251487614 },             { -0.5867644251487614, 1.0232932029324642 } }                 );         correctCovMats[1] = new Array2DRowRealMatrix(new double[][] {             { 4.245384898007161, 2.5797798966382155 },             { 2.5797798966382155, 3.9200272522448367 } });          final MultivariateNormalDistribution[] correctMVNs = new MultivariateNormalDistribution[2];         correctMVNs[0] = new MultivariateNormalDistribution(correctMeans[0], correctCovMats[0].getData());         correctMVNs[1] = new MultivariateNormalDistribution(correctMeans[1], correctCovMats[1].getData());          MultivariateNormalMixtureExpectationMaximization fitter             = new MultivariateNormalMixtureExpectationMaximization(data);          MixtureMultivariateNormalDistribution initialMix             = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);         fitter.fit(initialMix);         MixtureMultivariateNormalDistribution fittedMix = fitter.getFittedModel();         List<Pair<Double, MultivariateNormalDistribution>> components = fittedMix.getComponents();          Assert.assertEquals(correctLogLikelihood,                             fitter.getLogLikelihood(),                             Math.ulp(1d));          int i = 0;         for (Pair<Double, MultivariateNormalDistribution> component : components) {             final double weight = component.getFirst();             final MultivariateNormalDistribution mvn = component.getSecond();             final double[] mean = mvn.getMeans();             final RealMatrix covMat = mvn.getCovariances();             Assert.assertEquals(correctWeights[i], weight, Math.ulp(1d));             Assert.assertTrue(Arrays.equals(correctMeans[i], mean));             Assert.assertEquals(correctCovMats[i], covMat);             i++;         }     }      private double[][] getTestSamples() {         // generated using R Mixtools rmvnorm with mean vectors [-1.5, 2] and         // [4, 8.2]         return new double[][] { { 7.358553610469948, 11.31260831446758 },                 { 7.175770420124739, 8.988812210204454 },                 { 4.324151905768422, 6.837727899051482 },                 { 2.157832219173036, 6.317444585521968 },                 { -1.890157421896651, 1.74271202875498 },                 { 0.8922409354455803, 1.999119343923781 },                 { 3.396949764787055, 6.813170372579068 },                 { -2.057498232686068, -0.002522983830852255 },                 { 6.359932157365045, 8.343600029975851 },                 { 3.353102234276168, 7.087541882898689 },                 { -1.763877221595639, 0.9688890460330644 },                 { 6.151457185125111, 9.075011757431174 },                 { 4.281597398048899, 5.953270070976117 },                 { 3.549576703974894, 8.616038155992861 },                 { 6.004706732349854, 8.959423391087469 },                 { 2.802915014676262, 6.285676742173564 },                 { -0.6029879029880616, 1.083332958357485 },                 { 3.631827105398369, 6.743428504049444 },                 { 6.161125014007315, 9.60920569689001 },                 { -1.049582894255342, 0.2020017892080281 },                 { 3.910573022688315, 8.19609909534937 },                 { 8.180454017634863, 7.861055769719962 },                 { 1.488945440439716, 8.02699903761247 },                 { 4.813750847823778, 12.34416881332515 },                 { 0.0443208501259158, 5.901148093240691 },                 { 4.416417235068346, 4.465243084006094 },                 { 4.0002433603072, 6.721937850166174 },                 { 3.190113818788205, 10.51648348411058 },                 { 4.493600914967883, 7.938224231022314 },                 { -3.675669533266189, 4.472845076673303 },                 { 6.648645511703989, 12.03544085965724 },                 { -1.330031331404445, 1.33931042964811 },                 { -3.812111460708707, 2.50534195568356 },                 { 5.669339356648331, 6.214488981177026 },                 { 1.006596727153816, 1.51165463112716 },                 { 5.039466365033024, 7.476532610478689 },                 { 4.349091929968925, 7.446356406259756 },                 { -1.220289665119069, 3.403926955951437 },                 { 5.553003979122395, 6.886518211202239 },                 { 2.274487732222856, 7.009541508533196 },                 { 4.147567059965864, 7.34025244349202 },                 { 4.083882618965819, 6.362852861075623 },                 { 2.203122344647599, 7.260295257904624 },                 { -2.147497550770442, 1.262293431529498 },                 { 2.473700950426512, 6.558900135505638 },                 { 8.267081298847554, 12.10214104577748 },                 { 6.91977329776865, 9.91998488301285 },                 { 0.1680479852730894, 6.28286034168897 },                 { -1.268578659195158, 2.326711221485755 },                 { 1.829966451374701, 6.254187605304518 },                 { 5.648849025754848, 9.330002040750291 },                 { -2.302874793257666, 3.585545172776065 },                 { -2.629218791709046, 2.156215538500288 },                 { 4.036618140700114, 10.2962785719958 },                 { 0.4616386422783874, 0.6782756325806778 },                 { -0.3447896073408363, 0.4999834691645118 },                 { -0.475281453118318, 1.931470384180492 },                 { 2.382509690609731, 6.071782429815853 },                 { -3.203934441889096, 2.572079552602468 },                 { 8.465636032165087, 13.96462998683518 },                 { 2.36755660870416, 5.7844595007273 },                 { 0.5935496528993371, 1.374615871358943 },                 { -2.467481505748694, 2.097224634713005 },                 { 4.27867444328542, 10.24772361238549 },                 { -2.013791907543137, 2.013799426047639 },                 { 6.424588084404173, 9.185334939684516 },                 { -0.8448238876802175, 0.5447382022282812 },                 { 1.342955703473923, 8.645456317633556 },                 { 3.108712208751979, 8.512156853800064 },                 { 4.343205178315472, 8.056869549234374 },                 { -2.971767642212396, 3.201180146824761 },                 { 2.583820931523672, 5.459873414473854 },                 { 4.209139115268925, 8.171098193546225 },                 { 0.4064909057902746, 1.454390775518743 },                 { 3.068642411145223, 6.959485153620035 },                 { 6.085968972900461, 7.391429799500965 },                 { -1.342265795764202, 1.454550012997143 },                 { 6.249773274516883, 6.290269880772023 },                 { 4.986225847822566, 7.75266344868907 },                 { 7.642443254378944, 10.19914817500263 },                 { 6.438181159163673, 8.464396764810347 },                 { 2.520859761025108, 7.68222425260111 },                 { 2.883699944257541, 6.777960331348503 },                 { 2.788004550956599, 6.634735386652733 },                 { 3.331661231995638, 5.794191300046592 },                 { 3.526172276645504, 6.710802266815884 },                 { 3.188298528138741, 10.34495528210205 },                 { 0.7345539486114623, 5.807604004180681 },                 { 1.165044595880125, 7.830121829295257 },                 { 7.146962523500671, 11.62995162065415 },                 { 7.813872137162087, 10.62827008714735 },                 { 3.118099164870063, 8.286003148186371 },                 { -1.708739286262571, 1.561026755374264 },                 { 1.786163047580084, 4.172394388214604 },                 { 3.718506403232386, 7.807752990130349 },                 { 6.167414046828899, 10.01104941031293 },                 { -1.063477247689196, 1.61176085846339 },                 { -3.396739609433642, 0.7127911050002151 },                 { 2.438885945896797, 7.353011138689225 },                 { -0.2073204144780931, 0.850771146627012 }, };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;  import static org.junit.Assert.assertEquals;  import java.util.ArrayList; import java.util.List;  import org.apache.commons.statistics.distribution.ContinuousDistribution; import org.apache.commons.math4.exception.DimensionMismatchException; import org.apache.commons.math4.exception.MathArithmeticException; import org.apache.commons.math4.exception.NotANumberException; import org.apache.commons.math4.exception.NotFiniteNumberException; import org.apache.commons.math4.exception.NotPositiveException; import org.apache.commons.math4.util.FastMath; import org.apache.commons.math4.util.Pair; import org.apache.commons.rng.UniformRandomProvider; import org.apache.commons.rng.simple.RandomSource; import org.junit.Assert; import org.junit.Test;  /**  * Test class for {@link EnumeratedRealDistribution}.  *  */ public class EnumeratedRealDistributionTest {      /**      * The distribution object used for testing.      */     private final EnumeratedRealDistribution testDistribution;      /**      * Creates the default distribution object used for testing.      */     public EnumeratedRealDistributionTest() {         // Non-sorted singleton array with duplicates should be allowed.         // Values with zero-probability do not extend the support.         testDistribution = new EnumeratedRealDistribution(                 new double[]{3.0, -1.0, 3.0, 7.0, -2.0, 8.0},                 new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});     }      /**      * Tests if the {@link EnumeratedRealDistribution} constructor throws      * exceptions for invalid data.      */     @Test     public void testExceptions() {         EnumeratedRealDistribution invalid = null;         try {             invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0});             Assert.fail("Expected DimensionMismatchException");         } catch (DimensionMismatchException e) {         }         try{         invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, -1.0});             Assert.fail("Expected NotPositiveException");         } catch (NotPositiveException e) {         }         try {             invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, 0.0});             Assert.fail("Expected MathArithmeticException");         } catch (MathArithmeticException e) {         }         try {             invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.NaN});             Assert.fail("Expected NotANumberException");         } catch (NotANumberException e) {         }         try {             invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.POSITIVE_INFINITY});             Assert.fail("Expected NotFiniteNumberException");         } catch (NotFiniteNumberException e) {         }         Assert.assertNull("Expected non-initialized DiscreteRealDistribution", invalid);     }      /**      * Tests if the distribution returns proper probability values.      */     @Test     public void testProbability() {         double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};         double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};         for (int p = 0; p < points.length; p++) {             double density = testDistribution.probability(points[p]);             Assert.assertEquals(results[p], density, 0.0);         }     }      /**      * Tests if the distribution returns proper density values.      */     @Test     public void testDensity() {         double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};         double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};         for (int p = 0; p < points.length; p++) {             double density = testDistribution.density(points[p]);             Assert.assertEquals(results[p], density, 0.0);         }     }      /**      * Tests if the distribution returns proper cumulative probability values.      */     @Test     public void testCumulativeProbability() {         double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};         double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0};         for (int p = 0; p < points.length; p++) {             double probability = testDistribution.cumulativeProbability(points[p]);             Assert.assertEquals(results[p], probability, 1e-10);         }     }      /**      * Tests if the distribution returns proper mean value.      */     @Test     public void testGetNumericalMean() {         Assert.assertEquals(3.4, testDistribution.getMean(), 1e-10);     }      /**      * Tests if the distribution returns proper variance.      */     @Test     public void testGetNumericalVariance() {         Assert.assertEquals(7.84, testDistribution.getVariance(), 1e-10);     }      /**      * Tests if the distribution returns proper lower bound.      */     @Test     public void testGetSupportLowerBound() {         Assert.assertEquals(-1, testDistribution.getSupportLowerBound(), 0);     }      /**      * Tests if the distribution returns proper upper bound.      */     @Test     public void testGetSupportUpperBound() {         Assert.assertEquals(7, testDistribution.getSupportUpperBound(), 0);     }      /**      * Tests if the distribution returns properly that the support is connected.      */     @Test     public void testIsSupportConnected() {         Assert.assertTrue(testDistribution.isSupportConnected());     }      /**      * Tests sampling.      */     @Test     public void testSample() {         final int n = 1000000;         final ContinuousDistribution.Sampler sampler =             testDistribution.createSampler(RandomSource.create(RandomSource.WELL_1024_A, -123456789));         final double[] samples = AbstractRealDistribution.sample(n, sampler);         Assert.assertEquals(n, samples.length);         double sum = 0;         double sumOfSquares = 0;         for (int i = 0; i < samples.length; i++) {             sum += samples[i];             sumOfSquares += samples[i] * samples[i];         }         Assert.assertEquals(testDistribution.getMean(),                 sum / n, 1e-2);         Assert.assertEquals(testDistribution.getVariance(),                 sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2);     }      @Test     public void testIssue942() {         List<Pair<Object,Double>> list = new ArrayList<>();         list.add(new Pair<Object, Double>(new Object() {}, new Double(0)));         list.add(new Pair<Object, Double>(new Object() {}, new Double(1)));         final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_512_A);         Assert.assertEquals(1, new EnumeratedDistribution<>(list).createSampler(rng).sample(1).length);     }      @Test     public void testIssue1065() {         // Test Distribution for inverseCumulativeProbability         //         //         ^         //         |         // 1.000   +--------------------------------o===============         //         |                               3|         //         |                                |         //         |                             1o=         // 0.750   +-------------------------> o==  .         //         |                          3|  . .         //         |                   0       |  . .         // 0.5625  +---------------> o==o======   . .         //         |                 |  .      .  . .         //         |                 |  .      .  . .         //         |                5|  .      .  . .         //         |                 |  .      .  . .         //         |             o===   .      .  . .         //         |             |   .  .      .  . .         //         |            4|   .  .      .  . .         //         |             |   .  .      .  . .         // 0.000   +=============----+--+------+--+-+--------------->         //                      14  18 21     28 31 33         //         // sum  = 4+5+0+3+1+3 = 16          EnumeratedRealDistribution distribution = new EnumeratedRealDistribution(                 new double[] { 14.0, 18.0, 21.0, 28.0, 31.0, 33.0 },                 new double[] { 4.0 / 16.0, 5.0 / 16.0, 0.0 / 16.0, 3.0 / 16.0, 1.0 / 16.0, 3.0 / 16.0 });          assertEquals(14.0, distribution.inverseCumulativeProbability(0.0000), 0.0);         assertEquals(14.0, distribution.inverseCumulativeProbability(0.2500), 0.0);         assertEquals(33.0, distribution.inverseCumulativeProbability(1.0000), 0.0);          assertEquals(18.0, distribution.inverseCumulativeProbability(0.5000), 0.0);         assertEquals(18.0, distribution.inverseCumulativeProbability(0.5624), 0.0);         assertEquals(28.0, distribution.inverseCumulativeProbability(0.5626), 0.0);         assertEquals(31.0, distribution.inverseCumulativeProbability(0.7600), 0.0);         assertEquals(18.0, distribution.inverseCumulativeProbability(0.5625), 0.0);         assertEquals(28.0, distribution.inverseCumulativeProbability(0.7500), 0.0);     }      @Test     public void testCreateFromDoubles() {         final double[] data = new double[] {0, 1, 1, 2, 2, 2};         EnumeratedRealDistribution distribution = new EnumeratedRealDistribution(data);         assertEquals(0.5, distribution.probability(2), 0);         assertEquals(0.5, distribution.cumulativeProbability(1), 0);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.math4.distribution;  import org.apache.commons.math4.analysis.UnivariateFunction; import org.apache.commons.math4.analysis.integration.RombergIntegrator; import org.apache.commons.math4.analysis.integration.UnivariateIntegrator; import org.apache.commons.math4.exception.OutOfRangeException; import org.junit.Assert; import org.junit.Test;  /** Various tests related to MATH-699. */ public class AbstractRealDistributionTest {      @Test     public void testContinuous() {         final double x0 = 0.0;         final double x1 = 1.0;         final double x2 = 2.0;         final double x3 = 3.0;         final double p12 = 0.5;         final AbstractRealDistribution distribution;         distribution = new AbstractRealDistribution() {             private static final long serialVersionUID = 1L;              @Override             public double cumulativeProbability(final double x) {                 if ((x < x0) || (x > x3)) {                     throw new OutOfRangeException(x, x0, x3);                 }                 if (x <= x1) {                     return p12 * (x - x0) / (x1 - x0);                 } else if (x <= x2) {                     return p12;                 } else if (x <= x3) {                     return p12 + (1.0 - p12) * (x - x2) / (x3 - x2);                 }                 return 0.0;             }              @Override             public double density(final double x) {                 if ((x < x0) || (x > x3)) {                     throw new OutOfRangeException(x, x0, x3);                 }                 if (x <= x1) {                     return p12 / (x1 - x0);                 } else if (x <= x2) {                     return 0.0;                 } else if (x <= x3) {                     return (1.0 - p12) / (x3 - x2);                 }                 return 0.0;             }              @Override             public double getMean() {                 return ((x0 + x1) * p12 + (x2 + x3) * (1.0 - p12)) / 2.0;             }              @Override             public double getVariance() {                 final double meanX = getMean();                 final double meanX2;                 meanX2 = ((x0 * x0 + x0 * x1 + x1 * x1) * p12 + (x2 * x2 + x2                         * x3 + x3 * x3)                         * (1.0 - p12)) / 3.0;                 return meanX2 - meanX * meanX;             }              @Override             public double getSupportLowerBound() {                 return x0;             }              @Override             public double getSupportUpperBound() {                 return x3;             }              @Override             public boolean isSupportConnected() {                 return false;             }              @Override             public double probability(final double x) {                 throw new UnsupportedOperationException();             }         };         final double expected = x1;         final double actual = distribution.inverseCumulativeProbability(p12);         Assert.assertEquals("", expected, actual,                 distribution.getSolverAbsoluteAccuracy());     }      @Test     public void testDiscontinuous() {         final double x0 = 0.0;         final double x1 = 0.25;         final double x2 = 0.5;         final double x3 = 0.75;         final double x4 = 1.0;         final double p12 = 1.0 / 3.0;         final double p23 = 2.0 / 3.0;         final AbstractRealDistribution distribution;         distribution = new AbstractRealDistribution() {             private static final long serialVersionUID = 1L;              @Override             public double cumulativeProbability(final double x) {                 if ((x < x0) || (x > x4)) {                     throw new OutOfRangeException(x, x0, x4);                 }                 if (x <= x1) {                     return p12 * (x - x0) / (x1 - x0);                 } else if (x <= x2) {                     return p12;                 } else if (x <= x3) {                     return p23;                 } else {                     return (1.0 - p23) * (x - x3) / (x4 - x3) + p23;                 }             }              @Override             public double density(final double x) {                 if ((x < x0) || (x > x4)) {                     throw new OutOfRangeException(x, x0, x4);                 }                 if (x <= x1) {                     return p12 / (x1 - x0);                 } else if (x <= x2) {                     return 0.0;                 } else if (x <= x3) {                     return 0.0;                 } else {                     return (1.0 - p23) / (x4 - x3);                 }             }              @Override             public double getMean() {                 final UnivariateFunction f = new UnivariateFunction() {                      @Override                     public double value(final double x) {                         return x * density(x);                     }                 };                 final UnivariateIntegrator integrator = new RombergIntegrator();                 return integrator.integrate(Integer.MAX_VALUE, f, x0, x4);             }              @Override             public double getVariance() {                 final double meanX = getMean();                 final UnivariateFunction f = new UnivariateFunction() {                      @Override                     public double value(final double x) {                         return x * x * density(x);                     }                 };                 final UnivariateIntegrator integrator = new RombergIntegrator();                 final double meanX2 = integrator.integrate(Integer.MAX_VALUE,                         f, x0, x4);                 return meanX2 - meanX * meanX;             }              @Override             public double getSupportLowerBound() {                 return x0;             }              @Override             public double getSupportUpperBound() {                 return x4;             }              @Override             public boolean isSupportConnected() {                 return false;             }              @Override             public double probability(final double x) {                 throw new UnsupportedOperationException();             }         };         final double expected = x2;         final double actual = distribution.inverseCumulativeProbability(p23);         Assert.assertEquals("", expected, actual,                 distribution.getSolverAbsoluteAccuracy());      } } 
